/*===========================================================================

                         Q M I _ N A S . C

DESCRIPTION

 The Qualcomm Network Access Services MSM Interface source file.

EXTERNALIZED FUNCTIONS

  qmi_nas_init()
    Register the Network Access Service with QMUX for all applicable QMI links.

  qmi_nas_gen_serving_system_ind_cb()
    Call back function called when the serving system changes.

  qmi_nas_rssi_change_cb()
    Callback to be called when signal strength changes.

Copyright (c) 2004-2015 QUALCOMM Technologies Incorporated.
All Rights Reserved.
Qualcomm Confidential and Proprietary.
===========================================================================*/
/*===========================================================================

                      EDIT HISTORY FOR FILE

  $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/mmcp/mmode/qmi/src/qmi_nas.c#1 $ $DateTime: 2016/12/13 08:00:05 $ $Author: mplcsds1 $

when        who    what, where, why
--------    ---    ----------------------------------------------------------

05/15/12    aa     Centralized EONS support status message
06/21/10    kk     Fix to check UIM status before posting commands to MMGSDI.
11/10/09    jee    Changes to support MMGSDI re-architecture
10/22/09    kk     Windows7 compliance - WDS changes and BER/PER/FER support.
10/16/09    kk     Windows7 compliance - new messages and ATCoP dependencies.
10/09/09    kk     Windows7 compliance - NAS changes.
04/13/09    rt     Fixed the issue of array bound overflow if PLMN list is
                   large.
02/19/09    am     DS Task De-coupling effort and introduction of DCC task.
09/21/06    ks     Fix qmi_nasi_get_client_sp_by_clid() to return cl_sp for
                   correct NAS instance.
08/23/06    ks     Changes to support multiple qmi/rmnet instances.
07/20/06    ks     Fixed a bug in NAS ABORT request.
07/11/06    ks     Fixed potential memory leak, change to use dsi_get_nv_item
07/10/06    ks     Fixed error in passing result and error code for some msgs
07/06/06    ks     Major clean up
07/06/06    ks     Changed implementation of signal strength reporting.
05/01/06    ks     Updated Attach and Register commands.
04/18/06    ks     Added support for Aborting NAS commands.
03/22/06    ks     Changed QMI_ERR_IN_USE to QMI_ERR_DEVICE_IN_USE.
03/13/06    ks     Changed parsing of requests to return error for fixed
                   length tlvs when tlv lengh passed is incorrect.
03/13/06    ks     Changed QMI_ERR_INVALID_ARG to QMI_ERR_MALFORMED_MSG.
                   Added reporting of some new error codes.
03/07/06    ks     Removed De-register support. Populating in_use bit in
                   network_scan status.
03/06/06    ks     Returning QMI_ERR_INVALID_ARG if a malformed TLV is
                   received.
12/11/05    jd     Support message bundling, remove command buffers from
                   pending queues upon client reset.
09/15/05    ks     Corrected type of TLV in Network_scan response.
09/15/05    ks     Fixes in perform_network_register().
09/09/05    ks     Fixed some async transaction stuff.
09/08/05    ks     Added support for more QMI_NAS messages.
08/15/05    ks     Return error when all optional TLVs are absent for messages
                   which don't have any mandatory TLVs.
06/27/05    jd     Removed nasi_get_version, fixed message numbering
05/13/05   ks/jd   Created module
===========================================================================*/

/*===========================================================================

                          INCLUDE FILES FOR MODULE

===========================================================================*/

#include "mmcp_variation.h"
#include "comdef.h"
#include "customer.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stringl/stringl.h>
#include "dsm.h"
#include "ps_byte.h"
#include "ps_in.h"
#include "sys.h"
#include "cm.h"
#ifdef FEATURE_DUAL_SIM
#include  "cm_dualsim.h"
#endif /*FEATURE_DUAL_SIM*/
#include "mcfg_fs.h"

#include "auth.h"

#ifdef FEATURE_CMI
#include "sys_v.h"
#endif

#include "nv.h"
#include "rex.h"

#include "qmi_svc_utils.h"
#include "qmi_nas.h"
#include "ds_qmi_defs.h"

#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
#include "mmgsdilib.h"
#include "mmgsdisessionlib.h"
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */
#endif /* FEATURE_MMGSDI_SESSION_LIB */

/* This is a temporary include, until the ATCoP team moves the required
 * APIs to dsat.h */

#include "qmi_nas_msg.h"
//#include "qmi_nas_mmgsdi.h"

#ifdef FEATURE_HDR
#include "ds_sys_conf.h"
#endif

#include "qmi_nas_utils.h"
#include "qmi_nas_internal.h"
#include "time_genoff.h"

#include "qmi_nas_hdr.h"
#include "cm_v.h" // CM APIs
#include "mccdma_v.h"

#include "qmi_svc_utils.h"
#include "qmi_framework.h"
#include "qmi_mmode_task_cmd.h"
#include "modem_mem.h"
#include "qmi_mmode_svc.h"

#include "qmi_idl_lib.h"
#include "network_access_service_v01.h"
#include "network_access_service_impl_v01.h"

#ifdef FEATURE_TDSCDMA
#include "tds_rrc_msg.h"
#endif


#include "lte_cphy_rssi_msg.h"

#include "lte_rrc_ext_msg.h"
#include "geran_grr_msg.h"

#include "cm_msgr_msg.h"

#include "qm_comdef.h"
#include "qm_cbpq.h"
#include "qm_si.h"
#include "qm_nas_clnt.h"
#include "qm_util.h"
#include "qm_meas.h"
#include "qm_tib.h"
#include "qm_mstats.h"
#include "qm_efs.h"
#include "lte_rrc_ext_msg.h"
#include "wcdma_rrc_msg.h"
#include "policyman.h"

#ifdef FEATURE_MODEM_CONFIG_REFRESH
#include "mcfg_refresh.h"
#endif // FEATURE_MODEM_CONFIG_REFRESH

/*===========================================================================

                               DEFINITIONS

===========================================================================*/

/*---------------------------------------------------------------------------
  Service management
---------------------------------------------------------------------------*/
#define NASI_CLID_UNUSED (0)

/*---------------------------------------------------------------------------
  Major and Minor Version Nos for NAS
---------------------------------------------------------------------------*/
#define NASI_BASE_VER_MAJOR  (1)
#define NASI_BASE_VER_MINOR  (25)

#define NASI_ADDENDUM_VER_MAJOR  (0)
#define NASI_ADDENDUM_VER_MINOR  (0)

/*---------------------------------------------------------------------------
  Message-internal TLV type field values
---------------------------------------------------------------------------*/
#define NASI_PARAM_TYPE_MANUAL_REGISTER                   (0x10)
#define NASI_PARAM_TYPE_3GPP_NETWORK_SCAN                 (0x10)
#define NASI_PARAM_TYPE_3GPP_NETWORK_SCAN_RAT             (0x11)
#define NASI_PARAM_TYPE_3GPP_PREF_NETWORKS                (0x10)
#define NASI_PARAM_TYPE_3GPP_STATIC_PREF_NETWORKS         (0x11)
#define NASI_PARAM_TYPE_3GPP_PREF_NETWORKS_MNC_PCS        (0x12)
#define NASI_PARAM_TYPE_3GPP_STATIC_PREF_NETWORKS_MNC_PCS (0x13)
#define NASI_PARAM_TYPE_SET_PREF_NETWORKS                 (0x10)
#define NASI_PARAM_TYPE_SET_PREF_NETWORKS_MNC_PCS         (0x11)
#define NASI_PARAM_TYPE_SET_PREF_NETWORKS_CLEAR_PREV      (0x12)
#define NASI_PARAM_TYPE_GET_FORB_NETWORKS                 (0x10)
#define NASI_PARAM_TYPE_SET_FORB_NETWORKS                 (0x10)

#define NASI_SIG_STRENGTH_INACTIVE_RSSI                   (255)
#define NASI_SIG_STRENGTH_INACTIVE_IO                     (9999)
#define NASI_SIG_STRENGTH_INACTIVE_ECIO                   (9999)
#define NASI_SIG_STRENGTH_INACTIVE_SINR                   (255)
#define NASI_SIG_STRENGTH_INACTIVE_RSRP                   (9999)
#define NASI_SIG_STRENGTH_INACTIVE_RSRQ                   (127)
#define NASI_LTE_SNR_STRENGTH_INACTIVE                    (255)
#define NASI_AUTOMATIC_REGISTER                           (0x01)
#define NASI_MANUAL_REGISTER                              (0x02)

#define NASI_PLMN_STATUS_CURRENT_MASK        (0x01)
#define NASI_PLMN_STATUS_AVAILABLE_MASK      (0x02)
#define NASI_PLMN_STATUS_HOME_MASK           (0x04)
#define NASI_PLMN_STATUS_ROAM_MASK           (0x08)
#define NASI_PLMN_STATUS_FORBIDDEN_MASK      (0x10)
#define NASI_PLMN_STATUS_NOT_FORBIDDEN_MASK  (0x20)
#define NASI_PLMN_STATUS_PREFERRED_MASK      (0x40)
#define NASI_PLMN_STATUS_NOT_PREFERRED_MASK  (0x80)

#define NASI_PARAM_PLMN_INFO_MAX_SIZE     (270)

/*---------------------------------------------------------------------------
  Max length of network name
---------------------------------------------------------------------------*/
#define NASI_SIG_STRENGTH_DELTA_NO_CHANGE        ((uint8)-1)

#define NASI_DEFAULT_RSSI_DELTA     5 /* Default RSSI delta change threshold
                                      ** for SIGNAL STRENGTH reporting
                                      */

#define NASI_DEFAULT_IO_DELTA      5 /* Default IO delta change threshold
                                      ** for SIGNAL STRENGTH reporting
                                      */
#define NASI_DEFAULT_RSRQ_DELTA    5 /* Default RSRQ delta change threshold */
#define NASI_DEFAULT_RSRP_DELTA    1 /* Default RSRQ delta change threshold */
#define NASI_MIN_SINR_DELTA        1 /* Minimum delta threshold for SINR */
#define NASI_MIN_ECIO_DELTA        1 /* Minimum delta threshold for ECIO */
#define NASI_MIN_SIG_INFO_DELTA    1 /* Minimum delta threshold for ECIO */
#define NASI_DISABLE_LTE_DURATION_MIN_VALUE       720    /* Minimum LTE disable duration */

/*---------------------------------------------------------------------------
  Event Reporting Mode
---------------------------------------------------------------------------*/
#define NASI_EVENT_REPORT_MODE_DELTA     0x00
#define NASI_EVENT_REPORT_MODE_THRESHOLD 0x01

#define NASI_PRL_WILDCARD_SID 0x0000
#define NASI_PRL_WILDCARD_NID 0xFFFF

/*---------------------------------------------------------------------------
  Macro used in command handlers (common)
---------------------------------------------------------------------------*/
#define CHECK_RETVAL()  if (FALSE == retval) { dsm_free_packet(&response); \
                                               return NULL; }

// Event registration check helper
#define REGISTERED(cl_sp, event) ( cl_sp->report_status.report_##event == TRUE )

/*---------------------------------------------------------------------------
  Other Macros used in command handlers (common)
---------------------------------------------------------------------------*/
#define TARGET_SUPPORTS_GSM   (qmi_nasi_global.cm_ph_info.mode_capability & SYS_SYS_MODE_MASK_GSM  )
#define TARGET_SUPPORTS_WCDMA (qmi_nasi_global.cm_ph_info.mode_capability & SYS_SYS_MODE_MASK_WCDMA)
#define TARGET_SUPPORTS_CDMA  (qmi_nasi_global.cm_ph_info.mode_capability & SYS_SYS_MODE_MASK_CDMA )
#define TARGET_SUPPORTS_HDR   (qmi_nasi_global.cm_ph_info.mode_capability & SYS_SYS_MODE_MASK_HDR  )
#define TARGET_SUPPORTS_LTE   (qmi_nasi_global.cm_ph_info.mode_capability & SYS_SYS_MODE_MASK_LTE  )
#define TARGET_SUPPORTS_TDS   (qmi_nasi_global.cm_ph_info.mode_capability & SYS_SYS_MODE_MASK_TDS  )

#define QMI_NAS_6BIT_2_8BIT(a)  (int8)(((a)&0x20) ? ((a)|0xC0) : ((a)&0x3F)) // convert 6bit 2's complement integer to 8bit 2's complement integer

#define IS_TAC_VALID(X)  ( (X) != 0xFFFE && (X) != 0 )
/*---------------------------------------------------------------------------
  EFS File for persistent NITZ caching
---------------------------------------------------------------------------*/
#define MMGSDI_EFS_NITZ_PLMN_INFO "/nv/item_files/modem/uim/mmgsdi/eons/rplmn_info"

//Periodic CSG Configuration
#define QMI_NAS_TUI_CSG_CONFIG_EFS_FILE "/nv/item_files/modem/mmode/tui/csg_search_sel_config"


//Invalid SSAC Barring time in LTE Service Indication
#define QMI_NAS_SSAC_INVALID_BARR_TIME  20

/*===========================================================================

                                DATA TYPES

===========================================================================*/

/*---------------------------------------------------------------------------
  Type of core network which the mobile is registered on
---------------------------------------------------------------------------*/
typedef enum
{
  NASI_REG_NET_UNKNOWN   = 0x00,   /* the mobile is not registered */
  NASI_REG_NET_3GPP2     = 0x01,   /* 3GPP2 network */
  NASI_REG_NET_3GPP      = 0x02    /* 3GPP network */
} qmi_nasi_reg_net_e_type;

/*---------------------------------------------------------------------------
  CS Attach enum type
---------------------------------------------------------------------------*/
typedef enum
{
  NASI_CS_UNKNOWN   = 0x00,   /* the mobile is not attached */
  NASI_CS_ATTACHED  = 0x01,
  NASI_CS_DETACHED  = 0x02
} qmi_nasi_cs_attach_e_type;

typedef enum
{
  NASI_MODE_EMERGENCY_MODE_OFF     = 0x00,
  NASI_MODE_EMERGENCY_MODE_ON      = 0x01
} qmi_nasi_emergency_mode_e_type;

/*---------------------------------------------------------------------------
  Enum for Mode preference Bitmask
  Bit 0 : cdma2000 1X
  Bit 1 : cdma2000 HRPD (1xEV-DO)
  Bit 2 : GSM
  Bit 3 : UMTS
  Bit 4 : LTE
---------------------------------------------------------------------------*/
#define QMI_NAS_MODE_PREF_BIT_CDMA   0x0001
#define QMI_NAS_MODE_PREF_BIT_HDR    0x0002
#define QMI_NAS_MODE_PREF_BIT_GSM    0x0004
#define QMI_NAS_MODE_PREF_BIT_UMTS   0x0008
#define QMI_NAS_MODE_PREF_BIT_LTE    0x0010
#define QMI_NAS_MODE_PREF_BIT_TDS    0x0020
#define QMI_NAS_MODE_PREF_BIT_ALL    0x003F

// list of supported mode pref in CM
// CHGW only supported in non-LTE targets for now
#define QMI_NAS_MODE_PREF_NONE  (0x0000)
#define QMI_NAS_MODE_PREF_C     (QMI_NAS_MODE_PREF_BIT_CDMA)
#define QMI_NAS_MODE_PREF_H     (QMI_NAS_MODE_PREF_BIT_HDR)
#define QMI_NAS_MODE_PREF_CH    (QMI_NAS_MODE_PREF_BIT_CDMA|QMI_NAS_MODE_PREF_H)
#define QMI_NAS_MODE_PREF_G     (QMI_NAS_MODE_PREF_BIT_GSM)
#define QMI_NAS_MODE_PREF_W     (QMI_NAS_MODE_PREF_BIT_UMTS)
#define QMI_NAS_MODE_PREF_GW    (QMI_NAS_MODE_PREF_BIT_GSM|QMI_NAS_MODE_PREF_BIT_UMTS)
#define QMI_NAS_MODE_PREF_CGW   (QMI_NAS_MODE_PREF_BIT_CDMA|QMI_NAS_MODE_PREF_GW)
#define QMI_NAS_MODE_PREF_CHGW  (QMI_NAS_MODE_PREF_BIT_HDR|QMI_NAS_MODE_PREF_CGW)
#define QMI_NAS_MODE_PREF_L     (QMI_NAS_MODE_PREF_BIT_LTE)
#define QMI_NAS_MODE_PREF_GWL   (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_GW)
#define QMI_NAS_MODE_PREF_CHGWL (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_CHGW)
#define QMI_NAS_MODE_PREF_HL    (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_BIT_HDR)
#define QMI_NAS_MODE_PREF_CHL   (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_CH)
#define QMI_NAS_MODE_PREF_CL    (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_BIT_CDMA)
#define QMI_NAS_MODE_PREF_GL    (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_BIT_GSM)
#define QMI_NAS_MODE_PREF_CGL   (QMI_NAS_MODE_PREF_BIT_CDMA|QMI_NAS_MODE_PREF_GL)
#define QMI_NAS_MODE_PREF_HGL   (QMI_NAS_MODE_PREF_BIT_HDR|QMI_NAS_MODE_PREF_GL)
#define QMI_NAS_MODE_PREF_WL    (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_BIT_UMTS)
#define QMI_NAS_MODE_PREF_CWL   (QMI_NAS_MODE_PREF_BIT_CDMA|QMI_NAS_MODE_PREF_WL)
#define QMI_NAS_MODE_PREF_HWL   (QMI_NAS_MODE_PREF_BIT_HDR|QMI_NAS_MODE_PREF_WL)
#define QMI_NAS_MODE_PREF_T     (QMI_NAS_MODE_PREF_BIT_TDS)
#define QMI_NAS_MODE_PREF_GT    (QMI_NAS_MODE_PREF_BIT_TDS|QMI_NAS_MODE_PREF_BIT_GSM)
#define QMI_NAS_MODE_PREF_CHG   (QMI_NAS_MODE_PREF_CH|QMI_NAS_MODE_PREF_G)
#define QMI_NAS_MODE_PREF_CG    (QMI_NAS_MODE_PREF_BIT_CDMA|QMI_NAS_MODE_PREF_BIT_GSM)
#define QMI_NAS_MODE_PREF_TGWL  (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_GWL)
#define QMI_NAS_MODE_PREF_TGW   (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_GW)
#define QMI_NAS_MODE_PREF_TCHGWL (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_CHGWL)
#define QMI_NAS_MODE_PREF_TL    (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_BIT_LTE)
#define QMI_NAS_MODE_PREF_TGL   (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_GL)
#define QMI_NAS_MODE_PREF_TW    (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_BIT_UMTS)
#define QMI_NAS_MODE_PREF_TWL   (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_WL)
#define QMI_NAS_MODE_PREF_TCHGL (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_CHG|QMI_NAS_MODE_PREF_L)
#define QMI_NAS_MODE_PREF_TCHGW (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_CHGW)
#define QMI_NAS_MODE_PREF_TCGW  (QMI_NAS_MODE_PREF_T|QMI_NAS_MODE_PREF_CGW)
#define QMI_NAS_MODE_PREF_CHGL   (QMI_NAS_MODE_PREF_CHG|QMI_NAS_MODE_PREF_BIT_LTE)
#define QMI_NAS_MODE_PREF_CGWL   (QMI_NAS_MODE_PREF_CGW|QMI_NAS_MODE_PREF_BIT_LTE)
#define QMI_NAS_MODE_PREF_HTW    (QMI_NAS_MODE_PREF_BIT_HDR|QMI_NAS_MODE_PREF_TW)
#define QMI_NAS_MODE_PREF_HTWL   (QMI_NAS_MODE_PREF_BIT_LTE|QMI_NAS_MODE_PREF_HTW)

struct qmi_nas_nv_mode_pref_s {
  uint16            qmi_val;
  nv_mode_enum_type nv_val;
};

const struct qmi_nas_nv_mode_pref_s qmi_nas_allowed_nv_mode_pref[] = {
  { QMI_NAS_MODE_PREF_C,     NV_MODE_CDMA_ONLY             },
  { QMI_NAS_MODE_PREF_H,     NV_MODE_HDR_ONLY              },
  { QMI_NAS_MODE_PREF_CH,    NV_MODE_CDMA_HDR_ONLY         },
  { QMI_NAS_MODE_PREF_G,     NV_MODE_GSM_ONLY              },
  { QMI_NAS_MODE_PREF_W,     NV_MODE_WCDMA_ONLY            },
  { QMI_NAS_MODE_PREF_GW,    NV_MODE_GSM_WCDMA_ONLY        },
  { QMI_NAS_MODE_PREF_L,     NV_MODE_LTE_ONLY}
};

/*---------------------------------------------------------------------------
  QMI NAS network type to mode pref
---------------------------------------------------------------------------*/
struct qmi_nas_network_to_mode_pref_s {
  uint8               network_type;
  cm_mode_pref_e_type cm_val;
};

const struct qmi_nas_network_to_mode_pref_s qmi_nas_allowed_network_types[] = {
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_WCDMA_ONLY_V01|NAS_NETWORK_TYPE_LTE_ONLY_V01), CM_MODE_PREF_GWL },
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_WCDMA_ONLY_V01), CM_MODE_PREF_GSM_WCDMA_ONLY },
  { NAS_NETWORK_TYPE_GSM_ONLY_V01, CM_MODE_PREF_GSM_ONLY },
  { NAS_NETWORK_TYPE_WCDMA_ONLY_V01, CM_MODE_PREF_WCDMA_ONLY },
  { NAS_NETWORK_TYPE_LTE_ONLY_V01, CM_MODE_PREF_LTE_ONLY },
  { NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01, CM_MODE_PREF_TDS_ONLY},
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_LTE_ONLY_V01), CM_MODE_PREF_GSM_LTE },
  { (NAS_NETWORK_TYPE_WCDMA_ONLY_V01|NAS_NETWORK_TYPE_LTE_ONLY_V01), CM_MODE_PREF_WCDMA_LTE },
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_GSM },
  { (NAS_NETWORK_TYPE_WCDMA_ONLY_V01|NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_WCDMA },
  { (NAS_NETWORK_TYPE_LTE_ONLY_V01|NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_LTE },
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_WCDMA_ONLY_V01|NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_GSM_WCDMA },
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_LTE_ONLY_V01|NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_GSM_LTE },
  { (NAS_NETWORK_TYPE_GSM_ONLY_V01|NAS_NETWORK_TYPE_WCDMA_ONLY_V01|NAS_NETWORK_TYPE_LTE_ONLY_V01|NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_GSM_WCDMA_LTE },
  { (NAS_NETWORK_TYPE_WCDMA_ONLY_V01 | NAS_NETWORK_TYPE_LTE_ONLY_V01 | NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01), CM_MODE_PREF_TDS_WCDMA_LTE }
};

/*---------------------------------------------------------------------------
  NAS Command enum type - not equal to the actual command values!
  mapping is in qmi_nas_cmd_callbacks table

  DO NOT REORDER THIS ENUM!  (make sure the command value here = index into
  qmi_nasi_cmd_callbacks table for corresponding command)
---------------------------------------------------------------------------*/
typedef enum
{
  NASI_CMD_MIN                         = 0,
  NASI_CMD_RESET                       = NASI_CMD_MIN,
  NASI_CMD_ABORT,
  NASI_CMD_SET_EVENT_REPORT,
  NASI_CMD_INDICATION_REGISTER,
  NASI_CMD_GET_SIGNAL_STRENGTH,
  NASI_CMD_PERFORM_NETWORK_SCAN,
  NASI_CMD_INITIATE_NETWORK_REGISTER,
  NASI_CMD_INITIATE_ATTACH,
  NASI_CMD_GET_SERVING_SYSTEM,
  NASI_CMD_GET_HOME_NETWORK,
  NASI_CMD_GET_PREFERRED_NETWORKS,
  NASI_CMD_SET_PREFERRED_NETWORKS,
  NASI_CMD_GET_FORBIDDEN_NETWORKS,
  NASI_CMD_SET_FORBIDDEN_NETWORKS,
  NASI_CMD_SET_TECHNOLOGY_PREFERENCE,
  NASI_CMD_GET_TECHNOLOGY_PREFERENCE,
  NASI_CMD_GET_ACCOLC,
  NASI_CMD_SET_ACCOLC,
  NASI_CMD_GET_SYSTEM_PREFERENCE,
  NASI_CMD_GET_DEVICE_CONFIG,
  NASI_CMD_SET_DEVICE_CONFIG,
  NASI_CMD_GET_RF_BAND_INFO,
  NASI_CMD_GET_AN_AAA_STATUS,
  NASI_CMD_SET_SYS_SEL_PREF,
  NASI_CMD_GET_SYS_SEL_PREF,
  NASI_CMD_SET_DDTM_PREFERENCE,
  NASI_CMD_GET_OPERATOR_NAME_DATA,
  NASI_CMD_GET_CSP_PLMN_MODE_BIT,
  NASI_CMD_UPDATE_AKEY,
  NASI_CMD_GET_3GPP2_SUBSCRIPTION_INFO,
  NASI_CMD_SET_3GPP2_SUBSCRIPTION_INFO,
  NASI_CMD_GET_MOB_CAI_REV,
  NASI_CMD_GET_RTRE_CONFIG,
  NASI_CMD_SET_RTRE_CONFIG,
  NASI_CMD_GET_CELL_LOCATION_INFO,
  NASI_CMD_GET_PLMN_NAME,
  NASI_CMD_BIND_SUBSCRIPTION,
  NASI_CMD_GET_MODE_PREF,
  NASI_CMD_SET_DUAL_STANDBY_PREF_NEW,
  NASI_CMD_GET_SYS_INFO,
  NASI_CMD_GET_SIG_INFO,
  NASI_CMD_CONFIG_SIG_INFO,
  NASI_CMD_GET_ERR_RATE,
  NASI_CMD_GET_HDR_SUBTYPE,
  NASI_CMD_GET_HDR_COLOR_CODE,
  NASI_CMD_GET_CURRENT_ACQ_SYS_MODE,
  NASI_CMD_SET_RX_DIVERSITY,
  NASI_CMD_GET_TX_RX_INFO,
  NASI_CMD_UPDATE_AKEY_EXT,
  NASI_CMD_GET_DUAL_STANDBY_PREF,
  NASI_CMD_DETACH_LTE,
  NASI_CMD_BLOCK_LTE_PLMN,
  NASI_CMD_UNBLOCK_LTE_PLMN,
  NASI_CMD_RESET_LTE_PLMN_BLOCKING,
  NASI_CMD_CONFIG_EMBMS,
  NASI_CMD_GET_EMBMS_STATUS,
  NASI_CMD_GET_CDMA_POSITION_INFO,
  NASI_CMD_FORCE_NETWORK_SEARCH,
  NASI_CMD_GET_MANAGED_ROAMING_CONFIG,
  NASI_CMD_GET_CENTRALIZED_EONS_SUPPORT_STATUS,
  NASI_CMD_CONFIG_SIG_INFO2,
  NASI_CMD_GET_TDS_CELL_AND_POSITION_INFO,
  NASI_CMD_SET_HPLMN_IRAT_SEARCH_TIMER,
  NASI_CMD_GET_EMBMS_SIG,
  NASI_CMD_LIMIT_SYS_INFO_IND_REPORTING,
  NASI_CMD_GET_SYS_INFO_IND_REPORTING_LIMIT,
  NASI_CMD_UPDATE_IMS_STATUS,
  NASI_CMD_GET_IMS_PREF_STATUS,
  NASI_CMD_IMS_PREF_STATUS_IND,
  NASI_CMD_CONFIG_PLMN_NAME_IND_REPORTING,
  NASI_CMD_CDMA_AVOID_SYSTEM,
  NASI_CMD_GET_CDMA_AVOID_SYSTEM_LIST,
  NASI_CMD_SET_HPLMN_SEARCH_TIMER,
  NASI_CMD_GET_HPLMN_SEARCH_TIMER,
  NASI_CMD_SET_BUILTIN_PLMN_LIST,
  NASI_CMD_SET_E911_STATE,
  NASI_CMD_E911_STATE_READY_IND,
  NASI_CMD_GET_LTE_SIB16_NETWORK_TIME,
  NASI_CMD_LTE_SIB16_NETWORK_TIME_IND,
  NASI_CMD_SET_LTE_BAND_PRIORITY,
  NASI_CMD_GET_EMBMS_SIG_EXT,
  NASI_CMD_LTE_CPHY_CA_IND,
  NASI_CMD_GET_SUBSCRIPTION_INFO,
  NASI_CMD_PERFORM_INCREMENTAL_NETWORK_SCAN,
  NASI_CMD_GET_NETWORK_TIME,
  NASI_CMD_SUBSCRIPTION_CHANGE_IND,
  NASI_CMD_IMS_DEREGISTRATION,
  NASI_CMD_SET_DRX,
  NASI_CMD_GET_DRX,
  NASI_CMD_SET_CELL_LOCK_CONFIG,
  NASI_CMD_CSG_SEARCH_SELECTION_CONFIG,
  NASI_CMD_CSG_IMMEDIATE_SEARCH_SELECTION,
  NASI_CMD_GET_CSG_SEARCH_SELECTION_CONFIG,
  NASI_CMD_SSAC_INFO_IND,
  NASI_CMD_SSAC_CHANGE_INFO_IND,
  NASI_CMD_GET_SSAC_INFO,
  NASI_CMD_GET_SERVING_CELL_SIB,
  NASI_CMD_SET_PERIODIC_SEARCH_ALLOWED,
  NASI_CMD_GET_ACB_INFO,
  NASI_CMD_SET_DATA_SUBS_PRIORITY,
  NASI_CMD_GET_DATA_SUBS_PRIORITY,
  NASI_CMD_DATA_SUBS_PRIORITY_IND,
  NASI_CMD_SET_DATA_ROAMING_STATUS,
  NASI_CMD_GET_DATA_ROAMING_STATUS,
  NASI_CMD_SET_SRVCC,
  NASI_SET_BSR_TIMER,
  NASI_GET_BSR_TIMER,
  NASI_CMD_AVOID_TUNEAWAY,
  NASI_CMD_T3346_TIMER_STATUS_CHANGE_IND,
  NASI_CMD_SET_MCC,
  NASI_CMD_SET_DRX_SCALING_FACTOR,
  NASI_CMD_CALL_MODE_IND,
  NASI_CMD_GET_CALL_MODE,
  NASI_CMD_VOLTE_STATE_NOTIFICATION,
  NASI_CMD_IMS_CALL_STATE_NOTIFICATION,
  NASI_CMD_SET_RPM_PARAMETERS,
  NASI_CMD_GET_RPM_PARAMETERS,
  NASI_CMD_SET_RPM_STATE,
  NASI_CMD_MAX,
  NASI_CMD_WIDTH                       = 0xFFFF

} qmi_nasi_cmd_e_type;

typedef enum
{
  NASI_CMD_VAL_RESET                      = 0x0000,
  NASI_CMD_VAL_ABORT                      = 0x0001,
  NASI_CMD_VAL_SET_EVENT_REPORT           = 0x0002,
  NASI_CMD_VAL_INDICATION_REGISTER        = 0x0003,
  NASI_CMD_VAL_GET_SIGNAL_STRENGTH        = 0x0020,
  NASI_CMD_VAL_PERFORM_NETWORK_SCAN       = 0x0021,
  NASI_CMD_VAL_INITIATE_NETWORK_REGISTER  = 0x0022,
  NASI_CMD_VAL_INITIATE_ATTACH            = 0x0023,
  NASI_CMD_VAL_GET_SERVING_SYSTEM         = 0x0024,
  NASI_CMD_VAL_GET_HOME_NETWORK           = 0x0025,
  NASI_CMD_VAL_GET_PREFERRED_NETWORKS     = 0x0026,
  NASI_CMD_VAL_SET_PREFERRED_NETWORKS     = 0x0027,
  NASI_CMD_VAL_GET_FORBIDDEN_NETWORKS     = 0x0028,
  NASI_CMD_VAL_SET_FORBIDDEN_NETWORKS     = 0x0029,
  NASI_CMD_VAL_SET_TECHNOLOGY_PREFERENCE  = 0x002A,
  NASI_CMD_VAL_GET_TECHNOLOGY_PREFERENCE  = 0x002B,
  NASI_CMD_VAL_GET_ACCOLC                 = 0x002C,
  NASI_CMD_VAL_SET_ACCOLC                 = 0x002D,
  NASI_CMD_VAL_GET_SYSTEM_PREFERENCE      = 0x002E,
  NASI_CMD_VAL_GET_DEVICE_CONFIG          = 0x002F,
  NASI_CMD_VAL_SET_DEVICE_CONFIG          = 0x0030,
  NASI_CMD_VAL_GET_RF_BAND_INFO           = 0x0031,
  NASI_CMD_VAL_GET_AN_AAA_STATUS          = 0x0032,
  NASI_CMD_VAL_SET_SYS_SEL_PREF           = 0x0033,
  NASI_CMD_VAL_GET_SYS_SEL_PREF           = 0x0034,
  NASI_CMD_VAL_SET_NAM                    = 0x0035,
  NASI_CMD_VAL_GET_NAM                    = 0x0036,
  NASI_CMD_VAL_SET_DDTM_PREFERENCE        = 0x0037,
  NASI_CMD_VAL_DDTM_IND                   = 0x0038,
  NASI_CMD_VAL_GET_OPERATOR_NAME_DATA     = 0x0039,
  NASI_CMD_VAL_OPERATOR_NAME_DATA_IND     = 0x003A,
  NASI_CMD_VAL_GET_CSP_PLMN_MODE_BIT      = 0x003B,
  NASI_CMD_VAL_CSP_PLMN_MODE_BIT_IND      = 0x003C,
  NASI_CMD_VAL_UPDATE_AKEY                = 0x003D,
  NASI_CMD_VAL_GET_3GPP2_SUBSCRIPTION_INFO = 0x003E,
  NASI_CMD_VAL_SET_3GPP2_SUBSCRIPTION_INFO = 0x003F,
  NASI_CMD_VAL_GET_MOB_CAI_REV            = 0x0040,
  NASI_CMD_VAL_GET_RTRE_CONFIG            = 0x0041,
  NASI_CMD_VAL_SET_RTRE_CONFIG            = 0x0042,
  NASI_CMD_VAL_GET_CELL_LOCATION_INFO     = 0x0043,
  NASI_CMD_VAL_GET_PLMN_NAME              = 0x0044,
  NASI_CMD_VAL_BIND_SUBSCRIPTION          = 0x0045,
  NASI_CMD_VAL_MANAGED_ROAMING_IND        = 0x0046,
  NASI_CMD_VAL_DUAL_STANDBY_PREF_IND      = 0x0047,
  NASI_CMD_VAL_SUBSCRIPTION_INFO_IND      = 0x0048,
  NASI_CMD_VAL_GET_MODE_PREF              = 0x0049,
  NASI_CMD_VAL_THERMAL_EMERGENCY_STATE_IND= 0x004A,
  NASI_CMD_VAL_SET_DUAL_STANDBY_PREF_NEW  = 0x004B,
  NASI_CMD_VAL_NETWORK_TIME_IND           = 0x004C,
  NASI_CMD_VAL_GET_SYS_INFO               = 0x004D,
  NASI_CMD_VAL_SYS_INFO_IND               = 0x004E,
  NASI_CMD_VAL_GET_SIG_INFO               = 0x004F,
  NASI_CMD_VAL_CONFIG_SIG_INFO            = 0x0050,
  NASI_CMD_VAL_SIG_INFO_IND               = 0x0051,
  NASI_CMD_VAL_GET_ERR_RATE               = 0x0052,
  NASI_CMD_VAL_ERR_RATE_IND               = 0x0053,
  NASI_CMD_VAL_HDR_SESSION_CLOSE_IND      = 0x0054,
  NASI_CMD_VAL_HDR_UATI_UPDATE_IND        = 0x0055,
  NASI_CMD_VAL_GET_HDR_SUBTYPE            = 0x0056,
  NASI_CMD_VAL_GET_HDR_COLOR_CODE         = 0x0057,
  NASI_CMD_VAL_GET_CURRENT_ACQ_SYS_MODE   = 0x0058,
  NASI_CMD_VAL_SET_RX_DIVERSITY           = 0x0059,
  NASI_CMD_VAL_GET_TX_RX_INFO             = 0x005A,
  NASI_CMD_VAL_UPDATE_AKEY_EXT            = 0x005B,
  NASI_CMD_VAL_GET_DUAL_STANDBY_PREF      = 0x005C,
  NASI_CMD_VAL_DETACH_LTE                 = 0x005D,
  NASI_CMD_VAL_BLOCK_LTE_PLMN             = 0x005E,
  NASI_CMD_VAL_UNBLOCK_LTE_PLMN           = 0x005F,
  NASI_CMD_VAL_RESET_LTE_PLMN_BLOCKING    = 0x0060,
  NASI_CMD_VAL_CURRENT_PLMN_NAME_IND      = 0x0061,
  NASI_CMD_VAL_CONFIG_EMBMS               = 0x0062,
  NASI_CMD_VAL_GET_EMBMS_STATUS           = 0x0063,
  NASI_CMD_VAL_EMBMS_STATUS_IND           = 0x0064,
  NASI_CMD_VAL_GET_CDMA_POSITION_INFO     = 0x0065,
  NASI_CMD_VAL_RF_BAND_INFO_IND           = 0x0066,
  NASI_CMD_VAL_FORCE_NETWORK_SEARCH       = 0x0067,
  NASI_CMD_VAL_NETWORK_REJECT_IND         = 0x0068,
  NASI_CMD_VAL_GET_MANAGED_ROAMING_CONFIG = 0x0069,
  NASI_CMD_VAL_RTRE_CONFIG_IND            = 0x006A,
  NASI_CMD_VAL_GET_CENTRALIZED_EONS_SUPPORT_STATUS = 0x006B,
  NASI_CMD_VAL_CONFIG_SIG_INFO2           = 0x006C,
  NASI_CMD_VAL_GET_TDS_CELL_AND_POSITION_INFO= 0x006D,
  NASI_CMD_VAL_SET_HPLMN_IRAT_SEARCH_TIMER = 0x006E,
  NASI_CMD_VAL_GET_EMBMS_SIG               = 0x006F,
  NASI_CMD_VAL_LIMIT_SYS_INFO_IND_REPORTING = 0x0070,
  NASI_CMD_VAL_GET_SYS_INFO_IND_REPORTING_LIMIT = 0x0071,
  NASI_CMD_VAL_UPDATE_IMS_STATUS          = 0x0072,
  NASI_CMD_VAL_GET_IMS_PREF_STATUS        = 0x0073,
  NASI_CMD_VAL_IMS_PREF_STATUS_IND        = 0x0074,
  NASI_CMD_VAL_CONFIG_PLMN_NAME_IND_REPORTING   = 0x0075,
  NASI_CMD_VAL_CDMA_AVOID_SYSTEM                = 0x0076,
  NASI_CMD_VAL_GET_CDMA_AVOID_SYSTEM_LIST       = 0x0077,
  NASI_CMD_VAL_SET_HPLMN_SEARCH_TIMER    = 0x0078,
  NASI_CMD_VAL_GET_HPLMN_SEARCH_TIMER    = 0x0079,
  NASI_CMD_VAL_SET_BUILTIN_PLMN_LIST     = 0x0084,
  NASI_CMD_VAL_SET_E911_STATE             = 0x007A,
  NASI_CMD_VAL_E911_STATE_READY_IND       = 0x007B,
  NASI_CMD_VAL_GET_SUBSCRIPTION_INFO      = 0x007C,
  NASI_CMD_VAL_GET_NETWORK_TIME                 = 0x007D,
  NASI_CMD_VAL_GET_LTE_SIB16_NETWORK_TIME           = 0x007E,
  NASI_CMD_VAL_LTE_SIB16_NETWORK_TIME_IND           = 0x007F,
  NASI_CMD_VAL_SET_LTE_BAND_PRIORITY            = 0x0080,
  NASI_CMD_VAL_GET_EMBMS_SIG_EXT                = 0x0081,
  NASI_CMD_VAL_LTE_CPHY_CA_IND        = 0x0082,
  NASI_CMD_VAL_GET_LTE_BAND_PRIORITY            = 0x0083,
  NASI_CMD_VAL_PERFORM_INCREMENTAL_NETWORK_SCAN  = 0x0085,
  NASI_CMD_VAL_SUBSCRIPTION_CHANGE_IND    = 0x0086,
  NASI_CMD_VAL_IMS_DEREGISTRATION         = 0x0087,
  NASI_CMD_VAL_SET_DRX                    = 0x0088,
  NASI_CMD_VAL_GET_DRX                    = 0x0089,
  NASI_CMD_VAL_CSG_SEARCH_SELECTION_CONFIG      = 0x008A,
  NASI_CMD_VAL_CSG_IMMEDIATE_SEARCH_SELECTION   = 0x008B,
  NASI_CMD_VAL_GET_CSG_SEARCH_SELECTION_CONFIG  = 0x008C,
  NASI_CMD_VAL_SSAC_INFO_IND         = 0x008D,
  NASI_CMD_VAL_GET_LTE_EMBMS_INFO         = 0x008E,
  NASI_CMD_VAL_GET_SERVING_CELL_SIB       = 0x008F,
  NASI_CMD_VAL_SSAC_CHANGE_INFO_IND         = 0x0090,
  NASI_CMD_VAL_GET_SSAC_INFO         = 0x0091,
  NASI_CMD_VAL_SET_PERIODIC_SEARCH_ALLOWED  = 0x0092,
  NASI_CMD_VAL_GET_ACB_INFO           = 0x0094,
  NASI_CMD_VAL_SET_DATA_SUBS_PRIORITY = 0x0095,
  NASI_CMD_VAL_GET_DATA_SUBS_PRIORITY = 0x0096,
  NASI_CMD_VAL_DATA_SUBS_PRIORITY_IND = 0x0097,
  NASI_CMD_VAL_AVOID_TUNEAWAY_REQ = 0x0098,
  NASI_CMD_VAL_SET_MCC = 0x0099,
  NASI_CMD_VAL_SET_DATA_ROAMING_STATUS = 0x009A,
  NASI_CMD_VAL_GET_DATA_ROAMING_STATUS = 0x009B,
  NASI_CMD_VAL_SET_SRVCC = 0x009C,
  NASI_CMD_VAL_SET_BSR_TIMER = 0x009D,
  NASI_CMD_VAL_GET_BSR_TIMER = 0x009E,
  NASI_CMD_VAL_T3346_TIMER_STATUS_CHANGE_IND = 0x00A0,
  NASI_CMD_VAL_SET_DRX_SCALING_FACTOR = 0x009F,
  NASI_CMD_VAL_IMS_CALL_STATE_NOTIFICATION = 0x00A1,
  NASI_CMD_VAL_CALL_MODE_IND         = 0x00A2,
  NASI_CMD_VAL_GET_CALL_MODE         = 0x00A3,
  NASI_CMD_VAL_VOLTE_STATE_NOTIFICATION         = 0x00A4,
  NASI_CMD_VAL_SET_CELL_LOCK_CONFIG       = 0x00AF,
  NASI_CMD_VAL_SET_RPM_PARAMETERS        = 0x00A9,
  NASI_CMD_VAL_GET_RPM_PARAMETERS        = 0x00AA,
  NASI_CMD_VAL_SET_RPM_STATE        = 0x00AB,
  NASI_CMD_VAL_SET_RPM_PARAMETERS_2 = 0x00B9,
  NASI_CMD_VAL_SET_VOICE_ROAMING_STATUS = 0x00B7,
  NASI_CMD_VAL_GET_VOICE_ROAMING_STATUS = 0x00B8,
  NASI_CMD_VAL_GCELL_INFO = 0x00BD,
  NASI_CMD_VAL_BAR_GCELL = 0x00BE,
/* QC EXTERNAL QMI COMMAND RANGE IS 0x0000 - 0x5555.
   Add the next external QMI Command here */

/* VENDOR SPECIFIC QMI COMMAND RANGE IS 0x5556 - 0xAAAA.
   IMPORTANT!
   Add the vendor specific QMI Commands within this range only to avoid
   conflicts with QC QMI commands that would get released in future */

/* RESERVED QC QMI COMMAND RANGE IS 0xAAAB - 0xFFFE */
  NASI_CMD_VAL_WIDTH                      = 0xFFFF
} qmi_nasi_cmd_val_e_type;

//===========================================================================
// GLOBALS
//===========================================================================
struct qmi_nasi_global_s qmi_nasi_global;
struct qmi_nas_nitz_time_info_s qmi_nasi_nitz_time;
struct qmi_nas_ssac_change_info_s  qmi_nasi_ssac_info;
/*===========================================================================

                               INTERNAL DATA

===========================================================================*/

/*---------------------------------------------------------------------------
  QMI_NAS service command handlers
  forward declarations & cmd handler dispatch table definition
---------------------------------------------------------------------------*/

#ifdef _WIN32
#define NAS_HDLR_PROTOTYPE(x)   dsm_item_type* x( void*, void*, void*, dsm_item_type** )
#else
#define NAS_HDLR_PROTOTYPE(x)   dsm_item_type* x( void*, void*, void*, dsm_item_type** )__attribute__((unused))
#endif

static NAS_HDLR_PROTOTYPE(qmi_nasi_reset);
static NAS_HDLR_PROTOTYPE(qmi_nasi_abort);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_event_report);
static NAS_HDLR_PROTOTYPE(qmi_nasi_indication_register);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_signal_strength);
static NAS_HDLR_PROTOTYPE(qmi_nasi_perform_network_scan);
static NAS_HDLR_PROTOTYPE(qmi_nasi_initiate_network_register);
static NAS_HDLR_PROTOTYPE(qmi_nasi_initiate_attach);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_serving_system);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_home_network);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_preferred_networks);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_preferred_networks);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_forbidden_networks);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_forbidden_networks);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_technology_preference);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_technology_preference);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_accolc);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_accolc);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_system_preference);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_device_config);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_device_config);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_rf_band_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_an_aaa_status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_sys_sel_pref);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_sys_sel_pref);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_ddtm_preference);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_operator_name_data);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_csp_plmn_mode_bit);
static NAS_HDLR_PROTOTYPE(qmi_nasi_update_akey);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_3gpp2_subscription_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_3gpp2_subscription_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_mob_cai_rev);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_rtre_config);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_rtre_config);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_cell_location_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_plmn_name);
static NAS_HDLR_PROTOTYPE(qmi_nasi_bind_subscription);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_mode_pref);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_dual_standby_pref_new);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_sys_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_sig_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_config_sig_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_err_rate);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_hdr_subtype);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_hdr_color_code);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_cm_acq_mode);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_rx_diversity);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_tx_rx_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_update_akey_ext);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_dual_standby_pref);
static NAS_HDLR_PROTOTYPE(qmi_nasi_detach_lte);
static NAS_HDLR_PROTOTYPE(qmi_nasi_block_lte_plmn);
static NAS_HDLR_PROTOTYPE(qmi_nasi_unblock_lte_plmn);
static NAS_HDLR_PROTOTYPE(qmi_nasi_reset_lte_plmn_blocking);
static NAS_HDLR_PROTOTYPE(qmi_nasi_config_embms);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_embms_status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_cdma_position_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_force_network_search);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_managed_roaming_config);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_centralized_eons_support_status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_config_sig_info2);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_tds_cell_and_position_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_hplmn_irat_search_timer);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_embms_sig);
static NAS_HDLR_PROTOTYPE(qmi_nasi_limit_sys_info_ind_reporting);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_sys_info_ind_reporting_limit);
static NAS_HDLR_PROTOTYPE(qmi_nasi_update_ims_status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_ims_pref_status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_config_plmn_name_ind_reporting);
static NAS_HDLR_PROTOTYPE(qmi_nasi_cdma_avoid_system);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_cdma_avoid_system_list);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_hplmn_search_timer);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_hplmn_search_timer);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_builtin_plmn_list);
NAS_HDLR_PROTOTYPE(qmi_nasi_set_e911_state);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_lte_sib16_network_time);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_lte_band_priority);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_embms_sig_ext);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_lte_band_priority_list);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_subscription_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_perform_incremental_network_scan);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_network_time);
NAS_HDLR_PROTOTYPE(qmi_nasi_ims_deregistration);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_drx);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_drx);
static NAS_HDLR_PROTOTYPE(qmi_nasi_csg_search_selection_config);
static NAS_HDLR_PROTOTYPE(qmi_nasi_csg_immediate_search_selection);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_csg_search_selection_config);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_lte_embms_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_serving_cell_sib);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_ssac_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_periodic_search_allowed);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_acb_info);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_data_subs_priority);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_data_subs_priority);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_srvcc);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_bsr_timer);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_bsr_timer);
static NAS_HDLR_PROTOTYPE(qmi_nasi_avoid_tuneaway_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_mcc);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_drx_scaling_factor);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_data_roaming_status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_data_roaming_status);
NAS_HDLR_PROTOTYPE(qmi_nasi_get_call_mode);
NAS_HDLR_PROTOTYPE(qmi_nasi_volte_state_notification);
NAS_HDLR_PROTOTYPE(qmi_nasi_ims_call_state_notification);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_rpm_parameters);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_rpm_parameters);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_rpm_state);

static NAS_HDLR_PROTOTYPE(qmi_nasi_set_voice_roaming_status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_get_voice_roaming_status);
static NAS_HDLR_PROTOTYPE(qmi_nasi_gcell_info_req);
static NAS_HDLR_PROTOTYPE(qmi_nasi_bar_gcell_req);

static void qmi_nas_generate_net_scan_resp_ext ( sys_found_plmn_list_u_type *available_networks, sys_plmn_list_status_e_type available_networks_list_cnf,
                                                cm_network_list_type_e_type list_type);
static void qmi_nas_set_hplmn_irat_search_timer_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type ph_cmd_err );
boolean qmi_nas_get_nitz_time_from_cache(nas_get_network_time_resp_msg_v01 *resp);
void qmi_nas_update_cached_time_info( cm_mm_msim_ss_info_s_type *p_info );
void qmi_nasi_ssac_info_ind( lte_rrc_ssac_params_s * );
void qmi_nasi_ssac_change_info_ind( lte_rrc_ssac_params_s * );
void qmi_nasi_gen_emm_t3402_changed_ind( emm_t3402_changed_ind_s_type * );
void qmi_nasi_acb_info_ind( lte_rrc_ac_barring_info_s * );
void qmi_nasi_set_data_subs_priority_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
void qmi_nasi_set_srvcc_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
void qmi_nasi_avoid_tuneaway_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
static void qmi_nasi_generate_set_drx_scaling_factor_rsp ( errno_enum_type status);
void qmi_nasi_set_data_roaming_status_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
void qmi_nasi_generate_call_mode_ind( qmi_mmodei_msgr_type * msg_p );
static void qmi_nasi_generate_manual_scan_fail_ind ( sys_modem_as_id_e_type asid );

static dsm_item_type* qmi_nasi_set_cell_lock_config ( void*, void*, void*, dsm_item_type** );
static void qmi_nasi_set_cell_lock_config_resp (lte_rrc_cell_lock_status_e status);
static void qmi_nasi_generate_set_rpm_parameters_rsp ( qmi_mmodei_msgr_type * msg_p);
static void qmi_nasi_generate_get_rpm_parameters_rsp ( qmi_mmodei_msgr_type * msg_p);
static NAS_HDLR_PROTOTYPE(qmi_nasi_set_rpm_parameters_2);
static void qmi_nasi_generate_set_rpm_parameters_2_rsp ( qmi_mmodei_msgr_type * msg_p);
void qmi_nasi_set_voice_roaming_status_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
void qmi_nasi_gcell_info_ind (geran_grr_qmi_cell_info_ind_t *gcell_info_ind);
static void qmi_nasi_generate_gcell_info_resp(geran_grr_qmi_cell_info_rsp_t  *geran_cell_info_rsp);
#define NAS_HDLR(a,b)  QMI_SVC_HDLR( (uint16)a, (qmi_svc_hdlr_ftype) b )

static qmi_svc_cmd_hdlr_type  qmi_nasi_cmd_callbacks[NASI_CMD_MAX] =
{
    #ifndef REMOVE_QMI_NAS_RESET_V01
    NAS_HDLR( NASI_CMD_VAL_RESET,                       qmi_nasi_reset ),
    #endif
    #ifndef REMOVE_QMI_NAS_ABORT_V01
    NAS_HDLR( NASI_CMD_VAL_ABORT,                       qmi_nasi_abort ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_EVENT_REPORT_V01
    NAS_HDLR( NASI_CMD_VAL_SET_EVENT_REPORT,            qmi_nasi_set_event_report ),
    #endif
    #ifndef REMOVE_QMI_NAS_INDICATION_REGISTER_V01
    NAS_HDLR( NASI_CMD_VAL_INDICATION_REGISTER,         qmi_nasi_indication_register ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SIGNAL_STRENGTH_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SIGNAL_STRENGTH,         qmi_nasi_get_signal_strength ),
    #endif
    #ifndef REMOVE_QMI_NAS_PERFORM_NETWORK_SCAN_V01
    NAS_HDLR( NASI_CMD_VAL_PERFORM_NETWORK_SCAN,        qmi_nasi_perform_network_scan ),
    #endif
    #ifndef REMOVE_QMI_NAS_INITIATE_NETWORK_REGISTER_V01
    NAS_HDLR( NASI_CMD_VAL_INITIATE_NETWORK_REGISTER,   qmi_nasi_initiate_network_register ),
    #endif
    #ifndef REMOVE_QMI_NAS_INITIATE_ATTACH_V01
    NAS_HDLR( NASI_CMD_VAL_INITIATE_ATTACH,             qmi_nasi_initiate_attach ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SERVING_SYSTEM_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SERVING_SYSTEM,          qmi_nasi_get_serving_system ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_HOME_NETWORK_V01
    NAS_HDLR( NASI_CMD_VAL_GET_HOME_NETWORK,            qmi_nasi_get_home_network ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_PREFERRED_NETWORKS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_PREFERRED_NETWORKS,      qmi_nasi_get_preferred_networks ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_PREFERRED_NETWORKS_V01
    NAS_HDLR( NASI_CMD_VAL_SET_PREFERRED_NETWORKS,      qmi_nasi_set_preferred_networks ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_FORBIDDEN_NETWORKS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_FORBIDDEN_NETWORKS,      qmi_nasi_get_forbidden_networks ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_FORBIDDEN_NETWORKS_V01
    NAS_HDLR( NASI_CMD_VAL_SET_FORBIDDEN_NETWORKS,      qmi_nasi_set_forbidden_networks ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_TECHNOLOGY_PREFERENCE_V01
    NAS_HDLR( NASI_CMD_VAL_SET_TECHNOLOGY_PREFERENCE,   qmi_nasi_set_technology_preference ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_TECHNOLOGY_PREFERENCE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_TECHNOLOGY_PREFERENCE,   qmi_nasi_get_technology_preference ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_ACCOLC_V01
    NAS_HDLR( NASI_CMD_VAL_GET_ACCOLC,                  qmi_nasi_get_accolc ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_ACCOLC_V01
    NAS_HDLR( NASI_CMD_VAL_SET_ACCOLC,                  qmi_nasi_set_accolc ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_NETWORK_SYSTEM_PREFERENCE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SYSTEM_PREFERENCE,       qmi_nasi_get_system_preference ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_DEVICE_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_GET_DEVICE_CONFIG,           qmi_nasi_get_device_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DEVICE_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DEVICE_CONFIG,           qmi_nasi_set_device_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_RF_BAND_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_RF_BAND_INFO,            qmi_nasi_get_rf_band_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_AN_AAA_STATUS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_AN_AAA_STATUS,           qmi_nasi_get_an_aaa_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_V01
    NAS_HDLR( NASI_CMD_VAL_SET_SYS_SEL_PREF,            qmi_nasi_set_sys_sel_pref ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SYS_SEL_PREF,            qmi_nasi_get_sys_sel_pref ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DDTM_PREFERENCE_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DDTM_PREFERENCE,         qmi_nasi_set_ddtm_preference ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_OPERATOR_NAME_DATA_V01
    NAS_HDLR( NASI_CMD_VAL_GET_OPERATOR_NAME_DATA,      qmi_nasi_get_operator_name_data ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CSP_PLMN_MODE_BIT_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CSP_PLMN_MODE_BIT,       qmi_nasi_get_csp_plmn_mode_bit ),
    #endif
    #ifndef REMOVE_QMI_NAS_UPDATE_AKEY_V01
    NAS_HDLR( NASI_CMD_VAL_UPDATE_AKEY,                 qmi_nasi_update_akey ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_3GPP2_SUBSCRIPTION_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_3GPP2_SUBSCRIPTION_INFO, qmi_nasi_get_3gpp2_subscription_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_3GPP2_SUBSCRIPTION_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_SET_3GPP2_SUBSCRIPTION_INFO, qmi_nasi_set_3gpp2_subscription_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_MOB_CAI_REV_V01
    NAS_HDLR( NASI_CMD_VAL_GET_MOB_CAI_REV,             qmi_nasi_get_mob_cai_rev ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_RTRE_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_GET_RTRE_CONFIG,             qmi_nasi_get_rtre_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_RTRE_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_SET_RTRE_CONFIG,             qmi_nasi_set_rtre_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CELL_LOCATION_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CELL_LOCATION_INFO,      qmi_nasi_get_cell_location_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_PLMN_NAME_V01
    NAS_HDLR( NASI_CMD_VAL_GET_PLMN_NAME,               qmi_nasi_get_plmn_name ),
    #endif
    #ifndef REMOVE_QMI_NAS_BIND_SUBSCRIPTION_V01
    NAS_HDLR( NASI_CMD_VAL_BIND_SUBSCRIPTION,           qmi_nasi_bind_subscription ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_MODE_PREF_V01
    NAS_HDLR( NASI_CMD_VAL_GET_MODE_PREF,               qmi_nasi_get_mode_pref ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DUAL_STANDBY_PREF_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DUAL_STANDBY_PREF_NEW,   qmi_nasi_set_dual_standby_pref_new ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SYS_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SYS_INFO,                qmi_nasi_get_sys_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SIG_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SIG_INFO,                qmi_nasi_get_sig_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_CONFIG_SIG_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_CONFIG_SIG_INFO,             qmi_nasi_config_sig_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_ERR_RATE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_ERR_RATE,                qmi_nasi_get_err_rate ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_HDR_SUBTYPE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_HDR_SUBTYPE,             qmi_nasi_get_hdr_subtype ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_HDR_COLOR_CODE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_HDR_COLOR_CODE,          qmi_nasi_get_hdr_color_code ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CURRENT_ACQ_SYS_MODE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CURRENT_ACQ_SYS_MODE,    qmi_nasi_get_cm_acq_mode ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_RX_DIVERSITY_V01
    NAS_HDLR( NASI_CMD_VAL_SET_RX_DIVERSITY,            qmi_nasi_set_rx_diversity ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_TX_RX_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_TX_RX_INFO,              qmi_nasi_get_tx_rx_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_UPDATE_AKEY_EXT_V01
    NAS_HDLR( NASI_CMD_VAL_UPDATE_AKEY_EXT,             qmi_nasi_update_akey_ext ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_DUAL_STANDBY_PREF_V01
    NAS_HDLR( NASI_CMD_VAL_GET_DUAL_STANDBY_PREF,       qmi_nasi_get_dual_standby_pref ),
    #endif
    #ifndef REMOVE_QMI_NAS_DETACH_LTE_V01
    NAS_HDLR( NASI_CMD_VAL_DETACH_LTE,                  qmi_nasi_detach_lte ),
    #endif
    #ifndef REMOVE_QMI_NAS_BLOCK_LTE_PLMN_V01
    NAS_HDLR( NASI_CMD_VAL_BLOCK_LTE_PLMN,              qmi_nasi_block_lte_plmn ),
    #endif
    #ifndef REMOVE_QMI_NAS_UNBLOCK_LTE_PLMN_V01
    NAS_HDLR( NASI_CMD_VAL_UNBLOCK_LTE_PLMN,            qmi_nasi_unblock_lte_plmn ),
    #endif
    #ifndef REMOVE_QMI_NAS_RESET_LTE_PLMN_BLOCKING_V01
    NAS_HDLR( NASI_CMD_VAL_RESET_LTE_PLMN_BLOCKING,     qmi_nasi_reset_lte_plmn_blocking ),
    #endif
    #ifndef REMOVE_QMI_NAS_CONFIG_EMBMS_V01
    NAS_HDLR( NASI_CMD_VAL_CONFIG_EMBMS,                qmi_nasi_config_embms ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_EMBMS_STATUS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_EMBMS_STATUS,            qmi_nasi_get_embms_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CDMA_POSITION_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CDMA_POSITION_INFO,      qmi_nasi_get_cdma_position_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_FORCE_NETWORK_SEARCH_V01
    NAS_HDLR( NASI_CMD_VAL_FORCE_NETWORK_SEARCH,        qmi_nasi_force_network_search ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_MANAGED_ROAMING_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_GET_MANAGED_ROAMING_CONFIG,  qmi_nasi_get_managed_roaming_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CENTRALIZED_EONS_SUPPORT_STATUS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CENTRALIZED_EONS_SUPPORT_STATUS,  qmi_nasi_get_centralized_eons_support_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_CONFIG_SIG_INFO2_V01
    NAS_HDLR( NASI_CMD_VAL_CONFIG_SIG_INFO2,            qmi_nasi_config_sig_info2 ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_TDS_CELL_AND_POSITION_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_TDS_CELL_AND_POSITION_INFO,  qmi_nasi_get_tds_cell_and_position_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_HPLMN_IRAT_SEARCH_TIMER_V01
    NAS_HDLR( NASI_CMD_VAL_SET_HPLMN_IRAT_SEARCH_TIMER,      qmi_nasi_set_hplmn_irat_search_timer ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_EMBMS_SIG_V01
    NAS_HDLR( NASI_CMD_VAL_GET_EMBMS_SIG,                    qmi_nasi_get_embms_sig ),
    #endif
    #ifndef REMOVE_QMI_NAS_LIMIT_SYS_INFO_IND_REPORTING_V01
    NAS_HDLR( NASI_CMD_VAL_LIMIT_SYS_INFO_IND_REPORTING,  qmi_nasi_limit_sys_info_ind_reporting ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SYS_INFO_IND_REPORTING_LIMIT_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SYS_INFO_IND_REPORTING_LIMIT,  qmi_nasi_get_sys_info_ind_reporting_limit ),
    #endif
    #ifndef REMOVE_QMI_NAS_UPDATE_IMS_STATUS_V01
    NAS_HDLR( NASI_CMD_VAL_UPDATE_IMS_STATUS,         qmi_nasi_update_ims_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_IMS_PREF_STATUS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_IMS_PREF_STATUS,       qmi_nasi_get_ims_pref_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_CONFIG_PLMN_NAME_IND_REPORTING_V01
    NAS_HDLR( NASI_CMD_VAL_CONFIG_PLMN_NAME_IND_REPORTING, qmi_nasi_config_plmn_name_ind_reporting ),
    #endif
    #ifndef REMOVE_QMI_NAS_CDMA_AVOID_SYSTEM_V01
    NAS_HDLR( NASI_CMD_VAL_CDMA_AVOID_SYSTEM,                 qmi_nasi_cdma_avoid_system ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CDMA_AVOID_SYSTEM_LIST_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CDMA_AVOID_SYSTEM_LIST,        qmi_nasi_get_cdma_avoid_system_list ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_HPLMN_SEARCH_TIMER_V01
    NAS_HDLR( NASI_CMD_VAL_SET_HPLMN_SEARCH_TIMER,      qmi_nasi_set_hplmn_search_timer ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_HPLMN_SEARCH_TIMER_V01
    NAS_HDLR( NASI_CMD_VAL_GET_HPLMN_SEARCH_TIMER,      qmi_nasi_get_hplmn_search_timer ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_BUILTIN_PLMN_LIST_V01
    NAS_HDLR( NASI_CMD_VAL_SET_BUILTIN_PLMN_LIST,      qmi_nasi_set_builtin_plmn_list ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_E911_STATE_V01
    NAS_HDLR( NASI_CMD_VAL_SET_E911_STATE,           qmi_nasi_set_e911_state ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_LTE_SIB16_NETWORK_TIME_V01
    NAS_HDLR( NASI_CMD_VAL_GET_LTE_SIB16_NETWORK_TIME,  qmi_nasi_get_lte_sib16_network_time ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_LTE_BAND_PRIORITY_V01
    NAS_HDLR( NASI_CMD_VAL_SET_LTE_BAND_PRIORITY,             qmi_nasi_set_lte_band_priority ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_EMBMS_SIG_EXT_V01
    NAS_HDLR( NASI_CMD_VAL_GET_EMBMS_SIG_EXT,             qmi_nasi_get_embms_sig_ext ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_LTE_BAND_PRIORITY_LIST_V01
    NAS_HDLR( NASI_CMD_VAL_GET_LTE_BAND_PRIORITY,             qmi_nasi_get_lte_band_priority_list ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SUBSCRIPTION_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SUBSCRIPTION_INFO,      qmi_nasi_get_subscription_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_V01
    NAS_HDLR( NASI_CMD_VAL_PERFORM_INCREMENTAL_NETWORK_SCAN, qmi_nasi_perform_incremental_network_scan ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_NETWORK_TIME_V01
    NAS_HDLR( NASI_CMD_VAL_GET_NETWORK_TIME,             qmi_nasi_get_network_time ),
    #endif
    #ifndef REMOVE_QMI_NAS_IMS_PROCEED_WITH_SUBSCRIPTION_CHANGE_V01
    NAS_HDLR( NASI_CMD_VAL_IMS_DEREGISTRATION,          qmi_nasi_ims_deregistration ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DRX_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DRX,                  qmi_nasi_set_drx ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_DRX_V01
    NAS_HDLR( NASI_CMD_VAL_GET_DRX,                  qmi_nasi_get_drx ),
    #endif
    #ifndef REMOVE_QMI_NAS_CSG_SEARCH_SELECTION_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_CSG_SEARCH_SELECTION_CONFIG,          qmi_nasi_csg_search_selection_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_CSG_IMMEDIATE_SEARCH_SELECTION_V01
    NAS_HDLR( NASI_CMD_VAL_CSG_IMMEDIATE_SEARCH_SELECTION,          qmi_nasi_csg_immediate_search_selection ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CSG_SEARCH_SELECTION_CONFIGURATION_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CSG_SEARCH_SELECTION_CONFIG,          qmi_nasi_get_csg_search_selection_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_LTE_EMBMS_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_LTE_EMBMS_INFO,          qmi_nasi_get_lte_embms_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SERV_CELL_SIB_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SERVING_CELL_SIB,          qmi_nasi_get_serving_cell_sib ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_SSAC_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_SSAC_INFO,             qmi_nasi_get_ssac_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_PERIODIC_SEARCH_ALLOWED_V01
    NAS_HDLR( NASI_CMD_VAL_SET_PERIODIC_SEARCH_ALLOWED,          qmi_nasi_set_periodic_search_allowed ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_ACB_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GET_ACB_INFO,                  qmi_nasi_get_acb_info ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DATA_SUBS_PRIORITY_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DATA_SUBS_PRIORITY,             qmi_nasi_set_data_subs_priority ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_DATA_SUBS_PRIORITY_V01
    NAS_HDLR( NASI_CMD_VAL_GET_DATA_SUBS_PRIORITY,             qmi_nasi_get_data_subs_priority ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_SRVCC_V01
    NAS_HDLR( NASI_CMD_VAL_SET_SRVCC,                          qmi_nasi_set_srvcc ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_BSR_TIMER_V01
    NAS_HDLR( NASI_CMD_VAL_SET_BSR_TIMER,             qmi_nasi_set_bsr_timer ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_BSR_TIMER_V01
    NAS_HDLR( NASI_CMD_VAL_GET_BSR_TIMER,             qmi_nasi_get_bsr_timer ),
    #endif
    #ifndef REMOVE_QMI_NAS_AVOID_TUNEAWAY_V01
    NAS_HDLR( NASI_CMD_VAL_AVOID_TUNEAWAY_REQ,             qmi_nasi_avoid_tuneaway_req ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_MCC_V01
    NAS_HDLR( NASI_CMD_VAL_SET_MCC,             qmi_nasi_set_mcc ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DRX_SCALING_FACTOR_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DRX_SCALING_FACTOR,             qmi_nasi_set_drx_scaling_factor ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_DATA_ROAMING_V01
    NAS_HDLR( NASI_CMD_VAL_SET_DATA_ROAMING_STATUS,             qmi_nasi_set_data_roaming_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_DATA_ROAMING_V01
    NAS_HDLR( NASI_CMD_VAL_GET_DATA_ROAMING_STATUS,             qmi_nasi_get_data_roaming_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_CALL_MODE_V01
    NAS_HDLR( NASI_CMD_VAL_GET_CALL_MODE,             qmi_nasi_get_call_mode ),
    #endif
    #ifndef REMOVE_QMI_NAS_VOLTE_STATE_NOTIFICATION_V01
    NAS_HDLR( NASI_CMD_VAL_VOLTE_STATE_NOTIFICATION,             qmi_nasi_volte_state_notification ),
    #endif
    #ifndef REMOVE_QMI_NAS_IMS_CALL_STATE_NOTIFICATION_V01
    NAS_HDLR( NASI_CMD_VAL_IMS_CALL_STATE_NOTIFICATION,             qmi_nasi_ims_call_state_notification ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_CELL_LOCK_CONFIG_V01
    NAS_HDLR( NASI_CMD_VAL_SET_CELL_LOCK_CONFIG,           qmi_nasi_set_cell_lock_config ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_RPM_PARAMETERS_V01
    NAS_HDLR( NASI_CMD_VAL_SET_RPM_PARAMETERS,             qmi_nasi_set_rpm_parameters ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_RPM_PARAMETERS_V01
    NAS_HDLR( NASI_CMD_VAL_GET_RPM_PARAMETERS,             qmi_nasi_get_rpm_parameters ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_RPM_STATE_V01
    NAS_HDLR( NASI_CMD_VAL_SET_RPM_STATE,             qmi_nasi_set_rpm_state ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_RPM_PARAMETERS_2_V01
    NAS_HDLR( NASI_CMD_VAL_SET_RPM_PARAMETERS_2,             qmi_nasi_set_rpm_parameters_2 ),
    #endif
    #ifndef REMOVE_QMI_NAS_SET_VOICE_ROAMING_V01
    NAS_HDLR( NASI_CMD_VAL_SET_VOICE_ROAMING_STATUS,             qmi_nasi_set_voice_roaming_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_GET_VOICE_ROAMING_V01
    NAS_HDLR( NASI_CMD_VAL_GET_VOICE_ROAMING_STATUS,             qmi_nasi_get_voice_roaming_status ),
    #endif
    #ifndef REMOVE_QMI_NAS_GCELL_INFO_V01
    NAS_HDLR( NASI_CMD_VAL_GCELL_INFO,     qmi_nasi_gcell_info_req ),
    #endif
    #ifndef REMOVE_QMI_NAS_BAR_GCELL_V01
    NAS_HDLR( NASI_CMD_VAL_BAR_GCELL,     qmi_nasi_bar_gcell_req ),
    #endif
};

/*---------------------------------------------------------------------------
  Each QMI link (usb, BT etc) has its own NAS state
---------------------------------------------------------------------------*/
qmi_nasi_state_type  qmi_nas_state;

/*---------------------------------------------------------------------------
  QMI_WS instance configurations
---------------------------------------------------------------------------*/
static void     qmi_nasi_reset_client(void *);

static qmi_mmode_svc_config_type  qmi_nasi_cfg;

/*===========================================================================

                   NEW FW FUNCTIONS

===========================================================================*/

/*===========================================================================
  FUNCTION QMI_NASI_GET_CL_SP_BY_CMD_BUF()

  DESCRIPTION
    Retrieve client sp from the command buffer

  PARAMETERS
    cmd_buf_p_in  :  command buffer

  RETURN VALUE
    cl_sp   :  client sp

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void* qmi_nasi_get_cl_sp_by_cmd_buf( qmi_cmd_buf_type* cmd_buf_p )
{
  qmi_common_client_state_type *cl_sp;
  void                         *ret_val = NULL;
  int                           i=0;

  if ( cmd_buf_p && cmd_buf_p->x_p && cmd_buf_p->x_p->cl_sp )
  {
    cl_sp = cmd_buf_p->x_p->cl_sp;

    for ( i=0; i<NASI_MAX_CLIDS; i++ )
    {
      if ( qmi_nas_state.client[i] )
      {
        if ( qmi_nas_state.client[i]->common.clid == cl_sp->clid )
        {
          ret_val = (void*)qmi_nas_state.client[i];
          break;
        }
      }
    }
  }
  else
  {
    if ( cmd_buf_p != NULL && cmd_buf_p->x_p != NULL )
    {
      QM_MSG_ERROR("qmi_nasi_get_cl_sp_by_cmd_buf() cl_sp is null");
    }
    else
    {
      QM_MSG_ERROR_1("qmi_nasi_get_cl_sp_by_cmd_buf() cmd_buf_p %x or x_p is null", cmd_buf_p);
    }
  }

  return ret_val;
}

/*===========================================================================
  FUNCTION QMI_NASI_SEND_RESPONSE()

  DESCRIPTION
    Send the response to framework

  PARAMETERS
    clid: uint8

  RETURN VALUE
    TRUE if sent successfully, FALSE otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_nasi_send_response
(
  qmi_cmd_buf_type *      cmd_buf_p,
  dsm_item_type *         msg_ptr
)
{
  qmi_framework_common_msg_hdr_type hdr;
  qmi_nasi_client_state_type *      cl_sp;
  boolean                           status = FALSE;
  uint16                            cmd_type;

  if ( cmd_buf_p == NULL )
  {
    QM_MSG_ERROR("cmd_buf_p is NULL");
    return FALSE;
  }

  cl_sp = (qmi_nasi_client_state_type*)qmi_nasi_get_cl_sp_by_cmd_buf( cmd_buf_p );

  if ( cl_sp )
  {
    memset( &hdr, 0x00, sizeof(hdr) );

    hdr.service      = (qmux_service_e_type)cl_sp->service_id;
    hdr.client_id    = cl_sp->common.clid;
    hdr.qmi_instance = cl_sp->instance;
    /* Transaction id will be filled by svc layer */

    cmd_type = cmd_buf_p->cmd_type;
    status = qmi_mmode_svc_send_response( &hdr, cmd_buf_p, msg_ptr );

    QM_MSG_HIGH_3("qmi_nasi_send_response() sending resp: cmd %d clnt %d status %d",
                  cmd_type, hdr.client_id, status);
  }
  else
  {
    dsm_free_packet( &msg_ptr );

    //QM_MSG_ERROR("qmi_nasi_send_response() can't find cl_sp");
  }

  return status;
}

/*===========================================================================
  FUNCTION qmi_nasi_send_ind()

  DESCRIPTION
    This function is calls the QMI Framework API to send out the NAS service
    indication to client.
===========================================================================*/
static void qmi_nasi_send_ind( qmi_nasi_client_state_type* cl_sp, qmi_nasi_cmd_val_e_type cmd, dsm_item_type* ind )
{
  qmi_framework_common_msg_hdr_type hdr;
  boolean                           status = FALSE;

  if ( cl_sp )
  {
    hdr.client_id    = cl_sp->common.clid;
    hdr.qmi_instance = cl_sp->instance;
    hdr.service      = (qmux_service_e_type)cl_sp->service_id;

    status = qmi_mmode_svc_send_indication( &hdr, (uint16)cmd, ind );

    QM_MSG_LOW_3("qmi_nasi_send_ind() sending ind: cmd %d clnt %d status %d", cmd, hdr.client_id, status);
  }
  else
  {
    dsm_free_packet( &ind );
  }
}

/*===========================================================================

                   INTERNAL FUNCTION FORWARD DECLARATIONS

===========================================================================*/
static void qmi_nasi_sys_sel_pref_ind
(
  qmi_nasi_client_state_type *  cl_sp,
  uint8         emergency_mode,
  uint16        mode_pref,
  uint64        band_pref,
  uint16        prl_pref,
  uint16        roam_pref,
  sys_lte_band_mask_e_type        lte_band_pref,
  uint64        tds_band_pref,
  uint8         net_sel_mode_pref,
  uint32        srv_domain_pref,
  uint32        gw_acq_order_pref,
  sys_plmn_id_s_type plmn,
  cm_acq_pri_order_pref_s_type acq_order,
  sys_ue_usage_setting_e_type ue_usage_setting,
  sys_csg_id_type csg_id,
  sys_radio_access_tech_e_type csg_rat,
  sys_voice_domain_pref_e_type  voice_domain_pref  
);

static void qmi_nasi_current_nam_ind
(
  qmi_nasi_client_state_type *  cl_sp,
  uint8         current_nam_index
);

static void qmi_nasi_ddtm_ind
(
  qmi_nasi_client_state_type *  cl_sp,
  uint8         cur_ddtm_status,
  uint8         ddtm_pref,
  uint16        ddtm_act_mask,
  uint8         num_so_instances,
  uint16*       srv_option
);

static boolean qmi_nas_gen_report_ecio
(
  uint16        ecio,
  struct        report_status_s *p_rs,
  boolean       isHDR
);

static boolean qmi_nas_gen_report_sinr
(
 uint16 sinr,
 struct report_status_s *p_rs
);

static boolean qmi_nasi_include_3GPP2_time_zone
(
  uint8 *lp_sec,
  int8  *ltm_offset,
  uint8 *daylt_savings,
  cm_mm_msim_ss_info_s_type *p_ss_info
);

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
static boolean nasi_convert_mm_info_oper_name(
  uint8 *, mmgsdi_eons_encoding_enum_type,
  char *, uint8 *, uint8, uint8 );

#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */

#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE)
static void qmi_nasi_generate_get_preferred_nw_resp( mmgsdi_read_cnf_type *);
static void qmi_nasi_generate_get_forbidden_nw_resp( mmgsdi_read_cnf_type *);
static void qmi_nasi_generate_set_preferred_nw_resp( mmgsdi_write_cnf_type *);
static void qmi_nasi_generate_set_forbidden_nw_resp( mmgsdi_write_cnf_type *);
#endif /* defined(FEATURE_GSM) || defined(FEATURE_WCDMA) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */
void qmi_nas_set_dual_standby_pref_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
void qmi_nas_gen_dual_standby_pref_ind( qmi_cm_ph_info_s_type *p_info );
void qmi_nas_gen_data_subs_priority_ind( qmi_cm_ph_info_s_type *p_info );

qmi_error_type_v01 qmi_nas_generate_sys_info_msg(
    cm_mm_msim_ss_info_s_type *p_ss_info,
    qmi_cm_ph_info_s_type *p_ph_info,
  nas_get_sys_info_resp_msg_v01 * nas_get_sys_info_resp,
    sys_modem_as_id_e_type asubs_id
    );

void qmi_nas_populate_sys_info_ind(
    cm_mm_msim_ss_info_s_type *p_ss_info,
    qmi_cm_ph_info_s_type *p_ph_info,
  nas_sys_info_ind_msg_v01 * nas_sys_info_ind_msg,
    sys_modem_as_id_e_type asubs_id
    );

void qmi_nas_gen_sys_info_ind( cm_mm_msim_ss_info_s_type *p_ss_info, qmi_cm_ph_info_s_type *p_ph_info, boolean evt_reg_reject);
#if 0
boolean get_mode_pref( qmi_cm_ph_info_s_type *p_ph_info, struct access_tech_s *p );
#endif

void convert_cdma_mcc_2_ascii_mcc     ( char * p_mcc, word src );
void convert_cdma_mnc_2_ascii_mnc     ( char * p_mnc, byte src );
void convert_3gpp_plmn_2_ascii_mcc_mnc( char * p_mcc, char * p_mnc, sys_plmn_id_s_type p_plmn );
void qmi_nas_gen_managed_roaming_ind( cm_mm_msim_ss_info_s_type *p_ss_info, qmi_cm_ph_info_s_type *p_ph_info, enum qmi_nas_subs_e bound_subs );

void qmi_nas_set_plmn_blocking_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
sys_lac_type qmi_nas_get_lac( cm_mm_msim_ss_info_s_type *p_ss_info, uint8 stack_idx );
boolean qmi_nas_populate_rf_band_info_ind(
  cm_mm_msim_ss_info_s_type *p_ss_info,
  nas_rf_band_info_ind_msg_v01 *ind_msg,
  enum qm_stack_index_e stack
);
void qmi_nas_send_rf_band_info_ind(
  cm_mm_msim_ss_info_s_type  *p_ss_info,
  enum qm_stack_index_e  stack,
  qmi_nasi_client_state_type *cl_sp,
  int                         clid
);
void qmi_nas_gen_rf_band_info_ind( cm_mm_msim_ss_info_s_type *p_ss_info );

void qmi_nas_populate_network_reject_ind(
  cm_mm_msim_ss_info_s_type  *p_ss_info,
  struct nas_0068_ind_s *ind_msg,
  enum qm_stack_index_e  stack
);
void qmi_nas_send_network_reject_ind(
  cm_mm_msim_ss_info_s_type  *p_ss_info,
  enum qm_stack_index_e  stack,
  qmi_nasi_client_state_type *cl_sp,
  int                         clid
);
void qmi_nas_gen_network_reject_ind( cm_mm_msim_ss_info_s_type *p_ss_info );
void qmi_nasi_generate_get_plmn_name_resp( const mmgsdi_session_get_operator_name_cnf_type *name_cnf );
void qmi_nasi_generate_perform_network_scan_resp( const mmgsdi_session_get_operator_name_cnf_type *name_cnf );
void qmi_nasi_generate_perform_network_scan_resp_pci_scan( sys_found_plmn_list_u_type *plmn_list_rec );
void qmi_nasi_generate_get_home_network_resp( const mmgsdi_session_get_operator_name_cnf_type *name_cnf );
nas_lte_voice_status_enum_type_v01 qmi_nas_map_lte_voice_status_cm_to_qmi(cm_mm_msim_ss_info_s_type *p_ss_info);
nas_possible_reg_domain_enum_type_v01 qmi_nas_map_available_plmn_type_cm_to_qmi( sys_reg_domain_e_type available_plmn_type );
void qmi_nasi_generate_get_se13_plmn_name_resp( const mmgsdi_get_se13_plmn_names_cnf_type *name_cnf );
nas_tri_state_boolean_type_v01 qmi_nas_map_lte_eb_status_cm_to_qmi( sys_ims_lte_emerg_supp_e_type lte_ims_emerg_avail );

#ifdef FEATURE_TDSCDMA
void qmi_nasi_generate_get_tds_cell_and_position_info_rsp ( qmi_mmodei_msgr_type * msg_p);
#endif

void qmi_nasi_generate_get_embms_sig_rsp ( qmi_mmodei_msgr_type * msg_p);
void qmi_nas_generate_rtre_config_ind( qmi_cm_ph_info_s_type *p_ph_info  );
boolean qmi_nas_compare_mmgsdi_cm_network_rat( mmgsdi_rat_enum_type  rat, sys_radio_access_tech_e_type available_rat);

boolean qmi_nas_populate_ims_pref_status_ind(
  cm_domain_sel_ims_pref_info_s_type *ims_pref,
  nas_ims_pref_status_ind_msg_v01    *ind_msg
);
void qmi_nas_gen_ims_pref_status_ind( cm_domain_sel_ims_pref_info_s_type *ims_pref );
void qmi_nas_generate_get_ims_pref_resp( cm_domain_sel_ims_pref_rsp_msg_type_ext *ims_pref );

void qmi_nas_set_hplmn_search_timer_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
void qmi_nas_get_hplmn_search_timer_err_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
void qmi_nas_get_hplmn_search_timer_resp( uint32 timer_value );

void qmi_nas_generate_set_builtin_plmn_list_ind(qmi_error_type_v01 err, enum qmi_nas_subs_e as_id);

static sys_ue_usage_setting_e_type qmi_nas_map_ue_usage_qmi_to_cm( uint32 qmi_ue_usage );
nas_tri_state_boolean_type_v01 qmi_nas_map_lte_eab_status_cm_to_qmi( sys_lte_emerg_access_status_e_type cm_eab_status);
static void qmi_nas_update_lte_sib16_network_time_cache(lte_rrc_utc_time_update_ind_s *lte_sib16_nw_time);
static void qmi_nas_generate_lte_sib16_network_time_ind(void);
static uint8 qmi_nas_map_lte_sib16_dlsavingtime_lte_to_qmi( lte_rrc_utc_dayLightSaving_type_e dayLightSavingTime );
void qmi_nasi_generate_set_lte_band_priority_resp ( lte_rrc_band_pri_change_cnf_s * lte_band_pri_cnf );
static void qmi_nas_generate_lte_cphy_ca_ind(lte_cphy_ca_event_ind_s *cphy_ca);

void qmi_nasi_generate_set_e911_state_resp ( cm_ac_info_ind_s_type * e911_state_ind );
void qmi_nasi_generate_e911_state_ready_ind( cm_ac_info_ind_s_type * e911_state_ind );
void qmi_nasi_generate_get_lte_band_priority_list_resp( lte_rrc_get_band_pri_list_cnf_s * lte_get_band_pri_cnf );
void qmi_nasi_generate_get_serving_cell_sib_resp( lte_rrc_get_serv_cell_sib_cnf_s * lte_get_serv_cell_cnf );
void qmi_nasi_generate_get_serving_cell_sib_ind( lte_rrc_get_serv_cell_sib_cnf_s *lte_get_serv_cell_cnf, qmi_nasi_client_state_type *cl_sp );

void qmi_nasi_generate_get_embms_sig_ext_rsp ( qmi_mmodei_msgr_type * msg_p);
boolean qmi_nas_populate_current_plmn_name_ind(
  nas_current_plmn_name_ind_msg_v01 *ind_msg,
  cm_mm_msim_ss_info_s_type         *p_ss_info,
  uint8                              stack_idx,
  boolean                            ign_disp,
  mmgsdi_session_type_enum_type      session
);

void qmi_nasi_generate_subscription_change_ind( cm_subsc_chgnd_ind_msg_type * subs_change_ind );
void qmi_nas_set_drx_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
void qmi_nas_get_drx_err_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err );
void qmi_nas_get_drx_resp( sys_drx_cn_coefficient_s1_e_type drx_coefficient );

void qmi_nasi_generate_t3346_timer_status_change_ind( qmi_mmodei_msgr_type * msg_p );

void qmi_nas_map_standby_pref_cm_to_qmi ( uint32* qmi_standby_pref, sys_modem_dual_standby_pref_e_type cm_standby_pref );

static void qmi_nasi_generate_perform_incremental_network_scan_resp( void *, cm_ph_cmd_err_e_type );
static void qmi_nasi_generate_perform_incremental_network_scan_ind( const mmgsdi_session_get_operator_name_cnf_type *name_cnf);
static void qmi_nasi_generate_perform_incremental_network_scan_err_ind( nas_scan_status_enum_v01 scan_status );

static nas_lte_cphy_ca_bandwidth_enum_v01 qmi_nas_map_lte_bw_to_qmi_bw( lte_bandwidth_e dl_bandwidth );

static boolean qmi_nasi_get_csp_plmn_mode_val( qmi_nas_mmgsdi_session_e_type qmi_session, qmi_error_e_type* errval_p, uint8* plmn_mode_p );
void qmi_nasi_generate_get_csp_plmn_mode_bit_resp( void );

/*===========================================================================

                        EXTERNAL FUNCTION DEFINITIONS

===========================================================================*/

struct qmi_nas_cmstats_evt_cb_s
{
  cm_stats_event_e_type       evt;
  sys_modem_stats_info_s_type info;
};

/*===========================================================================
  FUNCTION QMI_NAS_CMSTATS_EVT_CB()

  DESCRIPTION
    Handle CM modem stats event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmstats_evt_cb( cm_stats_event_e_type evt, const sys_modem_stats_info_s_type *p_info )
{
  struct qmi_nas_cmstats_evt_cb_s *ptr;

  if ( p_info )
  {
    ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

    if ( ptr )
      {
      ptr->evt  = evt;
      ptr->info = *p_info;

      qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMSTATS_EVT_CB, ptr);
      }
      else
      {
		qmi_voice_mem_error();      
      }
    }
    else
    {
    QM_MSG_ERROR("qmi_nas_cmstats_evt_cb() p_info is null");
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMSTATS_EVT()

  DESCRIPTION
    Handle data queued for CM stats event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmstats_evt( qmi_mmode_cmd_enum_type cmd, void *user_data_ptr )
{
  struct qmi_nas_cmstats_evt_cb_s *ptr = (struct qmi_nas_cmstats_evt_cb_s *)user_data_ptr;

  if ( ptr )
  {
    qm_mstats_process_cm_modem_stats_event ( &ptr->info );
  }
  else
  {
    QM_MSG_ERROR("cm stats evt null pointer");
  }
}

#ifdef FEATURE_DUAL_SIM
struct qmi_nas_cmsubs_evt_cb_s
{
  cm_ph_event_e_type  evt;
  cm_subs_info_s_type info;
};

/*===========================================================================
  FUNCTION QMI_NAS_CMSUBS_EVT_CB()

  DESCRIPTION
    Handle CM subs event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmsubs_evt_cb( cm_ph_event_e_type evt, const cm_subs_info_s_type *p_info )
{
  struct qmi_nas_cmsubs_evt_cb_s *ptr;

  if ( p_info )
  {
    ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

    if ( ptr )
    {
      ptr->evt  = evt;
      ptr->info = *p_info;

      QM_MSG_HIGH_5("qmi_nas_cmsubs_evt_cb: DDS - %d, VID - %d, IMS LTE VID- %d, subs id - %d, IMS WLAN VID - %d", 
	  	  p_info->is_default_data, p_info->hw_id[SYS_VSID_APP_CS_VOICE],p_info->hw_id[SYS_VSID_APP_IMS_LTE], p_info->subscription_id, p_info->hw_id[SYS_VSID_APP_IMS_WLAN]);

      qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMSUBS_EVT_CB, ptr);
      }
      else
    {
		qmi_voice_mem_error();
      }
    }
    else
    {
    QM_MSG_ERROR("qmi_nas_cmsubs_evt_cb() p_info is null");
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_ASUBS_ID_MATCH_BOUND_SUBS()

  DESCRIPTION
    see if given asubs id and bound_subs match. assumption is that asubs id 1
    is always primary subs and 2 is always secondary

  RETURN VALUE
    TRUE if match, FALSE if not

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_asubs_id_match_bound_subs( sys_modem_as_id_e_type asubs_id, enum qmi_nas_subs_e bound_subs )
{
  if ( (asubs_id == SYS_MODEM_AS_ID_1 && bound_subs == QMI_NAS_SUBS_PRIMARY  ) 
  #ifdef  FEATURE_DUAL_SIM
  	||  (asubs_id == SYS_MODEM_AS_ID_2 && bound_subs == QMI_NAS_SUBS_SECONDARY) 
  #endif
  #ifdef FEATURE_TRIPLE_SIM
  	||  (asubs_id == SYS_MODEM_AS_ID_3 && bound_subs == QMI_NAS_SUBS_TERTIARY) 
  #endif
       )
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMSUBS_EVT()

  DESCRIPTION
    Handle data queued for CM subs event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmsubs_evt( qmi_mmode_cmd_enum_type cmd, void *user_data_ptr )
{
  struct qmi_nas_cmsubs_evt_cb_s *ptr = (struct qmi_nas_cmsubs_evt_cb_s*)user_data_ptr;

  qmi_nasi_client_state_type        *cl_sp = NULL;
  int                               client;
  dsm_item_type                     *ind = NULL;
  nas_subscription_info_ind_msg_v01 *ind_msg = NULL;

  if ( ptr )
  {
    QM_MSG_HIGH_3("cm subs evt %d %d %d", ptr->evt, ptr->info.subscription_id, ptr->info.is_operational);

    switch ( ptr->evt )
    {
      case CM_PH_EVENT_SUBSCRIPTION_PREF_INFO:
        if ( ptr->info.subscription_id == SYS_MODEM_AS_ID_1 || ptr->info.subscription_id == SYS_MODEM_AS_ID_2  ||
             ptr->info.subscription_id == SYS_MODEM_AS_ID_3)
        {
            ind_msg = ( nas_subscription_info_ind_msg_v01 *)modem_mem_alloc(sizeof(nas_subscription_info_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

            if(ind_msg != NULL)
          {
              boolean send_ind = FALSE;
              memset( ind_msg, 0x00, sizeof(nas_subscription_info_ind_msg_v01) );

            if(qmi_nasi_global.subs_info[ptr->info.subscription_id].is_priority_subs !=  ptr->info.is_priority_subs)
            {
              ind_msg->is_priority_subs = ptr->info.is_priority_subs ? NAS_PRIORITY_SUBSCRIPTION_TRUE_V01 : NAS_PRIORITY_SUBSCRIPTION_FALSE_V01;
              ind_msg->is_priority_subs_valid = TRUE;
              send_ind = TRUE;
              QM_MSG_HIGH_1("priority_subs info changed : %d", ptr->info.is_priority_subs);
            }
            if(qmi_nasi_global.subs_info[ptr->info.subscription_id].is_operational !=  ptr->info.is_operational)
            {
              ind_msg->is_active = ptr->info.is_operational ? NAS_SUBSCRIPTION_ACTIVE_V01 : NAS_SUBSCRIPTION_NOT_ACTIVE_V01;
              ind_msg->is_active_valid = TRUE;
              send_ind = TRUE;
              QM_MSG_HIGH_1("operational info changed: %d", ptr->info.is_operational);
            }
            if(qmi_nasi_global.subs_info[ptr->info.subscription_id].is_default_data !=  ptr->info.is_default_data)
            {
              ind_msg->is_default_data_subs = ptr->info.is_default_data;
              ind_msg->is_default_data_subs_valid = TRUE;
              if(ind_msg->is_default_data_subs)
              {
                ind_msg->dds_type = (nas_dds_type_enum_v01)ptr->info.dds_switch_type;
                ind_msg->dds_type_valid = TRUE;
              }
              send_ind = TRUE;
              QM_MSG_HIGH_2("default_data info changed : %d, dds_type : %d", ptr->info.is_default_data, ptr->info.dds_switch_type);
            }
            if(qmi_nasi_global.subs_info[ptr->info.subscription_id].hw_id[SYS_VSID_APP_CS_VOICE] !=  ptr->info.hw_id[SYS_VSID_APP_CS_VOICE])
            {  
              ind_msg->voice_system_id = (uint32) ptr->info.hw_id[SYS_VSID_APP_CS_VOICE];
              ind_msg->voice_system_id_valid = TRUE;
              send_ind = TRUE;
              QM_MSG_HIGH_1("voice_system_id info changed : %d", (uint32)ptr->info.hw_id[SYS_VSID_APP_CS_VOICE]);
            }
            if(qmi_nasi_global.subs_info[ptr->info.subscription_id].hw_id[SYS_VSID_APP_IMS_LTE] !=  ptr->info.hw_id[SYS_VSID_APP_IMS_LTE])
            {  
              ind_msg->lte_voice_system_id = (uint32) ptr->info.hw_id[SYS_VSID_APP_IMS_LTE];
              ind_msg->lte_voice_system_id_valid = TRUE;
              send_ind = TRUE;
              QM_MSG_HIGH_1("lte_voice_system_id info changed : %d", (uint32)ptr->info.hw_id[SYS_VSID_APP_IMS_LTE]);
            }
            if(qmi_nasi_global.subs_info[ptr->info.subscription_id].hw_id[SYS_VSID_APP_IMS_WLAN] !=  ptr->info.hw_id[SYS_VSID_APP_IMS_WLAN])
            {  
              ind_msg->wlan_voice_system_id = (uint32) ptr->info.hw_id[SYS_VSID_APP_IMS_WLAN];
              ind_msg->wlan_voice_system_id_valid = TRUE;
              send_ind = TRUE;
              QM_MSG_HIGH_1("wlan_voice_system_id info changed : %d", (uint32)ptr->info.hw_id[SYS_VSID_APP_IMS_WLAN]);
            }
            
            if( send_ind )
            {
            for ( client=0; client<NASI_MAX_CLIDS; client++ )
              {
              cl_sp = qmi_nas_state.client[client];

              if ( cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED )
              {
                if ( qmi_nas_asubs_id_match_bound_subs( ptr->info.subscription_id, cl_sp->report_status.bound_subs ) )
                  {
                    if ( cl_sp->report_status.report_subscription_info_ind )
                    {
                      ind = NULL;
                      if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                          QMI_IDL_INDICATION,
                                                          (uint16_t) QMI_NAS_SUBSCRIPTION_INFO_IND_MSG_V01,
                                                          (void *) ind_msg,
                                                          (uint32_t) sizeof( nas_subscription_info_ind_msg_v01 ),
                                                          &ind )
                                                        )
                      {
                        qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_SUBSCRIPTION_INFO_IND, ind );
                          }
                      else
                          {
                        QM_MSG_HIGH_1("qmi_nas_process_cmsubs_evt() idl_message_encode failed, no indication sent %d.", cl_sp->common.clid);
                      }
                      }
                    }
                  }
                }
              }
            }
            else
            {
              QM_MSG_ERROR_1("Alloc Failed for subsId:%d", ptr->info.subscription_id);
          }
            if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
            ind_msg = NULL;
            memscpy( &qmi_nasi_global.subs_info[ptr->info.subscription_id], sizeof(cm_subs_info_s_type), &ptr->info, sizeof(cm_subs_info_s_type) );
        }
        else
        {
          QM_MSG_ERROR_1("invalid subs id %d", ptr->info.subscription_id);
        }
        break;

      default:
        QM_MSG_ERROR_1("unknown cm subs evt %d", ptr->evt);
        break;
    }
  }
  else
  {
    QM_MSG_ERROR("cm subs evt null pointer");
  }
}
#endif

struct qmi_nas_cmph_evt_cb_s
{
  cm_ph_event_e_type evt;
  qmi_cm_ph_info_s_type  info;
};

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMPH_EVT()

  DESCRIPTION
    Handle data queued for CM PH event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmph_evt( qmi_mmode_cmd_enum_type cmd, void *user_data_ptr )
{
  struct qmi_nas_cmph_evt_cb_s *ptr = (struct qmi_nas_cmph_evt_cb_s*)user_data_ptr;
  cm_ph_event_e_type *p_evt;
  qmi_cm_ph_info_s_type  *p_info;
  boolean             copy_info = TRUE;
  int                 i;

  if (ptr)
  {
    p_evt  = &ptr->evt;
    p_info = &ptr->info;

    QM_MSG_HIGH_2("cm ph event %d asubs_id %d", *p_evt, p_info->asubs_id);

    switch (*p_evt)
    {
      case CM_PH_EVENT_CURR_NAM:
        qmi_nas_generate_current_nam_ind( p_info );
        break;

      case CM_PH_EVENT_DDTM_STATUS:
        qmi_nas_generate_ddtm_ind( p_info );
        break;

      case CM_PH_EVENT_INFO_AVAIL:
        if ( !qmi_nasi_global.rcvd_ss_info )
        {
          if ( !cm_ss_cmd_get_ss_info(qmi_nas_cmss_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id) )
          {
            QM_MSG_ERROR("cm_ss_cmd_get_ss_info failed");
          }

#ifdef FEATURE_DUAL_SIM
          if ( !cm_ph_cmd_get_subs_pref_info(qmi_nas_cmph_cmd_cb, (void*)SYS_MODEM_AS_ID_1, qmi_nasi_global.cm_clnt_id, SYS_MODEM_AS_ID_1 ) )
          {
            memset( &qmi_nasi_global.subs_info[SYS_MODEM_AS_ID_1], 0x00, sizeof(cm_subs_info_s_type) );
            QM_MSG_ERROR_1("cm_ph_cmd_get_subs_pref_info failed %d", SYS_MODEM_AS_ID_1);
          }

          if ( !cm_ph_cmd_get_subs_pref_info(qmi_nas_cmph_cmd_cb, (void*)SYS_MODEM_AS_ID_2, qmi_nasi_global.cm_clnt_id, SYS_MODEM_AS_ID_2 ) )
          {
            memset( &qmi_nasi_global.subs_info[SYS_MODEM_AS_ID_2], 0x00, sizeof(cm_subs_info_s_type) );
            QM_MSG_ERROR_1("cm_ph_cmd_get_subs_pref_info failed %d", SYS_MODEM_AS_ID_2);
          }
#ifdef FEATURE_TRIPLE_SIM
         if ( !cm_ph_cmd_get_subs_pref_info(qmi_nas_cmph_cmd_cb, (void*)SYS_MODEM_AS_ID_3, qmi_nasi_global.cm_clnt_id, SYS_MODEM_AS_ID_3 ) )
         {
           memset( &qmi_nasi_global.subs_info[SYS_MODEM_AS_ID_3], 0x00, sizeof(cm_subs_info_s_type) );
           QM_MSG_ERROR_1("cm_ph_cmd_get_subs_pref_info failed %d", SYS_MODEM_AS_ID_3);
         }
#endif

#endif
        }
        break;

      case CM_PH_EVENT_OPRT_MODE:
        
#ifdef FEATURE_DUAL_SIM
        if ( p_info->asubs_id == SYS_MODEM_AS_ID_2 )
        {
          if ( qmi_nasi_global.cm_ph_info2.oprt_mode != SYS_OPRT_MODE_ONLINE && p_info->oprt_mode == SYS_OPRT_MODE_ONLINE )
          {
            qmi_nas_generate_sys_sel_pref_ind( p_info );      
          }
        }
        else
#endif
#ifdef FEATURE_TRIPLE_SIM
        if (  p_info->asubs_id == SYS_MODEM_AS_ID_3 )
        {
           if ( qmi_nasi_global.cm_ph_info3.oprt_mode != SYS_OPRT_MODE_ONLINE && p_info->oprt_mode == SYS_OPRT_MODE_ONLINE )
           {
             qmi_nas_generate_sys_sel_pref_ind( p_info );      
           }
        }
        else
#endif
        {
          if ( qmi_nasi_global.cm_ph_info.oprt_mode != SYS_OPRT_MODE_ONLINE && p_info->oprt_mode == SYS_OPRT_MODE_ONLINE )
          {
            qmi_nas_generate_sys_sel_pref_ind( p_info );      
          }
        }
        if(p_info->oprt_mode == SYS_OPRT_MODE_LPM ||
           p_info->oprt_mode == SYS_OPRT_MODE_PWROFF ||
           p_info->oprt_mode == SYS_OPRT_MODE_RESET ||
           p_info->oprt_mode == SYS_OPRT_MODE_OFFLINE ||
           p_info->oprt_mode == SYS_OPRT_MODE_FTM)
        {
          QM_MSG_HIGH_3( "resetting call mode due to CM_PH_EVENT_OPRT_MODE %d - old valid: %d old call mode: %d", p_info->oprt_mode, qmi_nasi_global.call_mode_valid, qmi_nasi_global.call_mode );
          for(i = 0; i < QMI_NAS_SUBS_MAX; i++)
          {
            qmi_nasi_global.call_mode_valid[i] = FALSE;
            qmi_nasi_global.call_mode[i] = SYS_CALL_MODE_NORMAL;
          }
        }
        break;

      case CM_PH_EVENT_SYS_SEL_PREF:
        qmi_nas_generate_sys_sel_pref_ind( p_info );
        break;

      case CM_PH_EVENT_INFO:
        if ( qmi_nasi_global.inited == INIT_STATE_PENDING_MODE_CAPABILITY )
        {
          qmi_nasi_global.inited = INIT_STATE_INITIALIZED;
          (void)cm_client_act( qmi_nasi_global.cm_clnt_id );
        }
        break;

      case CM_PH_EVENT_NVRUIM_CONFIG_CHANGED:
        QM_MSG_HIGH_3("rtre_config prev %d new %d, rtre_control %d", qmi_nasi_global.cm_ph_info.rtre_config, p_info->rtre_config, p_info->rtre_control);
        if( qmi_nasi_global.rtre_set_status_pending == TRUE )
        {
          qmi_nasi_global.rtre_set_status_pending = FALSE;      // reset the RTRE config status
          qmi_nas_set_rtre_config_resp(TRUE);
        }
        qmi_nas_generate_rtre_config_ind( p_info );
        break;

      case CM_PH_EVENT_SUBSCRIPTION_AVAILABLE:
      case CM_PH_EVENT_SUBSCRIPTION_NOT_AVAILABLE:
      case CM_PH_EVENT_SUBSCRIPTION_CHANGED:
      case CM_PH_EVENT_TERMINATE_GET_NETWORKS:
        if ( qmi_nasi_global.net_scan_started )
        {
          if(qmi_nasi_global.incremental_net_scan_status != QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE)
          {
            QM_MSG_HIGH_1( "Sending incremental network scan abort ind on PH evt %d", *p_evt );
            qmi_nasi_generate_perform_incremental_network_scan_err_ind(NAS_SCAN_STATUS_ABORT_V01);
          } 
          else 
          {
            // use arbitrary error code to send RESP with failure
            qmi_nas_generate_net_scan_err_resp( NULL, CM_PH_CMD_ERR_GET_NETWORKS_S );
          }
        }
        break;

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
      case CM_PH_EVENT_AVAILABLE_NETWORKS_CONF:
	  if(p_info->p_available_networks)
	  {
            qmi_nas_generate_net_scan_resp_ext( p_info->p_available_networks, p_info->available_networks_list_cnf, p_info->network_list_type);
            modem_mem_free( p_info->p_available_networks, MODEM_MEM_CLIENT_QMI_MMODE );
            QM_MSG_HIGH( "Freeing available_networks");
	    p_info->p_available_networks = NULL;
          }
	  else 
          {
            QM_MSG_HIGH("NO available_networks");
	  }
        break;
#endif

      case CM_PH_EVENT_DATA_PRIORITY:
        qmi_nas_gen_data_subs_priority_ind( p_info );
        break;

      case CM_PH_EVENT_DUAL_STANDBY_PREF:
        qmi_nas_gen_dual_standby_pref_ind( p_info );
        break;

      case CM_PH_EVENT_GET_HPLMN_TIMER:
        qmi_nas_get_hplmn_search_timer_resp( p_info->hplmn_timer );
        break;

      case CM_PH_EVENT_GET_DRX_CNF:
        qmi_nas_get_drx_resp( p_info->drx_coefficient );
        break;

      default:
        copy_info = FALSE;
        break;
    }

    if ( copy_info )
    {
      QM_MSG_HIGH_1("cm_ph_evt->mode_capability = %d", p_info->mode_capability);
#ifdef FEATURE_DUAL_SIM
      if ( p_info->asubs_id == SYS_MODEM_AS_ID_2 ) // TODO: need to revisit this logic
      {
        qmi_nasi_global.rcvd_ph_info2 = TRUE;
        memscpy(&qmi_nasi_global.cm_ph_info2, sizeof(qmi_cm_ph_info_s_type),
                &ptr->info, sizeof(qmi_cm_ph_info_s_type));
        if ( p_info->mode_pref != CM_MODE_PREF_EMERGENCY )
          qmi_nasi_global.last_mode_pref2 = p_info->mode_pref;
      }
      else
#endif
#ifdef FEATURE_TRIPLE_SIM
      if ( p_info->asubs_id == SYS_MODEM_AS_ID_3 ) // TODO: need to revisit this logic
      {
        qmi_nasi_global.rcvd_ph_info3 = TRUE;
        memscpy( &qmi_nasi_global.cm_ph_info3, sizeof(qmi_cm_ph_info_s_type), &ptr->info, sizeof(qmi_cm_ph_info_s_type));
        if ( p_info->mode_pref != CM_MODE_PREF_EMERGENCY )
          qmi_nasi_global.last_mode_pref3 = p_info->mode_pref;
      }
      else
#endif
      {
        qmi_nasi_global.rcvd_ph_info = TRUE;
        memscpy(&qmi_nasi_global.cm_ph_info, sizeof(qmi_cm_ph_info_s_type), 
                &ptr->info, sizeof(qmi_cm_ph_info_s_type));
        if ( p_info->mode_pref != CM_MODE_PREF_EMERGENCY )
          qmi_nasi_global.last_mode_pref = p_info->mode_pref;
      }
    }
  }
  /*Else, ptr is NULL so we ignore the cm ph event*/
}

/*===========================================================================
  FUNCTION copy_cm_ph_info_to_qmi_cm_ph_info()

  DESCRIPTION
    Copy CM Ph Info into QMI data structure

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void copy_cm_ph_info_to_qmi_cm_ph_info(cm_ph_event_e_type evt, qmi_cm_ph_info_s_type  *info, const cm_ph_info_s_type *p_info)
{
  info->oprt_mode = p_info->oprt_mode;
  info->mode_capability = p_info->mode_capability;
  info->band_capability = p_info->band_capability;
  info->lte_band_capability = p_info->lte_band_capability;
  info->tds_band_capability = p_info->tds_band_capability;
  info->curr_nam = p_info->curr_nam;
  info->ue_usage_setting = p_info->ue_usage_setting;
  info->voice_domain_pref = p_info->voice_domain_pref;
  info->asubs_id = p_info->asubs_id;
  info->mode_pref = p_info->mode_pref;
  info->pref_term = p_info->pref_term;
  info->prl_pref = p_info->prl_pref;
  info->acq_order_pref = p_info->acq_order_pref;
  info->srv_domain_pref = p_info->srv_domain_pref;
  info->band_pref = p_info->band_pref;
  info->lte_band_pref = p_info->lte_band_pref;
  info->tds_band_pref = p_info->tds_band_pref;
  info->roam_pref = p_info->roam_pref;
  info->network_sel_mode_pref = p_info->network_sel_mode_pref;
  info->plmn = p_info->plmn;
  info->csg_id = p_info->csg_id;
  info->csg_rat = p_info->csg_rat;

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  if(evt == CM_PH_EVENT_AVAILABLE_NETWORKS_CONF)
  {
      info->p_available_networks = modem_mem_alloc( sizeof(sys_found_plmn_list_u_type), MODEM_MEM_CLIENT_QMI_MMODE );

    QM_MSG_HIGH( "Alloc for available_networks");
    if(info->p_available_networks)
    {
        if(p_info->network_list_type != CM_NETWORK_LIST_PCI_SCAN)
        {
      memscpy( info->p_available_networks, sizeof(p_info->available_networks),
                      &p_info->available_networks,  sizeof(p_info->available_networks));
    }
    else
    {
          memscpy( info->p_available_networks, sizeof(p_info->pci_plmn_list),
                           &p_info->pci_plmn_list,  sizeof(p_info->pci_plmn_list));
        }
    }
    else
    {
       qmi_voice_mem_error();
    }
 
  }

#endif

  info->network_list_type = p_info->network_list_type;
  info->available_networks_list_cnf = p_info->available_networks_list_cnf;
  info->acq_pri_order_pref = p_info->acq_pri_order_pref;
  info->drx_coefficient = p_info->drx_coefficient;
  info->rtre_config = p_info->rtre_config;
  info->rtre_control = p_info->rtre_control;
  info->ddtm_pref = p_info->ddtm_pref;
  info->cur_ddtm_status = p_info->cur_ddtm_status;
  info->ddtm_act_mask = p_info->ddtm_act_mask;
  info->ddtm_num_srv_opt = p_info->ddtm_num_srv_opt;

  memscpy( info->ddtm_srv_opt_list, sizeof(info->ddtm_srv_opt_list),
                  p_info->ddtm_srv_opt_list,  sizeof(p_info->ddtm_srv_opt_list) );

  info->standby_pref = p_info->standby_pref;
  info->active_subs = p_info->active_subs;
  info->default_voice_subs = p_info->default_voice_subs;
  info->default_data_subs = p_info->default_data_subs;
  info->priority_subs = p_info->priority_subs;
  info->priority_type = p_info->priority_type;
  info->hplmn_timer = p_info->hplmn_timer;
}

/*===========================================================================
  FUNCTION QMI_NAS_CMPH_EVT_CB()

  DESCRIPTION
    Queue CM PH events into DCC

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmph_evt_cb( cm_ph_event_e_type evt, const cm_ph_info_s_type *p_info)
{
  struct qmi_nas_cmph_evt_cb_s *ptr;

  if (p_info)
  {
    ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

    if ( ptr )
    {
      memset( ptr, 0x00, sizeof(*ptr) );

      ptr->evt = evt;
      copy_cm_ph_info_to_qmi_cm_ph_info(evt, &ptr->info, p_info);

      qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMPH_EVT_CB, ptr);
    }
    else
      {
	qmi_voice_mem_error();
    }
      }
  else
  {
    QM_MSG_ERROR("qmi_nas_cmph_evt_cb() p_info is null");
    }
  }

struct qmi_nas_cmph_cmd_cb_s
{
  void                *p_data;
  cm_ph_cmd_e_type     cmd;
  cm_ph_cmd_err_e_type err;
};

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMPH_CMD()

  DESCRIPTION
    Handle CM PH command callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmph_cmd( qmi_mmode_cmd_enum_type cmd_type, void *user_data_ptr )
{
  struct qmi_nas_cmph_cmd_cb_s *ptr = (struct qmi_nas_cmph_cmd_cb_s*)user_data_ptr;
  void                *p_data;
  cm_ph_cmd_e_type     cmd;
  cm_ph_cmd_err_e_type err;

  if ( ptr )
  {
    // cache to local variables for readability
    p_data = ptr->p_data;
    cmd    = ptr->cmd;
    err    = ptr->err;
    QM_MSG_HIGH_1("ph_cmd (%d) received", cmd);
    switch (cmd)
    {
      case CM_PH_CMD_SET_TRM_PRIORITY:
        qmi_nasi_avoid_tuneaway_resp(p_data, err);
        break;

      case CM_PH_CMD_DATA_PRIORITY:
        qmi_nasi_set_data_subs_priority_resp(p_data, err);
        break;

      case CM_PH_CMD_SET_SRVCC_CAPABILITY:
        qmi_nasi_set_srvcc_resp(p_data, err);
        break;

      case CM_PH_CMD_DATA_ROAMING:
        qmi_nasi_set_data_roaming_status_resp(p_data, err);
        break;

      case CM_PH_CMD_GET_NETWORKS:
        if(qmi_nasi_global.incremental_net_scan_status != QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE)
        {
          QM_MSG_HIGH_1( "Sending incremental network scan resp with err: %d", err);
          qmi_nasi_generate_perform_incremental_network_scan_resp(p_data, err);
        }
        else
        {
          qmi_nas_generate_net_scan_err_resp(p_data, err);
        }
        break;

      case CM_PH_CMD_SIGNAL_STRENGTH_DELTA:
        if( qmi_nasi_global.is_pending_config_sig_info && err == CM_PH_CMD_ERR_NOERR )
        {
          qmi_nasi_global.is_pending_config_sig_info = FALSE;
          qmi_nasi_global.is_set_cm_ph_cmd_signal_strength_delta = TRUE;
        }
        qmi_nas_generate_reg_attach_resp(p_data, err);
        break;

      case CM_PH_CMD_SYS_SEL_PREF:
      case CM_PH_CMD_NAM_SEL:
      case CM_PH_CMD_DDTM_PREF:
        qmi_nas_generate_reg_attach_resp(p_data, err);
        break;

      case CM_PH_CMD_INFO_GET:
        break;

      case  CM_PH_CMD_CHANGE_RTRE_CONFIG:
        if(  err != CM_PH_CMD_ERR_NOERR )
        {
          if( qmi_nasi_global.rtre_set_status_pending == TRUE )
          {
            qmi_nasi_global.rtre_set_status_pending = FALSE;      // reset the RTRE config status
            qmi_nas_set_rtre_config_resp(FALSE);
          }
        }
        break;

      case CM_PH_CMD_DUAL_STANDBY_PREF:
        qmi_nas_set_dual_standby_pref_resp( (qmi_cmd_buf_type*)p_data, err );
        break;

#ifdef FEATURE_DUAL_SIM
      case CM_PH_CMD_SUBSCRIPTION_INFO_GET:
        if ( err != CM_PH_CMD_ERR_NOERR )
        {
          if ( p_data == (void*)SYS_MODEM_AS_ID_1 )
          {
            memset( &qmi_nasi_global.subs_info[SYS_MODEM_AS_ID_1], 0x00, sizeof(cm_subs_info_s_type) );
            QM_MSG_ERROR_1("cm_ph_cmd_get_subs_pref_info failed %d", SYS_MODEM_AS_ID_1);
          }
          else if ( p_data == (void*)SYS_MODEM_AS_ID_2 )
          {
            memset( &qmi_nasi_global.subs_info[SYS_MODEM_AS_ID_2], 0x00, sizeof(cm_subs_info_s_type) );
            QM_MSG_ERROR_1("cm_ph_cmd_get_subs_pref_info failed %d", SYS_MODEM_AS_ID_2);
          }
#ifdef FEATURE_TRIPLE_SIM
         else if ( p_data == (void*)SYS_MODEM_AS_ID_3 )
         {
          memset( &qmi_nasi_global.subs_info[SYS_MODEM_AS_ID_3], 0x00, sizeof(cm_subs_info_s_type) );
          MSG_ERROR( "cm_ph_cmd_get_subs_pref_info failed %d", SYS_MODEM_AS_ID_3, 0, 0 );
         }
#endif
        }
        break;
#endif

      case CM_PH_CMD_PLMN_BLOCKING:
        qmi_nas_set_plmn_blocking_resp( (qmi_cmd_buf_type*)p_data, err );
        break;

      case CM_PH_CMD_SET_TL_IRAT_SEARCH_TIMER_REQ:
        qmi_nas_set_hplmn_irat_search_timer_resp( (qmi_cmd_buf_type*)p_data, err );
        break;

      case CM_PH_CMD_AVOID_SYS:
        qmi_nas_generate_cdma_avoid_system_resp(p_data, err);
        break;

      case CM_PH_CMD_SET_HPLMN_TIMER:
        qmi_nas_set_hplmn_search_timer_resp( (qmi_cmd_buf_type*)p_data, err );
        break;

      case CM_PH_CMD_GET_HPLMN_TIMER:
        qmi_nas_get_hplmn_search_timer_err_resp( (qmi_cmd_buf_type*)p_data, err );
        break;

      case CM_PH_CMD_SET_DRX_REQ:
        qmi_nas_set_drx_resp( (qmi_cmd_buf_type*)p_data, err );
        break;

      case CM_PH_CMD_GET_DRX_REQ:
        qmi_nas_get_drx_err_resp( (qmi_cmd_buf_type*)p_data, err );
        break;

      case CM_PH_CMD_SET_ROAMING_PREF:
        qmi_nasi_set_voice_roaming_status_resp( (qmi_cmd_buf_type*)p_data, err );
        break;
		
      default:
        /*[QMINAS] Unexpected ph_cmd (%d) received*/
        break;
    }
  }
  /*If cmd doesnot get printed, it means ptr is NULL*/
}

/*===========================================================================
  FUNCTION QMI_NAS_CMPH_CMD_CB()

  DESCRIPTION
    Handle CM PH command callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmph_cmd_cb( void *p_data, cm_ph_cmd_e_type cmd, cm_ph_cmd_err_e_type err)
{
  struct qmi_nas_cmph_cmd_cb_s *ptr;

  ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ptr )
    {
    ptr->p_data = p_data;
    ptr->cmd    = cmd;
    ptr->err    = err;

    qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMPH_CMD_CB, ptr);
  }
  else
  {
	qmi_voice_mem_error();
  }
}

struct qmi_nas_timer_cmd_cb_s
{
  uint32  timer_id;
};

/*===========================================================================
  FUNCTION QMI_NAS_TIMER_CMD_CB()

  DESCRIPTION
    Handle QMI NAS TIMER command callback, queues an item to MMODE_QMI task

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_timer_cmd_cb( timer_cb_data_type  user_data )
{  
  struct qmi_nas_timer_cmd_cb_s  *ptr = NULL;

  ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

  if (ptr) 
  {
    ptr->timer_id = (uint32)user_data;         
    // user data contains the timer event type, so convert to uint32 and assign to evt_type

    qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_TIMER_EVT_CB, ptr);

    QM_MSG_HIGH("qmi_nasi_timer_cmd_cb cmd posted to mmode task");
  }
  else 
  {
	qmi_voice_mem_error();
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_TIMER_EVT()

  DESCRIPTION
    Handle data queued for timer event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_timer_evt( qmi_mmode_cmd_enum_type cmd_type, void *user_data )
{
  struct qmi_nas_timer_cmd_cb_s *timer_cmd = (struct qmi_nas_timer_cmd_cb_s *)user_data;

  if(timer_cmd != NULL)
  {
    QM_MSG_HIGH_1("qmi_nas_process_timer_evt, timer_id :%d",timer_cmd->timer_id);
    switch (timer_cmd->timer_id)
    {
      case QM_TIMER_TIB:
        qm_tib_process_timer();
        break;

      default:
        /*unhandled timer id*/
        break;
    }
  }
  /*If Else, then else qmi_nas_process_timer_evt processing timer_cmd is NULL*/
}

/*===========================================================================
  FUNCTION QMI_NAS_POST_INTERNAL_BUILTIN_PLMN_CMD()

  DESCRIPTION
    Post internal command 

  PARAMETERS
    as_id: uint8

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_post_internal_builtin_plmn_cmd
(
  uint8 as_id
)
{
  qmi_mmode_common_cmd_type* data_ptr;

  data_ptr = (qmi_mmode_common_cmd_type*) QMI_NAS_MEM_ALLOC( sizeof( qmi_mmode_common_cmd_type ) );
  if( NULL == data_ptr )
  {
    qmi_voice_mem_fatal();
    return;
  }

  data_ptr->id = QMI_MMODE_NAS_INT_BUILTIN_PLMN_CB;
  data_ptr->data.nas_int_info.bplmn_list_cb.as_id = as_id;

  qmi_mmode_send_cmd(QMI_MMODE_CMD_NAS_INTERNAL_CB, data_ptr);
}



/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_INTERNAL_CMD()

  DESCRIPTION
    Handle internal commands

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_internal_cmd( qmi_mmode_cmd_enum_type cmd_type, void *user_data )
{

  qmi_mmode_common_cmd_type* data_ptr = (qmi_mmode_common_cmd_type *) user_data;;

  if(data_ptr == NULL )
  {
    QM_MSG_HIGH("Internal data null");
    return;
  }

  switch(data_ptr->id)
  {
     case QMI_MMODE_NAS_INT_BUILTIN_PLMN_CB:
      qmi_nas_generate_set_builtin_plmn_list_ind(QMI_ERR_NONE_V01, (enum qmi_nas_subs_e)data_ptr->data.nas_int_info.bplmn_list_cb.as_id);
      break;

    default:
      QM_MSG_ERROR("Unsupported qmi-nas internal cmd");
      break;
  }

} /* qmi_nas_process_internal_cmd */ 

#ifdef FEATURE_MODEM_CONFIG_REFRESH
/*===========================================================================
  FUNCTION QMI_NAS_MCFG_REFRESH_EVT()

  DESCRIPTION:
  This function cmd handler to process NV refresh events

  INPUT/OUTPUT PARAMETERS:
  cmd - command ID
  user_data_ptr - User data provided by the caller routine

  RETURN VALUE:
  None

  SIDE EFFECTS:
  None
===========================================================================*/
void qmi_nas_mcfg_refresh_evt
(
  qmi_mmode_cmd_enum_type cmd,
  void                    * user_data_ptr
)
{
  mcfg_refresh_info_s_type     *event_info     = NULL;
     
  if(NULL == user_data_ptr)
  {
    QM_MSG_ERROR("qmi_nas_mcfg_refresh_evt() NULL user_data_ptr");
    return;
  }
  
  event_info =  (mcfg_refresh_info_s_type  *) user_data_ptr;

  QM_MSG_HIGH_2("qmi_nas_mcfg_refresh_evt() updating NV/EFS cache for subs %d (ref %d)", (uint16)event_info->sub_index, event_info->reference_id);
  qmi_efs_refresh_mcfg((uint16)event_info->sub_index);
  
  if(mcfg_refresh_done(event_info->reference_id) == FALSE)
  {
    QM_MSG_ERROR("qmi_nas_mcfg_refresh_evt() mcfg_refresh_done failed");
  }
  else
  {
  QM_MSG_HIGH_1("qmi_nas_mcfg_refresh_evt() finished (ref %d)", event_info->reference_id);
  }

}/*qmi_nas_mcfg_refresh_evt*/
#endif // FEATURE_MODEM_CONFIG_REFRESH

/*===========================================================================
  FUNCTION qmi_nas_get_reg_state()

  DESCRIPTION
    get registration state based on CM SS event

  RETURN VALUE
    registration state

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
nas_registration_state_enum_v01 qmi_nas_get_reg_state( cm_mm_msim_ss_info_s_type *p_ss_info, qmi_cm_ph_info_s_type *p_ph_info )
{
  nas_registration_state_enum_v01 state;
  sys_sim_state_e_type      sim_state;
  sys_srv_status_e_type     srv_status       = p_ss_info->stack_info[STACK_INDEX_0].srv_status;
  boolean                   is_sys_forbidden = p_ss_info->stack_info[STACK_INDEX_0].is_sys_forbidden;

  if ( p_ss_info->stack_info[STACK_INDEX_0].mode_info.gw_info.sim_state == SYS_SIM_STATE_NOT_AVAILABLE )
  {
    if( p_ss_info->asubs_id >= QMI_NAS_SUBS_MAX || p_ss_info->asubs_id<= QMI_NAS_SUBS_NONE)
    {
      QM_MSG_FATAL_1("Invalid asubs_id %d", p_ss_info->asubs_id);
      return NAS_REGISTRATION_UNKNOWN_V01;
    }
    sim_state = qmi_nasi_global.sim_state_before_not_avail[p_ss_info->asubs_id];
    }
    else
    {
    sim_state = p_ss_info->stack_info[STACK_INDEX_0].mode_info.gw_info.sim_state;
  }

  switch ( srv_status )
  {
    case SYS_SRV_STATUS_NO_SRV:
    case SYS_SRV_STATUS_LIMITED:
    case SYS_SRV_STATUS_LIMITED_REGIONAL:
      if ( sim_state == SYS_SIM_STATE_CS_INVALID || sim_state == SYS_SIM_STATE_CS_PS_INVALID || is_sys_forbidden )
      {
        state = NAS_REGISTRATION_DENIED_V01;
      }
      else
      {
        if ( p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL ||
             p_ph_info->oprt_mode == SYS_OPRT_MODE_LPM          ||
             p_ph_info->oprt_mode == SYS_OPRT_MODE_FTM          ||
             p_ph_info->oprt_mode == SYS_OPRT_MODE_OFFLINE      ||
             p_ph_info->oprt_mode == SYS_OPRT_MODE_OFFLINE_AMPS ||
             p_ph_info->oprt_mode == SYS_OPRT_MODE_OFFLINE_CDMA )
        {
          state = NAS_NOT_REGISTERED_V01;
        }
        else
        {
          state = NAS_NOT_REGISTERED_SEARCHING_V01;
        }
      }
      break;

    case SYS_SRV_STATUS_PWR_SAVE:
      if ( sim_state == SYS_SIM_STATE_CS_INVALID || sim_state == SYS_SIM_STATE_CS_PS_INVALID || is_sys_forbidden )
      {
        state = NAS_REGISTRATION_DENIED_V01;
      }
      else
      {
        state = NAS_NOT_REGISTERED_V01;
      }
      break;

    case SYS_SRV_STATUS_SRV:
      state = NAS_REGISTERED_V01;
      break;

    default:
      QM_MSG_HIGH("Unhandled srv_status in get_registration_info");
      state = NAS_REGISTRATION_UNKNOWN_V01;
  }

  if ( p_ss_info->asubs_id == SYS_MODEM_AS_ID_1 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
    {
      state = NAS_REGISTERED_V01;
    }
  }

  return state;
}

/*===========================================================================
  FUNCTION qmi_nas_get_cs_attach_state()

  DESCRIPTION
    get cs attach state based on CM SS event

  RETURN VALUE
    registration state

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_nasi_cs_attach_e_type qmi_nas_get_cs_attach_state( cm_mm_msim_ss_info_s_type *p_info )
{
  qmi_nasi_cs_attach_e_type state;
  sys_srv_domain_e_type     srv_domain = p_info->stack_info[STACK_INDEX_0].srv_domain;

  switch ( srv_domain )
  {
    case SYS_SRV_DOMAIN_NO_SRV:
    case SYS_SRV_DOMAIN_CAMPED:
    case SYS_SRV_DOMAIN_PS_ONLY:
      state = NASI_CS_DETACHED;
      break;

    case SYS_SRV_DOMAIN_CS_ONLY:
    case SYS_SRV_DOMAIN_CS_PS:
      state = NASI_CS_ATTACHED;
      break;

    default:
      state = NASI_CS_UNKNOWN;
      break;
  }

  return state;
}

/*===========================================================================
  FUNCTION qmi_nas_get_ps_attach_state()

  DESCRIPTION
    get ps attach state based on CM SS event

  RETURN VALUE
    registration state

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_nasi_ps_attach_e_type qmi_nas_get_ps_attach_state( cm_mm_msim_ss_info_s_type *p_info )
{
  qmi_nasi_ps_attach_e_type state;
  sys_srv_domain_e_type     srv_domain = p_info->stack_info[STACK_INDEX_0].srv_domain;

  switch ( srv_domain )
  {
    case SYS_SRV_DOMAIN_NO_SRV:
    case SYS_SRV_DOMAIN_CAMPED:
    case SYS_SRV_DOMAIN_CS_ONLY:
      state = NASI_PS_DETACHED;
      break;

    case SYS_SRV_DOMAIN_PS_ONLY:
    case SYS_SRV_DOMAIN_CS_PS:
      state = NASI_PS_ATTACHED;
      break;

    default:
      state = NASI_PS_UNKNOWN;
      break;
  }

  if ( p_info->asubs_id == SYS_MODEM_AS_ID_1 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
    {
      state = NASI_PS_ATTACHED;
    }
  }

  return state;
}

/*===========================================================================
  FUNCTION qmi_nas_get_reg_network()

  DESCRIPTION
    get registered network info based on CM SS event

  RETURN VALUE
    registration state

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_nasi_reg_net_e_type qmi_nas_get_reg_network( cm_mm_msim_ss_info_s_type *p_info )
{
  qmi_nasi_reg_net_e_type network;
  sys_sys_mode_e_type     sys_mode = p_info->stack_info[STACK_INDEX_0].sys_mode;

  switch ( sys_mode )
  {
    case SYS_SYS_MODE_CDMA:
    case SYS_SYS_MODE_HDR:
      network = NASI_REG_NET_3GPP2;
      break;

    case SYS_SYS_MODE_GSM:
    case SYS_SYS_MODE_WCDMA:
    case SYS_SYS_MODE_GW:
    case SYS_SYS_MODE_LTE:
      network = NASI_REG_NET_3GPP;
      break;

    default:
      network = NASI_REG_NET_UNKNOWN;
      break;
  }

  if ( p_info->asubs_id == SYS_MODEM_AS_ID_1 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
    {
      network = NASI_REG_NET_3GPP2;
    }
  }

  return network;
}

/*===========================================================================
  FUNCTION qmi_nas_get_in_use_radio_if()

  DESCRIPTION
    get radio interfaces in use based on CM SS event

  RETURN VALUE
    number of radio interfaces in use

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
int qmi_nas_get_in_use_radio_if(
  cm_mm_msim_ss_info_s_type * p_info,
  nas_radio_if_enum_v01     * p_radio_if_lst
)
{
  int i = 0;

  if ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE) != QMI_NAS_RADIO_IF_NONE )
    {
    *(p_radio_if_lst+i) = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
      i++;
    }

  if ( p_info->asubs_id == SYS_MODEM_AS_ID_1 )
    {
    if ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
    {
      *(p_radio_if_lst+i) = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,FALSE);
      i++;
    }
  }

  if ( i == 0 ) // if no service, populate QMI_NAS_RADIO_IF_NONE
  {
    *(p_radio_if_lst+i) = (uint8)QMI_NAS_RADIO_IF_NONE;
    i++;
  }

  return i;
}
/*===========================================================================
  FUNCTION qmi_nas_get_data_capability()

  DESCRIPTION
    get data capabilities in use based on CM SS event

  RETURN VALUE
    number of data capabilities in use

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
int qmi_nas_get_data_capability(
  cm_mm_msim_ss_info_s_type     * p_info,
  nas_data_capabilites_enum_v01 * p_data_capa_lst
)
{
  int cnt = 0;
  sys_hs_ind_e_type        hs_ind;
  sys_srv_domain_e_type    srv_capability = p_info->stack_info[STACK_INDEX_0].srv_capability;
  sys_egprs_support_e_type egprs_supp = p_info->stack_info[STACK_INDEX_0].cell_srv_ind.egprs_supp;

  hs_ind = p_info->stack_info[STACK_INDEX_0].cell_srv_ind.hs_ind;

  switch ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE) )
  {
    case QMI_NAS_RADIO_IF_GSM:

      switch ( srv_capability )
      {
        case SYS_SRV_DOMAIN_PS_ONLY:
        case SYS_SRV_DOMAIN_CS_PS:
          if ( egprs_supp )
            p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EDGE_V01;
          else
            p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_GPRS_V01;
          break;

        case SYS_SRV_DOMAIN_CS_ONLY:
          p_data_capa_lst[cnt++]   = NAS_DATA_CAPABILITIES_GSM_V01;
          break;

        default:
          QM_MSG_HIGH_1("unexpected domain %d", srv_capability);
          break;
      }
      break;

    case QMI_NAS_RADIO_IF_UMTS:

      switch ( srv_capability )
      {
        case SYS_SRV_DOMAIN_PS_ONLY:
        case SYS_SRV_DOMAIN_CS_PS:

          switch ( hs_ind )
          {
            case SYS_HS_IND_HSDPA_SUPP_CELL: /* Cell supports HSDPA */
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              break;

            case SYS_HS_IND_HSUPA_SUPP_CELL: /* Cell supports HSUPA. assume DPA as default */
            case SYS_HS_IND_HSDPA_HSUPA_SUPP_CELL: /* Cell supports HSDPA and HSUPA */
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSUPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              break;

            case SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL:
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              break;

            case SYS_HS_IND_HSDPAPLUS_SUPP_CELL:
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_PLUS_V01;
              break;

            case SYS_HS_IND_HSDPAPLUS_HSUPA_SUPP_CELL:
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSUPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_PLUS_V01;
              break;

            case SYS_HS_IND_DC_HSDPAPLUS_SUPP_CELL:
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_PLUS_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_DC_HSDPA_PLUS_V01;
              break;

            case SYS_HS_IND_DC_HSDPAPLUS_HSUPA_SUPP_CELL:
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSUPA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_WCDMA_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_HSDPA_PLUS_V01;
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_DC_HSDPA_PLUS_V01;
              break;

            default: /* Add support for any new values */
              QM_MSG_ERROR_2("unknown HS capability %d info from %d", srv_capability, hs_ind);
              break;
          }
          break;

        default:
          QM_MSG_HIGH_1("unexpected domain %d", srv_capability);
          break;
      }
      break;

    case QMI_NAS_RADIO_IF_CDMA20001X:
      // P_rev: 3-5 => Low speed data
      // P_rev: 6 and greater => High speed data
      if ( p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.p_rev_in_use >= 3 )
      {
        p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_CDMA_V01;
      }
      break;

    case QMI_NAS_RADIO_IF_CDMA20001XEVDO:

      switch ( p_info->stack_info[STACK_INDEX_0].rat_mode_info.hdr_mode_info.hdr_active_prot )
      {
        case SYS_ACTIVE_PROT_NONE:
        case SYS_ACTIVE_PROT_HDR_START:
          break;

        case SYS_ACTIVE_PROT_HDR_REL0: /* Cell supports HDR Rev0 */
          p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EVDO_REV_O_V01;
          break;

        case SYS_ACTIVE_PROT_HDR_RELA: /* Cell supports HDR RevA */
          p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EVDO_REV_A_V01;
          break;

        case SYS_ACTIVE_PROT_HDR_RELB: /* Cell supports HDR RevB */
          p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EVDO_REV_B_V01;
          break;

        default: /* Add support for any new values */
          QM_MSG_ERROR_1("unknown hdr protocol %d", p_info->stack_info[STACK_INDEX_0].rat_mode_info.hdr_mode_info.hdr_active_prot);
          break;
      }
      break;

    case QMI_NAS_RADIO_IF_LTE:

      p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_LTE_V01;
      break;

    default:
      QM_MSG_ERROR_3("service status %d", qmi_nas_sys_mode_2_radio_if(p_info, STACK_INDEX_0, FALSE), 0, 0 );
      break;
  }

  if ( p_info->asubs_id == SYS_MODEM_AS_ID_1 )
  {
    switch ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,TRUE) )
    {
      case QMI_NAS_RADIO_IF_CDMA20001XEVDO:

        if ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE) != QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          switch ( p_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_active_prot )
          {
            case SYS_ACTIVE_PROT_HDR_REL0: /* Cell supports HDR Rev0 */
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EVDO_REV_O_V01;
              break;

            case SYS_ACTIVE_PROT_HDR_RELA: /* Cell supports HDR RevA */
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EVDO_REV_A_V01;
              break;

            case SYS_ACTIVE_PROT_HDR_RELB: /* Cell supports HDR RevB */
              p_data_capa_lst[cnt++] = NAS_DATA_CAPABILITIES_EVDO_REV_B_V01;
              break;

            default: /* Add support for any new values */
              QM_MSG_ERROR_1("unknown hdr protocol %d", p_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_active_prot);
              break;
          }
        }
        break;

      default:
        QM_MSG_ERROR("hybrid stack not in service");
        break;
    }
  }

  return cnt;
}

/*===========================================================================
  FUNCTION qmi_nas_get_roaming_indicator()

  DESCRIPTION
    get roaming indicator based on CM SS event

  RETURN VALUE
    roaming indicator

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
uint8 qmi_nas_get_roaming_indicator( cm_mm_msim_ss_info_s_type *p_info )
{
  uint8                  roam_ind;
  sys_roam_status_e_type roam_status = p_info->stack_info[STACK_INDEX_0].roam_status;

  switch ( roam_status )
  {
    case SYS_ROAM_STATUS_OFF: roam_ind = 1; /* home */       break;
    case SYS_ROAM_STATUS_ON:  roam_ind = 0; /*roaming */     break;
    default:                  roam_ind = (uint8)roam_status; break;
  }

  if ( p_info->asubs_id == SYS_MODEM_AS_ID_1 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
    {
      switch ( p_info->stack_info[STACK_INDEX_1].roam_status )
      {
        case SYS_ROAM_STATUS_OFF: roam_ind = 1; /* home */                   break;
        case SYS_ROAM_STATUS_ON:  roam_ind = 0; /*roaming */                 break;
        default:                  roam_ind = (uint8)p_info->stack_info[STACK_INDEX_1].roam_status; break;
      }
    }
  }

  return roam_ind;
}

/*===========================================================================
  FUNCTION qmi_nas_get_roaming_ind_list()

  DESCRIPTION
    get roaming indicator list based on CM SS event

  RETURN VALUE
    number of elements

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
uint8 qmi_nas_get_roaming_ind_list(
  cm_mm_msim_ss_info_s_type      * p_info,
  nas_roaming_indicator_type_v01 * p_roam_ind
)
{
  uint8                  cnt         = 0;
  sys_roam_status_e_type roam_status = p_info->stack_info[STACK_INDEX_0].roam_status;
  sys_srv_status_e_type  srv_status  = p_info->stack_info[STACK_INDEX_0].srv_status;
  enum qmi_nas_radio_if_e my_radio_if;

  if ( srv_status != SYS_SRV_STATUS_NO_SRV && srv_status != SYS_SRV_STATUS_PWR_SAVE )
  {
    if ( roam_status != SYS_ROAM_STATUS_UNKNOWN )
  {
      p_roam_ind->radio_if = (nas_radio_if_enum_v01) qmi_nas_sys_mode_2_radio_if( p_info, STACK_INDEX_0, FALSE );

    switch ( roam_status )
    {
      case SYS_ROAM_STATUS_OFF:   
	  	   p_roam_ind->roaming_indicator = NAS_ROAMING_IND_OFF_V01;
	       break; /* home */
      case SYS_ROAM_STATUS_ON:    
	  	   p_roam_ind->roaming_indicator = NAS_ROAMING_IND_ON_V01;
	       break; /* roaming */
      default:
        p_roam_ind->roaming_indicator = (nas_roaming_indicator_enum_v01) roam_status;
          QM_MSG_HIGH_1("ENUM, %d, being returned as roaming indicator.", p_roam_ind->roaming_indicator);
        break;
    }

    cnt++;
    p_roam_ind++;
  }
    else
    {
      QM_MSG_HIGH("roaming indicator UNKNOWN not being included");
    }
  }

  if ( p_info->asubs_id == SYS_MODEM_AS_ID_1 )
  {
    my_radio_if = qmi_nas_sys_mode_2_radio_if( p_info, STACK_INDEX_1, TRUE );

    if ( my_radio_if == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
    {
      if ( p_info->stack_info[STACK_INDEX_1].roam_status != SYS_ROAM_STATUS_UNKNOWN )
  {
      p_roam_ind->radio_if = (nas_radio_if_enum_v01) my_radio_if;

        switch ( p_info->stack_info[STACK_INDEX_1].roam_status )
      {
        case SYS_ROAM_STATUS_OFF:   p_roam_ind->roaming_indicator = NAS_ROAMING_IND_OFF_V01;                                  break; /* home */
        case SYS_ROAM_STATUS_ON:    p_roam_ind->roaming_indicator = NAS_ROAMING_IND_ON_V01;                                   break; /* roaming */
        default:
            p_roam_ind->roaming_indicator = (nas_roaming_indicator_enum_v01) p_info->stack_info[STACK_INDEX_1].roam_status;
            QM_MSG_HIGH_1("ENUM, %d, being returned as roaming_indicator.", p_roam_ind->roaming_indicator);
          break;
      }

      cnt++;
      p_roam_ind++;
    }
      else
      {
        QM_MSG_HIGH("roaming indicator UNKNOWN not being included");
      }
    }
  }

  return cnt;
}

/*===========================================================================
  FUNCTION qmi_nas_get_def_roam_ind()

  DESCRIPTION
    Gives the default roaming indicator based on CM SS event

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
uint8 qmi_nas_get_def_roam_ind( cm_mm_msim_ss_info_s_type *p_info )
{
  uint8 def_roam_ind;

  switch ( p_info->def_roam_ind )
  {
    case SYS_ROAM_STATUS_OFF: def_roam_ind = 1; /* home */                break;
    case SYS_ROAM_STATUS_ON:  def_roam_ind = 0; /* roaming */             break;
    default:                  def_roam_ind = (uint8)p_info->def_roam_ind; break;
  }

  return def_roam_ind;
}

/*===========================================================================
  FUNCTION qmi_nas_populate_serving_system_ind_msg()

  DESCRIPTION
    populatest serving system ind msg structure based on given
    CM SS and CM PH event

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_serving_system_ind_msg(
  cm_mm_msim_ss_info_s_type           * p_ss_info,
  qmi_cm_ph_info_s_type              * p_ph_info,
  nas_serving_system_ind_msg_v01 * p_msg,
  boolean                          recreating_msg,
  sys_modem_as_id_e_type           asubs_id
)
{
  enum qm_stack_index_e      stack          = STACK_INDEX_0;

  sys_sys_id_s_type         sys_id         = p_ss_info->stack_info[stack].sys_id;
  sys_mm_information_s_type mm_information = p_ss_info->stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information;
  sys_lac_type              lac            = qmi_nas_get_lac( p_ss_info, stack );
  sys_lac_type              lac_tac        = p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_LTE ? p_ss_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.tac : qmi_nas_get_lac( p_ss_info, stack );
  sys_cell_id_type          cell_id        = p_ss_info->stack_info[STACK_INDEX_0].cell_info.cell_id;
  uint16                    psc            = p_ss_info->stack_info[STACK_INDEX_0].cell_info.psc;
  sys_dtm_support_e_type    dtm_supp       = p_ss_info->stack_info[STACK_INDEX_0].cell_srv_ind.dtm_supp;
  sys_srv_status_e_type     srv_status     = p_ss_info->stack_info[STACK_INDEX_0].srv_status;
  sys_srv_domain_e_type     srv_capability = p_ss_info->stack_info[STACK_INDEX_0].srv_capability;
  mmgsdi_session_type_enum_type session    = MMGSDI_GW_PROV_PRI_SESSION;
  sys_domain_access_bar_s_type  cell_access_info = p_ss_info->stack_info[STACK_INDEX_0].cell_access_info;

  if( p_ss_info->asubs_id == SYS_MODEM_AS_ID_2 )
  {
    session        = MMGSDI_GW_PROV_SEC_SESSION;
  }

  {
    p_msg->serving_system.registration_state = qmi_nas_get_reg_state( p_ss_info, p_ph_info );
    p_msg->serving_system.cs_attach_state    = (uint8) qmi_nas_get_cs_attach_state( p_ss_info );
    p_msg->serving_system.ps_attach_state    = (uint8) qmi_nas_get_ps_attach_state( p_ss_info );
    p_msg->serving_system.selected_network   = (uint8) qmi_nas_get_reg_network( p_ss_info );
    p_msg->serving_system.radio_if_len       = (uint8) qmi_nas_get_in_use_radio_if( p_ss_info, &p_msg->serving_system.radio_if[0] );
  } // TLV 01 Serving System

  if ( p_ss_info->stack_info[STACK_INDEX_0].srv_status     != SYS_SRV_STATUS_NO_SRV && p_ss_info->stack_info[STACK_INDEX_0].srv_status  != SYS_SRV_STATUS_PWR_SAVE )
  {
    p_msg->roaming_indicator       = qmi_nas_get_roaming_indicator( p_ss_info );
    if ( (uint8)p_msg->roaming_indicator != (uint8)SYS_ROAM_STATUS_UNKNOWN )
    {
      p_msg->roaming_indicator_valid = TRUE;
    }
  }

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    p_msg->data_capabilities_len   = (uint8) qmi_nas_get_data_capability( p_ss_info, &p_msg->data_capabilities[0] );
    p_msg->data_capabilities_valid = TRUE;
  }
  else
  {
    p_msg->data_capabilities_len = 0;
    p_msg->data_capabilities_valid = TRUE;
  }// TLV 11

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
  if ( srv_status ==  SYS_SRV_STATUS_SRV     ||
       srv_status ==  SYS_SRV_STATUS_LIMITED ||
       srv_status ==  SYS_SRV_STATUS_LIMITED_REGIONAL )
  {
    sys_plmn_id_s_type plmn;
    sys_mcc_type       mcc;
    sys_mnc_type       mnc;
    boolean            plmn_undefined, plmn_includes_pcs_digit_ptr;

    if ( sys_id.id_type == SYS_SYS_ID_TYPE_UMTS )
    {
      plmn = sys_id.id.plmn;

      sys_plmn_get_mcc_mnc( plmn, &plmn_undefined, &plmn_includes_pcs_digit_ptr, &mcc, &mnc );

      (void) hput16( (byte *) &p_msg->current_plmn.mobile_country_code, (uint16) mcc );
      (void) hput16( (byte *) &p_msg->current_plmn.mobile_network_code, (uint16) mnc );
      (void) hput16( (byte *) &p_msg->mnc_includes_pcs_digit.mcc,       (uint16) mcc );
      (void) hput16( (byte *) &p_msg->mnc_includes_pcs_digit.mnc,       (uint16) mnc );
      p_msg->mnc_includes_pcs_digit.mnc_includes_pcs_digit = plmn_includes_pcs_digit_ptr;

      if ( recreating_msg ) // purpose is to read last reported network name
      {
        strlcpy( p_msg->current_plmn.network_description, (char *) qmi_nasi_global.prev_nw_desc[asubs_id].desc, MIN( NAS_NETWORK_DESCRIPTION_MAX_V01 + 1, QMI_NAS_NET_DESC_LEN_MAX ) );
        p_msg->current_plmn_valid = TRUE;
      }
      else if ( !plmn_undefined )
      {
        mmgsdi_eons_evt_info_type *eons;

        if( (eons = qmi_nas_nw_name_find( session, plmn, lac_tac, qmi_nas_rat_cm_mode_to_mmgsdi(p_ss_info->stack_info[STACK_INDEX_0].sys_mode), qm_util_retrieve_csg_id(p_ss_info, STACK_INDEX_0))) != NULL )
          {
          memscpy( p_msg->current_plmn.network_description, 
                   eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len,
                   eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_ptr, 
                   eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len );
        }
        p_msg->current_plmn_valid = TRUE;
        p_msg->mnc_includes_pcs_digit_valid = TRUE;
      }
    }
  } // TLV 12 (Current PLMN)
#endif

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
      {
        p_msg->cdma_system_id.sid   = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.sid;
        p_msg->cdma_system_id.nid   = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.nid;
        p_msg->cdma_system_id_valid = TRUE;
      }
    }
  } // TLV 13 (CDMA System ID)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
      {
        p_msg->cdma_base_station_info.base_id   = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_id;
        p_msg->cdma_base_station_info.base_lat  = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_lat;
        p_msg->cdma_base_station_info.base_long = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_long;
        p_msg->cdma_base_station_info_valid     = TRUE;
      }
    }
  } // TLV 14 (CDMA Base Station Information)

  p_msg->roaming_indicator_list_len = qmi_nas_get_roaming_ind_list( p_ss_info, &p_msg->roaming_indicator_list[0] );

  if ( p_msg->roaming_indicator_list_len > 0 )
  {
    p_msg->roaming_indicator_list_valid = TRUE;
  } // TLV 15 (Roaming Indicator List)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
      {
        p_msg->def_roam_ind = qmi_nas_get_def_roam_ind( p_ss_info );
        p_msg->def_roam_ind_valid = TRUE;
      }
    }
  } // TLV 16 (Default Roaming Indicator)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
      {
        if ( qmi_nasi_include_3GPP2_time_zone( &p_msg->nas_3gpp_time_zone.lp_sec, &p_msg->nas_3gpp_time_zone.ltm_offset, &p_msg->nas_3gpp_time_zone.daylt_savings, p_ss_info ) )
        {
          p_msg->nas_3gpp_time_zone_valid = TRUE;
        }
      }
    }
  } // TLV 17 (3GPP2 Time Zone)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
      {
        p_msg->p_rev_in_use = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.p_rev_in_use;
        p_msg->p_rev_in_use_valid = TRUE;
      }
    }
  } // TLV 18 (CDMA P_Rev In Use)

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 && !recreating_msg ) // don't include tlv when recreating
  {
    sys_plmn_id_s_type plmn;
    boolean                     plmn_name_changed = FALSE;
    mmgsdi_eons_evt_info_type *eons;

    if ( sys_id.id_type == SYS_SYS_ID_TYPE_UMTS )
    {
      plmn = sys_id.id.plmn;

      if( (eons = qmi_nas_nw_name_find( session, plmn, lac_tac, qmi_nas_rat_cm_mode_to_mmgsdi(p_ss_info->stack_info[STACK_INDEX_0].sys_mode), qm_util_retrieve_csg_id(p_ss_info, STACK_INDEX_0) )) != NULL )
      {
        QM_MSG_LOW_3("SPN=%d, short=%d, long=%d", eons->spn.eons_data.data_len, eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len, eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_len);

        if ( (qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_encoding != eons->spn.eons_encoding) ||
             (qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_len != eons->spn.eons_data.data_len) ||
             memcmp( qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr, eons->spn.eons_data.data_ptr, eons->spn.eons_data.data_len ) )
        {
          QM_MSG_HIGH("SPN has changed from cached value");
          if ( qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr != NULL )
          {
            modem_mem_free( qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
            qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr = NULL;
          }
          qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_encoding = eons->spn.eons_encoding;
          qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_len = eons->spn.eons_data.data_len;
          if( qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_len > 0 )
          {
             qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr = modem_mem_alloc(qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_len, MODEM_MEM_CLIENT_QMI_MMODE);
             if( qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr != NULL )
             {
               memscpy( (void*)qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_ptr, 
                        qmi_nasi_global.get_plmn_name.last_reported_srv_prov_name.eons_data.data_len, 
                        (void*)eons->spn.eons_data.data_ptr, 
                        eons->spn.eons_data.data_len );
             }
          }
          plmn_name_changed = TRUE;
        }

        if ( (qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name_spare_bits          != eons->first_stack_info.operator_info.plmn_short_name.plmn_name_spare_bits)         ||
             (qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name_ci                  != eons->first_stack_info.operator_info.plmn_short_name.plmn_name_ci)                 ||
             (qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_encoding       != eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_encoding)      ||
             (qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_len != eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len) ||
             memcmp( qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr, eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_ptr, eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len ) ) 
        {
          QM_MSG_HIGH("PLMN short name has changed from cached value");
          if ( qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr != NULL )
          {
            modem_mem_free( qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
            qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr = NULL;
          }
          qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name_spare_bits = eons->first_stack_info.operator_info.plmn_short_name.plmn_name_spare_bits;
          qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name_ci = eons->first_stack_info.operator_info.plmn_short_name.plmn_name_ci;
          qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_encoding = eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_encoding;
          qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_len = eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len;
          if( qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_len > 0 )
          {
             qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr = modem_mem_alloc(qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_len, MODEM_MEM_CLIENT_QMI_MMODE);
             if( qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr != NULL )
             {
               memscpy( (void*)qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_ptr, 
                        qmi_nasi_global.get_plmn_name.last_reported_plmn_short_name.plmn_name.eons_data.data_len, 
                       (void*)eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_ptr, 
                       eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len );
             }
          }
          plmn_name_changed = TRUE;
        }

        if ( (qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name_spare_bits          != eons->first_stack_info.operator_info.plmn_long_name.plmn_name_spare_bits)         ||
             (qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name_ci                  != eons->first_stack_info.operator_info.plmn_long_name.plmn_name_ci)                 ||
             (qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_encoding       != eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_encoding)      ||
             (qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_len != eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_len) ||
             memcmp( qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr, eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_ptr, eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_len ) )
        {
          QM_MSG_HIGH("PLMN long name has changed from cached value");
          if ( qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr != NULL )
          {
            modem_mem_free( qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
            qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr = NULL;
          }
          qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name_spare_bits = eons->first_stack_info.operator_info.plmn_long_name.plmn_name_spare_bits;
          qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name_ci = eons->first_stack_info.operator_info.plmn_long_name.plmn_name_ci;
          qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_encoding = eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_encoding;
          qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_len = eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_len;
          if( qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_len > 0 )
          {
             qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr = modem_mem_alloc(qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_len, MODEM_MEM_CLIENT_QMI_MMODE);
             if( qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr != NULL )
             {
               memscpy( (void*)qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_ptr, 
                        qmi_nasi_global.get_plmn_name.last_reported_plmn_long_name.plmn_name.eons_data.data_len, 
                       (void*)eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_ptr, 
                       eons->first_stack_info.operator_info.plmn_long_name.plmn_name.eons_data.data_len );
             }
          }
          plmn_name_changed = TRUE;
        }

        if ( plmn_name_changed )
        {
          p_msg->plmn_description_changed_valid = TRUE;
          p_msg->plmn_description_changed       = 0x01;
        }
      }
    }
  } // TLV 19 (3GPP PLMN Name Flag)
#endif //#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM ||
         qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
         qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_LTE )
    {
      if ( mm_information.time_zone_avail )
      {
        p_msg->time_zone       = (int8) mm_information.time_zone;
        p_msg->time_zone_valid = TRUE;
      }
    }
  } // TLV 1A 3GPP time_zone

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM ||
         qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
         qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_LTE )
    {
      if ( mm_information.daylight_saving_adj_avail )
      {
        p_msg->adj       = (uint8) mm_information.daylight_saving_adj;
        p_msg->adj_valid = TRUE;
      }
    }
  } // TLV 1B 3GPP daylight savings time adjustments

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM ||
         qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
         qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_LTE )
    {
      if( mm_information.univ_time_and_time_zone_avail )
      {
        p_msg->universal_time_and_local_time_3gpp_zone.year      = mm_information.univ_time_and_time_zone.year + 2000; // NITZ sends 2011 as 11
        p_msg->universal_time_and_local_time_3gpp_zone.month     = mm_information.univ_time_and_time_zone.month;
        p_msg->universal_time_and_local_time_3gpp_zone.day       = mm_information.univ_time_and_time_zone.day;
        p_msg->universal_time_and_local_time_3gpp_zone.hour      = mm_information.univ_time_and_time_zone.hour;
        p_msg->universal_time_and_local_time_3gpp_zone.minute    = mm_information.univ_time_and_time_zone.minute;
        p_msg->universal_time_and_local_time_3gpp_zone.second    = mm_information.univ_time_and_time_zone.second;
        p_msg->universal_time_and_local_time_3gpp_zone.time_zone = (int8) mm_information.univ_time_and_time_zone.time_zone;
        p_msg->universal_time_and_local_time_3gpp_zone_valid     = TRUE;
      }
    }
  } // TLV 1C 3GPP UTC time and time_zone (i.e offset from UTC)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM ||
         qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
         qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_LTE )
    {
      if( lac != QMI_NAS_INVALID_LAC )
      {
        p_msg->lac       = lac;
        p_msg->lac_valid = TRUE;
      }
    }
  } // TLV 1D Location Area Code

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM ||
         qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
         qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_LTE )
    {
      p_msg->cell_id       = cell_id;
      p_msg->cell_id_valid = TRUE;
    }
  } // TLV 1E cell id

#if defined (FEATURE_IS2000_REL_A_SVD)

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
      {
        p_msg->ccs       = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.ccs_supported;
        p_msg->ccs_valid = TRUE;
      }
    }
  } // TLV 1F Concurrent Service Info
#endif

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
      {
        p_msg->prl_ind       = p_ss_info->stack_info[STACK_INDEX_0].is_sys_prl_match;
        p_msg->prl_ind_valid = TRUE;
      }
    }
  } // TLV 20 PRL indicator

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM )
    {
      p_msg->dtm_ind       = (uint8) dtm_supp;
      p_msg->dtm_ind_valid = TRUE;
    }
  } // TLV 21 DTM indicator

  {
    p_msg->detailed_service_info.srv_status       = (uint8) srv_status;
    p_msg->detailed_service_info.srv_capability   = (uint8) srv_capability;
    if ( p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_HDR )
    {
      p_msg->detailed_service_info.hdr_srv_status   = (uint8) p_ss_info->stack_info[STACK_INDEX_1].srv_status;
      p_msg->detailed_service_info.hdr_hybrid       = p_ss_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_hybrid;
    }
    p_msg->detailed_service_info.is_sys_forbidden = p_ss_info->stack_info[STACK_INDEX_0].is_sys_forbidden;
    p_msg->detailed_service_info_valid            = TRUE;
  } // TLV 22 Detailed Service Info

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
      {
        p_msg->cdma_system_id_ext.mcc        = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.mcc;
        p_msg->cdma_system_id_ext.imsi_11_12 = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.imsi_11_12;
        p_msg->cdma_system_id_ext_valid      = TRUE;
      }
    }
  } // TLV 23 CDMA System ID - ext

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0 ,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
    {
        p_msg->hdr_personality       = (uint8) qmi_nas_cm_2_qmi_hdr_personality( p_ss_info->stack_info[STACK_INDEX_0].rat_mode_info.hdr_mode_info.hdr_personality);
        p_msg->hdr_personality_valid = TRUE;
      }
      else if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
      {
        p_msg->hdr_personality       = (uint8) qmi_nas_cm_2_qmi_hdr_personality( p_ss_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_personality);
        p_msg->hdr_personality_valid = TRUE;
      }
  } // TLV 24 HDR personality

  if ( p_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
  {
    if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_LTE )
    {
      p_msg->tac       = p_ss_info->stack_info[stack].rat_mode_info.lte_mode_info.tac;
      p_msg->tac_valid = TRUE;
    }
  } // TLV 25 Tracking Area Code

  if ( srv_status != SYS_SRV_STATUS_PWR_SAVE &&
       srv_status != SYS_SRV_STATUS_NO_SRV )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_UMTS )
      {
        if ( cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
             cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
          p_msg->call_barring_status.cs_bar_status = (uint32) cell_access_info.cs_bar_status;
        }
        else
        {
          p_msg->call_barring_status.cs_bar_status = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
        if ( cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
             cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
          p_msg->call_barring_status.ps_bar_status = (uint32) cell_access_info.ps_bar_status;
        }
        else
        {
          p_msg->call_barring_status.ps_bar_status = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
        p_msg->call_barring_status_valid = TRUE;
      }
    } // TLV 26 Call Barring

  if ( p_ss_info->stack_info[stack].changed_fields & CM_SS_EVT_NO_CHANGE_MASK )
  {
    p_msg->srv_sys_no_change_valid = TRUE;
    p_msg->srv_sys_no_change = TRUE;
  }  // TLV 27

  if ( qmi_nas_sys_mode_2_radio_if( p_ss_info, stack, FALSE ) == QMI_NAS_RADIO_IF_UMTS && psc != 0xFFFF )
  {
    p_msg->umts_psc       = psc;
    p_msg->umts_psc_valid = TRUE;
  } // TLV 28 PSC

  if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,FALSE) == QMI_NAS_RADIO_IF_UMTS )
  {
    p_msg->hs_call_status = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack].cell_srv_ind.hs_call_status;
    p_msg->hs_call_status_valid = TRUE;
  } // TLV 2A HS call status
}

/*===========================================================================
  FUNCTION qmi_nas_gen_serving_system_ind()

  DESCRIPTION
    Generate and send serving system IND message

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_serving_system_ind(
  cm_mm_msim_ss_info_s_type * p_ss_info,
  qmi_cm_ph_info_s_type    * p_ph_info,
  qmi_cm_ph_info_s_type    * p_ph_info2
)
{
  nas_serving_system_ind_msg_v01 * new_ind;
  nas_serving_system_ind_msg_v01 * old_ind;

  qmi_cm_ph_info_s_type              * p_new_ph_info;
  qmi_cm_ph_info_s_type              * p_old_ph_info;

  dsm_item_type                  * indication      = NULL;
  boolean                          send_indication = TRUE;     // replaces new_ind->t01_valid, which ALWAYS comes back TRUE from call to qmi_nas_populate_serving_system_ind_msg();
  sys_modem_as_id_e_type asid = SYS_MODEM_AS_ID_1;

  int                         clid;
  qmi_nasi_client_state_type *cl_sp;
  sys_modem_as_id_e_type      asubs_id, i=0, max_subs = SYS_MODEM_AS_ID_1;

  new_ind = (nas_serving_system_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_serving_system_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  old_ind = (nas_serving_system_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_serving_system_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if(p_ss_info->asubs_id != SYS_MODEM_AS_ID_NONE)
  {
    asid = p_ss_info->asubs_id;
  }

  if ( new_ind != NULL && old_ind != NULL )
  {
  for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
  {
    cl_sp = qmi_nas_state.client[clid];

      if ( cl_sp              != NULL                       &&
           cl_sp->common.clid != QMI_SVC_CLID_UNUSED        &&
           !cl_sp->report_status.not_report_serving_system &&
           cl_sp->report_status.bound_subs == (enum qmi_nas_subs_e)asid )
      {
        p_new_ph_info = p_ph_info;
        p_old_ph_info = &qmi_nasi_global.cm_ph_info;

        if ( cl_sp->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY )
        {
          asubs_id = SYS_MODEM_AS_ID_1;
        }
#ifdef FEATURE_DUAL_SIM
        else if ( cl_sp->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
        {
          asubs_id      = SYS_MODEM_AS_ID_2;
          p_new_ph_info = p_ph_info2;
          p_old_ph_info = &qmi_nasi_global.cm_ph_info2;
        }
#endif
        else
        {
          QM_MSG_ERROR_1("invalid asubs_id %d", cl_sp->report_status.bound_subs);
          continue;
        }

        memset( new_ind, 0x00, sizeof(nas_serving_system_ind_msg_v01) );
        memset( old_ind, 0x00, sizeof(nas_serving_system_ind_msg_v01) );

        qmi_nas_populate_serving_system_ind_msg( p_ss_info,                   p_new_ph_info, new_ind, FALSE, asubs_id );
        qmi_nas_populate_serving_system_ind_msg( &qmi_nasi_global.cm_msim_ss_info[asubs_id], p_old_ph_info, old_ind, TRUE,  asubs_id );

        if ( !qmi_nasi_global.rcvd_ss_info )
        {
          send_indication = TRUE;
        }
        else if ( memcmp( old_ind, new_ind, sizeof(nas_serving_system_ind_msg_v01) ) )
        {
          if ( old_ind->universal_time_and_local_time_3gpp_zone_valid && ! memcmp( &old_ind->universal_time_and_local_time_3gpp_zone,
                                                                                       &new_ind->universal_time_and_local_time_3gpp_zone,
                                                                                       sizeof(new_ind->universal_time_and_local_time_3gpp_zone) )
             ) new_ind->universal_time_and_local_time_3gpp_zone_valid = FALSE;

          if ( old_ind->data_capabilities_valid        && ! memcmp( &old_ind->data_capabilities,
                                                                        &new_ind->data_capabilities,
                                                                        MAX( new_ind->data_capabilities_len,      old_ind->data_capabilities_len      ) * sizeof(nas_data_capabilites_enum_v01) )
             ) new_ind->data_capabilities_valid        = FALSE;

          if ( old_ind->roaming_indicator_list_valid   && ! memcmp( &old_ind->roaming_indicator_list,
                                                                        &new_ind->roaming_indicator_list,
                                                                        MAX( new_ind->roaming_indicator_list_len, old_ind->roaming_indicator_list_len ) * sizeof(nas_roaming_indicator_type_v01) )
             ) new_ind->roaming_indicator_list_valid   = FALSE;

          if (                                            ! memcmp( &old_ind->serving_system,           &new_ind->serving_system,           sizeof(new_ind->serving_system) )
             ) send_indication                         = FALSE;
          if ( old_ind->roaming_indicator_valid        && ! memcmp( &old_ind->roaming_indicator,        &new_ind->roaming_indicator,        sizeof(new_ind->roaming_indicator) )
             ) new_ind->roaming_indicator_valid        = FALSE;
          if ( old_ind->current_plmn_valid             && ! memcmp( &old_ind->current_plmn,             &new_ind->current_plmn,             sizeof(new_ind->current_plmn) )
             ) new_ind->current_plmn_valid             = FALSE;
          if ( old_ind->cdma_system_id_valid           && ! memcmp( &old_ind->cdma_system_id,           &new_ind->cdma_system_id,           sizeof(new_ind->cdma_system_id) )
             ) new_ind->cdma_system_id_valid           = FALSE;
          if ( old_ind->cdma_base_station_info_valid   && ! memcmp( &old_ind->cdma_base_station_info,   &new_ind->cdma_base_station_info,   sizeof(new_ind->cdma_base_station_info) )
             ) new_ind->cdma_base_station_info_valid   = FALSE;
          if ( old_ind->def_roam_ind_valid             && ! memcmp( &old_ind->def_roam_ind,             &new_ind->def_roam_ind,             sizeof(new_ind->def_roam_ind) )
             ) new_ind->def_roam_ind_valid             = FALSE;
          if ( old_ind->nas_3gpp_time_zone_valid       && ! memcmp( &old_ind->nas_3gpp_time_zone,       &new_ind->nas_3gpp_time_zone,       sizeof(new_ind->nas_3gpp_time_zone) )
             ) new_ind->nas_3gpp_time_zone_valid       = FALSE;
          if ( old_ind->p_rev_in_use_valid             && ! memcmp( &old_ind->p_rev_in_use,             &new_ind->p_rev_in_use,             sizeof(new_ind->p_rev_in_use) )
             ) new_ind->p_rev_in_use_valid             = FALSE;
          if ( old_ind->plmn_description_changed_valid && ! memcmp( &old_ind->plmn_description_changed, &new_ind->plmn_description_changed, sizeof(new_ind->plmn_description_changed) )
             ) new_ind->plmn_description_changed_valid = FALSE;
          if ( old_ind->time_zone_valid                && ! memcmp( &old_ind->time_zone,                &new_ind->time_zone,                sizeof(new_ind->time_zone) )
             ) new_ind->time_zone_valid                = FALSE;
          if ( old_ind->adj_valid                      && ! memcmp( &old_ind->adj,                      &new_ind->adj,                      sizeof(new_ind->adj) )
             ) new_ind->adj_valid                      = FALSE;
          if ( old_ind->lac_valid                      && ! memcmp( &old_ind->lac,                      &new_ind->lac,                      sizeof(new_ind->lac) )
             ) new_ind->lac_valid                      = FALSE;
          if ( old_ind->cell_id_valid                  && ! memcmp( &old_ind->cell_id,                  &new_ind->cell_id,                  sizeof(new_ind->cell_id) )
             ) new_ind->cell_id_valid                  = FALSE;
          if ( old_ind->ccs_valid                      && ! memcmp( &old_ind->ccs,                      &new_ind->ccs,                      sizeof(new_ind->ccs) )
             ) new_ind->ccs_valid                      = FALSE;
          if ( old_ind->prl_ind_valid                  && ! memcmp( &old_ind->prl_ind,                  &new_ind->prl_ind,                  sizeof(new_ind->prl_ind) )
             ) new_ind->prl_ind_valid                  = FALSE;
          if ( old_ind->dtm_ind_valid                  && ! memcmp( &old_ind->dtm_ind,                  &new_ind->dtm_ind,                  sizeof(new_ind->dtm_ind) )
             ) new_ind->dtm_ind_valid                  = FALSE;
          if ( old_ind->detailed_service_info_valid    && ! memcmp( &old_ind->detailed_service_info,    &new_ind->detailed_service_info,    sizeof(new_ind->detailed_service_info) )
             ) new_ind->detailed_service_info_valid    = FALSE;
          if ( old_ind->cdma_system_id_ext_valid       && ! memcmp( &old_ind->cdma_system_id_ext,       &new_ind->cdma_system_id_ext,       sizeof(new_ind->cdma_system_id_ext) )
             ) new_ind->cdma_system_id_ext_valid       = FALSE;
          if ( old_ind->hdr_personality_valid          && ! memcmp( &old_ind->hdr_personality,          &new_ind->hdr_personality,          sizeof(new_ind->hdr_personality) )
             ) new_ind->hdr_personality_valid          = FALSE;
          if ( old_ind->tac_valid                      && ! memcmp( &old_ind->tac,                      &new_ind->tac,                      sizeof(new_ind->tac) )
             ) new_ind->tac_valid                      = FALSE;
          if ( old_ind->call_barring_status_valid      && ! memcmp( &old_ind->call_barring_status,      &new_ind->call_barring_status,      sizeof(new_ind->call_barring_status) )
             ) new_ind->call_barring_status_valid      = FALSE;
          if ( old_ind->hs_call_status_valid           && ! memcmp( &old_ind->hs_call_status,           &new_ind->hs_call_status,           sizeof(new_ind->hs_call_status) )
             ) new_ind->hs_call_status_valid           = FALSE;

          // Don't comapre TLV 0x27. Always send if available in new_ind msg
          // Only sending t29 when t12 is also sent

          if ( new_ind->current_plmn_valid == FALSE ) new_ind->mnc_includes_pcs_digit_valid = FALSE;

          if ( new_ind->roaming_indicator_valid                         || new_ind->data_capabilities_valid        ||
               new_ind->current_plmn_valid                              || new_ind->cdma_system_id_valid           ||
               new_ind->cdma_base_station_info_valid                    || new_ind->roaming_indicator_list_valid   ||
               new_ind->def_roam_ind_valid                              || new_ind->nas_3gpp_time_zone_valid       ||
               new_ind->p_rev_in_use_valid                              || new_ind->plmn_description_changed_valid ||
               new_ind->time_zone_valid                                 || new_ind->adj_valid                      ||
               new_ind->universal_time_and_local_time_3gpp_zone_valid   || new_ind->lac_valid                      ||
               new_ind->cell_id_valid                                   || new_ind->ccs_valid                      ||
               new_ind->prl_ind_valid                                   || new_ind->dtm_ind_valid                  ||
               new_ind->detailed_service_info_valid                     || new_ind->cdma_system_id_ext_valid       ||
               new_ind->hdr_personality_valid                           || new_ind->tac_valid                      ||
               new_ind->call_barring_status_valid                       || new_ind->srv_sys_no_change_valid        ||
               new_ind->hs_call_status_valid )
          {
            send_indication = TRUE;
          }

          if ( send_indication )
          {
            new_ind->data_capabilities_valid = TRUE;                                                 // If we have anything to send, data caps TLV must be included.
          }
          else
          {
            QM_MSG_HIGH_1("information changed but nothing to send %d", clid);
            continue;
            }
          }
          else
            {
          QM_MSG_HIGH_1("serving system indication contents didn't change %d", clid);
          continue;
            }

        if ( send_indication )
        {
          indication = NULL;                                                                         // Important!  When multiple encode calls may be made.
          if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                             (uint16_t) QMI_NAS_SERVING_SYSTEM_IND_MSG_V01,          // message_id = 0x0024 for _IND
                                             (void *)   new_ind,
                                             (uint32_t) sizeof(nas_serving_system_ind_msg_v01),
                                             &indication ) )
          {
            qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_GET_SERVING_SYSTEM, indication );
          }
          else
          {
            QM_MSG_HIGH_1("qmi_nas_gen_serving_system_ind(): idl_message_encode() failed, no indication sent.", clid);
          }
      }
    }
  }
#ifdef FEATURE_DUAL_SIM
  max_subs = SYS_MODEM_AS_ID_2;
#endif

  for ( i=SYS_MODEM_AS_ID_1; i<=max_subs; i++ )
  {
    QM_MSG_HIGH_1("qmi_nas_gen_serving_system_ind(), i=%d", i);
    if ( i == SYS_MODEM_AS_ID_1 )
    {
      p_new_ph_info = p_ph_info;
    }
#ifdef FEATURE_DUAL_SIM
    else
    {
      p_new_ph_info = p_ph_info2;
    }
#endif
      memset( new_ind, 0x00, sizeof(nas_serving_system_ind_msg_v01) );

      qmi_nas_populate_serving_system_ind_msg( p_ss_info, p_new_ph_info, new_ind, FALSE, i );

    if ( new_ind->serving_system.registration_state != NAS_REGISTERED_V01 )
    {
        memset( qmi_nasi_global.prev_nw_desc[i].desc, 0x00, QMI_NAS_NET_DESC_LEN_MAX );
    }
    else if ( new_ind->current_plmn_valid )
    {
        /*NAS_NETWORK_DESCRIPTION_MAX_V01+1 or QMI_NAS_NET_DESC_LEN_MAX*/
        memscpy( qmi_nasi_global.prev_nw_desc[i].desc, QMI_NAS_NET_DESC_LEN_MAX, 
                 new_ind->current_plmn.network_description, QMI_NAS_NET_DESC_LEN_MAX );         
    }
  }

  if ( !qmi_nasi_global.rcvd_ss_info )
  {
    qmi_nasi_global.rcvd_ss_info = TRUE;
  }
}
  else
  {
    QM_MSG_ERROR_2("Not enough memory to allocate QMI_NAS_SYS_INFO_IND buffers. new %p old %p", new_ind, old_ind);
  }

  if ( new_ind != NULL ) { modem_mem_free( (void *) new_ind, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( old_ind != NULL ) { modem_mem_free( (void *) old_ind, MODEM_MEM_CLIENT_QMI_MMODE ); }
}

/*===========================================================================
  FUNCTION qmi_nas_crossed_hdr_rssi_threashold()

  DESCRIPTION
    check whether hdr_rssi in argument passed threshold compared to last reported hdr rssi

  RETURN VALUE
    TRUE if new hdr rssi value crossed threshold. FALSE if not.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_crossed_hdr_rssi_threashold( cm_mm_msim_ss_info_s_type *p_info, qmi_nasi_client_state_type *cl_sp )
{
  struct report_status_s *p_rs = &cl_sp->report_status;
  uint16 i, rssi; // cm saves rssi as positive value by multiplying (-1)

  rssi = qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,FALSE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO ? p_info->stack_info[STACK_INDEX_1].rssi 
                                                                                                    : p_info->stack_info[STACK_INDEX_0].rssi;

  for ( i=0; i<p_rs->num_thresholds; i++)
  {
    /*-----------------------------------------------------------------
      If current_rssi < threshold <= last_reported_hdr_rssi (eg -75>=-85>-95)
      -----------------------------------------------------------------*/
    if ( (-1)*(char)rssi < p_rs->sig_str_thresholds[i] && p_rs->sig_str_thresholds[i] <= (-1)*(char)p_rs->last_reported_hdr_rssi_ex )
      return TRUE;

    /*-----------------------------------------------------------------
      If last_reported_hdr_rssi < threshold <= current_rssi(eg -125<-85<=-75)
      -----------------------------------------------------------------*/
    if ( (-1)*(char)p_rs->last_reported_hdr_rssi_ex < p_rs->sig_str_thresholds[i] && p_rs->sig_str_thresholds[i] <= (-1)*(char)rssi )
      return TRUE;
  }

  return FALSE;
}

/*===========================================================================
  FUNCTION qmi_nas_crossed_rssi_threashold()

  DESCRIPTION
    check whether rssi in argument passed threshold compared to last reported rssi

  RETURN VALUE
    TRUE if new rssi value crossed threshold. FALSE if not.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_crossed_rssi_threashold( cm_mm_msim_ss_info_s_type const *p_info, qmi_nasi_client_state_type *cl_sp )
{
  struct report_status_s *p_rs = &cl_sp->report_status;
  int    i;

  for ( i=0; i<p_rs->num_thresholds; i++)
  {
    /*-----------------------------------------------------------------
      If current_rssi < threshold <= last_reported_rssi (eg -75>=-85>-95)
      -----------------------------------------------------------------*/
    if ( (-1)*(char)p_info->stack_info[STACK_INDEX_0].rssi < p_rs->sig_str_thresholds[i] && p_rs->sig_str_thresholds[i] <= (-1)*(char)p_rs->last_reported_rssi_ex )
      return TRUE;

    /*-----------------------------------------------------------------
      If last_reported_rssi < threshold <= current_rssi(eg -125<-85<=-75)
      -----------------------------------------------------------------*/
    if ( (-1)*(char)p_rs->last_reported_rssi_ex < p_rs->sig_str_thresholds[i] && p_rs->sig_str_thresholds[i] <= (-1)*(char)p_info->stack_info[STACK_INDEX_0].rssi )
      return TRUE;
  }

  return FALSE;
}

/*===========================================================================
  FUNCTION qmi_nas_gen_event_report_ind()

  DESCRIPTION
    Generate and send event report IND message

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_event_report_ind( cm_ss_event_e_type *p_evt, cm_mm_msim_ss_info_s_type *p_info )
{
  nas_event_report_ind_msg_v01       *ind_msg;
  int                         i = 0, clid;
  qmi_nasi_client_state_type *cl_sp;
  struct report_status_s     *p_rs;
  uint16                      rssi=NASI_SIG_STRENGTH_INACTIVE_RSSI, ecio;
  int                         io;
  byte                        sinr;
  uint8                       stack_idx = STACK_INDEX_0;

  ind_msg = (nas_event_report_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_event_report_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  if( ind_msg == NULL)
  {
	qmi_voice_mem_error();
	return;
  }

  for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
  {
    cl_sp = qmi_nas_state.client[clid];

    if ( cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
         cl_sp->report_status.bound_subs == (enum qmi_nas_subs_e)p_info->asubs_id )
      {
        p_rs = &cl_sp->report_status; // shortcut
        memset( ind_msg, 0x00, sizeof(nas_event_report_ind_msg_v01) );
        QM_MSG_HIGH_1("cm ss evt %d", *p_evt);
        switch ( *p_evt )
        {
          case CM_SS_EVENT_SRV_CHANGED:
          case CM_SS_EVENT_DCH_CELL_ID_RSP:
            if ( p_rs->report_rf_band_info )
            {
              if ( p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_ACTIVE_BAND_MASK           || // active_band
                   p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_ACTIVE_CHANNEL_MASK        || // active_channel
                   p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_CELL_INFO_MASK             || // cell_info
                   p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_SRV_STATUS_MASK            || // srv_status
                   (p_info->number_of_stacks > 1 && p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_HDR &&
                    (p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_ACTIVE_BAND_MASK           || // active_band
                     p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_ACTIVE_CHANNEL_MASK        || // active_channel
                     p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_SRV_STATUS_MASK
                    )
                   )
                  )
              {
                if ( p_info->number_of_stacks > 1 && qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
                {
                  ind_msg->rf_band_info_list[i].radio_if       = (uint8)QMI_NAS_RADIO_IF_CDMA20001XEVDO;
                  ind_msg->rf_band_info_list[i].active_band    = (uint16)qmi_nas_cm_bc_2_qmi_bc( p_info->stack_info[STACK_INDEX_1].active_band );
                  ind_msg->rf_band_info_list[i].active_channel = p_info->stack_info[STACK_INDEX_1].active_channel;
                  i++;
                }

                if ( ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE) != QMI_NAS_RADIO_IF_NONE ) &&
                     ( p_info->stack_info[STACK_INDEX_0].srv_status != SYS_SRV_STATUS_NO_SRV && p_info->stack_info[STACK_INDEX_0].srv_status != SYS_SRV_STATUS_PWR_SAVE ) )
                {
                  ind_msg->rf_band_info_list[i].radio_if       = (uint8)qmi_nas_sys_mode_2_radio_if( p_info, STACK_INDEX_0, FALSE );
                  ind_msg->rf_band_info_list[i].active_band    = (uint16)qmi_nas_cm_bc_2_qmi_bc( p_info->stack_info[STACK_INDEX_0].active_band );
                  switch ( ind_msg->rf_band_info_list[i].radio_if )
                  {
                    case QMI_NAS_RADIO_IF_CDMA20001X:
                    case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
                      ind_msg->rf_band_info_list[i].active_channel = p_info->stack_info[STACK_INDEX_0].active_channel;
                      break;

                    case QMI_NAS_RADIO_IF_GSM:
                      ind_msg->rf_band_info_list[i].active_channel = p_info->stack_info[STACK_INDEX_0].cell_info.arfcn;
                      break;

                    case QMI_NAS_RADIO_IF_UMTS:
                    case QMI_NAS_RADIO_IF_TDSCDMA:
                      ind_msg->rf_band_info_list[i].active_channel = p_info->stack_info[STACK_INDEX_0].cell_info.uarfcn_dl;
                      break;

                    case QMI_NAS_RADIO_IF_LTE:
                      ind_msg->rf_band_info_list[i].active_channel = p_info->stack_info[STACK_INDEX_0].cell_info.earfcn_dl;
                        // DSDS not possible for LTE yet
                      break;

                    default:
                      break;
                  }
                  i++;
                }

                if ( i > 0 )
                {
                  ind_msg->rf_band_info_list_len     = (uint8)i;
                  ind_msg->rf_band_info_list_valid   = TRUE;
                }
              }
            }

            break;

          case CM_SS_EVENT_RSSI:
            if ( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE) == QMI_NAS_RADIO_IF_NONE )
            {
              QM_MSG_LOW_1("not sending rssi inds %d", p_info->stack_info[STACK_INDEX_0].rssi);
              break;
            }

            if ( p_rs->report_sig_str && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_RSSI_MASK )
            {
              if ( qmi_nas_crossed_rssi_threashold( p_info, cl_sp ) )
              {
                ind_msg->signal_strength.sig_strength = (-1)*(int8)p_info->stack_info[STACK_INDEX_0].rssi;
                ind_msg->signal_strength.radio_if     = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                ind_msg->signal_strength_valid        = TRUE;
                // save value to p_rs->last_reported_rssi_ex later
              }
            }

            if ( p_rs->report_rssi && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_RSSI_MASK )
            {
              if ( abs(p_info->stack_info[STACK_INDEX_0].rssi - p_rs->last_reported_rssi_ex) >= p_rs->report_rssi_delta )
              {
                ind_msg->rssi.rssi     = (uint8)p_info->stack_info[STACK_INDEX_0].rssi;
                ind_msg->rssi.radio_if = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                ind_msg->rssi_valid    = TRUE;
                // save value to p_rs->last_reported_rssi_ex later
              }
            }

            if ( ind_msg->signal_strength_valid || ind_msg->rssi_valid )
              p_rs->last_reported_rssi_ex = p_info->stack_info[STACK_INDEX_0].rssi;

            if ( p_rs->report_ecio )
            {
              if ( p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_ECIO_MASK )
              {
                if ( qmi_nas_gen_report_ecio( p_info->stack_info[STACK_INDEX_0].ecio, p_rs, FALSE) )
                {
                  ind_msg->ecio.ecio     = (uint8)p_info->stack_info[STACK_INDEX_0].ecio;
                  ind_msg->ecio.radio_if = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                  ind_msg->ecio_valid    = TRUE;

                  p_rs->last_reported_ecio = p_info->stack_info[STACK_INDEX_0].ecio;
                }
              }
            }

            if ( p_rs->report_io && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_IO_MASK )
            {
              if ( abs(p_info->stack_info[STACK_INDEX_0].io - p_rs->last_reported_io) >= p_rs->report_io_delta )
              {
                ind_msg->io    = (int32)p_info->stack_info[STACK_INDEX_0].io;
                ind_msg->io_valid = TRUE;

                p_rs->last_reported_io = p_info->stack_info[STACK_INDEX_0].io;
              }
            }

            if ( p_rs->report_sinr && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_SINR_MASK )
            {
              if ( qmi_nas_gen_report_sinr(p_info->stack_info[STACK_INDEX_0].sinr, p_rs) )
              {
                ind_msg->sinr  = (uint8)p_info->stack_info[STACK_INDEX_0].sinr;
                ind_msg->sinr_valid = TRUE;

                p_rs->last_reported_sinr = p_info->stack_info[STACK_INDEX_0].sinr;
              }
            }

            if ( p_rs->report_rsrq && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_RSRQ_MASK )
            {
              if ( abs(p_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrq - p_rs->last_reported_rsrq) >= p_rs->report_rsrq_delta )
              {
                ind_msg->rsrq.rsrq  = (uint8)p_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrq;
                ind_msg->rsrq.radio_if = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                ind_msg->rsrq_valid = TRUE;

                p_rs->last_reported_rsrq = p_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrq;
              }
            }

            if( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,TRUE)   == QMI_NAS_RADIO_IF_LTE )
            {
              if ( p_rs->report_lte_snr && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_SINR_MASK )
              {
                if ( (abs(p_info->stack_info[STACK_INDEX_0].sinr - p_rs->last_reported_lte_snr)*2) >= p_rs->report_lte_snr_delta )
                {
                  ind_msg->snr = (2 * (p_info->stack_info[STACK_INDEX_0].sinr) ) - 200;
                  ind_msg->snr_valid = TRUE;

                  p_rs->last_reported_lte_snr = p_info->stack_info[STACK_INDEX_0].sinr;
                }
              }
            }

            if( qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,TRUE)   == QMI_NAS_RADIO_IF_LTE )
            {
              if ( p_rs->report_lte_rsrp && p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_RSRP_MASK )
              {
                if ( abs(p_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrp - p_rs->last_reported_lte_rsrp) >= p_rs->report_lte_rsrp_delta )
                {
                  ind_msg->rsrp  = p_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrp;
                  ind_msg->rsrp_valid = TRUE;

                  p_rs->last_reported_lte_rsrp = p_info->stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrp;
                }
              }
            }

            if ( p_rs->report_error_rate )
            {
              if ( p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_HDR_PER_MASK )
              {
                ind_msg->error_rate.error_rate = p_info->stack_info[STACK_INDEX_0].rat_mode_info.hdr_mode_info.hdr_packet_err_rate;
                ind_msg->error_rate.radio_if   = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                ind_msg->error_rate_valid      = TRUE;
              }
              else if ( p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_FER_MASK )
              {
                ind_msg->error_rate.error_rate = p_info->stack_info[STACK_INDEX_0].rat_mode_info.cdma_mode_info.frame_err_rate;
                ind_msg->error_rate.radio_if   = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                ind_msg->error_rate_valid      = TRUE;
              }
              else if ( p_info->stack_info[STACK_INDEX_0].signal_strength_changed_fields & CM_SS_EVT_BER_MASK )
              {
                ind_msg->error_rate.error_rate = p_info->stack_info[STACK_INDEX_0].mode_info.gw_info.bit_err_rate * 100; // 100 is for normalization
                ind_msg->error_rate.radio_if   = (uint8)qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_0,FALSE);
                ind_msg->error_rate_valid      = TRUE;
              }
            }
            break;

          case CM_SS_EVENT_HDR_RSSI:
            if( p_info->number_of_stacks > 1 && 
                qmi_nas_sys_mode_2_radio_if(p_info,STACK_INDEX_1,FALSE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
            {
              stack_idx = STACK_INDEX_1;
            }
            else
            {
              stack_idx = STACK_INDEX_0;
            }
            
            if ( p_rs->report_sig_str && p_info->stack_info[stack_idx].signal_strength_changed_fields & CM_SS_EVT_RSSI_MASK )
            {
              rssi = p_info->stack_info[stack_idx].rssi;

              if ( qmi_nas_crossed_hdr_rssi_threashold( p_info, cl_sp ) )
              {
                ind_msg->signal_strength.sig_strength = (-1)*(int8)rssi;
                ind_msg->signal_strength.radio_if     = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001XEVDO;
                ind_msg->signal_strength_valid        = TRUE;
                // save value to p_rs->last_reported_hdr_rssi_ex later
              }
            }

            if ( p_rs->report_rssi && p_info->stack_info[stack_idx].signal_strength_changed_fields & CM_SS_EVT_RSSI_MASK )
            {
              rssi = p_info->stack_info[stack_idx].rssi;

              if ( abs(rssi - p_rs->last_reported_hdr_rssi_ex) >= p_rs->report_rssi_delta )
              {
                ind_msg->rssi.rssi     = (uint8)rssi;
                ind_msg->rssi.radio_if = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001XEVDO;
                ind_msg->rssi_valid    = TRUE;
                // save value to p_rs->last_reported_hdr_rssi_ex later
              }
            }

            if ( ind_msg->signal_strength_valid || ind_msg->rssi_valid )
              p_rs->last_reported_hdr_rssi_ex = rssi;

            if ( p_rs->report_ecio && p_info->stack_info[stack_idx].signal_strength_changed_fields & CM_SS_EVT_ECIO_MASK )
            {
              ecio = p_info->stack_info[stack_idx].ecio;

              if ( qmi_nas_gen_report_ecio(ecio, p_rs, TRUE) )
              {
                ind_msg->ecio.ecio     = (uint8)ecio;
                ind_msg->ecio.radio_if = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001XEVDO;
                ind_msg->ecio_valid    = TRUE;

                p_rs->last_reported_hdr_ecio = ecio;
              }
            }

            if ( p_rs->report_io && p_info->stack_info[stack_idx].signal_strength_changed_fields & CM_SS_EVT_IO_MASK )
            {
              io = p_info->stack_info[stack_idx].io;

              if ( abs(io - p_rs->last_reported_io) >= p_rs->report_io_delta )
              {
                ind_msg->io    = (int32)io;
                ind_msg->io_valid = TRUE;

                p_rs->last_reported_io = io;
              }
            }

            if ( p_rs->report_sinr && p_info->stack_info[stack_idx].signal_strength_changed_fields & CM_SS_EVT_SINR_MASK )
            {
              sinr = p_info->stack_info[stack_idx].sinr;

              if ( qmi_nas_gen_report_sinr(sinr, p_rs) )
              {
                ind_msg->sinr  = (uint8)sinr;
                ind_msg->sinr_valid = TRUE;

                p_rs->last_reported_sinr = sinr;
              }
            }

            if ( p_rs->report_error_rate && p_info->stack_info[stack_idx].signal_strength_changed_fields & CM_SS_EVT_HDR_PER_MASK )
            {
              ind_msg->error_rate.error_rate = p_info->stack_info[stack_idx].rat_mode_info.hdr_mode_info.hdr_packet_err_rate;
              ind_msg->error_rate.radio_if   = (uint8)QMI_NAS_RADIO_IF_CDMA20001X;
              ind_msg->error_rate_valid      = TRUE;
            }
            break;

          case CM_SS_EVENT_REG_REJECT:
            if ( p_rs->report_reg_reject_reason )
            {
              ind_msg->registration_reject_reason.service_domain = (nas_network_service_domain_enum_v01)p_info->stack_info[stack_idx].reg_reject_info.reject_srv_domain;
              ind_msg->registration_reject_reason.reject_cause   = p_info->stack_info[stack_idx].reg_reject_info.reject_cause;
              ind_msg->registration_reject_reason_valid          = TRUE;
            }
            break;

          default:
            /*unexpected cm ss evt */
            break;
        }

        if ( ind_msg->signal_strength_valid || ind_msg->rf_band_info_list_valid || ind_msg->registration_reject_reason_valid || 
	      ind_msg->rssi_valid || ind_msg->ecio_valid || ind_msg->io_valid || ind_msg->sinr_valid || ind_msg->error_rate_valid ||
             ind_msg->rsrq_valid || ind_msg->snr_valid || ind_msg->rsrp_valid )
        {
          dsm_item_type                         *ind = NULL;
          if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                              (uint16_t) QMI_NAS_EVENT_REPORT_IND_MSG_V01,
                                             (void *) ind_msg,
                                             (uint32_t) sizeof( nas_event_report_ind_msg_v01 ),
                                             &ind ) )
          {
            qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_SET_EVENT_REPORT, ind );
        }
      }
    }
  }

  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}

/*===========================================================================
  FUNCTION QMI_NAS_GEN_REPORT_ECIO()

  DESCRIPTION
    Utility function to decide whether or to send ecio value

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_nas_gen_report_ecio
(
 uint16 ecio,
 struct report_status_s *p_rs,
 boolean   isHDR
)
{
  boolean report_ecio = FALSE;
  int i;
  uint16 last_reported_ecio = isHDR ? p_rs->last_reported_hdr_ecio : p_rs->last_reported_ecio;

  if ( p_rs->reporting_mode_ecio == NASI_EVENT_REPORT_MODE_DELTA )
  {
    if( abs(ecio - last_reported_ecio) >= p_rs->report_ecio_delta)
    {
      report_ecio = TRUE;
    }
  }
  else if( p_rs->reporting_mode_ecio == NASI_EVENT_REPORT_MODE_THRESHOLD )
  {
    for ( i=0 ; i < p_rs->num_thresholds_ecio ; i++ )
    {
      /*-----------------------------------------------------------------
        current EcIo < Threshold <= last reported EcIo
      -----------------------------------------------------------------*/
      if( ecio < p_rs->ecio_thresholds[i]  &&
          p_rs->ecio_thresholds[i] <= last_reported_ecio)
      {
        report_ecio = TRUE;
        break;
      }

    /*-----------------------------------------------------------------
      last reported EcIo  <= Threshold < current EcIo
    -----------------------------------------------------------------*/
      if( last_reported_ecio <= p_rs->ecio_thresholds[i]  &&
          p_rs->ecio_thresholds[i] < ecio )
      {
        report_ecio = TRUE;
        break;
      }
    }
  }
  return report_ecio;
}

/*===========================================================================
  FUNCTION QMI_NAS_GEN_REPORT_SINR()

  DESCRIPTION
    Utility function to decide whether or to send sinr value

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_nas_gen_report_sinr
(
 uint16 sinr,
 struct report_status_s *p_rs
)
{
  boolean report_sinr = FALSE;
  int i;
  uint16 last_reported_sinr =  p_rs->last_reported_sinr;

  if ( p_rs->reporting_mode_sinr == NASI_EVENT_REPORT_MODE_DELTA )
  {
    if( abs(sinr - last_reported_sinr) >= p_rs->report_sinr_delta)
    {
      report_sinr = TRUE;
    }
  }
  else if( p_rs->reporting_mode_sinr == NASI_EVENT_REPORT_MODE_THRESHOLD )
  {
    for ( i=0 ; i < p_rs->num_thresholds_sinr ; i++ )
    {
      /*-----------------------------------------------------------------
        current sinr < Threshold <= last reported sinr
      -----------------------------------------------------------------*/
      if( sinr < p_rs->sinr_thresholds[i]  &&
          p_rs->sinr_thresholds[i] <= last_reported_sinr)
      {
        report_sinr = TRUE;
        break;
      }

    /*-----------------------------------------------------------------
      last reported sinr  <= Threshold < current sinr
    -----------------------------------------------------------------*/
      if( last_reported_sinr <= p_rs->sinr_thresholds[i]  &&
          p_rs->sinr_thresholds[i] < sinr )
      {
        report_sinr = TRUE;
        break;
      }
    }
  }
  return report_sinr;
}

/*===========================================================================
  FUNCTION qmi_nas_gen_network_time_ind()

  DESCRIPTION
    send QMI_NAS_NETWORK_TIME_IND

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_network_time_ind( cm_mm_msim_ss_info_s_type *p_info )
{
  time_genoff_args_struct_type time_genoff_args;
  time_julian_type             jul_val;
  time_type                    ts_val_secs; // genoff time in secs
  uint32                       secs; // genoff time in secs temp var
  byte                         lp_sec = 0;

  struct nas_004C_ind_s        ind_msg;
  dsm_item_type               *ind;

  int                          client;
  qmi_nasi_client_state_type  *cl_sp;
  enum qmi_nas_subs_e          bound_subs = QMI_NAS_SUBS_PRIMARY;
  time_bases_type              time_base  = ATS_RTC;

#ifdef FEATURE_DUAL_SIM
  bound_subs = (p_info->asubs_id == SYS_MODEM_AS_ID_1) ? QMI_NAS_SUBS_PRIMARY : QMI_NAS_SUBS_SECONDARY;
#endif
  memset( &ind_msg, 0x00, sizeof(ind_msg) );

  if ( (p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_CDMA_TIME_CHGD_MASK) &&
       (p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_CDMA || p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_HDR) )
  {
    time_base = ATS_TOD;

    if ( p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.sys_mode == SYS_SYS_MODE_CDMA )
    {
      lp_sec            = p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.cdma_time.lp_sec;
      ind_msg.t01_valid = TRUE;

      ind_msg.t10.time_zone = QMI_NAS_6BIT_2_8BIT( p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.cdma_time.ltm_offset ) * 2; // cdma reports in units of 30 min
      ind_msg.t10_valid     = TRUE;

      ind_msg.t11.daylt_sav_adj = (enum nas_daylt_sav_adj_e)p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.cdma_time.daylt_savings;
      ind_msg.t11_valid         = TRUE;

      ind_msg.t12.radio_if = QMI_NAS_RADIO_IF_CDMA20001X;
      ind_msg.t12_valid = TRUE;
    }
    else if ( p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.sys_mode == SYS_SYS_MODE_HDR )
    {
      lp_sec            = p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.hdr_time.lp_sec;
      ind_msg.t01_valid = TRUE;

      ind_msg.t10.time_zone = (uint8)(p_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.hdr_time.ltm_offset/15); // hdr reports in units of 1 min
      ind_msg.t10_valid     = TRUE;

      ind_msg.t11.daylt_sav_adj = NAS_DAYLT_SAV_ADJ_NONE;
      ind_msg.t11_valid         = TRUE;

      ind_msg.t12.radio_if = QMI_NAS_RADIO_IF_CDMA20001XEVDO;
      ind_msg.t12_valid = TRUE;
    }
  }
  else if ( (p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_MOBILITY_MGMT_MASK) &&
            (p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_GSM || p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_WCDMA || p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_LTE || p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_TDS) )
  {
    ind_msg.t12.radio_if = qmi_nas_sys_mode_2_radio_if( p_info, STACK_INDEX_0, FALSE );
    ind_msg.t12_valid = TRUE;

    time_base = ATS_3GPP;

    if ( p_info->stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.univ_time_and_time_zone_avail )
    {
      ind_msg.t01_valid = TRUE;

      ind_msg.t10.time_zone = (int8)p_info->stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.univ_time_and_time_zone.time_zone;
      ind_msg.t10_valid     = TRUE;
    }
    else if ( p_info->stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.time_zone_avail )
    {
      ind_msg.t01_valid = TRUE;

      ind_msg.t10.time_zone = (int8)p_info->stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.time_zone;
      ind_msg.t10_valid     = TRUE;
    }

    if ( p_info->stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.daylight_saving_adj_avail )
    {
      ind_msg.t01_valid = TRUE;

      ind_msg.t11.daylt_sav_adj = (enum nas_daylt_sav_adj_e)p_info->stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.daylight_saving_adj;
      ind_msg.t11_valid         = TRUE;
    }
  }
  else if ( p_info->number_of_stacks > 1 && p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_MOBILITY_MGMT_MASK ) // for 2nd subscription in DSDS
  {
    if( p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_GSM || p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_WCDMA || p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE || p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_TDS )
    {
      ind_msg.t12.radio_if = qmi_nas_sys_mode_2_radio_if( p_info, STACK_INDEX_1, FALSE );
      ind_msg.t12_valid = TRUE;

      time_base = ATS_3GPP;

      if ( p_info->stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.univ_time_and_time_zone_avail )
      {
        ind_msg.t01_valid = TRUE;

        ind_msg.t10.time_zone = (int8)p_info->stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.univ_time_and_time_zone.time_zone;
        ind_msg.t10_valid     = TRUE;

      }
      else if ( p_info->stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.time_zone_avail )
      {
        ind_msg.t01_valid = TRUE;

        ind_msg.t10.time_zone = (int8)p_info->stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.time_zone;
        ind_msg.t10_valid     = TRUE;
      }

      if ( p_info->stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.daylight_saving_adj_avail )
      {
        ind_msg.t11.daylt_sav_adj = (enum nas_daylt_sav_adj_e)p_info->stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.daylight_saving_adj;
        ind_msg.t11_valid         = TRUE;
      }
    }
  }
  else
  {
    QM_MSG_HIGH_2("unexpected bitmask %x %x", (dword)(p_info->stack_info[STACK_INDEX_0].changed_fields & (uint64)0xFFFFFFFF), (dword)(p_info->stack_info[STACK_INDEX_0].changed_fields >> 32));
  }

  if ( ind_msg.t01_valid )
  {
    // read time from time service
    time_genoff_args.base        = time_base;
    time_genoff_args.base_source = TIME_SCLK;
    time_genoff_args.ts_val      = (void *)&ts_val_secs;
    time_genoff_args.unit        = TIME_SECS;
    time_genoff_args.operation   = T_GET;

    time_genoff_opr( &time_genoff_args );

    secs  = ts_val_secs[0];
    secs -= lp_sec; // subtract leap seconds

    QM_MSG_HIGH_2("secs %d lp_sec %d", secs, lp_sec);

    time_jul_from_secs( secs, &jul_val ); // convert to julian
	QM_MSG_HIGH_6("y %d m %d d %d h %d m %d s %d", jul_val.year, jul_val.month, jul_val.day,
	jul_val.hour, jul_val.minute, jul_val.second);


    ind_msg.t01.year        = jul_val.year;
    ind_msg.t01.month       = jul_val.month;
    ind_msg.t01.day         = jul_val.day;
    ind_msg.t01.hour        = jul_val.hour;
    ind_msg.t01.minute      = jul_val.minute;
    ind_msg.t01.second      = jul_val.second;
    ind_msg.t01.day_of_week = jul_val.day_of_week;

    for ( client=0; client<NASI_MAX_CLIDS; client++ )
    {
      cl_sp = qmi_nas_state.client[client];

      if ( cl_sp && cl_sp->common.clid != NASI_CLID_UNUSED && cl_sp->report_status.report_network_time && cl_sp->report_status.bound_subs == bound_subs )
          {
            ind = NULL;

            if ( qmi_nas_004C_ind_write ( &ind_msg, &ind ) == QMI_ERR_NONE )
            {
          qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_NETWORK_TIME_IND, ind );
            }
          }
        }
      }
    }

/*===========================================================================
  FUNCTION QMI_NAS_COPY_TO_RSSI_STRUCT()

  DESCRIPTION
    Handle data queued for CM SS event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_copy_to_rssi_struct(
  qmi_nasi_rssi_info_type    *p_nas_info,
  const cm_mm_msim_ss_info_s_type *p_ss_info
)
{
  int i = 0;

  for( i = 0; i < p_ss_info->number_of_stacks && i < STACK_INDEX_MAX; i++ )
  {
    p_nas_info->stack_info[i].signal_strength_changed_fields = p_ss_info->stack_info[i].signal_strength_changed_fields;
    p_nas_info->stack_info[i].sys_mode = p_ss_info->stack_info[i].sys_mode;
    p_nas_info->stack_info[i].rssi = p_ss_info->stack_info[i].rssi;
    p_nas_info->stack_info[i].sinr = p_ss_info->stack_info[i].sinr;
    p_nas_info->stack_info[i].ecio = p_ss_info->stack_info[i].ecio;
    p_nas_info->stack_info[i].io = p_ss_info->stack_info[i].io;

    if( p_ss_info->stack_info[i].sys_mode == SYS_SYS_MODE_LTE )
    {
      p_nas_info->stack_info[i].rsrp = p_ss_info->stack_info[i].rat_mode_info.lte_mode_info.rsrp;
      p_nas_info->stack_info[i].rsrq = p_ss_info->stack_info[i].rat_mode_info.lte_mode_info.rsrq;
    }
    
    if( p_ss_info->stack_info[i].sys_mode == SYS_SYS_MODE_CDMA )
    {
      p_nas_info->stack_info[i].frame_err_rate = p_ss_info->stack_info[i].rat_mode_info.cdma_mode_info.frame_err_rate;
    }
    else if( p_ss_info->stack_info[i].sys_mode == SYS_SYS_MODE_HDR )
    {
      p_nas_info->stack_info[i].hdr_hybrid = p_ss_info->stack_info[i].rat_mode_info.hdr_mode_info.hdr_hybrid;
      p_nas_info->stack_info[i].hdr_packet_err_rate = p_ss_info->stack_info[i].rat_mode_info.hdr_mode_info.hdr_packet_err_rate;
    }
    else
    {
      p_nas_info->stack_info[i].bit_err_rate = p_ss_info->stack_info[i].mode_info.gw_info.bit_err_rate;
    }
  }
}


/*===========================================================================
  FUNCTION QMI_NAS_COPY_FROM_RSSI_STRUCT()

  DESCRIPTION
    Handle data queued for CM SS event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_copy_from_rssi_struct(
  cm_mm_msim_ss_info_s_type    *p_ss_info,
  qmi_nasi_rssi_info_type *p_nas_info
)
{
  int i = 0;
 
  for( i = 0; i < p_nas_info->number_of_stacks && i < STACK_INDEX_MAX; i++ )
  {
    p_ss_info->stack_info[i].signal_strength_changed_fields = p_nas_info->stack_info[i].signal_strength_changed_fields;
    p_ss_info->stack_info[i].sys_mode = p_nas_info->stack_info[i].sys_mode;
    p_ss_info->stack_info[i].rssi = p_nas_info->stack_info[i].rssi;
    p_ss_info->stack_info[i].sinr = p_nas_info->stack_info[i].sinr;
    p_ss_info->stack_info[i].ecio = p_nas_info->stack_info[i].ecio;
    p_ss_info->stack_info[i].io = p_nas_info->stack_info[i].io;

    if( p_nas_info->stack_info[i].sys_mode == SYS_SYS_MODE_LTE )
    {
      p_ss_info->stack_info[i].rat_mode_info.lte_mode_info.rsrp = p_nas_info->stack_info[i].rsrp;
      p_ss_info->stack_info[i].rat_mode_info.lte_mode_info.rsrq = p_nas_info->stack_info[i].rsrq;
    }
  
    if( p_nas_info->stack_info[i].sys_mode == SYS_SYS_MODE_CDMA )
    {
      p_ss_info->stack_info[i].rat_mode_info.cdma_mode_info.frame_err_rate = p_nas_info->stack_info[i].frame_err_rate;
    }
    else if( p_nas_info->stack_info[i].sys_mode == SYS_SYS_MODE_HDR )
    {
      p_ss_info->stack_info[i].rat_mode_info.hdr_mode_info.hdr_hybrid = p_nas_info->stack_info[i].hdr_hybrid;
      p_ss_info->stack_info[i].rat_mode_info.hdr_mode_info.hdr_packet_err_rate = p_nas_info->stack_info[i].hdr_packet_err_rate;
    }
    else
    {
      p_ss_info->stack_info[i].mode_info.gw_info.bit_err_rate = p_nas_info->stack_info[i].bit_err_rate;
    }
  }
}


/*===========================================================================
  FUNCTION QMI_NAS_COPY_FROM_GLOBAL_SYS_MODE()

  DESCRIPTION
    Handle data queued for CM SS event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_copy_from_global_sys_mode(
  cm_mm_msim_ss_info_s_type *p_ss_info_from,
  cm_mm_msim_ss_info_s_type *p_ss_info_to
)
{
  int i;

  for( i = 0; i < p_ss_info_to->number_of_stacks && i < STACK_INDEX_MAX; i++ )
  {
    p_ss_info_to->stack_info[i].sys_mode = p_ss_info_from->stack_info[i].sys_mode;

    if( p_ss_info_from->stack_info[i].sys_mode == SYS_SYS_MODE_HDR )
    {
      p_ss_info_to->stack_info[i].rat_mode_info.hdr_mode_info.hdr_hybrid = p_ss_info_from->stack_info[i].rat_mode_info.hdr_mode_info.hdr_hybrid;
    }
  }
}

struct qmi_nas_cmss_msim_evt_cb_s
{
  cm_ss_event_e_type   evt;
  cm_mm_msim_ss_info_s_type  info;
};

/*===========================================================================
  FUNCTION QMI_NAS_CHECK_AND_UPDATE_CELL_ID()

  DESCRIPTION
    Verify if NAS and RRC PLMN ID and LAC match.  If not, use old cell id
    information.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_check_and_update_cell_id(
  cm_mm_msim_ss_info_s_type *p_ss_info,
  enum qm_stack_index_e      stack

)
{
  sys_modem_as_id_e_type asubs_id=SYS_MODEM_AS_ID_1;
  uint8 asubs_max = sizeof(qmi_nasi_global.cm_msim_ss_info)/sizeof(qmi_nasi_global.cm_msim_ss_info[0]);

  if( (p_ss_info->asubs_id != SYS_MODEM_AS_ID_NONE) && (p_ss_info->asubs_id < asubs_max) )
  {
    asubs_id = p_ss_info->asubs_id;
  }

  QM_MSG_HIGH_2("qmi_nas_check_and_update_cell_id(): asubs_id = %d, sys_mode = %d", asubs_id, p_ss_info->stack_info[stack].sys_mode);

  if ( (p_ss_info->stack_info[stack].sys_mode == p_ss_info->stack_info[stack].cell_info.as_sys_mode) ||
       (p_ss_info->stack_info[stack].sys_mode == SYS_SYS_MODE_TDS && p_ss_info->stack_info[stack].cell_info.as_sys_mode == SYS_SYS_MODE_WCDMA) )
  {
    QM_MSG_HIGH_6("sys_id.id.plmn.identity = {%d, %d, %d} cell_info.plmn_id.identity = {%d, %d, %d} ",
                 p_ss_info->stack_info[stack].sys_id.id.plmn.identity[0],
                 p_ss_info->stack_info[stack].sys_id.id.plmn.identity[1],
                 p_ss_info->stack_info[stack].sys_id.id.plmn.identity[2],                 
                 p_ss_info->stack_info[stack].cell_info.plmn_id.identity[0],
                 p_ss_info->stack_info[stack].cell_info.plmn_id.identity[1],
                 p_ss_info->stack_info[stack].cell_info.plmn_id.identity[2]
                );

    if ( !memcmp( p_ss_info->stack_info[stack].sys_id.id.plmn.identity, p_ss_info->stack_info[stack].cell_info.plmn_id.identity, sizeof(p_ss_info->stack_info[stack].sys_id.id.plmn.identity) ) )
    {
      QM_MSG_HIGH_4("rat_mode_info.lte_mode_info.tac = %d, cell_info.tac = %d, sys_id.id.plmn_lac.lac = %d, cell_info.lac_id = %d",
                   p_ss_info->stack_info[stack].rat_mode_info.lte_mode_info.tac,
                   p_ss_info->stack_info[stack].cell_info.tac,
                   p_ss_info->stack_info[stack].sys_id.id.plmn_lac.lac,
                   p_ss_info->stack_info[stack].cell_info.lac_id
                  );

      if ( (p_ss_info->stack_info[stack].sys_mode == SYS_SYS_MODE_LTE) &&
           p_ss_info->stack_info[stack].rat_mode_info.lte_mode_info.tac != p_ss_info->stack_info[stack].cell_info.tac )
      {
        QM_MSG_HIGH_2("RRC tac %d not matching NAS %d", p_ss_info->stack_info[stack].cell_info.tac, p_ss_info->stack_info[stack].rat_mode_info.lte_mode_info.tac);
        p_ss_info->stack_info[stack].cell_info = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[stack].cell_info;
      }
      else if ( ((p_ss_info->stack_info[stack].sys_mode == SYS_SYS_MODE_WCDMA) || (p_ss_info->stack_info[stack].sys_mode == SYS_SYS_MODE_GSM) || (p_ss_info->stack_info[stack].sys_mode == SYS_SYS_MODE_TDS)) &&
                p_ss_info->stack_info[stack].sys_id.id.plmn_lac.lac != p_ss_info->stack_info[stack].cell_info.lac_id )
      {
        QM_MSG_HIGH_2("RRC lac %d not matching NAS %d", p_ss_info->stack_info[stack].cell_info.lac_id, p_ss_info->stack_info[stack].sys_id.id.plmn_lac.lac);
        p_ss_info->stack_info[stack].cell_info = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[stack].cell_info;
      }
    }
    else
    {
      QM_MSG_HIGH("RRC PLMN ID not matching NAS");
      p_ss_info->stack_info[stack].cell_info = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[stack].cell_info;
    }
  }
  else
  {
    QM_MSG_HIGH_2("RRC sys_mode %d not matching NAS %d", p_ss_info->stack_info[stack].cell_info.as_sys_mode, p_ss_info->stack_info[stack].sys_mode);
    p_ss_info->stack_info[stack].cell_info = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[stack].cell_info;
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMSS_MSIM_EVT()

  DESCRIPTION
    Handle data queued for CM SS event callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmss_msim_evt( qmi_mmode_cmd_enum_type cmd, void *user_data_ptr )
{
  struct qmi_nas_cmss_msim_evt_cb_s *ptr = (struct qmi_nas_cmss_msim_evt_cb_s*)user_data_ptr;
  cm_ss_event_e_type         *p_evt;
  cm_mm_msim_ss_info_s_type       *p_info;
  qmi_nasi_rssi_info_type     rssi_info;
  mmgsdi_session_type_enum_type session = MMGSDI_GW_PROV_PRI_SESSION;
  boolean             copy_info = TRUE;
  uint8 stack_index=0, i=0;
  if ( ptr )
  {
    p_evt  = &ptr->evt;
    p_info = &ptr->info;

    // Set up asubs id in case of single sim target
    if( p_info->asubs_id == SYS_MODEM_AS_ID_NONE )
    {
      p_info->asubs_id = SYS_MODEM_AS_ID_1;
    }
    
    QM_MSG_HIGH_3("Recieved evt=%d,asubs_id=%d,no_of_stacks=%d", *p_evt, p_info->asubs_id, p_info->number_of_stacks);
    for(i=0;i<p_info->number_of_stacks && i<STACK_INDEX_MAX;i++)
    {
      QM_MSG_HIGH_7("Rxd sys_mode=%d,srv_status=%d,is_operational=%d,chg_fields=%x,chg_fields2=%x,srv_domain=%d signal_strength_changed_fields=%x", 
	  	p_info->stack_info[i].sys_mode, p_info->stack_info[i].srv_status, p_info->stack_info[i].is_operational,
	  	p_info->stack_info[i].changed_fields, p_info->stack_info[i].changed_fields2, p_info->stack_info[i].srv_domain,p_info->stack_info[i].signal_strength_changed_fields);

 }

    //Verify if NAS and RRC PLMN ID and LAC match only if SS event is reported for CELL_INFO
    if(
        (p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_CELL_INFO_MASK) ||
        !(p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_SYS_ID_MASK)
      )
    {
      //Calling qmi_nas_check_and_update_cell_id, STACK_INDEX_0
      qmi_nas_check_and_update_cell_id(p_info, STACK_INDEX_0);
    }

    //Verify if NAS and RRC PLMN ID and LAC match only if SS event is reported for CELL_INFO
    if(
        (p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_CELL_INFO_MASK) ||
        !(p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_SYS_ID_MASK)
      )
    {
      //Calling qmi_nas_check_and_update_cell_id, STACK_INDEX_1
      qmi_nas_check_and_update_cell_id(p_info, STACK_INDEX_1);
    }
    // Check MM Info PLMN ID
    for (stack_index=0;stack_index < p_info->number_of_stacks && stack_index < STACK_INDEX_MAX;stack_index++)
    {
      enum qmi_nas_radio_if_e rat = qmi_nas_sys_mode_2_radio_if(p_info,stack_index,FALSE);
      if ( (  rat == QMI_NAS_RADIO_IF_GSM || rat == QMI_NAS_RADIO_IF_UMTS || rat == QMI_NAS_RADIO_IF_LTE ) &&
           p_info->stack_info[stack_index].mode_info.gw_info.mm_information.plmn_avail &&
           memcmp( &p_info->stack_info[stack_index].mode_info.gw_info.mm_information.plmn, &p_info->stack_info[stack_index].sys_id.id.plmn, sizeof(p_info->stack_info[stack_index].sys_id.id.plmn) ) )
      {
        p_info->stack_info[stack_index].mode_info.gw_info.mm_information.short_name_avail = FALSE;
        p_info->stack_info[stack_index].mode_info.gw_info.mm_information.full_name_avail = FALSE;
    }
    }

    switch ( *p_evt )
            {
      case CM_SS_EVENT_INFO:
      case CM_SS_EVENT_SRV_CHANGED:
      case CM_SS_EVENT_DCH_CELL_ID_RSP:
#ifdef FEATURE_DUAL_SIM
        qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, &qmi_nasi_global.cm_ph_info2 );
#else
        qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, NULL );
#endif
        qmi_nas_gen_sys_info_ind( p_info, &qmi_nasi_global.cm_ph_info, FALSE );
        qmi_nas_gen_event_report_ind( p_evt, p_info );

        for( stack_index = 0; stack_index < p_info->number_of_stacks; stack_index++ )
        {
          if ( qmi_nas_sys_mode_2_radio_if(p_info,stack_index,FALSE) == QMI_NAS_RADIO_IF_GSM ||
               qmi_nas_sys_mode_2_radio_if(p_info,stack_index,FALSE) == QMI_NAS_RADIO_IF_UMTS ||
               qmi_nas_sys_mode_2_radio_if(p_info,stack_index,FALSE) == QMI_NAS_RADIO_IF_LTE )
          {
            sys_mm_information_s_type *p_new_mm_info = &p_info->stack_info[stack_index].mode_info.gw_info.mm_information;
            sys_mm_information_s_type *p_old_mm_info = &qmi_nasi_global.cm_msim_ss_info[p_info->asubs_id].stack_info[stack_index].mode_info.gw_info.mm_information;
          boolean                    send_ind = FALSE;

          if ( p_new_mm_info->short_name_avail )
          {
            if ( !p_old_mm_info->short_name_avail ||
                 memcmp( &p_old_mm_info->short_name, &p_new_mm_info->short_name, sizeof(sys_network_short_name_s_type) ) )
            {
                QM_MSG_HIGH_3("nitz updated short name %d %d %d", p_old_mm_info->short_name_avail, p_new_mm_info->short_name_avail, p_new_mm_info->short_name.length);
              send_ind = TRUE;
            }
          }

          if ( p_new_mm_info->full_name_avail )
          {
            if ( !p_old_mm_info->full_name_avail ||
                 memcmp( &p_old_mm_info->full_name, &p_new_mm_info->full_name, sizeof(sys_network_full_name_s_type) ) )
            {
                QM_MSG_HIGH_3("nitz updated full name %d %d %d", p_old_mm_info->full_name_avail, p_new_mm_info->full_name_avail, p_new_mm_info->full_name.length);
              send_ind = TRUE;
            }
          }

            //TODO: map Mmgsdi session based on asubs_id
          if ( send_ind )
          {
            qmi_nas_operator_name_data_ind( MMGSDI_GW_PROV_PRI_SESSION, p_new_mm_info );
          }
        }
        }

        qm_tib_check_and_invalidate_cdma_hdr_cache(p_info);

        if ( p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_CDMA_TIME_CHGD_MASK ||
             p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_MOBILITY_MGMT_MASK  ||
             ( p_info->number_of_stacks > 1 && p_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_MOBILITY_MGMT_MASK ) )
        {
          // compare CDMA time data with global cache, send ind and start timer
          if ( p_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_CDMA_TIME_CHGD_MASK )
          { 
            if( qm_tib_is_enabled() )    // check if time ind blocking module is valid to use
            {
              if( qm_tib_is_time_info_changed(p_info) )
              {
                if( qm_tib_is_time_ind_blocked() )
                {
                  qm_tib_unblock_time_ind();
                }
                qmi_nas_update_cached_time_info(p_info);
                qmi_nas_gen_network_time_ind( p_info );
                qm_tib_update_time_info(p_info);
                qm_tib_block_time_ind();
                QM_MSG_HIGH("sent time ind and blocked tib");
              }
              else
              {
                if( !qm_tib_is_time_ind_blocked() )
                {
                  qmi_nas_update_cached_time_info(p_info);
                  qmi_nas_gen_network_time_ind( p_info );
                  qm_tib_update_time_info(p_info);       // after oos we land here so need to update cache as well
                  qm_tib_block_time_ind();
                  QM_MSG_HIGH("CM SS EVENT Time changed, network_time_ind sent and blocked tib");
                }
                else
                {
                  QM_MSG_HIGH("CM SS EVENT Time changed, dropping network_time_ind");
                }
              }
            }
            else
            {
              qmi_nas_update_cached_time_info(p_info);
              qmi_nas_gen_network_time_ind(p_info); // default behavior send ind
              QM_MSG_HIGH("tib not valid to use, sending network_time_ind rightaway");
            }
          }
          else
          {
            qmi_nas_update_cached_time_info(p_info);
            qmi_nas_gen_network_time_ind(p_info); // send ind for 3gpp networks
            QM_MSG_HIGH("network_time_ind sent for 3GPP networks");
          }
        }

        if( *p_evt == CM_SS_EVENT_SRV_CHANGED )
        {
          qmi_nas_gen_managed_roaming_ind( p_info, &qmi_nasi_global.cm_ph_info, QMI_NAS_SUBS_PRIMARY );
#ifdef FEATURE_DUAL_SIM
          qmi_nas_gen_managed_roaming_ind( p_info, &qmi_nasi_global.cm_ph_info2, QMI_NAS_SUBS_SECONDARY );
#ifdef FEATURE_TRIPLE_SIM
          qmi_nas_gen_managed_roaming_ind( p_info, &qmi_nasi_global.cm_ph_info3, QMI_NAS_SUBS_TERTIARY );
#endif
#endif
        }

        if( p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_WCDMA ||
            p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_GSM ||
            p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_LTE ||
            p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_TDS ||
            ( p_info->number_of_stacks > 1 &&
              ( p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE ||
                p_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_GSM ) ) )
        {
          session = qmi_nas_map_cm_asubs_to_mmgsdi_session( p_info->asubs_id );
          qmi_nas_gen_current_plmn_name_ind( p_info, session );
        }
#ifdef FEATURE_DUAL_SIM
        // Need second call for secondary subscription
#endif

        qmi_nas_gen_rf_band_info_ind( p_info );

        qmi_nas_update_global_ims_pref( p_info );

        qm_si_process_cm_ss_event( p_info, *p_evt );

        break;

      case CM_SS_EVENT_HDR_RSSI:
      case CM_SS_EVENT_RSSI:
      case CM_SS_EVENT_GW_RSSI:
        qm_meas_process_cm_measurement_event(p_info, *p_evt);
        qmi_nas_copy_to_rssi_struct( &rssi_info, p_info );
        memscpy( p_info, sizeof(cm_mm_msim_ss_info_s_type), &qmi_nasi_global.cm_msim_ss_info[p_info->asubs_id], sizeof(cm_mm_msim_ss_info_s_type));
        qmi_nas_copy_from_rssi_struct( p_info, &rssi_info );
        qmi_nas_gen_event_report_ind( p_evt, p_info );
        qmi_nas_copy_from_global_sys_mode( &qmi_nasi_global.cm_msim_ss_info[p_info->asubs_id], p_info );
        break;

    case CM_SS_EVENT_REG_REJECT:
#ifdef FEATURE_DUAL_SIM
        qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, &qmi_nasi_global.cm_ph_info2 );
#else
        qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, NULL );
#endif
        qmi_nas_gen_sys_info_ind( p_info, &qmi_nasi_global.cm_ph_info, TRUE );
        qmi_nas_gen_network_reject_ind( p_info );
        qmi_nas_gen_event_report_ind( p_evt, p_info );
        break;

      case CM_SS_EVENT_CELL_ACCESS_IND:
#ifdef FEATURE_DUAL_SIM
       qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, &qmi_nasi_global.cm_ph_info2 );
#else
       qmi_nas_gen_serving_system_ind( p_info, &qmi_nasi_global.cm_ph_info, NULL );
#endif
        qmi_nas_gen_sys_info_ind( p_info, &qmi_nasi_global.cm_ph_info, FALSE );
        break;

      default:
        copy_info = FALSE;
        // do nothing for now
        (void)p_info;
        break;
    }

    if ( copy_info )
    {
      memscpy(&qmi_nasi_global.cm_msim_ss_info[p_info->asubs_id], sizeof(cm_mm_msim_ss_info_s_type),
              &ptr->info, sizeof(cm_mm_msim_ss_info_s_type));
    }
  }
  /*Else, null pointer. ignoring cm ss event*/
}

/*===========================================================================
  FUNCTION qmi_nas_cmss_msim_evt_cb()

  DESCRIPTION
    Queue CM MSIM SS events into MMODE_QMI

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmss_msim_evt_cb( cm_ss_event_e_type evt, const cm_mm_msim_ss_info_s_type *p_info)
{
  struct qmi_nas_cmss_msim_evt_cb_s *ptr;

  if ( p_info )
    {
    if ( evt == CM_SS_EVENT_CELL_ACCESS_IND && p_info->number_of_stacks >= 1 &&
         ( p_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_NO_SRV || p_info->stack_info[STACK_INDEX_0].srv_status == SYS_SRV_STATUS_PWR_SAVE ||
           p_info->stack_info[STACK_INDEX_0].srv_status == SYS_SRV_STATUS_NO_SRV ) )
    {
      QM_MSG_HIGH("Dropping Cell Access due to no service");
    }
    else
    {
    ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

    if ( ptr )
      {
      ptr->evt  = evt;
      ptr->info = *p_info;
        qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMSS_MSIM_EVT_CB, ptr);
          }
          else
          {
			qmi_voice_mem_error();        
        }
      }
  }
      else
      {
    QM_MSG_ERROR("qmi_nas_cmss_evt_cb() p_info is null");
      }
    }

struct qmi_nas_cmss_cmd_cb_s
      {
  void                *p_data;
  cm_ss_cmd_e_type     cmd;
  cm_ss_cmd_err_e_type err;
};

/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_CMSS_CMD()

  DESCRIPTION
    Handle CM SS command callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_cmss_cmd( qmi_mmode_cmd_enum_type cmd_type, void *user_data_ptr )
{
  struct qmi_nas_cmss_cmd_cb_s *ptr = (struct qmi_nas_cmss_cmd_cb_s*)user_data_ptr;
  void                *p_data;
  cm_ss_cmd_e_type     cmd;
  cm_ss_cmd_err_e_type err;
  boolean              success=FALSE;

  if ( ptr )
  {
    // cache to local variables for readability
    p_data = ptr->p_data;
    cmd    = ptr->cmd;
    err    = ptr->err;

    QM_MSG_HIGH_3("cm ss cmd cb %d err %d user_data", cmd, err, (int)p_data );

    success = TRUE;

    switch (cmd)
    {
      case CM_SS_CMD_INFO_GET: // cm_ss_cmd_get_ss_info()
        break;

      default:
        // do nothing for now
        (void)p_data;
        (void)err;
        break;
    }
  }
  /*Success will be set to TRUE if no error in handling CM SS cmd*/
}

/*===========================================================================
  FUNCTION QMI_NAS_CMSS_CMD_CB()

  DESCRIPTION
    Handle CM SS command callback

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_cmss_cmd_cb( void *p_data, cm_ss_cmd_e_type cmd, cm_ss_cmd_err_e_type err)
{
  struct qmi_nas_cmss_cmd_cb_s *ptr;

  ptr = modem_mem_alloc( sizeof(*ptr), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ptr )
  {
    ptr->p_data = p_data;
    ptr->cmd    = cmd;
    ptr->err    = err;

    qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMSS_CMD_CB, ptr);
  }
  else
    {
	qmi_voice_mem_error();
  }
    }

struct qmi_nas_cmph_event_s
{
  cm_ph_event_e_type beg;
  cm_ph_event_e_type end;
};

struct qmi_nas_cmss_event_s
{
  cm_ss_event_e_type beg;
  cm_ss_event_e_type end;
};

/*===========================================================================
  FUNCTION QMI_NAS_REGISTER_TO_AMSS()

  DESCRIPTION
    Perform necessary registration to AMSS modules (e.g., CM)

  RETURN VALUE
    TRUE for success, FALSE for failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    QMI_NAS global variables will be updated
===========================================================================*/
static boolean qmi_nas_register_to_amss(void)
{
  cm_client_status_e_type ret_val;
  int                     i;

  const struct qmi_nas_cmph_event_s ph_event_list[] = {
    { CM_PH_EVENT_OPRT_MODE, CM_PH_EVENT_OPRT_MODE },
    { CM_PH_EVENT_SYS_SEL_PREF, CM_PH_EVENT_SYS_SEL_PREF },
    { CM_PH_EVENT_CURR_NAM, CM_PH_EVENT_CURR_NAM },
    { CM_PH_EVENT_INFO, CM_PH_EVENT_INFO },
    { CM_PH_EVENT_INFO_AVAIL, CM_PH_EVENT_AVAILABLE_NETWORKS_CONF },
    { CM_PH_EVENT_NVRUIM_CONFIG_CHANGED, CM_PH_EVENT_NVRUIM_CONFIG_CHANGED },
    { CM_PH_EVENT_TERMINATE_GET_NETWORKS, CM_PH_EVENT_DDTM_STATUS }, 
    { CM_PH_EVENT_DUAL_STANDBY_PREF, CM_PH_EVENT_DUAL_STANDBY_PREF },
    { CM_PH_EVENT_GET_DRX_CNF, CM_PH_EVENT_GET_DRX_CNF },
    { CM_PH_EVENT_GET_HPLMN_TIMER, CM_PH_EVENT_GET_HPLMN_TIMER }
  };

  const struct qmi_nas_cmss_event_s ss_event_list[] = {
    { CM_SS_EVENT_SRV_CHANGED, CM_SS_EVENT_INFO },
    { CM_SS_EVENT_HDR_RSSI, CM_SS_EVENT_HDR_RSSI },
    { CM_SS_EVENT_GW_RSSI, CM_SS_EVENT_GW_RSSI },
    { CM_SS_EVENT_REG_REJECT, CM_SS_EVENT_REG_REJECT },
    { CM_SS_EVENT_CELL_ACCESS_IND, CM_SS_EVENT_CELL_ACCESS_IND },
    { CM_SS_EVENT_DCH_CELL_ID_RSP, CM_SS_EVENT_DCH_CELL_ID_RSP } };

  ret_val = cm_client_init( CM_CLIENT_TYPE_RM_NETWORK_INTERFACE, &qmi_nasi_global.cm_clnt_id);

  if ( ret_val == CM_CLIENT_OK ) {
    for ( i=0; i<QMI_NAS_ARR_SIZE(ph_event_list); i++ )
    {
      ret_val = cm_client_ph_reg( qmi_nasi_global.cm_clnt_id,
                                  qmi_nas_cmph_evt_cb,
                                  CM_CLIENT_EVENT_REG,
                                  ph_event_list[i].beg,
                                  ph_event_list[i].end,
                                  NULL );
      if ( ret_val != CM_CLIENT_OK )
        break;
    }
  }

  if ( ret_val == CM_CLIENT_OK ) 
  {
    for ( i=0; i<QMI_NAS_ARR_SIZE(ss_event_list); i++ )
    {
      ret_val = cm_mm_client_ss_reg_msim( qmi_nasi_global.cm_clnt_id,
                                         qmi_nas_cmss_msim_evt_cb,
                                     CM_CLIENT_EVENT_REG,
                                     ss_event_list[i].beg,
                                     ss_event_list[i].end,
                                         NULL,
                                         SYS_MODEM_AS_ID_1_MASK|SYS_MODEM_AS_ID_2_MASK|SYS_MODEM_AS_ID_3_MASK);
      if ( ret_val != CM_CLIENT_OK )
      {
        QM_MSG_ERROR_1("cm_mm_client_ss_reg_msim registration failed %d", ret_val);
        break;
    }
  }
  }

  if ( ret_val == CM_CLIENT_OK )
  {
    ret_val = cm_client_stats_reg( qmi_nasi_global.cm_clnt_id,
                                   qmi_nas_cmstats_evt_cb,
                                   CM_CLIENT_EVENT_REG,
                                   CM_STATS_EVENT_MODEM_INFO,
                                   CM_STATS_EVENT_MODEM_INFO,
                                   NULL );

    if ( ret_val != CM_CLIENT_OK )
      QM_MSG_ERROR_1("cm stats registratio failed %d", ret_val);

    if ( !cm_stats_set_modem_info_mask( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_GSM,
                                        CM_GERAN_ENG_MODE_NMR_INFO       |
                                        CM_GERAN_ENG_MODE_TIMING_ADVANCE |
                                        CM_GERAN_ENG_MODE_SCELL_INFO     |
                                        CM_GERAN_ENG_MODE_SCELL_MEASUREMENTS  |
                                        SYS_GERAN_ENG_MODE_CURRENT_L1_TIMESLOT |
                                        SYS_GERAN_ENG_SCELL_CONFIG) )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem GSM info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }

    if ( !cm_stats_set_modem_info_mask( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_WCDMA,
                                        CM_WCDMA_MONITORED_SET_BIT_MASK     |
                                        CM_WCDMA_SERVING_CELL_INFO_BIT_MASK |
                                        CM_WCDMA_SERVING_CELL_POWER_INFO_BIT_MASK |
                                        CM_WCDMA_ACTIVE_SET_REFERENCE_CELL_INFO_BIT_MASK | 
                                        CM_WCDMA_RRC_STATE | 
                                        CM_WCDMA_ACTIVE_SET_INFO_BIT_MASK
                                      )
       )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem WCDMA info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }
#ifdef FEATURE_DUAL_SIM
    if ( !cm_stats_set_modem_info_mask_per_subs ( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_GSM,
                                        CM_GERAN_ENG_MODE_NMR_INFO       |
                                        CM_GERAN_ENG_MODE_TIMING_ADVANCE |
                                        CM_GERAN_ENG_MODE_SCELL_INFO     |
                                        CM_GERAN_ENG_MODE_SCELL_MEASUREMENTS, 
					SYS_MODEM_AS_ID_2) )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem GSM info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }

    if ( !cm_stats_set_modem_info_mask_per_subs ( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_WCDMA,
                                        CM_WCDMA_MONITORED_SET_BIT_MASK     |
                                        CM_WCDMA_SERVING_CELL_INFO_BIT_MASK |
                                        CM_WCDMA_SERVING_CELL_POWER_INFO_BIT_MASK |
                                        CM_WCDMA_ACTIVE_SET_REFERENCE_CELL_INFO_BIT_MASK | 
                                        CM_WCDMA_RRC_STATE | 
                                        CM_WCDMA_ACTIVE_SET_INFO_BIT_MASK,
                                        SYS_MODEM_AS_ID_2
                                      )
       )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem WCDMA info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }
   #endif
   #ifdef FEATURE_TRIPLE_SIM
    if ( !cm_stats_set_modem_info_mask_per_subs ( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_GSM,
                                        CM_GERAN_ENG_MODE_NMR_INFO       |
                                        CM_GERAN_ENG_MODE_TIMING_ADVANCE |
                                        CM_GERAN_ENG_MODE_SCELL_INFO     |
                                        CM_GERAN_ENG_MODE_SCELL_MEASUREMENTS,
                                        SYS_MODEM_AS_ID_3) )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem GSM info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }
    if ( !cm_stats_set_modem_info_mask_per_subs ( NULL, NULL, qmi_nasi_global.cm_clnt_id,
                                        SYS_MODEM_MODULE_WCDMA,
                                        CM_WCDMA_MONITORED_SET_BIT_MASK     |
                                        CM_WCDMA_SERVING_CELL_INFO_BIT_MASK |
                                        CM_WCDMA_SERVING_CELL_POWER_INFO_BIT_MASK |
                                        CM_WCDMA_ACTIVE_SET_REFERENCE_CELL_INFO_BIT_MASK | 
                                        CM_WCDMA_RRC_STATE | 
                                        CM_WCDMA_ACTIVE_SET_INFO_BIT_MASK,
                                        SYS_MODEM_AS_ID_3
                                      )
       )
    {
      QM_MSG_ERROR("Fail to set CM Stats modem WCDMA info mask");
      ret_val = CM_CLIENT_ERR_CLIENT_INIT_FAIL;
    }
   #endif
  }

#ifdef FEATURE_DUAL_SIM
  if ( ret_val == CM_CLIENT_OK )
  {
    ret_val = cm_client_subs_reg( qmi_nasi_global.cm_clnt_id,
                                  qmi_nas_cmsubs_evt_cb );
    if ( ret_val != CM_CLIENT_OK )
      QM_MSG_ERROR_1("cm_client_subs_reg failed %d", ret_val);
  }
#endif

  if ( ret_val == CM_CLIENT_OK ) {
    ret_val = qmi_nas_mmgsdi_register_to_amss() ? CM_CLIENT_OK : CM_CLIENT_ERR_CLIENT_ID_PTR;
  }

#ifdef FEATURE_HDR
  if ( ret_val == CM_CLIENT_OK ) {
    ret_val = qmi_nas_register_to_hdr() ? CM_CLIENT_OK : CM_CLIENT_ERR_CLIENT_ID_PTR;
  }
#endif

  if ( ret_val != CM_CLIENT_OK ) {
    (void)cm_client_release( qmi_nasi_global.cm_clnt_id );
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/*===========================================================================
  FUNCTION qmi_nas_fw_dealloc_clid_cb()

  DESCRIPTION
    Callback to deallocate the client from Framework
===========================================================================*/
void qmi_nas_fw_dealloc_clid_cb( qmi_framework_common_msg_hdr_type *hdr )
{
  qmi_framework_common_msg_hdr_type *ptr;

  if ( hdr )
  {
    ptr = modem_mem_alloc( sizeof(qmi_framework_common_msg_hdr_type), MODEM_MEM_CLIENT_QMI_MMODE );

    if ( ptr )
    {
      memscpy(ptr, sizeof(qmi_framework_common_msg_hdr_type), 
              hdr, sizeof(qmi_framework_common_msg_hdr_type) );

      qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_DEALLOC_CLID, ptr);
    }
    else
    {
	 qmi_voice_mem_error();
    }
  }
  else
  {
    QM_MSG_ERROR("qmi_nas_fw_dealloc_clid_cb() hdr is null");
  }
}

/*===========================================================================
  FUNCTION dealloc_cl_sp()

  DESCRIPTION
    Free the client data buffer for the given clid.

  PARAMETERS
    clid: uint8 type

  RETURN VALUE
    TRUE if success, FALSE otherwise
===========================================================================*/
static boolean dealloc_cl_sp( uint8 clid )
{
  qmi_nasi_client_state_type *cl_sp = NULL;
  boolean                     ret_val = FALSE;

  QM_MSG_MED_1("In dealloc_cl_sp(): clid = %d", clid);

  if ( clid != QMI_SVC_CLID_UNUSED && clid <= NASI_MAX_CLIDS )
  {
    qm_nas_clnt_config_dealloc(clid);
    cl_sp = qmi_nas_state.client[clid-1];

    if ( cl_sp )
    {
      q_destroy( &cl_sp->common.x_free_q );
      q_destroy( &cl_sp->common.cmd_free_q );

      modem_mem_free( cl_sp, MODEM_MEM_CLIENT_QMI_MMODE );
      qmi_nas_state.client[clid-1] = NULL;
      ret_val = TRUE;
    }
    else
    {
      QM_MSG_ERROR("dealloc_cl_sp() cl_sp is null");
    }
  }
  else
  {
    QM_MSG_ERROR("dealloc_cl_sp() invalid clid");
  }

  return ret_val;
}

/*===========================================================================
  FUNCTION qmi_nas_process_dealloc_clid()

  DESCRIPTION
    Process deallocate clid from Framework
===========================================================================*/
void qmi_nas_process_dealloc_clid( qmi_mmode_cmd_enum_type cmd, void *user_data_ptr )
{
  qmi_framework_common_msg_hdr_type *hdr = (qmi_framework_common_msg_hdr_type *)user_data_ptr;
  qmi_nasi_client_state_type        *cl_sp = NULL;
  qmi_result_e_type                  result = QMI_RESULT_FAILURE;
  qmi_error_e_type                errval = QMI_ERR_NONE;

  if( hdr!= NULL )
  {
    if( hdr->client_id != QMI_SVC_CLID_UNUSED && hdr->client_id <= NASI_MAX_CLIDS )
    {
      cl_sp = qmi_nas_state.client[hdr->client_id-1]; // client id values start from 1
    }
    else
    {
      QM_MSG_ERROR_1("qmi_nas_process_dealloc_clid() clid out of range %d", hdr->client_id);
      errval = QMI_ERR_INVALID_CLIENT_ID;
    }
  }
  else
  {
    QM_MSG_ERROR("qmi_nas_process_dealloc_clid() hdr is NULL");
    errval = QMI_ERR_NO_MEMORY;
  }

  if ( cl_sp )
  {
    if ( cl_sp->common.clid == hdr->client_id )
    {
      qmi_nasi_reset_client( cl_sp );
      dealloc_cl_sp( hdr->client_id );

      result = QMI_RESULT_SUCCESS;
    }
    else
    {
      QM_MSG_ERROR_2("qmi_nas_process_dealloc_clid() clid mismatch %d %d", cl_sp->common.clid, hdr->client_id);
      errval = QMI_ERR_INVALID_CLIENT_ID;
    }
  }
  else
  {
    QM_MSG_ERROR("qmi_nas_process_dealloc_clid() cl_sp is NULL");
    errval = QMI_ERR_NO_MEMORY;
  }

  /* Notifying the clid deallocation back to client via QMI Framework*/
  qmi_framework_svc_send_dealloc_clid_result_ex( result, hdr,errval );
  }

/*===========================================================================
  FUNCTION QMI_NAS_ALLOC_CLID_CB()

  DESCRIPTION
    Callback to allocate the client from Framework
===========================================================================*/
boolean qmi_nas_fw_alloc_clid_cb( qmi_framework_common_msg_hdr_type *hdr )
{
  qmi_framework_common_msg_hdr_type *ptr;
  boolean ret_val;

  if ( hdr )
  {
    ptr = modem_mem_alloc( sizeof(qmi_framework_common_msg_hdr_type), MODEM_MEM_CLIENT_QMI_MMODE );

    if ( ptr )
    {
      memscpy(ptr, sizeof(qmi_framework_common_msg_hdr_type), hdr, sizeof(qmi_framework_common_msg_hdr_type) );

      qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_ALLOC_CLID, ptr);
      ret_val = TRUE;
    }
    else
    {
		qmi_voice_mem_error();
      ret_val = FALSE;
    }
  }
  else
  {
    QM_MSG_ERROR("qmi_nas_fw_alloc_clid_cb() hdr is null");
    ret_val = FALSE;
  }

  return ret_val;
}

/*===========================================================================
  FUNCTION alloc_cl_sp()

  DESCRIPTION
    Allocate the client data buffer

  PARAMETERS
    clid: uint8

  RETURN VALUE
    ptr to malloc'ed client pointer in case of success. NULL otherwise.
===========================================================================*/
static qmi_nasi_client_state_type* alloc_cl_sp( uint8 clid )
{
  qmi_nasi_client_state_type *cl_sp = NULL;

  QM_MSG_MED_1("In alloc_cl_sp(): clid = %d", clid);

  if ( clid != QMI_SVC_CLID_UNUSED && clid <= NASI_MAX_CLIDS )
  {
    qm_nas_clnt_config_alloc(clid);
    cl_sp = modem_mem_alloc( sizeof(qmi_nasi_client_state_type), MODEM_MEM_CLIENT_QMI_MMODE );

    if ( cl_sp )
    {
      memset( cl_sp->common.transactions, 0x00, sizeof(qmi_transaction_type)*MAX_PENDING_TRANSACTIONS );
      memset( cl_sp->common.cmd_buf, 0x00, sizeof(qmi_cmd_buf_type)*MAX_PENDING_COMMANDS );
      memset( &cl_sp->report_status, 0x00, sizeof(cl_sp->report_status));

      qmi_nas_state.client[clid - 1] = cl_sp;
    }
    else
    {
     qmi_voice_mem_error();
    }
  }
  else
  {
    QM_MSG_ERROR("qmi_nasi_alloc_cl_sp() invalid clid");
  }

  return cl_sp;
  }

/*===========================================================================
  FUNCTION qmi_nas_process_alloc_clid()

  DESCRIPTION
    Process allocate clid from Framework
===========================================================================*/
void qmi_nas_process_alloc_clid( qmi_mmode_cmd_enum_type cmd, void *user_data_ptr )
  {
  qmi_framework_common_msg_hdr_type *hdr = (qmi_framework_common_msg_hdr_type *)user_data_ptr;
  qmi_nasi_client_state_type        *cl_sp = NULL;
  qmi_result_e_type                  result = QMI_RESULT_FAILURE;
  qmi_error_e_type                errval = QMI_ERR_NONE;

  if ( hdr )
    {
    cl_sp = alloc_cl_sp( hdr->client_id );

    if ( cl_sp )
    {
      qmi_mmode_svc_initialize_common_client(&cl_sp->common, &qmi_nas_state);


      /* TODO
       * initialize client specific data here
       */

      cl_sp->common.clid = hdr->client_id;
      cl_sp->service_id  = hdr->service;
      cl_sp->instance    = (uint16)hdr->qmi_instance;

    /*-----------------------------------------------------------------------
      Initialize client state variables
      - last reported signal strength to inactive
    -----------------------------------------------------------------------*/
    cl_sp->report_status.last_reported_rssi_ex = NASI_SIG_STRENGTH_INACTIVE_RSSI;
    cl_sp->report_status.last_reported_ecio = NASI_SIG_STRENGTH_INACTIVE_ECIO;
    cl_sp->report_status.last_reported_io   = NASI_SIG_STRENGTH_INACTIVE_IO;
    cl_sp->report_status.last_reported_sinr = NASI_SIG_STRENGTH_INACTIVE_SINR;
    cl_sp->report_status.last_reported_rsrq = NASI_SIG_STRENGTH_INACTIVE_RSRQ;
    cl_sp->report_status.last_reported_lte_rsrp = NASI_SIG_STRENGTH_INACTIVE_RSRP;
    cl_sp->report_status.last_reported_lte_snr  = NASI_LTE_SNR_STRENGTH_INACTIVE;
    cl_sp->report_status.last_reported_hdr_rssi = NASI_SIG_STRENGTH_INACTIVE_RSSI;
    cl_sp->report_status.last_reported_hdr_ecio = NASI_SIG_STRENGTH_INACTIVE_ECIO;
    cl_sp->report_status.last_reported_hdr_io   = NASI_SIG_STRENGTH_INACTIVE_IO;
    cl_sp->report_status.last_reported_hdr_sinr = NASI_SIG_STRENGTH_INACTIVE_SINR;
    cl_sp->report_status.reporting_mode_ecio    = NASI_EVENT_REPORT_MODE_DELTA;
    cl_sp->report_status.reporting_mode_sinr    = NASI_EVENT_REPORT_MODE_DELTA;
    cl_sp->report_status.bound_subs             = QMI_NAS_SUBS_PRIMARY;
    cl_sp->report_status.report_dual_standby_pref_ind   = FALSE;
    cl_sp->report_status.report_subscription_info_ind   = FALSE;
    cl_sp->report_status.report_thermal_emergency_state = FALSE;
    cl_sp->report_status.report_network_time            = FALSE;
    cl_sp->report_status.report_sys_info                = FALSE;
    cl_sp->report_status.report_sig_info                = FALSE;
    cl_sp->report_status.report_err_rate                = FALSE;
    cl_sp->report_status.report_current_plmn_name       = FALSE;
    cl_sp->report_status.report_operator_name_data      = TRUE;
    cl_sp->report_status.report_csp_plmn_mode_bit       = TRUE;
	  cl_sp->report_status.report_sinr                    = FALSE;
    cl_sp->report_status.report_rsrq				            = FALSE;
    cl_sp->report_status.report_lte_snr			            = FALSE;
    cl_sp->report_status.limit_sys_info_reporting_mask  = QMI_NAS_LIMIT_NONE;
    cl_sp->report_status.ignore_plmn_display_cond_in_ind = FALSE;
    cl_sp->report_status.network_reject.report_network_reject_ind = FALSE;
    cl_sp->report_status.network_reject.suppress_sys_info_on_reject = FALSE;

    cl_sp->report_status.report_sig_str = FALSE;
    cl_sp->report_status.num_thresholds = 0;
    cl_sp->report_status.num_thresholds_ecio = 0;
    cl_sp->report_status.num_thresholds_sinr = 0;

    result = QMI_RESULT_SUCCESS;
  }
    else
    {
      QM_MSG_ERROR("qmi_nas_process_alloc_clid() alloc_cl_sp failed");
      errval = QMI_ERR_CLIENT_IDS_EXHAUSTED;
    }
  }

  /* Notifying the clid allocation back to client via QMI Framework*/
  qmi_framework_svc_send_alloc_clid_result_ex( result, hdr, errval );
}

/*===========================================================================
  FUNCTION qmi_nas_fw_init_cb()

  DESCRIPTION
    Callback for Service initialization from Framework
===========================================================================*/
void qmi_nas_fw_init_cb( uint16 num_instances )
{
  uint16 *ptr;

  ptr = modem_mem_alloc( sizeof(uint16), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ptr )
  {
    memscpy( ptr, sizeof(uint16), &num_instances, sizeof(uint16) );

    qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_INIT_CBACK, ptr);
  }
  else
  {
    qmi_voice_mem_error();
  }
  }

/*===========================================================================
  FUNCTION qmi_nas_process_init_cback()

  DESCRIPTION
    Process init from Framework
===========================================================================*/
void qmi_nas_process_init_cback(
  qmi_mmode_cmd_enum_type   cmd,
  void                    * user_data_ptr
)
{
  uint16 *num_instances = (uint16 *)user_data_ptr;
  int i;

  if ( num_instances != NULL )
  {
    memset( &qmi_nas_state, 0x00, sizeof(qmi_nas_state) );

    qmi_nas_state.num_instances = *num_instances;
    qmi_nasi_cfg.svc_sp         = &qmi_nas_state;

  /*-------------------------------------------------------------------------
    Initialize the global NAS service parameters
  -------------------------------------------------------------------------*/
  if(qmi_nasi_global.inited == INIT_STATE_NOT_INITIALIZED)
  {
    boolean success;

    memset(&qmi_nasi_global, 0, sizeof(qmi_nasi_global));
    memset(&qmi_nasi_nitz_time,0,sizeof(qmi_nasi_nitz_time));
    memset(&qmi_nasi_ssac_info,0 , sizeof(qmi_nasi_ssac_info));

    qmi_nas_mmgsdi_init(&qmi_nasi_global.mmgsdi);
    qmi_nas_nw_name_init();
    qm_tib_init( qmi_nas_timer_cmd_cb ); 

#ifdef FEATURE_QMI_NAS_HDR
    // init HDR module
    qmi_nas_init_hdr();
#endif

    success = qmi_nas_register_to_amss();

    if ( success ) {
      (void)cm_ph_cmd_get_ph_info( qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id );

#ifdef FEATURE_DUAL_SIM
      (void)cm_ph_cmd_get_ph_info_per_subs( qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, SYS_MODEM_AS_ID_2 ); // dwbeacon
#ifdef FEATURE_TRIPLE_SIM
      (void)cm_ph_cmd_get_ph_info_per_subs( qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, SYS_MODEM_AS_ID_3 );
#endif
#endif

      qmi_nasi_global.net_scan_started = FALSE;
      qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE;
      qmi_nasi_global.inited = INIT_STATE_PENDING_MODE_CAPABILITY;
      qmi_nasi_global.min_rssi_delta = NASI_DEFAULT_RSSI_DELTA;
      qmi_nasi_global.min_io_delta   = NASI_DEFAULT_IO_DELTA;
      qmi_nasi_global.min_rsrq_delta = NASI_DEFAULT_RSRQ_DELTA;
      qmi_nasi_global.min_rsrp_delta = NASI_DEFAULT_RSRP_DELTA;
      qmi_nasi_global.rtre_set_status_pending = FALSE;
      memset( qmi_nasi_global.cm_msim_ss_info,  0x00, sizeof(qmi_nasi_global.cm_msim_ss_info) );
      memset( &qmi_nasi_global.cm_ph_info,  0x00, sizeof(qmi_cm_ph_info_s_type) );
      
#ifdef FEATURE_DUAL_SIM
      memset( &qmi_nasi_global.cm_ph_info2, 0x00, sizeof(qmi_cm_ph_info_s_type) );
      qmi_nasi_global.rcvd_ph_info2     = FALSE;
      qmi_nasi_global.sim_state_before_not_avail[QMI_NAS_SUBS_SECONDARY] = SYS_SIM_STATE_NOT_AVAILABLE;
#endif
#ifdef FEATURE_TRIPLE_SIM
      memset( &qmi_nasi_global.cm_ph_info3, 0x00, sizeof(qmi_cm_ph_info_s_type) );
      qmi_nasi_global.rcvd_ph_info3     = FALSE;
     qmi_nasi_global.sim_state_before_not_avail[QMI_NAS_SUBS_TERTIARY] = SYS_SIM_STATE_NOT_AVAILABLE;
#endif
      qmi_nasi_global.rcvd_ss_info      = FALSE;
      qmi_nasi_global.rcvd_ph_info      = FALSE;
      
      qmi_nasi_global.current_plmn_name_cache.current_plmn_valid = FALSE;
        qmi_nasi_global.embms_status      = FALSE;
        qmi_nasi_global.trace_id                = -1;
        qmi_nasi_global.cmd_buf_p               = NULL;
      qmi_nasi_global.sim_state_before_not_avail[QMI_NAS_SUBS_PRIMARY] = SYS_SIM_STATE_NOT_AVAILABLE;
      qmi_nasi_global.svc_obj = nas_get_service_object_v01();

      for ( i=QMI_NAS_SUBS_PRIMARY; i<QMI_NAS_SUBS_MAX; i++ )
      {
        memset( qmi_nasi_global.prev_nw_desc[i].desc, 0x00, QMI_NAS_NET_DESC_LEN_MAX );
#ifdef FEATURE_DUAL_SIM
        memset( &qmi_nasi_global.subs_info[i], 0x00, sizeof(cm_subs_info_s_type) );
#endif
      }

      qmi_nasi_ssac_info.is_valid = FALSE;
      qmi_nasi_ssac_info.ssac_cache.ssac_param_voice_valid = FALSE;
      qmi_nasi_ssac_info.ssac_cache.ssac_param_video_valid = FALSE;
      qmi_nasi_ssac_info.ssac_cache.barring_factor_mmtel_voice = 0xFF;
      qmi_nasi_ssac_info.ssac_cache.barring_factor_mmtel_video = 0xFF;
      qmi_nasi_ssac_info.ssac_cache.barring_time_mmtel_voice = 0xFFFF;
      qmi_nasi_ssac_info.ssac_cache.barring_time_mmtel_video = 0xFFFF;
      qmi_nasi_ssac_info.ssac_cache.sib2_barring_factor_mmtel_voice = 0xFF;
      qmi_nasi_ssac_info.ssac_cache.sib2_barring_factor_mmtel_video = 0xFF;
      qmi_nasi_ssac_info.ssac_cache.sib2_barring_time_mmtel_voice = 0xFFFF;
      qmi_nasi_ssac_info.ssac_cache.sib2_barring_time_mmtel_video = 0xFFFF;
      
      for( i = 0; i < QMI_NAS_SUBS_MAX; i++)
      {
        qmi_nasi_global.data_roam_cache_valid[i] = qm_efs_read_data_roaming_status(i, &qmi_nasi_global.data_roam_cache[i]);
        qmi_nasi_global.t3402_value[i] = NASI_DISABLE_LTE_DURATION_MIN_VALUE;
      }

      QM_MSG_HIGH_2( "resetting call mode due to initialization - old valid: %d old call mode: %d", qmi_nasi_global.call_mode_valid, qmi_nasi_global.call_mode);
      for(i = 0; i < QMI_NAS_SUBS_MAX; i++)
      {
        qmi_nasi_global.call_mode_valid[i] = FALSE;
        qmi_nasi_global.call_mode[i] = SYS_CALL_MODE_NORMAL;
      }

      qmi_nasi_global.rpm_parameters_cmd_buf_p = NULL;
    }
    else {
      QM_MSG_ERROR("CM/MMGSDI client registration failed");
    }
  }
  }
  else
  {
    QM_MSG_ERROR("qmi_nas_process_init_cback() user_data_ptr is NULL");
  }
}

struct qmi_nas_cmd_hdlr_s
{
  qmi_framework_msg_hdr_type  hdr;
  dsm_item_type              *sdu;
};

/*===========================================================================
  FUNCTION qmi_nas_fw_cmd_hdlr_cb()

  DESCRIPTION
    Callback REQ message from Framework
===========================================================================*/
void qmi_nas_fw_cmd_hdlr_cb( qmi_framework_msg_hdr_type *hdr, dsm_item_type **sdu )
{
  struct qmi_nas_cmd_hdlr_s *ptr;

  ptr = modem_mem_alloc( sizeof(struct qmi_nas_cmd_hdlr_s), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ptr )
  {
    ptr->hdr = *hdr;
    ptr->sdu = *sdu;

    qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_CMD_HDLR, ptr );
  }
  else
  {
	qmi_voice_mem_error();
  }
}

/*===========================================================================
  FUNCTION qmi_nas_process_cmd_hdlr()

  DESCRIPTION
    Process REQ message from Framework
===========================================================================*/
void qmi_nas_process_cmd_hdlr( qmi_mmode_cmd_enum_type cmd, void *user_data_ptr )
{
  struct qmi_nas_cmd_hdlr_s  *ptr = (struct qmi_nas_cmd_hdlr_s *)user_data_ptr;
  qmi_nasi_client_state_type *cl_sp;

  if ( ptr )
  {
    //QM_MSG_HIGH_1("qmi_nas_process_cmd_hdlr() clid %d", ptr->hdr.common_hdr.client_id);

    if ( ptr->hdr.common_hdr.client_id != QMI_SVC_CLID_UNUSED && ptr->hdr.common_hdr.client_id <= NASI_MAX_CLIDS )
    {
      cl_sp = qmi_nas_state.client[ptr->hdr.common_hdr.client_id-1];

      if ( cl_sp )
      {
        qmi_mmode_svc_req_hdlr( &qmi_nasi_cfg, &ptr->hdr, &cl_sp->common, ptr->sdu );
      }
      else
      {
        QM_MSG_ERROR("qmi_nas_process_cmd_hdlr() cl_sp is NULL");
      }
    }
  }
  else
  {
    QM_MSG_ERROR("qmi_nas_process_cmd_hdlr() user_data_ptr is NULL");
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_INIT()

  DESCRIPTION
    Register the Netowrk Access Service with QMUX for all applicable QMI links
===========================================================================*/
void qmi_nas_init( void )
{
  qmi_framework_err_e_type      errval;
  qmi_idl_service_object_type   svc_obj;

#ifdef FEATURE_MODEM_CONFIG_REFRESH
  mcfg_refresh_registration_s_type mcfg_refresh_reg;
#endif // FEATURE_MODEM_CONFIG_REFRESH

  /* Set the cmd handlers in QMI MMODE task */
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_ALLOC_CLID,     qmi_nas_process_alloc_clid     );
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_DEALLOC_CLID,   qmi_nas_process_dealloc_clid   );
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_INIT_CBACK,     qmi_nas_process_init_cback     );
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMD_HDLR,       qmi_nas_process_cmd_hdlr       );
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMPH_EVT_CB,    qmi_nas_process_cmph_evt       );
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMSS_MSIM_EVT_CB, qmi_nas_process_cmss_msim_evt);
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMSTATS_EVT_CB, qmi_nas_process_cmstats_evt    );
#ifdef FEATURE_DUAL_SIM
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMSUBS_EVT_CB,  qmi_nas_process_cmsubs_evt     );
#endif
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMSS_CMD_CB,    qmi_nas_process_cmss_cmd       );
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_MMGSDI_CMD_CB,  qmi_nas_mmgsdi_process_cmd_rsp );
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_MMGSDI_EVT_CB,  qmi_nas_mmgsdi_process_evt     );
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_CMPH_CMD_CB,    qmi_nas_process_cmph_cmd       );
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_HDR_EVT_CB,     qmi_nas_cmd_handler            );
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_TIMER_EVT_CB,   qmi_nas_process_timer_evt      );
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_INTERNAL_CB,    qmi_nas_process_internal_cmd   );
#ifdef FEATURE_MODEM_CONFIG_REFRESH 
  qmi_mmode_set_cmd_handler( QMI_MMODE_CMD_NAS_MCFG_REFRESH_EVT_CB, qmi_nas_mcfg_refresh_evt  );
#endif // FEATURE_MODEM_CONFIG_REFRESH
  memset( &qmi_nas_state, 0x00, sizeof(qmi_nasi_state_type) );
  memset( &qmi_nasi_cfg, 0x00, sizeof(qmi_nasi_cfg) );
#ifdef FEATURE_MODEM_CONFIG_REFRESH
  /*-------------------------------------------------------------------------
      Register with MCFG for NV/EFS refresh event
   -------------------------------------------------------------------------*/

  memset(&mcfg_refresh_reg,0,sizeof(mcfg_refresh_registration_s_type));
  mcfg_refresh_reg.order       = MCFG_REFRESH_ORDER_50;
  mcfg_refresh_reg.slot_mask   = MCFG_REFRESH_INDEX_MASK_ALL;
  mcfg_refresh_reg.sub_mask    = MCFG_REFRESH_INDEX_MASK_ALL;
  mcfg_refresh_reg.cb          = qmi_nas_mcfg_refresh_evt_cb;

  if(mcfg_refresh_register(&mcfg_refresh_reg) == FALSE)
  {
    QM_MSG_ERROR("qmi_nas_init() mcfg_refresh_register failed");
  }
#endif // FEATURE_MODEM_CONFIG_REFRESH
  /*-----------------------------------------------------------------------
    Register service with QMUX.
  -----------------------------------------------------------------------*/
  qmi_nasi_cfg.fw_cfg.base_version.major     = NASI_BASE_VER_MAJOR;
  qmi_nasi_cfg.fw_cfg.base_version.minor     = NASI_BASE_VER_MINOR;

  qmi_nasi_cfg.fw_cfg.addendum_version.major = NASI_ADDENDUM_VER_MAJOR;
  qmi_nasi_cfg.fw_cfg.addendum_version.minor = NASI_ADDENDUM_VER_MINOR;

  qmi_nasi_cfg.fw_cfg.cbs.alloc_clid         = qmi_nas_fw_alloc_clid_cb;
  qmi_nasi_cfg.fw_cfg.cbs.dealloc_clid       = qmi_nas_fw_dealloc_clid_cb;
  qmi_nasi_cfg.fw_cfg.cbs.init_cback         = qmi_nas_fw_init_cb;
  qmi_nasi_cfg.fw_cfg.cbs.cmd_hdlr           = qmi_nas_fw_cmd_hdlr_cb;

  qmi_nasi_cfg.cmd_hdlr_array                = qmi_nasi_cmd_callbacks;
  qmi_nasi_cfg.cmd_num_entries               = NASI_CMD_MAX;
  qmi_nasi_cfg.service_id                    = QMUX_SERVICE_NAS;

  errval = qmi_framework_reg_service( QMUX_SERVICE_NAS, &qmi_nasi_cfg.fw_cfg );

  svc_obj =  nas_get_service_object_v01();
  (void) qmi_si_register_object ( svc_obj,
                                  0, /* Service Instance */
                                  nas_get_service_impl_v01() );

  if ( errval != QMI_FRAMEWORK_ERR_NONE )
  {
    QM_MSG_ERROR_1("qmi_nas_init() qmi_framework_reg_service failed %d", errval);
    return;
  }
} /* qmi_nas_init() */

#ifdef FEATURE_MODEM_CONFIG_REFRESH
/*===========================================================================

FUNCTION  QMI_NAS_MCFG_REFRESH_EVT_CB

DESCRIPTION
   This function is the callback to process mcfg refresh ind.
   CB returns TRUE- MCFG will wait for DONE api.
   CB returns FALSE- MCFG will not wait for DONE api
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
boolean qmi_nas_mcfg_refresh_evt_cb
(
  mcfg_refresh_info_s_type *mcfg_refresh_info_ptr
)
{
  mcfg_refresh_info_s_type     *event_info = NULL;
   
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  if(NULL == mcfg_refresh_info_ptr)
  {
    QM_MSG_ERROR("qmi_nas_mcfg_refresh_evt_cb() NULL refresh pointer");
    return FALSE;
  }
  
  /*-----------------------------------------------------------------------
     Allocate buffer for NV refresh event
    -----------------------------------------------------------------------*/
  event_info = (mcfg_refresh_info_s_type *) modem_mem_alloc( sizeof( mcfg_refresh_info_s_type ), MODEM_MEM_CLIENT_QMI_MMODE );

  if(NULL == event_info)
  {
	qmi_voice_mem_error();
    return FALSE;
  }
  
  /*-----------------------------------------------------------------------
     Copy the refresh info
    -----------------------------------------------------------------------*/
    (void) memscpy(event_info,
                   sizeof(mcfg_refresh_info_s_type),
                   mcfg_refresh_info_ptr,
                   sizeof(mcfg_refresh_info_s_type));
  
 /*-------------------------------------------------------------------------
      Post a command to QMI_NAS task to handle this event
  -------------------------------------------------------------------------*/
  qmi_mmode_send_cmd( QMI_MMODE_CMD_NAS_MCFG_REFRESH_EVT_CB, event_info);

  return TRUE;

}/*qmi_nas_mcfg_refresh_evt_cb*/
#endif // FEATURE_MODEM_CONFIG_REFRESH

/*===========================================================================
  FUNCTION QMI_NAS_MAP_MODE_PREF_QMI_TO_CM()

  DESCRIPTION
    Map uint16 QMI mode pref to cm_mode_pref_e_type

  PARAMETERS
    qmi_val: mode pref value from QMI

  RETURN VALUE
    mode pref value in CM format (bitmask). Return CM_MODE_PREF_NONE
    for error

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static cm_mode_pref_e_type qmi_nas_map_mode_pref_qmi_to_cm (uint16 qmi_val)
{
  cm_mode_pref_e_type retval = CM_MODE_PREF_NONE;
  QM_MSG_HIGH_1("QMI mode pref value %d", qmi_val);
  switch( qmi_val )
  {
    case QMI_NAS_MODE_PREF_C:     retval = CM_MODE_PREF_CDMA_ONLY;         break;
    case QMI_NAS_MODE_PREF_CG:    retval = CM_MODE_PREF_CDMA_GSM;          break;
    case QMI_NAS_MODE_PREF_CGL:   retval = CM_MODE_PREF_CDMA_GSM_LTE;      break;
    case QMI_NAS_MODE_PREF_CGW:   retval = CM_MODE_PREF_CDMA_GW;           break;
    case QMI_NAS_MODE_PREF_CH:    retval = CM_MODE_PREF_CDMA_HDR_ONLY;     break;
    case QMI_NAS_MODE_PREF_CHG:   retval = CM_MODE_PREF_CDMA_HDR_GSM;      break;
    case QMI_NAS_MODE_PREF_CHGW:  retval = CM_MODE_PREF_CDMA_HDR_GW;       break;
    case QMI_NAS_MODE_PREF_CHL:   retval = CM_MODE_PREF_CDMA_HDR_LTE_ONLY; break;
    case QMI_NAS_MODE_PREF_CL:    retval = CM_MODE_PREF_CDMA_LTE_ONLY;     break;
    case QMI_NAS_MODE_PREF_CWL:   retval = CM_MODE_PREF_CDMA_WCDMA_LTE;    break;
    case QMI_NAS_MODE_PREF_G:     retval = CM_MODE_PREF_GSM_ONLY;          break;
    case QMI_NAS_MODE_PREF_GL:    retval = CM_MODE_PREF_GSM_LTE;           break;
    case QMI_NAS_MODE_PREF_GW:    retval = CM_MODE_PREF_GSM_WCDMA_ONLY;    break;
    case QMI_NAS_MODE_PREF_GWL:   retval = CM_MODE_PREF_GWL;               break;
    case QMI_NAS_MODE_PREF_GT:    retval = CM_MODE_PREF_TDS_GSM;           break;
    case QMI_NAS_MODE_PREF_H:     retval = CM_MODE_PREF_HDR_ONLY;          break;
    case QMI_NAS_MODE_PREF_HGL:   retval = CM_MODE_PREF_HDR_GSM_LTE;       break;
    case QMI_NAS_MODE_PREF_HL:    retval = CM_MODE_PREF_HDR_LTE_ONLY;      break;
    case QMI_NAS_MODE_PREF_HWL:   retval = CM_MODE_PREF_HDR_WCDMA_LTE;     break;
    case QMI_NAS_MODE_PREF_L:     retval = CM_MODE_PREF_LTE_ONLY;          break;
    case QMI_NAS_MODE_PREF_T:     retval = CM_MODE_PREF_TDS_ONLY;          break;
    case QMI_NAS_MODE_PREF_TGWL:  retval = CM_MODE_PREF_TDS_GSM_WCDMA_LTE; break;
    case QMI_NAS_MODE_PREF_TGW:   retval = CM_MODE_PREF_TDS_GSM_WCDMA;     break;
    case QMI_NAS_MODE_PREF_W:     retval = CM_MODE_PREF_WCDMA_ONLY;        break;
    case QMI_NAS_MODE_PREF_WL:    retval = CM_MODE_PREF_WCDMA_LTE;         break;
    case QMI_NAS_MODE_PREF_TCHGWL: retval = CM_MODE_PREF_AUTOMATIC;    break;
    case QMI_NAS_MODE_PREF_TL:    retval = CM_MODE_PREF_TDS_LTE;           break;
    case QMI_NAS_MODE_PREF_TGL:   retval = CM_MODE_PREF_TDS_GSM_LTE;       break;
    case QMI_NAS_MODE_PREF_TW:     retval = CM_MODE_PREF_TDS_WCDMA;        break;
    case QMI_NAS_MODE_PREF_TWL:   retval = CM_MODE_PREF_TDS_WCDMA_LTE;     break;
    case QMI_NAS_MODE_PREF_TCHGL: retval = CM_MODE_PREF_CDMA_HDR_GSM_TDS_LTE; break;
    case QMI_NAS_MODE_PREF_TCHGW: retval = CM_MODE_PREF_CDMA_HDR_GW_TDS;      break;
    case QMI_NAS_MODE_PREF_TCGW:  retval = CM_MODE_PREF_CDMA_GW_TDS;          break;
    case QMI_NAS_MODE_PREF_CHGL:  retval = CM_MODE_PREF_CDMA_HDR_GSM_LTE;     break;
    case QMI_NAS_MODE_PREF_CGWL:  retval = CM_MODE_PREF_CDMA_GSM_WCDMA_LTE; break;
    case QMI_NAS_MODE_PREF_HTW:   retval = CM_MODE_PREF_HDR_TDS_WCDMA;     break;
    case QMI_NAS_MODE_PREF_HTWL:  retval = CM_MODE_PREF_HDR_TDS_WCDMA_LTE; break;
    case QMI_NAS_MODE_PREF_CHGWL:
      if(TARGET_SUPPORTS_TDS)
      {
        retval = CM_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE;
        break;
      }
      else
      {
        retval = CM_MODE_PREF_AUTOMATIC;
        break;
      }

    default:
      /*unsupported QMI mode pref value*/
      retval = CM_MODE_PREF_NONE;
      break;
  }

  QM_MSG_HIGH_2("QMI mode pref value %d, CM mode pref value %d", qmi_val, retval);
  return retval;
}

/*===========================================================================
  FUNCTION QMI_NAS_MAP_MODE_PREF_CM_TO_QMI()

  DESCRIPTION
    Map cm_mode_pref_e_type to uint16 QMI mode pref

  PARAMETERS
    cm_val: mode pref value from CM

  RETURN VALUE
    mode pref value in QMI format (bitmask). Return QMI_NAS_MODE_PREF_NONE
    for error

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint16 qmi_nas_map_mode_pref_cm_to_qmi (cm_mode_pref_e_type cm_val)
{
  uint16 retval = 0;
  QM_MSG_HIGH_1("CM Mode Pref value %d", cm_val);
  switch( cm_val )
  {
    case CM_MODE_PREF_CDMA_ONLY:         retval = QMI_NAS_MODE_PREF_C;     break;
    case CM_MODE_PREF_CDMA_GSM:          retval = QMI_NAS_MODE_PREF_CG;    break;
    case CM_MODE_PREF_CDMA_GW:           retval = QMI_NAS_MODE_PREF_CGW;   break;
    case CM_MODE_PREF_CDMA_GSM_LTE:      retval = QMI_NAS_MODE_PREF_CGL;   break;
    case CM_MODE_PREF_CDMA_HDR_ONLY:     retval = QMI_NAS_MODE_PREF_CH;    break;
    case CM_MODE_PREF_CDMA_HDR_GSM:      retval = QMI_NAS_MODE_PREF_CHG;   break;
    case CM_MODE_PREF_CDMA_HDR_GW:       retval = QMI_NAS_MODE_PREF_CHGW;  break;
    case CM_MODE_PREF_CDMA_HDR_LTE_ONLY: retval = QMI_NAS_MODE_PREF_CHL;   break;
    case CM_MODE_PREF_CDMA_LTE_ONLY:     retval = QMI_NAS_MODE_PREF_CL;    break;
    case CM_MODE_PREF_CDMA_WCDMA_LTE:    retval = QMI_NAS_MODE_PREF_CWL;   break;
    case CM_MODE_PREF_GSM_ONLY:          retval = QMI_NAS_MODE_PREF_G;     break;
    case CM_MODE_PREF_GSM_LTE:           retval = QMI_NAS_MODE_PREF_GL;    break;
    case CM_MODE_PREF_GSM_WCDMA_ONLY:    retval = QMI_NAS_MODE_PREF_GW;    break;
    case CM_MODE_PREF_GWL:               retval = QMI_NAS_MODE_PREF_GWL;   break;
    case CM_MODE_PREF_HDR_ONLY:          retval = QMI_NAS_MODE_PREF_H;     break;
    case CM_MODE_PREF_HDR_GSM_LTE:       retval = QMI_NAS_MODE_PREF_HGL;   break;
    case CM_MODE_PREF_HDR_LTE_ONLY:      retval = QMI_NAS_MODE_PREF_HL;    break;
    case CM_MODE_PREF_HDR_WCDMA_LTE:     retval = QMI_NAS_MODE_PREF_HWL;   break;
    case CM_MODE_PREF_WCDMA_ONLY:        retval = QMI_NAS_MODE_PREF_W;     break;
    case CM_MODE_PREF_WCDMA_LTE:         retval = QMI_NAS_MODE_PREF_WL;    break;
    case CM_MODE_PREF_LTE_ONLY:          retval = QMI_NAS_MODE_PREF_L;     break;
    case CM_MODE_PREF_TDS_ONLY:          retval = QMI_NAS_MODE_PREF_T;     break;
    case CM_MODE_PREF_TDS_GSM:           retval = QMI_NAS_MODE_PREF_GT;    break;
    case CM_MODE_PREF_TDS_GSM_WCDMA_LTE: retval = QMI_NAS_MODE_PREF_TGWL;  break;
    case CM_MODE_PREF_TDS_GSM_WCDMA:     retval = QMI_NAS_MODE_PREF_TGW;   break;
    case CM_MODE_PREF_CDMA_HDR_GSM_WCDMA_LTE: retval = QMI_NAS_MODE_PREF_CHGWL;  break;
    case CM_MODE_PREF_TDS_LTE:           retval = QMI_NAS_MODE_PREF_TL;    break;
    case CM_MODE_PREF_TDS_GSM_LTE:       retval = QMI_NAS_MODE_PREF_TGL;   break;
    case CM_MODE_PREF_TDS_WCDMA:              retval = QMI_NAS_MODE_PREF_TW;     break;
    case CM_MODE_PREF_TDS_WCDMA_LTE:     retval = QMI_NAS_MODE_PREF_TWL;   break;
    case CM_MODE_PREF_CDMA_HDR_GSM_TDS_LTE: retval = QMI_NAS_MODE_PREF_TCHGL; break;
      case CM_MODE_PREF_CDMA_HDR_GW_TDS:      retval = QMI_NAS_MODE_PREF_TCHGW; break;
      case CM_MODE_PREF_CDMA_GW_TDS:          retval = QMI_NAS_MODE_PREF_TCGW;  break;
    case CM_MODE_PREF_CDMA_HDR_GSM_LTE:   retval = QMI_NAS_MODE_PREF_CHGL;     break;
    case CM_MODE_PREF_HDR_TDS_WCDMA:      retval = QMI_NAS_MODE_PREF_HTW;  break;
    case CM_MODE_PREF_HDR_TDS_WCDMA_LTE:  retval = QMI_NAS_MODE_PREF_HTWL;  break;	

    case CM_MODE_PREF_ANY_BUT_CDMA_HDR:
      if ( TARGET_SUPPORTS_LTE  ) { retval |= QMI_NAS_MODE_PREF_L;}
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_TDS  ) { retval |= QMI_NAS_MODE_PREF_T;}
      break;
	
    case CM_MODE_PREF_ANY_BUT_HDR_TDS:
      if ( TARGET_SUPPORTS_LTE  ) { retval |= QMI_NAS_MODE_PREF_L;}
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      break;
	  
    case CM_MODE_PREF_ANY_BUT_LTE_TDS:
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      if ( TARGET_SUPPORTS_HDR  ) { retval |= QMI_NAS_MODE_PREF_H;}
      break;
	
    case CM_MODE_PREF_ANY_BUT_TDS:
      if ( TARGET_SUPPORTS_LTE  ) { retval |= QMI_NAS_MODE_PREF_L;}
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      if ( TARGET_SUPPORTS_HDR  ) { retval |= QMI_NAS_MODE_PREF_H;}
      break;
	
    case CM_MODE_PREF_ANY_BUT_HDR:
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      if ( TARGET_SUPPORTS_LTE  ) { retval |= QMI_NAS_MODE_PREF_L;}
      if ( TARGET_SUPPORTS_TDS  ) { retval |= QMI_NAS_MODE_PREF_T;}
      break;
	
    case CM_MODE_PREF_ANY_BUT_LTE:
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      if ( TARGET_SUPPORTS_HDR  ) { retval |= QMI_NAS_MODE_PREF_H;}
      if ( TARGET_SUPPORTS_TDS  ) { retval |= QMI_NAS_MODE_PREF_T;}
      break;
	case CM_MODE_PREF_ANY_BUT_HDR_LTE:
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      if ( TARGET_SUPPORTS_TDS  ) { retval |= QMI_NAS_MODE_PREF_T;}
      break;

    // CM_MODE_PREF_DIGITAL_ONLY means different between LTE and non-LTE targets
    case CM_MODE_PREF_DIGITAL_ONLY:
    case CM_MODE_PREF_AUTOMATIC:
      if ( TARGET_SUPPORTS_LTE  ) { retval |= QMI_NAS_MODE_PREF_L;}
      if ( TARGET_SUPPORTS_GSM  ) { retval |= QMI_NAS_MODE_PREF_G;}
      if ( TARGET_SUPPORTS_WCDMA) { retval |= QMI_NAS_MODE_PREF_W;}
      if ( TARGET_SUPPORTS_CDMA ) { retval |= QMI_NAS_MODE_PREF_C;}
      if ( TARGET_SUPPORTS_HDR  ) { retval |= QMI_NAS_MODE_PREF_H;}
      if ( TARGET_SUPPORTS_TDS  ) { retval |= QMI_NAS_MODE_PREF_T;}
      break;

    default:
      /*unsupported CM Mode Pref value */
      retval = QMI_NAS_MODE_PREF_NONE;
      break;
  }

  QM_MSG_HIGH_2("CM mode Pref value %d, QMI mode pref value %d", cm_val, retval);
  return retval;
}

/*===========================================================================
  FUNCTION QMI_NAS_MAP_MODE_PREF_NV_TO_QMI()

  DESCRIPTION
    Map nv_mode_enum_type to uint16 QMI mode pref

  PARAMETERS
    nv_val: mode pref value from NV

  RETURN VALUE
    mode pref value in QMI format (bitmask). Return QMI_NAS_MODE_PREF_NONE
    for error

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint16 qmi_nas_map_mode_pref_nv_to_qmi (nv_mode_enum_type nv_val)
{
  int    i;
  uint16 retval = 0;

  // DIGITAL_ONLY and AUTOMATIC means different between LTE and non-LTE targets
  if (nv_val == NV_MODE_DIGITAL_ONLY || nv_val == NV_MODE_AUTOMATIC)
  {
    retval = QMI_NAS_MODE_PREF_BIT_ALL;
  }
  else if (nv_val == NV_MODE_DIGITAL_LESS_HDR_ONLY)
  {
    retval = QMI_NAS_MODE_PREF_BIT_ALL & ~QMI_NAS_MODE_PREF_BIT_HDR;
  }
  else
  {
    for (i=0; i<QMI_NAS_ARR_SIZE(qmi_nas_allowed_nv_mode_pref); i++)
    {
      if (nv_val == qmi_nas_allowed_nv_mode_pref[i].nv_val)
      {
        retval = qmi_nas_allowed_nv_mode_pref[i].qmi_val;
        break;
      }
    }
  }

  if ( !TARGET_SUPPORTS_GSM   ) { retval &= ~QMI_NAS_MODE_PREF_BIT_GSM;  }
  if ( !TARGET_SUPPORTS_WCDMA ) { retval &= ~QMI_NAS_MODE_PREF_BIT_UMTS; }
  if ( !TARGET_SUPPORTS_CDMA  ) { retval &= ~QMI_NAS_MODE_PREF_BIT_CDMA; }
  if ( !TARGET_SUPPORTS_HDR   ) { retval &= ~QMI_NAS_MODE_PREF_BIT_HDR;  }
  if ( !TARGET_SUPPORTS_LTE   ) { retval &= ~QMI_NAS_MODE_PREF_BIT_LTE;  }

  return retval;
}

/*===========================================================================
   FUNCTION QMI_NAS_MAP_STANDBY_PREF_CM_TO_QMI()

   DESCRIPTION
     Map sys_modem_dual_standby_pref_e_type to uint8 QMI standby_pref

   PARAMETERS
     cm_val: mode pref value from CM

   RETURN VALUE
     mode pref value in QMI format (bitmask). Return QMI_NAS_MODE_PREF_NONE
     for error

   DEPENDENCIES
     None

   SIDE EFFECTS
     None
 ===========================================================================*/
void qmi_nas_map_standby_pref_cm_to_qmi
(
  uint32* qmi_standby_pref,
  sys_modem_dual_standby_pref_e_type cm_standby_pref
)
{
  QM_MSG_HIGH_1("cm_standby_pref value %d", cm_standby_pref);
  switch(cm_standby_pref)
  {
    case SYS_MODEM_DS_PREF_SINGLE_STANDBY:
      *qmi_standby_pref = NAS_SINGLE_STANDBY_V01;
      break;

    case SYS_MODEM_DS_PREF_DUAL_STANDBY:
     *qmi_standby_pref = NAS_DUAL_STANDBY_WITH_TUNE_AWAY_V01;
     break;

    case SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY:
      *qmi_standby_pref = NAS_DUAL_STANDBY_WITHOUT_TUNE_AWAY_V01;
      break;

    case SYS_MODEM_DS_PREF_TRIPLE_STANDBY:
      *qmi_standby_pref = NAS_TRIPLE_STANDBY_V01;
      break;

    case SYS_MODEM_DS_PREF_AUTO:
      *qmi_standby_pref = NAS_AUTOMATIC_WITH_TUNE_AWAY_V01;
      break;

    case SYS_MODEM_DS_PREF_AUTO_NO_TUNEAWAY:
      *qmi_standby_pref = NAS_AUTOMATIC_WITHOUT_TUNE_AWAY_V01;
      break;

    case SYS_MODEM_DS_PREF_NO_CHANGE:
    case SYS_MODEM_DS_PREF_NONE:
    default:
      *qmi_standby_pref = NAS_STANDBY_PREF_ENUM_MIN_ENUM_VAL_V01;
  }

  QM_MSG_HIGH_2("CM standby pref value %d, QMI standby pref value %d",
                cm_standby_pref, *qmi_standby_pref);
}

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_SYS_SEL_PREF_IND()

  DESCRIPTION
    Called when the serving system info changes. Causes
    sys sel pref_ind to be sent to all clients

  PARAMETERS
    CM PH event

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_sys_sel_pref_ind
(
  qmi_cm_ph_info_s_type  *p_info
)
{
  qmi_nasi_client_state_type *  cl_sp;
  int                           client;
  uint8                         emergency_mode;
  uint16                        nasi_mode_pref;

  /*-------------------------------------------------------------------------
    collect information required to generate indication
    - emergency mode and mode preference
    - Band preference
    - prl and roam preference
  -------------------------------------------------------------------------*/
  if ( p_info->mode_pref == CM_MODE_PREF_EMERGENCY )
  {
    emergency_mode = NASI_MODE_EMERGENCY_MODE_ON;

#ifdef FEATURE_DUAL_SIM
    if ( p_info->asubs_id == SYS_MODEM_AS_ID_2 )
    {
      nasi_mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( qmi_nasi_global.last_mode_pref2 );
    }
    else 
#endif
#ifdef FEATURE_TRIPLE_SIM
    if ( p_info->asubs_id == SYS_MODEM_AS_ID_3 )
    {
      nasi_mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( qmi_nasi_global.last_mode_pref3 );
    }
    else
#endif
    {
      nasi_mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( qmi_nasi_global.last_mode_pref );
    }
  }
  else
  {
    emergency_mode = NASI_MODE_EMERGENCY_MODE_OFF;
    nasi_mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( p_info->mode_pref );
  }


  /*-------------------------------------------------------------------------
    broadcast system selection pref indication to all registered clients
  -------------------------------------------------------------------------*/
  for(client = 0; client < NASI_MAX_CLIDS; client++)
  {
    cl_sp = qmi_nas_state.client[client];

    if ( cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
           cl_sp->report_status.reg_sys_sel_pref &&
           cl_sp->report_status.bound_subs == (enum qmi_nas_subs_e)p_info->asubs_id
         )
      {
      qmi_nasi_sys_sel_pref_ind( cl_sp,
                                   emergency_mode,
                                   nasi_mode_pref,
                                   (uint64)p_info->band_pref,
                                   (uint16)p_info->prl_pref,
                                   (uint16)p_info->roam_pref,
                                   (sys_lte_band_mask_e_type)p_info->lte_band_pref,
                                 (uint64)p_info->tds_band_pref,
                                   (uint8)p_info->network_sel_mode_pref,
                                   (uint32)p_info->srv_domain_pref,
                                   (uint32)p_info->acq_order_pref,
                                   p_info->plmn,
                                   p_info->acq_pri_order_pref,
                                   p_info->ue_usage_setting,
                                   p_info->csg_id,
                                   p_info->csg_rat,
                                   p_info->voice_domain_pref
                                  );
      }
    }
} /* qmi_nas_generate_sys_sel_pref_ind() */

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_CURRENT_NAM_IND()

  DESCRIPTION
    Called when the curent name changes.
    Causes current_nam_ind to be sent to all clients

  PARAMETERS
    CM PH event

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_current_nam_ind ( qmi_cm_ph_info_s_type  *p_info )
{
  qmi_nasi_client_state_type *  cl_sp;
  int                           client;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    broadcast current nam indication to all registered clients
  -------------------------------------------------------------------------*/
  for(client = 0; client < NASI_MAX_CLIDS; client++)
  {
    cl_sp = qmi_nas_state.client[client];

    if( cl_sp && (cl_sp->common.clid != QMI_SVC_CLID_UNUSED) &&
         (cl_sp->report_status.reg_current_nam))
      {
      qmi_nasi_current_nam_ind( cl_sp, (uint8) p_info->curr_nam );
    }
  }
} /* qmi_nas_generate_current_nam_ind() */

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_DDTM_IND()

  DESCRIPTION
    Called when the ddtm status changes.
    Causes ddtm_ind to be sent to all clients

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_ddtm_ind
(
  qmi_cm_ph_info_s_type  *p_info
)
{
  qmi_nasi_client_state_type *  cl_sp;
  int                           client;

  /*-------------------------------------------------------------------------
    broadcast DDTM indication to all registered clients
  -------------------------------------------------------------------------*/
  for(client = 0; client < NASI_MAX_CLIDS; client++)
  {
    cl_sp = qmi_nas_state.client[client];

    if(cl_sp && (cl_sp->common.clid != QMI_SVC_CLID_UNUSED) &&
         (cl_sp->report_status.reg_ddtm_events))
      {
        qmi_nasi_ddtm_ind(
            cl_sp,
              p_info->cur_ddtm_status,
              p_info->ddtm_pref,
              p_info->ddtm_act_mask,
              (uint8)p_info->ddtm_num_srv_opt,
              p_info->ddtm_srv_opt_list);
      }
    }
} /* qmi_nas_generate_ddtm_ind() */

/*===========================================================================
  FUNCTION QMI_NAS_GEN_DUAL_STANDBY_PREF_IND()

  DESCRIPTION
    generate QMI_NAS_DUAL_STANDBY_PREF_IND by comparing new CM PH event and
    last CM PH event cache

  PARAMETERS
    pointer to new CM PH event
===========================================================================*/
void qmi_nas_gen_dual_standby_pref_ind( qmi_cm_ph_info_s_type *p_info )
{
  qmi_cm_ph_info_s_type                     *p_old_info;
  boolean                               info_changed = FALSE;
  nas_dual_standby_pref_ind_msg_v01     *ind_msg;
  dsm_item_type                         *ind;
  int                                   client;
  qmi_nasi_client_state_type            *cl_sp;

  ind_msg = (nas_dual_standby_pref_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_dual_standby_pref_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if(ind_msg != NULL)
  {
  memset( ind_msg, 0x00, sizeof(nas_dual_standby_pref_ind_msg_v01) );

  switch ( p_info->asubs_id )
  {
#ifdef FEATURE_TRIPLE_SIM
    case SYS_MODEM_AS_ID_3:
      p_old_info = &qmi_nasi_global.cm_ph_info3;
      break;
#endif
#ifdef FEATURE_DUAL_SIM
    case SYS_MODEM_AS_ID_2:  // TODO: need to revisit this logic
      p_old_info = &qmi_nasi_global.cm_ph_info2;
      break;
#endif
    case SYS_MODEM_AS_ID_1:
      p_old_info = &qmi_nasi_global.cm_ph_info;
      break;
    default:
      p_old_info = NULL;
      QM_MSG_HIGH_1("asubs_id is not handled %d", p_info->asubs_id);
      break;
  }

  // check if we need to send indication
  if (   p_old_info != NULL &&
       ( p_old_info->standby_pref      != p_info->standby_pref  ||
         p_old_info->active_subs       != p_info->active_subs   ||
         p_old_info->priority_subs     != p_info->priority_subs ||
         p_old_info->default_data_subs != p_info->default_data_subs ||
         p_old_info->default_voice_subs != p_info->default_voice_subs )
       )
  {
    info_changed = TRUE;
  }

  if ( info_changed )
  {
    // fill out the message
    qmi_nas_map_standby_pref_cm_to_qmi((uint32*)&ind_msg->standby_pref.standby_pref, p_info->standby_pref );
    ind_msg->standby_pref.priority_subs      = (nas_subs_type_enum_v01)p_info->priority_subs;
    ind_msg->standby_pref.active_subs        = (nas_subs_type_enum_v01)p_info->active_subs;
    ind_msg->standby_pref.default_data_subs  = (nas_subs_type_enum_v01)p_info->default_data_subs;
    ind_msg->default_voice_subs              = (nas_subs_type_enum_v01)p_info->default_voice_subs;
    ind_msg->standby_pref_valid              = TRUE;
    ind_msg->default_voice_subs_valid        = TRUE;

    ind_msg->active_subs_mask_valid = TRUE;
    if ( p_info->standby_pref == SYS_MODEM_DS_PREF_NO_STANDBY_PREF )
    {
      ind_msg->active_subs_mask = 0;
    }
    else if ( p_info->standby_pref == SYS_MODEM_DS_PREF_SINGLE_STANDBY )
    {
#ifdef FEATURE_TRIPLE_SIM
      if ( p_info->active_subs == SYS_MODEM_AS_ID_3 )
      {
        ind_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_TERTIARY_V01;
      } 
      else 
#endif
      if ( p_info->active_subs == SYS_MODEM_AS_ID_2 )
      {
        ind_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
      }
      else
      {
        ind_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
      }
    }
    else if ( p_info->standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY ||
              p_info->standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY )
    {
      ind_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
      ind_msg->active_subs_mask |= QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( p_info->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY ||
              p_info->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY )
    {
      ind_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
      ind_msg->active_subs_mask |= QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
      ind_msg->active_subs_mask |= QMI_NAS_ACTIVE_SUB_TERTIARY_V01;
    }
#endif
    else
    {
      ind_msg->active_subs_mask_valid = FALSE;
    }

    // then send the message
    for ( client=0; client < NASI_MAX_CLIDS; client++ )
    {
      cl_sp = qmi_nas_state.client[client];

      if ( cl_sp && cl_sp->common.clid != NASI_CLID_UNUSED &&
               cl_sp->report_status.report_dual_standby_pref_ind ) // need to send all clients regardless they are bound to primary or secondary
      {
        // TODO: dwbeacon: send indication to primary subs for asubs_id 1 and secondary subs for asubs_id 2

        ind = NULL;                                                                         // Important!  When multiple encode calls may be made.
        if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_INDICATION,
                                           (uint16_t) QMI_NAS_DUAL_STANDBY_PREF_IND_MSG_V01,
                                           (void *) ind_msg,
                                           (uint32_t) sizeof( nas_dual_standby_pref_ind_msg_v01 ),
                                           &ind ) )
        {
          qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_DUAL_STANDBY_PREF_IND, ind );
        }
      }
      else
      {
        if( cl_sp != NULL )
        {
          QM_MSG_HIGH_3("not sending DUAL_STANDBY_PREF_IND for client %d %d %d", cl_sp->common.clid, cl_sp->report_status.bound_subs, cl_sp->report_status.report_dual_standby_pref_ind);
        }
        else
        {
          //QM_MSG_ERROR("not sending DUAL_STANDBY_PREF_IND cl_sp is NULL");
        }
      }
    }
  }
  else
  {
    QM_MSG_HIGH("no effective change in dual standby pref");
  }
}
  else
  {
	qmi_voice_mem_error();
  }

  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_REG_ATTACH_RESP()

  DESCRIPTION
    Called when error_cb() supplied in cm_ph functions are called
    by CM. Sends response to control point for the correspoding
    Register, Attach and other Ph cmd related requests.

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_reg_attach_resp
(
  void *               user_data,
  cm_ph_cmd_err_e_type ph_cmd_err
)
{
  dsm_item_type *        response = NULL;
  qmi_cmd_buf_type *     cmd_buf_p;
  qmi_error_e_type       errval;
  qmi_result_e_type      result;
  boolean                retval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  errval = QMI_ERR_NONE;
  cmd_buf_p = (qmi_cmd_buf_type *) user_data;

  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
  {
    return;
  }
  else if(cmd_buf_p == NULL)
  {
    QM_MSG_HIGH("Null cmd_buf ptr");
    return;
  }
  else if ( cmd_buf_p->x_p == NULL )
  {
    QM_MSG_ERROR("null x_p");
    return;
  }

  /*-------------------------------------------------------------------------
    Send SUCCESS or FAILURE response to control point based on ph_cmd_err

    SUCCESS => For all phone related operations, the control point must not
    assume SUCCESS here, only with the corresponding state changes in inds
    sent after this can success be assumed. E.g. CM register or attach has
    been initiated, the actual result will be conveyed through serving system
    indication.

    FAILURE => There was an error. E.g register or attach action failed
  -------------------------------------------------------------------------*/
  switch (ph_cmd_err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE;
      break;

      /* For REGISTER & ATTACH */
    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE;
      break;

      /* For Register */
    case CM_PH_CMD_ERR_PLMN_P:
      errval = QMI_ERR_NO_NETWORK_FOUND;
      break;

    case CM_PH_CMD_ERR_SYS_SEL_PREF_S:
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
      break;

      /* For SET_SYS_SEL_PREF */
    case CM_PH_CMD_ERR_API_NOT_SUPPORTED_S:
    case CM_PH_CMD_ERR_PS_LOCAL_DETACH_NOT_ALLOWED_S:
      errval = QMI_ERR_INVALID_OPERATION;
      break;

    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);

  if (FALSE == retval)
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
	/*Send Network Scan response*/
  }
} /* qmi_nas_generate_reg_attach_err_resp() */

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_NET_SCAN_ERR_RESP()

  DESCRIPTION
    Called when error_cb() supplied in cm_ph_cmd_get_networks() is called
    by CM. Sends error response to control point if error is reported by CM

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : Error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_net_scan_err_resp
(
  void *               user_data,
  cm_ph_cmd_err_e_type ph_cmd_err
)
{
  dsm_item_type      *response;
  qmi_cmd_buf_type   *cmd_buf_p;
  qmi_error_e_type    errval;
  qmi_result_e_type   result;
  boolean             retval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    If no error reported, then Don't send any response now. Response will be
    sent when corresponding CM event(AVAILABLE_NETWROKS_CONF) occurs
  -------------------------------------------------------------------------*/
  if (ph_cmd_err == CM_PH_CMD_ERR_NOERR)
  {
    return;
  }

  /*-------------------------------------------------------------------------
    Return response with appropriate error code
  -------------------------------------------------------------------------*/
  switch (ph_cmd_err)
  {
    case CM_PH_CMD_ERR_NET_TYPE_P:
      errval = QMI_ERR_INVALID_OPERATION;
      break;

    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE;
      break;

    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }

  result = QMI_RESULT_FAILURE;
  qmi_nasi_global.net_scan_started = FALSE;

  /*-------------------------------------------------------------------------
    Complete pending network_scan transaction
  -------------------------------------------------------------------------*/
  while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_NW_SCAN )) != NULL )
  {
    if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
    {
      continue;
    }
    response = NULL;
    retval = qmi_svc_put_result_tlv(&response, result, errval);
    if(FALSE == retval)
    {
      dsm_free_packet(&response);
      qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
      continue;
    }
    qmi_nasi_send_response( cmd_buf_p, response);
     /*Send Network Scan response*/
  }
} /* qmi_nas_generate_net_scan_err_resp() */

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_NET_SCAN_RESP_EXT()

  DESCRIPTION
    Used to send the network scan response to the control point when CM calls
    qmi_nas_network_scan_cb() with async response

  PARAMETERS
    available_networks : List of networks resulting from the network scan
    available_networks_list_cnf: Scan result

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_net_scan_resp_ext
(
  sys_found_plmn_list_u_type *available_networks,
  sys_plmn_list_status_e_type    available_networks_list_cnf,
  cm_network_list_type_e_type list_type
)
{
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  qmi_error_type_v01       errval = QMI_ERR_NONE_V01;
  boolean gen_resp_now = FALSE;
  qmi_nas_mmgsdi_session_e_type qmi_session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  mmgsdi_plmn_id_list_type      plmn_id_list;
  struct qmi_nasi_mmgsdi_client_data_s *callback_data;
  uint32 sys_plmn_list_index;  
  mmgsdi_eons_ignore_disp_cond_enum_type ignore_disp = MMGSDI_EONS_IGNORE_RPLMN_DISPLAY_COND;

  if(list_type == CM_NETWORK_LIST_PCI_SCAN )
  {

    QM_MSG_HIGH_2("PCI_SCAN: generate_net_scan resp/ind(list_cnf=%d, incremental status=%d)",
                 available_networks_list_cnf,
                 qmi_nasi_global.incremental_net_scan_status);
  }
  else
  {
  QM_MSG_HIGH_3("generate_net_scan resp/ind(list_cnf=%d, length=%d,incremental status=%d)",
                 available_networks_list_cnf, available_networks->plmn_list.length,
                 qmi_nasi_global.incremental_net_scan_status);
  }


  if ( qmi_nasi_global.net_scan_asubs_id == SYS_MODEM_AS_ID_2 )
  {
    qmi_session = QMI_NAS_MMGSDI_GW_SEC_SESSION;
  }
#ifdef FEATURE_TRIPLE_SIM
  else if ( qmi_nasi_global.net_scan_asubs_id == SYS_MODEM_AS_ID_3 )
  {
    qmi_session = QMI_NAS_MMGSDI_GW_TER_SESSION;
  }
#endif


  plmn_id_list.num_of_plmn_ids = MIN( NAS_3GPP_NETWORK_INFO_LIST_MAX_V01, available_networks->plmn_list.length);
  
  
  if( list_type != CM_NETWORK_LIST_PCI_SCAN &&
      plmn_id_list.num_of_plmn_ids > 0 && 
     ( available_networks_list_cnf == SYS_PLMN_LIST_SUCCESS || 
      ( ( available_networks_list_cnf == SYS_PLMN_LIST_PARTIAL || 
          available_networks_list_cnf == SYS_PLMN_LIST_AS_ABORT )&& 
         qmi_nasi_global.incremental_net_scan_status == QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_INPROGRESS ) ) )
  {
    mmgsdi_plmn_id_type plmn_list[NAS_3GPP_NETWORK_INFO_LIST_MAX_V01];

    if( qmi_nasi_global.incremental_net_scan_status == QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_INPROGRESS)
    {
      if(available_networks_list_cnf == SYS_PLMN_LIST_SUCCESS)
      {
        qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_DONE;
        QM_MSG_HIGH("Incremental scan is done");
      }
      else if( available_networks_list_cnf == SYS_PLMN_LIST_AS_ABORT )
      {
        qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_AS_ABORT;
        QM_MSG_HIGH("Incremental scan done but aborted");
      }
      else
      {
        QM_MSG_ERROR("Not Handled...");
      }
    }
		      
    // Put plmn list into mmgsdi structure for get_operator_name call
    for(sys_plmn_list_index=0; sys_plmn_list_index < plmn_id_list.num_of_plmn_ids; sys_plmn_list_index++)
    {
      memscpy( &plmn_list[sys_plmn_list_index].plmn_id_val, MMGSDI_PLMN_ID_SIZE * sizeof(uint8), &available_networks->plmn_list.info[sys_plmn_list_index].plmn.identity, MMGSDI_PLMN_ID_SIZE * sizeof(uint8) );
#ifdef FEATURE_FEMTO_CSG
      if ( qm_efs_csg_supported() )
      {
      plmn_list[sys_plmn_list_index].csg_id = available_networks->plmn_list.info[sys_plmn_list_index].csg_info.csg_id;
      }
      else
      {
        plmn_list[sys_plmn_list_index].csg_id = SYS_CSG_ID_INVALID;
      }
#else 
        plmn_list[sys_plmn_list_index].csg_id = SYS_CSG_ID_INVALID;
#endif
      plmn_list[sys_plmn_list_index].rat = qmi_nas_rat_cm_scan_to_mmgsdi( available_networks->plmn_list.info[sys_plmn_list_index].rat );
    }

    plmn_id_list.plmn_list_ptr = plmn_list;

    callback_data = (struct qmi_nasi_mmgsdi_client_data_s*)modem_mem_alloc(sizeof(struct qmi_nasi_mmgsdi_client_data_s), MODEM_MEM_CLIENT_QMI_MMODE);
    if( callback_data != NULL )
    {
      callback_data->cmd_buf_ptr = (void *)modem_mem_alloc(sizeof(sys_detailed_plmn_list_s_type), MODEM_MEM_CLIENT_QMI_MMODE);

      if( callback_data->cmd_buf_ptr != NULL )
      {
        memscpy(callback_data->cmd_buf_ptr, sizeof(sys_detailed_plmn_list_s_type), 
                      &available_networks->plmn_list, sizeof(sys_detailed_plmn_list_s_type));
      }
      callback_data->reason      = NAS_CMD_PERFORM_NETWORK_SCAN;



      if( MMGSDI_SUCCESS != mmgsdi_session_get_operator_name_ext ( qmi_nasi_global.mmgsdi.session_id[qmi_session],
                                                              plmn_id_list,
                                                                   ignore_disp,
                                                              qmi_nas_mmgsdi_cmd_rsp_cb,
                                                              (uint32) callback_data ) )
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_HIGH("network_scan: get_operator_name failed");
        gen_resp_now = TRUE;
        if( callback_data->cmd_buf_ptr != NULL )
        {
          modem_mem_free( callback_data->cmd_buf_ptr, MODEM_MEM_CLIENT_QMI_MMODE );
        }
        modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
      }
    }
    else
    {
	qmi_voice_mem_error();
      errval = QMI_ERR_INTERNAL_V01;
      gen_resp_now = TRUE;
    }
  }
  else
  {
    gen_resp_now = TRUE;
  }

  if( gen_resp_now )
  {
    if(qmi_nasi_global.incremental_net_scan_status != QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE)
    {
      nas_scan_status_enum_v01 scan_status = NAS_SCAN_STATUS_ABORT_V01;

      /*Wait for next report insted of sending error indication in case if incremental scan is still going on*/
      if(available_networks_list_cnf == SYS_PLMN_LIST_PARTIAL )
      {
        QM_MSG_HIGH("Wait for next scan result");
        return;
      }
      if ( errval == QMI_ERR_NONE_V01 )
      {
        switch( available_networks_list_cnf )
        {
          case SYS_PLMN_LIST_AS_ABORT:
            scan_status = NAS_SCAN_STATUS_ABORT_V01;
            break;
          case SYS_PLMN_LIST_REJ_IN_RLF:
            scan_status = NAS_SCAN_STATUS_REJ_IN_RLF_V01;
            break;
          default:
            QM_MSG_HIGH_1("Unhandled type for scan result %d",available_networks_list_cnf);
            break;
        }
      } // End if QMI_ERR_NONE_V01
      qmi_nasi_generate_perform_incremental_network_scan_err_ind(scan_status);

    } // !QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE
    else if(list_type == CM_NETWORK_LIST_PCI_SCAN && (available_networks_list_cnf == SYS_PLMN_LIST_SUCCESS)) 
      {
        qmi_nasi_generate_perform_network_scan_resp_pci_scan( available_networks );
      }
    else
    {
      qmi_cmd_buf_type      *cmd_buf_p = NULL;
      nas_perform_network_scan_resp_msg_v01 *rsp_msg   = NULL;
      dsm_item_type *        response   = NULL;

      if( available_networks_list_cnf == SYS_PLMN_LIST_PARTIAL ) 
      {
        QM_MSG_HIGH( "Ignoring partial results!!!");
        return;
      }

      // Clear pending network scan global var
      qmi_nasi_global.net_scan_started = FALSE;

      rsp_msg = (nas_perform_network_scan_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_perform_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
      if( rsp_msg == NULL)
      {
        qmi_voice_mem_error();
        errval = QMI_ERR_NO_MEMORY_V01;
      }

      while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_NW_SCAN )) != NULL )
      {
        if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
        {
          continue;
        }

        if( errval != QMI_ERR_NO_MEMORY_V01 )
        {
          memset(rsp_msg, 0, sizeof(nas_perform_network_scan_resp_msg_v01));

          // Populate TLV 0x02 (Mandatory error code)
          rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01) ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01;
          rsp_msg->resp.error  = errval;

          if ( errval == QMI_ERR_NONE_V01 )
          {
            if(list_type != CM_NETWORK_LIST_PCI_SCAN)
            {  
              rsp_msg->nas_3gpp_network_info_len = available_networks->plmn_list.length;

            // TLV 0x10 will be available at all times. including for num_instances = 0
            // (Gobi backward compatibility)
            rsp_msg->nas_3gpp_network_info_valid = TRUE;
            }

            rsp_msg->scan_result_valid = TRUE;
            switch( available_networks_list_cnf )
            {
              case SYS_PLMN_LIST_SUCCESS:
                rsp_msg->scan_result = NAS_SCAN_SUCCESS_V01;
                break;
  
              case SYS_PLMN_LIST_AS_ABORT:
                rsp_msg->nas_3gpp_network_info_len = 0;
                rsp_msg->scan_result = NAS_SCAN_AS_ABORT_V01;
                break;
 
              case SYS_PLMN_LIST_REJ_IN_RLF:
                rsp_msg->nas_3gpp_network_info_len = 0;
                rsp_msg->scan_result = NAS_SCAN_REJ_IN_RLF_V01;
                break;
 
              default:
                rsp_msg->scan_result_valid = FALSE;
                QM_MSG_HIGH_1("Unhandled type for scan result %d", available_networks_list_cnf);
                break;
            }
          }

          response = NULL;

          if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_RESPONSE,
                                             (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                             (void *) rsp_msg,
                                             (uint32_t) sizeof(nas_perform_network_scan_resp_msg_v01),
                                             &response
                                           ) )
          {
			  qmi_nasi_send_response( cmd_buf_p, response);
          }
          else
          {
            dsm_free_packet(&response);
            qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
          }
        } // End if
      }// end while (cmd buf queue is empty)

      if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
    }
  }
#endif /* #if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */ 
} /* qmi_nas_generate_network_scan_resp_ext */

/*===========================================================================
  FUNCTION QMI_NAS_GET_HPLMN_SEARCH_TIMER_RESP()

  DESCRIPTION
    Send response for GET_HPLMN_SEARCH_TIMER
        
  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type
    
  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_get_hplmn_search_timer_resp( uint32 timer_value )
{
  dsm_item_type *        response = NULL;
  qmi_error_e_type       errval = QMI_ERR_NONE;
  struct nas_0079_rsp_s *rsp_msg   = NULL;
  qmi_cmd_buf_type      *cmd_buf_p = qmi_nasi_global.get_hplmn_cmd_buf_p;

  if ( cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in GET_HPLMN_SEARCH_TIMER resp: %d", cmd_buf_p);
    qmi_nasi_global.get_hplmn_cmd_buf_p = NULL;
    return; //nothing to send
  }

  rsp_msg = (struct nas_0079_rsp_s *) modem_mem_alloc( sizeof(struct nas_0079_rsp_s), MODEM_MEM_CLIENT_QMI_MMODE ); 
  if( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    qmi_nasi_global.get_hplmn_cmd_buf_p = NULL;
    return;
  }

  memset(rsp_msg, 0, sizeof(struct nas_0079_rsp_s));

  if( errval == QMI_ERR_NONE )
  {
    rsp_msg->t10.timer_value = timer_value;
    rsp_msg->t10_valid = TRUE;
  }

  rsp_msg->t02.result_code = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg->t02.error_code  = errval;
  rsp_msg->t02_valid       = TRUE;

  if ( qmi_nas_0079_rsp_write ( rsp_msg, &response ) == QMI_ERR_NONE )
  {
     qmi_nasi_send_response( cmd_buf_p, response);
    }
  else
  {
    dsm_free_packet(&response); 
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }

  if ( rsp_msg ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  qmi_nasi_global.get_hplmn_cmd_buf_p = NULL;

} /* qmi_nas_get_hplmn_search_timer_resp() */

/*===========================================================================
  FUNCTION QMI_NAS_SET_DUAL_STANDBY_PREF_RESP()

  DESCRIPTION
    Send response for SET_DUAL_STANDBY_PREF_REQ

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_dual_standby_pref_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *                         response = NULL;
  qmi_error_type_v01                      errval   = QMI_ERR_NONE_V01;
  boolean                                 retval   = TRUE;
  nas_set_dual_standby_pref_resp_msg_v01 *resp_msg;

  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf || !p_cmd_buf->x_p )
  {
    /*Null cmd_buf ptr*/
    return;
  }

  switch (err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE_V01;
      break;

    case CM_PH_CMD_ERR_NET_TYPE_P:
      errval = QMI_ERR_INVALID_OPERATION_V01;
      break;

    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE_V01;
      break;

    case CM_PH_CMD_ERR_DDS_REJECT_NETWORK_NOT_ALLOWED:
      errval = QMI_ERR_OP_NETWORK_UNSUPPORTED_V01;
      break;

    default:
      errval = QMI_ERR_INTERNAL_V01;
      break;
  }
  resp_msg = (nas_set_dual_standby_pref_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_dual_standby_pref_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_dual_standby_pref_resp_msg_v01) );
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)((qmi_cmd_buf_type*)p_cmd_buf)->cmd_type,
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_set_dual_standby_pref_resp_msg_v01),
                                           &response
                                         );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &p_cmd_buf );
  }
  else if ( !qmi_nasi_send_response( p_cmd_buf, response ) )
  {
    QM_MSG_HIGH("QMI_NAS_SET_DUAL_STANDBY_PREF_RESP send failed");
  }
  
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nas_set_dual_standby_pref_resp() */


/*===========================================================================
  FUNCTION QMI_NAS_SET_PLMN_BLOCKING_RESP()

  DESCRIPTION
    Send response for DETACH_LTE, BLOCK_LTE_PLMN, UNBLOCK_LTE_PLMN and
    RESET_LTE_PLMN_BLOCKING

  PARAMETERS
    p_cmd_buf   : user data
    err         : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_plmn_blocking_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *        response = NULL;
  qmi_error_e_type       errval;
  qmi_result_e_type      result;
  boolean                retval;

  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf || !p_cmd_buf->x_p )
  {
    /*Null cmd_buf ptr*/
    return;
  }

  errval = ( err == CM_PH_CMD_ERR_NOERR ) ? QMI_ERR_NONE : QMI_ERR_INTERNAL;

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &p_cmd_buf );
  }
  else if ( !qmi_nasi_send_response( p_cmd_buf, response ) )
  {
    QM_MSG_HIGH("QMI NAS PLMN Blocking Response send failed");
  }
} /* qmi_nas_set_dual_standby_pref_resp() */

/*===========================================================================
  FUNCTION QMI_NAS_SET_HPLMN_IRAT_SEARCH_TIMER_RESP()

  DESCRIPTION
    Send response for HPLMN_IRAT_SEARCH_TIMER

  PARAMETERS
    p_cmd_buf   : user data
    err         : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_hplmn_irat_search_timer_resp(qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type ph_cmd_err)
{
  dsm_item_type *response = NULL;
  qmi_error_e_type          errval;
  qmi_result_e_type         result;
  boolean                   retval;
  qmi_cmd_buf_type          *cmd_buf_p;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  errval = QMI_ERR_NONE;
  cmd_buf_p = (qmi_cmd_buf_type *) p_cmd_buf;

  if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in SET_HPLMN_IRAT_SEARCH_TIMER callback");
    return;
  }

  switch (ph_cmd_err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE;
      break;

    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_SET_HPLMN_SEARCH_TIMER_RESP() 

  DESCRIPTION
    Send response for SET_HPLMN_SEARCH_TIMER
        
  PARAMETERS
    p_cmd_buf   : user data
    err         : error type
    
  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_hplmn_search_timer_resp(qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type ph_cmd_err)
{
  dsm_item_type *response = NULL;
  qmi_error_e_type          errval;
  qmi_result_e_type         result;
  boolean                   retval;
  qmi_cmd_buf_type          *cmd_buf_p;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  errval = QMI_ERR_NONE;
  cmd_buf_p = (qmi_cmd_buf_type *) p_cmd_buf;

  if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in SET_HPLMN_SEARCH_TIMER callback");
    return;
  }

  switch (ph_cmd_err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE;
      break;

    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS 
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
    /*Send qmi_nas_set_hplmn_search_timer_resp response*/
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_GET_HPLMN_SEARCH_TIMER_ERR_RESP() 

  DESCRIPTION
    Send error response for GET_HPLMN_SEARCH_TIMER
        
  PARAMETERS
    p_cmd_buf   : user data
    err         : error type
    
  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_get_hplmn_search_timer_err_resp(qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type ph_cmd_err)
{
  dsm_item_type *response = NULL;
  qmi_error_e_type          errval = QMI_ERR_NONE;
  qmi_result_e_type         result;
  boolean                   retval;
  qmi_cmd_buf_type          *cmd_buf_p = (qmi_cmd_buf_type *) p_cmd_buf;

  if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in GET_HPLMN_SEARCH_TIMER callback");
    qmi_nasi_global.get_hplmn_cmd_buf_p = NULL;
    return;
  }

  /*-------------------------------------------------------------------------
    If no error reported, then Don't send any response now. Response will be 
    sent when corresponding CM event(GET_HPLMN_TIMER) occurs
  -------------------------------------------------------------------------*/
  if (ph_cmd_err == CM_PH_CMD_ERR_NOERR)
  {
    return;
  }

  switch (ph_cmd_err)
  {
    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS 
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
    /*send qmi_nas_get_hplmn_search_timer_resp response*/
  }

  qmi_nasi_global.get_hplmn_cmd_buf_p = NULL;
}

#if defined(FEATURE_MMGSDI_SESSION_LIB)
/*===========================================================================
  FUNCTION QMI_NAS_PROCESS_MMGSDI_OPERATION_COMPLETE()

  DESCRIPTION
    Callback function called by mmgsdi to return response

  PARAMETERS
    status  : return status
    cnf     : type of cnf response
    cnf_ptr : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_mmgsdi_operation_complete
(
  mmgsdi_cnf_enum_type    cnf_type,
  mmgsdi_cnf_type        *cnf_data
)
{
  qmi_cmd_buf_type        *cmd_buf_p;
  qmi_nasi_cmd_val_e_type  cmd;

  if (cnf_data == NULL)
  {
    QM_MSG_HIGH("Received NULL cnf_data in MMGSDI callback for NAS");
    return;
  }

  switch (cnf_type)
  {
    case MMGSDI_READ_CNF:

      cmd_buf_p = (qmi_cmd_buf_type *)cnf_data->read_cnf.response_header.client_data;

      if (cmd_buf_p == NULL)
      {
        QM_MSG_HIGH("Received NULL cmd_buf in MMGSDI READ CNF callback for NAS");
        return;
      }
      cmd = (qmi_nasi_cmd_val_e_type)cmd_buf_p->cmd_type;

      QM_MSG_MED_1("MMGSDI READ CNF, cmd:%d", cmd);

      switch (cmd)
      {
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
        case NASI_CMD_VAL_GET_PREFERRED_NETWORKS:
          qmi_nasi_generate_get_preferred_nw_resp( &cnf_data->read_cnf );
          break;
        case NASI_CMD_VAL_GET_FORBIDDEN_NETWORKS:
          qmi_nasi_generate_get_forbidden_nw_resp( &cnf_data->read_cnf );
          break;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
        default:
          QM_MSG_ERROR_1("Received unsolicited read confirmation for command %d", (int)cmd);
          break;
      }
      break;

    case MMGSDI_WRITE_CNF:

      cmd_buf_p = (qmi_cmd_buf_type *)cnf_data->write_cnf.response_header.client_data;

      if (cmd_buf_p == NULL)
      {
        QM_MSG_HIGH("Received NULL cmd_buf in MMGSDI WRITE CNF callback for NAS");
        return;
      }
      cmd = (qmi_nasi_cmd_val_e_type)cmd_buf_p->cmd_type;

      switch (cmd)
      {
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
        case NASI_CMD_VAL_SET_PREFERRED_NETWORKS:
          qmi_nasi_generate_set_preferred_nw_resp( &cnf_data->write_cnf );
          break;
        case NASI_CMD_VAL_SET_FORBIDDEN_NETWORKS:
          qmi_nasi_generate_set_forbidden_nw_resp( &cnf_data->write_cnf );
          break;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */
        default:
          QM_MSG_ERROR_1("Received unsolicited write confirmation for command %d", (int)cmd);
          break;
      }
      break;

    case MMGSDI_GET_FILE_ATTR_CNF:
      switch (cnf_data->get_file_attr_cnf.access.file.file_enum)
      {
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM)
        case MMGSDI_GSM_PLMNWACT:
        case MMGSDI_USIM_PLMNWACT:
          if ( (cnf_data->response_header.mmgsdi_status ==
                  MMGSDI_SUCCESS) &&
               (cnf_data->get_file_attr_cnf.file_attrib.file_size > 0) )
          {
            qmi_nasi_global.mmgsdi_ef_info.plmn_wact =
              QMI_NASI_MMGSDI_PLMN_EF_FOUND;
          }
          else
          {
            qmi_nasi_global.mmgsdi_ef_info.plmn_wact =
              QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
          }
          break;

        case MMGSDI_GSM_OPLMNWACT:
        case MMGSDI_USIM_OPLMNWACT:
          if ( (cnf_data->response_header.mmgsdi_status ==
                  MMGSDI_SUCCESS) &&
               (cnf_data->get_file_attr_cnf.file_attrib.file_size > 0) )
          {
            qmi_nasi_global.mmgsdi_ef_info.oplmn_wact =
              QMI_NASI_MMGSDI_PLMN_EF_FOUND;
          }
          else
          {
            qmi_nasi_global.mmgsdi_ef_info.oplmn_wact =
              QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
          }
          break;

        case MMGSDI_GSM_PLMN:
          if ( (cnf_data->response_header.mmgsdi_status ==
                  MMGSDI_SUCCESS) &&
               (cnf_data->get_file_attr_cnf.file_attrib.file_size > 0) )
          {
            qmi_nasi_global.mmgsdi_ef_info.plmn =
              QMI_NASI_MMGSDI_PLMN_EF_FOUND;
          }
          else
          {
            qmi_nasi_global.mmgsdi_ef_info.plmn =
              QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
          }
          break;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */
        default:
          QM_MSG_ERROR("Received unsolicited GET_FILE_ATTR confirmation");
          break;
      }
      break;

    default:
      QM_MSG_ERROR_1("Received unsolicited confirmation %d", (int)cnf_type);
      break;
  }
} /* qmi_nas_process_mmgsdi_operation_complete */

#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */


/*===========================================================================
  FUNCTION qmi_nas_process_mmgsdi_get_operator_name()

  DESCRIPTION
    Process information from mmgsdi_get_operator_name

  PARAMETERS
    p_nas: pointer to nas structure in command queue item

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_mmgsdi_get_operator_name (
  const mmgsdi_cnf_type        *cnf_data
)
{
  struct qmi_nasi_mmgsdi_client_data_s *callback_data;
  enum qmi_nasi_calling_cmd             cmd;

  if (cnf_data == NULL)
  {
    QM_MSG_HIGH("Received NULL cnf_data in MMGSDI callback for NAS");
    return;
  }

  callback_data = (struct qmi_nasi_mmgsdi_client_data_s *)cnf_data->session_get_operator_name_cnf.response_header.client_data;

  if (callback_data == NULL)
  {
    QM_MSG_HIGH("Received NULL cmd_buf in MMGSDI GET OPERATOR NAME CNF callback for NAS");
    return;
  }
  cmd = callback_data->reason;

  switch (cmd)
  {
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
    case NAS_CMD_PERFORM_NETWORK_SCAN:
      if(qmi_nasi_global.incremental_net_scan_status != QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE)
      {
        qmi_nasi_generate_perform_incremental_network_scan_ind( &cnf_data->session_get_operator_name_cnf );
      }
      else
      {
        qmi_nasi_generate_perform_network_scan_resp( &cnf_data->session_get_operator_name_cnf );
      }
      break;
    case NAS_CMD_GET_PLMN_NAME:
      qmi_nasi_generate_get_plmn_name_resp( &cnf_data->session_get_operator_name_cnf );
      break;
    case NAS_CMD_GET_HOME_NETWORK:
      qmi_nasi_generate_get_home_network_resp( &cnf_data->session_get_operator_name_cnf );
      break;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
    default:
      ERR( "Received unsolicited read confirmation for command %d", (int)cmd, 0, 0 );
      break;
  }
} /* qmi_nas_process_mmgsdi_get_operator_name */


/*===========================================================================
  FUNCTION qmi_nas_process_mmgsdi_get_se13_plmn_names()

  DESCRIPTION
    Process information from mmgsdi_get_se13_plmn_names

  PARAMETERS
    p_nas: pointer to nas structure in command queue item

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_process_mmgsdi_get_se13_plmn_names (
  const mmgsdi_cnf_type        *cnf_data
)
{
  struct qmi_nasi_mmgsdi_client_data_s *callback_data;
  enum qmi_nasi_calling_cmd             cmd;

  if (cnf_data != NULL)
  {
    callback_data = (struct qmi_nasi_mmgsdi_client_data_s *)cnf_data->get_se13_plmn_names_cnf.response_header.client_data;

    if (callback_data != NULL)
    {
      cmd = callback_data->reason;

      switch (cmd)
      {
        case NAS_CMD_GET_PLMN_NAME:
          qmi_nasi_generate_get_se13_plmn_name_resp( &cnf_data->get_se13_plmn_names_cnf );
          break;

        default:
          QM_MSG_ERROR_1("Received unsolicited read confirmation for command %d", (int)cmd);
          break;
      }
    }
    else
    {
      QM_MSG_HIGH("Received NULL cmd_buf in MMGSDI GET OPERATOR NAME CNF callback for NAS");
    }
  }
  else
  {
    QM_MSG_HIGH("Received NULL cnf_data in MMGSDI callback for NAS");
  }
}

/*===========================================================================

                             INTERNAL FUNCTIONS

===========================================================================*/

/*=============================================================================
FUNCTION: QMI_NAS_GET_HOME_MCC_MNC

DESCRIPTION: Reads the MCC and MNC from SIM.

PARAMETERS:
  None

RETURN VALUE:
  None

DEPENDENCIES:
  None

SIDE EFFECTS:
  None
=============================================================================*/
void qmi_nas_get_home_mcc_mnc( void )
{
  // dummy just to aleviate dependency from ds_qmi_task.c.
  // TODO: remove
}

/*===========================================================================
  FUNCTION QMI_NASI_RESET()

  DESCRIPTION
    Reset the issuing client's NAS state

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_reset
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type          * response = NULL;
  qmi_error_type_v01       errval   = QMI_ERR_NONE_V01;
//nas_reset_req_msg_v01  * nas_reset_req;
  nas_reset_resp_msg_v01 * nas_reset_resp;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

//nas_reset_req  = (nas_reset_req_msg_v01  *) modem_mem_alloc( sizeof( nas_reset_req_msg_v01  ), MODEM_MEM_CLIENT_QMI_MMODE );
  nas_reset_resp = (nas_reset_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_reset_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

//if ( nas_reset_req  == NULL )
//{
//  QM_MSG_ERROR("Not enough memory to allocate for QMI_NAS_RESET request.");
//  errval = QMI_ERR_NO_MEMORY_V01;
//}
//
//if ( errval == QMI_ERR_NONE_V01 )
//{
//  memset( nas_reset_req, 0x00, sizeof( nas_reset_req_msg_v01 ) );
//
//  errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
//                                         (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
//                                         sdu_in,
//                                         (void *) nas_reset_req,
//                                         (uint32_t) sizeof( nas_reset_req_msg_v01 )
//                                       );
//}
//
//if (errval == QMI_ERR_NONE_V01)
//{
//  errval = qmi_nas_0000_req_check( nas_reset_req );
//}
//
//if ( errval == QMI_ERR_NONE_V01 )
//{
    QM_MSG_HIGH("qmi_nasi_reset resetting client");
    qmi_nasi_reset_client( cl_sp );
//}

  if ( nas_reset_resp != NULL )
  {
    memset( nas_reset_resp, 0x00, sizeof( nas_reset_resp_msg_v01 ) );

    nas_reset_resp->resp.error  = errval;
    nas_reset_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) nas_reset_resp,
                                  (uint32_t) sizeof( nas_reset_resp_msg_v01 ),
                                  &response
                                );
  }
  else
{
    qmi_voice_mem_error();
}

//if ( nas_reset_req  != NULL ) { modem_mem_free( (void *) nas_reset_req,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( nas_reset_resp != NULL ) { modem_mem_free( (void *) nas_reset_resp, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_reset() */

/*===========================================================================
  FUNCTION QMI_NASI_NETWORK_SCAN_ABORT_HDLR()

  DESCRIPTION
    Abort handler for the network scan operation

  PARAMETERS
    nas_sp     : Service provided state pointer
    cmd_buf_p  : Ptr to the cmd buf to be aborted

  RETURN VALUE
    TRUE       : Abort succeeded
    FALSE      : Abort Failed

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_nasi_network_scan_abort_hdlr
(
  qmi_cmd_buf_type *     cmd_buf_p
)
{
  qmi_cmd_buf_type *  aborted_cmd_buf_p;
  dsm_item_type *     aborted_cmd_response;
  boolean             retval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    extract cmd_buf_p under queue function (mutexed) to ensure that
     CM task concurrent cm_network_scan_cb doesn't mess things up.
  -------------------------------------------------------------------------*/
  aborted_cmd_buf_p = qm_cbpq_del_specific_item( QM_CBPQ_QTYPE_NW_SCAN, cmd_buf_p );

  if(aborted_cmd_buf_p == NULL)
  {
    QM_MSG_HIGH("Network Scan completed but response still pending transaction completion!");
    return FALSE;
  }

  if(qm_cbpq_count( QM_CBPQ_QTYPE_NW_SCAN ) == 0)
  {
    /*-----------------------------------------------------------------------
      Issue terminate req to CM, Don't bother about success of terminate
      req irrespective send ABORT SUCCESS to client and ignore any
      network scan result that comes (AVALIABLE_CONF event)
    -----------------------------------------------------------------------*/
#ifdef FEATURE_DUAL_SIM
    {
      qmi_nasi_client_state_type  *cl_sp = NULL;
      
      cl_sp = (qmi_nasi_client_state_type*)qmi_nasi_get_cl_sp_by_cmd_buf( cmd_buf_p );
      if(cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED)
      {
         QM_MSG_HIGH_1("terminate_get_networks Sub:%d",cl_sp->report_status.bound_subs );
         (void) cm_ph_cmd_terminate_get_networks_per_subs(NULL,
                                            NULL,
                                            qmi_nasi_global.cm_clnt_id,
                                            (sys_modem_as_id_e_type)cl_sp->report_status.bound_subs  );
      	}
    }
#else
    (void) cm_ph_cmd_terminate_get_networks(NULL,
                                            NULL,
                                            qmi_nasi_global.cm_clnt_id);
#endif
    /*-----------------------------------------------------------------------
      reset net_scan_started state variable, so that any new scan requests
      result in issuing a cmd to CM
    -----------------------------------------------------------------------*/
    qmi_nasi_global.net_scan_started = FALSE;
  }
  else
  {
    QM_MSG_HIGH("More net scan requests pending, returning abort success");
  }

  /*-----------------------------------------------------------------------
    Send a response for the aborted cmd with ERR_ABORTED
  -----------------------------------------------------------------------*/
  aborted_cmd_response = NULL;
  retval = qmi_svc_put_result_tlv(&aborted_cmd_response,
                                  QMI_RESULT_FAILURE,
                                  QMI_ERR_ABORTED);
  if(FALSE == retval)
  {
    dsm_free_packet(&aborted_cmd_response);
    qmi_mmode_svc_free_transaction_cmd_buf( &aborted_cmd_buf_p );
    return FALSE;
  }

   qmi_nasi_send_response( aborted_cmd_buf_p, aborted_cmd_response);

  return TRUE;
} /* qmi_nasi_network_scan_abort_hdlr */

/*===========================================================================
  FUNCTION QMI_NASI_ABORT()

  DESCRIPTION
    Abort an outstanding NAS command specified by transaction ID

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_abort
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response = NULL;
  qmi_nasi_client_state_type * nas_client_sp = (qmi_nasi_client_state_type *) cl_sp;
  uint8                        tx_ix         = 0;
  uint8                      cmd;

  qmi_error_type_v01           errval        = QMI_ERR_NONE_V01;
  nas_abort_req_msg_v01      * nas_abort_req;
  nas_abort_resp_msg_v01     * nas_abort_resp;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  nas_abort_req  = (nas_abort_req_msg_v01  *) modem_mem_alloc( sizeof(nas_abort_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  nas_abort_resp = (nas_abort_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_abort_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( nas_abort_req == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset( nas_abort_req, 0x00, sizeof(nas_abort_req_msg_v01) );

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *) nas_abort_req,
                                           (uint32_t) sizeof(nas_abort_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0001_req_check( nas_abort_req );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = QMI_ERR_INVALID_TX_ID_V01;

    for ( tx_ix = 0 ; tx_ix < MAX_PENDING_TRANSACTIONS ; tx_ix++ )
    {
      if ( nas_client_sp->common.transactions[tx_ix].x_id == nas_abort_req->tx_id )
      {
        errval = QMI_ERR_NONE_V01;
        break;
      }
    }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( tx_ix < MAX_PENDING_TRANSACTIONS )
    { //lint requires this check
      errval = QMI_ERR_UNABORTABLE_TRANSACTION_V01;

      for (cmd=0; cmd<nas_client_sp->common.transactions[tx_ix].n_cmds; cmd++)
      {
        if (nas_client_sp->common.transactions[tx_ix].cmd_list[cmd]->cmd_type == NASI_CMD_VAL_PERFORM_NETWORK_SCAN)
        {
          if (TRUE == qmi_nasi_network_scan_abort_hdlr( nas_client_sp->common.transactions[tx_ix].cmd_list[cmd]))
          {
            errval = QMI_ERR_NONE_V01;
          }
          }
          }
        }
      }

  if ( errval == QMI_ERR_INVALID_TX_ID_V01 )
    {
    QM_MSG_HIGH_1("Transaction (0x%x) not outstanding - can't abort!", nas_abort_req->tx_id);
    }
  else if ( errval == QMI_ERR_UNABORTABLE_TRANSACTION_V01 )
  {
    QM_MSG_HIGH_1("Transaction 0x%x not abortable.", nas_abort_req->tx_id);
    }

  if ( nas_abort_resp != NULL )
    {
    memset( nas_abort_resp, 0x00, sizeof(nas_abort_resp_msg_v01) );

    nas_abort_resp->resp.error  = errval;
    nas_abort_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) nas_abort_resp,
                                  (uint32_t) sizeof(nas_abort_resp_msg_v01),
                                  &response
                                );
    }
  else
  {
    qmi_voice_mem_error();
  }

  if ( nas_abort_req  != NULL ) { modem_mem_free( (void *) nas_abort_req,  MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( nas_abort_resp != NULL ) { modem_mem_free( (void *) nas_abort_resp, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_abort() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_EVENT_REPORT()

  DESCRIPTION
    To set state for event reporting

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_set_event_report
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_nasi_client_state_type *  nasi_client_sp;

  qmi_error_e_type               errval = QMI_ERR_NONE;
  boolean                        call_cm_api = FALSE;

  nas_set_event_report_req_msg_v01    *req_msg;
  nas_set_event_report_resp_msg_v01   rsp_msg;
  dsm_item_type  *response = NULL;
  
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp); ASSERT(cmd_buf_p); ASSERT(cl_sp); ASSERT(sdu_in);

  nasi_client_sp = (qmi_nasi_client_state_type *)cl_sp;

  req_msg = (nas_set_event_report_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_event_report_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    return NULL;

  }

  memset (req_msg, 0x00, sizeof(nas_set_event_report_req_msg_v01));
  // extract information from REQ message
  errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                         sdu_in,
                                         (void *) req_msg,
                                         (uint32_t) sizeof(nas_set_event_report_req_msg_v01)
                                       );
  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_0002_req_check (req_msg);
  }

  if (errval == QMI_ERR_NONE)
  {
    struct report_status_s *p_rs = &nasi_client_sp->report_status; // shorthand

    // change signal strength reporting if tlv included in request
    if (req_msg->signal_strength_valid)
    {
      if ( req_msg->signal_strength.report_signal_strength == NAS_0002_REQ_REPORT )
      {
        p_rs->report_sig_str = TRUE;
        p_rs->num_thresholds = req_msg->signal_strength.report_signal_strength_threshold_list_len;
        memscpy((void*)p_rs->sig_str_thresholds, 
			  sizeof(p_rs->sig_str_thresholds),
                       (const void*)req_msg->signal_strength.report_signal_strength_threshold_list, 
                       req_msg->signal_strength.report_signal_strength_threshold_list_len * sizeof(int8_t) );

        qsort( (void*)p_rs->sig_str_thresholds, p_rs->num_thresholds, sizeof(signed char), qmi_nas_byte_array_compare );
      }
      else
      {
        p_rs->report_sig_str     = FALSE;
        p_rs->last_reported_rssi_ex = NASI_SIG_STRENGTH_INACTIVE_RSSI;
      }
    }

    // change RF info (band/chan) reporting if tlv included in request
    if (req_msg->report_rf_band_info_valid)
      p_rs->report_rf_band_info = req_msg->report_rf_band_info;

    // change registration reject info reporting if tlv included in request
    if (req_msg->report_reg_reject_valid)
      p_rs->report_reg_reject_reason = req_msg->report_reg_reject;

    // setting rssi delta reporting if tlv included in request
    if (req_msg->rssi_indicator_valid)
    {
      call_cm_api             = TRUE;
      p_rs->report_rssi         = req_msg->rssi_indicator.report_rssi;
      p_rs->report_rssi_delta = req_msg->rssi_indicator.rssi_delta;

      if ( !p_rs->report_rssi )
      {
        p_rs->last_reported_rssi_ex = NASI_SIG_STRENGTH_INACTIVE_RSSI;
      }

      if ( req_msg->rssi_indicator.rssi_delta < qmi_nasi_global.min_rssi_delta )
        qmi_nasi_global.min_rssi_delta = req_msg->rssi_indicator.rssi_delta;
    }


    // setting io delta reporting if tlv included in request
    if (req_msg->io_indicator_valid)
    {
      call_cm_api           = TRUE;
      p_rs->report_io       = req_msg->io_indicator.report_io;
      p_rs->report_io_delta = req_msg->io_indicator.io_delta;

      if( !p_rs->report_io  )
      {
        p_rs->last_reported_io = NASI_SIG_STRENGTH_INACTIVE_IO;
      }

      if ( req_msg->io_indicator.io_delta < qmi_nasi_global.min_io_delta )
        qmi_nasi_global.min_io_delta =  req_msg->io_indicator.io_delta;
    }



    if (req_msg->report_error_rate_valid)
      p_rs->report_error_rate = req_msg->report_error_rate;

    if (req_msg->rsrq_indicator_valid)
    {
      call_cm_api           = TRUE;
      p_rs->report_rsrq = req_msg->rsrq_indicator.report_rsrq;
      p_rs->report_rsrq_delta = req_msg->rsrq_indicator.rsrq_delta;

      if ( req_msg->rsrq_indicator.rsrq_delta < qmi_nasi_global.min_rsrq_delta )
      {
        qmi_nasi_global.min_rsrq_delta = req_msg->rsrq_indicator.rsrq_delta;
      }
    }

    // setting ecio delta reporting if tlv included in request
    if (req_msg->ecio_indicator_valid && !req_msg->ecio_threshold_indicator_valid )
    {
      call_cm_api             = TRUE;
      p_rs->report_ecio               = req_msg->ecio_indicator.report_ecio;
      p_rs->report_ecio_delta      = req_msg->ecio_indicator.ecio_delta;
      p_rs->reporting_mode_ecio = NASI_EVENT_REPORT_MODE_DELTA;

      if( !p_rs->report_ecio  )
      {
        p_rs->last_reported_ecio = NASI_SIG_STRENGTH_INACTIVE_ECIO;
      }
    }
    else if ( req_msg->ecio_threshold_indicator_valid )
    {

      if ( req_msg->ecio_threshold_indicator.report_ecio == NAS_0002_REQ_REPORT )
      {
        call_cm_api               = TRUE;
        p_rs->report_ecio               = req_msg->ecio_threshold_indicator.report_ecio;
        p_rs->reporting_mode_ecio = NASI_EVENT_REPORT_MODE_THRESHOLD;
        p_rs->num_thresholds_ecio = req_msg->ecio_threshold_indicator.threshold_list_len;

        if( !p_rs->report_ecio  )
        {
          p_rs->last_reported_ecio = NASI_SIG_STRENGTH_INACTIVE_ECIO;
        }

        if ( req_msg->ecio_threshold_indicator.threshold_list_len <= NAS_ECIO_THRESHOLD_LIST_MAX_V01 )
        {
         memscpy((void *)p_rs->ecio_thresholds, 
                 (sizeof(req_msg->ecio_threshold_indicator.threshold_list[0]) * req_msg->ecio_threshold_indicator.threshold_list_len),
                 (const void *) req_msg->ecio_threshold_indicator.threshold_list, 
                 (sizeof(req_msg->ecio_threshold_indicator.threshold_list[0])  * req_msg->ecio_threshold_indicator.threshold_list_len) );
        }
        else
        {
          errval = QMI_ERR_ARG_TOO_LONG;
        }
      }
      else
      {
        p_rs->report_ecio        = FALSE;
        p_rs->last_reported_ecio = NASI_SIG_STRENGTH_INACTIVE_ECIO ;
      }
    }

    // setting sinr delta reporting if tlv included in request
    if (req_msg->sinr_indicator_valid && !req_msg->sinr_threshold_indicator_valid)
    {
      call_cm_api           = TRUE;
      p_rs->report_sinr               = req_msg->sinr_indicator.report_sinr;
      p_rs->report_sinr_delta      = req_msg->sinr_indicator.sinr_delta;
      p_rs->reporting_mode_sinr = NASI_EVENT_REPORT_MODE_DELTA;
      if( !p_rs->report_sinr  )
      {
        p_rs->last_reported_sinr = NASI_SIG_STRENGTH_INACTIVE_SINR;
      }
    }
    else if ( req_msg->sinr_threshold_indicator_valid)
    {
      if( req_msg->sinr_threshold_indicator.report_sinr == NAS_0002_REQ_REPORT )
      {
        call_cm_api               = TRUE;
        p_rs->report_sinr         = req_msg->sinr_threshold_indicator.report_sinr;
        p_rs->reporting_mode_sinr = NASI_EVENT_REPORT_MODE_THRESHOLD;
        p_rs->num_thresholds_sinr = req_msg->sinr_threshold_indicator.threshold_list_len;

        if( !p_rs->report_sinr  )
        {
          p_rs->last_reported_sinr = NASI_SIG_STRENGTH_INACTIVE_SINR;
        }

        if ( req_msg->sinr_threshold_indicator.threshold_list_len <= NAS_SINR_THRESHOLD_LIST_MAX_V01 )
        {
          memscpy((void *)p_rs->sinr_thresholds, (sizeof(req_msg->sinr_threshold_indicator.threshold_list[0]) * req_msg->sinr_threshold_indicator.threshold_list_len),
                  (const void *) req_msg->sinr_threshold_indicator.threshold_list, (sizeof(req_msg->sinr_threshold_indicator.threshold_list[0]) * req_msg->sinr_threshold_indicator.threshold_list_len) );
        }
        else
        {
          errval = QMI_ERR_ARG_TOO_LONG;
        }
      }
      else
      {
        p_rs->report_sinr        = FALSE;
        p_rs->last_reported_sinr = NASI_SIG_STRENGTH_INACTIVE_SINR ;
      }
    }

    if ( req_msg->lte_snr_delta_indicator_valid )
    {
      call_cm_api                  = TRUE;
      p_rs->report_lte_snr            = req_msg->lte_snr_delta_indicator.report_lte_snr;
      p_rs->report_lte_snr_delta   = req_msg->lte_snr_delta_indicator.lte_snr_delta;

      if( !p_rs->report_lte_snr )
      {
        p_rs->last_reported_lte_snr = NASI_LTE_SNR_STRENGTH_INACTIVE;
      }

    }

    if ( req_msg->lte_rsrp_delta_indicator_valid )
    {
      call_cm_api                   = TRUE;
      p_rs->report_lte_rsrp         =  req_msg->lte_rsrp_delta_indicator.report_lte_rsrp;
      p_rs->report_lte_rsrp_delta   =  req_msg->lte_rsrp_delta_indicator.lte_rsrp_delta;

      if( !p_rs->report_lte_rsrp )
      {
        p_rs->last_reported_lte_rsrp = NASI_SIG_STRENGTH_INACTIVE_RSRP;
      }
    }

    // Set the RSSI/ECIO/IO/SIR delta value by calling cm function
    if ( errval == QMI_ERR_NONE )
    {
      if (call_cm_api)
      {
        if (!cm_ph_cmd_signal_strength_delta_lte( qmi_nas_cmph_cmd_cb,
                                          cmd_buf_p,
                                          qmi_nasi_global.cm_clnt_id,
                                          qmi_nasi_global.min_rssi_delta,
                                          NASI_MIN_ECIO_DELTA,
                                          qmi_nasi_global.min_io_delta,
                                          NASI_MIN_SINR_DELTA,
                                          NASI_SIG_STRENGTH_DELTA_NO_CHANGE, //pathloss_delta
                                          NASI_SIG_STRENGTH_DELTA_NO_CHANGE, //cqi_delta
                                          qmi_nasi_global.min_rsrp_delta,    //rsrp_delta
                                          qmi_nasi_global.min_rsrq_delta ))
        {
          QM_MSG_ERROR("Unable to set rssi, ecio, io, sinr, and rsrq delta");
          errval = QMI_ERR_INTERNAL;
        }
        QM_MSG_HIGH("Response pending for Set rssi, ecio, io, sinr and rsrq delta ");
      }
    }
  }

  if (call_cm_api && errval == QMI_ERR_NONE)
  {
    response = (dsm_item_type*) QMI_SVC_RESPONSE_PENDING; 
  }
  else if( cmd_buf_p != NULL )
  {
    rsp_msg.resp.error  = (qmi_error_type_v01)errval;
    rsp_msg.resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) &rsp_msg,
                                  (uint32_t) sizeof(nas_set_event_report_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
} /* qmi_nasi_set_event_report() */

/*===========================================================================
  FUNCTION QMI_NASI_INDICATION_REGISTER()

  DESCRIPTION
    Set the registration state for the following QMI NAS indciation
    1. System selection preference indication
    2. Current nam indication
    3. DDTM events indication

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_indication_register
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                 *response  = NULL;
  qmi_nasi_client_state_type    *nasi_client_sp;

  qmi_error_type_v01             errval = QMI_ERR_NONE_V01;

  nas_indication_register_req_msg_v01  *nas_ind_reg_req;
  nas_indication_register_resp_msg_v01 *nas_ind_reg_resp;


  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  nasi_client_sp = (qmi_nasi_client_state_type *) cl_sp;

  nas_ind_reg_req  = ( nas_indication_register_req_msg_v01  *)modem_mem_alloc(sizeof(nas_indication_register_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);
  nas_ind_reg_resp = ( nas_indication_register_resp_msg_v01 *)modem_mem_alloc(sizeof(nas_indication_register_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

  if ( nas_ind_reg_req == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(nas_ind_reg_req, 0, sizeof(nas_indication_register_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *)nas_ind_reg_req,
                                           (uint32_t)sizeof(nas_indication_register_req_msg_v01)
                                         );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_nas_0003_req_check(nas_ind_reg_req);
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    struct report_status_s *p_rs = &nasi_client_sp->report_status;

    if ( nas_ind_reg_req->reg_sys_sel_pref_valid ) // system selection preference TLV 0x10
    {
      if ( nas_ind_reg_req->reg_sys_sel_pref == FALSE )
      {
        p_rs->reg_sys_sel_pref = FALSE;
      }
      else if ( nas_ind_reg_req->reg_sys_sel_pref == TRUE )
      {
        p_rs->reg_sys_sel_pref = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_ddtm_events_valid ) // DDTM events TLV 0x12
    {
      if ( nas_ind_reg_req->reg_ddtm_events == FALSE )
      {
        p_rs->reg_ddtm_events = FALSE;
      }
      else if ( nas_ind_reg_req->reg_ddtm_events == TRUE )
      {
        p_rs->reg_ddtm_events = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->req_serving_system_valid ) // serving system events TLV 0x13
    {
      if ( nas_ind_reg_req->req_serving_system == FALSE )
      {
        p_rs->not_report_serving_system = TRUE;
      }
      else if ( nas_ind_reg_req->req_serving_system == TRUE )
      {
        p_rs->not_report_serving_system = FALSE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->dual_standby_pref_valid ) // dual standby pref TLV 0x14
    {
      if ( nas_ind_reg_req->dual_standby_pref == FALSE )
      {
        p_rs->report_dual_standby_pref_ind = FALSE;
      }
      else if ( nas_ind_reg_req->dual_standby_pref == TRUE )
      {
        p_rs->report_dual_standby_pref_ind = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->subscription_info_valid ) // subscription info TLV 0x15
    {
      if ( nas_ind_reg_req->subscription_info == FALSE )
      {
        p_rs->report_subscription_info_ind = FALSE;
      }
      else if ( nas_ind_reg_req->subscription_info == TRUE )
      {
        p_rs->report_subscription_info_ind = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_network_time_valid ) // reg_network_time TLV 0x17
    {
      if (nas_ind_reg_req->reg_network_time == FALSE )
      {
        p_rs->report_network_time = FALSE;
      }
      else if (nas_ind_reg_req->reg_network_time == TRUE )
      {
        p_rs->report_network_time = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->sys_info_valid ) // sys_info TLV 0x18
    {
      if (nas_ind_reg_req->sys_info == FALSE )
      {
        p_rs->report_sys_info = FALSE;
      }
      else if (nas_ind_reg_req->sys_info== TRUE )
      {
        p_rs->report_sys_info = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->sig_info_valid ) // sig_info TLV 0x19
    {
      if (nas_ind_reg_req->sig_info == FALSE )
      {
        p_rs->report_sig_info = FALSE;
      }
      else if (nas_ind_reg_req->sig_info== TRUE )
      {
        p_rs->report_sig_info = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->err_rate_valid ) // err_rate TLV 0x1A
    {
      if (nas_ind_reg_req->err_rate == FALSE )
      {
        p_rs->report_err_rate = FALSE;
      }
      else if (nas_ind_reg_req->err_rate== TRUE )
      {
        p_rs->report_err_rate = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    if ( nas_ind_reg_req->reg_hdr_uati_valid ) // reg_hdr_uati TLV 0x1B
    {
      if (nas_ind_reg_req->reg_hdr_uati == FALSE )
      {
        p_rs->report_uati = FALSE;
      }
      else if (nas_ind_reg_req->reg_hdr_uati == TRUE )
      {
        p_rs->report_uati = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_hdr_session_close_valid ) // reg_hdr_session_close TLV 0x1C
    {
      if (nas_ind_reg_req->reg_hdr_session_close == FALSE )
      {
        p_rs->report_session_close = FALSE;
      }
      else if (nas_ind_reg_req->reg_hdr_session_close == TRUE )
      {
        p_rs->report_session_close = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_managed_roaming_valid ) // reg_managed_roaming TLV 0x1D
    {
      if ( nas_ind_reg_req->reg_managed_roaming == FALSE )
      {
        p_rs->report_managed_roaming = FALSE;
      }
      else if ( nas_ind_reg_req->reg_managed_roaming == TRUE )
      {
        p_rs->report_managed_roaming = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_current_plmn_name_valid ) // reg_current_plmn_name TLV 0x1E
    {
      if ( nas_ind_reg_req->reg_current_plmn_name == FALSE )
      {
        p_rs->report_current_plmn_name = FALSE;
      }
      else if ( nas_ind_reg_req->reg_current_plmn_name == TRUE )
      {
        p_rs->report_current_plmn_name = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_embms_status_valid ) // reg_embms_status TLV 0x1F
    {
      if ( nas_ind_reg_req->reg_embms_status == FALSE )
      {
        p_rs->report_embms_status = FALSE;
      }
      else if ( nas_ind_reg_req->reg_embms_status == TRUE )
      {
        p_rs->report_embms_status = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_rf_band_info_valid ) // reg_rf_band_info TLV 0x20
    {
      if ( nas_ind_reg_req->reg_rf_band_info == FALSE )
      {
        p_rs->report_rf_band_info_ind = FALSE;
      }
      else if ( nas_ind_reg_req->reg_rf_band_info == TRUE )
      {
        p_rs->report_rf_band_info_ind = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->network_reject_valid ) // network_reject TLV 0x21
    {
      if ( nas_ind_reg_req->network_reject.reg_network_reject == FALSE )
      {
        p_rs->network_reject.report_network_reject_ind = FALSE;
        p_rs->network_reject.suppress_sys_info_on_reject = FALSE;
      }
      else if ( nas_ind_reg_req->network_reject.reg_network_reject == TRUE )
      {
        p_rs->network_reject.report_network_reject_ind = TRUE;
        if ( nas_ind_reg_req->network_reject.suppress_sys_info == TRUE )
        {
          p_rs->network_reject.suppress_sys_info_on_reject = TRUE;
        }
        else
        {
          p_rs->network_reject.suppress_sys_info_on_reject = FALSE;
        }
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_operator_name_data_valid ) // reg_operator_name_data TLV 0x22
    {
      if ( nas_ind_reg_req->reg_operator_name_data == FALSE )
      {
        p_rs->report_operator_name_data = FALSE;
      }
      else if ( nas_ind_reg_req->reg_operator_name_data == TRUE )
      {
        p_rs->report_operator_name_data = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_csp_plmn_mode_bit_valid ) // reg_csp_plmn_mode_bit TLV 0x23
    {
      if ( nas_ind_reg_req->reg_csp_plmn_mode_bit == FALSE )
      {
        p_rs->report_csp_plmn_mode_bit = FALSE;
      }
      else if ( nas_ind_reg_req->reg_csp_plmn_mode_bit == TRUE )
      {
        p_rs->report_csp_plmn_mode_bit = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_rtre_cfg_valid ) // reg_rtre_cfg TLV 0x24
    {
      if ( nas_ind_reg_req->reg_rtre_cfg == FALSE )
      {
        p_rs->report_rtre_config = FALSE;
      }
      else if ( nas_ind_reg_req->reg_rtre_cfg == TRUE )
      {
        p_rs->report_rtre_config = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_ims_pref_status_valid )
    {
      if ( nas_ind_reg_req->reg_ims_pref_status == FALSE )
      {
        p_rs->report_ims_pref_status = FALSE;
      }
      else if ( nas_ind_reg_req->reg_ims_pref_status == TRUE )
      {
        p_rs->report_ims_pref_status = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_e911_state_ready_status_valid )
    {
      if ( nas_ind_reg_req->reg_e911_state_ready_status == FALSE )
      {
        p_rs->report_e911_state_ready = FALSE;
      }
      else if ( nas_ind_reg_req->reg_e911_state_ready_status == TRUE )
      {
        p_rs->report_e911_state_ready = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }


    if ( nas_ind_reg_req->reg_lte_cphy_ca_valid )
    {
      if ( nas_ind_reg_req->reg_lte_cphy_ca == FALSE )
      {
        p_rs->report_lte_cphy_ca_status = FALSE;
      }
      else if ( nas_ind_reg_req->reg_lte_cphy_ca == TRUE )
      {
        p_rs->report_lte_cphy_ca_status = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_lte_sib16_network_time_valid )
    {
      if ( nas_ind_reg_req->reg_lte_sib16_network_time == FALSE )
      {
        p_rs->report_lte_sib16_network_time = FALSE;
      }
      else if ( nas_ind_reg_req->reg_lte_sib16_network_time == TRUE )
      {
        p_rs->report_lte_sib16_network_time = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
  }

    if ( nas_ind_reg_req->reg_ssac_info_valid )
    {
      if ( nas_ind_reg_req->reg_ssac_info == FALSE )
      {
        p_rs->report_ssac_info = FALSE;
      }
      else if ( nas_ind_reg_req->reg_ssac_info == TRUE )
      {
        p_rs->report_ssac_info = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
    if ( nas_ind_reg_req->reg_subscription_change_valid )
    {
      if ( nas_ind_reg_req->reg_subscription_change == FALSE )
      {
        p_rs->report_subscription_change = FALSE;
      }
      else if ( nas_ind_reg_req->reg_subscription_change == TRUE )
      {
        p_rs->report_subscription_change = TRUE;
      }
    }
	
    if ( nas_ind_reg_req->reg_emm_t3402_change_valid )
    {
      if ( nas_ind_reg_req->reg_emm_t3402_change == FALSE )
      {
        p_rs->report_t3402_timer_change = FALSE;
      }
      else if ( nas_ind_reg_req->reg_emm_t3402_change == TRUE )
      {
        p_rs->report_t3402_timer_change = TRUE;
      }
    }

    if ( nas_ind_reg_req->reg_acb_info_change_valid )
    {
      if ( nas_ind_reg_req->reg_acb_info_change == FALSE )
      {
        p_rs->reg_acb_info_change = FALSE;
      }
      else if ( nas_ind_reg_req->reg_acb_info_change == TRUE )
      {
        p_rs->reg_acb_info_change = TRUE;
      }
    }

    if ( nas_ind_reg_req->reg_data_subs_priority_change_valid )
    {
      if ( nas_ind_reg_req->reg_data_subs_priority_change == FALSE )
      {
        p_rs->report_data_priority_subs_change = FALSE;
      }
      else if ( nas_ind_reg_req->reg_data_subs_priority_change == TRUE )
      {
        p_rs->report_data_priority_subs_change = TRUE;
      }
    }

    if ( nas_ind_reg_req->reg_t3346_timer_status_change_valid )
    {
      if ( nas_ind_reg_req->reg_t3346_timer_status_change == FALSE )
      {
        p_rs->report_t3346_timer_status_change = FALSE;
      }
      else if ( nas_ind_reg_req->reg_t3346_timer_status_change == TRUE )
      {
        p_rs->report_t3346_timer_status_change = TRUE;
      }
    }

    if ( nas_ind_reg_req->reg_call_mode_change_valid )
    {
      if ( nas_ind_reg_req->reg_call_mode_change == FALSE )
      {
        p_rs->report_call_mode_change = FALSE;
      }
      else if ( nas_ind_reg_req->reg_call_mode_change == TRUE )
      {
        p_rs->report_call_mode_change = TRUE;
      }
    }

    if ( nas_ind_reg_req->reg_ssac_change_info_valid )
    {
      if ( nas_ind_reg_req->reg_ssac_change_info == FALSE )
      {
        p_rs->report_ssac_change_info = FALSE;
      }
      else if ( nas_ind_reg_req->reg_ssac_change_info == TRUE )
      {
        p_rs->report_ssac_change_info = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }
	
    if ( nas_ind_reg_req->reg_manual_scan_fail_valid )
    {
      if ( nas_ind_reg_req->reg_manual_scan_fail == FALSE )
      {
        p_rs->report_manual_scan_fail = FALSE;
      }
      else if ( nas_ind_reg_req->reg_manual_scan_fail == TRUE )
      {
        p_rs->report_manual_scan_fail = TRUE;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
    }

    if ( nas_ind_reg_req->reg_gcell_info_ind_valid)
    {
      if ( nas_ind_reg_req->reg_gcell_info_ind == FALSE )
      {
        p_rs->report_gcell_info_ind = FALSE;
		 QM_MSG_HIGH("Gcell Info ind is set to FALSE");
      }
      else if ( nas_ind_reg_req->reg_gcell_info_ind == TRUE )
      {
        p_rs->report_gcell_info_ind = TRUE;
		QM_MSG_HIGH("Gcell Info ind is set to TRUE");
      }
  }

  }
  if ( nas_ind_reg_resp != NULL )
  {
    memset(nas_ind_reg_resp, 0, sizeof(nas_indication_register_resp_msg_v01) );
    nas_ind_reg_resp->resp.error  = errval;
    nas_ind_reg_resp->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                  (void *)nas_ind_reg_resp,
                                  (uint32_t)sizeof(nas_indication_register_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( nas_ind_reg_req  != NULL ){ modem_mem_free((void *)nas_ind_reg_req,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( nas_ind_reg_resp != NULL ){ modem_mem_free((void *)nas_ind_reg_resp, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_indication_register() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_SIGNAL_STRENGTH()

  DESCRIPTION
    Gives the current signal strength measured by the device

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_signal_strength
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type  *response = NULL;

  qmi_error_e_type        errval = QMI_ERR_NONE;

  nas_get_signal_strength_req_msg_v01   *req_msg;
  nas_get_signal_strength_resp_msg_v01  *rsp_msg;

  enum qmi_nas_radio_if_e main_svc, sec_svc = QMI_NAS_RADIO_IF_NONE;

  sys_modem_as_id_e_type     asubs_id = SYS_MODEM_AS_ID_1;

  ASSERT(sp); ASSERT(cmd_buf_p); ASSERT(cl_sp); ASSERT(sdu_in);

  req_msg = (nas_get_signal_strength_req_msg_v01  *) modem_mem_alloc( sizeof(nas_get_signal_strength_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_signal_strength_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_signal_strength_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL || rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    goto end_get_signal_strength;
  }
  
  memset(req_msg, 0, sizeof(nas_get_signal_strength_req_msg_v01));
  memset(rsp_msg, 0, sizeof(nas_get_signal_strength_resp_msg_v01));


  // extract information from REQ message
  errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                         sdu_in,
                                         (void *) req_msg,
                                         (uint32_t) sizeof(nas_get_signal_strength_req_msg_v01)
                                       );


  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_0020_req_check( req_msg );
  }

  if (errval == QMI_ERR_NONE)
  {
#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
    }
#endif
    main_svc   = qmi_nas_sys_mode_2_radio_if(&qmi_nasi_global.cm_msim_ss_info[asubs_id],STACK_INDEX_0,FALSE);
    if( qmi_nasi_global.cm_msim_ss_info[asubs_id].number_of_stacks > 1 )
    {
      sec_svc = qmi_nas_sys_mode_2_radio_if(&qmi_nasi_global.cm_msim_ss_info[asubs_id],STACK_INDEX_1,FALSE);
    }

    if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_LTE_RSRP_MASK_V01 )
    {
      if ( main_svc == QMI_NAS_RADIO_IF_LTE && asubs_id == SYS_MODEM_AS_ID_1 )
      {
        rsp_msg->lte_rsrp_valid    = TRUE;
        rsp_msg->lte_rsrp = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrp;
      } // LTE RSRP
    }

    if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_LTE_SNR_MASK_V01 )
    {
      if ( main_svc == QMI_NAS_RADIO_IF_LTE && asubs_id == SYS_MODEM_AS_ID_1 )
      {
        rsp_msg->snr_valid    = TRUE;
        rsp_msg->snr  = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].sinr * 2 - 200;
      } // LTE SNR
    }

    if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_RSRQ_MASK_V01 )
    {
      if ( main_svc == QMI_NAS_RADIO_IF_LTE && asubs_id == SYS_MODEM_AS_ID_1 )
      {
        rsp_msg->rsrq_valid    = TRUE;
        rsp_msg->rsrq.rsrq     = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rat_mode_info.lte_mode_info.rsrq;
        rsp_msg->rsrq.radio_if = main_svc;
      } // RSRQ
    }

    if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_ERROR_RATE_MASK_V01 )
    {
      int i = 0;

        switch ( main_svc )
        {
          case QMI_NAS_RADIO_IF_NONE:
          if ( sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
            {
              rsp_msg->error_rate[i  ].error_rate = 0xFFFF; // unknown err rate
              rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001X;
            }
            else
            {
              rsp_msg->error_rate[i  ].error_rate = 0xFFFF; // unknown err rate
              rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)main_svc;
            }
            break;

          case QMI_NAS_RADIO_IF_CDMA20001X:
          rsp_msg->error_rate[i  ].error_rate = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rat_mode_info.cdma_mode_info.frame_err_rate;
            rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)main_svc;
            break;

          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          rsp_msg->error_rate[i  ].error_rate = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rat_mode_info.hdr_mode_info.hdr_packet_err_rate;
            rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)main_svc;
            break;

          case QMI_NAS_RADIO_IF_GSM:
          case QMI_NAS_RADIO_IF_UMTS:
          rsp_msg->error_rate[i  ].error_rate = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].mode_info.gw_info.bit_err_rate;
            rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)main_svc;
            break;

          case QMI_NAS_RADIO_IF_LTE:
            rsp_msg->error_rate[i  ].error_rate = 0xFFFF; // unknown err rate
            rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)main_svc;
            break;

          default:
            break;
        }

      switch ( sec_svc )
        {
          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          rsp_msg->error_rate[i  ].error_rate = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_packet_err_rate;
          rsp_msg->error_rate[i++].radio_if   = (nas_radio_if_enum_v01)sec_svc;
            break;

          default:
            break;
        }

      if ( i > 0 )
      {
        rsp_msg->error_rate_valid         = TRUE;
        rsp_msg->error_rate_len            = i;
      }
    } // ERR_RATE

    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_SINR_MASK_V01 )
      {
        if ( main_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->sinr_valid = TRUE;
          rsp_msg->sinr = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].sinr;
        }
        else if ( sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->sinr_valid = TRUE;
          rsp_msg->sinr  = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].sinr;
        }
        else
        {
          rsp_msg->sinr_valid = TRUE;
#define QMI_NAS_SINR_VALUE_NO_SIGNAL 8
          rsp_msg->sinr  = QMI_NAS_SINR_VALUE_NO_SIGNAL;
        }
      } // SINR
    }

    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_IO_MASK_V01 )
      {
        if ( main_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->io_valid = TRUE;
          rsp_msg->io    = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].io;
        }
        else if ( sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->io_valid = TRUE;
          rsp_msg->io    = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].io;
        }
        else
        {
          rsp_msg->io_valid= TRUE;
#define QMI_NAS_IO_VALUE_NO_SIGNAL       (-106)
          rsp_msg->io    = QMI_NAS_IO_VALUE_NO_SIGNAL;
        }
      } // IO
    }

    if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_ECIO_MASk_V01 )
    {
      int i = 0;

        switch ( main_svc )
        {
          case QMI_NAS_RADIO_IF_NONE:
          if ( sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
            {
              rsp_msg->ecio[i  ].ecio     = 5; // unknown ecio
              rsp_msg->ecio[i++].radio_if = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001X;
            }
            else
            {
              rsp_msg->ecio[i  ].ecio     = 5; // unknown ecio
              rsp_msg->ecio[i++].radio_if = (nas_radio_if_enum_v01)main_svc;
            }
            break;

          case QMI_NAS_RADIO_IF_CDMA20001X:
          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          rsp_msg->ecio[i  ].ecio     = (uint8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].ecio;
            rsp_msg->ecio[i++].radio_if = (nas_radio_if_enum_v01)main_svc;
            break;

          case QMI_NAS_RADIO_IF_GSM:
          case QMI_NAS_RADIO_IF_UMTS:
          case QMI_NAS_RADIO_IF_LTE:
          rsp_msg->ecio[i  ].ecio     = (uint8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].ecio;
            rsp_msg->ecio[i++].radio_if = (nas_radio_if_enum_v01)main_svc;
            break;

          default:
            break;
        }

      switch ( sec_svc )
        {
          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          rsp_msg->ecio[i  ].ecio     = (uint8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].ecio;
          rsp_msg->ecio[i++].radio_if = (nas_radio_if_enum_v01)sec_svc;
            break;

          default:
            break;
        }

      if ( i > 0 )
      {
        rsp_msg->ecio_valid     = TRUE;
        rsp_msg->ecio_len       = i;
      }
    } // ECIO

    if ( req_msg->request_mask_valid && req_msg->request_mask & QMI_NAS_REQUEST_SIG_INFO_RSSI_MASK_V01 )
    {
      int i = 0;

        switch ( main_svc )
        {
          case QMI_NAS_RADIO_IF_NONE:
          if ( sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
            {
              rsp_msg->rssi[i  ].rssi     = 128; // unknown rssi
              rsp_msg->rssi[i++].radio_if = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001X;
            }
            else
            {
              rsp_msg->rssi[i  ].rssi     = 128; // unknown rssi
              rsp_msg->rssi[i++].radio_if = (nas_radio_if_enum_v01)main_svc;
            }
            break;

          case QMI_NAS_RADIO_IF_CDMA20001X:
          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          case QMI_NAS_RADIO_IF_GSM:
          case QMI_NAS_RADIO_IF_UMTS:
          case QMI_NAS_RADIO_IF_LTE:
          rsp_msg->rssi[i  ].rssi     = (uint8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rssi;
            rsp_msg->rssi[i++].radio_if = (nas_radio_if_enum_v01)main_svc;
            break;

          default:
            break;
        }

      switch ( sec_svc )
        {
          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          rsp_msg->rssi[i  ].rssi     = (uint8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].rssi;
          rsp_msg->rssi[i++].radio_if = (nas_radio_if_enum_v01)sec_svc;
            break;

          default:
            break;
        }

      if ( i > 0 )
      {
        rsp_msg->rssi_valid     = TRUE;
        rsp_msg->rssi_len        = i;
      }
    } // RSSI

    {
      int i = 0;

      if ( asubs_id == SYS_MODEM_AS_ID_1 && sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
      {
        switch ( main_svc )
        {
          case QMI_NAS_RADIO_IF_NONE:
            rsp_msg->signal_strength_list[i  ].sig_strength = -128; // unknown sig_strength
            rsp_msg->signal_strength_list[i++].radio_if     = (nas_radio_if_enum_v01)QMI_NAS_RADIO_IF_CDMA20001X;
            break;

          case QMI_NAS_RADIO_IF_CDMA20001X:
            rsp_msg->signal_strength_list[i  ].sig_strength = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rssi > 127 ? -128 : (int8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rssi*(-1);
            rsp_msg->signal_strength_list[i++].radio_if     = (nas_radio_if_enum_v01)main_svc;
            break;

          default:
            break;
        }

        rsp_msg->signal_strength_list[i  ].sig_strength = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].rssi > 127 ? -128 : (int8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_1].rssi*(-1);
        rsp_msg->signal_strength_list[i++].radio_if     = (nas_radio_if_enum_v01)sec_svc;

        rsp_msg->signal_strength_list_valid    = TRUE;
        rsp_msg->signal_strength_list_len       = i;
      }
    } // Signal Strength list

    {
        switch ( main_svc )
        {
          case QMI_NAS_RADIO_IF_NONE:
            rsp_msg->signal_strength.radio_if = (nas_radio_if_enum_v01)( sec_svc == QMI_NAS_RADIO_IF_CDMA20001XEVDO ? QMI_NAS_RADIO_IF_CDMA20001X : QMI_NAS_RADIO_IF_NONE);
            rsp_msg->signal_strength.sig_strength = -128; // unknown sig_strength
            break;

          case QMI_NAS_RADIO_IF_CDMA20001X:
          case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
          case QMI_NAS_RADIO_IF_GSM:
          case QMI_NAS_RADIO_IF_UMTS:
          case QMI_NAS_RADIO_IF_LTE:
          rsp_msg->signal_strength.sig_strength = qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rssi > 127 ? -128 : (int8)qmi_nasi_global.cm_msim_ss_info[asubs_id].stack_info[STACK_INDEX_0].rssi*(-1);
            rsp_msg->signal_strength.radio_if     = (nas_radio_if_enum_v01)main_svc;
            break;

          default:
            break;
        }
    } // Signal Strength

  }

  if( cmd_buf_p != NULL )
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    /*-------------------------------------------------------------------------
     * Pack message
     -------------------------------------------------------------------------*/
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_signal_strength_resp_msg_v01),
                                  &response
                                );
  }
end_get_signal_strength:
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_signal_strength() */


/*===========================================================================
  FUNCTION FILTER_NETWORKS_TO_SCAN()

  DESCRIPTION
    Given QMI_NAS_PERFORM_NETWORK_SCAN_REQ 0x2100 t10 network_type,
    filter mask based on networks supported by target,
    masking off bits of unsupported networks.

  PARAMETERS
    network_type - Bitmask representing the network types to scan. Values:
      Bit 0 -- GSM  (lsb)
      Bit 1 -- UMTS
      Bit 2 -- LTE
      Bit 3 -- TD-SCDMA (>= MPSS.NI.3.2)
      (from network_access_service_wireformat_v01.html#QMI_NAS_PERFORM_NETWORK_SCAN_REQ Field Type 0x10)

  RETURN VALUE
    modified network scan mask (see parameter above)

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint8 filter_networks_to_scan( uint8 network_type )
{
  // mask off network scan bits that the target does not support

  if ( ! TARGET_SUPPORTS_GSM   ) { network_type &= ~ NAS_NETWORK_TYPE_GSM_ONLY_V01;   }

  if ( ! TARGET_SUPPORTS_WCDMA ) { network_type &= ~ NAS_NETWORK_TYPE_WCDMA_ONLY_V01; }

  if ( ! TARGET_SUPPORTS_LTE   ) { network_type &= ~ NAS_NETWORK_TYPE_LTE_ONLY_V01;   }

  // NOTE:  NI-3.2 and beyond supports TD-SCDMA, so we test and mask it, like the RATS above.

  if ( ! TARGET_SUPPORTS_TDS   ) { network_type &= ~ NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01;   }

  // NOTE:  For pre-NI-3.2, TD-SCDMA is not supported, so we need to mask off the bit for TDS network scan also

  network_type &= ( NAS_NETWORK_TYPE_GSM_ONLY_V01 | NAS_NETWORK_TYPE_WCDMA_ONLY_V01 | NAS_NETWORK_TYPE_LTE_ONLY_V01 | NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01 );

  QM_MSG_HIGH_2("mode_capability = %d, filter network type %d",
                qmi_nasi_global.cm_ph_info.mode_capability, network_type);
  return network_type;
}

/*===========================================================================
  FUNCTION QMI_NASI_PERFORM_NETWORK_SCAN()

  DESCRIPTION
    Returns a list of network providers that have been scanned.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_perform_network_scan
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type             * response = NULL;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
  boolean                     retval   = TRUE;
  nas_perform_network_scan_req_msg_v01  * req_msg;
  nas_perform_network_scan_resp_msg_v01 * rsp_msg;
  int                         i;
  cm_mode_pref_e_type         mode_pref = CM_MODE_PREF_GWL;
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
  cm_network_list_type_e_type list_type = CM_NETWORK_LIST_AVAILABLE;
  cm_band_pref_e_type         band_pref     = CM_BAND_PREF_ANY,
                              lte_band_pref = CM_BAND_PREF_LTE_ANY,
                              tds_band_pref = CM_BAND_PREF_TDS_ANY;

  uint8                       filtered_network_type;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  QM_MSG_HIGH( "PCI_DEBUG qmi_nasi_perform_network_scan ");

  req_msg = (nas_perform_network_scan_req_msg_v01  *) modem_mem_alloc( sizeof(nas_perform_network_scan_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_perform_network_scan_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_perform_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#endif
#ifdef FEATURE_TRIPLE_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
  {
    asubs_id = SYS_MODEM_AS_ID_3;
  }
#endif
  if ( ! TARGET_SUPPORTS_GSM && ! TARGET_SUPPORTS_WCDMA && ! TARGET_SUPPORTS_LTE && ! TARGET_SUPPORTS_TDS )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
  {
    memset( req_msg, 0x00, sizeof(nas_perform_network_scan_req_msg_v01) );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_perform_network_scan_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0021_req_check( req_msg );
  }

  if( (errval == QMI_ERR_NONE_V01) && req_msg->scan_type_valid )
  {
    if( req_msg->scan_type == NAS_SCAN_TYPE_CSG_V01 )
    {
#ifdef FEATURE_FEMTO_CSG
      if ( qm_efs_csg_supported() )
      {
      list_type = CM_NETWORK_LIST_CSG;
      }
      else
#endif
  {
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
      }
    }

    else if(req_msg->scan_type == NAS_SCAN_TYPE_MODE_PREF_V01)
    {
      list_type = CM_NETWORK_LIST_WITH_MAX_CAP;
    }

    if( req_msg->scan_type == NAS_SCAN_TYPE_PCI_V01 )
    {
      list_type = CM_NETWORK_LIST_PCI_SCAN;
    }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( qmi_nasi_global.net_scan_started )
    {
      if ( asubs_id == qmi_nasi_global.net_scan_asubs_id )
      {
        if( req_msg->scan_type_valid &&  (list_type != qmi_nasi_global.net_scan_type )) 
        { /* previous scan and current scan type is not same */
          errval = QMI_ERR_INVALID_OPERATION_V01;
          QM_MSG_HIGH_2("Net Scan already started with different scan type(prev :%d, curr :%d)", qmi_nasi_global.net_scan_type, req_msg->scan_type);
        } 
        else if( !req_msg->scan_type_valid &&  (qmi_nasi_global.net_scan_type != CM_NETWORK_LIST_AVAILABLE)) 
        { /* previous scan is CSG & scan type is not provided in the curr scan */
          errval = QMI_ERR_INVALID_OPERATION_V01;
          QM_MSG_HIGH_1("Net Scan already started with different scan type(prev :%d)", qmi_nasi_global.net_scan_type);
        }
        else if(qmi_nasi_global.incremental_net_scan_status != QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE)
        {
          QM_MSG_HIGH( "Incremental Net Scan already started earlier,waiting for response");
          errval = QMI_ERR_INVALID_OPERATION_V01;
        }
        else
        {
        qm_cbpq_add ( QM_CBPQ_QTYPE_NW_SCAN, cmd_buf_p, ((qmi_nasi_client_state_type *)cl_sp)->common.clid );
        //Net Scan already started earlier,waiting for response
      }
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_HIGH_2("net scan ongoing on other subscription:%d %d", qmi_nasi_global.net_scan_asubs_id, asubs_id);
      }
    }
    else
    {
      if( req_msg->network_type_valid )
      {
        if ( req_msg->network_type == 0 )
        {
          mode_pref = CM_MODE_PREF_NO_CHANGE;
        }
        else
        {
          filtered_network_type = filter_networks_to_scan( req_msg->network_type );
          retval = FALSE; // assume no match, until proven otherwise by the loop below...

          for( i = 0 ; i < QMI_NAS_ARR_SIZE(qmi_nas_allowed_network_types) ; i++ )
          {
            if ( filtered_network_type == qmi_nas_allowed_network_types[i].network_type )
            {
              mode_pref = qmi_nas_allowed_network_types[i].cm_val;
              retval = TRUE; // a match has been found, proceed as before.
              break;
            }
          }

          if ( ! retval ) { errval = QMI_ERR_INTERNAL_V01; }

          QM_MSG_HIGH_3("qmi_nasi_perform_network_scan() network_type = %d, filtered = %d, change = %d.", req_msg->network_type, filtered_network_type, req_msg->network_type ^ filtered_network_type);
      }
      }

      QM_MSG_HIGH_3("network_type_valid = %d mode_pref = %d retval = %d (T/F)", req_msg->network_type_valid, mode_pref, retval);

      if ( req_msg->band_pref_valid )
      {
        band_pref = (cm_band_pref_e_type) req_msg->band_pref;
      }

      if ( req_msg->lte_band_pref_valid )
      {
        lte_band_pref = (cm_band_pref_e_type) req_msg->lte_band_pref;
      }

      if ( req_msg->tdscdma_band_pref_valid )
      {
        tds_band_pref = (cm_band_pref_e_type) req_msg->tdscdma_band_pref;
      }

      if ( errval == QMI_ERR_NONE_V01 )
      {
        if ( asubs_id == SYS_MODEM_AS_ID_1 )
        {
        retval = cm_ph_cmd_get_networks_extn(qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, list_type, mode_pref, band_pref, lte_band_pref, tds_band_pref);
        }
#ifdef FEATURE_DUAL_SIM
        else if ( asubs_id == SYS_MODEM_AS_ID_2
#ifdef FEATURE_TRIPLE_SIM
                  || ( asubs_id == SYS_MODEM_AS_ID_3 )
#endif
                )
        {
        retval = cm_ph_cmd_get_networks_per_subs_extn(qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, list_type, mode_pref, asubs_id, band_pref, lte_band_pref, tds_band_pref );
        }
#endif
      }

      if ( retval )
      {
        qm_cbpq_add ( QM_CBPQ_QTYPE_NW_SCAN, cmd_buf_p, ( (qmi_nasi_client_state_type *) cl_sp)->common.clid );

        QM_MSG_HIGH("Starting Net Scan, waiting for response");
        qmi_nasi_global.net_scan_started  = TRUE;
        qmi_nasi_global.net_scan_asubs_id = asubs_id;
        qmi_nasi_global.net_scan_type = list_type;
        qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE;
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = (dsm_item_type*) QMI_SVC_RESPONSE_PENDING;
    // shall react to CM_PH_CMD_GET_NETWORKS and CM_PH_EVENT_AVAILABLE_NETWORKS_CONF later
  }
  else if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_perform_network_scan_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_perform_network_scan_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_perform_network_scan() */
#if 0

#ifdef FEATURE_DUAL_SIM
/*===========================================================================
  FUNCTION qmi_nas_get_session_type_from_subs()

  DESCRIPTION
    Retrieve session_type information that is mapped to provided subscription type

  PARAMETERS
    subscription type

  RETURN VALUE
    session_type information that is mapped to provided subscription information.
    MMGSDI_MAX_SESSION_TYPE_ENUM-1 if there is no session_type mapped to subscription type
===========================================================================*/
mmgsdi_session_type_enum_type qmi_nas_get_session_type_from_subs( enum qmi_nas_subs_e subs_type )
{
  sys_modem_as_id_e_type        i;

  for ( i=SYS_MODEM_AS_ID_1; i<=SYS_MODEM_AS_ID_3; i++ )
  {
    if ( qmi_nasi_global.subs_info[i].is_operational )
    {
      if ( subs_type == QMI_NAS_SUBS_PRIMARY )
      {
        if ( qmi_nasi_global.subs_info[i].session_type == MMGSDI_GW_PROV_PRI_SESSION ||
             qmi_nasi_global.subs_info[i].session_type == MMGSDI_1X_PROV_PRI_SESSION ||
             qmi_nasi_global.subs_info[i].session_type == MMGSDI_MAX_SESSION_TYPE_ENUM /* subscription from nv. for cdma */)
        {
          return qmi_nasi_global.subs_info[i].session_type;
        }
      }
#ifdef FEATURE_DUAL_SIM
      else if ( subs_type == QMI_NAS_SUBS_SECONDARY )
      {
        if ( qmi_nasi_global.subs_info[i].session_type == MMGSDI_GW_PROV_SEC_SESSION ||
             qmi_nasi_global.subs_info[i].session_type == MMGSDI_1X_PROV_SEC_SESSION )
        {
          return qmi_nasi_global.subs_info[i].session_type;
        }
      }
#endif
#ifdef FEATURE_TRIPLE_SIM
      else if ( subs_type == QMI_NAS_SUBS_TERTIARY )
      {
        if ( qmi_nasi_global.subs_info[i].session_type == MMGSDI_GW_PROV_TER_SESSION ||
             qmi_nasi_global.subs_info[i].session_type == MMGSDI_1X_PROV_TER_SESSION )
        {
          return qmi_nasi_global.subs_info[i].session_type;
        }
      }
#endif

    }
  }

  return (mmgsdi_session_type_enum_type)(MMGSDI_MAX_SESSION_TYPE_ENUM-1); // MMGSDI_MAX_SESSION_TYPE_ENUM used for cdma nv subscription
}
#endif

#endif

/*===========================================================================
  FUNCTION QMI_NASI_INITIATE_NETWORK_REGISTER()

  DESCRIPTION
    Returns the current serving system registration state and radio
    technology information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_initiate_network_register (
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;
  struct nas_0022_req_s      req_msg;

  cm_network_sel_mode_pref_e_type  net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_NO_CHANGE;
  cm_mode_pref_e_type              cm_mode_pref = CM_MODE_PREF_NONE;
  cm_pref_term_e_type              cm_term_pref = CM_PREF_TERM_PWR_CYCLE;
  sys_plmn_id_s_type               plmn, *plmn_ptr = NULL;
  boolean                          register_req = FALSE;
  qmi_error_e_type                 errval = QMI_ERR_NONE;

  sys_modem_as_id_e_type           asubs_id = SYS_MODEM_AS_ID_1;
  mmgsdi_session_type_enum_type    session;
  boolean                          mnc_includes_pcs_digit;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
   QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#endif

  if ( errval == QMI_ERR_NONE )
  {
    session = asubs_id == SYS_MODEM_AS_ID_1 ? MMGSDI_GW_PROV_PRI_SESSION : MMGSDI_GW_PROV_SEC_SESSION;

    if ( qmi_nasi_global.mmgsdi.operation_ready[session] == FALSE )
    {
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    memset( &req_msg, 0x00, sizeof(struct nas_0022_req_s) );

    errval = qmi_nas_0022_req_read( &req_msg, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_0022_req_check( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( req_msg.t11.change_duration == QMI_NAS_CHANGE_DURATION_POWER_CYCLE )
    {
      cm_term_pref = CM_PREF_TERM_PWR_CYCLE;
    }
    else if ( req_msg.t11.change_duration == QMI_NAS_CHANGE_DURATION_PERMANENT )
    {
      cm_term_pref = CM_PREF_TERM_PERMANENT;
    }

    switch ( req_msg.t01.register_action )
    {
      case QMI_NAS_REGISTER_ACTION_AUTOMATIC:
          register_req = TRUE;
          net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
          cm_mode_pref = CM_MODE_PREF_DIGITAL_ONLY;
        break;

      case QMI_NAS_REGISTER_ACTION_MANUAL:
        // Process MNC 3rd digit include status
        if ( req_msg.t12_valid )
        {
          mnc_includes_pcs_digit = req_msg.t12.mnc_includes_pcs_digit;

          if ( req_msg.t10.mobile_network_code>99 && mnc_includes_pcs_digit == FALSE)
          {
            errval = QMI_ERR_INVALID_ARG;
          }
        }
        else
        {
          mnc_includes_pcs_digit = req_msg.t10.mobile_network_code>99 ? TRUE : FALSE;
        }

        if( errval == QMI_ERR_NONE )
        {
          if ( !sys_plmn_set_mcc_mnc( mnc_includes_pcs_digit, req_msg.t10.mobile_country_code, req_msg.t10.mobile_network_code, &plmn) )
          {
            errval = QMI_ERR_INVALID_ARG;
          }
          else
          {
            register_req = TRUE;
            net_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL;
            plmn_ptr = &plmn;

            switch ( req_msg.t10.radio_access_technology )
            {
              case QMI_NAS_RADIO_IF_GSM:
                if (TARGET_SUPPORTS_GSM) {
                  cm_mode_pref = CM_MODE_PREF_GSM_ONLY;
                }
                break;

              case QMI_NAS_RADIO_IF_UMTS:
                if (TARGET_SUPPORTS_WCDMA) {
                  cm_mode_pref = CM_MODE_PREF_WCDMA_ONLY;
                }
                break;

              case QMI_NAS_RADIO_IF_LTE:
                if (TARGET_SUPPORTS_LTE) {
                  cm_mode_pref = CM_MODE_PREF_LTE_ONLY;
                }
                break;

              case QMI_NAS_RADIO_IF_NO_CHANGE:
                cm_mode_pref = CM_MODE_PREF_NO_CHANGE;
                break;

              default:
                break;
            }

            if ( cm_mode_pref == CM_MODE_PREF_NONE )
            {
              errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
            }
          }
        }
        break;

      default:
        errval = QMI_ERR_INVALID_REGISTER_ACTION;
        break;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( register_req == TRUE )
    {
      boolean ret_val = FALSE;

      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        ret_val = cm_ph_cmd_sys_sel_pref_with_lte( qmi_nas_cmph_cmd_cb,
                                                   cmd_buf_p,
                                                   qmi_nasi_global.cm_clnt_id,
                                                   cm_mode_pref,
                                                   cm_term_pref,
                                                   0,
                                                   CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                   CM_BAND_PREF_NO_CHANGE,
                                                   CM_BAND_PREF_NO_CHANGE,
                                                   CM_PRL_PREF_NO_CHANGE,
                                                   CM_ROAM_PREF_NO_CHANGE,
                                                   CM_HYBR_PREF_NO_CHANGE,
                                                   CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                   net_sel_mode_pref,
                                                   plmn_ptr,
                                                   NULL );
      }
#ifdef FEATURE_DUAL_SIM
      else if ( asubs_id == SYS_MODEM_AS_ID_2 )
      {
        ret_val = cm_ph_cmd_sys_sel_pref_per_subs( qmi_nas_cmph_cmd_cb,
                                                   cmd_buf_p,
                                                   qmi_nasi_global.cm_clnt_id,
                                                   asubs_id,
                                                   cm_mode_pref,
                                                   cm_term_pref,
                                                   0,
                                                   CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                   CM_BAND_PREF_NO_CHANGE,
                                                   CM_PRL_PREF_NO_CHANGE,
                                                   CM_ROAM_PREF_NO_CHANGE,
                                                   CM_HYBR_PREF_NO_CHANGE,
                                                   CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                   net_sel_mode_pref,
                                                   plmn_ptr );
      }
#endif

      if ( ret_val )
      {
        QM_MSG_HIGH("Response pending for CM event");
        return QMI_SVC_RESPONSE_PENDING;
      }
      else
      {
        QM_MSG_ERROR("Unable to change sys sel pref for Net Register");
        errval = QMI_ERR_NO_EFFECT;
      }
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    struct nas_0022_rsp_s rsp_msg;

    memset( &rsp_msg, 0x00, sizeof(struct nas_0022_rsp_s) );

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_0022_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
} /* qmi_nasi_initiate_network_register() */

/*===========================================================================
  FUNCTION QMI_NASI_INITIATE_ATTACH()

  DESCRIPTION
    Returns the current serving system registration state and radio
    technology information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_initiate_attach
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response = NULL;
  qmi_error_e_type           errval    = QMI_ERR_NONE;
  cm_srv_domain_pref_e_type  srv_domain_pref = CM_SRV_DOMAIN_PREF_NO_CHANGE;
  cm_srv_domain_pref_e_type  curr_srv_domain_pref = CM_SRV_DOMAIN_PREF_NO_CHANGE;
  struct nas_0023_req_s      req_msg;

  sys_modem_as_id_e_type     asubs_id = SYS_MODEM_AS_ID_1;
  mmgsdi_session_type_enum_type    session;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_3("null ptr %d %d %d", sp, cmd_buf_p, cl_sp);
	QM_MSG_ERROR_1("null ptr %d", sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  if ( !TARGET_SUPPORTS_GSM && !TARGET_SUPPORTS_WCDMA && !TARGET_SUPPORTS_LTE )
  {
    errval = QMI_ERR_OP_NETWORK_UNSUPPORTED;
  }

  if (errval == QMI_ERR_NONE)
  {
    memset(&req_msg, 0, sizeof(req_msg));

    errval = qmi_nas_0023_req_read(&req_msg, sdu_in);
  }

  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_0023_req_check(&req_msg);
  }

  if ( errval == QMI_ERR_NONE )
  {
  
#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
      curr_srv_domain_pref = qmi_nasi_global.cm_ph_info2.srv_domain_pref;
    }
    else
#endif
    {
      curr_srv_domain_pref = qmi_nasi_global.cm_ph_info.srv_domain_pref;
    }
    QM_MSG_HIGH_1("curr_srv_domain_pref:%d", curr_srv_domain_pref);
  }

  if ( errval == QMI_ERR_NONE )
  {
    session = asubs_id == SYS_MODEM_AS_ID_1 ? MMGSDI_GW_PROV_PRI_SESSION : MMGSDI_GW_PROV_SEC_SESSION;

    if ( qmi_nasi_global.mmgsdi.operation_ready[session] == FALSE )
    {
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
      QM_MSG_HIGH("QMI_ERR_SIM_NOT_INITIALIZED");
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    if(req_msg.t10_valid)
    {
      QM_MSG_HIGH_1("ps_attach_action:%d", req_msg.t10.ps_attach_action);
      switch(req_msg.t10.ps_attach_action)
      {
        case NASI_PS_ATTACHED:
          if ( curr_srv_domain_pref == CM_SRV_DOMAIN_PREF_CS_PS ||
               curr_srv_domain_pref == CM_SRV_DOMAIN_PREF_PS_ONLY )
          {
            errval = QMI_ERR_NO_EFFECT;
          }
          else
          {
            srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_ATTACH;
          }
          break;

        case NASI_PS_DETACHED:
          if ( curr_srv_domain_pref != CM_SRV_DOMAIN_PREF_PS_ONLY &&
               curr_srv_domain_pref != CM_SRV_DOMAIN_PREF_CS_PS )
          {
            errval = QMI_ERR_NO_EFFECT;
          }
          else
          {
            srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_DETACH;
          }
          break;

        default:
          //should never occur
          errval = QMI_ERR_INVALID_PS_ATTACH_ACTION;
      }
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    if (req_msg.t10_valid == TRUE)
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if (!cm_ph_cmd_sys_sel_pref_with_lte( qmi_nas_cmph_cmd_cb,
                                              cmd_buf_p,
                                              qmi_nasi_global.cm_clnt_id,
                                              CM_MODE_PREF_NO_CHANGE,
                                              CM_PREF_TERM_PWR_CYCLE,
                                              0,
                                              CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                              CM_BAND_PREF_NO_CHANGE,
                                              CM_BAND_PREF_NO_CHANGE,
                                              CM_PRL_PREF_NO_CHANGE,
                                              CM_ROAM_PREF_NO_CHANGE,
                                              CM_HYBR_PREF_NO_CHANGE,
                                              srv_domain_pref,
                                              CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                              NULL,
                                              NULL))
        {
          QM_MSG_ERROR("Unable to change sys sel pref for PS attach");
          errval = QMI_ERR_NO_EFFECT;
        }
      }
#ifdef FEATURE_DUAL_SIM
      else if ( asubs_id == SYS_MODEM_AS_ID_2 )
      {
        if (!cm_ph_cmd_sys_sel_pref_per_subs( qmi_nas_cmph_cmd_cb,
                                              cmd_buf_p,
                                              qmi_nasi_global.cm_clnt_id,
                                              asubs_id,
                                              CM_MODE_PREF_NO_CHANGE,
                                              CM_PREF_TERM_PWR_CYCLE,
                                              0,
                                              CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                              CM_BAND_PREF_NO_CHANGE,
                                              CM_PRL_PREF_NO_CHANGE,
                                              CM_ROAM_PREF_NO_CHANGE,
                                              CM_HYBR_PREF_NO_CHANGE,
                                              srv_domain_pref,
                                              CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                              NULL))
        {
          QM_MSG_ERROR("Unable to change sys sel pref for PS attach");
          errval = QMI_ERR_NO_EFFECT;
        }
      }
#endif
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    QM_MSG_HIGH("Response pending for NAS Attach");
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    if ( qmi_svc_put_result_tlv(&response, QMI_RESULT_FAILURE, errval) == FALSE )
    {
      dsm_free_packet(&response);
      response = NULL;
    }
  }

  return response;
} /* qmi_nasi_initiate_attach() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_SERVING_SYSTEM()

  DESCRIPTION
    Returns the current serving system registration state and radio
    technology information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_serving_system
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;

  qmi_error_type_v01                    errval           = QMI_ERR_NONE_V01;

  nas_get_serving_system_resp_msg_v01 * rsp_msg;

  sys_modem_as_id_e_type    asubs_id = SYS_MODEM_AS_ID_1;
  
  cm_mm_msim_ss_info_s_type *p_ss_info = &qmi_nasi_global.cm_msim_ss_info[asubs_id];
  qmi_cm_ph_info_s_type        *p_ph_info = &qmi_nasi_global.cm_ph_info;

  enum qm_stack_index_e stack          = STACK_INDEX_0;
  sys_sys_id_s_type         sys_id         = p_ss_info->stack_info[stack].sys_id;
  sys_mm_information_s_type mm_information = p_ss_info->stack_info[stack].mode_info.gw_info.mm_information;
  sys_lac_type              lac            = qmi_nas_get_lac( p_ss_info, stack );
  sys_lac_type              lac_tac        = p_ss_info->stack_info[stack].sys_mode == SYS_SYS_MODE_LTE ? p_ss_info->stack_info[stack].rat_mode_info.lte_mode_info.tac : qmi_nas_get_lac( p_ss_info, stack );
  sys_cell_id_type          cell_id        = p_ss_info->stack_info[stack].cell_info.cell_id;
  uint16                    psc            = p_ss_info->stack_info[stack].cell_info.psc;
  sys_dtm_support_e_type    dtm_supp       = p_ss_info->stack_info[stack].cell_srv_ind.dtm_supp;
  sys_srv_status_e_type     srv_status     = p_ss_info->stack_info[stack].srv_status;
  sys_srv_domain_e_type     srv_capability = p_ss_info->stack_info[stack].srv_capability;
  boolean                   is_sys_forbidden = p_ss_info->stack_info[stack].is_sys_forbidden;
  mmgsdi_session_type_enum_type session    = MMGSDI_GW_PROV_PRI_SESSION;
  sys_domain_access_bar_s_type  cell_access_info = p_ss_info->stack_info[stack].cell_access_info;

#ifdef FEATURE_DUAL_SIM
  asubs_id = (cl_sp)? (((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY)?
                        SYS_MODEM_AS_ID_2 : SYS_MODEM_AS_ID_1
                        : SYS_MODEM_AS_ID_1;
#endif  

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  rsp_msg = (nas_get_serving_system_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_serving_system_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
     qmi_voice_mem_error();
      errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
  {
    memset(rsp_msg, 0x00, sizeof(nas_get_serving_system_resp_msg_v01));
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( !qmi_nasi_global.rcvd_ss_info )
    {
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    }
  }

#ifdef FEATURE_DUAL_SIM
  if (errval == QMI_ERR_NONE_V01)
  {
    if ( asubs_id == SYS_MODEM_AS_ID_2 )
    {
      p_ph_info      = &qmi_nasi_global.cm_ph_info2;
      session        = MMGSDI_GW_PROV_SEC_SESSION;
    }
  }
#endif

  if ( errval == QMI_ERR_NONE_V01 )
  {
    {
      rsp_msg->serving_system.registration_state = qmi_nas_get_reg_state( p_ss_info, p_ph_info );
      rsp_msg->serving_system.cs_attach_state    = (uint8) qmi_nas_get_cs_attach_state( p_ss_info );
      rsp_msg->serving_system.ps_attach_state    = (uint8) qmi_nas_get_ps_attach_state( p_ss_info );
      rsp_msg->serving_system.selected_network   = (uint8) qmi_nas_get_reg_network( p_ss_info );
      rsp_msg->serving_system.radio_if_len       = (uint8) qmi_nas_get_in_use_radio_if( p_ss_info, &rsp_msg->serving_system.radio_if[0] );
    } // TLV 01 (serving system)

    if ( p_ss_info->stack_info[stack].srv_status != SYS_SRV_STATUS_NO_SRV && p_ss_info->stack_info[stack].srv_status != SYS_SRV_STATUS_PWR_SAVE )
    {
      rsp_msg->roaming_indicator       = qmi_nas_get_roaming_indicator( p_ss_info );
      if ( (uint8)rsp_msg->roaming_indicator != (uint8)SYS_ROAM_STATUS_UNKNOWN )
      {
        rsp_msg->roaming_indicator_valid = TRUE;
      }
    } // TLV 10 (roaming indicator)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      rsp_msg->data_capabilities_len   = (uint8) qmi_nas_get_data_capability( p_ss_info, &rsp_msg->data_capabilities[0] );
      rsp_msg->data_capabilities_valid = TRUE;
    }
    else
    {
      rsp_msg->data_capabilities_len   = 0;
      rsp_msg->data_capabilities_valid = TRUE;
    }// TLV 11 (Data Service Capability)

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
    if ( srv_status ==  SYS_SRV_STATUS_SRV     ||
         srv_status ==  SYS_SRV_STATUS_LIMITED ||
         srv_status ==  SYS_SRV_STATUS_LIMITED_REGIONAL )
    {
      sys_plmn_id_s_type plmn;
      sys_mcc_type       mcc;
      sys_mnc_type       mnc;
      boolean            plmn_undefined, plmn_includes_pcs_digit_ptr;
      mmgsdi_eons_evt_info_type *eons;

      if ( sys_id.id_type == SYS_SYS_ID_TYPE_UMTS )
      {
        plmn = sys_id.id.plmn;

        sys_plmn_get_mcc_mnc( plmn, &plmn_undefined, &plmn_includes_pcs_digit_ptr, &mcc, &mnc );

        (void) hput16( (byte *) &rsp_msg->current_plmn.mobile_country_code, (uint16) mcc);
        (void) hput16( (byte *) &rsp_msg->current_plmn.mobile_network_code, (uint16) mnc);
        (void) hput16( (byte *) &rsp_msg->mnc_includes_pcs_digit.mcc,       (uint16) mcc);       // T27
        (void) hput16( (byte *) &rsp_msg->mnc_includes_pcs_digit.mnc,       (uint16) mnc);       // T27
        rsp_msg->mnc_includes_pcs_digit.mnc_includes_pcs_digit = plmn_includes_pcs_digit_ptr;    // T27

        if ( !plmn_undefined )
        {
          if( (eons = qmi_nas_nw_name_find( session, plmn, lac_tac, qmi_nas_rat_cm_mode_to_mmgsdi(p_ss_info->stack_info[stack].sys_mode), qm_util_retrieve_csg_id(p_ss_info, STACK_INDEX_0) )) != NULL )
            {
            memscpy( rsp_msg->current_plmn.network_description,
                     eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len,
                     eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_ptr,
                     eons->first_stack_info.operator_info.plmn_short_name.plmn_name.eons_data.data_len );
          }
          rsp_msg->current_plmn_valid           = TRUE;
          rsp_msg->mnc_includes_pcs_digit_valid = TRUE;    // T27
        }
      }
    } // TLV 12 (Current PLMN)
#endif

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
        {
          rsp_msg->cdma_system_id.sid   = p_ss_info->stack_info[stack].sys_id.id.is95.sid;
          rsp_msg->cdma_system_id.nid   = p_ss_info->stack_info[stack].sys_id.id.is95.nid;
          rsp_msg->cdma_system_id_valid = TRUE;
        }
      }
    } // TLV 13 (CDMA System ID)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
        {
          rsp_msg->cdma_base_station_info.base_id   = p_ss_info->stack_info[stack].mode_info.cdma_info.base_id;
          rsp_msg->cdma_base_station_info.base_lat  = p_ss_info->stack_info[stack].mode_info.cdma_info.base_lat;
          rsp_msg->cdma_base_station_info.base_long = p_ss_info->stack_info[stack].mode_info.cdma_info.base_long;
          rsp_msg->cdma_base_station_info_valid     = TRUE;
        }
      }
    } // TLV 14 (CDMA Base Station Information)

    rsp_msg->roaming_indicator_list_len = qmi_nas_get_roaming_ind_list( p_ss_info, &rsp_msg->roaming_indicator_list[0] );

    if ( rsp_msg->roaming_indicator_list_len > 0 )
    {
      rsp_msg->roaming_indicator_list_valid = TRUE;
    } // TLV 15 (Roaming Indicator List)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
             qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO ||
             qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->def_roam_ind       = qmi_nas_get_def_roam_ind( p_ss_info );
          rsp_msg->def_roam_ind_valid = TRUE;
        }
      }
    } // TLV 16 (Default Roaming Indicator)


    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
             qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO ||
             qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          if ( qmi_nasi_include_3GPP2_time_zone( &rsp_msg->nas_3gpp_time_zone.lp_sec, &rsp_msg->nas_3gpp_time_zone.ltm_offset, &rsp_msg->nas_3gpp_time_zone.daylt_savings, p_ss_info ) )
          {
            rsp_msg->nas_3gpp_time_zone_valid = TRUE;
          }
        }
      }
    } // TLV 17 (3GPP2 Time Zone)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
        {
          rsp_msg->p_rev_in_use       = p_ss_info->stack_info[stack].mode_info.cdma_info.p_rev_in_use;
          rsp_msg->p_rev_in_use_valid = TRUE;
        }
      }
    } // TLV 18 (CDMA P_Rev In Use)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_LTE )
      {
        if ( mm_information.time_zone_avail )
        {
          rsp_msg->time_zone       = (int8) mm_information.time_zone;
          rsp_msg->time_zone_valid = TRUE;
        }
      }
    } // TLV 1A (3GPP Time Zone)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_LTE )
      {
        if ( mm_information.daylight_saving_adj_avail )
        {
          rsp_msg->adj       = mm_information.daylight_saving_adj;
          rsp_msg->adj_valid = TRUE;
        }
      }
    } // TLV 1B (3GPP Network Daylight Saving Adjustment)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_LTE )
      {
        if( lac != QMI_NAS_INVALID_LAC )
        {
          rsp_msg->lac       = lac;
          rsp_msg->lac_valid = TRUE;
        }
      }
    } // TLV 1C (Location Area Code)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_UMTS ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_LTE )
      {
        rsp_msg->cell_id       = cell_id;
        rsp_msg->cell_id_valid = TRUE;
      }
    } // TLV 1D (3GPP Cell ID)

#if defined (FEATURE_IS2000_REL_A_SVD)
    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
             qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO ||
             qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->ccs       = p_ss_info->stack_info[stack].mode_info.cdma_info.ccs_supported;
          rsp_msg->ccs_valid = TRUE;
        }
      }
    } // TLV 1E (Concurrent Service Info)
#endif

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X ||
             qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO ||
             qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->prl_ind       = p_ss_info->stack_info[stack].is_sys_prl_match;
          rsp_msg->prl_ind_valid = TRUE;
        }
      }
    } // TLV 1F (PRL indicator)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM )
      {
        rsp_msg->dtm_ind = dtm_supp;
        rsp_msg->dtm_ind_valid   = TRUE;
      }
    } // TLV 20 (Dual Transfer Mode (DTM) Indication (GSM Only))

    {
      rsp_msg->detailed_service_info.srv_status       = srv_status;
      rsp_msg->detailed_service_info.srv_capability   = srv_capability;
      if( p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_HDR )
      {
        rsp_msg->detailed_service_info.hdr_srv_status   = p_ss_info->stack_info[STACK_INDEX_1].srv_status;
        rsp_msg->detailed_service_info.hdr_hybrid       = p_ss_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_hybrid;
      }
      rsp_msg->detailed_service_info.is_sys_forbidden = is_sys_forbidden;

      rsp_msg->detailed_service_info_valid = TRUE;
    } // TLV 21 (Detailed Service Information)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001X )
        {
          rsp_msg->cdma_system_id_ext.mcc        = p_ss_info->stack_info[stack].sys_id.id.is95.mcc;
          rsp_msg->cdma_system_id_ext.imsi_11_12 = p_ss_info->stack_info[stack].sys_id.id.is95.imsi_11_12;
          rsp_msg->cdma_system_id_ext_valid      = TRUE;
        }
      }
    } // TLV 22 (CDMA System Info - ext)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( asubs_id == SYS_MODEM_AS_ID_1 )
      {
        if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_0,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->hdr_personality       = (uint8) qmi_nas_cm_2_qmi_hdr_personality( p_ss_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_personality );
          rsp_msg->hdr_personality_valid = TRUE;
        }
        else if( qmi_nas_sys_mode_2_radio_if(p_ss_info,STACK_INDEX_1,TRUE) == QMI_NAS_RADIO_IF_CDMA20001XEVDO )
        {
          rsp_msg->hdr_personality       = (uint8) qmi_nas_cm_2_qmi_hdr_personality( p_ss_info->stack_info[STACK_INDEX_1].rat_mode_info.hdr_mode_info.hdr_personality );
          rsp_msg->hdr_personality_valid = TRUE;
        }
      }
    } // TLV 23 (HDR Personality)

    if ( rsp_msg->serving_system.registration_state == NAS_REGISTERED_V01 )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_LTE )
      {
        rsp_msg->tac       = p_ss_info->stack_info[stack].rat_mode_info.lte_mode_info.tac;
        rsp_msg->tac_valid = TRUE;
      }
    } // TLV 24 (Tracking Area Code (TAC) Information for LTE)

    if ( srv_status != SYS_SRV_STATUS_PWR_SAVE &&
         srv_status != SYS_SRV_STATUS_NO_SRV )
    {
      if ( qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_GSM ||
           qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,TRUE) == QMI_NAS_RADIO_IF_UMTS )
      {
        if( (cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY) &&
            (cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS) )
        {
          rsp_msg->call_barring_status.cs_bar_status = (uint32) cell_access_info.cs_bar_status;
        }
        else
        {
          rsp_msg->call_barring_status.cs_bar_status = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
        if( (cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY) &&
            (cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS) )
        {
          rsp_msg->call_barring_status.ps_bar_status = (uint32) cell_access_info.ps_bar_status;
        }
        else
        {
          rsp_msg->call_barring_status.ps_bar_status = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
        rsp_msg->call_barring_status_valid = TRUE;
      }
    } // TLV 25 (Call Barring Status)

    if ( qmi_nas_sys_mode_2_radio_if( p_ss_info, stack, FALSE ) == QMI_NAS_RADIO_IF_UMTS && psc != 0xFFFF )
    {
      rsp_msg->umts_psc       = psc;
      rsp_msg->umts_psc_valid = TRUE;
    } // TLV 26 (UMTS Primary Scrambling Code (PSC))

    // TLV 27 (MNC PCS Digit Include Status)
    // Scattered above, see:
    //   rsp_msg->mnc_includes_pcs_digit.mcc
    //   rsp_msg->mnc_includes_pcs_digit.mnc
    //   rsp_msg->mnc_includes_pcs_digit.mnc_includes_pcs_digit
    //   rsp_msg->mnc_includes_pcs_digit_valid

    if (  qmi_nas_sys_mode_2_radio_if(p_ss_info,stack,FALSE) == QMI_NAS_RADIO_IF_UMTS )
    {
      rsp_msg->hs_call_status       = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack].cell_srv_ind.hs_call_status;
      rsp_msg->hs_call_status_valid = TRUE;
    } // TLV 28 (HS Call Status)
  } // end-if ( errval == QMI_ERR_NONE_V01 )

  if ( rsp_msg == NULL )
  {
    QM_MSG_ERROR_1("Not enough memory to allocate for QMI_NAS_GET_SERVING_SYSTEM response.  %d", errval);
    }
  else if ( cmd_buf_p != NULL )
  {
    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_serving_system_resp_msg_v01),
                                  &response
                                );
  }

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}

/*===========================================================================
  FUNCTION qmi_nasi_include_3GPP2_time_zone()

  DESCRIPTION
    Gives the current cdma system informations like Base station information
    and 3GPP2 timezone.

  PARAMETERS
    Pointers to lp_sec, ltm_offset, and daylt_savings to be returned

  RETURN VALUE
     boolean:
         TRUE if CDMA or HDR
         FALSE otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_nasi_include_3GPP2_time_zone
(
  uint8 *lp_sec,
  int8  *ltm_offset,
  uint8 *daylt_savings,
  cm_mm_msim_ss_info_s_type *p_ss_info
)
{
  boolean is_cdma_or_hdr = FALSE;

  if ( lp_sec == NULL || ltm_offset == NULL || daylt_savings == NULL)
  {
    return FALSE;
  }
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*
     CDMA time is reported in 30minute increments.
     Convert units to minutes and return in the tlv.
  */
  if( SYS_SYS_MODE_CDMA == p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.sys_mode )
  {
    *lp_sec = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.cdma_time.lp_sec;

    *ltm_offset = QMI_NAS_6BIT_2_8BIT( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.cdma_time.ltm_offset );

    // cdma ltm_offset is already in increments of 30 min
    *daylt_savings = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.cdma_time.daylt_savings;

    is_cdma_or_hdr = TRUE;
  }
  else if( SYS_SYS_MODE_HDR == p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.sys_mode )
  {
    *lp_sec = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.hdr_time.lp_sec;

    *ltm_offset = (uint8)(p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.time_info.time.hdr_time.ltm_offset/30);

    /* for HDR day light saving is always off */
    *daylt_savings = (uint8) (0x00FF & SYS_DAYLT_SAVINGS_OFF);

    is_cdma_or_hdr = TRUE;
  }

  return is_cdma_or_hdr;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_HOME_NETWORK()

  DESCRIPTION
    Returns a list of HOME network providers.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_home_network
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type          *response      = NULL;
  boolean                acq_mode_cdma  = FALSE;
  boolean                acq_mode_gw    = FALSE;
  nv_item_type           nv_item;

  nv_stat_enum_type      nv_status;
  uint8                  curr_nam       = 0; //default NAM value
  sys_plmn_id_s_type     home_plmn_id;
  uint16                 mcc, mnc;
  boolean                mnc_includes_pcs_digit = FALSE;

  nas_get_home_network_resp_msg_v01  *resp_msg;

  qmi_error_e_type       errval = QMI_ERR_NONE;
  enum qmi_nas_subs_e    bound_subs; // subscription which the client is bound to
  qmi_nas_mmgsdi_session_e_type qmi_session = QMI_NAS_MMGSDI_SESSION_MAX;
  mmgsdi_plmn_id_list_type      plmn_id_list;

  struct qmi_nas_mmgsdi_cache_s *p_cache; // shorthand
  mmgsdi_eons_ignore_disp_cond_enum_type ignore_disp = MMGSDI_EONS_IGNORE_DISPLAY_COND_NONE;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);

    return NULL;
  }

  resp_msg = (nas_get_home_network_resp_msg_v01 *) 
  	modem_mem_alloc( sizeof( nas_get_home_network_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  if( resp_msg == NULL)
  {
  	qmi_voice_mem_error();
	return NULL;
  }

  bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;

  memset(resp_msg, 0, sizeof(nas_get_home_network_resp_msg_v01));

  if(qmi_nasi_global.sim_busy_status.sim_busy == TRUE)
  {
    QM_MSG_ERROR_1("Get Home network SIM busy status %d", qmi_nasi_global.sim_busy_status.sim_busy);
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
  }
  else
  {
    switch ( bound_subs )
    {
    case QMI_NAS_SUBS_PRIMARY:
      switch (qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].sys_mode)
      {
        case SYS_SYS_MODE_CDMA:
        case SYS_SYS_MODE_HDR:
          acq_mode_cdma = TRUE;
          qmi_session = QMI_NAS_MMGSDI_1x_PRI_SESSION;
          break;
        case SYS_SYS_MODE_GSM:
        case SYS_SYS_MODE_WCDMA:
        case SYS_SYS_MODE_GW:
        case SYS_SYS_MODE_LTE:
        case SYS_SYS_MODE_TDS:
          acq_mode_gw = TRUE;
          qmi_session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
          break;
        default:
          break;
        }
        break;
#ifdef FEATURE_DUAL_SIM
      case QMI_NAS_SUBS_SECONDARY:
        acq_mode_gw = TRUE;
        qmi_session = QMI_NAS_MMGSDI_GW_SEC_SESSION;
        break;
#endif
#ifdef FEATURE_TRIPLE_SIM    
      case QMI_NAS_SUBS_TERTIARY:
        acq_mode_gw = TRUE;
        qmi_session = QMI_NAS_MMGSDI_GW_TER_SESSION;
        break;
#endif
      default:
        QM_MSG_ERROR_1( "invalid binding %d", bound_subs );
       break;
    }
  }
QM_MSG_HIGH_5("bounds_sub = %d, acq_mode_cdma = %d, acq_mode_gw = %d, qmi_session = %d, qmi_nasi_global.mmgsdi.operation_ready[qmi_session] = %d", bound_subs, acq_mode_cdma, acq_mode_gw,
	qmi_session, qmi_nasi_global.mmgsdi.operation_ready[qmi_session]);
  if (acq_mode_gw == TRUE && qmi_session != QMI_NAS_MMGSDI_SESSION_MAX)
  {
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
    if ( qmi_nasi_global.mmgsdi.operation_ready[qmi_session] == FALSE )
    {
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
    }

    if ( errval == QMI_ERR_NONE )
    {
      p_cache = &qmi_nasi_global.mmgsdi.cache[qmi_session]; // shorthand

      if ( p_cache->ef_ad_valid   == QMI_NAS_MMGSDI_VALID &&
           p_cache->ef_imsi_valid == QMI_NAS_MMGSDI_VALID )
      {
        if ( p_cache->ef_imsi[0] == 0xFF && p_cache->ef_imsi[1] == 0xFF && p_cache->ef_imsi[2] == 0xFF )
        {
          QM_MSG_ERROR("Invalid IMSI");
          errval = QMI_ERR_INTERNAL;
        }
        else
        {
          mcc = (100 * QMI_NAS_BCD_HIGH_DIGIT(p_cache->ef_imsi[1])) + (10 * QMI_NAS_BCD_LOW_DIGIT(p_cache->ef_imsi[2])) + QMI_NAS_BCD_HIGH_DIGIT(p_cache->ef_imsi[2]);
          mnc = (10 * QMI_NAS_BCD_LOW_DIGIT(p_cache->ef_imsi[3])) + QMI_NAS_BCD_HIGH_DIGIT(p_cache->ef_imsi[3]);

          // if EF_AD size is 4 or more, 4th byte carries MNC length info
          // marked as optional in 3GPP TS 11.11 V8.14.0 cl. 10.3.18 EFAD
          // marked as mandatory in 3GPP TS 31.102 V8.8.0 cl. 4.2.18 EFAD
          if ( p_cache->ef_ad_size >= 4 )
          {
            if ( (p_cache->ef_ad[3] & 0x0F) == 0x03 ) // MNC length is 3
            {
              mnc = (10 * mnc) + QMI_NAS_BCD_LOW_DIGIT(p_cache->ef_imsi[4]);
              mnc_includes_pcs_digit = TRUE;
            }
          }
        }
      }
      else
      {
        errval = QMI_ERR_NOT_PROVISIONED;
      }

    if ( errval == QMI_ERR_NONE )
    {
        if ( !sys_plmn_set_mcc_mnc(mnc_includes_pcs_digit, mcc, mnc, &home_plmn_id) )
      {
          errval = QMI_ERR_INTERNAL;
      }
        else
        {
          struct qmi_nasi_mmgsdi_client_data_s *callback_data;
          mmgsdi_plmn_id_type plmn;
          plmn_id_list.num_of_plmn_ids = 1;
          memscpy(&plmn.plmn_id_val, sizeof(plmn.plmn_id_val),
                  &home_plmn_id.identity, sizeof(plmn.plmn_id_val) );
          plmn.csg_id = SYS_CSG_ID_INVALID;
          plmn.rat = MMGSDI_RAT_NONE;
          plmn_id_list.plmn_list_ptr = &plmn;

          callback_data = (struct qmi_nasi_mmgsdi_client_data_s *)modem_mem_alloc( sizeof(struct qmi_nasi_mmgsdi_client_data_s), MODEM_MEM_CLIENT_QMI_MMODE );
          if( callback_data != NULL )
          {
            callback_data->reason = NAS_CMD_GET_HOME_NETWORK;
            callback_data->cmd_buf_ptr = cmd_buf_p;

            if ( qm_efs_always_return_plmn() )
            {
              ignore_disp = MMGSDI_EONS_IGNORE_RPLMN_DISPLAY_COND;
            }

            if( MMGSDI_SUCCESS != mmgsdi_session_get_operator_name_ext ( qmi_nasi_global.mmgsdi.session_id[qmi_session],
                                                                     plmn_id_list,
                                                                         ignore_disp,
                                                                     qmi_nas_mmgsdi_cmd_rsp_cb,
                                                                     (uint32) callback_data ) )
      {
              errval = QMI_ERR_INTERNAL;
              modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
            }
          }
          else
        {
            //Can't allocate memory
            errval = QMI_ERR_INTERNAL;
          }
        }
      }
    }
#endif // FEATURE_WCDMA || FEATURE_GSM
  }
  else if (acq_mode_cdma == TRUE)
  {
    if ( qmi_nasi_global.cm_ph_info.rtre_control == CM_RTRE_CONTROL_RUIM &&
         qmi_nasi_global.mmgsdi.operation_ready[qmi_session] == FALSE )
    {
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
    }

    if (errval == QMI_ERR_NONE)
    {
      /* Read and temporarily cache the current NAM */
      nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
      if (nv_status == NV_DONE_S && nv_item.curr_nam < NV_MAX_NAMS)
      {
        curr_nam = nv_item.curr_nam;
      }

      /*-------------------------------------------------------------------------
        Get the MCC from NV
      -------------------------------------------------------------------------*/
      nv_item.imsi_mcc.nam = curr_nam;
      nv_status = qmi_mmode_get_nv_item( NV_IMSI_MCC_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        resp_msg->home_network.mobile_country_code = nv_item.imsi_mcc.imsi_mcc;
      }
      else if (nv_status == NV_NOTACTIVE_S)
      {
        QM_MSG_HIGH("MCC NV item not active");
        errval = QMI_ERR_NOT_PROVISIONED;
      }
      else
      {
        QM_MSG_ERROR("Error reading MCC NV item");
        errval = QMI_ERR_INTERNAL;
      }
    }

    /*-----------------------------------------------------------------------
      Get the MNC from NV
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE)
    {
      nv_item.imsi_11_12.nam = curr_nam;
      nv_status = qmi_mmode_get_nv_item(NV_IMSI_11_12_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        resp_msg->home_network.mobile_network_code = nv_item.imsi_11_12.imsi_11_12;

        resp_msg->nas_3gpp_mcs_include_digit.is_3gpp_network            = FALSE;
        resp_msg->nas_3gpp_mcs_include_digit.mnc_includes_pcs_digit   = FALSE;
        resp_msg->nas_3gpp_mcs_include_digit_valid   = TRUE;
      }
      else if (nv_status == NV_NOTACTIVE_S )
      {
        QM_MSG_HIGH("MNC NV item not active");
        errval = QMI_ERR_NOT_PROVISIONED;
      }
      else
      {
        QM_MSG_ERROR("Error reading MNC NV item");
        errval = QMI_ERR_INTERNAL;
      }
    }

    /*-------------------------------------------------------------------------
      Get the SID/NID from NV if provisioned
    -------------------------------------------------------------------------*/
#ifdef FEATURE_SSPR_ENHANCEMENTS
    if (errval == QMI_ERR_NONE)
    {
      //possibly put these around two different ifs?
      nv_item.home_sid_nid.nam = curr_nam;
      nv_status = qmi_mmode_get_nv_item(NV_HOME_SID_NID_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        resp_msg->home_system_id.sid   = nv_item.home_sid_nid.pair[0].sid;
        resp_msg->home_system_id.nid   = nv_item.home_sid_nid.pair[0].nid;
        resp_msg->home_system_id_valid = TRUE;
      }
      else if (nv_status == NV_NOTACTIVE_S )
      {
        QM_MSG_HIGH("Home SID NID NV item not active");
      }
      else
      {
        QM_MSG_ERROR("Error reading Home SID NID NV item");
        errval = QMI_ERR_INTERNAL;
      }
    }
#else
    if (errval == QMI_ERR_NONE)
    {
      nv_item.sid_nid.nam = curr_nam;
      nv_status = qmi_mmode_get_nv_item( NV_SID_NID_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        resp_msg->home_system_id.sid   = nv_item.sid_nid.pair[NV_CDMA_MIN_INDEX][0].sid;
        resp_msg->home_system_id.nid   = nv_item.sid_nid.pair[NV_CDMA_MIN_INDEX][0].nid;
        resp_msg->home_system_id_valid = TRUE;
      }
      else if (nv_status == NV_NOTACTIVE_S )
      {
        QM_MSG_HIGH("SID NID NV item not active");
      }
      else
      {
        QM_MSG_ERROR("Error reading SID NID NV item");
        errval = QMI_ERR_INTERNAL;
      }
    }
#endif /* FEATURE_SSPR_ENHANCEMENTS */

    if (errval == QMI_ERR_NONE &&
        qmi_nasi_global.cm_ph_info.rtre_control == CM_RTRE_CONTROL_RUIM)
    {
      resp_msg->nas_3gpp2_home_network_ext.mcc_mnc.mcc= resp_msg->home_network.mobile_country_code;
      resp_msg->nas_3gpp2_home_network_ext.mcc_mnc.mnc= resp_msg->home_network.mobile_network_code;

      if ( qmi_nasi_global.mmgsdi.cache[qmi_session].ef_cdma_spn_valid == QMI_NAS_MMGSDI_VALID )
      {
        resp_msg->nas_3gpp2_home_network_ext.network_desc_display  = (qmi_nasi_global.mmgsdi.cache[qmi_session].ef_cdma_spn[0] & 0x01) ? NAS_NETWORK_DESC_DISP_TRUE_V01 : NAS_NETWORK_DESC_DISP_FALSE_V01;
        resp_msg->nas_3gpp2_home_network_ext.network_desc_encoding = qmi_nasi_global.mmgsdi.cache[qmi_session].ef_cdma_spn[1];
        resp_msg->nas_3gpp2_home_network_ext.network_desc_len = qmi_nasi_global.mmgsdi.cache[qmi_session].ef_cdma_spn_size-3; // subtract display condition, character encoding, language indicator
        memscpy(resp_msg->nas_3gpp2_home_network_ext.network_desc, 
                qmi_nasi_global.mmgsdi.cache[qmi_session].ef_cdma_spn_size-3,
                qmi_nasi_global.mmgsdi.cache[qmi_session].ef_cdma_spn+3, 
                qmi_nasi_global.mmgsdi.cache[qmi_session].ef_cdma_spn_size-3);
      }
      else
      {
        resp_msg->nas_3gpp2_home_network_ext.network_desc_display  = NAS_NETWORK_DESC_DISP_UNKNOWN_V01;
        resp_msg->nas_3gpp2_home_network_ext.network_desc_encoding = NAS_NETWORK_DESC_ENCODING_OCTECT_UNSPECIFIED_V01;
        resp_msg->nas_3gpp2_home_network_ext.network_desc_len= 0;
        resp_msg->nas_3gpp2_home_network_ext.network_desc[0]       = '\0';
      }

      resp_msg->nas_3gpp2_home_network_ext_valid = TRUE;
    }
  }
  else if(qmi_nasi_global.sim_busy_status.sim_busy == TRUE)
  {
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
  }
  else
  {
    errval = QMI_ERR_NOT_PROVISIONED;
  }

  if( acq_mode_gw == TRUE && errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    if ( acq_mode_cdma == TRUE && errval == QMI_ERR_NONE)
    {
      resp_msg->resp.error  = (qmi_error_type_v01)errval;
      resp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
    } 
    else
    {
      QM_MSG_HIGH("Error");
      //Failed so reset the data populated if any.
      memset(resp_msg, 0, sizeof(nas_get_home_network_resp_msg_v01));

      resp_msg->resp.error  = (qmi_error_type_v01)errval;
      resp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    }
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                (void *) resp_msg,
                                (uint32_t) sizeof(nas_get_home_network_resp_msg_v01),
                                &response
                              );
    }

  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_home_network() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_PREFERRED_NETWORKS()

  DESCRIPTION
    Returns a list of preferred network providers.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_preferred_networks
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;
  boolean          retval;
  qmi_error_e_type errval = QMI_ERR_NONE;
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
  mmgsdi_file_enum_type plmn_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_file_enum_type plmn_wact_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_file_enum_type oplmn_wact_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_access_type    file_access;
  qmi_nas_mmgsdi_session_e_type session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  mmgsdi_session_type_enum_type mmgsdi_session =  MMGSDI_GW_PROV_PRI_SESSION;
  enum qmi_nas_subs_e    bound_subs; // subscription which the client is bound to
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
  QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  /*-------------------------------------------------------------------------
    Operation not supported if device doesn't have WCDMA or GSM
    Operation works for multimode devices but will return only what
    is in the SIM ie GW
  -------------------------------------------------------------------------*/
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  if(qmi_nasi_global.sim_busy_status.sim_busy == TRUE)
  {
    QM_MSG_ERROR_1("Get Preferred network, SIM busy status %d", qmi_nasi_global.sim_busy_status.sim_busy);
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
    goto send_result;
  }

  bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
#ifdef FEATURE_DUAL_SIM
  if( bound_subs == QMI_NAS_SUBS_SECONDARY ) 
  {
    mmgsdi_session =  MMGSDI_GW_PROV_SEC_SESSION;
  }
#ifdef FEATURE_TRIPLE_SIM
  else if( bound_subs == QMI_NAS_SUBS_TERTIARY ) 
  {
    mmgsdi_session =  MMGSDI_GW_PROV_TER_SESSION;
  }
#endif
#endif
  session = qmi_nas_map_mmgsdi_session_to_qmi(mmgsdi_session); 
  
  QM_MSG_HIGH_3("qmi_nasi_get_preferred_networks: mmgsdi_session:%d, session:%d, app_type:%d", mmgsdi_session, session, 
  	qmi_nasi_global.mmgsdi.app_type[session]);
  	
  if ( qmi_nasi_global.mmgsdi.operation_ready[session] == FALSE )
  {
    QM_MSG_HIGH_1("session:%d  is not ready", session);
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
    goto send_result;
  }

  if ( qmi_nasi_global.mmgsdi.app_type[session] == MMGSDI_APP_SIM)
  {
    plmn_filename       = MMGSDI_GSM_PLMN;
    plmn_wact_filename  = MMGSDI_GSM_PLMNWACT;
    oplmn_wact_filename = MMGSDI_GSM_OPLMNWACT;
  }
  else if ( qmi_nasi_global.mmgsdi.app_type[session] == MMGSDI_APP_USIM)
  {
    plmn_wact_filename  = MMGSDI_USIM_PLMNWACT;
    oplmn_wact_filename = MMGSDI_USIM_OPLMNWACT;
  }
  else
  {
    QM_MSG_HIGH_1("app_type:%d  not supported", qmi_nasi_global.mmgsdi.app_type[session]);
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    goto send_result;
  }

  /* Queue the command buffer to send response later */
  qm_cbpq_add ( QM_CBPQ_QTYPE_GET_PREF, cmd_buf_p, ((qmi_nasi_client_state_type *)cl_sp)->common.clid );

  if ( !qmi_nasi_global.get_pref_nwks_req_pending )
  {
    file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
    file_access.file.file_enum = plmn_wact_filename;

    if (qmi_nasi_global.mmgsdi_ef_info.plmn_wact == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND)
    {
      qmi_nasi_global.pref_nw_scratch.plmn_wact = QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
      QM_MSG_HIGH("plmn_wact NOT_FOUND");
    }
    else
    {
      QM_MSG_HIGH_1("Reading  plmn_wact_filename:%d", plmn_wact_filename);
      if ( MMGSDI_SUCCESS == mmgsdi_session_read_transparent( qmi_nasi_global.mmgsdi.session_id[session],
                                                              file_access,
                                                              0,
                                                              sizeof(qmi_nasi_mmgsdi_plmn_wact_type) * SYS_USER_PPLMN_LIST_MAX_LENGTH,
                                                              qmi_nas_mmgsdi_cmd_rsp_cb,
                                                              (uint32) cmd_buf_p) )
      {
        qmi_nasi_global.pref_nw_scratch.plmn_wact = QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED;
      }
      else
      {
        //mmgsdi_session_read_transparent failed
        errval = QMI_ERR_INTERNAL;
        goto send_result;
      }
    }

    file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
    file_access.file.file_enum = oplmn_wact_filename;

    if (qmi_nasi_global.mmgsdi_ef_info.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND)
    {
      qmi_nasi_global.pref_nw_scratch.oplmn_wact = QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
      QM_MSG_HIGH("oplmn_wact NOT_FOUND");
    }
    else
    {
      QM_MSG_HIGH_1("Reading  oplmn_wact_filename:%d", oplmn_wact_filename);
      if ( MMGSDI_SUCCESS == mmgsdi_session_read_transparent( qmi_nasi_global.mmgsdi.session_id[session],
                                                              file_access,
                                                              0,
                                                              sizeof(qmi_nasi_mmgsdi_plmn_wact_type) * SYS_PLMN_LIST_MAX_LENGTH,
                                                              qmi_nas_mmgsdi_cmd_rsp_cb,
                                                              (uint32) cmd_buf_p) )
      {
        qmi_nasi_global.pref_nw_scratch.oplmn_wact = QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED;
      }
      else
      {
        //mmgsdi_session_read_transparent failed
        errval = QMI_ERR_INTERNAL;
        goto send_result;
      }
    }

    if (qmi_nasi_global.mmgsdi.app_type[session] == MMGSDI_APP_SIM)
    {
      file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
      file_access.file.file_enum = plmn_filename;

      if (qmi_nasi_global.mmgsdi_ef_info.plmn == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND)
      {
        qmi_nasi_global.pref_nw_scratch.plmn = QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
       QM_MSG_HIGH("plmn NOT_FOUND");
      }
      else
      {
        QM_MSG_HIGH_1("Reading  plmn_filename:%d", plmn_filename);
        if ( MMGSDI_SUCCESS == mmgsdi_session_read_transparent( qmi_nasi_global.mmgsdi.session_id[session],
                                                                file_access,
                                                                0,
                                                                sizeof(sys_plmn_id_s_type) * SYS_PLMN_LIST_MAX_LENGTH,
                                                                qmi_nas_mmgsdi_cmd_rsp_cb,
                                                                (uint32) cmd_buf_p) )
        {
          qmi_nasi_global.pref_nw_scratch.plmn = QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED;
        }
        else
        {
          //mmgsdi_session_read_transparent failed
          errval = QMI_ERR_INTERNAL;
          goto send_result;
        }
      }
    }
    qmi_nasi_global.get_pref_nwks_req_pending = TRUE;
    QM_MSG_HIGH("Response pending for get preferred networks");
  }
  else
  {
    QM_MSG_HIGH("Get preferred nwks already called with response pending.");
  }
  return QMI_SVC_RESPONSE_PENDING;
#else
  QM_MSG_HIGH("Unable to process GET_PREF_NWKS request: non-GSM non-WCDMA target");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */
#else
  QM_MSG_HIGH("Unable to process GET_PREF_NWKS request: no MMGSDI support");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

send_result:
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
  (void) qm_cbpq_get( QM_CBPQ_QTYPE_GET_PREF );
  if (qmi_nasi_global.pref_nw_scratch.plmn_list != NULL)
  {
    modem_mem_free( qmi_nasi_global.pref_nw_scratch.plmn_list, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  if (qmi_nasi_global.pref_nw_scratch.plmn_wact_list != NULL)
  {
    modem_mem_free( qmi_nasi_global.pref_nw_scratch.plmn_wact_list, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  if (qmi_nasi_global.pref_nw_scratch.oplmn_wact_list != NULL)
  {
    modem_mem_free( qmi_nasi_global.pref_nw_scratch.oplmn_wact_list, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  qmi_nasi_global.get_pref_nwks_req_pending = FALSE;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */
  retval = qmi_svc_put_result_tlv(&response, QMI_RESULT_FAILURE, errval);
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_get_preferred_networks() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_PREFERRED_NETWORKS()

  DESCRIPTION
    Sets the list of preferred network providers in the SIM/UIM to the list
    provided in the request.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_preferred_networks
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  qmi_error_e_type   errval;
  
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  nas_set_preferred_networks_req_msg_v01 *req_msg;

  mmgsdi_file_enum_type            plmn_wact_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_file_enum_type            plmn_filename = MMGSDI_NO_FILE_ENUM;
  qmi_nasi_mmgsdi_plmn_wact_type   preferred_networks_list[SYS_USER_PPLMN_LIST_MAX_LENGTH];
  sys_plmn_id_s_type               pref_plmn_list[SYS_USER_PPLMN_LIST_MAX_LENGTH];
  mmgsdi_write_data_type           plmn_data;

  uint8                            i;
  boolean                          mnc_includes_pcs_digit;
  mmgsdi_access_type               file_access;
  uint8                            file_num_recs;
  enum qmi_nas_subs_e    bound_subs; // subscription which the client is bound to
  qmi_nas_mmgsdi_session_e_type session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  mmgsdi_session_type_enum_type mmgsdi_session =  MMGSDI_GW_PROV_PRI_SESSION;
  
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  response = NULL;
  errval = QMI_ERR_NONE;

  /*-------------------------------------------------------------------------
    Operation not supported if device doesn't have WCDMA or GSM
    Operation works for multimode devices but will return only wht
    is in the SIM ie GW
  -------------------------------------------------------------------------*/
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  req_msg = ( nas_set_preferred_networks_req_msg_v01 *) modem_mem_alloc( sizeof(nas_set_preferred_networks_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if( req_msg  == NULL )
        {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY;
    ASSERT(req_msg);
          goto send_result;
        }

  memset (req_msg, 0x00, sizeof(nas_set_preferred_networks_req_msg_v01));

  // extract information from REQ message
  errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                         sdu_in,
                                         (void *) req_msg,
                                         (uint32_t) sizeof(nas_set_preferred_networks_req_msg_v01)
                                       );
  if( errval != QMI_ERR_NONE )
    {
      goto send_result;
    }

  if(!req_msg->nas_3gpp_preferred_networks_valid)
  {
    errval = QMI_ERR_MISSING_ARG;
  }
  else
  {
    if(qmi_nasi_global.sim_busy_status.sim_busy == TRUE)
    {
      QM_MSG_ERROR_1("Set Preferred network, SIM busy status %d", qmi_nasi_global.sim_busy_status.sim_busy);
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
      goto send_result;
    }

    bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
    
#ifdef FEATURE_DUAL_SIM
    if( bound_subs == QMI_NAS_SUBS_SECONDARY ) 
    {
      mmgsdi_session =  MMGSDI_GW_PROV_SEC_SESSION;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if( bound_subs == QMI_NAS_SUBS_TERTIARY ) 
    {
      mmgsdi_session =  MMGSDI_GW_PROV_TER_SESSION;
    }
#endif
#endif
    session = qmi_nas_map_mmgsdi_session_to_qmi(mmgsdi_session); 

    QM_MSG_HIGH_3("qmi_nasi_set_preferred_networks: mmgsdi_session:%d, session:%d app_type:%d", mmgsdi_session, session,
		qmi_nasi_global.mmgsdi.app_type[session]);
    if ( qmi_nasi_global.mmgsdi.operation_ready[session] == FALSE )
    {
      QM_MSG_HIGH_1("session:%d  is not ready", session);
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
      goto send_result;
    }

    if ( qmi_nasi_global.mmgsdi.app_type[session] == MMGSDI_APP_SIM)
    {
      if (qmi_nasi_global.mmgsdi.cache[session].ef_plmnwact_valid == QMI_NAS_MMGSDI_VALID)
      {
        plmn_wact_filename = MMGSDI_GSM_PLMNWACT;
      }
      else if (qmi_nasi_global.mmgsdi.cache[session].ef_plmn_valid == QMI_NAS_MMGSDI_VALID)
      {
        plmn_filename = MMGSDI_GSM_PLMN;
      }
      else
      {
        QM_MSG_HIGH("SIM NOT_INITIALIZED");
        errval = QMI_ERR_SIM_NOT_INITIALIZED;
        goto send_result;
      }
    }
    else if ( qmi_nasi_global.mmgsdi.app_type[session] == MMGSDI_APP_USIM)
    {
      if (qmi_nasi_global.mmgsdi.cache[session].ef_plmnwact_valid == QMI_NAS_MMGSDI_VALID)
      {
        plmn_wact_filename = MMGSDI_USIM_PLMNWACT;
      }
      else
      {
        QM_MSG_HIGH("USIM NOT_INITIALIZED");
        errval = QMI_ERR_SIM_NOT_INITIALIZED;
        goto send_result;
      }
    }
    else
    {
      QM_MSG_HIGH_1("app_type:%d  not supported", qmi_nasi_global.mmgsdi.app_type[session]);
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
      goto send_result;
    }

    QM_MSG_HIGH_2("plmn_wact_filename:%d, plmn_filename:%d", plmn_wact_filename, plmn_filename);

    if ( req_msg->nas_3gpp_mnc_includes_pcs_digit_valid 
         &&  req_msg->nas_3gpp_preferred_networks_len != req_msg->nas_3gpp_mnc_includes_pcs_digit_len )
    {
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }

    for(i=0; i<req_msg->nas_3gpp_preferred_networks_len; i++)
    {
      if ( req_msg->nas_3gpp_mnc_includes_pcs_digit_valid )
      {
        mnc_includes_pcs_digit = req_msg->nas_3gpp_mnc_includes_pcs_digit[i].mnc_includes_pcs_digit;
      }
      else
      {
        mnc_includes_pcs_digit = (req_msg->nas_3gpp_preferred_networks[i].mobile_country_code > 99) ? TRUE : FALSE;
      }

      if ( FALSE == sys_plmn_set_mcc_mnc(
                             mnc_includes_pcs_digit,
                             (uint32) req_msg->nas_3gpp_preferred_networks[i].mobile_country_code,
                             (uint32) req_msg->nas_3gpp_preferred_networks[i].mobile_network_code,
                             &(preferred_networks_list[i].plmn)) )
      {
        errval = QMI_ERR_INVALID_ARG;
        goto send_result;
      }
      else
      {
        memscpy ( &(pref_plmn_list[i]),
                  sizeof(sys_plmn_id_s_type),
                 &(preferred_networks_list[i].plmn),
                 sizeof(sys_plmn_id_s_type) );
      }

      preferred_networks_list[i].act[0] = 0;
      preferred_networks_list[i].act[1] = 0;

      if(req_msg->nas_3gpp_preferred_networks[i].radio_access_technology & 0x0080)
      {
        preferred_networks_list[i].act[1] |= 0x80; // 0000 0000 1000 0000 GSM
      }
      if(req_msg->nas_3gpp_preferred_networks[i].radio_access_technology & 0x0040)
      {
        preferred_networks_list[i].act[1] |= 0x40; // 0000 0000 0100 0000 GSM compact
      }
      if(req_msg->nas_3gpp_preferred_networks[i].radio_access_technology & 0x8000)
      {
        preferred_networks_list[i].act[0] |= 0x80; // 1000 0000 0000 0000 UMTS
      }
      if(req_msg->nas_3gpp_preferred_networks[i].radio_access_technology & 0x4000)
      {
        preferred_networks_list[i].act[0] |= 0x40; // 0100 0000 0000 0000 LTE
      }
    }

    if (plmn_wact_filename != MMGSDI_NO_FILE_ENUM)
    {
      plmn_data.data_len = req_msg->nas_3gpp_preferred_networks_len *
                             sizeof(qmi_nasi_mmgsdi_plmn_wact_type);
      plmn_data.data_ptr = (uint8*)preferred_networks_list;

      if ( req_msg->clear_prev_preferred_networks_valid && (req_msg->clear_prev_preferred_networks == TRUE) &&
           (plmn_data.data_len < qmi_nasi_global.mmgsdi.cache[session].ef_plmnwact_size) )
      {
        file_num_recs = MIN(SYS_USER_PPLMN_LIST_MAX_LENGTH, (qmi_nasi_global.mmgsdi.cache[session].ef_plmnwact_size/sizeof(qmi_nasi_mmgsdi_plmn_wact_type)));

        for( i = req_msg->nas_3gpp_preferred_networks_len; i < file_num_recs; i++ )
        {
          preferred_networks_list[i].plmn.identity[0] = 0xFF;
          preferred_networks_list[i].plmn.identity[1] = 0xFF;
          preferred_networks_list[i].plmn.identity[2] = 0xFF;

          preferred_networks_list[i].act[0] = 0x00;
          preferred_networks_list[i].act[1] = 0x00;
        }

        plmn_data.data_len = file_num_recs * sizeof(qmi_nasi_mmgsdi_plmn_wact_type);
      }

      file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
      file_access.file.file_enum = plmn_wact_filename;

      if (MMGSDI_SUCCESS == mmgsdi_session_write_transparent(
                              qmi_nasi_global.mmgsdi.session_id[session],
                              file_access,
                              0,
                              plmn_data,
                              qmi_nas_mmgsdi_cmd_rsp_cb,
                              (uint32) cmd_buf_p))
      {
        return QMI_SVC_RESPONSE_PENDING;
      }
      else
      {
        QM_MSG_HIGH("mmgsdi_session_write_transparent failed");
        errval = QMI_ERR_INTERNAL;
      }
    }
    else if (plmn_filename != MMGSDI_NO_FILE_ENUM)
    {
      plmn_data.data_len = req_msg->nas_3gpp_preferred_networks_len *
                             sizeof(sys_plmn_id_s_type);
      plmn_data.data_ptr = (uint8*)pref_plmn_list;

      if ( req_msg->clear_prev_preferred_networks_valid && (req_msg->clear_prev_preferred_networks == TRUE) &&
           (plmn_data.data_len < qmi_nasi_global.mmgsdi.cache[session].ef_plmn_size) )
      {
        file_num_recs = MIN(SYS_USER_PPLMN_LIST_MAX_LENGTH, (qmi_nasi_global.mmgsdi.cache[session].ef_plmn_size/sizeof(sys_plmn_id_s_type)));

        for( i = req_msg->nas_3gpp_preferred_networks_len; i < file_num_recs; i++ )
        {
          pref_plmn_list[i].identity[0] = 0xFF;
          pref_plmn_list[i].identity[1] = 0xFF;
          pref_plmn_list[i].identity[2] = 0xFF;
        }

        plmn_data.data_len = file_num_recs * sizeof(sys_plmn_id_s_type);
      }

      file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
      file_access.file.file_enum = plmn_filename;

      if (MMGSDI_SUCCESS == mmgsdi_session_write_transparent(
                              qmi_nasi_global.mmgsdi.session_id[session],
                              file_access,
                              0,
                              plmn_data,
                              qmi_nas_mmgsdi_cmd_rsp_cb,
                              (uint32) cmd_buf_p))
      {
        return QMI_SVC_RESPONSE_PENDING;
      }
      else
      {
        QM_MSG_HIGH("mmgsdi_session_write_transparent failed");
        errval = QMI_ERR_INTERNAL;
      }
    }
    else
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  QM_MSG_ERROR("Unable to change preferred networks settings");

#else
  QM_MSG_HIGH("Unable to process SET_PREF_NWKS request: non-GSM non-WCDMA target");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#else
  QM_MSG_HIGH("Unable to process SET_PREF_NWKS request: no MMGSDI support");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

send_result:
  if( cmd_buf_p != NULL )
  {
    nas_set_preferred_networks_resp_msg_v01 resp_msg;

    resp_msg.resp.error  = (qmi_error_type_v01)errval;
    resp_msg.resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) &resp_msg,
                                  (uint32_t) sizeof(nas_set_preferred_networks_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;

} /* qmi_nasi_set_preferred_networks() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_FORBIDDEN_NETWORKS()

  DESCRIPTION
    Returns a list of forbidden network providers.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_forbidden_networks
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  boolean            retval;
  qmi_error_e_type   errval;
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
  uint32             filesize;
  mmgsdi_return_enum_type mmgsdi_status;
  mmgsdi_file_enum_type fplmn_filename = MMGSDI_NO_FILE_ENUM;
  mmgsdi_access_type file_access;
  enum qmi_nas_subs_e    bound_subs; // subscription which the client is bound to
  qmi_nas_mmgsdi_session_e_type session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  mmgsdi_session_type_enum_type mmgsdi_session =  MMGSDI_GW_PROV_PRI_SESSION;

#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  response = NULL;
  errval = QMI_ERR_NONE;
  /*-------------------------------------------------------------------------
    Operation not supported if device doesn't have WCDMA or GSM
    Operation works for multimode devices but will return only wht
    is in the SIM ie GW
  -------------------------------------------------------------------------*/
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
#ifdef FEATURE_DUAL_SIM
  if( bound_subs == QMI_NAS_SUBS_SECONDARY ) 
  {
    mmgsdi_session =  MMGSDI_GW_PROV_SEC_SESSION;
  }
#ifdef FEATURE_TRIPLE_SIM
  else if( bound_subs == QMI_NAS_SUBS_TERTIARY ) 
  {
    mmgsdi_session =  MMGSDI_GW_PROV_TER_SESSION;
  }
#endif
#endif
  session = qmi_nas_map_mmgsdi_session_to_qmi(mmgsdi_session); 

  QM_MSG_HIGH_3("qmi_nasi_get_forbidden_networks, mmgsdi_session:%d, session:%d,app_type:%d ", mmgsdi_session, session,
  	qmi_nasi_global.mmgsdi.app_type[session]);
  if ( qmi_nasi_global.mmgsdi.operation_ready[session] == FALSE )
  {
    QM_MSG_HIGH_1("session:%d  is not ready", session);
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
    goto send_result;
  }

  if(qmi_nasi_global.sim_busy_status.sim_busy == TRUE)
  {
    QM_MSG_ERROR_1("Get forbidden_networks SIM busy status %d", qmi_nasi_global.sim_busy_status.sim_busy);
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
    goto send_result;
  }

  /* Queue the command buffer to send response later */
  filesize = sizeof(sys_plmn_id_s_type) * SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH;

  file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
  file_access.file.file_enum = MMGSDI_NO_FILE_ENUM;

  if ( qmi_nasi_global.mmgsdi.app_type[session] == MMGSDI_APP_SIM)
  {
    fplmn_filename = MMGSDI_GSM_FPLMN;
    filesize       = 0;
  }
  else if ( qmi_nasi_global.mmgsdi.app_type[session] == MMGSDI_APP_USIM)
  {
    fplmn_filename = MMGSDI_USIM_FPLMN;
  }
  else
  {
    QM_MSG_HIGH_1("app_type:%d  not supported", qmi_nasi_global.mmgsdi.app_type[session]);
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    goto send_result;
  }

  file_access.file.file_enum = fplmn_filename;

  mmgsdi_status = mmgsdi_session_read_transparent(
                                        qmi_nasi_global.mmgsdi.session_id[session],
                                        file_access,
                                        0,
                                        filesize,
                                        qmi_nas_mmgsdi_cmd_rsp_cb,
                                        (uint32) cmd_buf_p);
  if (mmgsdi_status != MMGSDI_SUCCESS)
  {
    QM_MSG_HIGH_1("mmgsdi_status:%d", mmgsdi_status);
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }
  return QMI_SVC_RESPONSE_PENDING;
#else
  QM_MSG_HIGH("Unable to process GET_FORB_NWKS request: non-GSM non-WCDMA target");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#else
  QM_MSG_HIGH("Unable to process GET_FORB_NWKS request: no MMGSDI support");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

send_result:
  retval = qmi_svc_put_result_tlv(&response,
                                  QMI_RESULT_FAILURE,
                                  errval);
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_get_forbidden_networks() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_FORBIDDEN_NETWORKS()

  DESCRIPTION
    Sets the list of forbidden network providers in the SIM/UIM to the list
    provided in the request.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_forbidden_networks
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  boolean            retval;
  qmi_error_e_type   errval;
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
  struct
  {
    uint16    length;
    struct
    {
      uint16  mcc;
      uint16  mnc;
    }plmn_info_list[SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH];
  } v_in_reqd;

  mmgsdi_access_type     file_access;
  mmgsdi_file_enum_type  fplmn_wact_filename = MMGSDI_NO_FILE_ENUM;
  sys_plmn_id_s_type     forbidden_networks_list[SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH];
  mmgsdi_write_data_type fplmn_data;
  boolean                got_v_in_reqd;
  uint8                  prm_type;
  uint16                 len;
  uint16                 expected_len;
  uint8                  i;
  void *                 value;
  boolean                mnc_includes_pcs_digit;
  uint16                 tlv_len = 0;
  enum qmi_nas_subs_e    bound_subs; // subscription which the client is bound to
  qmi_nas_mmgsdi_session_e_type session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  mmgsdi_session_type_enum_type mmgsdi_session =  MMGSDI_GW_PROV_PRI_SESSION;

#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  response = NULL;
  errval = QMI_ERR_NONE;

  /*-------------------------------------------------------------------------
    Operation not supported if device doesn't have WCDMA or GSM
    Operation works for multimode devices but will return only wht
    is in the SIM ie GW
  -------------------------------------------------------------------------*/
#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)

  file_access.access_method = MMGSDI_EF_ENUM_ACCESS;
  file_access.file.file_enum = MMGSDI_NO_FILE_ENUM;

  memset(&v_in_reqd, 0, sizeof(v_in_reqd));
  got_v_in_reqd = FALSE;
  mnc_includes_pcs_digit = TRUE;

  while (*sdu_in)
  {
    if( !qmi_svc_get_tl(sdu_in, &prm_type, &len) )
    {
      continue;
    }

    /* special value 0 = variable length or don't care (unrecognzied TLV) */
    expected_len = 0;
    value = NULL;
    switch (prm_type)
    {
      case NASI_PARAM_TYPE_SET_FORB_NETWORKS:
        if (len <= sizeof(v_in_reqd))
        {
          value = &v_in_reqd;
          got_v_in_reqd = TRUE;
          tlv_len = len;
        }
        else
        {
          errval = QMI_ERR_ARG_TOO_LONG;
          goto send_result;
        }
        break;

      default:
        QM_MSG_ERROR_1("Unrecognized TLV type (%d)", prm_type);
        break;
    }

    if ((expected_len != 0) && (expected_len != len))
    {
      QM_MSG_ERROR_2("Invalid TLV len (%d) for type (%d)", len, prm_type);
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }

    if(len != dsm_pullup( sdu_in, value, len ))
    {
      QM_MSG_ERROR("Invalid length in TLV");
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }
  }

  if(!got_v_in_reqd)
  {
    errval = QMI_ERR_MISSING_ARG;
    goto send_result;
  }
  else
  {
    /* Validate length of input tlv to ensure it is consistent with
       num instances field specified in the tlv (2bytes + (n*4bytes)) */
    if ( tlv_len !=
             ( sizeof(v_in_reqd.length) +
               ( v_in_reqd.length * sizeof(v_in_reqd.plmn_info_list[0]) ) ) )
    {
      QM_MSG_HIGH_1("Num_forbidden_network_instances value(%d) different from number of networks sent in TLV!", v_in_reqd.length);
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }

    for(i=0; i<v_in_reqd.length; i++)
    {
      mnc_includes_pcs_digit = (v_in_reqd.plmn_info_list[i].mnc > 99) ? TRUE
                                                                     : FALSE;
      if ( FALSE == sys_plmn_set_mcc_mnc( mnc_includes_pcs_digit,
                                   (uint32) v_in_reqd.plmn_info_list[i].mcc,
                                   (uint32) v_in_reqd.plmn_info_list[i].mnc,
                                   &(forbidden_networks_list[i])) )
      {
        errval = QMI_ERR_INVALID_ARG;
        goto send_result;
      }
    }
  }

  if(qmi_nasi_global.sim_busy_status.sim_busy == TRUE)
  {
    QM_MSG_ERROR_1("Set Forbidden networks, SIM busy status %d", qmi_nasi_global.sim_busy_status.sim_busy);
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
    goto send_result;
  }

  bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
#ifdef FEATURE_DUAL_SIM
  if( bound_subs == QMI_NAS_SUBS_SECONDARY ) 
  {
    mmgsdi_session =  MMGSDI_GW_PROV_SEC_SESSION;
  }
  #ifdef FEATURE_TRIPLE_SIM
  else if( bound_subs == QMI_NAS_SUBS_TERTIARY ) 
  {
    mmgsdi_session =  MMGSDI_GW_PROV_TER_SESSION;
  }
#endif
#endif
  session = qmi_nas_map_mmgsdi_session_to_qmi(mmgsdi_session); 

  QM_MSG_HIGH_3("qmi_nasi_set_forbidden_networks: mmgsdi_session:%d, session:%d, app_type:%d", mmgsdi_session, session,
  	qmi_nasi_global.mmgsdi.app_type[session]);
  if ( qmi_nasi_global.mmgsdi.operation_ready[session] == FALSE )
  {
    QM_MSG_HIGH_1("session:%d  is not ready", session);
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
    goto send_result;
  }

  if ( qmi_nasi_global.mmgsdi.app_type[session] == MMGSDI_APP_SIM)
  {
    fplmn_wact_filename = MMGSDI_GSM_FPLMN;
  }
  else if ( qmi_nasi_global.mmgsdi.app_type[session] == MMGSDI_APP_USIM)
  {
    fplmn_wact_filename = MMGSDI_USIM_FPLMN;
  }
  else
  {
    QM_MSG_HIGH_1("app_type:%d  not supported", qmi_nasi_global.mmgsdi.app_type[session]);
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    goto send_result;
  }

  QM_MSG_HIGH_1("fplmn_wact_filename:%d", fplmn_wact_filename);
  if ((errval == QMI_ERR_NONE) &&
      (fplmn_wact_filename != MMGSDI_NO_FILE_ENUM))
  {
    fplmn_data.data_len = v_in_reqd.length *
                           sizeof(sys_plmn_id_s_type);
    fplmn_data.data_ptr = (uint8*)forbidden_networks_list;
    file_access.file.file_enum = fplmn_wact_filename;
    QM_MSG_HIGH("mmgsdi_session_write_transparent");
    if (MMGSDI_SUCCESS == mmgsdi_session_write_transparent(
                            qmi_nasi_global.mmgsdi.session_id[session],
                            file_access,
                            0,
                            fplmn_data,
                            qmi_nas_mmgsdi_cmd_rsp_cb,
                            (uint32) cmd_buf_p))
    {
      return QMI_SVC_RESPONSE_PENDING;
    }
    else
    {
      QM_MSG_HIGH("mmgsdi_session_write_transparent failed");
      errval = QMI_ERR_INTERNAL;
    }
  }
  QM_MSG_ERROR("Unable to change Forbidden networks settings");

#else
  QM_MSG_HIGH("Unable to process SET_FORB_NWKS request: non-GSM non-WCDMA target");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#else
  QM_MSG_HIGH("Unable to process SET_FORB_NWKS request: no MMGSDI support");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

send_result:
  retval = qmi_svc_put_result_tlv(&response, QMI_RESULT_FAILURE, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_nasi_set_forbidden_networks() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_TECH_PREFERENCE()

  DESCRIPTION
    This writes the specified technology preference to the device.
    This setting is global to the device and is not unique to each control point.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in     : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_technology_preference
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  cm_mode_pref_e_type   cm_mode_pref = CM_MODE_PREF_NONE;
  cm_pref_term_e_type   cm_pref_term = CM_PREF_TERM_NONE;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  struct nas_002A_req_s req_msg;

  sys_modem_as_id_e_type  asubs_id = SYS_MODEM_AS_ID_1;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }
#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#endif
  if ( errval == QMI_ERR_NONE )
  {
    memset(&req_msg, 0x00, sizeof(req_msg));

    errval = qmi_nas_002A_req_read( &req_msg, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_002A_req_check( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    uint16 tech_pref = req_msg.t01.technology_pref & QMI_NAS_TECH_PREF_BIT_ALL;
    uint16 qmi_mode_pref = QMI_NAS_TECH_PREF_AUTOMATIC;

    if ( tech_pref == QMI_NAS_TECH_PREF_AUTOMATIC )
    {
      cm_mode_pref = CM_MODE_PREF_AUTOMATIC;
    }
    else
    {
      if ( tech_pref & QMI_NAS_TECH_PREF_BIT_3GPP2 )
      {
        if ( !TARGET_SUPPORTS_CDMA ) { tech_pref &= ~QMI_NAS_TECH_PREF_BIT_DIGITAL; }
        if ( !TARGET_SUPPORTS_HDR  ) { tech_pref &= ~QMI_NAS_TECH_PREF_BIT_HDR;     }

        if ( tech_pref & QMI_NAS_TECH_PREF_BIT_DIGITAL ) { qmi_mode_pref |= QMI_NAS_MODE_PREF_BIT_CDMA; }
        if ( tech_pref & QMI_NAS_TECH_PREF_BIT_HDR )     { qmi_mode_pref |= QMI_NAS_MODE_PREF_BIT_HDR;  }

        if ( qmi_mode_pref == 0x0000 )
        {
          errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
        }
      }
      else if ( tech_pref & QMI_NAS_TECH_PREF_BIT_3GPP )
      {
        if ( !TARGET_SUPPORTS_GSM )   { tech_pref &= ~QMI_NAS_TECH_PREF_BIT_ANALOG;  }
        if ( !TARGET_SUPPORTS_WCDMA ) { tech_pref &= ~QMI_NAS_TECH_PREF_BIT_DIGITAL; }
        if ( !TARGET_SUPPORTS_LTE )   { tech_pref &= ~QMI_NAS_TECH_PREF_BIT_LTE;     }

        if ( tech_pref & QMI_NAS_TECH_PREF_BIT_ANALOG  ) { qmi_mode_pref |= QMI_NAS_MODE_PREF_BIT_GSM;  }
        if ( tech_pref & QMI_NAS_TECH_PREF_BIT_DIGITAL ) { qmi_mode_pref |= QMI_NAS_MODE_PREF_BIT_UMTS; }
        if ( tech_pref & QMI_NAS_TECH_PREF_BIT_LTE     ) { qmi_mode_pref |= QMI_NAS_MODE_PREF_BIT_LTE;  }

        if ( qmi_mode_pref == 0x0000 )
        {
          errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
        }
      }

      cm_mode_pref = qmi_nas_map_mode_pref_qmi_to_cm( qmi_mode_pref );

      if ( cm_mode_pref == CM_MODE_PREF_NONE )
      {
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
      }
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( req_msg.t01.duration == QMI_NAS_TECH_PREF_DURATION_PERMANENT )
    {
      cm_pref_term = CM_PREF_TERM_PERMANENT; /* Permanent mode change */
    }
    else if ( req_msg.t01.duration == QMI_NAS_TECH_PREF_DURATION_POWER_CYCLE )
    {
      cm_pref_term = CM_PREF_TERM_PWR_CYCLE; /* Until power cycle */
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    boolean ret_val = FALSE;

    if ( asubs_id == SYS_MODEM_AS_ID_1 )
    {
      ret_val = cm_ph_cmd_sys_sel_pref_with_lte( qmi_nas_cmph_cmd_cb,
                                                 cmd_buf_p,
                                                 qmi_nasi_global.cm_clnt_id,
                                                 cm_mode_pref,
                                                 cm_pref_term,
                                                 0,
                                                 CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                 CM_BAND_PREF_NO_CHANGE,
                                                 CM_BAND_PREF_NO_CHANGE,
                                                 CM_PRL_PREF_NO_CHANGE,
                                                 CM_ROAM_PREF_NO_CHANGE,
                                                 CM_HYBR_PREF_NO_CHANGE,
                                                 CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                 CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                                 NULL,
                                                 NULL );
    }
#ifdef FEATURE_DUAL_SIM
    else if ( asubs_id == SYS_MODEM_AS_ID_2 )
    {
      ret_val = cm_ph_cmd_sys_sel_pref_per_subs( qmi_nas_cmph_cmd_cb,
                                                 cmd_buf_p,
                                                 qmi_nasi_global.cm_clnt_id,
                                                 asubs_id,
                                                 cm_mode_pref,
                                                 cm_pref_term,
                                                 0,
                                                 CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                 CM_BAND_PREF_NO_CHANGE,
                                                 CM_PRL_PREF_NO_CHANGE,
                                                 CM_ROAM_PREF_NO_CHANGE,
                                                 CM_HYBR_PREF_NO_CHANGE,
                                                 CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                 CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                                 NULL );
    }
#endif

    if ( ret_val )
    {
      QM_MSG_HIGH("Response pending for CM event");
      return QMI_SVC_RESPONSE_PENDING;
       // will react to CM_PH_CMD_SYS_SEL_PREF later
    }
    else
    {
     //Unable to change sys sel pref
      errval = QMI_ERR_NO_EFFECT;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    struct nas_002A_rsp_s rsp_msg;

    memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_002A_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
} /* qmi_nasi_set_technology_preference() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_TECH_PREFERENCE ()

  DESCRIPTION
    Returns the current serving system registration state and radio
    technology information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_technology_preference
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_e_type      errval   = QMI_ERR_NONE;
  struct nas_002B_rsp_s rsp_msg;
  nv_item_type          nv_item;

  qmi_cm_ph_info_s_type      *p_ph_info = &qmi_nasi_global.cm_ph_info;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }
#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    p_ph_info = &qmi_nasi_global.cm_ph_info2;
  }
#endif
  if ( errval == QMI_ERR_NONE )
  {
    memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

    if ( p_ph_info->mode_pref == CM_MODE_PREF_AUTOMATIC ||
         p_ph_info->mode_pref == CM_MODE_PREF_DIGITAL_ONLY )
    {
      rsp_msg.t01.active_technology_pref = QMI_NAS_TECH_PREF_AUTOMATIC;
    }
    else
    {
      uint16 qmi_mode_pref;

      qmi_mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( p_ph_info->mode_pref );

      if ( qmi_mode_pref != QMI_NAS_MODE_PREF_NONE )
      {
        if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_CDMA ) { rsp_msg.t01.active_technology_pref |= QMI_NAS_TECH_PREF_BIT_DIGITAL | QMI_NAS_TECH_PREF_BIT_3GPP2; }
        if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_HDR  ) { rsp_msg.t01.active_technology_pref |= QMI_NAS_TECH_PREF_BIT_HDR     | QMI_NAS_TECH_PREF_BIT_3GPP2; }
        if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_GSM  ) { rsp_msg.t01.active_technology_pref |= QMI_NAS_TECH_PREF_BIT_ANALOG  | QMI_NAS_TECH_PREF_BIT_3GPP;  }
        if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_UMTS ) { rsp_msg.t01.active_technology_pref |= QMI_NAS_TECH_PREF_BIT_DIGITAL | QMI_NAS_TECH_PREF_BIT_3GPP;  }
        if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_LTE  ) { rsp_msg.t01.active_technology_pref |= QMI_NAS_TECH_PREF_BIT_LTE     | QMI_NAS_TECH_PREF_BIT_3GPP;  }

        if ( (rsp_msg.t01.active_technology_pref & (QMI_NAS_TECH_PREF_BIT_3GPP|QMI_NAS_TECH_PREF_BIT_3GPP2)) == (QMI_NAS_TECH_PREF_BIT_3GPP|QMI_NAS_TECH_PREF_BIT_3GPP2) )
        {
          QM_MSG_ERROR_1("multimode not supported for get_technology_preference %d", p_ph_info->mode_pref);
          errval = QMI_ERR_INTERNAL;
        }
      }
      else
      {
        QM_MSG_ERROR_1("no mode pref bit set %d", p_ph_info->mode_pref);
        errval = QMI_ERR_INTERNAL;
      }
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    rsp_msg.t01_valid = TRUE;

    switch ( p_ph_info->pref_term )
    {
      case CM_PREF_TERM_PERMANENT     : rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_PERMANENT;      break;
      case CM_PREF_TERM_PWR_CYCLE     : rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_POWER_CYCLE;    break;
      case CM_PREF_TERM_1_CALL        : rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_1_CALL;         break;
      case CM_PREF_TERM_1_CALL_OR_TIME: rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_1_CALL_OR_TIME; break;
      case CM_PREF_TERM_CM_1_CALL     : rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_CM_1_CALL;      break;
      case CM_PREF_TERM_CM_1_CALL_PLUS: rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_CM_1_CALL_PLUS; break;
      case CM_PREF_TERM_CM_MO_SMS     : rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_CM_MO_SMS;      break;
      default:
        QM_MSG_ERROR_1("Unexpected CM mode preference duration %d", p_ph_info->pref_term);
        errval            = QMI_ERR_INTERNAL;
        rsp_msg.t01_valid = FALSE;
        break;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( rsp_msg.t01.duration != QMI_NAS_TECH_PREF_DURATION_PERMANENT )
    {
      memset(&nv_item, 0, sizeof(nv_item));

      if ( qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item) == NV_DONE_S )
      {
        nv_item.pref_mode.nam = nv_item.curr_nam;
      }
      else
      {
        nv_item.pref_mode.nam = 0;
      }

      if ( qmi_mmode_get_nv_item(NV_PREF_MODE_I, &nv_item) == NV_DONE_S )
      {
        rsp_msg.t10_valid = TRUE;

        if ( nv_item.pref_mode.mode == NV_MODE_AUTOMATIC ||
             nv_item.pref_mode.mode == NV_MODE_DIGITAL_ONLY )
        {
          rsp_msg.t10.persistent_technology_pref = QMI_NAS_TECH_PREF_AUTOMATIC;
        }
        else
        {
          uint16 qmi_mode_pref;

          qmi_mode_pref = qmi_nas_map_mode_pref_nv_to_qmi( nv_item.pref_mode.mode );

          if ( qmi_mode_pref != QMI_NAS_MODE_PREF_NONE )
          {
            if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_CDMA ) { rsp_msg.t10.persistent_technology_pref |= QMI_NAS_TECH_PREF_BIT_DIGITAL | QMI_NAS_TECH_PREF_BIT_3GPP2; }
            if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_HDR  ) { rsp_msg.t10.persistent_technology_pref |= QMI_NAS_TECH_PREF_BIT_HDR     | QMI_NAS_TECH_PREF_BIT_3GPP2; }
            if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_GSM  ) { rsp_msg.t10.persistent_technology_pref |= QMI_NAS_TECH_PREF_BIT_ANALOG  | QMI_NAS_TECH_PREF_BIT_3GPP;  }
            if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_UMTS ) { rsp_msg.t10.persistent_technology_pref |= QMI_NAS_TECH_PREF_BIT_DIGITAL | QMI_NAS_TECH_PREF_BIT_3GPP;  }
            if ( qmi_mode_pref & QMI_NAS_MODE_PREF_BIT_LTE  ) { rsp_msg.t10.persistent_technology_pref |= QMI_NAS_TECH_PREF_BIT_LTE     | QMI_NAS_TECH_PREF_BIT_3GPP;  }

            if ( (rsp_msg.t10.persistent_technology_pref & (QMI_NAS_TECH_PREF_BIT_3GPP|QMI_NAS_TECH_PREF_BIT_3GPP2)) == (QMI_NAS_TECH_PREF_BIT_3GPP|QMI_NAS_TECH_PREF_BIT_3GPP2) )
            {
              QM_MSG_ERROR_1("multimode not supported for get_technology_preference nv %d", nv_item.pref_mode.mode);
              errval            = QMI_ERR_INTERNAL;
              rsp_msg.t10_valid = FALSE;
            }
          }
          else
          {
            QM_MSG_ERROR_1("no nv mode pref bit set %d", nv_item.pref_mode.mode);
            errval            = QMI_ERR_INTERNAL;
            rsp_msg.t10_valid = FALSE;
          }
        }
      }
      else
      {
        QM_MSG_ERROR("Could not read NV_PREF_MODE_I from NV for getting persistent tech pref");
      }

      if ( rsp_msg.t01_valid && rsp_msg.t10_valid &&
           rsp_msg.t01.active_technology_pref == rsp_msg.t10.persistent_technology_pref )
      {
        QM_MSG_HIGH_2("same active %d persistent %d mode pref", rsp_msg.t01.active_technology_pref, rsp_msg.t10.persistent_technology_pref);
        rsp_msg.t01.duration = QMI_NAS_TECH_PREF_DURATION_PERMANENT;
        rsp_msg.t10_valid    = FALSE;
      }
    }
  }

  if ( errval != QMI_ERR_NONE )
  {
    rsp_msg.t01_valid = FALSE;
    rsp_msg.t10_valid = FALSE;
  }

  rsp_msg.t02.result_code = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_002B_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
} /* qmi_nasi_get_technology_preference() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_ACCOLC ()

  DESCRIPTION
    Returns the Access Overload Class for C2K

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_accolc
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response = NULL;
  qmi_error_e_type   errval   = QMI_ERR_NONE;
  qmi_result_e_type  result;
  boolean            retval;

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  struct nas_002C_rsp_s  nas_002C_rsp;
  nv_stat_enum_type      nv_status;
  nv_item_type           nv_item;
  uint8                  curr_nam = 0; //default to first NAM
#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  if ( qmi_nasi_global.cm_ph_info.rtre_control == CM_RTRE_CONTROL_RUIM &&
       qmi_nasi_global.mmgsdi.operation_ready[MMGSDI_1X_PROV_PRI_SESSION] == FALSE )
  {
    errval = QMI_ERR_SIM_NOT_INITIALIZED;
  }

  if (errval == QMI_ERR_NONE)
  {
    memset(&nas_002C_rsp, 0, sizeof(nas_002C_rsp));

    /*-------------------------------------------------------------------------
      Build the response
    -------------------------------------------------------------------------*/
    nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
    if ((nv_status != NV_NOTACTIVE_S) && (nv_item.curr_nam < NV_MAX_NAMS))
    {
      curr_nam = nv_item.curr_nam;
    }

    /* Read accolc from NV and write it to response struct */
    nv_item.accolc.nam = curr_nam;
    nv_status = qmi_mmode_get_nv_item(NV_ACCOLC_I, &nv_item);
    if ( nv_status == NV_DONE_S )
    {
      nas_002C_rsp.t01_valid  = TRUE;
      nas_002C_rsp.t01.accolc = nv_item.accolc.ACCOLCpClass[NV_CDMA_MIN_INDEX];
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("Accolc NV item inactive");
      errval = QMI_ERR_NOT_PROVISIONED;
    }
    else
    {
      QM_MSG_ERROR("Could not read ACCOLC from NV for qmi_nasi_get_accolc");
      errval = QMI_ERR_INTERNAL;
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_002C_rsp_write(&nas_002C_rsp, &response);
  }

#else /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;

#endif  /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_nasi_get_accolc() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_ACCOLC()

  DESCRIPTION

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in     : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_accolc
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response = NULL;
  qmi_error_e_type   errval = QMI_ERR_NONE;
  qmi_result_e_type  result;
  boolean            retval;

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  nv_stat_enum_type        nv_status;
  nv_item_type       nv_item;
  uint8                    current_accolc = 0;
  uint8                    curr_nam = 0; //default to the first NAM
  qmi_svc_spc_result_e_type check_spc_result;


  struct nas_002D_req_s nas_002D_req;
#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  memset(&nas_002D_req, 0, sizeof(nas_002D_req));

  errval = qmi_nas_002D_req_read(&nas_002D_req, sdu_in);

  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_002D_req_check(&nas_002D_req);
  }

  if ( qmi_nasi_global.cm_ph_info.rtre_control != CM_RTRE_CONTROL_NV )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }

  if (errval == QMI_ERR_NONE)
  {
    check_spc_result = qmi_svc_check_spc((uint8 *)nas_002D_req.t01.spc, TRUE);

    if (check_spc_result == QMI_SVC_SPC_FAIL )
    {
      errval = QMI_ERR_AUTHENTICATION_FAILED;
    }

    if (check_spc_result == QMI_SVC_SPC_LOCKED )
    {
      errval = QMI_ERR_AUTHENTICATION_LOCK;
    }

    if (check_spc_result == QMI_SVC_SPC_ERR_INTERNAL)
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    /* Read current NAM */
    nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
    if((nv_status == NV_DONE_S) && (nv_item.curr_nam < NV_MAX_NAMS))
    {
      curr_nam = nv_item.curr_nam;
    }

    /* Read accolc from NV */
    nv_item.accolc.nam = curr_nam;
    nv_status = qmi_mmode_get_nv_item(NV_ACCOLC_I, &nv_item);
    if ( nv_status == NV_DONE_S )
    {
      current_accolc = nv_item.accolc.ACCOLCpClass[NV_CDMA_MIN_INDEX];
    }
    else
    {
      QM_MSG_ERROR("Could not read current ACCOLC from NV for qmi_nasi_set_accolc");
      errval = QMI_ERR_INTERNAL;
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    if (nas_002D_req.t01.accolc == current_accolc)
    {
      errval = QMI_ERR_NO_EFFECT;
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    /* Update ACCOLC as required */
    nv_item.accolc.nam = curr_nam;
    nv_item.accolc.ACCOLCpClass[NV_CDMA_MIN_INDEX] = nas_002D_req.t01.accolc;
    if ( NV_DONE_S != qmi_mmode_put_nv_item( NV_ACCOLC_I, &nv_item ) )
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR("Could not write ACCOLC to NV for qmi_nasi_set_accolc");
    }
  }

#else /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;

#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_set_accolc() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_SYSTEM_PREFERENCE ()

  DESCRIPTION
    Returns the System Preference for C2K

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_system_preference
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  nv_stat_enum_type     nv_status;
  uint8                 curr_nam;
  struct nas_002E_rsp_s rsp_msg;
  nv_item_type          nv_item;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

  if ( !TARGET_SUPPORTS_CDMA && !TARGET_SUPPORTS_HDR )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }

  if ( errval == QMI_ERR_NONE )
  {
    nv_status = qmi_mmode_get_nv_item( NV_CURR_NAM_I, &nv_item );

    if ( nv_status == NV_DONE_S && nv_item.curr_nam < NV_MAX_NAMS )
    {
      curr_nam = nv_item.curr_nam;
    }
    else
    {
      curr_nam = 0;
    }

    nv_item.prl_pref.nam = curr_nam;
    nv_status = qmi_mmode_get_nv_item( NV_PRL_PREF_I, &nv_item );

    if ( nv_status != NV_DONE_S )
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR("Could not read Sys Pref from NV for PRL pref");
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    rsp_msg.t01_valid = TRUE;

    switch ( nv_item.prl_pref.prl )
    {
      case CM_PRL_PREF_ANY:         rsp_msg.t01.sys_pref = QMI_NAS_SYS_PREF_AUTOMATIC; break;
      case CM_PRL_PREF_AVAIL_BC0_A: rsp_msg.t01.sys_pref = QMI_NAS_SYS_PREF_AUTO_A;    break;
      case CM_PRL_PREF_AVAIL_BC0_B: rsp_msg.t01.sys_pref = QMI_NAS_SYS_PREF_AUTO_B;    break;

      default:
        QM_MSG_HIGH_1("unexpected PRL PREF %d", nv_item.prl_pref.prl);
        rsp_msg.t01_valid = FALSE;
        errval            = QMI_ERR_INTERNAL;
        break;
    }
  }

  if ( errval != QMI_ERR_NONE )
  {
    rsp_msg.t01_valid = FALSE;
  }

  rsp_msg.t02.result_code = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_002E_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
} /* qmi_nasi_get_system_preference() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_DEVICE_CONFIG ()

  DESCRIPTION
    Returns the network device configuration

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_device_config
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type      *response  = NULL;
  qmi_error_e_type   errval     = QMI_ERR_NONE;
  nas_get_device_config_resp_msg_v01 *rsp_msg = NULL;
  enum qmi_nas_subs_e  as_id;


#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  nv_item_type       nv_item;
  nv_stat_enum_type       nv_status;
  uint8                   curr_nam = 0; //default to first NAM

#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  as_id = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
  if( (as_id >= QMI_NAS_SUBS_MAX) || (as_id <= QMI_NAS_SUBS_NONE) )
  {
    QM_MSG_ERROR("qmi_nasi_get_device_config(): Received invalid as_id from client state pointer.");
    return response;
  }

  rsp_msg = (nas_get_device_config_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_device_config_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  if( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    return NULL;
  }
  memset(rsp_msg, 0, sizeof(nas_get_device_config_resp_msg_v01));

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  /*-------------------------------------------------------------------------
    Query all device config items
  -------------------------------------------------------------------------*/
  /* Read Slot Cycle Index from NV */
  memset(&nv_item, 0, sizeof(nv_item));
  nv_status = qmi_mmode_get_nv_item(NV_SLOT_CYCLE_INDEX_I, &nv_item);
  if (nv_status == NV_DONE_S)
  {
    rsp_msg->sci    = nv_item.slot_cycle_index;
    rsp_msg->sci_valid  = TRUE;
  }
  else if (nv_status == NV_NOTACTIVE_S)
  {
    QM_MSG_ERROR("Slot index NV item not active");
  }
  else
  {
    //Error reading slot index NV item
    errval = QMI_ERR_INTERNAL;
  }

  if (errval == QMI_ERR_NONE)
  {
    /* Read Station Class Mark from NV */
    memset(&nv_item, 0, sizeof(nv_item));
    nv_status = qmi_mmode_get_nv_item(NV_SCM_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->scm   = nv_item.scm;
      rsp_msg->scm_valid= TRUE;
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("Station Class Mark NV item not active");
    }
    else
    {
      //Error reading Station Class Mark NV item
      errval = QMI_ERR_INTERNAL;
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    memset(&nv_item, 0, sizeof(nv_item));
    nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
    if (NV_DONE_S == nv_status)
    {
      curr_nam = nv_item.curr_nam;
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("Current NAM NV item not active. Using default.");
    }
    else
    {
      QM_MSG_ERROR("Error reading NAM NV item");
    }
  }

  /* Read registration params from NV */
  if (errval == QMI_ERR_NONE)
  {
    /* Read registration param: Registered Home SID */
    nv_item.mob_term_home.nam = curr_nam;
    nv_status = qmi_mmode_get_nv_item(NV_MOB_TERM_HOME_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->registration_parameters.reg_home_sid = nv_item.mob_term_home.enabled[NV_CDMA_MIN_INDEX];
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("Reg Home SID NV item not active");
    }
    else
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR("Error reading Reg Home SID NV item");
    }
  }

  if (errval == QMI_ERR_NONE && nv_status == NV_DONE_S)
  {
    /* Read registration param: Registered Foreign SID */
    nv_status = qmi_mmode_get_nv_item(NV_MOB_TERM_FOR_SID_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->registration_parameters.reg_foreign_sid = nv_item.mob_term_for_sid.enabled[NV_CDMA_MIN_INDEX];
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("Reg For SID NV item not active");
    }
    else
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR("Error reading Reg For SID NV item");
    }
  }

  if (errval == QMI_ERR_NONE && nv_status == NV_DONE_S)
  {
    /* Read registration param: Registered Foreign NID */
    nv_status = qmi_mmode_get_nv_item(NV_MOB_TERM_FOR_NID_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      /* Set valid to TRUE because this is the last NV item to read
       * for registration parameters                                 */
      rsp_msg->registration_parameters_valid           = TRUE;
      rsp_msg->registration_parameters.reg_foreign_nid = nv_item.mob_term_for_nid.enabled[NV_CDMA_MIN_INDEX];
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("Reg For NID NV item not active");
    }
    else
    {
      QM_MSG_ERROR("Error reading Reg For NID NV item");
      errval = QMI_ERR_INTERNAL;
    }
  }

  /* Read HDR Force Rev0 from NV */
  if (errval == QMI_ERR_NONE)
  {
    memset(&nv_item, 0, sizeof(nv_item));
    nv_status = qmi_mmode_get_nv_item(NV_HDRSCP_FORCE_REL0_CONFIG_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->force_rev0_valid      = TRUE;
      rsp_msg->force_rev0 = nv_item.hdrscp_force_rel0_config;
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("HDR Force Rev0 NV item not active");
    }
    else
    {
      QM_MSG_ERROR("Error reading HDR Force Rev0 NV item");
      errval = QMI_ERR_INTERNAL;
    }
  }

  /* Read HDR SCP Custom Config from NV */
  if (errval == (qmi_error_e_type)QMI_ERR_NONE)
  {
    memset(&nv_item, 0, sizeof(nv_item));
    nv_status = qmi_mmode_get_nv_item(NV_HDRSCP_SUBTYPE_CUSTOM_CONFIG_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->hdr_scp_config_valid            = TRUE;
      rsp_msg->hdr_scp_config.state            = (uint8) nv_item.hdrscp_subtype_custom_config.custom_config_is_active;
      rsp_msg->hdr_scp_config.protocol_mask    = (uint32) nv_item.hdrscp_subtype_custom_config.prot_subtype_mask;
      rsp_msg->hdr_scp_config.broadcast_mask   = (uint32) nv_item.hdrscp_subtype_custom_config.bcmcs_subtype_mask;
      rsp_msg->hdr_scp_config.application_mask = (uint32) nv_item.hdrscp_subtype_custom_config.app_subtype_mask;
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("HDR SCP Cust Config NV item not active");
    }
    else
    {
      QM_MSG_ERROR("Error reading HDR SCP Cust Config NV item");
      errval = QMI_ERR_INTERNAL;
    }
  }

  /* Read Roam Pref from NV */
  if (errval == QMI_ERR_NONE)
  {
    nv_item.roam_pref.nam = curr_nam;
    nv_status = qmi_mmode_get_nv_item_ext(NV_ROAM_PREF_I, &nv_item,(uint16)as_id);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->roam_pref_valid     = TRUE;
      switch (nv_item.roam_pref.roam)
      {
        case CM_ROAM_PREF_ANY:
          rsp_msg->roam_pref= NAS_ROAM_CONFIG_PREF_AUTO_V01;
          break;

        case CM_ROAM_PREF_HOME:
          rsp_msg->roam_pref = NAS_ROAM_CONFIG_PREF_HOME_ONLY_V01;
          break;

        case CM_ROAM_PREF_ROAM_ONLY:
          rsp_msg->roam_pref = NAS_ROAM_CONFIG_PREF_ROAM_ONLY_V01;
          break;

        case CM_ROAM_PREF_AFFIL:
          rsp_msg->roam_pref = NAS_ROAM_CONFIG_PREF_HOME_AND_AFFILIATE_V01;
          break;

        default:
          QM_MSG_HIGH_1("Invalid roam pref %d", nv_item.roam_pref.roam);
          errval = QMI_ERR_INTERNAL;
      }
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_ERROR("Roam Pref NV item not set");
    }
    else
    {
      QM_MSG_ERROR("Error reading Roam Pref NV item");
      errval = QMI_ERR_INTERNAL;
    }
  }

  /* Read HDR Force AT Config from NV */
  if (errval == QMI_ERR_NONE)
  {
    memset(&nv_item, 0, sizeof(nv_item));
    nv_status = qmi_mmode_get_nv_item(NV_HDRSCP_FORCE_AT_CONFIG_I, &nv_item);
    if (nv_status == NV_DONE_S)
    {
      rsp_msg->force_hdrscp_config_at_valid                  = TRUE;
      rsp_msg->force_hdrscp_config_at = nv_item.hdrscp_force_at_config; //QMI values same as NV values
    }
    else if (nv_status == NV_NOTACTIVE_S)
    {
      QM_MSG_HIGH("NV_HDRSCP_FORCE_AT_CONFIG_I not active");
    }
    else
    {
      QM_MSG_ERROR("Error reading NV_HDRSCP_FORCE_AT_CONFIG_I NV item");
      errval = QMI_ERR_INTERNAL;
    }
  }

#else /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;

#endif  /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  rsp_msg->resp.error  = (qmi_error_type_v01)errval;
  rsp_msg->resp.result = ( errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 ;

  qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                (void *) rsp_msg,
                                (uint32_t) sizeof( nas_get_device_config_resp_msg_v01 ),
                                &response
                              );
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_device_config() */


/*===========================================================================
  FUNCTION QMI_NASI_SET_DEVICE_CONFIG()

  DESCRIPTION
    Sets the network device configuration

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in     : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_device_config
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type           *response = NULL;
  qmi_error_e_type        errval    = QMI_ERR_NONE;
  enum qmi_nas_subs_e  as_id;

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  nv_stat_enum_type       nv_status;
  nv_item_type            nv_item;
#endif

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  nas_set_device_config_req_msg_v01 *req_msg = NULL;
  uint8                    curr_nam  = 0; //default to first NAM
  uint8                    roam_pref = (uint8) CM_ROAM_PREF_MAX;
  qmi_svc_spc_result_e_type check_spc_result;

#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  nas_set_device_config_resp_msg_v01  rsp_msg;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  as_id = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
  if( (as_id >= QMI_NAS_SUBS_MAX) || (as_id <= QMI_NAS_SUBS_NONE) )
  {
    QM_MSG_ERROR("qmi_nasi_set_device_config(): Received invalid as_id from client state pointer.");
    return response;
  }

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  if (errval == QMI_ERR_NONE)
  {
     req_msg = (nas_set_device_config_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_device_config_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
     if ( req_msg == NULL )
     {
       qmi_voice_mem_error();
       errval = QMI_ERR_NO_MEMORY;
       ASSERT(0); 
     }
  }  
  if (errval == QMI_ERR_NONE)
  {
    memset(req_msg, 0, sizeof(nas_set_device_config_req_msg_v01));
    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_device_config_req_msg_v01)
                                         );
  }
  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_0030_req_check(req_msg);
  }

  /*-----------------------------------------------------------------------
    Check the supplied SPC is valid (only if given a TLV that requires an SPC)
  -----------------------------------------------------------------------*/
  if (errval == QMI_ERR_NONE)
  {
    if ( req_msg->force_hdr_rev0_valid|| req_msg->hdr_scp_config_valid)
    {
      if ( req_msg->spc_valid)
      {
        check_spc_result = qmi_svc_check_spc((uint8*)req_msg->spc, TRUE);

        if (check_spc_result == QMI_SVC_SPC_FAIL)
        {
          errval = QMI_ERR_AUTHENTICATION_FAILED;
        }
        else if (check_spc_result == QMI_SVC_SPC_LOCKED)
        {
          errval = QMI_ERR_AUTHENTICATION_LOCK;
        }
        else if (check_spc_result == QMI_SVC_SPC_ERR_INTERNAL)
        {
          errval = QMI_ERR_INTERNAL;
        }
      }
      else
      {
        errval = QMI_ERR_MISSING_ARG;
      }
    }
  }

  if (errval == QMI_ERR_NONE)
  {
    if (req_msg->roam_pref_valid)
    {
      //set roam_pref to CM values
      switch (req_msg->roam_pref)
      {
        case NAS_ROAM_CONFIG_PREF_AUTO_V01:                          roam_pref = CM_ROAM_PREF_ANY;       break;
        case NAS_ROAM_CONFIG_PREF_HOME_ONLY_V01:                roam_pref = CM_ROAM_PREF_HOME;      break;
        case NAS_ROAM_CONFIG_PREF_ROAM_ONLY_V01:                roam_pref = CM_ROAM_PREF_ROAM_ONLY; break;
        case NAS_ROAM_CONFIG_PREF_HOME_AND_AFFILIATE_V01: roam_pref = CM_ROAM_PREF_AFFIL;     break;
        default:
          //should never occur
          QM_MSG_ERROR("Invalid roam pref, check function failed");
          errval = QMI_ERR_INTERNAL;
      }

      if (errval == QMI_ERR_NONE)
      {
        //read current NAM from NV
        nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
        if ((nv_status == NV_DONE_S) && (nv_item.curr_nam < NV_MAX_NAMS))
        {
          curr_nam = nv_item.curr_nam;
        }

        nv_item.roam_pref.nam  = curr_nam;
        nv_item.roam_pref.roam = roam_pref;
        if (NV_DONE_S != qmi_mmode_put_nv_item_ext(NV_ROAM_PREF_I, &nv_item,(uint16)as_id))
        {
          errval = QMI_ERR_INTERNAL;
          QM_MSG_ERROR("Could not write NV");
        }
      }
    }
  }

#else /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;

#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */

  if( cmd_buf_p != NULL )
  {
    rsp_msg.resp.error  = (qmi_error_type_v01) errval;
    rsp_msg.resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) &rsp_msg,
                                  (uint32_t) sizeof(nas_set_device_config_resp_msg_v01),
                                  &response
                                );
  }

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
#endif

  return response;
} /* qmi_nasi_set_device_config() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_RF_BAND_INFO()

  DESCRIPTION
    Returns the current active band and channel information, along with
    the radio interface type.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_rf_band_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                 *response = NULL;
  qmi_error_e_type              errval = QMI_ERR_NONE;
  qmi_result_e_type             result;
  boolean                       retval;

  struct nas_0031_rsp_s                rsp_msg;

  int                           i = 0, stack_index = 0;
  cm_mm_msim_ss_info_s_type *p_ss_info = NULL;
  uint8 asubs_max = sizeof(qmi_nasi_global.cm_msim_ss_info)/sizeof(qmi_nasi_global.cm_msim_ss_info[0]);
  enum qmi_nas_subs_e bound_subs;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
  if( 
      (bound_subs > QMI_NAS_SUBS_NONE) && 
      (bound_subs < asubs_max) 
    )
  {
    p_ss_info = &qmi_nasi_global.cm_msim_ss_info[bound_subs];
  }

  if(!p_ss_info)
  {
    QM_MSG_ERROR("p_ss_info is NULL");
    errval = QMI_ERR_INTERNAL;
  }

  memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

  if ( errval == QMI_ERR_NONE )
  {
    if ( !qmi_nasi_global.rcvd_ss_info )
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    for( stack_index = 0; stack_index < p_ss_info->number_of_stacks && stack_index < STACK_INDEX_MAX && i < NAS_0031_RSP_MAX_RADIO_IFS; stack_index++ )
    {
      if ( qmi_nas_sys_mode_2_radio_if( p_ss_info, stack_index, FALSE ) != QMI_NAS_RADIO_IF_NONE )
    {
        rsp_msg.t01.instances[i].radio_if       = qmi_nas_sys_mode_2_radio_if( p_ss_info, stack_index, FALSE );
        rsp_msg.t01.instances[i].active_band    = qmi_nas_cm_bc_2_qmi_bc( p_ss_info->stack_info[stack_index].active_band);

        rsp_msg.t11.instances[i].radio_if       = qmi_nas_sys_mode_2_radio_if( p_ss_info, stack_index, FALSE );
        rsp_msg.t11.instances[i].active_band    = qmi_nas_cm_bc_2_qmi_bc( p_ss_info->stack_info[stack_index].active_band);

      switch ( rsp_msg.t01.instances[i].radio_if )
      {
        case QMI_NAS_RADIO_IF_CDMA20001X:
        case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
            rsp_msg.t01.instances[i].active_channel = p_ss_info->stack_info[stack_index].active_channel;
            rsp_msg.t11.instances[i].active_channel = p_ss_info->stack_info[stack_index].active_channel;
          break;

        case QMI_NAS_RADIO_IF_GSM:
#ifdef FEATURE_CM_NEW_RR_CELL_INFO_INTERFACE
            rsp_msg.t01.instances[i].active_channel = p_ss_info->stack_info[stack_index].cell_info.arfcn;
            rsp_msg.t11.instances[i].active_channel = p_ss_info->stack_info[stack_index].cell_info.arfcn;
#else
          rsp_msg.t01.instances[i].active_channel = 0;
            rsp_msg.t11.instances[i].active_channel = 0;
#endif
          break;

        case QMI_NAS_RADIO_IF_UMTS:
        case QMI_NAS_RADIO_IF_TDSCDMA:
            rsp_msg.t01.instances[i].active_channel = p_ss_info->stack_info[stack_index].cell_info.uarfcn_dl;
            rsp_msg.t11.instances[i].active_channel = p_ss_info->stack_info[stack_index].cell_info.uarfcn_dl;
          break;

        case QMI_NAS_RADIO_IF_LTE:
            rsp_msg.t01.instances[i].active_channel = (uint16)p_ss_info->stack_info[stack_index].cell_info.earfcn_dl;
            rsp_msg.t11.instances[i].active_channel = p_ss_info->stack_info[stack_index].cell_info.earfcn_dl;
          break;

        default:
          break;
      }
      i++;
    }
    }

    if ( i > 0 )
    {
      rsp_msg.t01.num_instances = i;
      rsp_msg.t11.num_instances = i;
      rsp_msg.t01_valid = TRUE;
      rsp_msg.t11_valid = TRUE;

      errval = qmi_nas_0031_rsp_write(&rsp_msg, &response);
    }
    else
    {
      errval = QMI_ERR_INFO_UNAVAILABLE;
    }
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_get_rf_band_info() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_AN_AAA_STATUS()

  DESCRIPTION
    Returns the latest AN AAA status of 1xEV-DO.
    - AN : Access Network
    - AAA : Authentication, Authorization and Accounting

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_an_aaa_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type      *response = NULL;
  qmi_error_e_type   errval    = QMI_ERR_NONE;
  qmi_result_e_type  result;
  boolean            retval;

#ifdef FEATURE_HDR
  struct nas_0032_rsp_s   rsp_msg;
  int16              dss_errno=0;
  ds_sys_conf_3gpp2_an_auth_status_enum_type sys_status_type = DS_SYS_CONF_3GPP2_AN_AUTH_STATUS_NOT_AUTHENTICAED;
#endif /* FEATURE_HDR */

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

#ifdef FEATURE_HDR
  memset(&rsp_msg, 0, sizeof(rsp_msg));

  /*-------------------------------------------------------------------------
    Build the response from back to front
  -------------------------------------------------------------------------*/
  /* Get the last AN AAA status */
  if ( !ds_sys_conf_get( DS_SYS_TECH_3GPP2,
                         DS_SYS_CONF_3GPP2_AN_AUTH_STATUS,
                         &sys_status_type,
                         &dss_errno))
  {
    /* Translate aaa status info */
    switch (sys_status_type)
    {
      case DS_SYS_CONF_3GPP2_AN_AUTH_STATUS_NOT_AUTHENTICAED :    /* Not Authenticated */
        rsp_msg.t01.an_aaa_status = NAS_0032_AN_AAA_STATUS_NOT_AUTH;
        rsp_msg.t01_valid         = TRUE;
        errval = qmi_nas_0032_rsp_write(&rsp_msg, &response);
        break;

      case DS_SYS_CONF_3GPP2_AN_AUTH_STATUS_PASS:   /* Authenticated successfully */
        rsp_msg.t01.an_aaa_status = NAS_0032_AN_AAA_STATUS_SUCCESS;
        rsp_msg.t01_valid         = TRUE;
        errval = qmi_nas_0032_rsp_write(&rsp_msg, &response);
        break;

      case DS_SYS_CONF_3GPP2_AN_AUTH_STATUS_FAILED: /* Failed authentication */
        rsp_msg.t01.an_aaa_status = NAS_0032_AN_AAA_STATUS_FAILED;
    rsp_msg.t01_valid         = TRUE;
    errval = qmi_nas_0032_rsp_write(&rsp_msg, &response);
        break;

      default:
        QM_MSG_ERROR_1("qmi_nasi_get_an_aaa_status: received invalid aaa status = %d ", (int)sys_status_type);
        errval = QMI_ERR_INFO_UNAVAILABLE;
    }
  }
  else
  {
    errval = QMI_ERR_INFO_UNAVAILABLE;
    QM_MSG_ERROR_1("qmi_nasi_get_an_aaa_status: Cannot get configuration %d", dss_errno);
  }

#else /* FEATURE_HDR */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
#endif  /* FEATURE_HDR */

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* qmi_nasi_get_an_aaa_status() */

/*===========================================================================
  FUNCTION QMI_NAS_MAP_UE_USAGE_QMI_TO_CM()

  DESCRIPTION
    This functions maps QMI_NAS ue_usage preference enum to CM defined enum
        
  PARAMETERS
    ue_usage : QMI_NAS ue_usage enum type

  RETURN VALUE
    CM sys_ue_usage_setting_e_type ue_usage enum
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static sys_ue_usage_setting_e_type qmi_nas_map_ue_usage_qmi_to_cm( uint32 qmi_ue_usage )
{
  sys_ue_usage_setting_e_type cm_ue_usage = SYS_UE_USAGE_SETTING_NO_CHANGE;

  switch(qmi_ue_usage)
  {
    case NAS_USAGE_VOICE_CENTRIC_V01:
      cm_ue_usage = SYS_UE_USAGE_SETTING_VOICE_CENTRIC;
      break;
    case NAS_USAGE_DATA_CENTRIC_V01:
      cm_ue_usage = SYS_UE_USAGE_SETTING_DATA_CENTRIC;
      break;
    default:
      QM_MSG_ERROR_1("wrong ue_usage passed in qmi_nas_set_system_selection_preference() request %d", qmi_ue_usage);
      break;
  }

  return cm_ue_usage;
}

/*===========================================================================
  FUNCTION QMI_NAS_MAP_LTE_BW_QMI_BW()

  DESCRIPTION
    This functions maps LTE Bandwidth to QMI_NAS enum 
        
  PARAMETERS
    dl_bandwidth : LTE lte_bandwidth_e enum type

  RETURN VALUE
    QMI_NAS nas_lte_cphy_ca_bandwidth_enum_v01  enum
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static nas_lte_cphy_ca_bandwidth_enum_v01 qmi_nas_map_lte_bw_to_qmi_bw( lte_bandwidth_e dl_bandwidth )
{
  nas_lte_cphy_ca_bandwidth_enum_v01 qmi_bw = 0xFF;

  switch(dl_bandwidth)
  {
    case LTE_BW_NRB_6:
      qmi_bw = NAS_LTE_CPHY_CA_BW_NRB_6_V01;
      break;
    case LTE_BW_NRB_15:
      qmi_bw = NAS_LTE_CPHY_CA_BW_NRB_15_V01;
      break;
    case LTE_BW_NRB_25:
      qmi_bw = NAS_LTE_CPHY_CA_BW_NRB_25_V01;
      break;
    case LTE_BW_NRB_50:
      qmi_bw = NAS_LTE_CPHY_CA_BW_NRB_50_V01;
      break;
    case LTE_BW_NRB_75:
      qmi_bw = NAS_LTE_CPHY_CA_BW_NRB_75_V01;
      break;
    case LTE_BW_NRB_100:
      qmi_bw = NAS_LTE_CPHY_CA_BW_NRB_100_V01;
      break;

    default:
      QM_MSG_ERROR_1("Invalid dl_bandwidth passed in qmi_nas_map_lte_bw_to_qmi_bw() request %d", (int)dl_bandwidth);
      break;
  }

  return qmi_bw;
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_LTE_CPHY_CA_IND()

  DESCRIPTION
    Generates and sends the LTE physical carrier aggregation(CA) status.

  PARAMETERS
    None

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nas_generate_lte_cphy_ca_ind(lte_cphy_ca_event_ind_s *cphy_ca)
{

  nas_lte_cphy_ca_ind_msg_v01        *ind_msg;
  dsm_item_type               *ind;

  int                          client=0;
  qmi_nasi_client_state_type  *cl_sp;
  enum qmi_nas_subs_e          bound_subs;

  if (cphy_ca == NULL)
  {
    QM_MSG_HIGH("The information received from LTE RRC is NULL");
    return;
  }

  bound_subs = (enum qmi_nas_subs_e)(INST_ID_TO_SYS_AS_ID(cphy_ca->msgr_hdr.inst_id));
  
  QM_MSG_HIGH_2("Subs INfo: Received from LTE RRC: %d What we store: %d", cphy_ca->msgr_hdr.inst_id, bound_subs);

  ind_msg = (nas_lte_cphy_ca_ind_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_lte_cphy_ca_ind_msg_v01 ) );

  if ( ind_msg != NULL )
  {
    memset( ind_msg, 0x00, sizeof( nas_lte_cphy_ca_ind_msg_v01 ) );

    QM_MSG_MED_6("qmi_nas_generate_lte_cphy_ca_ind() Scell PCI: %d FREQ: %d BANDWIDTH: %d,Pcell PCI: %d FREQ: %d BANDWIDTH: %d", (uint16_t)cphy_ca->scell_info.pci, (uint16_t)cphy_ca->scell_info.freq, (int)cphy_ca->scell_info.dl_bandwidth,
                         (uint16_t)cphy_ca->pcell_info.pci, (uint16_t)cphy_ca->pcell_info.freq, (int)cphy_ca->pcell_info.dl_bandwidth);

    QM_MSG_MED_3("qmi_nas_generate_lte_cphy_ca_ind() Scell BAND: %d STATUS: %d, Pcell BAND: %d", (int)cphy_ca->scell_info.sys_band, (int)cphy_ca->scell_info.scell_state,(int)cphy_ca->pcell_info.sys_band);

    //Old TLVs
    ind_msg->cphy_ca.pci = (uint16_t)cphy_ca->scell_info.pci;
    ind_msg->cphy_ca.freq = (uint16_t)cphy_ca->scell_info.freq;
    ind_msg->cphy_ca.scell_state = (nas_scell_state_enum_v01)cphy_ca->scell_info.scell_state;

    ind_msg->cphy_ca_dl_bandwidth_valid = TRUE;
    ind_msg->cphy_ca_dl_bandwidth = (nas_lte_cphy_ca_bandwidth_enum_v01)qmi_nas_map_lte_bw_to_qmi_bw(cphy_ca->scell_info.dl_bandwidth);

    //New TLVs
    ind_msg->pcell_info_valid = TRUE;
    ind_msg->pcell_info.pci = (uint16_t)cphy_ca->pcell_info.pci;
    ind_msg->pcell_info.freq = (uint16_t)cphy_ca->pcell_info.freq;
    ind_msg->pcell_info.cphy_ca_dl_bandwidth = (nas_lte_cphy_ca_bandwidth_enum_v01)qmi_nas_map_lte_bw_to_qmi_bw(cphy_ca->pcell_info.dl_bandwidth);
    ind_msg->pcell_info.band = (nas_active_band_enum_v01)qmi_nas_qmi_sys_lte_bc_2_lte_bc(cphy_ca->pcell_info.sys_band);

    ind_msg->scell_info_valid = TRUE;
    ind_msg->scell_info.pci = (uint16_t)cphy_ca->scell_info.pci;
    ind_msg->scell_info.freq = (uint16_t)cphy_ca->scell_info.freq;
    ind_msg->scell_info.cphy_ca_dl_bandwidth = (nas_lte_cphy_ca_bandwidth_enum_v01)qmi_nas_map_lte_bw_to_qmi_bw(cphy_ca->scell_info.dl_bandwidth);
    ind_msg->scell_info.band = (nas_active_band_enum_v01)qmi_nas_qmi_sys_lte_bc_2_lte_bc(cphy_ca->scell_info.sys_band);
    ind_msg->scell_info.scell_state = (nas_scell_state_enum_v01)cphy_ca->scell_info.scell_state;

    for ( client=0; client<NASI_MAX_CLIDS; client++ )
    {
      cl_sp = qmi_nas_state.client[client];

      if ( cl_sp && cl_sp->common.clid != NASI_CLID_UNUSED && cl_sp->report_status.report_lte_cphy_ca_status && cl_sp->report_status.bound_subs == bound_subs )
      {
        ind = NULL;

        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                  QMI_IDL_INDICATION,
                                                  QMI_NAS_LTE_CPHY_CA_IND_V01,
                                                  (void *) ind_msg,
                                                  (uint32_t) sizeof( nas_lte_cphy_ca_ind_msg_v01 ),
                                                  &ind
                                                )
          )
        {
          qmi_nasi_send_ind( cl_sp, (uint16)QMI_NAS_LTE_CPHY_CA_IND_V01, ind );
        }
        else
        {
           QM_MSG_ERROR_1("failed to send LTE_CPHY_CA_IND ind, client %d", client);
        }
      }
    }

  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( ind_msg != NULL ) { QMI_NAS_MEM_FREE( (void *) ind_msg ); }
}

/*===========================================================================
  FUNCTION QMI_NASI_SET_SYS_SEL_PREF()

  DESCRIPTION
    Sets the different System Selection Preference of the device.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_set_sys_sel_pref(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type    *response = NULL;
  boolean           retval = FALSE;
  qmi_error_type_v01                errval                 = QMI_ERR_NONE_V01;

  nas_set_system_selection_preference_req_msg_v01  * req_msg;
  nas_set_system_selection_preference_resp_msg_v01 * rsp_msg;

  cm_cmd_user_pref_update_type  sys_pref_info;
  qmi_cm_ph_info_s_type   *p_ph_info     = &qmi_nasi_global.cm_ph_info;
  sys_plmn_id_s_type                plmn;
  boolean                         mnc_includes_pcs_digit = TRUE;
  uint32_t                          i;
  cm_rat_acq_order_pref_s_type rat_acq_order;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_MALFORMED_MSG_V01;
  }

  req_msg = (nas_set_system_selection_preference_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_system_selection_preference_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_system_selection_preference_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_system_selection_preference_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    QM_MSG_ERROR_2("Not enough memory to allocate for QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE request. %p %p", req_msg, rsp_msg);
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( !cm_user_pref_init( &sys_pref_info ) )
    {
      QM_MSG_ERROR("Failed to initalize user pref structure");
      errval = QMI_ERR_MALFORMED_MSG_V01;
    }
    else
    {
      // QMI_NAS has different default value for pref_term than CM
      sys_pref_info.pref_term = CM_PREF_TERM_PERMANENT;
    }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_system_selection_preference_req_msg_v01) );

#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      sys_pref_info.asubs_id  = SYS_MODEM_AS_ID_2;
      p_ph_info = &qmi_nasi_global.cm_ph_info2;
    }
    else 
#endif
#ifdef FEATURE_TRIPLE_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
      sys_pref_info.asubs_id  = SYS_MODEM_AS_ID_3;
      p_ph_info = &qmi_nasi_global.cm_ph_info3;
    }
    else
#endif
    {
      sys_pref_info.asubs_id = SYS_MODEM_AS_ID_1;
    }

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_system_selection_preference_req_msg_v01)
                                         );
  }

  // check for error in REQ message
  if (errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_nas_0033_req_check( req_msg );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    if ( req_msg->mode_pref_valid )
    {
      mode_pref_mask_type_v01 tmp_mp = req_msg->mode_pref;

      if ( ! TARGET_SUPPORTS_CDMA  ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_CDMA2000_1X_V01;
      if ( ! TARGET_SUPPORTS_HDR   ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_CDMA2000_HRPD_V01;
      if ( ! TARGET_SUPPORTS_GSM   ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_GSM_V01;
      if ( ! TARGET_SUPPORTS_WCDMA ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_UMTS_V01;
      if ( ! TARGET_SUPPORTS_LTE   ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_LTE_V01;
      if ( ! TARGET_SUPPORTS_TDS   ) tmp_mp &= (mode_pref_mask_type_v01) ~QMI_NAS_RAT_MODE_PREF_TDSCDMA_V01;

      if ( tmp_mp == 0x0000 )
      {
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
      }
    }
  }

  // fill in mode_pref, band_pref, prl_pref and roam_pref based on the REQ
  if (errval == QMI_ERR_NONE_V01)
  {
    // Handle emergency mode settings
    // Note: qmi_nas_0033_req_check will set all other TLVs to invalid if
    //       t10 is valid, and emergency mode is set to ON
    if ( req_msg->emergency_mode_valid )
    {
      if ( req_msg->emergency_mode == NAS_0033_EMERGENCY_MODE_ON )
      {
        sys_pref_info.mode_pref = CM_MODE_PREF_EMERGENCY;
        sys_pref_info.pref_term = CM_PREF_TERM_PWR_CYCLE;
      }
      else if ( p_ph_info->mode_pref == CM_MODE_PREF_EMERGENCY )
        {
        sys_pref_info.mode_pref = CM_MODE_PREF_PERSISTENT;
      }
    }

    // Handle mode pref settings
    // When emergency mode is set to OFF, and t11 is valid
    // the value in t11 will take precedence over persistent
    // settings
    if ( req_msg->mode_pref_valid )
    {
      sys_pref_info.mode_pref = qmi_nas_map_mode_pref_qmi_to_cm( req_msg->mode_pref );

      if (sys_pref_info.mode_pref == CM_MODE_PREF_NONE)
      {
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
      }
    }

    // handle Band preference
    if ( req_msg->band_pref_valid )
      sys_pref_info.band_pref = (cm_band_pref_e_type) req_msg->band_pref;

    // handle CDMA PRL preference
    if ( req_msg->prl_pref_valid )
      sys_pref_info.prl_pref  = (cm_prl_pref_e_type) req_msg->prl_pref;

    // handle Roam preference
    if ( req_msg->roam_pref_valid )
      sys_pref_info.roam_pref = (cm_roam_pref_e_type) req_msg->roam_pref;

    // handle LTE band preference
    if ( req_msg->lte_band_pref_valid )// set only the first 64 bits as we are using the legacy TLV
    {
      memset(&sys_pref_info.lte_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
      memscpy(&sys_pref_info.lte_band_pref, sizeof(uint64), &req_msg->lte_band_pref, sizeof(uint64));
    }
    else if(req_msg->lte_band_pref_ext_valid)// set the whole 256 bitmask as we are using the new TLV
    {
      memset(&sys_pref_info.lte_band_pref, 0, sizeof(sys_lte_band_mask_e_type));
      memscpy(&sys_pref_info.lte_band_pref, sizeof(sys_lte_band_mask_e_type), &req_msg->lte_band_pref_ext, sizeof(sys_lte_band_mask_e_type));
    }

    if ( req_msg->net_sel_pref_valid && req_msg->srv_reg_restriction_valid )
    {
      switch ( req_msg->srv_reg_restriction )
      {
        case NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01:
          sys_pref_info.network_sel_mode_pref = (cm_network_sel_mode_pref_e_type) req_msg->net_sel_pref.net_sel_pref;
          break;

        case NAS_SRV_REG_RESTRICTION_LIMITED_V01:
          if ( req_msg->net_sel_pref.net_sel_pref == NAS_NET_SEL_PREF_AUTOMATIC_V01 )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV;
          }
          else if ( req_msg->net_sel_pref.net_sel_pref == NAS_NET_SEL_PREF_MANUAL_V01 )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV;
          }
          break;

        case NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01:
          if ( req_msg->net_sel_pref.net_sel_pref == NAS_NET_SEL_PREF_AUTOMATIC_V01 )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY;
          }
          else if ( req_msg->net_sel_pref.net_sel_pref == NAS_NET_SEL_PREF_MANUAL_V01 )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY;
          }
          break;

        default:
          QM_MSG_HIGH_1("Unexpected srv_reg_restriction %d", req_msg->srv_reg_restriction);
          break;
      }

      if ( req_msg->net_sel_pref.net_sel_pref == NAS_NET_SEL_PREF_MANUAL_V01 ||
           req_msg->rat_valid )
      {
        if ( req_msg->mnc_includes_pcs_digit_valid )
        {
          mnc_includes_pcs_digit = req_msg->mnc_includes_pcs_digit;
        }
        else
        {
          mnc_includes_pcs_digit = ( req_msg->net_sel_pref.mnc > 99 );
        }

        if ( sys_plmn_set_mcc_mnc( mnc_includes_pcs_digit , req_msg->net_sel_pref.mcc, req_msg->net_sel_pref.mnc, &plmn ) )
        {
          sys_pref_info.plmn_ptr = &plmn;
        }
        else
        {
          errval = QMI_ERR_INVALID_ARG_V01;
        }

        if ( req_msg->rat_valid )
        {
          sys_pref_info.manual_rat = qmi_nas_radio_if_2_sys_radio_access( req_msg->rat );
        }
      }
    }
    else if ( req_msg->net_sel_pref_valid )
    {
      sys_pref_info.network_sel_mode_pref = (cm_network_sel_mode_pref_e_type) req_msg->net_sel_pref.net_sel_pref;

      if ( sys_pref_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL ||
           req_msg->rat_valid )
      {
        if ( req_msg->mnc_includes_pcs_digit_valid )
        {
          mnc_includes_pcs_digit = req_msg->mnc_includes_pcs_digit;
        }
        else
        {
          mnc_includes_pcs_digit = ( req_msg->net_sel_pref.mnc > 99 );
        }

        if ( sys_plmn_set_mcc_mnc( mnc_includes_pcs_digit , req_msg->net_sel_pref.mcc, req_msg->net_sel_pref.mnc, &plmn ) )
        {
          sys_pref_info.plmn_ptr = &plmn;
        }
        else
        {
          errval = QMI_ERR_INVALID_ARG_V01;
        }

        if ( req_msg->rat_valid )
        {
          sys_pref_info.manual_rat = qmi_nas_radio_if_2_sys_radio_access( req_msg->rat );
        }
      }
    }
    else if ( req_msg->srv_reg_restriction_valid )
    {
      switch ( req_msg->srv_reg_restriction )
      {
        case NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01:
          if ( qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC        ||
               qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV ||
               qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY   )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
          }
          else if ( qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL             ||
                    qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV ||
                    qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY   )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL;
          }
          break;

        case NAS_SRV_REG_RESTRICTION_LIMITED_V01:
          if ( qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC        ||
               qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV ||
               qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY   )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV;
          }
          else if ( qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL             ||
                    qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV ||
                    qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY   )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV;
        }
          break;

        case NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01:
          if ( qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC        ||
               qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV ||
               qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY   )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY;
          }
          else if ( qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL             ||
                    qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV ||
                    qmi_nasi_global.cm_ph_info.network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY   )
          {
            sys_pref_info.network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY;
          }
          break;

        default:
          QM_MSG_HIGH_1("Unexpected srv_reg_restriction %d", req_msg->srv_reg_restriction);
          break;
      }
    }

    if ( req_msg->change_duration_valid )
    {
      switch ( req_msg->change_duration )
      {
        case NAS_PERMANENT_V01:
          sys_pref_info.pref_term = CM_PREF_TERM_PERMANENT;
          break;

        case NAS_POWER_CYCLE_V01:
          sys_pref_info.pref_term = CM_PREF_TERM_PWR_CYCLE;
          break;

        default:
          break;
      }
    }

    if ( req_msg->srv_domain_pref_valid )
    {
      switch( req_msg->srv_domain_pref )
      {
        case QMI_SRV_DOMAIN_PREF_CS_ONLY_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_ONLY;
            break;

        case QMI_SRV_DOMAIN_PREF_PS_ONLY_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_ONLY;
            break;

        case QMI_SRV_DOMAIN_PREF_CS_PS_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_CS_PS;
            break;

        case QMI_SRV_DOMAIN_PREF_PS_ATTACH_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_ATTACH;
            break;

        case QMI_SRV_DOMAIN_PREF_PS_DETACH_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_DETACH;
            break;

        case QMI_SRV_DOMAIN_PREF_PS_DETACH_NO_PREF_CHANGE_V01:
            sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_PS_LOCAL_DETACH;
            break;

        case QMI_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH_V01:
                sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH;
                break;
    
        case QMI_SRV_DOMAIN_PREF_FORCE_PS_DETACH_V01:
                sys_pref_info.srv_domain_pref = CM_SRV_DOMAIN_PREF_FORCE_PS_DETACH;
                break;

          default:
            break;
      }
    }

    if ( req_msg->acq_order_valid )
    {
        rat_acq_order.type = CM_ACQ_ORDER_TYPE_RAT_PRI;
        rat_acq_order.acq_order.rat_acq_pri_order.num_rat = req_msg->acq_order_len;
        for( i = 0 ; i < req_msg->acq_order_len && i < NAS_ACQ_ORDER_LIST_MAX_V01 && errval == QMI_ERR_NONE_V01 ; i++ )
        {
          switch( req_msg->acq_order[i] )
          {
            case NAS_RADIO_IF_CDMA_1X_V01:
              rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_CDMA;
              break;
            case NAS_RADIO_IF_CDMA_1XEVDO_V01:
              rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_HDR;
              break;
            case NAS_RADIO_IF_GSM_V01:
              rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_GSM;
              break;
            case NAS_RADIO_IF_UMTS_V01:
              rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_WCDMA;
              break;
            case NAS_RADIO_IF_LTE_V01:
              rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_LTE;
              break;
            case NAS_RADIO_IF_TDSCDMA_V01:
              rat_acq_order.acq_order.rat_acq_pri_order.acq_order[i] = SYS_SYS_MODE_TDS;
              break;
            default:
            QM_MSG_ERROR_2("Unexpected acquisition order rat %d, in index %d", req_msg->acq_order[i], i);
              errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
              break;
          }
        }
        sys_pref_info.rat_acq_order_pref_ptr = &rat_acq_order;
      }
    else if ( req_msg->gw_acq_order_pref_valid )
    {
      rat_acq_order.type = CM_ACQ_ORDER_TYPE_GW;
      switch( req_msg->gw_acq_order_pref )
      {
        case NAS_GW_ACQ_ORDER_PREF_AUTOMATIC_V01:
            rat_acq_order.acq_order.gw_acq_order = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
            break;
        case NAS_GW_ACQ_ORDER_PREF_GSM_WCDMA_V01:
            rat_acq_order.acq_order.gw_acq_order = CM_GW_ACQ_ORDER_PREF_GSM_WCDMA;
            break;
        case NAS_GW_ACQ_ORDER_PREF_WCDMA_GSM_V01:
            rat_acq_order.acq_order.gw_acq_order = CM_GW_ACQ_ORDER_PREF_WCDMA_GSM;
            break;
          default:
            break;
    }

      sys_pref_info.rat_acq_order_pref_ptr = &rat_acq_order;
    }

    // handle TDS band preference
    if ( req_msg->tdscdma_band_pref_valid )
    {
      sys_pref_info.tds_band_pref = (cm_band_pref_e_type) req_msg->tdscdma_band_pref;
    }

  // handle usage setting
  if ( req_msg->usage_setting_valid )
    sys_pref_info.ue_usage_setting = (sys_ue_usage_setting_e_type) qmi_nas_map_ue_usage_qmi_to_cm(req_msg->usage_setting);

#ifdef FEATURE_FEMTO_CSG
    if(qm_efs_csg_supported() && req_msg->csg_info_valid)
    {
      mnc_includes_pcs_digit = req_msg->csg_info.mnc_includes_pcs_digit;
      if ( sys_plmn_set_mcc_mnc( mnc_includes_pcs_digit , req_msg->csg_info.mcc, req_msg->csg_info.mnc, &plmn ) )
      {
        sys_pref_info.plmn_ptr = &plmn;
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG_V01;
      }
      sys_pref_info.csg_id = req_msg->csg_info.id;
      sys_pref_info.manual_rat = qmi_nas_radio_if_2_sys_radio_access( req_msg->csg_info.rat );
    }
#endif
  }

  // handle voice_domain_pref setting
  if(req_msg != NULL)
  {
    if ( req_msg->voice_domain_pref_valid )
    {
      sys_pref_info.voice_domain_pref = req_msg->voice_domain_pref;
    }
  }
  else
  {
    sys_pref_info.voice_domain_pref = SYS_VOICE_DOMAIN_PREF_NO_CHANGE;
  }

  // now call CM API
  if ( errval == QMI_ERR_NONE_V01 )
  {
    sys_pref_info.client_id = qmi_nasi_global.cm_clnt_id;

    retval = cm_user_pref_update_req( &sys_pref_info,
                                      qmi_nas_cmph_cmd_cb,
                                      cmd_buf_p );

    if ( !retval )
    {
      QM_MSG_ERROR_1("[QMINAS] cm_user_pref_update_req error: mode_pref %d", sys_pref_info.mode_pref);
      errval = QMI_ERR_INVALID_ARG_V01;
    }
  }

  // take care of result
  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_set_sys_sel_pref() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if ( rsp_msg == NULL )
  {
    QM_MSG_ERROR_1("Not enough memory to allocate for QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE request. %p", rsp_msg);
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_set_system_selection_preference_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_system_selection_preference_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

    return response;
} /* qmi_nasi_set_sys_sel_pref() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_SYS_SEL_PREF()

  DESCRIPTION
    Get the different System Selection Preference of the device.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_sys_sel_pref(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type           *response = NULL;
  qmi_error_type_v01      errval                 = QMI_ERR_NONE_V01;
  nas_get_system_selection_preference_resp_msg_v01   *rsp_msg;
  qmi_cm_ph_info_s_type      *p_ph_info = &qmi_nasi_global.cm_ph_info;
  boolean                 mnc_includes_pcs_digit = FALSE;
  sys_mcc_type            mcc = 0;
  sys_mnc_type            mnc = 0;
  boolean                 is_plmn_undefined = TRUE;
  int                     i;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_system_selection_preference_resp_msg_v01 *) 
  	modem_mem_alloc( sizeof( nas_get_system_selection_preference_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
  {  
    memset( rsp_msg, 0, sizeof(nas_get_system_selection_preference_resp_msg_v01) );
  }

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    p_ph_info = &qmi_nasi_global.cm_ph_info2;
  }
#ifdef FEATURE_TRIPLE_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
  {
    p_ph_info = &qmi_nasi_global.cm_ph_info3;
  }
#endif
#endif
  if (errval == QMI_ERR_NONE_V01)
  {
    if ( p_ph_info->mode_pref == CM_MODE_PREF_EMERGENCY )
    {
      rsp_msg->emergency_mode = NASI_MODE_EMERGENCY_MODE_ON;

#ifdef FEATURE_DUAL_SIM
      if ( p_ph_info->asubs_id == SYS_MODEM_AS_ID_2 )
      {
        rsp_msg->mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( qmi_nasi_global.last_mode_pref2 );
      }
      else
#endif
#ifdef FEATURE_TRIPLE_SIM
      if ( p_ph_info->asubs_id == SYS_MODEM_AS_ID_3 )
      {
        rsp_msg->mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( qmi_nasi_global.last_mode_pref3 );
      }
      else
#endif
      {
        rsp_msg->mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( qmi_nasi_global.last_mode_pref );
      }
    }
    else
    {
      rsp_msg->emergency_mode = NASI_MODE_EMERGENCY_MODE_OFF;
      rsp_msg->mode_pref = qmi_nas_map_mode_pref_cm_to_qmi( p_ph_info->mode_pref );
    }

    rsp_msg->emergency_mode_valid      = TRUE;

    if (rsp_msg->mode_pref != 0)
    {
      rsp_msg->mode_pref_valid   = TRUE;
    }
    else
    {
      QM_MSG_HIGH_1("[QMINAS] Unsupported Mode preference (%d)", p_ph_info->mode_pref);
    }

    rsp_msg->band_pref = (uint64)p_ph_info->band_pref;
    rsp_msg->band_pref_valid     = TRUE;

    if ( TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR )
    {
      rsp_msg->prl_pref = (uint16)p_ph_info->prl_pref;
      rsp_msg->prl_pref_valid    = TRUE;
    }

    rsp_msg->roam_pref = (uint16)p_ph_info->roam_pref;
    rsp_msg->roam_pref_valid     = TRUE;

    memscpy(&rsp_msg->band_pref_ext, sizeof(uint64), &p_ph_info->lte_band_pref, sizeof(uint64));//copy first 64 bits of the bitmask to the legacy TLV
    memscpy(&rsp_msg->lte_band_pref_ext, sizeof(sys_lte_band_mask_e_type), &p_ph_info->lte_band_pref, sizeof(sys_lte_band_mask_e_type));//copy all 256 bits of the bitmask to the new TLV
    
    rsp_msg->band_pref_ext_valid         = TRUE;
    rsp_msg->lte_band_pref_ext_valid          = TRUE;

    if ( p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC ||
         p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL )
    {
      rsp_msg->net_sel_pref                   = (uint8)p_ph_info->network_sel_mode_pref;
      rsp_msg->net_sel_pref_valid           = TRUE;
      rsp_msg->srv_reg_restriction          = (uint8)NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01;
      rsp_msg->srv_reg_restriction_valid  = TRUE;
    }
    else if ( p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV )
    {
      rsp_msg->net_sel_pref             = (uint8)CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
      rsp_msg->net_sel_pref_valid    = TRUE;
      rsp_msg->srv_reg_restriction           = (uint8)NAS_SRV_REG_RESTRICTION_LIMITED_V01;
      rsp_msg->srv_reg_restriction_valid   = TRUE;
    }
    else if ( p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV )
    {
      rsp_msg->net_sel_pref             = (uint8)CM_NETWORK_SEL_MODE_PREF_MANUAL;
      rsp_msg->net_sel_pref_valid     = TRUE;
      rsp_msg->srv_reg_restriction             = (uint8)NAS_SRV_REG_RESTRICTION_LIMITED_V01;
      rsp_msg->srv_reg_restriction_valid     = TRUE;
    }
    else if ( p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY )
    {
      rsp_msg->net_sel_pref              = (uint8)CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
      rsp_msg->net_sel_pref_valid     = TRUE;
      rsp_msg->srv_reg_restriction            = (uint8)NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01;
      rsp_msg->srv_reg_restriction_valid    = TRUE;
    }
    else if ( p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY )
    {
      rsp_msg->net_sel_pref                     = (uint8)CM_NETWORK_SEL_MODE_PREF_MANUAL;
      rsp_msg->net_sel_pref_valid             = TRUE;
      rsp_msg->srv_reg_restriction            = (uint8)NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01;
      rsp_msg->srv_reg_restriction_valid    = TRUE;
    }

    //service domain preference
    switch( p_ph_info->srv_domain_pref )
    {
      case CM_SRV_DOMAIN_PREF_CS_ONLY:
        rsp_msg->srv_domain_pref         = QMI_SRV_DOMAIN_PREF_CS_ONLY_V01;
        rsp_msg->srv_domain_pref_valid = TRUE;
        break;

      case CM_SRV_DOMAIN_PREF_PS_ONLY:
        rsp_msg->srv_domain_pref         = QMI_SRV_DOMAIN_PREF_PS_ONLY_V01;
        rsp_msg->srv_domain_pref_valid = TRUE;
        break;

      case CM_SRV_DOMAIN_PREF_CS_PS:
        rsp_msg->srv_domain_pref         = QMI_SRV_DOMAIN_PREF_CS_PS_V01;
        rsp_msg->srv_domain_pref_valid = TRUE;
        break;

      case CM_SRV_DOMAIN_PREF_PS_ATTACH:
        rsp_msg->srv_domain_pref         = QMI_SRV_DOMAIN_PREF_PS_ATTACH_V01;
        rsp_msg->srv_domain_pref_valid = TRUE;
        break;

      case CM_SRV_DOMAIN_PREF_PS_DETACH:
        rsp_msg->srv_domain_pref         = QMI_SRV_DOMAIN_PREF_PS_DETACH_V01;
        rsp_msg->srv_domain_pref_valid = TRUE;
        break;

      default:
        // don't include this TLV
        break;

    }

    // GW acquisition order preference
    switch(p_ph_info->acq_order_pref)
    {
      case CM_GW_ACQ_ORDER_PREF_AUTOMATIC:
        rsp_msg->gw_acq_order_pref         = NAS_GW_ACQ_ORDER_PREF_AUTOMATIC_V01;
        rsp_msg->gw_acq_order_pref_valid = TRUE;
        break;

      case CM_GW_ACQ_ORDER_PREF_GSM_WCDMA:
        rsp_msg->gw_acq_order_pref          = NAS_GW_ACQ_ORDER_PREF_GSM_WCDMA_V01;
        rsp_msg->gw_acq_order_pref_valid = TRUE;
        break;

      case CM_GW_ACQ_ORDER_PREF_WCDMA_GSM:
        rsp_msg->gw_acq_order_pref = NAS_GW_ACQ_ORDER_PREF_WCDMA_GSM_V01;
        rsp_msg->gw_acq_order_pref_valid = TRUE;
        break;

      default :
        // don't include this TLV
        break;

    }

    // 0x1A - TDSCDMA band preference
    rsp_msg->tdscdma_band_pref              = (uint64)p_ph_info->tds_band_pref;
    rsp_msg->tdscdma_band_pref_valid      = TRUE;

    // 0x1B - PLMN info - to be included when net_sel_mode_pref is manual
    if( rsp_msg->net_sel_pref_valid && rsp_msg->net_sel_pref == (uint8) CM_NETWORK_SEL_MODE_PREF_MANUAL )
    {
      sys_plmn_get_mcc_mnc( p_ph_info->plmn, &is_plmn_undefined, &mnc_includes_pcs_digit, &mcc, &mnc );
      if( !is_plmn_undefined )
      {
        rsp_msg->manual_net_sel_plmn.mcc = (uint16) mcc;
        rsp_msg->manual_net_sel_plmn.mnc = (uint16) mnc;
        rsp_msg->manual_net_sel_plmn.mnc_includes_pcs_digit = (uint8) mnc_includes_pcs_digit;
        rsp_msg->manual_net_sel_plmn_valid = TRUE;
      }
      else
      {
        QM_MSG_ERROR("Undefined PLMN value. Unable to obtain PLMN info");
      }

    }

    if( p_ph_info->acq_pri_order_pref.num_rat > NAS_ACQ_ORDER_LIST_MAX_V01 )
    {
      QM_MSG_HIGH_2("Received acquisition order num rat %d, max expected %d", p_ph_info->acq_pri_order_pref.num_rat, NAS_ACQ_ORDER_LIST_MAX_V01);
      rsp_msg->acq_order_len = NAS_ACQ_ORDER_LIST_MAX_V01;
    }
    else
    {
      rsp_msg->acq_order_len = p_ph_info->acq_pri_order_pref.num_rat ;
    }
    for( i = 0; i < rsp_msg->acq_order_len && errval == QMI_ERR_NONE_V01; i++ )
    {
      switch( p_ph_info->acq_pri_order_pref.acq_order[i] )
      {
        case SYS_SYS_MODE_CDMA:
          rsp_msg->acq_order[i] = NAS_RADIO_IF_CDMA_1X_V01;
          break;
        case SYS_SYS_MODE_HDR:
          rsp_msg->acq_order[i] = NAS_RADIO_IF_CDMA_1XEVDO_V01;
          break;
        case SYS_SYS_MODE_GSM:
          rsp_msg->acq_order[i] = NAS_RADIO_IF_GSM_V01;
          break;
        case SYS_SYS_MODE_WCDMA:
          rsp_msg->acq_order[i] = NAS_RADIO_IF_UMTS_V01;
          break;
        case SYS_SYS_MODE_LTE:
          rsp_msg->acq_order[i] = NAS_RADIO_IF_LTE_V01;
          break;
        case SYS_SYS_MODE_TDS:
          rsp_msg->acq_order[i] = NAS_RADIO_IF_TDSCDMA_V01;
          break;
        default:
          QM_MSG_ERROR_2("Unexpected acquisition order rat %d, in index %d", p_ph_info->acq_pri_order_pref.acq_order[i], i);
          errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
          break;
      }
    }
    if ( errval == QMI_ERR_NONE_V01 )
    {
      rsp_msg->acq_order_valid = TRUE;
    }

#ifdef FEATURE_FEMTO_CSG
    if ( qm_efs_csg_supported() )
    {
    if( p_ph_info->csg_id != SYS_CSG_ID_INVALID )
    {
      sys_plmn_get_mcc_mnc( p_ph_info->plmn, &is_plmn_undefined, &mnc_includes_pcs_digit, &mcc, &mnc );
      if( !is_plmn_undefined )
      {
        rsp_msg->csg_info_valid = TRUE;
        rsp_msg->csg_info.mcc = (uint16) mcc;
        rsp_msg->csg_info.mnc = (uint16) mnc;
        rsp_msg->csg_info.mnc_includes_pcs_digit = (uint8) mnc_includes_pcs_digit;
        rsp_msg->csg_info.id = p_ph_info->csg_id;
        rsp_msg->csg_info.rat = (nas_radio_if_enum_v01)qmi_nas_sys_radio_access_2_radio_if( p_ph_info->csg_rat );
      }
      else
      {
        QM_MSG_ERROR("Undefined PLMN value. Unable to obtain CSG PLMN info");
      }
    }
    }
#endif

    rsp_msg->usage_setting_valid = TRUE;
    QM_MSG_HIGH_2("cm_ph_info->ue_usage_setting %d, voice_domain_pref %d", p_ph_info->ue_usage_setting, p_ph_info->voice_domain_pref);

    switch(p_ph_info->ue_usage_setting)
    {
      case SYS_UE_USAGE_SETTING_VOICE_CENTRIC:
        rsp_msg->usage_setting = (uint32)NAS_USAGE_VOICE_CENTRIC_V01;
        break;
      case SYS_UE_USAGE_SETTING_DATA_CENTRIC:
        rsp_msg->usage_setting = (uint32)NAS_USAGE_DATA_CENTRIC_V01;
        break;
      default:
        rsp_msg->usage_setting = (uint32)NAS_USAGE_UNKNOWN_V01;
        break;      
    }

    rsp_msg->voice_domain_pref_valid = TRUE;
    //QM_MSG_HIGH_1("cm_ph_info->voice_domain_pref %d", p_ph_info->voice_domain_pref);
    rsp_msg->voice_domain_pref = (nas_voice_domain_pref_enum_type_v01)p_ph_info->voice_domain_pref;

  }

  if(rsp_msg != NULL)
  {
    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *)rsp_msg,
                                  (uint32_t) sizeof(nas_get_system_selection_preference_resp_msg_v01),
                                  &response
                                );
    modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
  }

  return response;
} /* qmi_nasi_get_sys_sel_pref() */

/*===========================================================================
  FUNCTION QMI_NASI_SYS_SEL_PREF_IND()

  DESCRIPTION
    Is called when any of the conditions set in reg_sys_sel_pref becomes true
    Sends an indication to the client

  PARAMETERS
    sp             : service provided state pointer (user data)
    clid           : clientID
    emergency_mode : Emergency mode
    mode_pref      : Mode preference
    band_pref      : Band preference
    prl_pref       : prl preference
    roam_pref      : roam preference

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_sys_sel_pref_ind(
  qmi_nasi_client_state_type *  cl_sp,
  uint8         emergency_mode,
  uint16        mode_pref,
  uint64        band_pref,
  uint16        prl_pref,
  uint16        roam_pref,
  sys_lte_band_mask_e_type        lte_band_pref,
  uint64        tds_band_pref,
  uint8         net_sel_mode_pref,
  uint32        srv_domain_pref,
  uint32        gw_acq_order_pref,
  sys_plmn_id_s_type plmn,
  cm_acq_pri_order_pref_s_type acq_order,
  sys_ue_usage_setting_e_type ue_usage_setting,
  sys_csg_id_type csg_id,
  sys_radio_access_tech_e_type csg_rat,
  sys_voice_domain_pref_e_type  voice_domain_pref
)
{
  dsm_item_type               *ind = NULL;
  nas_system_selection_preference_ind_msg_v01      *ind_msg;
  boolean                     mnc_includes_pcs_digit = FALSE;
  sys_mcc_type                mcc = 0;
  sys_mnc_type                mnc = 0;
  boolean                     is_plmn_undefined = TRUE;
  int                         i;
  boolean                     include_acq_order = TRUE;

  if(cl_sp == NULL)
  {
    QM_MSG_HIGH("qmi_nasi_sys_sel_pref_ind: Client no longer available");
    return;
  }

  ind_msg = (nas_system_selection_preference_ind_msg_v01  *) 
  	modem_mem_alloc( sizeof(nas_system_selection_preference_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ind_msg == NULL )
  {
    qmi_voice_mem_error();
    return;
  }

  memset( ind_msg, 0, sizeof(nas_system_selection_preference_ind_msg_v01) );
 
  // TLV 0x20 - Usage setting
  ind_msg->voice_domain_pref_valid = TRUE;

  ind_msg->voice_domain_pref = (nas_voice_domain_pref_enum_type_v01)voice_domain_pref;

  // TLV 0x1F - Usage setting
  ind_msg->usage_setting_valid = TRUE;
    QM_MSG_HIGH_2("cm_ph_info->voice_domain_pref %d, ue_usage_setting %d", voice_domain_pref, ue_usage_setting);

  switch(ue_usage_setting)
  {
    case SYS_UE_USAGE_SETTING_VOICE_CENTRIC:
      ind_msg->usage_setting = (uint32)NAS_USAGE_VOICE_CENTRIC_V01;
      break;
    case SYS_UE_USAGE_SETTING_DATA_CENTRIC:
      ind_msg->usage_setting = (uint32)NAS_USAGE_DATA_CENTRIC_V01;
      break;
    default:
      ind_msg->usage_setting = (uint32)NAS_USAGE_UNKNOWN_V01;
      break;      
    }

#ifdef FEATURE_FEMTO_CSG
  if ( qm_efs_csg_supported() )
  {
  if( csg_id != SYS_CSG_ID_INVALID )
  {
    sys_plmn_get_mcc_mnc( plmn, &is_plmn_undefined, &mnc_includes_pcs_digit, &mcc, &mnc );
    if( !is_plmn_undefined )
    {
      ind_msg->csg_info_valid = TRUE;
      ind_msg->csg_info.mcc = (uint16) mcc;
      ind_msg->csg_info.mnc = (uint16) mnc;
      ind_msg->csg_info.mnc_includes_pcs_digit = (uint8) mnc_includes_pcs_digit;
      ind_msg->csg_info.id = csg_id;
      ind_msg->csg_info.rat = (nas_radio_if_enum_v01)qmi_nas_sys_radio_access_2_radio_if( csg_rat );
      QM_MSG_HIGH_2("SYS_SEL_PREF csg_id %d, csg_rat %d", csg_id, csg_rat);
    }
    else
    {
      QM_MSG_ERROR("Undefined PLMN value. Unable to obtain CSG PLMN info");
    }
  }
  }
#endif

  if( acq_order.num_rat > NAS_ACQ_ORDER_LIST_MAX_V01 )
  {
    QM_MSG_HIGH_2("Received acquisition order num rat %d, max expected %d", acq_order.num_rat, NAS_ACQ_ORDER_LIST_MAX_V01);
    ind_msg->acq_order_len = NAS_ACQ_ORDER_LIST_MAX_V01;
  }
  else
  {
    ind_msg->acq_order_len = acq_order.num_rat ;
  }

  for( i = 0; i < ind_msg->acq_order_len && include_acq_order; i++ )
  {
    switch( acq_order.acq_order[i] )
    {
      case SYS_SYS_MODE_CDMA:
        ind_msg->acq_order[i] = NAS_RADIO_IF_CDMA_1X_V01;
        break;
      case SYS_SYS_MODE_HDR:
        ind_msg->acq_order[i] = NAS_RADIO_IF_CDMA_1XEVDO_V01;
        break;
      case SYS_SYS_MODE_GSM:
        ind_msg->acq_order[i] = NAS_RADIO_IF_GSM_V01;
        break;
      case SYS_SYS_MODE_WCDMA:
        ind_msg->acq_order[i] = NAS_RADIO_IF_UMTS_V01;
        break;
      case SYS_SYS_MODE_LTE:
        ind_msg->acq_order[i] = NAS_RADIO_IF_LTE_V01;
        break;
      case SYS_SYS_MODE_TDS:
        ind_msg->acq_order[i] = NAS_RADIO_IF_TDSCDMA_V01;
        break;
      default:
        QM_MSG_ERROR_2("Unexpected acquisition order rat %d, in index %d", acq_order.acq_order[i], i);
        include_acq_order = FALSE;
        break;
    }
  }

  if( include_acq_order )
  {
    ind_msg->acq_order_valid = TRUE;
  }

  // 0x1B - PLMN info - to be included when net_sel_mode_pref is manual
  if( net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL )
  {
    sys_plmn_get_mcc_mnc( plmn, &is_plmn_undefined, &mnc_includes_pcs_digit, &mcc, &mnc );
    if( !is_plmn_undefined )
    {
      ind_msg->manual_net_sel_plmn.mcc = (uint16) mcc;
      ind_msg->manual_net_sel_plmn.mnc = (uint16) mnc;
      ind_msg->manual_net_sel_plmn.mnc_includes_pcs_digit = (uint8) mnc_includes_pcs_digit;
      ind_msg->manual_net_sel_plmn_valid = TRUE;
    }
    else
    {
      QM_MSG_ERROR("Undefined PLMN value. Unable to obtain PLMN info");
    }
  }

  // 0x1A TDSCDMA band preference
  ind_msg->tdscdma_band_pref  = tds_band_pref;
  ind_msg->tdscdma_band_pref_valid          = TRUE;

  // GW acquisition order preference
  switch( gw_acq_order_pref )
  {
    case CM_GW_ACQ_ORDER_PREF_AUTOMATIC:
      ind_msg->gw_acq_order_pref = NAS_GW_ACQ_ORDER_PREF_AUTOMATIC_V01;
      ind_msg->gw_acq_order_pref_valid = TRUE;
      break;

    case CM_GW_ACQ_ORDER_PREF_GSM_WCDMA:
      ind_msg->gw_acq_order_pref = NAS_GW_ACQ_ORDER_PREF_GSM_WCDMA_V01;
      ind_msg->gw_acq_order_pref_valid = TRUE;
      break;

    case CM_GW_ACQ_ORDER_PREF_WCDMA_GSM:
      ind_msg->gw_acq_order_pref = NAS_GW_ACQ_ORDER_PREF_WCDMA_GSM_V01;
      ind_msg->gw_acq_order_pref_valid = TRUE;
      break;

    default :
      // don't include this TLV
      break;

  }

  //service domain preference
  switch( srv_domain_pref )
  {
    case CM_SRV_DOMAIN_PREF_CS_ONLY:
      ind_msg->srv_domain_pref = QMI_SRV_DOMAIN_PREF_CS_ONLY_V01;
      ind_msg->srv_domain_pref_valid = TRUE;
      break;

    case CM_SRV_DOMAIN_PREF_PS_ONLY:
      ind_msg->srv_domain_pref = QMI_SRV_DOMAIN_PREF_PS_ONLY_V01;
      ind_msg->srv_domain_pref_valid = TRUE;
      break;

    case CM_SRV_DOMAIN_PREF_CS_PS:
      ind_msg->srv_domain_pref = QMI_SRV_DOMAIN_PREF_CS_PS_V01;
      ind_msg->srv_domain_pref_valid = TRUE;
      break;

    case CM_SRV_DOMAIN_PREF_PS_ATTACH:
      ind_msg->srv_domain_pref = QMI_SRV_DOMAIN_PREF_PS_ATTACH_V01;
      ind_msg->srv_domain_pref_valid = TRUE;
      break;

    case CM_SRV_DOMAIN_PREF_PS_DETACH:
      ind_msg->srv_domain_pref = QMI_SRV_DOMAIN_PREF_PS_DETACH_V01;
      ind_msg->srv_domain_pref_valid = TRUE;
      break;

    default:
      // don't include this TLV
      break;
  }

  if( net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC || net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL)
  {
    ind_msg->net_sel_pref = net_sel_mode_pref;
    ind_msg->net_sel_pref_valid             = TRUE;
    ind_msg->srv_reg_restriction                        = (uint8)NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01;
    ind_msg->srv_reg_restriction_valid               = TRUE;
  }
  else if ( net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_LIMITED_SRV )
  {
    ind_msg->net_sel_pref   = (uint8)CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
    ind_msg->net_sel_pref_valid               = TRUE;
    ind_msg->srv_reg_restriction = (uint8)NAS_SRV_REG_RESTRICTION_LIMITED_V01;
    ind_msg->srv_reg_restriction_valid               = TRUE;
  }
  else if ( net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_LIMITED_SRV )
  {
    ind_msg->net_sel_pref   = (uint8)CM_NETWORK_SEL_MODE_PREF_MANUAL;
    ind_msg->net_sel_pref_valid               = TRUE;
    ind_msg->srv_reg_restriction = (uint8)NAS_SRV_REG_RESTRICTION_LIMITED_V01;
    ind_msg->srv_reg_restriction_valid               = TRUE;
  }
  else if ( net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTO_CAMP_ONLY )
  {
    ind_msg->net_sel_pref   = (uint8)CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
    ind_msg->net_sel_pref_valid               = TRUE;
    ind_msg->srv_reg_restriction = (uint8)NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01;
    ind_msg->srv_reg_restriction_valid               = TRUE;
  }
  else if ( net_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL_CAMP_ONLY )
  {
    ind_msg->net_sel_pref   = (uint8)CM_NETWORK_SEL_MODE_PREF_MANUAL;
    ind_msg->net_sel_pref_valid               = TRUE;
    ind_msg->srv_reg_restriction = (uint8)NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01;
    ind_msg->srv_reg_restriction_valid               = TRUE;
  }

  memscpy(&ind_msg->lte_band_pref, sizeof(uint64), &lte_band_pref, sizeof(uint64));//copy first 64 bits of the bitmask to the legacy TLV
  memscpy(&ind_msg->lte_band_pref_ext, sizeof(sys_lte_band_mask_e_type), &lte_band_pref, sizeof(sys_lte_band_mask_e_type));//copy all 256 bits of the bitmask to the new TLV
  ind_msg->lte_band_pref_valid          = TRUE;
  ind_msg->lte_band_pref_ext_valid          = TRUE;

  ind_msg->roam_pref                  = roam_pref;
  ind_msg->roam_pref_valid          = TRUE;

  ind_msg->prl_pref                  = prl_pref;
  ind_msg->prl_pref_valid          = TRUE;

  ind_msg->band_pref            = band_pref;
  ind_msg->band_pref_valid    = TRUE;

  ind_msg->mode_pref          = mode_pref;
  ind_msg->mode_pref_valid  = TRUE;

  ind_msg->emergency_mode          = emergency_mode;
  ind_msg->emergency_mode_valid  = TRUE;

  {
    ind = NULL;

    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                              QMI_IDL_INDICATION,
                                              QMI_NAS_SYSTEM_SELECTION_PREFERENCE_IND_MSG_V01,
                                              (void *) ind_msg,
                                              (uint32_t) sizeof( nas_system_selection_preference_ind_msg_v01 ),
                                              &ind
                                            )
      )
    {
      qmi_nasi_send_ind( cl_sp, (uint16)QMI_NAS_SYSTEM_SELECTION_PREFERENCE_IND_MSG_V01, ind );
    }
    else
    {
       QM_MSG_ERROR("failed to send SYSTEM_SELECTION_PREFERENCE_IND ind");
  }
  }

  if ( ind_msg != NULL ) { QMI_NAS_MEM_FREE( (void *) ind_msg ); }

} /* qmi_nasi_sys_sel_pref_ind() */

/*===========================================================================
  FUNCTION QMI_NASI_CURRENT_NAM_IND()

  DESCRIPTION
    Is called when any of the conditions set in reg_current_nam becomes true
    Sends an indication to the client

  PARAMETERS
    sp           : service provided state pointer (user data)
    clid         : clientID
    current_nam_index   : current name Index

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_current_nam_ind
(
  qmi_nasi_client_state_type *  cl_sp,
  uint8         current_nam_index
)
{
  dsm_item_type *  ind;

  struct
  {
    uint8   nam_index;
  } v_required_out;


  if(cl_sp == NULL)
  {
    QM_MSG_HIGH("qmi_nasi_current_nam_ind: Client no longer available");
    return;
  }

  ind = NULL;

  v_required_out.nam_index = current_nam_index;
  if(FALSE == qmi_svc_put_param_tlv(&ind,
                                    QMI_TYPE_REQUIRED_PARAMETERS,
                                    sizeof (v_required_out),
                                    &v_required_out))
  {
    QM_MSG_HIGH("Unable to return the Current NAM!");
    dsm_free_packet(&ind);
    return;
  }

  qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_GET_NAM, ind );

} /* qmi_nasi_current_nam_ind() */


/*===========================================================================
  FUNCTION QMI_NASI_SET_DDTM_PREFERENCE()

  DESCRIPTION
    Sets the DDTM(Data Dedicated Transmission Model) preference for
    the device.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_ddtm_preference
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  boolean            retval;
  qmi_result_e_type  result;
  qmi_error_e_type   errval;
#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

#ifdef _WIN32
#pragma pack(push,1) // Save previous, and turn on 1 byte alignment
#endif

  PACK(struct)
  {
    uint8       ddtm_pref;
    uint16      ddtm_act;
    uint8       so_list_action;
    uint8       num_so_instances;
    uint16      so[SYS_DDTM_MAX_SO_LIST_SIZE];
  } v_required;

#ifdef _WIN32
#pragma pack(pop) // Revert alignment to what it was previously
#endif

  boolean                              got_required_tlv;
  uint8                                type;
  uint16                               len;
  uint16                               expected_len;
  void *                               value;

  cm_ddtm_pref_e_type                  ddtm_pref;
  sys_ddtm_act_mask_e_type             ddtm_act;
  cm_ddtm_so_list_act_e_type           so_list_act;
  uint16                               num_srv_opt;
  sys_srv_opt_type                     srv_opt_list[SYS_DDTM_MAX_SO_LIST_SIZE];
  uint16                               srv_opt_len = 0;
  uint16                               tlv_len = 0;

#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);


  response = NULL;
  errval = QMI_ERR_NONE;

#if !defined (FEATURE_CDMA_800) && !defined (FEATURE_CDMA_1900)
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  goto send_result;
#else /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */
  memset(&v_required, 0, sizeof(v_required));
  got_required_tlv = FALSE;

  while (*sdu_in)
  {
    if( !qmi_svc_get_tl( sdu_in, &type, &len ) )
    {
      continue;
    }

    // special value 0 = variable length or don't care (unrecognzied TLV)
    expected_len = 0;
    value = NULL;
    switch (type)
    {
      case QMI_TYPE_REQUIRED_PARAMETERS:
        if (len <= sizeof(v_required))
        {
          got_required_tlv = TRUE;
          value = &v_required;
          tlv_len = len;
        }
        else
        {
          errval = QMI_ERR_ARG_TOO_LONG;
          goto send_result;
        }
        break;

      default:
        QM_MSG_ERROR_1("Unrecognized TLV type (%d)", type);
        break;
    }

    if ((expected_len != 0) && (expected_len != len))
    {
      QM_MSG_ERROR_2("Invalid TLV len (%d) for type (%d)", len, type);
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }

    /*-----------------------------------------------------------------------
      If type is unrecognized, value will be NULL, and dsm_pullup will
      free the unrecognized value, i.e. we skip past unrecognized TLVs
    -----------------------------------------------------------------------*/
    if(len != dsm_pullup( sdu_in, value, len ))
    {
      QM_MSG_ERROR("Invalid length in TLV");
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }
  }
  /*-------------------------------------------------------------------------
    If ALL optional TLVs are absent return error or else act depending on
    which tlvs are present
  -------------------------------------------------------------------------*/
  if(!(got_required_tlv))
  {
    errval = QMI_ERR_MISSING_ARG;
  }
  else
  {
    /* Validate length of input tlv to ensure it is consistent with
    num srv opt instances field specified in the tlv  */
    if ( tlv_len !=
             ( sizeof(v_required.ddtm_pref) +
               sizeof(v_required.ddtm_act) +
               sizeof(v_required.so_list_action) +
               sizeof(v_required.num_so_instances) +
               ( v_required.num_so_instances * sizeof(sys_srv_opt_type) ) ) )
    {
      QM_MSG_HIGH_2("Num_Service_opt_instances value(%d) different from number of Serice option sent in TLV: TLV_len(%d)!", v_required.num_so_instances, tlv_len);
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }

    if ((cm_ddtm_pref_e_type) v_required.ddtm_pref >= CM_DDTM_PREF_MAX)
    {
      errval = QMI_ERR_INVALID_ARG;
      goto send_result;
    }

    if ( (sys_ddtm_act_mask_e_type) v_required.ddtm_act == SYS_DDTM_ACT_MASK_EMPTY ||
         (sys_ddtm_act_mask_e_type) v_required.ddtm_act >= SYS_DDTM_ACT_MASK_MAX )
    {
      errval = QMI_ERR_INVALID_ARG;
      goto send_result;
    }

    if ((cm_ddtm_so_list_act_e_type) v_required.so_list_action >= CM_DDTM_SO_LIST_ACT_MAX)
    {
      errval = QMI_ERR_INVALID_ARG;
      goto send_result;
    }

    ddtm_pref = (cm_ddtm_pref_e_type) v_required.ddtm_pref;
    ddtm_act = (sys_ddtm_act_mask_e_type) v_required.ddtm_act;
    so_list_act = (cm_ddtm_so_list_act_e_type) v_required.so_list_action;
    num_srv_opt = v_required.num_so_instances;

    if(num_srv_opt > SYS_DDTM_MAX_SO_LIST_SIZE)
    {
      errval = QMI_ERR_ARG_TOO_LONG;
      goto send_result;
    }

    srv_opt_len = num_srv_opt * sizeof(sys_srv_opt_type);
    memscpy((sys_srv_opt_type *) srv_opt_list, srv_opt_len,
            (sys_srv_opt_type *) v_required.so, srv_opt_len);

    if (!cm_ph_cmd_ddtm_pref( qmi_nas_cmph_cmd_cb,
                              cmd_buf_p,
                              qmi_nasi_global.cm_clnt_id,
                              ddtm_pref,
                              ddtm_act,
                              so_list_act,
                              num_srv_opt,
                              srv_opt_list ))
    {
      QM_MSG_ERROR("Unable to change DDTM Preference");
    }
    QM_MSG_HIGH("Response pending for DDTM Preference");
    return QMI_SVC_RESPONSE_PENDING;
  }
#endif /* defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900) */
send_result:
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_set_ddtm_preference() */

/*===========================================================================
  FUNCTION QMI_NASI_DDTM_IND()

  DESCRIPTION
    Is called when any of the conditions set in reg_ddtm_events becomes true
    Sends an indication to the client

  PARAMETERS
    sp              : service provided state pointer (user data)
    clid            : clientID
    cur_ddtm_status : cuurent ddtm status
    ddtm_pref       : ddtm preference setting
    ddtm_act_mask   : bitmask representing combined DDTM action should take
    num_so_instances: number of service options that follow
    srv_option      : Serive option pages should be ignored when DDTM status ON

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_ddtm_ind
(
  qmi_nasi_client_state_type *  cl_sp,
  uint8         cur_ddtm_status,
  uint8         ddtm_pref,
  uint16        ddtm_act_mask,
  uint8         num_so_instances,
  uint16*       srv_option
)
{
  dsm_item_type *  ind;

#ifdef _WIN32
#pragma pack(push,1) // Save previous, and turn on 1 byte alignment
#endif

  PACK(struct)
  {
    uint8       cur_ddtm_status;
    uint8       ddtm_pref;
    uint16      ddtm_act_mask;
    uint8       num_so_instances;
    uint16      srv_option[SYS_DDTM_MAX_SO_LIST_SIZE];
  } v_required_out;

#ifdef _WIN32
#pragma pack(pop) // Revert alignment to what it was previously
#endif

  uint16                        srv_opt_len = 0;
  uint16                        tlv_len = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(srv_option);
  memset(&v_required_out, 0, sizeof(v_required_out));

  ind = NULL;

  if(cl_sp == NULL)
  {
    QM_MSG_HIGH("qmi_nasi_ddtm_ind: Client no longer available");
    return;
  }  

  if ( num_so_instances <= SYS_DDTM_MAX_SO_LIST_SIZE )
  {
    v_required_out.cur_ddtm_status = cur_ddtm_status;
    v_required_out.ddtm_pref = ddtm_pref;
    v_required_out.ddtm_act_mask = ddtm_act_mask;
    v_required_out.num_so_instances = num_so_instances;

    srv_opt_len = num_so_instances * sizeof(sys_srv_opt_type);
    memscpy ((void *)v_required_out.srv_option, srv_opt_len, srv_option, srv_opt_len);

    tlv_len = ( sizeof(v_required_out.cur_ddtm_status) +
                sizeof(v_required_out.ddtm_pref) +
                sizeof(v_required_out.ddtm_act_mask) +
                sizeof(v_required_out.num_so_instances) + srv_opt_len );

    if(FALSE == qmi_svc_put_param_tlv(&ind,
                                      QMI_TYPE_REQUIRED_PARAMETERS,
                                      tlv_len,
                                      &v_required_out))
    {
      QM_MSG_HIGH("Unable to generate DDTM indication!");
      dsm_free_packet(&ind);
      return;
    }

    qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_DDTM_IND, ind );
  }
  else
  {
    QM_MSG_ERROR_1("invalid SO instance %d", num_so_instances);
  }

} /* qmi_nasi_ddtm_ind() */

/*===========================================================================
  FUNCTION qmi_nas_bcd_to_ascii()

  DESCRIPTION
    BCD to ASCII

  RETURN VALUE
    Digits in ascii. 'D' considered as wildcard. 0x00 for error.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
uint8 qmi_nas_bcd_to_ascii( uint8 ch )
{
  if ( ch == 0x0d )
    return 'D'; // wild card per TS 31.102 cl. 4.2.59

  if ( ch <= 0x09 )
    return ch+'0';

  return 0x00;
}

/*===========================================================================
  FUNCTION qmi_nas_get_opl_data()

  DESCRIPTION
    Read EF OPL data from cache and parse into data structure.

  RETURN VALUE
    TRUE for success, FALSE for failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_get_opl_data( nas_operator_plmn_list_type_v01 *p_dest, uint8 *p_src )
{
  // MCC - All 3 digits must be present
  // Refer ITU-T E212, Annex. A, section A.3.1
  if ( (p_dest->mcc[0]=qmi_nas_bcd_to_ascii( *p_src & 0x0f )) == 0x00 )
    return FALSE; // something wrong
  if ( (p_dest->mcc[1]=qmi_nas_bcd_to_ascii( (*p_src & 0xf0) >> 4 )) == 0x00 )
    return FALSE; // something wrong
  if ( (p_dest->mcc[2]=qmi_nas_bcd_to_ascii( *(p_src+1) & 0x0f )) == 0x00 )
    return FALSE; // something wrong

  // MNC
  if ( (p_dest->mnc[0]=qmi_nas_bcd_to_ascii( *(p_src+2) & 0x0f )) == 0x00 )
    return FALSE; // something wrong
  if ( (p_dest->mnc[1]=qmi_nas_bcd_to_ascii( (*(p_src+2) & 0xf0) >> 4 )) == 0x00 )
    return FALSE; // something wrong

  // Digit 3 in MNC is optional and when not present encoded as 0xF
  // For more details refer TS - 24.008, Table 10.5.3

  if ( ( p_dest->mnc[2]=qmi_nas_bcd_to_ascii( ( (*(p_src+1) & 0xf0) >> 4 ) ) ) == 0x00 )
  {
    if ( ( (*(p_src+1) & 0xf0) >> 4 ) == 0x0F )
    {
      p_dest->mnc[2] = 'F';
    }
    else
    {
      return FALSE; //something wrong. (non compliant 3rd digit for MNC)
    }
  }

  // lac1
  memscpy( (void*)&p_dest->lac1, sizeof(p_dest->lac1), p_src+3, sizeof(p_dest->lac1) );

  // lac2
  memscpy( (void*)&p_dest->lac2, sizeof(p_dest->lac2), p_src+5, sizeof(p_dest->lac2) );

  // pnn_rec_id
  memscpy( &p_dest->pnn_rec_id, sizeof(p_dest->pnn_rec_id), p_src+7, sizeof(p_dest->pnn_rec_id) );

  return TRUE;
}

/*===========================================================================
  FUNCTION qmi_nas_get_pnn_data()

  DESCRIPTION
    Read EF PNN data from cache and parse into data structure.

  RETURN VALUE
    TRUE for success, FALSE for failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_get_pnn_data( nas_plmn_network_name_type_v01 *p_dest, uint8 *p_src, mmgsdi_session_type_enum_type session )
{
  int long_len, short_len;

  if ( *p_src != 0x43 ) // full name network name IEI
  {
    QM_MSG_ERROR_1("full name IEI missing %d", *p_src);
    return FALSE;
  }

  if ( *(p_src+1) <= 0x01 ) // full name network name IEI len
  {
    QM_MSG_ERROR_1("full name len too short %d", *(p_src+1));
    return FALSE;
  }

  p_dest->coding_scheme        = (*(p_src+2) & 0x70) >> 4;
  p_dest->ci                   = (*(p_src+2) & 0x08) >> 3;
  p_dest->long_name_spare_bits =  *(p_src+2) & 0x07;
  p_dest->long_name_len        =  *(p_src+1)-1;

  long_len = MIN( p_dest->long_name_len, NAS_LONG_NAME_MAX_V01 );

  memscpy( p_dest->long_name, long_len, p_src+3, long_len );

  if ( qmi_nasi_global.mmgsdi.cache[session].ef_pnn_rec_size > (uint32) p_dest->long_name_len + 3/*headers*/ ) // we have more text
  {
    p_src += ( p_dest->long_name_len + 3/*headers*/ ); // p_src now points to short name IEI

    if ( *p_src != 0x45 ) // short name network name IEI
    {
      QM_MSG_ERROR_1("no short name IEI %d", *p_src);
    }
    else if ( *(p_src+1) <= 0x01 ) // short name network name IEI len
    {
      QM_MSG_ERROR_1("short name len too short %d", *(p_src+1));
    }
    else
    {
      p_dest->short_name_spare_bits =  *(p_src+2) & 0x07;
      p_dest->short_name_len        =  *(p_src+1)-1;

      short_len = MIN( p_dest->short_name_len, NAS_SHORT_NAME_MAX_V01 );

      memscpy( p_dest->short_name, short_len, p_src+3, short_len );
    }
  }

  p_dest->long_name_len = long_len;

  return TRUE;
}

/*===========================================================================
  FUNCTION qmi_nas_populate_spn_from_cache()

  DESCRIPTION
    Copy EF_SPN data from cache to struct nas_get_operator_name_data_resp_msg_v01

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_spn_from_cache( nas_operator_name_data_ind_msg_v01 *p_msg, mmgsdi_session_type_enum_type session )
{
  uint8 *p_head, *p_tail;
  struct qmi_nas_mmgsdi_cache_s *p_cache;

  if ( p_msg && session <= MMGSDI_GW_PROV_SEC_SESSION )
  {
    p_cache = &qmi_nasi_global.mmgsdi.cache[session]; // shorthand

    if ( p_cache->ef_spn_size > 1 )
    {
      p_head = p_cache->ef_spn+1;
      p_tail = memchr ( p_head, 0xff, p_cache->ef_spn_size-1 );

      p_msg->service_provider_name.display_cond = *p_cache->ef_spn;
      p_msg->service_provider_name.spn_len      = (uint8) (p_tail ? p_tail-p_head : p_cache->ef_spn_size-1);

      if ( p_msg->service_provider_name.spn_len > 0 )
      {
        memscpy( p_msg->service_provider_name.spn, p_msg->service_provider_name.spn_len, p_head, p_msg->service_provider_name.spn_len );
        p_msg->service_provider_name_valid = TRUE;
      }
      else
      {
        QM_MSG_ERROR("zero length ef spn");
      }
    }
  }
  else
  {
    QM_MSG_ERROR_2("error populating spn %d %d", p_msg, session);
  }
}

/*===========================================================================
  FUNCTION qmi_nas_populate_opl_from_cache()

  DESCRIPTION
    Copy EF_OPL data from cache to struct nas_get_operator_name_data_resp_msg_v01

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_opl_from_cache( nas_operator_name_data_ind_msg_v01 *p_msg, mmgsdi_session_type_enum_type session )
{
  uint16 i;
  uint8 *p_head;
  struct qmi_nas_mmgsdi_cache_s *p_cache;

  if ( p_msg && session <= MMGSDI_GW_PROV_SEC_SESSION )
  {
    p_cache = &qmi_nasi_global.mmgsdi.cache[session]; // shorthand

    for (i=0; i<p_cache->ef_opl_num_recs && i<NAS_0039_RSP_T11_DATA_MAX; i++)
    {
      p_head = p_cache->ef_opl + i*QMI_NAS_MMGSDI_REC_SIZE_EF_OPL;

      if ( qmi_nas_get_opl_data( &p_msg->operator_plmn_list[i], p_head ) != TRUE )
      {
        QM_MSG_ERROR_1("ef opl record %d read fail", i);
        break;
      }
    }

    if ( (p_msg->operator_plmn_list_len = i) > 0 )
      p_msg->operator_plmn_list_valid = TRUE;
    else
      QM_MSG_ERROR("zero length ef opl");
  }
  else
  {
    QM_MSG_ERROR_2("error populating opl %d %d", p_msg, session);
  }
}

/*===========================================================================
  FUNCTION qmi_nas_populate_pnn_from_cache()

  DESCRIPTION
    Copy EF_PNN data from cache to struct nas_get_operator_name_data_resp_msg_v01

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_pnn_from_cache( nas_operator_name_data_ind_msg_v01 *p_msg, mmgsdi_session_type_enum_type session )
{
  uint8 i;
  uint8 *p_head;
  struct qmi_nas_mmgsdi_cache_s *p_cache;

  if ( p_msg && session <= MMGSDI_GW_PROV_SEC_SESSION )
  {
    p_cache = &qmi_nasi_global.mmgsdi.cache[session]; // shorthand

    for (i=0; i<p_cache->ef_pnn_num_recs && i<NAS_PLMN_NETWORK_NAME_LIST_MAX_V01; i++)
    {
      p_head = p_cache->ef_pnn + i*p_cache->ef_pnn_rec_size;

      if ( qmi_nas_get_pnn_data( &p_msg->plmn_network_name[i], p_head, session ) != TRUE )
      {
        QM_MSG_ERROR_1("ef pnn record %d read fail", i);
        break;
      }
    }

    if ( (p_msg->plmn_network_name_len = i) > 0 )
      p_msg->plmn_network_name_valid = TRUE;
    else
      QM_MSG_ERROR("zero length ef pnn");
  }
  else
  {
    QM_MSG_ERROR_2("error populating pnn %d %d", p_msg, session);
  }
}

/*===========================================================================
  FUNCTION qmi_nas_populate_ons_from_cache()

  DESCRIPTION
    Copy EF_ONS data from cache to struct nas_get_operator_name_data_resp_msg_v01

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_ons_from_cache( nas_operator_name_data_ind_msg_v01 *p_msg, mmgsdi_session_type_enum_type session )
{
  uint8 *p_head, *p_tail;
  struct qmi_nas_mmgsdi_cache_s *p_cache;
  uint8 plmn_name_len = 0;

  if ( p_msg && session <= MMGSDI_GW_PROV_SEC_SESSION )
  {
    p_cache = &qmi_nasi_global.mmgsdi.cache[session]; // shorthand

    p_head = p_cache->ef_ons;
    p_tail = memchr ( p_head, 0xff, p_cache->ef_ons_size );

    plmn_name_len = (uint8) (p_tail ? p_tail-p_head : p_cache->ef_ons_size);

    if ( plmn_name_len > 0 )
    {
      memscpy (p_msg->plmn_name, plmn_name_len,  p_head,  plmn_name_len);
      p_msg->plmn_name_valid = TRUE;
    }
    else
    {
      QM_MSG_ERROR("zero length ef ons");
    }
  }
  else
  {
    QM_MSG_ERROR_2("error populating ons %d %d", p_msg, session);
  }
}

/*===========================================================================
  FUNCTION qmi_nas_populate_nw_name_from_nitz()

  DESCRIPTION
    Copy network name data from NITZ to struct nas_get_operator_name_data_resp_msg_v01

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_nw_name_from_nitz( nas_operator_name_data_ind_msg_v01 *p_msg, sys_mm_information_s_type *p_mm_info )
{
  if ( p_mm_info )
  {
    if ( p_mm_info->short_name_avail )
    {
      p_msg->nitz_information.coding_scheme         = (nas_coding_scheme_enum_v01)p_mm_info->short_name.coding_scheme;
      p_msg->nitz_information.ci                    = p_mm_info->short_name.add_country_initials;
      p_msg->nitz_information.short_name_spare_bits = p_mm_info->short_name.spare_bits;
      p_msg->nitz_information.short_name_len        = p_mm_info->short_name.length;
      memscpy(p_msg->nitz_information.short_name, p_msg->nitz_information.short_name_len, 
              p_mm_info->short_name.name, p_msg->nitz_information.short_name_len );
      p_msg->nitz_information_valid = TRUE;
    }

    if ( p_mm_info->full_name_avail )
    {
      p_msg->nitz_information.coding_scheme         = (nas_coding_scheme_enum_v01)p_mm_info->full_name.coding_scheme;
      p_msg->nitz_information.ci                    = p_mm_info->full_name.add_country_initials;
      p_msg->nitz_information.long_name_spare_bits  = p_mm_info->full_name.spare_bits;
      p_msg->nitz_information.long_name_len         = p_mm_info->full_name.length;
      memscpy(p_msg->nitz_information.long_name, p_msg->nitz_information.long_name_len,
              p_mm_info->full_name.name, p_msg->nitz_information.long_name_len );
      p_msg->nitz_information_valid = TRUE;
    }
  }
  else
  {
    QM_MSG_ERROR("error populating nitz null pointer");
  }
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_PLMN_NAME()

  DESCRIPTION
    get the current nam of the device

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_plmn_name
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response = NULL;
  qmi_error_type_v01             errval = QMI_ERR_NONE_V01;
  nas_get_plmn_name_req_msg_v01 *req_msg;

  sys_plmn_id_s_type          plmn;
  qmi_nas_mmgsdi_session_e_type qmi_session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  mmgsdi_plmn_id_list_type      plmn_id_list;
  struct qmi_nasi_mmgsdi_client_data_s *callback_data;
  mmgsdi_plmn_id_type plmn_id;
  mmgsdi_eons_ignore_disp_cond_enum_type ignore_disp = MMGSDI_EONS_IGNORE_DISPLAY_COND_NONE;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

#if !defined(FEATURE_WCDMA) && !defined(FEATURE_GSM) && !defined(FEATURE_LTE)
  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

#else
  req_msg  = ( nas_get_plmn_name_req_msg_v01 *)modem_mem_alloc(sizeof(nas_get_plmn_name_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0, sizeof(nas_get_plmn_name_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_GET_PLMN_NAME_REQ_MSG_V01,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_get_plmn_name_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0044_req_check(req_msg);
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      qmi_session = QMI_NAS_MMGSDI_GW_SEC_SESSION;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
      qmi_session = QMI_NAS_MMGSDI_GW_TER_SESSION;
    }
#endif
#endif

    if ( !(req_msg->suppress_sim_error_valid && (req_msg->suppress_sim_error == TRUE)) )
    {
      if ( qmi_nasi_global.mmgsdi.operation_ready[qmi_session] == FALSE )
      {
        errval = QMI_ERR_SIM_NOT_INITIALIZED_V01;
      }
    }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    /*-------------------------------------------------------------------------
      check the provided PLMN
      -------------------------------------------------------------------------*/
    if ( !sys_plmn_set_mcc_mnc( (req_msg->mnc_includes_pcs_digit_valid ? req_msg->mnc_includes_pcs_digit : req_msg->plmn.mnc>99), (uint32)req_msg->plmn.mcc, (uint32)req_msg->plmn.mnc, &plmn) )
    {
      errval = QMI_ERR_INVALID_ARG_V01;
    }
    else
    {
      plmn_id_list.num_of_plmn_ids = 1;
      memscpy(&plmn_id.plmn_id_val, sizeof(plmn_id.plmn_id_val), 
              &plmn.identity, sizeof(plmn_id.plmn_id_val));
      plmn_id.csg_id = SYS_CSG_ID_INVALID;
#ifdef FEATURE_FEMTO_CSG
      if( qm_efs_csg_supported() && req_msg->csg_id_valid )
      {
        plmn_id.csg_id = req_msg->csg_id;
      }
#endif
      plmn_id.rat = (req_msg->rat_valid ? qmi_nas_rat_qmi_to_mmgsdi( req_msg->rat ) : MMGSDI_RAT_NONE);
      plmn_id_list.plmn_list_ptr = &plmn_id;

      callback_data = (struct qmi_nasi_mmgsdi_client_data_s*)modem_mem_alloc(sizeof(struct qmi_nasi_mmgsdi_client_data_s), MODEM_MEM_CLIENT_QMI_MMODE );
      if( callback_data != NULL )
      {
        callback_data->reason = NAS_CMD_GET_PLMN_NAME;
        callback_data->cmd_buf_ptr = cmd_buf_p;
        callback_data->send_all_info = FALSE;

        if( req_msg->use_static_table_only_valid && (req_msg->use_static_table_only == TRUE) )
        {
          if( MMGSDI_SUCCESS != mmgsdi_get_se13_plmn_names( qmi_nasi_global.mmgsdi.client_id,
                                                            plmn_id_list,
                                                            qmi_nas_mmgsdi_cmd_rsp_cb,
                                                            (uint32) callback_data ) )
          {
            errval = QMI_ERR_INTERNAL_V01;
            modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
          }
        }
        else
        {
          if ( req_msg->send_all_information_valid && (req_msg->send_all_information == TRUE) )
          {
            ignore_disp = MMGSDI_EONS_IGNORE_SPN_RPLMN_DISPLAY_COND;
            callback_data->send_all_info = TRUE;
          }
          else if ( req_msg->always_send_plmn_name_valid && (req_msg->always_send_plmn_name == TRUE) )
          {
            ignore_disp = MMGSDI_EONS_IGNORE_RPLMN_DISPLAY_COND;
          }

          if( MMGSDI_SUCCESS != mmgsdi_session_get_operator_name_ext ( qmi_nasi_global.mmgsdi.session_id[qmi_session],
                                                                       plmn_id_list,
                                                                       ignore_disp,
                                                                       qmi_nas_mmgsdi_cmd_rsp_cb,
                                                                       (uint32) callback_data ) )
          {
            errval = QMI_ERR_INTERNAL_V01;
            modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
          }
        }
      }
      else
      {
        //Can't allocate memory
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
  }
#endif

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    nas_get_plmn_name_resp_msg_v01 *rsp_msg;

    rsp_msg  = ( nas_get_plmn_name_resp_msg_v01 *)modem_mem_alloc(sizeof(nas_get_plmn_name_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

    if ( rsp_msg != NULL )
    {
      memset( rsp_msg, 0x00, sizeof(nas_get_plmn_name_resp_msg_v01) );
    
      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t)QMI_NAS_GET_PLMN_NAME_RESP_MSG_V01,
                                    (void *)rsp_msg,
                                    (uint32_t)sizeof(nas_get_plmn_name_resp_msg_v01),
                                    &response
                                  );

      modem_mem_free((void *)rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE);
    }
    else
    {
      /*Not enough memory to allocate for QMI_NAS_GET_PLMN_NAME response*/
	qmi_voice_mem_error();
    }
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_get_plmn_name */

/*===========================================================================
  FUNCTION qmi_nasi_get_operator_name_data()

  DESCRIPTION
    This message retrieves operator name data from multiple sources, including
    the card and NITZ 4 (Network Identity and Time Zone) information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_operator_name_data
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  nas_get_operator_name_data_resp_msg_v01 *rsp_msg;
  mmgsdi_session_type_enum_type session = MMGSDI_GW_PROV_PRI_SESSION;
  sys_mm_information_s_type    *p_mm_info = NULL;

  ASSERT(sp); ASSERT(cmd_buf_p); ASSERT(cl_sp); ASSERT(sdu_in);

  rsp_msg  = ( nas_get_operator_name_data_resp_msg_v01 *) 
  	               QMI_NAS_MEM_ALLOC( sizeof(nas_get_operator_name_data_resp_msg_v01) );

  if(NULL == rsp_msg)
  {
    qmi_voice_mem_fatal();
    return NULL;
  }
  memset (rsp_msg, 0x00, sizeof(nas_get_operator_name_data_resp_msg_v01));

  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY )
  {
    session = MMGSDI_GW_PROV_PRI_SESSION;
    if( qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].number_of_stacks > 1 && 
        qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE )
    {
      p_mm_info = &qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information;
    }
    else
    {
      p_mm_info = &qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information;
    }
  }
#ifdef FEATURE_DUAL_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    session = MMGSDI_GW_PROV_SEC_SESSION;
    p_mm_info = &qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information;
  }
#endif
  else
  {
    QM_MSG_ERROR_1("invalid binding %d", ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
    {
      QM_MSG_ERROR_1("NAS not initialized %d", qmi_nasi_global.inited);
      errval = QMI_ERR_INTERNAL;
    }
    else if ( !TARGET_SUPPORTS_GSM && !TARGET_SUPPORTS_WCDMA && !TARGET_SUPPORTS_LTE )
    {
      QM_MSG_ERROR_1("unsupported target %d", qmi_nasi_global.cm_ph_info.mode_capability);
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    }
    else if ((qmi_nas_mmgsdi_ef_ready ( session,
                                        QMI_NAS_MMGSDI_BITMAP_EF_SPN |
                                        QMI_NAS_MMGSDI_BITMAP_EF_OPL |
                                        QMI_NAS_MMGSDI_BITMAP_EF_PNN |
                                        QMI_NAS_MMGSDI_BITMAP_EF_ONS ) == FALSE )  &&
              !p_mm_info->short_name_avail                                         &&
              !p_mm_info->full_name_avail
            )
    {
      QM_MSG_ERROR("EF not ready for read");
      errval = QMI_ERR_INFO_UNAVAILABLE;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    struct qmi_nas_mmgsdi_cache_s *p_cache = &qmi_nasi_global.mmgsdi.cache[session]; // shorthand
    nas_operator_name_data_ind_msg_v01 * rsp_msg_t10  = (nas_operator_name_data_ind_msg_v01 * )&rsp_msg->service_provider_name_valid;

    if ( p_cache->ef_spn_valid == QMI_NAS_MMGSDI_VALID )
    {
      qmi_nas_populate_spn_from_cache( rsp_msg_t10, session );
    }

    if ( p_cache->ef_opl_valid == QMI_NAS_MMGSDI_VALID )
    {
      qmi_nas_populate_opl_from_cache(  rsp_msg_t10, session );
    }

    if ( p_cache->ef_pnn_valid == QMI_NAS_MMGSDI_VALID )
    {
      qmi_nas_populate_pnn_from_cache(  rsp_msg_t10, session );
    }

    if ( p_cache->ef_ons_valid == QMI_NAS_MMGSDI_VALID )
    {
      qmi_nas_populate_ons_from_cache(  rsp_msg_t10, session );
    }

    qmi_nas_populate_nw_name_from_nitz( rsp_msg_t10, p_mm_info );

    if ( !rsp_msg->service_provider_name_valid && // EF exists but no valid contents
         !rsp_msg->operator_plmn_list_valid &&
         !rsp_msg->plmn_network_name_valid &&
         !rsp_msg->plmn_name_valid &&
         !rsp_msg->nitz_information_valid )
    {
      QM_MSG_HIGH("no valid contents");
      errval = QMI_ERR_INFO_UNAVAILABLE;
    }
  }

  if( cmd_buf_p != NULL )
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_operator_name_data_resp_msg_v01),
                                  &response
                                );
  }

  
  if ( rsp_msg != NULL ) { QMI_NAS_MEM_FREE( (void *) rsp_msg ); }
  
  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_MODE_PREF()

  DESCRIPTION
    This messages retrieves the mode_pref from the NV

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_mode_pref(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_type_v01      errval   = QMI_ERR_NONE_V01;
  struct nas_0049_rsp_s rsp_msg;
  nv_item_type          nv_item;
  struct access_tech_s  access_tech;
  int                   i;
  nv_stat_enum_type     nv_status;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  memset( &rsp_msg, 0x00, sizeof(struct nas_0049_rsp_s) );

  for ( i=0; i<=1; i++ )
  {
    memset( &nv_item, 0x00, sizeof(nv_item_type) );

    nv_status = (nv_stat_enum_type) qmi_mmode_get_nv_item_ext( NV_PREF_MODE_I, &nv_item, i );

    if ( nv_status == NV_DONE_S )
    {
      if ( qmi_nas_get_supported_technology_from_nv_pref_mode( nv_item.pref_mode.mode, &access_tech ) )
      {
        uint16  *p_mode_pref;
        boolean *p_is_valid;

        p_mode_pref = i == 0 ? &rsp_msg.t10.mode_pref_0 : &rsp_msg.t11.mode_pref_1;
        p_is_valid  = i == 0 ? &rsp_msg.t10_valid       : &rsp_msg.t11_valid;

        if ( access_tech.c ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_CDMA2000_1X_V01;   }
        if ( access_tech.h ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_CDMA2000_HRPD_V01; }
        if ( access_tech.g ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_GSM_V01;           }
        if ( access_tech.w ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_UMTS_V01;          }
        if ( access_tech.l ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_LTE_V01;           }
        if ( access_tech.t ) { *p_mode_pref |= QMI_NAS_RAT_MODE_PREF_TDSCDMA_V01;       }

        *p_is_valid = TRUE;
      }
      else
      {
        QM_MSG_ERROR_2("unsupported nv mode pref %d %d", nv_item.pref_mode.mode, i);
      }
    }
    else
    {
      QM_MSG_ERROR_2("nv read failure %d %d", nv_status, i);
    }
  }

  if ( !rsp_msg.t10_valid && !rsp_msg.t11_valid )
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

  rsp_msg.t02.result_code = errval == QMI_ERR_NONE_V01 ?  QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0049_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
}

/*===========================================================================
  FUNCTION qmi_nas_operator_name_data_ind()

  DESCRIPTION
    This message sends indication for operator name data from multiple sources,
    including the card and NITZ (Network Identity and Time Zone) information.

  PARAMETERS
    nitz_changed: flag to indicate NITZ information changed

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_operator_name_data_ind( mmgsdi_session_type_enum_type session, sys_mm_information_s_type *p_mm_info )
{
  nas_operator_name_data_ind_msg_v01 *ind_msg; // reuse message 0x39 as they have same data
  enum qmi_nas_subs_e   bound_subs = QMI_NAS_SUBS_PRIMARY;

  struct qmi_nas_mmgsdi_cache_s *p_cache;

  if ( session == MMGSDI_GW_PROV_PRI_SESSION || session == MMGSDI_GW_PROV_SEC_SESSION )
  {
    p_cache = &qmi_nasi_global.mmgsdi.cache[session]; // shorthand
#ifdef FEATURE_DUAL_SIM
    bound_subs = session == MMGSDI_GW_PROV_PRI_SESSION ? QMI_NAS_SUBS_PRIMARY : QMI_NAS_SUBS_SECONDARY;
#endif
  }
  else
  {
    QM_MSG_ERROR_1("invalid session %d", session);
    return;
  }

  ind_msg  = ( nas_operator_name_data_ind_msg_v01 *) 
  	QMI_NAS_MEM_ALLOC( sizeof(nas_operator_name_data_ind_msg_v01) );
  if(NULL == ind_msg)
  {
    qmi_voice_mem_fatal();    
    return;
  }  
  memset (ind_msg, 0x00, sizeof(nas_operator_name_data_ind_msg_v01));

  if ( p_cache->ef_spn_valid == QMI_NAS_MMGSDI_VALID && p_cache->ef_spn_changed )
  {
    qmi_nas_populate_spn_from_cache(ind_msg, session );
  }

  if ( p_cache->ef_opl_valid == QMI_NAS_MMGSDI_VALID && p_cache->ef_opl_changed )
  {
    qmi_nas_populate_opl_from_cache( ind_msg, session );
  }

  if ( p_cache->ef_pnn_valid == QMI_NAS_MMGSDI_VALID && p_cache->ef_pnn_changed )
  {
    qmi_nas_populate_pnn_from_cache( ind_msg, session );
  }

  if ( p_cache->ef_ons_valid == QMI_NAS_MMGSDI_VALID && p_cache->ef_ons_changed )
  {
    qmi_nas_populate_ons_from_cache( ind_msg, session );
  }

  if ( p_mm_info != NULL )
  {
    qmi_nas_populate_nw_name_from_nitz( ind_msg, p_mm_info );
  }

  // pack ind message

  if ( ind_msg->service_provider_name_valid ||
       ind_msg->operator_plmn_list_valid ||
       ind_msg->plmn_network_name_valid ||
       ind_msg->plmn_name_valid ||
       ind_msg->nitz_information_valid )
  {
    dsm_item_type       *response;
    int                  clid;
    qmi_nasi_client_state_type *cl_sp;

    for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
    {
      cl_sp = qmi_nas_state.client[clid];

      if ( cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED && cl_sp->report_status.bound_subs == bound_subs &&
             cl_sp->report_status.report_operator_name_data)
        {
          response = NULL;

          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_INDICATION,
                                                    QMI_NAS_OPERATOR_NAME_DATA_IND_MSG_V01,
                                                    (void *) ind_msg,
                                                    (uint32_t) sizeof( nas_operator_name_data_ind_msg_v01 ),
                                                    &response
                                                   )
            )
          {
            qmi_nasi_send_ind( cl_sp, (uint16)QMI_NAS_OPERATOR_NAME_DATA_IND_MSG_V01, response );
          }
          else
          {
             QM_MSG_ERROR("failed to send SYSTEM_SELECTION_PREFERENCE_IND ind");
        }
      }
    }
  }
  else
  {
    QM_MSG_HIGH("no real change");
  }
  
  if ( ind_msg  != NULL ) { QMI_NAS_MEM_FREE( (void *) ind_msg ); }
  
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_CSP_LMN_MODE_BIT()
===========================================================================*/
static dsm_item_type* qmi_nasi_get_csp_plmn_mode_bit
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  boolean               retval;
  qmi_result_e_type     result;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  struct nas_003B_rsp_s msg;
  qmi_nas_mmgsdi_session_e_type qmi_session = QMI_NAS_MMGSDI_GW_PRI_SESSION;

  ASSERT(sp); ASSERT(cmd_buf_p); ASSERT(cl_sp); ASSERT(sdu_in);

  memset (&msg, 0x00, sizeof(msg));

  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY )
  {
    qmi_session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
  }
  #ifdef FEATURE_DUAL_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    qmi_session = QMI_NAS_MMGSDI_GW_SEC_SESSION;
  }
  #endif
  #ifdef FEATURE_TRIPLE_SIM    
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
  {
    qmi_session = QMI_NAS_MMGSDI_GW_TER_SESSION;
  }
  #endif
  else
  {
    QM_MSG_ERROR_1("invalid binding %d", ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    if(!qmi_nasi_get_csp_plmn_mode_val( qmi_session, &errval, &msg.t10.plmn_mode ))
    {
      if(qmi_nasi_global.mmgsdi.csp_req_buffer_valid)
      {
        QM_MSG_ERROR("EF not ready for read. Request already queued (not ready).");
        errval = QMI_ERR_DEVICE_NOT_READY;
      }
      else
      {
        QM_MSG_HIGH("EF not ready for read. Queueing request.");
        qmi_nasi_global.mmgsdi.csp_req_buffer_valid = TRUE;
        qmi_nasi_global.mmgsdi.csp_req_buffer = (qmi_cmd_buf_type*)cmd_buf_p;
        qmi_nasi_global.mmgsdi.csp_req_buffer_session = qmi_session;
        return QMI_SVC_RESPONSE_PENDING;
      }
    }
  }

  // pack response message

  if ( errval == QMI_ERR_NONE )
  {
    msg.t10_valid = TRUE;
    if ( !qmi_svc_put_param_tlv( &response, NAS_003B_RSP_T10, sizeof(msg.t10.plmn_mode), &(msg.t10.plmn_mode) ) )
    {
      QM_MSG_ERROR("error while packaging response");
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);

  if ((errval != QMI_ERR_NONE) && (response != NULL))
  {
    dsm_free_packet(&response);
  }
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();
  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_CSP_PLMN_MODE_VAL()

  DESCRIPTION
    Extract plmn mode from cached efs

  PARAMETERS
    qmi_session   : qmi subscription
    errval_p      : error type
    plmn_mode_p   : extracted plmn mode

  RETURN VALUE
    False if we need to queue the request(sim not ready), TRUE if 
    extraction was attempted, whether it succeeded or not

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

boolean qmi_nasi_get_csp_plmn_mode_val( qmi_nas_mmgsdi_session_e_type qmi_session, qmi_error_e_type* errval_p, uint8* plmn_mode_p )
{
  boolean found_val = FALSE;
  uint32                i;
  
    if ( qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
    {
      QM_MSG_ERROR_1("NAS not initialized %d", qmi_nasi_global.inited);
    *errval_p = QMI_ERR_INTERNAL;
    }
    else if ( !TARGET_SUPPORTS_GSM && !TARGET_SUPPORTS_WCDMA && !TARGET_SUPPORTS_LTE )
    {
      QM_MSG_ERROR_1("unsupported target %d", qmi_nasi_global.cm_ph_info.mode_capability);
    *errval_p = QMI_ERR_OP_DEVICE_UNSUPPORTED;
    }
    else if ( qmi_nasi_global.mmgsdi.operation_ready[qmi_session] == FALSE )
    {
      QM_MSG_ERROR("SIM was not Initialized");
    *errval_p = QMI_ERR_SIM_NOT_INITIALIZED;
    }
    else if ( qmi_nasi_global.mmgsdi.cache[qmi_session].ef_csp_valid == QMI_NAS_MMGSDI_ERROR )
    {
      QM_MSG_ERROR("EF does not exist");
    *errval_p = QMI_ERR_SIM_FILE_NOT_FOUND;
    }
    else if ( qmi_nas_mmgsdi_ef_ready( qmi_session, QMI_NAS_MMGSDI_BITMAP_EF_CSP ) == FALSE )
    {
    return FALSE;
  }

  if ( *errval_p == QMI_ERR_NONE )
  {
    struct qmi_nas_mmgsdi_cache_s *p_cache = &qmi_nasi_global.mmgsdi.cache[qmi_session]; // shorthand

    if ( p_cache->ef_csp_valid == QMI_NAS_MMGSDI_VALID )
    {
#define QMI_NAS_VALUE_ADDED_SERVICE_CODE  (0xC0)  // per CPHS Phase2 ver 4.2 cl. B.4.7.1
#define QMI_NAS_PLMN_MODE_BIT             (0x80)  // per CPHS Phase2 ver 4.2 cl. B.4.7.1
      for ( i=0; i<p_cache->ef_csp_size; i+=2 )
      {
        if ( p_cache->ef_csp[i] == QMI_NAS_VALUE_ADDED_SERVICE_CODE )
        {
          if ( p_cache->ef_csp[i+1] & QMI_NAS_PLMN_MODE_BIT )
            *plmn_mode_p = NAS_003B_RSP_T10_PLMN_MODE_DO_NOT_RESTRICT;
          else
            *plmn_mode_p = NAS_003B_RSP_T10_PLMN_MODE_RESTRICT;

          QM_MSG_HIGH_2("found VAS code with value %d in %dth byte", p_cache->ef_csp[i+1], i);
          found_val = TRUE;
          break;
        }
      }
    }
    else
    {
      QM_MSG_ERROR("ef csp not in valid state");
    }
  }

  if ( !found_val && *errval_p == QMI_ERR_NONE ) // EF exists but no valid contents
  {
    QM_MSG_HIGH("no valid contents");
    *errval_p = QMI_ERR_INTERNAL;
  }
  return TRUE;
}

/*===========================================================================
  FUNCTION QMI_NAS_CSP_POMN_MODE_BIT_IND()
===========================================================================*/
void qmi_nas_csp_plmn_mode_bit_ind( mmgsdi_session_type_enum_type session )
{
  struct nas_003B_rsp_s msg; // reuse message
  uint32                i;
  struct qmi_nas_mmgsdi_cache_s *p_cache;
  enum qmi_nas_subs_e            bound_subs = QMI_NAS_SUBS_PRIMARY;
  qmi_nas_mmgsdi_session_e_type qmi_session;

  if ( qmi_nas_mmgsdi_is_valid_3gpp_session(session) )
  {
    qmi_session = qmi_nas_map_mmgsdi_session_to_qmi(session);
    p_cache = &qmi_nasi_global.mmgsdi.cache[qmi_session]; // shorthand

    switch (session)
    {
      case MMGSDI_GW_PROV_PRI_SESSION:
        bound_subs = QMI_NAS_SUBS_PRIMARY;
        break;
#ifdef FEATURE_DUAL_SIM
      case MMGSDI_GW_PROV_SEC_SESSION:
        bound_subs = QMI_NAS_SUBS_SECONDARY;
        break;
#endif
#ifdef FEATURE_TRIPLE_SIM
      case MMGSDI_GW_PROV_TER_SESSION:
        bound_subs = QMI_NAS_SUBS_TERTIARY;
        break;
#endif
      default:
        break;
    }
  }
  else
  {
    QM_MSG_ERROR_1("invalid session %d", session);
    return;
  }

  memset (&msg, 0x00, sizeof(msg));

  if ( p_cache->ef_csp_valid == QMI_NAS_MMGSDI_VALID && p_cache->ef_csp_changed )
  {
    for ( i=0; i<p_cache->ef_csp_size; i+=2 )
    {
      if ( p_cache->ef_csp[i] == QMI_NAS_VALUE_ADDED_SERVICE_CODE )
      {
        if ( p_cache->ef_csp[i+1] & QMI_NAS_PLMN_MODE_BIT )
          msg.t10.plmn_mode = NAS_003B_RSP_T10_PLMN_MODE_DO_NOT_RESTRICT;
        else
          msg.t10.plmn_mode = NAS_003B_RSP_T10_PLMN_MODE_RESTRICT;

        QM_MSG_HIGH_2("found VAS code with value %d in %dth byte", p_cache->ef_csp[i+1], i);
        msg.t10_valid = TRUE;
        break;
      }
    }
  }
  else
  {
    QM_MSG_ERROR("ef csp not in valid state");
  }

  // pack response message
  if ( msg.t10_valid )
  {
    dsm_item_type              *response;
    boolean                     success = TRUE;
    uint8                       client;
    qmi_nasi_client_state_type *cl_sp;

    for ( client=0; client<NASI_MAX_CLIDS; client++, cl_sp++ )
    {
      cl_sp = qmi_nas_state.client[client];

      if ( cl_sp && cl_sp->common.clid != NASI_CLID_UNUSED && cl_sp->report_status.bound_subs == bound_subs &&
             cl_sp->report_status.report_csp_plmn_mode_bit )
        {
          response = NULL;
        success = TRUE;

          if ( msg.t10_valid ) // leave this check as it will be needed later when new TLVs get added
          {
            if ( !qmi_svc_put_param_tlv( &response, NAS_003B_RSP_T10, sizeof(msg.t10.plmn_mode), &msg.t10.plmn_mode ) )
            {
              QM_MSG_ERROR("error while packaging response");
              dsm_free_packet(&response);
              success = FALSE;
            }
          }

          if ( success )
          {
          qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_CSP_PLMN_MODE_BIT_IND, response );
        }
      }
    }
  }
  else // EF exists but no valid contents
  {
    QM_MSG_HIGH("no real change");
  }
}

/*===========================================================================
  FUNCTION QMI_NASI_RESET_CLIENT()

  DESCRIPTION
    Resets the state for the given client

  PARAMETERS
    cl_sp :  client state pointer

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_reset_client( void *cl_sp_in )
{
  qmi_nasi_client_state_type * cl_sp;

  cl_sp = (qmi_nasi_client_state_type *)cl_sp_in;

  qmi_mmode_svc_reset_common_client( &(cl_sp->common) );

  qm_nas_clnt_reset_info( cl_sp->common.clid );

  qm_cbpq_del_invalid_items( QM_CBPQ_QTYPE_NW_SCAN );

  /*-------------------------------------------------------------------------
    Free resources for client
    Remove any pending commmands for this client from the pending q's
    Clear pending msg transactions and partially bundled responses
  -------------------------------------------------------------------------*/
  qm_cbpq_del_client_items( QM_CBPQ_QTYPE_NW_SCAN, cl_sp->common.clid );

} /* qmi_nasi_reset_client() */

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
/*===========================================================================
  FUNCTION NASI_CONVERT_MM_INFO_OPER_NAME()

  DESCRIPTION
      This function converts the operator name received from NAS
      mobility management message into suitable format for TE
      presentation.  The IRA character set is the assumed output format.
      Mimiced ATCOP local function etsicall_convert_mminfo_oper_name()

  PARAMETERS
    name_ptr    - Network Name from ss_info
    in_scheme   - Coding scheme to be converted from
    out_ptr     - Network name to be returned to client
    out_scheme  - Coding scheme converted to
    max_len     - Max length allowed to be converted
    encoded_len - Length of the network name to be converted

  RETURN VALUE
    TRUE:  Successful conversion
    FALSE: Otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean nasi_convert_mm_info_oper_name
(
  uint8                                      * name_ptr,
  mmgsdi_eons_encoding_enum_type   in_scheme,
  char                                       * out_ptr,
  uint8                          * out_scheme,
  uint8                                        max_len,
  uint8                                        encoded_len
)
{
  uint8 num_chars;
  uint8 tmp_buf[SYS_MAX_SHORT_NAME_CHARS] = { 0 };
  uint16 conv_success;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  QM_MSG_HIGH_3("nasi_convert_mm_info_oper_name with in_scheme = %d, max_len = %d, encoded_len = %d", in_scheme, max_len, encoded_len);

  if (!encoded_len || !max_len || !out_scheme)
  {
    QM_MSG_HIGH_3("nasi_convert_mm_info_oper_name: encoded_len %d max_len %d out_scheme %d", encoded_len, max_len, out_scheme);
    return FALSE;
  }

  /* Translate coding scheme */
  switch( in_scheme )
  {
    case MMGSDI_EONS_ENC_UCS2:
      memscpy( tmp_buf, encoded_len, name_ptr, encoded_len );
      convert_endianness16( tmp_buf, encoded_len );
        // CM sends UCS2 in big endian. dsatutil_convert_chset is expecting little endian

      /* Convert from OTA coding scheme, assuming IRA output */
      num_chars = MIN(encoded_len/2+1, max_len); /* UCS2 is 16 bits per char */
      conv_success = cm_util_utf16_to_gsm7((uint16 *) tmp_buf, num_chars, (uint8 *) out_ptr, max_len, NULL);
      if( conv_success == CHR_CVRT_SUCCESS )
      {
        *out_scheme = (uint8)NASI_PLMN_NAME_ENC_GSM_DEFAULT;
      }
      else
      {
        memscpy( out_ptr, MIN(encoded_len, max_len), tmp_buf, MIN(encoded_len, max_len) );
        *out_scheme = (uint8)NASI_PLMN_NAME_ENC_UCS2_16;
      }
      break;

    case MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED:
      encoded_len = MIN(encoded_len, max_len);
      (void) cm_util_gsm7_unpack_remove_suspected_padding( name_ptr, encoded_len,
                                                           (byte *) out_ptr, max_len, NULL);
      *out_scheme = (uint8)NASI_PLMN_NAME_ENC_GSM_DEFAULT;
            break;

    case MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED:
      encoded_len = MIN(encoded_len, max_len);
      memscpy( out_ptr, encoded_len, name_ptr, encoded_len );
      *out_scheme = (uint8)NASI_PLMN_NAME_ENC_GSM_DEFAULT;
            break;

          default:
      QM_MSG_ERROR("Detected unsupported encoding");
  return FALSE;
      }
    return TRUE;
} /* nasi_convert_mm_info_oper_name */

#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */

#if defined(FEATURE_MMGSDI_SESSION_LIB)
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE)
/*===========================================================================
  FUNCTION QMI_NASI_POPULATE_GET_PREFERRED_NW_RESP()

  DESCRIPTION
    Function to populate response for NASI_CMD_VAL_GET_PREFERRED_NETWORKS

  PARAMETERS
    cnf_data : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_populate_get_preferred_nw_resp
(
   nas_get_preferred_networks_resp_msg_v01 *nas_get_pref_resp
)
{
  uint16             i;
  uint16             num_entries;
  qmi_nasi_mmgsdi_plmn_wact_type *plmn_iter;
  boolean            plmn_is_undefined = FALSE;
  boolean            mnc_includes_pcs_digit = FALSE;
  sys_mcc_type       mcc = 0;
  sys_mnc_type       mnc = 0;

  memset(nas_get_pref_resp, 0, sizeof(nas_get_preferred_networks_resp_msg_v01) );

  /* If at least one of PLMN_WACT and OPLMN_WACT has been read, we can send out the
   * response. The response for PLMN (without ACT) can be ignored. */
  if ( (qmi_nasi_global.pref_nw_scratch.plmn_wact  == QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ) ||
       (qmi_nasi_global.pref_nw_scratch.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ) )
  {
    if (qmi_nasi_global.pref_nw_scratch.plmn_wact == QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ)
    {
      nas_3gpp_preferred_networks_type_v01 *p_net_info;
      nas_mnc_pcs_digit_include_status_type_v01 *p_mnc_info;

      nas_get_pref_resp->nas_3gpp_preferred_networks_valid = TRUE;
      nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_valid = TRUE;
      nas_get_pref_resp->nas_3gpp_preferred_networks_len = 0;
      nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_len = 0;
      num_entries = qmi_nasi_global.pref_nw_scratch.plmn_wact_list_size;
      for (i = 0;
           (i < num_entries) &&
             (nas_get_pref_resp->nas_3gpp_preferred_networks_len < SYS_USER_PPLMN_LIST_MAX_LENGTH) ;
           i++)
      {
        p_net_info = &nas_get_pref_resp->nas_3gpp_preferred_networks[nas_get_pref_resp->nas_3gpp_preferred_networks_len];
        p_mnc_info = &nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit[nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_len];
        plmn_iter  = &qmi_nasi_global.pref_nw_scratch.plmn_wact_list[i];

        if(!sys_plmn_id_is_undefined(plmn_iter->plmn))
        {
          sys_plmn_get_mcc_mnc(plmn_iter->plmn, &plmn_is_undefined, &mnc_includes_pcs_digit, &mcc, &mnc);
          QM_MSG_HIGH_3("plmn(%d), mcc:%d, mnc%d", i, mcc, mnc);

          p_net_info->mobile_country_code     = (uint16) mcc;
          p_net_info->mobile_network_code     = (uint16) mnc;
          p_net_info->radio_access_technology = 0;

          p_net_info->radio_access_technology |= (plmn_iter->act[0] & 0x80) << 8; // 1000 0000 0000 0000 UMTS
          p_net_info->radio_access_technology |= (plmn_iter->act[0] & 0x40) << 8; // 0100 0000 0000 0000 LTE
          p_net_info->radio_access_technology |=  plmn_iter->act[1] & 0x80;       // 0000 0000 1000 0000 GSM
          p_net_info->radio_access_technology |=  plmn_iter->act[1] & 0x40;       // 0000 0000 0100 0000 GSM compact

          nas_get_pref_resp->nas_3gpp_preferred_networks_len++;

          p_mnc_info->mcc = mcc;
          p_mnc_info->mnc = mnc;
          p_mnc_info->mnc_includes_pcs_digit = (uint8_t) mnc_includes_pcs_digit;

          nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_len++;
        }
      }
    }

    if (qmi_nasi_global.pref_nw_scratch.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ)
    {
      nas_3gpp_preferred_networks_type_v01 *p_net_info;
      nas_mnc_pcs_digit_include_status_type_v01 *p_mnc_info;

      nas_get_pref_resp->static_3gpp_preferred_networks_valid = TRUE;
      nas_get_pref_resp->static_3gpp_mnc_includes_pcs_digit_valid = TRUE;
      nas_get_pref_resp->static_3gpp_preferred_networks_len = 0;
      nas_get_pref_resp->static_3gpp_mnc_includes_pcs_digit_len = 0;
      num_entries = qmi_nasi_global.pref_nw_scratch.oplmn_wact_list_size;
      for (i = 0;
           (i < num_entries) &&
             (nas_get_pref_resp->static_3gpp_preferred_networks_len < SYS_PLMN_LIST_MAX_LENGTH) ;
           i++)
      {
        p_net_info = &nas_get_pref_resp->static_3gpp_preferred_networks[nas_get_pref_resp->static_3gpp_preferred_networks_len];
        p_mnc_info = &nas_get_pref_resp->static_3gpp_mnc_includes_pcs_digit[nas_get_pref_resp->static_3gpp_mnc_includes_pcs_digit_len];
        plmn_iter  = &qmi_nasi_global.pref_nw_scratch.oplmn_wact_list[i];

        if(!sys_plmn_id_is_undefined(plmn_iter->plmn))
        {
          sys_plmn_get_mcc_mnc(plmn_iter->plmn,
                               &plmn_is_undefined,
                               &mnc_includes_pcs_digit,
                               &mcc,
                               &mnc);
          QM_MSG_HIGH_3("plmn(%d), mcc:%d, mnc%d", i, mcc, mnc);

          p_net_info->mobile_country_code     = (uint16) mcc;
          p_net_info->mobile_network_code     = (uint16) mnc;
          p_net_info->radio_access_technology = 0;

          p_net_info->radio_access_technology |= (plmn_iter->act[0] & 0x80) << 8; // 1000 0000 0000 0000 UMTS
          p_net_info->radio_access_technology |= (plmn_iter->act[0] & 0x40) << 8; // 0100 0000 0000 0000 LTE
          p_net_info->radio_access_technology |=  plmn_iter->act[1] & 0x80;       // 0000 0000 1000 0000 GSM
          p_net_info->radio_access_technology |=  plmn_iter->act[1] & 0x40;       // 0000 0000 0100 0000 GSM compact

          nas_get_pref_resp->static_3gpp_preferred_networks_len++;

          p_mnc_info->mcc = mcc;
          p_mnc_info->mnc = mnc;
          p_mnc_info->mnc_includes_pcs_digit = (uint8_t) mnc_includes_pcs_digit;

          nas_get_pref_resp->static_3gpp_mnc_includes_pcs_digit_len++;
        }
      }
    }
  }
  /* If all other checks have failed, it means that only the PLMN file
   * (without ACT) was read successfully. We need to construct our response
   * accordingly. */
  else
  {
    nas_3gpp_preferred_networks_type_v01 *p_net_info;
    nas_mnc_pcs_digit_include_status_type_v01 *p_mnc_info;

    nas_get_pref_resp->nas_3gpp_preferred_networks_valid = TRUE;
    nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_valid = TRUE;
    nas_get_pref_resp->nas_3gpp_preferred_networks_len = 0;
    nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_len = 0;
    num_entries = qmi_nasi_global.pref_nw_scratch.plmn_list_size;
    for (i = 0;
         (i < num_entries) &&
           (nas_get_pref_resp->nas_3gpp_preferred_networks_len < SYS_PLMN_LIST_MAX_LENGTH) ;
         i++)
    {
      p_net_info = &nas_get_pref_resp->nas_3gpp_preferred_networks[nas_get_pref_resp->nas_3gpp_preferred_networks_len];
      p_mnc_info = &nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit[nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_len];

      if(!sys_plmn_id_is_undefined(
            qmi_nasi_global.pref_nw_scratch.plmn_list[i]))
      {
        sys_plmn_get_mcc_mnc(  qmi_nasi_global.pref_nw_scratch.plmn_list[i],
                              &plmn_is_undefined,
                              &mnc_includes_pcs_digit,
                              &mcc,
                              &mnc);
        QM_MSG_MED_3("plmn(%d), mcc:%d, mnc%d", i, mcc, mnc);

        p_net_info->mobile_country_code     = (uint16) mcc;
        p_net_info->mobile_network_code     = (uint16) mnc;
        p_net_info->radio_access_technology = 0;

        nas_get_pref_resp->nas_3gpp_preferred_networks_len++;

        p_mnc_info->mcc = mcc;
        p_mnc_info->mnc = mnc;
        p_mnc_info->mnc_includes_pcs_digit = (uint8_t) mnc_includes_pcs_digit;

        nas_get_pref_resp->nas_3gpp_mnc_includes_pcs_digit_len++;
      }
    }
  }
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_PREFERRED_NW_RESP()

  DESCRIPTION
    Function to generate response for NASI_CMD_VAL_GET_PREFERRED_NETWORKS

  PARAMETERS
    cnf_data : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_get_preferred_nw_resp
(
  mmgsdi_read_cnf_type       * cnf_data
)
{
  qmi_cmd_buf_type    *cmd_buf_p;
  dsm_item_type       *response;
  qmi_error_type_v01   errval = QMI_ERR_NONE_V01;
  uint16               read_data_len;
  mmgsdi_return_enum_type status;
  nas_get_preferred_networks_resp_msg_v01 *nas_get_pref_resp;

  if (cnf_data == NULL)
  {
    QM_MSG_HIGH("Received NULL cnf_data in GET_PREF_NW callback");
    return;
  }
  status = cnf_data->response_header.mmgsdi_status;
  cmd_buf_p = (qmi_cmd_buf_type *)cnf_data->response_header.client_data;
  if (!qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL)
  {
    QM_MSG_HIGH("Received NULL cmd_buf in GET_PREF_NW callback");
    return;
  }

  if (qmi_nasi_global.get_pref_nwks_req_pending == FALSE)
  {
    QM_MSG_MED("Received an unsolicited read confirmation for NASI_CMD_VAL_GET_PREFERRED_NETWORKS") ;
    return;
  }

  QM_MSG_MED_2("qmi_nasi_generate_get_preferred_nw_resp, file_enum %d, status:%d", cnf_data->access.file.file_enum, status);

  /* Update the scratchpad based on the confirmation. */
  switch (cnf_data->access.file.file_enum)
  {
    case MMGSDI_GSM_PLMN:
      if (qmi_nasi_global.pref_nw_scratch.plmn == QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED)
      {
        if (status == MMGSDI_SUCCESS)
        {
          qmi_nasi_global.pref_nw_scratch.plmn = QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ;

          read_data_len = (uint8) MIN( cnf_data->read_data.data_len, sizeof(sys_plmn_id_s_type) * SYS_PLMN_LIST_MAX_LENGTH );
          qmi_nasi_global.pref_nw_scratch.plmn_list_size = read_data_len / sizeof(sys_plmn_id_s_type);
          qmi_nasi_global.pref_nw_scratch.plmn_list = (sys_plmn_id_s_type*) modem_mem_alloc( read_data_len, MODEM_MEM_CLIENT_QMI_MMODE );

          if (qmi_nasi_global.pref_nw_scratch.plmn_list == NULL)
          {
            errval = QMI_ERR_NO_MEMORY_V01;
          }
          else
          {
            memscpy((void*)qmi_nasi_global.pref_nw_scratch.plmn_list, read_data_len, 
                    cnf_data->read_data.data_ptr, read_data_len );
          }
        }
        else
        {
          qmi_nasi_global.pref_nw_scratch.plmn = QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
        }
      }
      else
      {
        return;
      }
      break;
    case MMGSDI_GSM_PLMNWACT:
    case MMGSDI_USIM_PLMNWACT:
      if (qmi_nasi_global.pref_nw_scratch.plmn_wact == QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED)
      {
        if (status == MMGSDI_SUCCESS)
        {
          qmi_nasi_global.pref_nw_scratch.plmn_wact = QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ;

          read_data_len = (uint8) MIN( cnf_data->read_data.data_len, sizeof(qmi_nasi_mmgsdi_plmn_wact_type) * SYS_USER_PPLMN_LIST_MAX_LENGTH );
          qmi_nasi_global.pref_nw_scratch.plmn_wact_list_size = read_data_len / sizeof(qmi_nasi_mmgsdi_plmn_wact_type);
          qmi_nasi_global.pref_nw_scratch.plmn_wact_list      = (qmi_nasi_mmgsdi_plmn_wact_type*) modem_mem_alloc( read_data_len, MODEM_MEM_CLIENT_QMI_MMODE );

          QM_MSG_MED_2("qmi_nasi_generate_get_preferred_nw_resp:PLMNWACT,  read_data_len%d,size:%d", read_data_len, sizeof(qmi_nasi_mmgsdi_plmn_wact_type));

          if (qmi_nasi_global.pref_nw_scratch.plmn_wact_list == NULL)
          {
            errval = QMI_ERR_NO_MEMORY_V01;
            QM_MSG_MED("modem_mem_alloc is failed");
          }
          else
          {
            memscpy((void*)qmi_nasi_global.pref_nw_scratch.plmn_wact_list, read_data_len,
                    cnf_data->read_data.data_ptr, read_data_len );
          }
        }
        else
        {
          qmi_nasi_global.pref_nw_scratch.plmn_wact = QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
          QM_MSG_MED("QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND");
        }
      }
      else
      {
        return;
      }
      break;
    case MMGSDI_GSM_OPLMNWACT:
    case MMGSDI_USIM_OPLMNWACT:
      if (qmi_nasi_global.pref_nw_scratch.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED)
      {
        if (status == MMGSDI_SUCCESS)
        {
          qmi_nasi_global.pref_nw_scratch.oplmn_wact = QMI_NASI_MMGSDI_PLMN_EF_FOUND_AND_READ;

          read_data_len = (uint8) MIN( cnf_data->read_data.data_len, sizeof(qmi_nasi_mmgsdi_plmn_wact_type) * SYS_PLMN_LIST_MAX_LENGTH );
          qmi_nasi_global.pref_nw_scratch.oplmn_wact_list_size = read_data_len / sizeof(qmi_nasi_mmgsdi_plmn_wact_type);
          qmi_nasi_global.pref_nw_scratch.oplmn_wact_list = (qmi_nasi_mmgsdi_plmn_wact_type*) modem_mem_alloc( read_data_len, MODEM_MEM_CLIENT_QMI_MMODE );

          QM_MSG_MED_2("qmi_nasi_generate_get_preferred_nw_resp:OPLMNWACT,  read_data_len%d,size:%d", read_data_len, sizeof(qmi_nasi_mmgsdi_plmn_wact_type));

          if (qmi_nasi_global.pref_nw_scratch.oplmn_wact_list == NULL)
          {
            errval = QMI_ERR_NO_MEMORY_V01;
            //Can't allocate memory
          }
          else
          {
            memscpy( (void*)qmi_nasi_global.pref_nw_scratch.oplmn_wact_list, read_data_len,
                      cnf_data->read_data.data_ptr, cnf_data->read_data.data_len );
          }
        }
        else
        {
          qmi_nasi_global.pref_nw_scratch.oplmn_wact = QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND;
          QM_MSG_MED("QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND");
        }
      }
      else
      {
        return;
      }
      break;
    default:
      QM_MSG_MED_1("Received unsolicited read confirmation on file %d", cnf_data->access.file.file_enum);
      return;
  }

  if ( errval == QMI_ERR_NONE_V01 &&
       ( (qmi_nasi_global.pref_nw_scratch.plmn_wact  == QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED) ||
         (qmi_nasi_global.pref_nw_scratch.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED) ||
         ( (qmi_nasi_global.pref_nw_scratch.plmn_wact  == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND) &&
           (qmi_nasi_global.pref_nw_scratch.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND) &&
           (qmi_nasi_global.pref_nw_scratch.plmn       == QMI_NASI_MMGSDI_PLMN_EF_READ_REQUESTED) ) ) )
  {
    QM_MSG_MED("Waiting for file read confirmation");
  }
  else
  {
    QM_MSG_MED("Got file read confirmation(s)");
    qm_cbpq_del_invalid_items( QM_CBPQ_QTYPE_GET_PREF );

    nas_get_pref_resp = ( nas_get_preferred_networks_resp_msg_v01 * )modem_mem_alloc(sizeof(nas_get_preferred_networks_resp_msg_v01), MODEM_MEM_CLIENT_QMI);
    if( nas_get_pref_resp == NULL )
    {
      qmi_voice_mem_error();

      while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_GET_PREF )) != NULL )
      {
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
      }
    }
    else
    {
      if ( errval == QMI_ERR_NONE_V01 )
      {
        if ( (qmi_nasi_global.pref_nw_scratch.plmn_wact  == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND) &&
             (qmi_nasi_global.pref_nw_scratch.oplmn_wact == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND) &&
             (qmi_nasi_global.pref_nw_scratch.plmn       == QMI_NASI_MMGSDI_PLMN_EF_NOT_FOUND) )
        {
          errval = QMI_ERR_SIM_FILE_NOT_FOUND_V01;
        }
        else
        {
          qmi_nasi_populate_get_preferred_nw_resp( nas_get_pref_resp );
        }
      }

      qmi_nasi_global.get_pref_nwks_req_pending = FALSE;
      QM_MSG_HIGH("get_pref_nwks_req_pending is set to FALSE");

      nas_get_pref_resp->resp.error  = errval;
      nas_get_pref_resp->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

      while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_GET_PREF )) != NULL )
      {
        response = NULL;                                                                         // Important!  When multiple encode calls may be made.
        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                  QMI_IDL_RESPONSE,
                                                  (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                                  (void *)nas_get_pref_resp,
                                                  (uint32_t)sizeof(nas_get_preferred_networks_resp_msg_v01),
                                                  &response
                                                ) )
        {
          if ( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
          {
            qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
          }
        }
      }

      modem_mem_free((void *)nas_get_pref_resp, MODEM_MEM_CLIENT_QMI);
    }

    if (qmi_nasi_global.pref_nw_scratch.plmn_list != NULL)
    {
      modem_mem_free( qmi_nasi_global.pref_nw_scratch.plmn_list, MODEM_MEM_CLIENT_QMI_MMODE );
    }
    else
    {
       QM_MSG_HIGH("pref_nw_scratch.plmn_list is NULL");
    }
    if (qmi_nasi_global.pref_nw_scratch.plmn_wact_list != NULL)
    {
      modem_mem_free( qmi_nasi_global.pref_nw_scratch.plmn_wact_list, MODEM_MEM_CLIENT_QMI_MMODE );
    }
    else
    {
       QM_MSG_HIGH("pref_nw_scratch.plmn_wact_list is NULL");
    }
    if (qmi_nasi_global.pref_nw_scratch.oplmn_wact_list != NULL)
    {
      modem_mem_free( qmi_nasi_global.pref_nw_scratch.oplmn_wact_list, MODEM_MEM_CLIENT_QMI_MMODE );
    }
    else
    {
       QM_MSG_HIGH("pref_nw_scratch.oplmn_wact_list is NULL");
    }
    QM_MSG_HIGH("Resetting  pref_nw_scratch");
    memset(&qmi_nasi_global.pref_nw_scratch, 0, sizeof(qmi_nasi_global.pref_nw_scratch));
  }
} /* qmi_nasi_generate_get_preferred_nw_resp */

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_FORBIDDEN_NW_RESP()

  DESCRIPTION
    Function to generate response for NASI_CMD_VAL_GET_FORBIDDEN_NETWORKS

  PARAMETERS
    cnf_data : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_get_forbidden_nw_resp
(
  mmgsdi_read_cnf_type       * cnf_data
)
{
  qmi_cmd_buf_type    *cmd_buf_p;
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
  qmi_result_e_type    result = QMI_RESULT_FAILURE;
  mmgsdi_return_enum_type status;
  uint16               read_data_len;
  sys_plmn_id_s_type   fplmn_list[SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH];
  int32                i;
  int32                num_entries;
  struct
  {
    uint16 num_of_networks;
    struct
    {
      uint16 mcc;
      uint16 mnc;
    }network_info[SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH];
  } v_out_networks_list;

  boolean              plmn_is_undefined = FALSE;
  boolean              mnc_includes_pcs_digit = FALSE;
  sys_mcc_type         mcc = 0;
  sys_mnc_type         mnc = 0;
  uint16               networks_list_size;

  if (cnf_data == NULL)
  {
    QM_MSG_HIGH("Received NULL cnf_data in GET_FORB_NW callback");
    return;
  }
  status = cnf_data->response_header.mmgsdi_status;
  cmd_buf_p = (qmi_cmd_buf_type *)cnf_data->response_header.client_data;
  if (!qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL)
  {
    QM_MSG_HIGH("Received NULL cmd_buf in GET_FORB_NW callback");
    return;
  }
  memset ( &v_out_networks_list, 0, sizeof(v_out_networks_list) );
  memset ( (void*)fplmn_list, 0, sizeof(sys_plmn_id_s_type)
                                   * SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH );

  switch (cnf_data->access.file.file_enum)
  {
    case MMGSDI_GSM_FPLMN:
    case MMGSDI_USIM_FPLMN:
      if (status != MMGSDI_SUCCESS)
      {
        errval = QMI_ERR_INTERNAL;
        goto send_result;
      }
      read_data_len = (uint16) MIN( cnf_data->read_data.data_len,
                                   sizeof(sys_plmn_id_s_type) *
                                     SYS_FORBIDDEN_PLMN_LIST_MAX_LENGTH );
      memscpy( (void*)fplmn_list, read_data_len,
              cnf_data->read_data.data_ptr,
              read_data_len );
      num_entries = cnf_data->read_data.data_len /
                      sizeof(sys_plmn_id_s_type);
      QM_MSG_HIGH_2("read_data_len: %d,  num_entries: %d", read_data_len, num_entries);
      for ( i = 0; i < num_entries; i++ )
      {
        if(!sys_plmn_id_is_undefined(fplmn_list[i]))
        {
         QM_MSG_HIGH_3("plmn[%d, %d, %d]", fplmn_list[i].identity[0], fplmn_list[i].identity[1],fplmn_list[i].identity[2]);
          sys_plmn_get_mcc_mnc(fplmn_list[i],
                               &plmn_is_undefined,
                               &mnc_includes_pcs_digit,
                               &mcc,
                               &mnc);
          v_out_networks_list.network_info\
            [v_out_networks_list.num_of_networks].mcc = (uint16) mcc;
          v_out_networks_list.network_info\
            [v_out_networks_list.num_of_networks].mnc = (uint16) mnc;
          v_out_networks_list.num_of_networks++;
          QM_MSG_HIGH_3("i: %d,  sizeof mcc %d, mnc: %d", i, mcc, mnc);
        }
      }
      QM_MSG_HIGH_3("data_len: %d,  num_entries: %d, num_of_networks: %d", cnf_data->read_data.data_len, num_entries, v_out_networks_list.num_of_networks);
      networks_list_size = sizeof(v_out_networks_list.network_info[0]) *
                             v_out_networks_list.num_of_networks +
                           sizeof(v_out_networks_list.num_of_networks);

      if(FALSE == qmi_svc_put_param_tlv(&response,
                                        NASI_PARAM_TYPE_GET_FORB_NETWORKS,
                                        networks_list_size,
                                        &v_out_networks_list))
      {
        errval = QMI_ERR_NO_MEMORY;
        dsm_free_packet(&response);
      }
      break;
    default:
      QM_MSG_ERROR_1("Received unsolicited read confirmation on file %d", cnf_data->access.file.file_enum);
      return;
  }

send_result:
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  if ( (FALSE == qmi_svc_put_result_tlv(&response, result, errval)) ||
       (FALSE == qmi_nasi_send_response( cmd_buf_p, response)))
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }
} /* qmi_nasi_generate_get_forbidden_nw_resp */

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_SET_PREFERRED_NW_RESP()

  DESCRIPTION
    Function to generate response for NASI_CMD_VAL_SET_PREFERRED_NETWORKS

  PARAMETERS
    cnf_data : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_set_preferred_nw_resp
(
  mmgsdi_write_cnf_type       * cnf_data
)
{
  qmi_cmd_buf_type  *cmd_buf_p;
  dsm_item_type     *response = NULL;
  qmi_error_e_type   errval = QMI_ERR_NONE;
  qmi_result_e_type  result = QMI_RESULT_FAILURE;
  mmgsdi_return_enum_type status;

  if (cnf_data == NULL)
  {
    QM_MSG_HIGH("Received NULL cnf_data in SET_PREF_NW callback");
    return;
  }
  status = cnf_data->response_header.mmgsdi_status;
  cmd_buf_p = (qmi_cmd_buf_type *)cnf_data->response_header.client_data;
  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL)
  {
    QM_MSG_HIGH("Received NULL cmd_buf in SET_PREF_NW callback");
    return;
  }

  errval = (status == MMGSDI_SUCCESS)? QMI_ERR_NONE: QMI_ERR_INTERNAL;
  result = (status == MMGSDI_SUCCESS)?
             QMI_RESULT_SUCCESS:
             QMI_RESULT_FAILURE;

  if ( (FALSE == qmi_svc_put_result_tlv(&response, result, errval)) ||
       (FALSE == qmi_nasi_send_response( cmd_buf_p, response)))
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }
}/* qmi_nasi_generate_set_preferred_nw_resp */

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_SET_FORBIDDEN_NW_RESP()

  DESCRIPTION
    Function to generate response for NASI_CMD_VAL_SET_FORBIDDEN_NETWORKS

  PARAMETERS
    cnf_data : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_set_forbidden_nw_resp
(
  mmgsdi_write_cnf_type       * cnf_data
)
{
  qmi_cmd_buf_type  *cmd_buf_p;
  dsm_item_type     *response = NULL;
  qmi_error_e_type   errval = QMI_ERR_NONE;
  qmi_result_e_type  result = QMI_RESULT_FAILURE;
  mmgsdi_return_enum_type status;

  if (cnf_data == NULL)
  {
    QM_MSG_HIGH("Received NULL cnf_data in SET_FORB_NW callback");
    return;
  }
  status = cnf_data->response_header.mmgsdi_status;
  cmd_buf_p = (qmi_cmd_buf_type *)cnf_data->response_header.client_data;
  if (!qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL)
  {
    QM_MSG_HIGH("Received NULL cmd_buf in SET_FORB_NW callback");
    return;
  }

  errval = (status == MMGSDI_SUCCESS)? QMI_ERR_NONE: QMI_ERR_INTERNAL;
  result = (status == MMGSDI_SUCCESS)?
             QMI_RESULT_SUCCESS:
             QMI_RESULT_FAILURE;

  if ( (FALSE == qmi_svc_put_result_tlv(&response, result, errval)) ||
       (FALSE == qmi_nasi_send_response( cmd_buf_p, response)))
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }
} /* qmi_nasi_generate_set_forbidden_nw_resp */

#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) */
#endif /* defined(FEATURE_MMGSDI_SESSION_LIB) */

/*===========================================================================
  FUNCTION QMI_NASI_UPDATE_AKEY()

  DESCRIPTION
    This command updates AKEY. Modem will run authentication on the
  presented AKEY before updating AKEY. Authentication failure will
  result in error in response. On successful operation, the message
  will update NV_A_KEY_I NV item.

  *** This message is now deprecated ***

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_update_akey
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type      *response = NULL;
  qmi_error_e_type   errval    = QMI_ERR_NONE;
  qmi_result_e_type  result;
  boolean            retval;

  errval = QMI_ERR_NOT_SUPPORTED;

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv( &response, result, errval );
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_update_akey() */

/*===========================================================================
  FUNCTION QMI_NASI_DECODE_3GPP2_MCC()

  DESCRIPTION
    This message is used to encode 3GPP2 subscription related information; mcc.

  PARAMETERS
    decoded_mcc
    encoded_mcc

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_decode_3gpp2_mcc(uint32 *decoded_mcc, const uint32 encoded_mcc)
{
  uint32 d1, d2, d3, buf = encoded_mcc + 111;

  d3 = buf % 10;
  buf = ( d3 == 0 ) ? (buf-10)/10 : buf/10;

  d2 = buf % 10;
  buf = ( d2 == 0 ) ? (buf-10)/10 : buf/10;

  d1 = ( buf == 10 ) ? 0 : buf;

  *decoded_mcc = d1*100 + d2*10 + d3;
}

/*===========================================================================
  FUNCTION QMI_NASI_ENCODE_3GPP2_MCC()

  DESCRIPTION
    This message is used to encode 3GPP2 subscription related information; 3 digit encoding including mcc value

  PARAMETERS
    encoded_mcc
    decoded_mcc

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_encode_3gpp2_mcc( uint32 *encoded_mcc, const uint32 decoded_mcc)
{
  uint32 temp_decoded_mcc, digit[3];

  int i;
  temp_decoded_mcc = decoded_mcc;

  for (i = 2; i >= 0; i--)
  {
    digit[i] = temp_decoded_mcc % 10;

    if( digit[i] == 0)
    {
      digit[i] = 10;
    }
    temp_decoded_mcc /= 10;
  }
  *encoded_mcc =  (uint32)(100*digit[0] + 10*digit[1] + digit[2] - 111);
}

/*===========================================================================
  FUNCTION QMI_NASI_ENCODE_3GPP2_IMSI_11_12()

  DESCRIPTION
    This message is used to encode 3GPP2 subscription related information; mcc.

  PARAMETERS
    encoded_mcc
    decoded_mcc

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_encode_3gpp2_imsi_11_12( uint32 *encoded, const uint32 decoded)
{
  uint32  d1, d2;

  d1 = decoded /10;
  d2 = decoded %10;

  d1 = (d1 == 0)? 10 : d1;
  d2 = (d2 == 0)? 10 : d2;

  *encoded =  d1*10 + d2 - 11;
}

/*===========================================================================
  FUNCTION QMI_NASI_DECODE_3GPP2_IMSI_11_12()

  DESCRIPTION
    This message is used to encode 3GPP2 subscription related information; imsi_m/t_11_12.

  PARAMETERS
    decoded_mcc
    encoded_mcc

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_decode_3gpp2_imsi_11_12(uint32 *decoded_imsi_11_12, const uint32 encoded_imsi_11_12)
{
  uint32 d1, d2, temp_encoded;
  temp_encoded = encoded_imsi_11_12;

  temp_encoded += 11;
  d2 = temp_encoded % 10;
  if( d2 == 0)
  {
    temp_encoded =(temp_encoded - 10)/10;
  }
  else
  {
    temp_encoded /= 10;
  }

  if( temp_encoded == 10)
  {
    d1 =0;
  }
  else
  {
    d1 = temp_encoded;
  }
  *decoded_imsi_11_12 = d1*10 + d2;
}

/*===========================================================================
  FUNCTION QMI_NAS_GET_3GPP2_SUBSCRIPTION_INFO()

  DESCRIPTION
    This message is used to retrieve 3GPP2 subscription related information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_3gpp2_subscription_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type         *response = NULL;
  qmi_error_e_type      errval    = QMI_ERR_NONE;
  boolean               missed_value;
  nv_stat_enum_type     nv_status;
  int                   count;
  nv_item_type          nv_item;

  nas_get_3gpp2_subscription_info_req_msg_v01    *req_msg;
  nas_get_3gpp2_subscription_info_resp_msg_v01   *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_get_3gpp2_subscription_info_req_msg_v01  *) 
  	modem_mem_alloc( sizeof(nas_get_3gpp2_subscription_info_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_3gpp2_subscription_info_resp_msg_v01 *) 
  	modem_mem_alloc( sizeof(nas_get_3gpp2_subscription_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL || rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    goto end_get_3gpp2_subscription_info;
  }
  memset (rsp_msg, 0x00, sizeof(nas_get_3gpp2_subscription_info_resp_msg_v01));


  
  if (TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR)
  {
    /*-------------------------------------------------------------------------
      Read the incoming message
    -------------------------------------------------------------------------*/

    memset (req_msg, 0x00, sizeof(nas_get_3gpp2_subscription_info_req_msg_v01));
    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_3gpp2_subscription_info_req_msg_v01)
                                         );
    /*-----------------------------------------------------------------------
      Check input
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE)
    {
      errval = qmi_nas_003E_req_check(req_msg);
    }

    /*-----------------------------------------------------------------------
      Check if we are supposed to get current NAM
    -----------------------------------------------------------------------*/
    if ( errval == QMI_ERR_NONE )
    {
      if (req_msg->nam_id == NAS_003E_REQ_CURR_NAM_MASK)
      {
        /* Read and temporarily cache the current NAM */
        nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
        if (nv_status == NV_NOTACTIVE_S)
        {
          QM_MSG_ERROR("Unable to get current NAM from NVM");
          errval = QMI_ERR_INTERNAL;
        }
        req_msg->nam_id = nv_item.curr_nam;
      }
    }

    /*-------------------------------------------------------------------------
      Get information to return. Begin with NAM name.
    -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_NAM_NAME_V01)))
    {
      nv_item.name_nam.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_NAME_NAM_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        memscpy(rsp_msg->nam_name, NV_MAX_LTRS, nv_item.name_nam.name, NV_MAX_LTRS);
        //figure out the length, assuming it is null-terminated
        for (count = 0; count < NV_MAX_LTRS; count++)
        {
          if (rsp_msg->nam_name[count] == 0)
          {
            break;
          }
        }

        rsp_msg->nam_name_len = count;
        rsp_msg->nam_name_valid= TRUE;
      }
      else if(nv_status == NV_NOTACTIVE_S)
      {
        QM_MSG_HIGH("NV_NAME_NAM_I not active");
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        QM_MSG_ERROR("Unable to read NV_NAME_NAM_I");
      }
    }

    /*-------------------------------------------------------------------------
      Get directory number
    -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_DIR_NUM_V01)))
    {
      nv_item.dir_number.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_DIR_NUMBER_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        memscpy(rsp_msg->dir_num, NV_DIR_NUMB_SIZ, nv_item.dir_number.dir_number, NV_DIR_NUMB_SIZ);
        //figure out the length, assuming it's null-terminated
        for (count = 0; count < NV_DIR_NUMB_SIZ; count++)
        {
          if (rsp_msg->dir_num[count] == 0)
          {
            break;
          }
        }

        rsp_msg->dir_num_len = count;
        rsp_msg->dir_num_valid= TRUE;
      }
      else if(nv_status == NV_NOTACTIVE_S)
      {
        QM_MSG_HIGH("NV_DIR_NUMBER_I not active");
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        QM_MSG_ERROR("Unable to read NV_DIR_NUMBER_I");
      }
    }

    /*-------------------------------------------------------------------------
      Get home SID/NID
    -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_HOME_SID_IND_V01)))
    {
      nv_item.home_sid_nid.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_HOME_SID_NID_I, &nv_item);

      if (nv_status == NV_DONE_S)
      {
        rsp_msg->cdma_sys_id_len = NAS_MAX_3GPP2_HOME_SID_NID_NUM_V01;

        for (count = 0; count < NAS_MAX_3GPP2_HOME_SID_NID_NUM_V01; count++)
        {
          rsp_msg->cdma_sys_id[count].sid = nv_item.home_sid_nid.pair[count].sid;
          rsp_msg->cdma_sys_id[count].nid = nv_item.home_sid_nid.pair[count].nid;
        }
        rsp_msg->cdma_sys_id_valid = TRUE;
      }
      else if(nv_status == NV_NOTACTIVE_S)
      {
        QM_MSG_HIGH("NV_HOME_SID_NID_I not active");
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        QM_MSG_ERROR("Unable to read NV_HOME_SID_NID_I");
      }
    }

    /*-------------------------------------------------------------------------
      Get MIN based IMSI
    -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_MIN_BASED_IMSI_V01)))
    {
      missed_value = FALSE;

      //mcc_m
      nv_item.imsi_mcc.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_IMSI_MCC_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        if( (uint16)nv_item.imsi_mcc.imsi_mcc != 0x03FF )
        {
          uint32 decoded_mcc;
          qmi_nasi_decode_3gpp2_mcc( &decoded_mcc, (uint32)nv_item.imsi_mcc.imsi_mcc );
          qmi_nas_binary_to_ascii(decoded_mcc, rsp_msg->min_based_info.mcc_m, NAS_003E_RSP_MCC_LEN);
        }
        else
        {
          rsp_msg->min_based_info.mcc_m[0] = '3';
          rsp_msg->min_based_info.mcc_m[1] = 'F';
          rsp_msg->min_based_info.mcc_m[2] = 'F';
        }
      }
      else if(nv_status == NV_NOTACTIVE_S)
      {
        missed_value = TRUE;
        QM_MSG_HIGH("NV_IMSI_MCC_I not active");
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        missed_value = TRUE;
        QM_MSG_ERROR("Unable to read NV_IMSI_MCC_I");
      }

      if (missed_value == FALSE)
      {
        //imsi_m_11_12
        nv_item.imsi_11_12.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_IMSI_11_12_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          if( (uint8)nv_item.imsi_11_12.imsi_11_12 != 0x7F )
          {
            uint32 decoded;
            qmi_nasi_decode_3gpp2_imsi_11_12(&decoded, (uint32)nv_item.imsi_11_12.imsi_11_12);
            qmi_nas_binary_to_ascii(decoded, rsp_msg->min_based_info.imsi_m_11_12, NAS_003E_RSP_11_12_LEN);
          }
          else // Wild card  MNC value, no need to decode/encode
          {
            rsp_msg->min_based_info.imsi_m_11_12[0] = '7';
            rsp_msg->min_based_info.imsi_m_11_12[1] = 'F';
          }
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          missed_value = TRUE;
          QM_MSG_HIGH("NV_IMSI_11_12_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          missed_value = TRUE;
          QM_MSG_ERROR("Unable to read NV_IMSI_11_12_I");
        }
      }

      if(missed_value == FALSE)
      {
        //imsi_m_s1
        nv_item.min1.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_MIN1_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          uint32  encoded_first, thousand, encoded_second;
          uint32  decoded_first, decoded_second, imsi_s1;
          imsi_s1 = (uint32)nv_item.min1.min1[NV_CDMA_MIN_INDEX];

          encoded_second = imsi_s1 & 0x3FF;
          imsi_s1 >>= 10;
          thousand = imsi_s1 & 0x0F;
          imsi_s1 >>= 4;
          encoded_first = imsi_s1;
          qmi_nasi_decode_3gpp2_mcc( &decoded_first, encoded_first) ;
          qmi_nasi_decode_3gpp2_mcc( &decoded_second, encoded_second) ;

          rsp_msg->min_based_info.imsi_m_s1[6] = (uint8)(decoded_second%10 +'0');
          rsp_msg->min_based_info.imsi_m_s1[5] = (uint8)((decoded_second/10)%10 +'0');
          rsp_msg->min_based_info.imsi_m_s1[4] = (uint8)(decoded_second/100 +'0');
          rsp_msg->min_based_info.imsi_m_s1[3] = (uint8)(thousand%10 +'0');
          rsp_msg->min_based_info.imsi_m_s1[2] = (uint8)(decoded_first%10 +'0');
          rsp_msg->min_based_info.imsi_m_s1[1] = (uint8)((decoded_first/10)%10 +'0');
          rsp_msg->min_based_info.imsi_m_s1[0] = (uint8)(decoded_first/100 +'0');
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          missed_value = TRUE;
          QM_MSG_HIGH("NV_IMSI_MIN1_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          missed_value = TRUE;
          QM_MSG_ERROR("Unable to read NV_IMSI_MIN1_I");
        }
      }

      if(missed_value == FALSE)
      {
        //imsi_m_s2
        nv_item.min2.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_MIN2_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          uint32 decoded_m_s2;
          qmi_nasi_decode_3gpp2_mcc( &decoded_m_s2, (uint32)nv_item.min2.min2[NV_CDMA_MIN_INDEX] );
          qmi_nas_binary_to_ascii(decoded_m_s2, rsp_msg->min_based_info.imsi_m_s2, NASI_MIN2_LEN);
          rsp_msg->min_based_info_valid= TRUE;
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
            QM_MSG_HIGH("NV_IMSI_MIN2_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          QM_MSG_ERROR("Unable to read NV_IMSI_MIN2_I");
        }
      }
    }

    /*-------------------------------------------------------------------------
      Get true IMSI
      -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_TRUE_IMSI_V01)))
    {
      missed_value = FALSE;

      //mcc_t
      nv_item.imsi_t_mcc.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_IMSI_T_MCC_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        // Wildcard  0x03ff
        if( (uint16)nv_item.imsi_t_mcc.imsi_mcc != 0x03FF )
        {
          uint32 decoded_mcc;
          qmi_nasi_decode_3gpp2_mcc( &decoded_mcc, (uint32)nv_item.imsi_t_mcc.imsi_mcc );
          qmi_nas_binary_to_ascii(decoded_mcc, rsp_msg->true_imsi.mcc_t, NAS_003E_RSP_MCC_LEN);
        }
        else
        {
          rsp_msg->true_imsi.mcc_t[0] = '3';
          rsp_msg->true_imsi.mcc_t[1] = 'F';
          rsp_msg->true_imsi.mcc_t[2] = 'F';
        }
      }
      else if(nv_status == NV_NOTACTIVE_S)
      {
        missed_value = TRUE;
        QM_MSG_HIGH("NV_IMSI_T_MCC_I not active");
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        missed_value = TRUE;
        QM_MSG_ERROR("Unable to read NV_IMSI_T_MCC_I");
      }

      if(missed_value == FALSE)
      {
        //imsi_t_11_12
        nv_item.imsi_t_11_12.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_IMSI_T_11_12_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          if( (uint8)nv_item.imsi_t_11_12.imsi_11_12 != 0x7F )
          {
            uint32 decoded;
            qmi_nasi_decode_3gpp2_imsi_11_12(&decoded, (uint32)nv_item.imsi_t_11_12.imsi_11_12);
            qmi_nas_binary_to_ascii(decoded, rsp_msg->true_imsi.imsi_t_11_12, NAS_003E_RSP_11_12_LEN);
          }
          else
          {
            rsp_msg->true_imsi.imsi_t_11_12[0] = '7';
            rsp_msg->true_imsi.imsi_t_11_12[1] = 'F';
          }
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          missed_value = TRUE;
          QM_MSG_HIGH("NV_IMSI_T_11_12_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          missed_value = TRUE;
          QM_MSG_ERROR("Unable to read NV_IMSI_T_11_12_I");
        }
      }

      if(missed_value == FALSE)
      {
        //imsi_t_s1
        nv_item.imsi_t_s1.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_IMSI_T_S1_I, &nv_item);

        if (nv_status == NV_DONE_S)
        {
          uint32  encoded_first, thousand, encoded_second;
          uint32  decoded_first, decoded_second, imsi_s1;
          imsi_s1 = (uint32)nv_item.imsi_t_s1.min1[NV_CDMA_MIN_INDEX];

          encoded_second = imsi_s1 & 0x3FF;
          imsi_s1 >>= 10;
          thousand = imsi_s1 & 0x0F;
          imsi_s1 >>= 4;
          encoded_first = imsi_s1;
          qmi_nasi_decode_3gpp2_mcc( &decoded_first, encoded_first) ;
          qmi_nasi_decode_3gpp2_mcc( &decoded_second, encoded_second) ;

          rsp_msg->true_imsi.imsi_t_s1[6] = (uint8)(decoded_second%10 +'0');
          rsp_msg->true_imsi.imsi_t_s1[5] = (uint8)((decoded_second/10)%10 +'0');
          rsp_msg->true_imsi.imsi_t_s1[4] = (uint8)(decoded_second/100 +'0');
          rsp_msg->true_imsi.imsi_t_s1[3] = (uint8)(thousand%10 +'0');
          rsp_msg->true_imsi.imsi_t_s1[2] = (uint8)(decoded_first%10 +'0');
          rsp_msg->true_imsi.imsi_t_s1[1] = (uint8)((decoded_first/10)%10 +'0');
          rsp_msg->true_imsi.imsi_t_s1[0] = (uint8)(decoded_first/100 +'0');
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          missed_value = TRUE;
          QM_MSG_HIGH("NV_IMSI_T_S1_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          missed_value = TRUE;
          QM_MSG_ERROR("Unable to read NV_IMSI_T_S1_I");
        }
      }

      if(missed_value == FALSE)
      {
        //imsi_m_s2
        nv_item.imsi_t_s2.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_IMSI_T_S2_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          uint32 decoded_m_t2;
          qmi_nasi_decode_3gpp2_mcc( &decoded_m_t2, (uint32)nv_item.imsi_t_s2.min2[NV_CDMA_MIN_INDEX] );
          qmi_nas_binary_to_ascii(decoded_m_t2, rsp_msg->true_imsi.imsi_t_s2, NASI_MIN2_LEN);
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          missed_value = TRUE;
          QM_MSG_HIGH("NV_IMSI_T_S2_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          missed_value = TRUE;
          QM_MSG_ERROR("Unable to read NV_IMSI_T_S2_I");
        }
      }

      if(missed_value == FALSE)
      {
        //imsi_t_addr_num
        nv_item.imsi_t_addr_num.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_IMSI_T_ADDR_NUM_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          rsp_msg->true_imsi.imsi_t_addr_num = nv_item.imsi_t_addr_num.num;
          rsp_msg->true_imsi_valid= TRUE;
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          QM_MSG_HIGH("NV_IMSI_T_ADDR_NUM_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          QM_MSG_ERROR("Unable to read NV_IMSI_T_ADDR_NUM_I");
        }
      }
    }

    /*-------------------------------------------------------------------------
      Get CDMA channel
      -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_CDMA_CHANNEL_V01)))
    {
      missed_value = FALSE;
      //primary channel
      nv_item.name_nam.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_PCDMACH_I, &nv_item);
      if (nv_status == NV_DONE_S)
      {
        rsp_msg->cdma_channel_info.pri_ch_a = nv_item.pcdmach.channel_a;
        rsp_msg->cdma_channel_info.pri_ch_b = nv_item.pcdmach.channel_b;
      }
      else if(nv_status == NV_NOTACTIVE_S)
      {
        missed_value = TRUE;
        QM_MSG_HIGH("NV_PCDMACH_I not active");
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        missed_value = TRUE;
        QM_MSG_ERROR("Unable to read NV_PCDMACH_I");
      }

      if(missed_value == FALSE)
      {
        //secondary channel
        nv_item.name_nam.nam = req_msg->nam_id;
        nv_status = qmi_mmode_get_nv_item(NV_SCDMACH_I, &nv_item);
        if (nv_status == NV_DONE_S)
        {
          rsp_msg->cdma_channel_info.sec_ch_a = nv_item.scdmach.channel_a;
          rsp_msg->cdma_channel_info.sec_ch_b = nv_item.scdmach.channel_b;
          rsp_msg->cdma_channel_info_valid= TRUE;
        }
        else if(nv_status == NV_NOTACTIVE_S)
        {
          QM_MSG_HIGH("NV_SCDMACH_I not active");
        }
        else
        {
          errval = QMI_ERR_INTERNAL;
          QM_MSG_ERROR("Unable to read NV_SCDMACH_I");
        }
      }
    }

    /*-------------------------------------------------------------------------
      Get Mobile Directory Number (MDN)
    -------------------------------------------------------------------------*/

    if( errval == QMI_ERR_NONE && (!req_msg->get_3gpp2_info_mask_valid ||(req_msg->get_3gpp2_info_mask & QMI_NAS_GET_3GPP2_SUBS_INFO_MDN_V01)))
    {
      nv_item.mob_dir_number.nam = req_msg->nam_id;
      nv_status = qmi_mmode_get_nv_item(NV_DIR_NUMBER_PCS_I, &nv_item);

      if (nv_status == NV_DONE_S)
      {
        rsp_msg->mdn_len = nv_item.mob_dir_number.n_digits;
        // copy just the specifed number of digits
        if( rsp_msg->mdn_len <= NASI_MDN_MAX_LEN )
        {
          rsp_msg->mdn_valid = TRUE;

          // Convert to ASCII from 3GPP2 format:
          //      - Spec: 3GPP2 C.S0005-D, Table 2.7.1.3.2.4-4
          //      - Byte padding: Unused bits (MSB) set to 0.
          for( count =0; count < rsp_msg->mdn_len ; count++ )
          {
            if ( nv_item.mob_dir_number.digitn[count] == 0x0B )
            {
              rsp_msg->mdn[count] = '*';
            }
            else if ( nv_item.mob_dir_number.digitn[count] == 0x0C )
            {
              rsp_msg->mdn[count] = '#';
            }
            else if ( nv_item.mob_dir_number.digitn[count] == 0x0A )
            {
              rsp_msg->mdn[count] = '0';
            }
            else
            {
              rsp_msg->mdn[count] =  nv_item.mob_dir_number.digitn[count] + '0';
            }
          }
        }
        else
        {
          QM_MSG_ERROR("Incorrect mdn_len");
          errval = QMI_ERR_INTERNAL;
        }
      }
    }

  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }

  if(errval != QMI_ERR_NONE)
  {
    memset (rsp_msg, 0x00, sizeof(nas_get_3gpp2_subscription_info_resp_msg_v01));
  }

  rsp_msg->resp.error  = (qmi_error_type_v01)errval;
  rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

  qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                (void *) rsp_msg,
                                (uint32_t) sizeof(nas_get_3gpp2_subscription_info_resp_msg_v01),
                                &response
                              );
end_get_3gpp2_subscription_info:
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }


  return response;
} /*qmi_nasi_get_3gpp2_subscription_info()*/

/*===========================================================================
  FUNCTION QMI_NASI_SET_3GPP2_SUBSCRIPTION_INFO()

  DESCRIPTION
    This message is used to set 3GPP2 subscription related information.
    For any invalid value in a request message will cause service point to
    reject the message without updating any subscription information.
    In case of successful update of all requested information, QMI_ERR_NONE
    will be returned. In case all or subset of information failed to be
    written, QMI_ERR_INTERNAL will be returned.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_3gpp2_subscription_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *                  response = NULL;
  qmi_error_type_v01               errval = QMI_ERR_NONE_V01;
  qmi_error_type_v01               error_spc = QMI_ERR_NONE_V01;
  nv_item_type                     nv_item;
  qmi_svc_spc_result_e_type        check_spc_result;

  nv_stat_enum_type                nv_status;

  uint8 count;

  nas_set_3gpp2_subscription_info_req_msg_v01   *req_msg;
  nas_set_3gpp2_subscription_info_resp_msg_v01  *resp_msg;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = ( nas_set_3gpp2_subscription_info_req_msg_v01 *)modem_mem_alloc(sizeof(nas_set_3gpp2_subscription_info_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);
  resp_msg = ( nas_set_3gpp2_subscription_info_resp_msg_v01 *)modem_mem_alloc(sizeof(nas_set_3gpp2_subscription_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if (TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR)
  {
    if( errval == QMI_ERR_NONE_V01)
    {
      memset(req_msg, 0, sizeof(nas_set_3gpp2_subscription_info_req_msg_v01));

      errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                             (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                             sdu_in,
                                             (void *)req_msg,
                                             (uint32_t)sizeof(nas_set_3gpp2_subscription_info_req_msg_v01)
                                           );
    }

  
    if (errval == QMI_ERR_NONE_V01)
    {
      errval = qmi_nas_003F_req_check(req_msg);
    }

    if( errval == QMI_ERR_NONE_V01 && req_msg->spc_valid == TRUE )
    {
      check_spc_result = qmi_svc_check_spc((uint8*)req_msg->spc, TRUE );

      if (check_spc_result == QMI_SVC_SPC_FAIL)
      {
        error_spc = QMI_ERR_AUTHENTICATION_FAILED_V01;
      }
      else if (check_spc_result == QMI_SVC_SPC_LOCKED)
      {
        error_spc = QMI_ERR_AUTHENTICATION_LOCK_V01;
      }
      else if (check_spc_result == QMI_SVC_SPC_ERR_INTERNAL)
    {
        error_spc = QMI_ERR_INTERNAL_V01;
      }
    }

    /*-----------------------------------------------------------------------
      Check if we are supposed to get current NAM
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE_V01 && req_msg->nam_id == NASI_CURR_NAM_MASK)
    {
      /* Read and temporarily cache the current NAM */
      nv_status = qmi_mmode_get_nv_item(NV_CURR_NAM_I, &nv_item);
      if (nv_status == NV_NOTACTIVE_S)
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Unable to get current NAM from NVM");
      }
      req_msg->nam_id = nv_item.curr_nam;
    }

    /*-----------------------------------------------------------------------
      Update NV Items
    -----------------------------------------------------------------------*/

    /*-----------------------------------------------------------------------
      Directory number
    -----------------------------------------------------------------------*/

    if (errval == QMI_ERR_NONE_V01 && error_spc == QMI_ERR_NONE_V01 && req_msg->dir_num_valid)
    {
      //terminate directory number if it isn't max length
      if (req_msg->dir_num_len < NV_DIR_NUMB_SIZ)
      {
        req_msg->dir_num[req_msg->dir_num_len] = 0;
      }

      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.dir_number.nam = req_msg->nam_id;
      memscpy(nv_item.dir_number.dir_number, sizeof(req_msg->dir_num),
              req_msg->dir_num, sizeof(req_msg->dir_num));
      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_DIR_NUMBER_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write directory number to NVM");
      }
    }

    /*-----------------------------------------------------------------------
      Home SID/NID
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE_V01 && error_spc == QMI_ERR_NONE_V01 && req_msg->cdma_sys_id_valid)
    {
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.sid_nid.nam = req_msg->nam_id;

      for (count = 0; count < req_msg->cdma_sys_id_len; count++)
      {
        nv_item.home_sid_nid.pair[count].sid = req_msg->cdma_sys_id[count].sid;
        nv_item.home_sid_nid.pair[count].nid = req_msg->cdma_sys_id[count].nid;
      }

      // Fill up the remaining values (upto NV_MAX_HOME_SID_NID) with default value
      for ( ; count < NV_MAX_HOME_SID_NID; count++)
      {
        nv_item.home_sid_nid.pair[count].sid = NASI_PRL_WILDCARD_SID;
        nv_item.home_sid_nid.pair[count].nid = NASI_PRL_WILDCARD_NID;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_HOME_SID_NID_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write home SID/NID to NVM");
      }
    }

    /*-----------------------------------------------------------------------
      MIN based IMSI
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE_V01 && error_spc == QMI_ERR_NONE_V01 && req_msg->min_based_info_valid)
    {
      /*-----------------------------------------------------------------------
        IMSI M MCC
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_mcc.nam = req_msg->nam_id;
      if( (req_msg->min_based_info.mcc_m[0]== '3') && (req_msg->min_based_info.mcc_m[1]=='F') && (req_msg->min_based_info.mcc_m[2]=='F') ) // wildcard handling
      {
        nv_item.imsi_mcc.imsi_mcc = 0x03FF;
      }
      else
      {
        uint32 encoded_mcc, mcc;
        uint8 buff[NASI_MCC_LEN+1];

        memscpy( buff, NASI_MCC_LEN, req_msg->min_based_info.mcc_m, NASI_MCC_LEN);
        buff[NASI_MCC_LEN] = '\0';
        mcc = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_mcc( &encoded_mcc, mcc );
        nv_item.imsi_mcc.imsi_mcc = (uint16)encoded_mcc ;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_MCC_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write MIN based IMSI MCC to NVM");
      }

      /*-----------------------------------------------------------------------
        IMSI M 11 12
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_11_12.nam = req_msg->nam_id;
      if( (req_msg->min_based_info.imsi_m_11_12[0]== '7') && (req_msg->min_based_info.imsi_m_11_12[1]=='F') ) // wildcard handling
      {
        nv_item.imsi_11_12.imsi_11_12 = 0x7F;
      }
      else
      {
        uint32 encoded, imsi_m_11_12;
        uint8 buff[NASI_11_12_LEN+1];

        memscpy ( buff, sizeof(buff), req_msg->min_based_info.imsi_m_11_12, NASI_11_12_LEN);
        buff[NASI_11_12_LEN] = '\0';
        imsi_m_11_12 = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_imsi_11_12( &encoded, imsi_m_11_12 );
        nv_item.imsi_11_12.imsi_11_12 = (uint8)encoded;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_11_12_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write MIN based IMSI 11 12 to NVM");
      }

      /*-----------------------------------------------------------------------
        IMSI M S1  MIN =  imsi_s2( 3 digt) + imsi_s1 (7 digit)
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.min1.nam = req_msg->nam_id;
      {
        uint32 encoded, encoded_first, encoded_second, thousand, first, second;
        uint8 buff[NASI_MCC_LEN+1];

        memscpy ( buff, NASI_MCC_LEN, req_msg->min_based_info.imsi_m_s1, NASI_MCC_LEN);
        buff[NASI_MCC_LEN] = '\0';
        first = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_mcc( &encoded_first, first );

        memscpy ( buff, NASI_MCC_LEN, req_msg->min_based_info.imsi_m_s1+4, NASI_MCC_LEN);
        buff[NASI_MCC_LEN] = '\0';
        second = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_mcc( &encoded_second, second );

        thousand = (uint32)((req_msg->min_based_info.imsi_m_s1[3] == '0') ? 10 : (req_msg->min_based_info.imsi_m_s1[3] -'0'));

        encoded = encoded_first;
        encoded <<= 4;
        encoded |= thousand;
        encoded <<= 10;
        encoded |= encoded_second;

        nv_item.min1.min1[NV_CDMA_MIN_INDEX] = (uint32)encoded;
      }
      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_MIN1_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write MIN based IMSI MIN1 to NVM");
      }

      /*-----------------------------------------------------------------------
        IMSI M MIN2
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.min2.nam = req_msg->nam_id;

      {
        uint32 encoded, imsi_m_s2;
        uint8 buff[NASI_MIN2_LEN+1];

        memscpy ( buff, NASI_MIN2_LEN, req_msg->min_based_info.imsi_m_s2, NASI_MIN2_LEN);
        buff[NASI_MIN2_LEN] = '\0';
        imsi_m_s2 = atoi( (char *)buff );

        qmi_nasi_encode_3gpp2_mcc( &encoded, imsi_m_s2 );
        nv_item.min2.min2[NV_CDMA_MIN_INDEX] = (uint16)encoded ;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_MIN2_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write MIN based IMSI MIN2 to NVM");
      }
    }

    /*-----------------------------------------------------------------------
      True IMSI
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE_V01 && req_msg->true_imsi_valid)
    {
      /*-----------------------------------------------------------------------
        IMSI T MCC
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_t_mcc.nam = req_msg->nam_id;
      if( (req_msg->true_imsi.mcc_t[0]== '3') && (req_msg->true_imsi.mcc_t[1]=='F') && (req_msg->true_imsi.mcc_t[2]=='F') ) // wildcard handling
      {
        nv_item.imsi_t_mcc.imsi_mcc = 0x3FF;
      }
      else
      {
        uint32 encoded_mcc, mcc;
        uint8 buff[NASI_MCC_LEN+1];

        memscpy ( buff, NASI_MCC_LEN, req_msg->true_imsi.mcc_t, NASI_MCC_LEN);
        buff[NASI_MCC_LEN] = '\0';
        mcc = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_mcc( &encoded_mcc, mcc );
        nv_item.imsi_t_mcc.imsi_mcc = (uint16)encoded_mcc;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_T_MCC_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write true IMSI MCC to NVM");
      }

      /*-----------------------------------------------------------------------
        IMSI T 11 12
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_t_11_12.nam = req_msg->nam_id;
      if( (req_msg->true_imsi.imsi_t_11_12[0]== '7') && (req_msg->true_imsi.imsi_t_11_12[1]=='F') ) // wildcard handling
      {
        nv_item.imsi_t_11_12.imsi_11_12 = 0x7F;
      }
      else
      {
        uint32 encoded, imsi_t_11_12;
        uint8 buff[NASI_11_12_LEN+1];

        memscpy ( buff, NASI_11_12_LEN, req_msg->true_imsi.imsi_t_11_12, NASI_11_12_LEN);
        buff[NASI_11_12_LEN] = '\0';
        imsi_t_11_12 = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_imsi_11_12( &encoded, imsi_t_11_12 );
        nv_item.imsi_t_11_12.imsi_11_12 = (uint16)encoded;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_T_11_12_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write true IMSI 11 12 to NVM");
      }

      /*-----------------------------------------------------------------------
        IMSI T MIN1
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_t_s1.nam = req_msg->nam_id;

      {
        uint32 encoded, encoded_first, encoded_second, thousand, first, second;
        uint8 buff[NASI_MCC_LEN+1];

        memscpy ( buff, NASI_MCC_LEN, req_msg->true_imsi.imsi_t_s1, NASI_MCC_LEN);
        buff[NASI_MCC_LEN] = '\0';
        first = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_mcc( &encoded_first, first );

        memscpy ( buff, NASI_MCC_LEN, req_msg->true_imsi.imsi_t_s1+4, NASI_MCC_LEN);
        buff[NASI_MCC_LEN] = '\0';
        second = atoi( (char *)buff );
        qmi_nasi_encode_3gpp2_mcc( &encoded_second, second );
        thousand = (uint32)((req_msg->true_imsi.imsi_t_s1[3] == '0') ? 10 : (req_msg->true_imsi.imsi_t_s1[3] -'0'));

        encoded = encoded_first;
        encoded <<= 4;
        encoded |= thousand;
        encoded <<= 10;
        encoded |= encoded_second;

        nv_item.imsi_t_s1.min1[NV_CDMA_MIN_INDEX] = (uint32)encoded;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_T_S1_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write true IMSI MIN1 to NVM");
      }

      /*-----------------------------------------------------------------------
        IMSI T MIN2
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_t_s2.nam = req_msg->nam_id;

      {
        uint32 encoded, imsi_t_s2;
        uint8 buff[NASI_MIN2_LEN+1];

        memscpy ( buff, NASI_MIN2_LEN, req_msg->true_imsi.imsi_t_s2, NASI_MIN2_LEN);
        buff[NASI_MIN2_LEN] = '\0';
        imsi_t_s2 = atoi( (char *)buff );

        qmi_nasi_encode_3gpp2_mcc( &encoded, imsi_t_s2 );
        nv_item.imsi_t_s2.min2[NV_CDMA_MIN_INDEX] = (uint16)encoded ;
      }

      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_T_S2_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write true IMSI MIN2 to NVM");
      }

      /*-----------------------------------------------------------------------
          Address Number
      -----------------------------------------------------------------------*/
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.imsi_t_addr_num.nam = req_msg->nam_id;
      memscpy((void *) &nv_item.imsi_t_addr_num.num, sizeof(req_msg->true_imsi.imsi_t_addr_num),
              &req_msg->true_imsi.imsi_t_addr_num, sizeof(req_msg->true_imsi.imsi_t_addr_num));
      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_IMSI_T_ADDR_NUM_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write true IMSI address number to NVM");
      }
    }

    /*-----------------------------------------------------------------------
      CDMA Channel
    -----------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE_V01 && error_spc == QMI_ERR_NONE_V01 && req_msg->cdma_channel_info_valid)
    {
      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.pcdmach.nam = req_msg->nam_id;
      memscpy((void *) &nv_item.pcdmach.channel_a, sizeof(req_msg->cdma_channel_info.pri_ch_a),
              &req_msg->cdma_channel_info.pri_ch_a, sizeof(req_msg->cdma_channel_info.pri_ch_a));
      memscpy((void *) &nv_item.pcdmach.channel_b, sizeof(req_msg->cdma_channel_info.pri_ch_b),
              &req_msg->cdma_channel_info.pri_ch_b, sizeof(req_msg->cdma_channel_info.pri_ch_b));
      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_PCDMACH_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write primary CDMA channels to NVM");
      }

      memset(&nv_item, 0, sizeof(nv_item));
      nv_item.scdmach.nam = req_msg->nam_id;
      memscpy((void *) &nv_item.scdmach.channel_a, sizeof(req_msg->cdma_channel_info.sec_ch_a),
              &req_msg->cdma_channel_info.sec_ch_a, sizeof(req_msg->cdma_channel_info.sec_ch_a));
      memscpy((void *) &nv_item.scdmach.channel_b, sizeof(req_msg->cdma_channel_info.sec_ch_b),
              &req_msg->cdma_channel_info.sec_ch_b, sizeof(req_msg->cdma_channel_info.sec_ch_b));
      if (NV_DONE_S != qmi_mmode_put_nv_item(NV_SCDMACH_I, &nv_item))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write secondary CDMA channels to NVM");
      }
    }

    /*-----------------------------------------------------------------------
      NAM Name
    -----------------------------------------------------------------------*/

    if( errval == QMI_ERR_NONE_V01 && req_msg->nam_name_valid)
    {
      memset(&nv_item, 0, sizeof(nv_item));

      nv_item.name_nam.nam = req_msg->nam_id;
      memscpy((void *) nv_item.name_nam.name, req_msg->nam_name_len,
              req_msg->nam_name, req_msg->nam_name_len);

      if ( NV_DONE_S != qmi_mmode_put_nv_item(NV_NAME_NAM_I, &nv_item) )
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write NAM name to NVM");
      }
    }

    /*-----------------------------------------------------------------------
      Mobile Directory Number (MDN)
    -----------------------------------------------------------------------*/
    if( errval == QMI_ERR_NONE_V01 && error_spc == QMI_ERR_NONE_V01 && req_msg->mdn_valid)
    {
      memset(&nv_item, 0, sizeof(nv_item));

      nv_item.mob_dir_number.nam = req_msg->nam_id;

      nv_item.mob_dir_number.n_digits = req_msg->mdn_len;

      // Convert from ASCII to 3GPP2 format:
      //      - Spec: 3GPP2 C.S0005-D, Table 2.7.1.3.2.4-4
      //      - Byte padding: Unused bits (MSB) set to 0.
      for ( count = 0; count < req_msg->mdn_len; count++ )
      {
       if ( req_msg->mdn[count] == '*' )
       {
         nv_item.mob_dir_number.digitn[count] = 0x0B ;
       }
       else if ( req_msg->mdn[count] == '#' )
       {
         nv_item.mob_dir_number.digitn[count] = 0x0C ;
       }
       else if ( req_msg->mdn[count] == '0' )
       {
         nv_item.mob_dir_number.digitn[count] = 0x0A ;
       }
       else
       {
         nv_item.mob_dir_number.digitn[count] =  req_msg->mdn[count] - '0';
       }
      }
      if ( NV_DONE_S != qmi_mmode_put_nv_item(NV_DIR_NUMBER_PCS_I, &nv_item) )
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("Failed to write MDN to NV memory");
      }
    }
  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_3gpp2_subscription_info_resp_msg_v01) );

    if(error_spc == QMI_ERR_NONE_V01)
    {
      resp_msg->resp.error  = errval;
      resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
    }
    else
    {
      resp_msg->resp.error  = error_spc;
      resp_msg->resp.result = (error_spc == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
    }

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                  (void *)resp_msg,
                                  (uint32_t)sizeof(nas_set_3gpp2_subscription_info_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    /*Not enough memory to allocate for QMI_NAS_SET_3GPP2_SUBSCRIPTION_INFO response*/
     qmi_voice_mem_error();
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_set_3gpp2_subscription_info() */

/*===========================================================================
  FUNCTION QMI_NAS_GET_MOB_CAI_REV()

  DESCRIPTION
    This message is used to retrieve Mobile CAI revision information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_mob_cai_rev
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  qmi_result_e_type     result;
  boolean               retval;
  nv_stat_enum_type     nv_status;
  nv_item_type          nv_item;

  struct nas_0040_rsp_s    rsp_msg;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR)
  {

    memset(&rsp_msg, 0, sizeof(rsp_msg));

    /*-------------------------------------------------------------------------
      Get mobile CAI revision
    -------------------------------------------------------------------------*/
    if ( errval == QMI_ERR_NONE)
    {
      memset(&nv_item, 0, sizeof(nv_item));
      nv_status = qmi_mmode_get_nv_item(NV_MOB_CAI_REV_I, &nv_item);

      if ( nv_status == NV_DONE_S)
      {
        rsp_msg.t10_valid   = TRUE;
        rsp_msg.t10.cai_rev = nv_item.mob_cai_rev;
      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        QM_MSG_ERROR("Unable to read NV_MOB_CAI_REV_I from NVM");
      }
    }

    /*-------------------------------------------------------------------------
      Construct response
    -------------------------------------------------------------------------*/
    if (errval == QMI_ERR_NONE)
    {
      errval = qmi_nas_0040_rsp_write(&rsp_msg, &response);
    }
  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv( &response, result, errval );
  CHECK_RETVAL();
  return response;
} /*qmi_nasi_get_mob_cai_rev()*/

/*===========================================================================
  FUNCTION QMI_NAS_GET_RTRE_CONFIG()

  DESCRIPTION
    This message is used to retrieve RTRE (RunTime R-UIM Enable)
    Control information.  - Note: get contro not a config data

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_rtre_config
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  qmi_result_e_type     result;
  boolean               retval;

  struct nas_0041_rsp_s    rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&rsp_msg, 0, sizeof(rsp_msg));

  if (TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR)
  {
    /*-------------------------------------------------------------------------
      Get RTRE config : Get RTRE_CONTROL from CM because qcril want to get rtre_control (24 Setp 10)
    -------------------------------------------------------------------------*/
      /* eventhough this GET_RTRE_CONFIG request would be happen after initialized, check for error */
      if( qmi_nasi_global.inited == INIT_STATE_INITIALIZED)
      {
        rsp_msg.t10_valid    = TRUE;
        switch(qmi_nasi_global.cm_ph_info.rtre_control)
        {
          case CM_RTRE_CONTROL_RUIM:
            rsp_msg.t10.rtre_cfg  = (uint8)NAS_RTRE_CFG_RUIM_ONLY;
            break;
          case CM_RTRE_CONTROL_NV:
            rsp_msg.t10.rtre_cfg  = (uint8)NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY;
            break;
          case CM_RTRE_CONTROL_SIM:
            rsp_msg.t10.rtre_cfg  = (uint8)NAS_RTRE_CFG_GSM_ON_1X;
            break;
          default:
            // Error in Getting  rtre_control data
            errval = QMI_ERR_INTERNAL;
            QM_MSG_ERROR_1("qmi_nasi_get_rtre_config: wrong cm_ph_info.rtre_control data, %d", qmi_nasi_global.cm_ph_info.rtre_control);
            break;
        }

        rsp_msg.t11_valid    = TRUE;
        switch(qmi_nasi_global.cm_ph_info.rtre_config)
        {
          case CM_RTRE_CONFIG_RUIM_ONLY:
            rsp_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_RUIM_ONLY;
            break;
          case CM_RTRE_CONFIG_NV_ONLY:
            rsp_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY;
            break;
          case CM_RTRE_CONFIG_RUIM_OR_DROP_BACK:
            rsp_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_RUIM_IF_AVAIL;
            break;
          case CM_RTRE_CONFIG_SIM_ACCESS:
            rsp_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_GSM_ON_1X;
            break;
          default:
            // Error in Getting  rtre_pref data
            errval = QMI_ERR_INTERNAL;
            QM_MSG_ERROR_1("qmi_nasi_get_rtre_config: wrong cm_ph_info.rtre_config data, %d", qmi_nasi_global.cm_ph_info.rtre_config);
            break;
        }

      }
      else
      {
        errval = QMI_ERR_INTERNAL;
        QM_MSG_ERROR("Unable to read RTRE control from NVM");
      }

    if (errval == QMI_ERR_NONE)
    {
      errval = qmi_nas_0041_rsp_write(&rsp_msg, &response);
    }

  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv( &response, result, errval );
  CHECK_RETVAL();
  return response;
} /*qmi_nasi_get_rtre_config()*/

/*===========================================================================
  FUNCTION QMI_NASI_SET_RTRE_CONFIG()

  DESCRIPTION
    This message is used to set RTRE (RunTime R-UIM Enable) configuration
    information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_set_rtre_config
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{

  dsm_item_type *response = NULL;
  qmi_nasi_client_state_type *nas_client_sp;
  qmi_error_type_v01               errval = QMI_ERR_NONE_V01;
  qmi_svc_spc_result_e_type        check_spc_result;

  nas_set_rtre_config_req_v01   *nas_rtre_config_req;
  nas_set_rtre_config_resp_v01  *nas_rtre_config_resp;


  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  nas_client_sp = (qmi_nasi_client_state_type *) cl_sp;

  nas_rtre_config_req  = ( nas_set_rtre_config_req_v01 *)modem_mem_alloc(sizeof(nas_set_rtre_config_req_v01), MODEM_MEM_CLIENT_QMI_MMODE);
  nas_rtre_config_resp = ( nas_set_rtre_config_resp_v01 *)modem_mem_alloc(sizeof(nas_set_rtre_config_resp_v01), MODEM_MEM_CLIENT_QMI_MMODE);

  if ( nas_rtre_config_req == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if (TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR)
  {
    if( errval == QMI_ERR_NONE_V01)
    {
      memset(nas_rtre_config_req, 0, sizeof(nas_set_rtre_config_req_v01));

      errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                             (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                             sdu_in,
                                             (void *)nas_rtre_config_req,
                                             (uint32_t)sizeof(nas_set_rtre_config_req_v01)
                                           );
    }

    if (errval == QMI_ERR_NONE_V01)
    {
      errval = qmi_nas_0042_req_check(nas_rtre_config_req);
    }

    if( (errval == QMI_ERR_NONE_V01) && (nas_rtre_config_req->spc_valid == TRUE) )
    {
      check_spc_result = qmi_svc_check_spc((uint8*)nas_rtre_config_req->spc, TRUE );

      if (check_spc_result == QMI_SVC_SPC_FAIL)
      {
        errval = QMI_ERR_AUTHENTICATION_FAILED_V01;
      }
      else if (check_spc_result == QMI_SVC_SPC_LOCKED)
    {
        errval = QMI_ERR_AUTHENTICATION_LOCK_V01;
      }
      else if (check_spc_result == QMI_SVC_SPC_ERR_INTERNAL)
    {
        errval = QMI_ERR_INTERNAL_V01;
      }
    }

    /*-----------------------------------------------------------------------
      Update RTRE config
    -----------------------------------------------------------------------*/
    if(errval == QMI_ERR_NONE_V01)
    {
      /* set rtre_set_status_pending: to indicate set_rtre_config request in service to prevent multiple requests
                                    TRUE - in the processing of previous request*/
      if( qmi_nasi_global.rtre_set_status_pending != TRUE )
      {
        if( qmi_nasi_global.cm_ph_info.rtre_config != (cm_rtre_config_e_type)nas_rtre_config_req->rtre_cfg_pref)
        {
          //0x04 - GSM on 1X (deprecated - converted to use 'Internal setting only' on QMI_NAS_SET_RTRE_CONFIG)
          if( nas_rtre_config_req->rtre_cfg_pref == (uint8)NAS_RTRE_CFG_GSM_ON_1X  )
          {
            nas_rtre_config_req->rtre_cfg_pref = (uint8)NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY;
          }

          if( cm_ph_cmd_change_rtre_config( qmi_nas_cmph_cmd_cb,
                                                (void *)cmd_buf_p,
                                                nas_client_sp->common.clid,
                                            (cm_rtre_config_e_type)nas_rtre_config_req->rtre_cfg_pref) )
          {
            errval = QMI_ERR_NONE_V01;
            qmi_nasi_global.rtre_set_status_pending = TRUE;
            qmi_nasi_global.p_rtre_set_status_cmd_buf = cmd_buf_p;
            QM_MSG_HIGH_1("qmi_nasi_set_rtre_config: nas_rtre_config_req.rtre_cfg_pref %d", nas_rtre_config_req->rtre_cfg_pref);
            response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
           }
           else
           {
            errval = QMI_ERR_INTERNAL_V01;
           }
         }
         else
         {
          errval = QMI_ERR_NO_EFFECT_V01;
         }
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
          QM_MSG_ERROR("Failed to write RTRE configuration to NVM due to previsous request in service");
      } /* qmi_nasi_global.rtre_set_status_pending != TRUE */
    }
  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if(response == NULL)
  {
  if ( nas_rtre_config_resp != NULL )
  {
    memset(nas_rtre_config_resp, 0, sizeof(nas_set_rtre_config_resp_v01) );
    nas_rtre_config_resp->resp.error  = errval;
    nas_rtre_config_resp->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                  (void *)nas_rtre_config_resp,
                                  (uint32_t)sizeof(nas_set_rtre_config_resp_v01),
                                  &response
                                );
  }
  else
  {
      qmi_voice_mem_error();
    }
  }

  if ( nas_rtre_config_req  != NULL ){ modem_mem_free((void *)nas_rtre_config_req,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( nas_rtre_config_resp != NULL ){ modem_mem_free((void *)nas_rtre_config_resp, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_set_rtre_config() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_RTRE_CONFIG_RESP()

  DESCRIPTION
    This message is used to set RTRE (RunTime R-UIM Enable) configuration response
    information.

  PARAMETERS
    result_status: TRUE - SUCCESS, FALSE - in case of Error

  RETURN VALUE
    none

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_rtre_config_resp
(
  boolean   result_status
)
{
  dsm_item_type *response = NULL;
  qmi_error_e_type       errval;
  qmi_result_e_type      result;
  boolean                retval;
  qmi_cmd_buf_type            *cmd_buf_p;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  errval = QMI_ERR_NONE;
  cmd_buf_p = qmi_nasi_global.p_rtre_set_status_cmd_buf;

  if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in SET_RTRE_CONFIG callback");
    return;
  }

  if( result_status == FALSE)
  {
    errval = QMI_ERR_INTERNAL;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
  }

}

/*===========================================================================
  FUNCTION QMI_NASI_GET_CELL_LOCATION_INFO()

  DESCRIPTION
    This message retrieves cell location related information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_cell_location_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type    *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

#ifdef FEATURE_LTE
  int               i, j;
#endif
  enum qm_subs_e subs_id;
  qmi_nasi_client_state_type *p_cs = (qmi_nasi_client_state_type*)cl_sp;


  nas_get_cell_location_info_resp_msg_v01 *rsp_msg;

  ASSERT(sp); ASSERT(cmd_buf_p); ASSERT(cl_sp); ASSERT(sdu_in);

  rsp_msg = (nas_get_cell_location_info_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_cell_location_info_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  if ( rsp_msg != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_cell_location_info_resp_msg_v01) );

    subs_id = qm_nas_clnt_get_binding( p_cs->common.clid );

  if ( qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
    {
        errval = QMI_ERR_INTERNAL_V01;
  }

    if ( errval == QMI_ERR_NONE_V01 )
    {
      qm_mstats_populate_cell_loc_info( rsp_msg, subs_id );
  
      if ( qm_si_is_rat_active( subs_id, QM_RAT_1X ) )
      {
        cm_cdma_position_info_s_type info;
  
        if ( cm_get_cdma_position_info( &info ) )
        {
          rsp_msg->cdma_info.sid       = info.sid;
          rsp_msg->cdma_info.nid       = info.nid;
          rsp_msg->cdma_info.base_id   = info.base_id;
          rsp_msg->cdma_info.refpn     = info.refpn;
          rsp_msg->cdma_info.base_lat  = info.base_lat;
          rsp_msg->cdma_info.base_long = info.base_long;
  
          rsp_msg->cdma_info_valid = TRUE;
        }
        else
        {
          QM_MSG_ERROR("cm_get_cdma_position_info() failed");
        }
      }
  
#ifdef FEATURE_LTE
      if( qm_si_is_rat_active( subs_id, QM_RAT_LTE ) )
      {
        cmapi_rat_meas_info_s_type meas_info;
        uint16                     my_mcc;
        uint16                     my_mnc;
        sys_plmn_id_s_type         my_plmn;
        boolean                    mnc_includes_pcs_digit_3;

        memset( &meas_info, 0, sizeof(meas_info) );
  
        if( cmapi_get_rat_meas_info( CMAPI_SYS_MODE_LTE, &meas_info ) == CMAPI_SUCCESS )
        {
          if( meas_info.is_service_available && (meas_info.sys_mode == CMAPI_SYS_MODE_LTE) &&
              meas_info.meas_info_u.lte_nbr_info.valid )
          {
            cmapi_lte_ngbr_ind_s* nbr_info = &meas_info.meas_info_u.lte_nbr_info;
  
            rsp_msg->lte_intra.ue_in_idle = nbr_info->idle;

            QM_MSG_HIGH_3("cmapi MCC = 0X%04X, MNC = 0X%04X, num_mnc_digits = %d", nbr_info->lte_serving_cell.mcc, nbr_info->lte_serving_cell.mnc, nbr_info->lte_serving_cell.num_mnc_digits);
    
            my_mcc = qm_util_bcd16_to_uint16( nbr_info->lte_serving_cell.mcc, NULL );
            my_mnc = qm_util_bcd16_to_uint16( nbr_info->lte_serving_cell.mnc, &mnc_includes_pcs_digit_3 );

            if ( my_mcc != QM_UTIL_INVALID_BCD16 && my_mnc != QM_UTIL_INVALID_BCD16 )
            {
              if ( sys_plmn_set_mcc_mnc( mnc_includes_pcs_digit_3, (sys_mcc_type) my_mcc, (sys_mnc_type) my_mnc, &my_plmn ) )
            {
                memscpy((void *) &rsp_msg->lte_intra.plmn, sizeof( rsp_msg->lte_intra.plmn ),
                        (void *) &my_plmn.identity, sizeof( rsp_msg->lte_intra.plmn ) );
          }
            }

            rsp_msg->lte_intra.tac            = nbr_info->lte_serving_cell.tac;
            rsp_msg->lte_intra.global_cell_id = (uint32) nbr_info->lte_serving_cell.serving_cell_id;

            QM_MSG_HIGH_9("PLMN = 0x%02X_%02X_%02X, t13.TAC = %d = 0x%X, lte_serving_cell.tac = %d, global_cell_id = %d = 0x%08X, serving_cell_id = %d",
                          rsp_msg->lte_intra.plmn[0], rsp_msg->lte_intra.plmn[1], rsp_msg->lte_intra.plmn[2],
                          rsp_msg->lte_intra.tac, rsp_msg->lte_intra.tac, nbr_info->lte_serving_cell.tac,
                          rsp_msg->lte_intra.global_cell_id, rsp_msg->lte_intra.global_cell_id, nbr_info->lte_serving_cell.serving_cell_id);

            rsp_msg->lte_intra.earfcn = (uint16)nbr_info->lte_intra.earfcn;
            rsp_msg->lte_intra_earfcn = nbr_info->lte_intra.earfcn;
            rsp_msg->lte_intra.serving_cell_id = nbr_info->lte_intra.serving_cell_id;
            if( rsp_msg->lte_intra.ue_in_idle )
            {
              rsp_msg->lte_intra.cell_resel_priority = nbr_info->lte_intra.idle.cell_resel_priority;
              rsp_msg->lte_intra.s_non_intra_search = nbr_info->lte_intra.idle.s_non_intra_search;
              rsp_msg->lte_intra.thresh_serving_low = nbr_info->lte_intra.idle.thresh_serving_low;
              rsp_msg->lte_intra.s_intra_search = nbr_info->lte_intra.idle.s_intra_search;
            }
  
            if( nbr_info->lte_intra.num_lte_cells > NAS_MAX_LTE_NGBR_NUM_CELLS_V01 )
            {
              QM_MSG_ERROR_2("Received %d lte intra cells, max allowed %d", nbr_info->lte_intra.num_lte_cells, NAS_MAX_LTE_NGBR_NUM_CELLS_V01);
              rsp_msg->lte_intra.cells_len = NAS_MAX_LTE_NGBR_NUM_CELLS_V01;
            }
            else
            {
              rsp_msg->lte_intra.cells_len = nbr_info->lte_intra.num_lte_cells;
            }
  
            for( i = 0; i<rsp_msg->lte_intra.cells_len; i++ )
            {
              rsp_msg->lte_intra.cells[i].pci = nbr_info->lte_intra.cell[i].pci;
              rsp_msg->lte_intra.cells[i].rsrq = nbr_info->lte_intra.cell[i].rsrq;
              rsp_msg->lte_intra.cells[i].rsrp = nbr_info->lte_intra.cell[i].rsrp;
              rsp_msg->lte_intra.cells[i].rssi = nbr_info->lte_intra.cell[i].rssi;
              if( rsp_msg->lte_intra.ue_in_idle )
              {
                rsp_msg->lte_intra.cells[i].srxlev = nbr_info->lte_intra.cell[i].idle.srxlev;
              }
            }
  
            rsp_msg->lte_intra_valid = TRUE;
            rsp_msg->lte_intra_earfcn_valid = TRUE;
  
            rsp_msg->lte_inter.ue_in_idle = nbr_info->idle;
            if( nbr_info->lte_inter.num_freqs > NAS_MAX_LTE_NGBR_NUM_FREQS_V01 )
            {
              QM_MSG_ERROR_2("Received %d lte inter freqs, max allowed %d", nbr_info->lte_inter.num_freqs, NAS_MAX_LTE_NGBR_NUM_FREQS_V01);
              rsp_msg->lte_inter.freqs_len = NAS_MAX_LTE_NGBR_NUM_FREQS_V01;
            }
            else
            {
              rsp_msg->lte_inter.freqs_len = nbr_info->lte_inter.num_freqs;
            }
            rsp_msg->lte_inter_earfcn_len = rsp_msg->lte_inter.freqs_len;
  
            for( i=0; i<rsp_msg->lte_inter.freqs_len; i++ )
            {
              rsp_msg->lte_inter.freqs[i].earfcn = (uint16)nbr_info->lte_inter.freqs[i].earfcn;
              rsp_msg->lte_inter_earfcn[i] = nbr_info->lte_inter.freqs[i].earfcn;
              if( rsp_msg->lte_inter.ue_in_idle )
              {
                rsp_msg->lte_inter.freqs[i].threshX_low = nbr_info->lte_inter.freqs[i].idle.threshX_low;
                rsp_msg->lte_inter.freqs[i].threshX_high = nbr_info->lte_inter.freqs[i].idle.threshX_high;
                rsp_msg->lte_inter.freqs[i].cell_resel_priority = nbr_info->lte_inter.freqs[i].idle.cell_resel_priority;
              }
  
              if( nbr_info->lte_inter.freqs[i].num_lte_cells > NAS_MAX_LTE_NGBR_NUM_CELLS_V01 )
              {
                QM_MSG_ERROR_2("Received %d lte inter cells, max allowed %d", nbr_info->lte_inter.freqs[i].num_lte_cells, NAS_MAX_LTE_NGBR_NUM_CELLS_V01);
                rsp_msg->lte_inter.freqs[i].cells_len = NAS_MAX_LTE_NGBR_NUM_CELLS_V01;
              }
              else
              {
                rsp_msg->lte_inter.freqs[i].cells_len = nbr_info->lte_inter.freqs[i].num_lte_cells;
              }
  
              for( j=0; j<rsp_msg->lte_inter.freqs[i].cells_len; j++ )
              {
                rsp_msg->lte_inter.freqs[i].cells[j].pci = nbr_info->lte_inter.freqs[i].cells[j].pci;
                rsp_msg->lte_inter.freqs[i].cells[j].rsrq = nbr_info->lte_inter.freqs[i].cells[j].rsrq;
                rsp_msg->lte_inter.freqs[i].cells[j].rsrp = nbr_info->lte_inter.freqs[i].cells[j].rsrp;
                rsp_msg->lte_inter.freqs[i].cells[j].rssi = nbr_info->lte_inter.freqs[i].cells[j].rssi;
                if( rsp_msg->lte_inter.ue_in_idle )
                {
                  rsp_msg->lte_inter.freqs[i].cells[j].srxlev = nbr_info->lte_inter.freqs[i].cells[j].idle.srxlev;
                }
              }
            }
  
            rsp_msg->lte_inter_valid = TRUE;
            rsp_msg->lte_inter_earfcn_valid = TRUE;
  
            rsp_msg->lte_gsm.ue_in_idle = nbr_info->idle;
            if( nbr_info->gsm.num_freq_groups > NAS_MAX_LTE_NGBR_GSM_NUM_FREQS_V01 )
            {
              QM_MSG_ERROR_2("Received %d gsm freqs, max allowed %d", nbr_info->gsm.num_freq_groups, NAS_MAX_LTE_NGBR_GSM_NUM_FREQS_V01);
              rsp_msg->lte_gsm.freqs_len = NAS_MAX_LTE_NGBR_GSM_NUM_FREQS_V01;
            }
            else
            {
              rsp_msg->lte_gsm.freqs_len = nbr_info->gsm.num_freq_groups;
            }
  
            for( i=0; i<rsp_msg->lte_gsm.freqs_len; i++ )
            {
              QM_MSG_HIGH_2("freq %d of %d", i, rsp_msg->lte_gsm.freqs_len);
              if( rsp_msg->lte_gsm.ue_in_idle )
              {
                rsp_msg->lte_gsm.freqs[i].cell_resel_priority = nbr_info->gsm.freq_group[i].idle.cell_resel_priority;
                rsp_msg->lte_gsm.freqs[i].thresh_gsm_high = nbr_info->gsm.freq_group[i].idle.thresh_gsm_high;
                rsp_msg->lte_gsm.freqs[i].thresh_gsm_low = nbr_info->gsm.freq_group[i].idle.thresh_gsm_low;
                rsp_msg->lte_gsm.freqs[i].ncc_permitted = nbr_info->gsm.freq_group[i].idle.ncc_permitted;
              }
  
              if( nbr_info->gsm.freq_group[i].num_gsm_arfcn > NAS_MAX_LTE_NGBR_GSM_NUM_CELLS_V01 )
              {
                QM_MSG_ERROR_2("Received %d gsm cells, max allowed %d", nbr_info->gsm.freq_group[i].num_gsm_arfcn, NAS_MAX_LTE_NGBR_GSM_NUM_CELLS_V01);
                rsp_msg->lte_gsm.freqs[i].cells_len = NAS_MAX_LTE_NGBR_GSM_NUM_CELLS_V01;
              }
              else
              {
                rsp_msg->lte_gsm.freqs[i].cells_len = nbr_info->gsm.freq_group[i].num_gsm_arfcn;
              }
  
              for( j=0; j<rsp_msg->lte_gsm.freqs[i].cells_len; j++ )
              {
                QM_MSG_HIGH_2("cell %d of %d", j, rsp_msg->lte_gsm.freqs[i].cells_len);
                rsp_msg->lte_gsm.freqs[i].cells[j].arfcn = nbr_info->gsm.freq_group[i].arfcn[j].arfcn;
                rsp_msg->lte_gsm.freqs[i].cells[j].band_1900 = nbr_info->gsm.freq_group[i].arfcn[j].band_1900;
                rsp_msg->lte_gsm.freqs[i].cells[j].cell_id_valid = nbr_info->gsm.freq_group[i].arfcn[j].cell_id_valid;
                rsp_msg->lte_gsm.freqs[i].cells[j].bsic_id = nbr_info->gsm.freq_group[i].arfcn[j].bsic_id;
                rsp_msg->lte_gsm.freqs[i].cells[j].rssi = nbr_info->gsm.freq_group[i].arfcn[j].rssi;
                if( rsp_msg->lte_gsm.ue_in_idle )
                {
                  rsp_msg->lte_gsm.freqs[i].cells[j].srxlev = nbr_info->gsm.freq_group[i].arfcn[j].idle.srxlev;
                }
              }
            }
  
            rsp_msg->lte_gsm_valid = TRUE;
  
            rsp_msg->lte_wcdma.ue_in_idle = nbr_info->idle;
            if( nbr_info->wcdma.num_wcdma_freqs > NAS_MAX_LTE_NGBR_WCDMA_NUM_FREQS_V01 )
            {
              QM_MSG_ERROR_2("Received %d wcdma freqs, max allowed %d", nbr_info->wcdma.num_wcdma_freqs, NAS_MAX_LTE_NGBR_WCDMA_NUM_FREQS_V01);
              rsp_msg->lte_wcdma.freqs_len = NAS_MAX_LTE_NGBR_WCDMA_NUM_FREQS_V01;
            }
            else
            {
              rsp_msg->lte_wcdma.freqs_len = nbr_info->wcdma.num_wcdma_freqs;
            }
  
            for( i=0; i<rsp_msg->lte_wcdma.freqs_len; i++ )
            {
              rsp_msg->lte_wcdma.freqs[i].uarfcn = nbr_info->wcdma.freq[i].uarfcn;
              if( rsp_msg->lte_wcdma.ue_in_idle )
              {
                rsp_msg->lte_wcdma.freqs[i].cell_resel_priority = nbr_info->wcdma.freq[i].idle.cell_resel_priority;
                rsp_msg->lte_wcdma.freqs[i].thresh_Xhigh = nbr_info->wcdma.freq[i].idle.thresh_Xhigh;
                rsp_msg->lte_wcdma.freqs[i].thresh_Xlow = nbr_info->wcdma.freq[i].idle.thresh_Xlow;
              }
  
              if( nbr_info->wcdma.freq[i].num_wcdma_cells > NAS_MAX_LTE_NGBR_WCDMA_NUM_CELLS_V01 )
              {
                QM_MSG_ERROR_2("Received %d wcdma cells, max allowed %d", nbr_info->wcdma.freq[i].num_wcdma_cells, NAS_MAX_LTE_NGBR_WCDMA_NUM_CELLS_V01);
                rsp_msg->lte_wcdma.freqs[i].cells_len = NAS_MAX_LTE_NGBR_WCDMA_NUM_CELLS_V01;
              }
              else
              {
                rsp_msg->lte_wcdma.freqs[i].cells_len = nbr_info->wcdma.freq[i].num_wcdma_cells;
              }
  
              for( j=0; j<rsp_msg->lte_wcdma.freqs[i].cells_len; j++ )
              {
                rsp_msg->lte_wcdma.freqs[i].cells[j].psc = nbr_info->wcdma.freq[i].cell[j].psc;
                rsp_msg->lte_wcdma.freqs[i].cells[j].cpich_rscp = nbr_info->wcdma.freq[i].cell[j].cpich_rscp;
                rsp_msg->lte_wcdma.freqs[i].cells[j].cpich_ecno = nbr_info->wcdma.freq[i].cell[j].cpich_ecno;
                if( rsp_msg->lte_wcdma.ue_in_idle )
                {
                  rsp_msg->lte_wcdma.freqs[i].cells[j].srxlev = nbr_info->wcdma.freq[i].cell[j].idle.srxlev;
                }
              }
            }
  
            rsp_msg->lte_wcdma_valid = TRUE;

            if ( nbr_info->timing_advance <= NAS_0043_RSP_T1E_LTE_TIMING_ADVANCE_MAX )
          {
              rsp_msg->timing_advance_valid = TRUE;
              rsp_msg->timing_advance       = (int32_t) nbr_info->timing_advance;
            }
            else if ( nbr_info->timing_advance == CMAPI_TIMING_ADVANCE_INVALID )            // prevent possible Klocwork/compiler warnings
          {
              rsp_msg->timing_advance_valid = TRUE;
              rsp_msg->timing_advance       = (int32_t) CMAPI_TIMING_ADVANCE_INVALID;       // it's really not present, instead of invalid
          }
          else
          {
              QM_MSG_ERROR_1("nbr_info->timing_advance = 0x%08x, uint32 to large to represent in an int32.", nbr_info->timing_advance);
              rsp_msg->timing_advance_valid = FALSE;
            }

            if ( nbr_info->doppler_measurement <= 400 || nbr_info->doppler_measurement == 0xFFFF)
            {
              rsp_msg->doppler_measurement_valid = TRUE;
              rsp_msg->doppler_measurement       = (uint16_t) nbr_info->doppler_measurement;
            }
            else
            {
              QM_MSG_ERROR_1( "Recieved Invalid nbr_info->doppler_measurement = %d", nbr_info->doppler_measurement );
            }
            
          }
        }
      }
#endif // FEATURE_LTE
  
      if ( !rsp_msg->geran_info_valid && !rsp_msg->umts_info_valid && !rsp_msg->cdma_info_valid && !rsp_msg->lte_intra_valid )
      {
        errval = QMI_ERR_NO_NETWORK_FOUND_V01;
      }
    }
  
    if ( errval != QMI_ERR_NONE_V01 )
    {
      memset( rsp_msg, 0x00, sizeof(nas_get_cell_location_info_resp_msg_v01) );
    }
  
    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) QMI_NAS_GET_CELL_LOCATION_INFO_RESP_MSG_V01,
                                  (void *)rsp_msg,
                                  (uint32_t)sizeof(nas_get_cell_location_info_resp_msg_v01),
                                  &response
                                );
  }

  if ( rsp_msg != NULL ){ modem_mem_free((void *)rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_get_cell_location_info() */

/*===========================================================================
  FUNCTION QMI_NASI_BIND_SUBSCRIPTION()

  DESCRIPTION
    This message binds the current control point to a specific subscription

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_bind_subscription(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type    *response = NULL;
  qmi_error_e_type  errval = QMI_ERR_NONE;
  qmi_result_e_type result;
  boolean           retval;
  qmi_nasi_client_state_type *p_cs = (qmi_nasi_client_state_type*)cl_sp; // client state pointer

  struct nas_0045_req_s  req_msg;

  ASSERT(sp); ASSERT(cmd_buf_p); ASSERT(cl_sp); ASSERT(sdu_in);

  memset( &req_msg, 0, sizeof(req_msg));

  if ( errval == QMI_ERR_NONE && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_0045_req_read ( &req_msg, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_0045_req_check ( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    p_cs->report_status.bound_subs = (enum qmi_nas_subs_e)req_msg.t01.subscription_type;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();
  return response;
}

/*===========================================================================
   FUNCTION qmi_nas_map_standby_pref_cm_to_active_subs()

   DESCRIPTION
     Map standby_pref to active_subs based on the  cm ph info.

   PARAMETERS

   RETURN VALUE

   DEPENDENCIES
     None

   SIDE EFFECTS
     None
 ===========================================================================*/
void qmi_nas_map_standby_pref_cm_to_active_subs( 
  uint8* p_active_subs,
  qmi_cm_ph_info_s_type *p_ph_info
)
{
   uint8 cm_active_subs = *p_active_subs;

  switch(p_ph_info->standby_pref)
  {
    case SYS_MODEM_DS_PREF_NO_STANDBY_PREF:
      cm_active_subs = SYS_MODEM_AS_ID_NO_ACTIVE_MASK;
      break;
      
    case SYS_MODEM_DS_PREF_SINGLE_STANDBY:
      if(p_ph_info->active_subs == SYS_MODEM_AS_ID_2)
      {
         cm_active_subs = SYS_MODEM_AS_ID_2_MASK;
      }
#ifdef FEATURE_TRIPLE_SIM
      else if(p_ph_info->active_subs == SYS_MODEM_AS_ID_3)
      {
         cm_active_subs = SYS_MODEM_AS_ID_3_MASK;
      }
#endif
      else  if(p_ph_info->active_subs == SYS_MODEM_AS_ID_1)
      {
        cm_active_subs = SYS_MODEM_AS_ID_1_MASK;
      }
      break;

    case SYS_MODEM_DS_PREF_DUAL_STANDBY:
    case SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY:
      cm_active_subs = SYS_MODEM_AS_ID_1_MASK | SYS_MODEM_AS_ID_2_MASK;
      break;

#ifdef FEATURE_TRIPLE_SIM
    case SYS_MODEM_DS_PREF_TRIPLE_STANDBY:
    case SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY:
      cm_active_subs = SYS_MODEM_AS_ID_1_MASK | SYS_MODEM_AS_ID_2_MASK | SYS_MODEM_AS_ID_3_MASK;
      break;
#endif
    default:
      QM_MSG_ERROR_1("error in standby_pref value %d", p_ph_info->standby_pref);
      break;
  }
  *p_active_subs = cm_active_subs;
  QM_MSG_HIGH_2("standby_pref:%d, active_subs:%d", p_ph_info->standby_pref, cm_active_subs);
}
/*===========================================================================
  FUNCTION QMI_NASI_SET_DUAL_STANDBY_PREF_NEW()

  DESCRIPTION
    This message configures dual standby preference

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_dual_standby_pref_new(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_type_v01                     errval            = QMI_ERR_NONE_V01;
  nas_set_dual_standby_pref_resp_msg_v01 *resp_msg;
  qmi_cm_ph_info_s_type                  *p_info            = NULL;
  nas_subs_type_enum_v01                 last_standby_pref;

#if defined(FEATURE_DUAL_SIM) || defined(FEATURE_TRIPLE_SIM)
  nas_set_dual_standby_pref_req_msg_v01  *req_msg;
  sys_modem_dual_standby_pref_e_type     standby_pref       = SYS_MODEM_DS_PREF_NO_CHANGE;
  sys_modem_as_id_e_type                 default_data_subs  = SYS_MODEM_AS_ID_NO_CHANGE;
  sys_modem_as_id_e_type                 priority_subs      = SYS_MODEM_AS_ID_NO_CHANGE;
  sys_modem_as_id_e_type                 default_voice_subs = SYS_MODEM_AS_ID_NO_CHANGE;
  uint8                                  active_subs        = SYS_MODEM_AS_ID_NO_CHANGE_MASK;
  uint8                                  current_active_subs = SYS_MODEM_AS_ID_NO_CHANGE_MASK;
  cm_dds_cause_e_type                    dds_cause          = DDS_CAUSE_PERMANENT;
#endif

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error: sp %d cmd_buf_p %d cl_sp %d sdu_in %d",
                   sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_set_dual_standby_pref_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_dual_standby_pref_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

#if defined(FEATURE_DUAL_SIM) || defined(FEATURE_TRIPLE_SIM)
  req_msg  = (nas_set_dual_standby_pref_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_dual_standby_pref_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0, sizeof(nas_set_dual_standby_pref_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_dual_standby_pref_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_004B_req_check ( req_msg );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    switch ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs )
    {
#ifdef FEATURE_TRIPLE_SIM
      case QMI_NAS_SUBS_TERTIARY:
        p_info = &qmi_nasi_global.cm_ph_info3;
        break;
#endif
#ifdef FEATURE_DUAL_SIM
      case QMI_NAS_SUBS_SECONDARY:
        p_info = &qmi_nasi_global.cm_ph_info2;
        break;
#endif
      case QMI_NAS_SUBS_PRIMARY:
        p_info = &qmi_nasi_global.cm_ph_info;
        break;
      default:
        QM_MSG_ERROR_1("bound_subs not valid %d", ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs);
        errval = QMI_ERR_INTERNAL_V01;
        break;
    }
  }


  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( req_msg->standby_pref_valid ) { standby_pref             = (sys_modem_dual_standby_pref_e_type)req_msg->standby_pref; }
    if ( req_msg->priority_subs_valid ) { priority_subs           = (sys_modem_as_id_e_type)req_msg->priority_subs;            }
    if ( req_msg->default_data_subs_valid ) { default_data_subs   = (sys_modem_as_id_e_type)req_msg->default_data_subs;        }
    if ( req_msg->default_voice_subs_valid ) { default_voice_subs = (sys_modem_as_id_e_type)req_msg->default_voice_subs;       }
    if ( req_msg->dds_duration_valid ) { dds_cause                = (cm_dds_cause_e_type)req_msg->dds_duration;                }

    if ( req_msg->active_subs_mask_valid ) 
    {
      if ( req_msg->active_subs_mask == 0 )
      {
        standby_pref = SYS_MODEM_DS_PREF_NO_STANDBY_PREF;
        active_subs = SYS_MODEM_AS_ID_NO_ACTIVE_MASK;
      }
#ifdef FEATURE_TRIPLE_SIM
      else if ( req_msg->active_subs_mask == 
               (QMI_NAS_ACTIVE_SUB_PRIMARY_V01|QMI_NAS_ACTIVE_SUB_SECONDARY_V01|QMI_NAS_ACTIVE_SUB_TERTIARY_V01) )
      {
        standby_pref = SYS_MODEM_DS_PREF_TRIPLE_STANDBY;
        active_subs = (uint8)req_msg->active_subs_mask;
      }
#endif
      else if ( req_msg->active_subs_mask == (QMI_NAS_ACTIVE_SUB_PRIMARY_V01|QMI_NAS_ACTIVE_SUB_SECONDARY_V01) )
      {
        standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
        active_subs = (uint8)req_msg->active_subs_mask;
      }
#ifdef FEATURE_TRIPLE_SIM
      else if ( req_msg->active_subs_mask == (QMI_NAS_ACTIVE_SUB_PRIMARY_V01|QMI_NAS_ACTIVE_SUB_TERTIARY_V01) )
      {
        standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
        active_subs = (uint8)req_msg->active_subs_mask;
      }
      else if ( req_msg->active_subs_mask == (QMI_NAS_ACTIVE_SUB_SECONDARY_V01|QMI_NAS_ACTIVE_SUB_TERTIARY_V01) )
      {
        standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
        active_subs = (uint8)req_msg->active_subs_mask;
      }
      else if ( req_msg->active_subs_mask == QMI_NAS_ACTIVE_SUB_TERTIARY_V01 )
      {
        standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
        active_subs = SYS_MODEM_AS_ID_3_MASK;
      }
#endif
      else if ( req_msg->active_subs_mask & QMI_NAS_ACTIVE_SUB_SECONDARY_V01 )
      {
        standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
        active_subs = SYS_MODEM_AS_ID_2_MASK;
      }
      else
      {
        standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
        active_subs = SYS_MODEM_AS_ID_1_MASK;
      }
    }

    if(p_info != NULL && errval == QMI_ERR_NONE_V01)
    {
      qmi_nas_map_standby_pref_cm_to_qmi((uint32*)&last_standby_pref, p_info->standby_pref );
      qmi_nas_map_standby_pref_cm_to_active_subs(&current_active_subs, p_info );

      if ( ( !req_msg->standby_pref_valid || req_msg->standby_pref == last_standby_pref) &&
           ( !req_msg->priority_subs_valid || req_msg->priority_subs == (nas_subs_type_enum_v01)p_info->priority_subs )  &&
           ( !req_msg->default_data_subs_valid || req_msg->default_data_subs == (nas_subs_type_enum_v01)p_info->default_data_subs) &&
           ( !req_msg->default_voice_subs_valid || req_msg->default_voice_subs == (nas_subs_type_enum_v01)p_info->default_voice_subs) &&
           ( !req_msg->active_subs_mask_valid || active_subs == current_active_subs) &&
	   ( !req_msg->dds_duration_valid || req_msg->dds_duration == (nas_dds_duration_enum_v01)qmi_nasi_global.subs_info[((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs].dds_switch_type)
         )
      {
        QM_MSG_ERROR("Duplicate dual standby request. Rejecting");
        errval = QMI_ERR_NO_EFFECT_V01;
      }
    }

    QM_MSG_HIGH_3("Active subs mask %d, standby %d, active subs %d", req_msg->active_subs_mask, standby_pref, active_subs);
    if ( errval == QMI_ERR_NONE_V01 )
    {
      if ( !cm_ph_cmd_dual_standby_pref_1( qmi_nas_cmph_cmd_cb,
                                         cmd_buf_p,
                                         qmi_nasi_global.cm_clnt_id,
                                         standby_pref,
                                         active_subs,
                                         default_voice_subs,
                                         default_data_subs,
                                       priority_subs ,
                                       dds_cause) )
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("cm_ph_cmd_dual_standby_pref() failed");
      }
    }
  }
#else
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    if ( resp_msg != NULL )
    {
      memset(resp_msg, 0, sizeof(nas_set_dual_standby_pref_resp_msg_v01) );
      resp_msg->resp.error  = errval;
      resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
    
      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                    (void *)resp_msg,
                                    (uint32_t)sizeof(nas_set_dual_standby_pref_resp_msg_v01),
                                    &response
                                  );
    }
    else
    {
      qmi_voice_mem_error();
    }
  }
#if defined(FEATURE_DUAL_SIM) || defined(FEATURE_TRIPLE_SIM)
  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
#endif
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}
#if 0

/*===========================================================================
  FUNCTION qmi_nas_get_subs_from_asid()

  DESCRIPTION
    Retrieve subscription information that is mapped to provided asubs_id

  PARAMETERS
    asubs_id

  RETURN VALUE
    subscription information that is mapped to provided asubs_id.
    QMI_NAS_SUBS_NONE if asubs_id is not operational
===========================================================================*/
enum qmi_nas_subs_e qmi_nas_get_subs_from_asid( sys_modem_as_id_e_type asubs_id )
{
  enum qmi_nas_subs_e subs = QMI_NAS_SUBS_NONE;

#ifdef FEATURE_DUAL_SIM
  if ( qmi_nasi_global.subs_info[asubs_id].is_operational )
  {
    switch ( qmi_nasi_global.subs_info[asubs_id].session_type )
    {
      case MMGSDI_GW_PROV_PRI_SESSION:
      case MMGSDI_1X_PROV_PRI_SESSION:
        subs = QMI_NAS_SUBS_PRIMARY;
        break;

      case MMGSDI_GW_PROV_SEC_SESSION:
      case MMGSDI_1X_PROV_SEC_SESSION:
        subs = QMI_NAS_SUBS_SECONDARY;
        break;
#ifdef FEATURE_TRIPLE_SIM
      case MMGSDI_GW_PROV_TER_SESSION:
        subs = QMI_NAS_SUBS_TERTIARY;
        break;
#endif
      default:
        QM_MSG_HIGH_1("unknown session %d", qmi_nasi_global.subs_info[asubs_id].session_type);
        break;
    }
  }
  else
  {
    QM_MSG_HIGH_1("subs id %d not operational", asubs_id);
  }
#else
  switch ( asubs_id )
  {
    case SYS_MODEM_AS_ID_1:  subs = QMI_NAS_SUBS_PRIMARY;   break;
    default:                                                break;
  }
#endif

  return subs;
}

/*===========================================================================
  FUNCTION qmi_nas_get_asid_from_subs()

  DESCRIPTION
    Retrieve asubs_id information that is mapped to provided subscription type

  PARAMETERS
    subscription type

  RETURN VALUE
    asubs_id information that is mapped to provided subscription information.
    SYS_MODEM_AS_ID_NONE if there is no asubs_id mapped to subscription type
===========================================================================*/
sys_modem_as_id_e_type qmi_nas_get_asid_from_subs( enum qmi_nas_subs_e subs_type )
{
  sys_modem_as_id_e_type asubs_id = SYS_MODEM_AS_ID_NONE;
#ifdef FEATURE_DUAL_SIM
  int                    i, found = 0;

  for ( i=SYS_MODEM_AS_ID_1; i<=SYS_MODEM_AS_ID_3; i++ )
  {
    if ( qmi_nasi_global.subs_info[i].is_operational )
    {
      if ( subs_type == QMI_NAS_SUBS_PRIMARY )
      {
        if ( qmi_nasi_global.subs_info[i].session_type == MMGSDI_GW_PROV_PRI_SESSION ||
             qmi_nasi_global.subs_info[i].session_type == MMGSDI_1X_PROV_PRI_SESSION ||
             qmi_nasi_global.subs_info[i].session_type == MMGSDI_MAX_SESSION_TYPE_ENUM /* subscription from nv. for cdma */)
        {
          found = 1;
        }
      }
#ifdef FEATURE_DUAL_SIM
      else if ( subs_type == QMI_NAS_SUBS_SECONDARY )
      {
        if ( qmi_nasi_global.subs_info[i].session_type == MMGSDI_GW_PROV_SEC_SESSION ||
             qmi_nasi_global.subs_info[i].session_type == MMGSDI_1X_PROV_SEC_SESSION )
        {
          found = 1;
        }
      }
#endif
#ifdef FEATURE_TRIPLE_SIM
      else if ( subs_type == QMI_NAS_SUBS_TERTIARY )
      {
        if ( qmi_nasi_global.subs_info[i].session_type == MMGSDI_GW_PROV_TER_SESSION ||
             qmi_nasi_global.subs_info[i].session_type == MMGSDI_1X_PROV_TER_SESSION )
        {
          found = 1;
        }
      }
#endif
    }

    if ( found )
      break;
  }

  if ( i <= SYS_MODEM_AS_ID_3 )
  {
    asubs_id = (sys_modem_as_id_e_type)i;
  }
  else
  {
    QM_MSG_HIGH_1("subs type of %d not found", subs_type);
  }
#else
  switch ( subs_type )
  {
    case QMI_NAS_SUBS_PRIMARY:   asubs_id = SYS_MODEM_AS_ID_1; break;
    default:                                                   break;
  }
#endif

  return asubs_id;
}
#endif

/*===========================================================================
  FUNCTION QMI_NASI_GET_SYS_INFO()

  DESCRIPTION
    Returns the current serving system registration state and radio
    technology information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_sys_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;
  sys_modem_as_id_e_type    asubs_id = SYS_MODEM_AS_ID_1;
  cm_mm_msim_ss_info_s_type *p_ss_info = NULL;
  uint8 asubs_max = sizeof(qmi_nasi_global.cm_msim_ss_info)/sizeof(qmi_nasi_global.cm_msim_ss_info[0]);
  enum qmi_nas_subs_e bound_subs;
  qmi_cm_ph_info_s_type        *p_ph_info = &qmi_nasi_global.cm_ph_info;

  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  nas_get_sys_info_resp_msg_v01 * nas_get_sys_info_resp;

  nas_get_sys_info_resp = (nas_get_sys_info_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_sys_info_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr 0x%x 0x%x 0x%x 0x%x", sp, cmd_buf_p, cl_sp, sdu_in);
    //QM_MSG_ERROR_1("null ptr 0x%x", sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }
  else
  {
    bound_subs = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
    if( 
        (bound_subs > QMI_NAS_SUBS_NONE) && 
        (bound_subs < asubs_max) 
      )
    {
      QM_MSG_HIGH("p_ss_info assigned");
      p_ss_info = &qmi_nasi_global.cm_msim_ss_info[bound_subs];
    }
  }

  if(!p_ss_info)
  {
    QM_MSG_ERROR("p_ss_info is NULL");
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( !qmi_nasi_global.rcvd_ss_info )
    {
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    }
  }

#ifdef FEATURE_DUAL_SIM
  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
      p_ph_info = &qmi_nasi_global.cm_ph_info2;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY)
    {
      asubs_id = SYS_MODEM_AS_ID_3;
      p_ph_info = &qmi_nasi_global.cm_ph_info3;
    }
#endif // FEATURE_TRIPLE_SIM
  }
#endif

  if ( nas_get_sys_info_resp != NULL && cmd_buf_p != NULL )
  {
    memset( nas_get_sys_info_resp, 0x00, sizeof( nas_get_sys_info_resp_msg_v01 ) );

    if( errval == QMI_ERR_NONE_V01 )
  {
      errval =  qmi_nas_generate_sys_info_msg( p_ss_info, p_ph_info, nas_get_sys_info_resp, asubs_id ); 
  }

    nas_get_sys_info_resp->resp.error  = errval;
    nas_get_sys_info_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) nas_get_sys_info_resp,
                                  (uint32_t) sizeof( nas_get_sys_info_resp_msg_v01 ),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( nas_get_sys_info_resp != NULL ) { modem_mem_free( (void *) nas_get_sys_info_resp, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_sys_info */

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_SYS_INFO_MSG ()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to generate
    qmi_nas_sys_info_type message from a given CM SS and PH info. To be used
    in QMI_NAS_GET_SYS_INFO

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    cm_ph_info_s_type    CM PH info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_error_type_v01 qmi_nas_generate_sys_info_msg(
    cm_mm_msim_ss_info_s_type   *p_ss_info,
    qmi_cm_ph_info_s_type      *p_ph_info,
  nas_get_sys_info_resp_msg_v01 * nas_get_sys_info_resp,
    sys_modem_as_id_e_type asubs_id
)
{
  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  enum qm_stack_index_e stack_index = STACK_INDEX_0;
  memset( nas_get_sys_info_resp, 0x00, sizeof(nas_get_sys_info_resp_msg_v01) );

  /////////////////////////////////////////////////////////
  // CDMA
  /////////////////////////////////////////////////////////

  if ( TARGET_SUPPORTS_CDMA && asubs_id == SYS_MODEM_AS_ID_1)
  {

    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_CDMA)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_CDMA)
    { 
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }
    // TLV 0x10

#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    nas_get_sys_info_resp->cdma_srv_status_info.srv_status = qmi_nas_get_srv_status_from_cmss_event(p_ss_info, stack_index, SYS_SYS_MODE_CDMA);
#else
    if(stack_index != STACK_INDEX_MAX)
    {
     nas_get_sys_info_resp->cdma_srv_status_info.srv_status = (nas_service_status_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].srv_status ;
    }
    else
    {
      nas_get_sys_info_resp->cdma_srv_status_info.srv_status = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
#endif // FEATURE_MMODE_REPORT_POWERSAVE

    nas_get_sys_info_resp->cdma_srv_status_info.is_pref_data_path = ( p_ss_info->stack_info[STACK_INDEX_0].cur_idle_digital_mode == SYS_SYS_MODE_CDMA );  // ? TRUE : FALSE;
    nas_get_sys_info_resp->cdma_srv_status_info_valid             = TRUE;

    if ( nas_get_sys_info_resp->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         nas_get_sys_info_resp->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      // TLV 0x15
      nas_get_sys_info_resp->cdma_sys_info_valid                                          = TRUE;

      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.srv_domain_valid               = TRUE;
      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.srv_domain                     = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].srv_domain;

      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.srv_capability_valid           = TRUE;
      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.srv_capability                 = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].srv_capability;

      if ( p_ss_info->stack_info[STACK_INDEX_0].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.roam_status_valid              = TRUE;
        nas_get_sys_info_resp->cdma_sys_info.common_sys_info.roam_status                    = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].roam_status;
      }

      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.is_sys_forbidden_valid         = TRUE;
      nas_get_sys_info_resp->cdma_sys_info.common_sys_info.is_sys_forbidden               = p_ss_info->stack_info[STACK_INDEX_0].is_sys_forbidden;

      nas_get_sys_info_resp->cdma_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match_valid  = TRUE;
      nas_get_sys_info_resp->cdma_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match        = p_ss_info->stack_info[STACK_INDEX_0].is_sys_prl_match ;

      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.p_rev_in_use != CM_SS_P_REV_IN_USE_NONE )
      {
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.p_rev_in_use_valid    = TRUE;
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.p_rev_in_use          = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.p_rev_in_use;
      }

      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.bs_p_rev != CM_SS_BS_P_REV_NONE )
      {
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.bs_p_rev_valid        = TRUE;
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.bs_p_rev              = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.bs_p_rev;
      }

      nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.ccs_supported_valid     = TRUE;
      nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.ccs_supported           = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.ccs_supported;

      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_id.id_type == SYS_SYS_ID_TYPE_IS95 )
      {
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.cdma_sys_id_valid     = TRUE;
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.cdma_sys_id.sid       = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.sid;
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.cdma_sys_id.nid       = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.nid;
      }

      nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.bs_info_valid           = TRUE;
      nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.bs_info.base_id         = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_id;
      nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.bs_info.base_lat        = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_lat;
      nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.bs_info.base_long       = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_long;

      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.packet_zone != 0x00)
      {
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.packet_zone_valid     = TRUE;
        nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.packet_zone           = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.packet_zone;
      }

      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_id.id_type == SYS_SYS_ID_TYPE_IS95 )
      {
        if ( p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.mcc == 0 && p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.imsi_11_12 == 0 )
        {
          nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.network_id_valid    = FALSE;
        }
        else
        {
          nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.network_id_valid    = TRUE;
          convert_cdma_mcc_2_ascii_mcc( nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.network_id.mcc, p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.mcc );        // TODO apply decoding
          convert_cdma_mnc_2_ascii_mnc( nas_get_sys_info_resp->cdma_sys_info.cdma_specific_sys_info.network_id.mnc, p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.imsi_11_12 ); // TODO apply decoding
        }

        if(p_ss_info->current_mcc < 1000)
        {
          nas_get_sys_info_resp->cdma_mcc_resolved_via_sid_lookup                         = p_ss_info->current_mcc;
          nas_get_sys_info_resp->cdma_mcc_resolved_via_sid_lookup_valid                   = TRUE;
        }
      }

    // TLV 0x1A additional CDMA sys info
      nas_get_sys_info_resp->cdma_sys_info2_valid                                         = TRUE;

      nas_get_sys_info_resp->cdma_sys_info2.geo_sys_idx                                   = p_ss_info->stack_info[STACK_INDEX_0].geo_sys_idx;
      nas_get_sys_info_resp->cdma_sys_info2.reg_prd                                       = p_ss_info->stack_info[STACK_INDEX_0].rat_mode_info.cdma_mode_info.cdma_reg_prd;

    // TLV 0x2B CDMA Reg Zone
      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.reg_zone != CM_SS_REG_ZONE_NONE )
      {
        nas_get_sys_info_resp->cdma_reg_zone_valid                                        = TRUE;
        nas_get_sys_info_resp->cdma_reg_zone                                              = ( NAS_004D_CDMA_REG_ZONE_MASK & p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.reg_zone );
    }

      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_CDMA &&
           ( p_ss_info->stack_info[STACK_INDEX_0].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[STACK_INDEX_0].srv_domain  == SYS_SRV_DOMAIN_CS_PS))
      {
        nas_get_sys_info_resp->cdma_voice_status_valid = TRUE;
        nas_get_sys_info_resp->cdma_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        nas_get_sys_info_resp->cdma_sms_status_valid = TRUE;
        nas_get_sys_info_resp->cdma_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }
    }
  } // end CDMA

  /////////////////////////////////////////////////////////
  // HDR
  /////////////////////////////////////////////////////////

  if( TARGET_SUPPORTS_HDR && asubs_id == SYS_MODEM_AS_ID_1)
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_HDR)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_HDR)
    { 
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }

    //TLV 0x11
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    nas_get_sys_info_resp->hdr_srv_status_info.srv_status                                 = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, stack_index, SYS_SYS_MODE_HDR );
#else
    if( stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->hdr_srv_status_info.srv_status                               = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
    }
    else
    {
      nas_get_sys_info_resp->hdr_srv_status_info.srv_status                               = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
#endif // FEATURE_MMODE_REPORT_POWERSAVE

    if( stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->hdr_srv_status_info.is_pref_data_path                        = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_HDR );
    }
    nas_get_sys_info_resp->hdr_srv_status_info_valid                                      = TRUE;

    //TLV 0x16
    if ( nas_get_sys_info_resp->hdr_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         nas_get_sys_info_resp->hdr_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01  &&
         stack_index != STACK_INDEX_MAX)
    {
      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.srv_domain_valid                = TRUE;
      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.srv_domain                      = SYS_SRV_DOMAIN_PS_ONLY_V01;

      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.srv_capability_valid            = TRUE;
      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.srv_capability                  = SYS_SRV_DOMAIN_PS_ONLY_V01;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.roam_status_valid               = TRUE;
        nas_get_sys_info_resp->hdr_sys_info.common_sys_info.roam_status                   = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
      }

      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.is_sys_forbidden_valid          = TRUE;
      nas_get_sys_info_resp->hdr_sys_info.common_sys_info.is_sys_forbidden                = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      nas_get_sys_info_resp->hdr_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match_valid   = TRUE;
      nas_get_sys_info_resp->hdr_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match         = p_ss_info->stack_info[stack_index].is_sys_prl_match ;

      if( p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_personality != SYS_PERSONALITY_NONE )
      {
        nas_get_sys_info_resp->hdr_sys_info.hdr_specific_sys_info.hdr_personality_valid   = TRUE;
        nas_get_sys_info_resp->hdr_sys_info.hdr_specific_sys_info.hdr_personality         = (nas_hdr_personality_enum_type_v01)p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_personality;
      }

      if( p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_active_prot != SYS_ACTIVE_PROT_NONE )
      {
        nas_get_sys_info_resp->hdr_sys_info.hdr_specific_sys_info.hdr_active_prot_valid   = TRUE;
        nas_get_sys_info_resp->hdr_sys_info.hdr_specific_sys_info.hdr_active_prot         = (nas_hdr_active_prot_enum_type_v01)p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_active_prot;
      }

      if ( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_IS856 )
        {
          nas_get_sys_info_resp->hdr_sys_info.hdr_specific_sys_info.is856_sys_id_valid    = TRUE;
          memscpy( &nas_get_sys_info_resp->hdr_sys_info.hdr_specific_sys_info.is856_sys_id, 
                   NAS_IS_856_MAX_LEN,
                 p_ss_info->stack_info[stack_index].sys_id.id.is856, NAS_IS_856_MAX_LEN );
        }
      nas_get_sys_info_resp->hdr_sys_info_valid                                           = TRUE;

    // TLV 0x1B additional HDR sys info
      nas_get_sys_info_resp->hdr_sys_info2_valid                                          = TRUE;
      nas_get_sys_info_resp->hdr_sys_info2.geo_sys_idx                                  = p_ss_info->stack_info[stack_index].geo_sys_idx;

      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        nas_get_sys_info_resp->hdr_voice_status_valid = TRUE;
        nas_get_sys_info_resp->hdr_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        nas_get_sys_info_resp->hdr_sms_status_valid = TRUE;
        nas_get_sys_info_resp->hdr_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }

      nas_get_sys_info_resp->hdr_subnet_mask_len_valid = TRUE;
      nas_get_sys_info_resp->hdr_subnet_mask_len = p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.subnet_mask_len;
    }
  } // end HDR

  /////////////////////////////////////////////////////////
  // GSM
  /////////////////////////////////////////////////////////

  if( TARGET_SUPPORTS_GSM )
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_GSM)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_GSM)
    {
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }

    //TLV 0x12
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
      nas_get_sys_info_resp->gsm_srv_status_info.srv_status                               = qmi_nas_get_srv_status_from_cmss_event(p_ss_info, stack_index, SYS_SYS_MODE_GSM);
#else
      if( stack_index != STACK_INDEX_MAX )
      {
        nas_get_sys_info_resp->gsm_srv_status_info.srv_status                             = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
      }
      else
      {
        nas_get_sys_info_resp->gsm_srv_status_info.srv_status                             = NAS_SYS_SRV_STATUS_NO_SRV_V01;
      }
#endif // FEATURE_MMODE_REPORT_POWERSAVE

      if( stack_index != STACK_INDEX_MAX )
      {
        nas_get_sys_info_resp->gsm_srv_status_info.true_srv_status                        =  (nas_true_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].true_srv_status;
        nas_get_sys_info_resp->gsm_srv_status_info.is_pref_data_path                      = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_GSM );
    }
    else
    {
        nas_get_sys_info_resp->gsm_srv_status_info.true_srv_status                        =  SYS_SRV_STATUS_NO_SRV_V01;
      }
      nas_get_sys_info_resp->gsm_srv_status_info_valid                                    = TRUE;


    //TLV 0x17
    if ( nas_get_sys_info_resp->gsm_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         nas_get_sys_info_resp->gsm_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 &&
         stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->gsm_sys_info.common_sys_info.srv_domain_valid                = TRUE;
      nas_get_sys_info_resp->gsm_sys_info.common_sys_info.srv_capability_valid            = TRUE;
      nas_get_sys_info_resp->gsm_sys_info.common_sys_info.is_sys_forbidden_valid          = TRUE;

      nas_get_sys_info_resp->gsm_sys_info.common_sys_info.srv_domain                      =  (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_domain;
      nas_get_sys_info_resp->gsm_sys_info.common_sys_info.srv_capability                  =  (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_capability;
      nas_get_sys_info_resp->gsm_sys_info.common_sys_info.is_sys_forbidden              =  p_ss_info->stack_info[stack_index].is_sys_forbidden;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
        nas_get_sys_info_resp->gsm_sys_info.common_sys_info.roam_status                   =  (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
        nas_get_sys_info_resp->gsm_sys_info.common_sys_info.roam_status_valid               = TRUE;
      }

      nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.lac                =  qmi_nas_get_lac( p_ss_info, stack_index );

      if ( nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.lac != QMI_NAS_INVALID_LAC )
      {
        nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.lac_valid          = TRUE;
      }

      nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.cell_id_valid    = TRUE;
      nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.cell_id          = p_ss_info->stack_info[stack_index].cell_info.cell_id;

      if( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->stack_info[stack_index].sys_id.id.plmn ))
      {
        nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.network_id_valid = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].sys_id.id.plmn );
      }

      if( p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
        {
          nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain;
        nas_get_sys_info_resp->gsm_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->stack_info[stack_index].reg_reject_info.reject_cause;
      }

      nas_get_sys_info_resp->gsm_sys_info.gsm_specific_sys_info.egprs_supp_valid          = TRUE;
      nas_get_sys_info_resp->gsm_sys_info.gsm_specific_sys_info.dtm_supp_valid            = TRUE;


      nas_get_sys_info_resp->gsm_sys_info.gsm_specific_sys_info.egprs_supp              = p_ss_info->stack_info[stack_index].cell_srv_ind.egprs_supp;
      nas_get_sys_info_resp->gsm_sys_info.gsm_specific_sys_info.dtm_supp                = p_ss_info->stack_info[stack_index].cell_srv_ind.dtm_supp;

      nas_get_sys_info_resp->gsm_sys_info_valid                                           = TRUE;

      nas_get_sys_info_resp->gsm_sys_info2_valid                                          = TRUE;
      nas_get_sys_info_resp->gsm_sys_info2.geo_sys_idx                                  = p_ss_info->stack_info[stack_index].geo_sys_idx;
      nas_get_sys_info_resp->gsm_sys_info2.cell_broadcast_cap                           = (nas_cell_broadcast_cap_enum_type_v01)p_ss_info->stack_info[stack_index].cell_bc_info.cell_bc_capability;

    // TLV 0x1F GSM Cell Access info
      nas_get_sys_info_resp->gsm_sys_info3_valid                                          = TRUE;
      if ( p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
      {
        nas_get_sys_info_resp->gsm_sys_info3.cs_bar_status                              = (nas_cell_access_status_e_type_v01) p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status;
      }
      else
      {
          nas_get_sys_info_resp->gsm_sys_info3.cs_bar_status                              = NAS_CELL_ACCESS_UNKNOWN_V01;
        }

      if ( p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        nas_get_sys_info_resp->gsm_sys_info3.ps_bar_status                              = (nas_cell_access_status_e_type_v01) p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status;
        }
        else
        {
          nas_get_sys_info_resp->gsm_sys_info3.ps_bar_status                              = NAS_CELL_ACCESS_UNKNOWN_V01;
      }

    // TLV 0x22 GSM Cipher Domain info
      nas_get_sys_info_resp->gsm_cipher_domain_valid                                      = TRUE;
      nas_get_sys_info_resp->gsm_cipher_domain                                            = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].cipher_domain;

    // TLV 0x2C GSM RAC
      if( p_ss_info->stack_info[stack_index].rat_mode_info.gsm_mode_info.rac_or_mme_code != 0xFF )
        {
          nas_get_sys_info_resp->gsm_rac_valid       = TRUE;
        nas_get_sys_info_resp->gsm_rac                                                    =  p_ss_info->stack_info[stack_index].rat_mode_info.gsm_mode_info.rac_or_mme_code ;
    }

    // TLV 0x33 GSM Possible Registration Domain
      if (  p_ss_info->stack_info[stack_index].available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        nas_get_sys_info_resp->gsm_reg_domain_valid                                       = TRUE;
        nas_get_sys_info_resp->gsm_reg_domain                                             = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->stack_info[stack_index].available_plmn_type );
    }

      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        nas_get_sys_info_resp->gsm_voice_status_valid = TRUE;
        nas_get_sys_info_resp->gsm_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );
        nas_get_sys_info_resp->gsm_sms_status_valid = TRUE;
        nas_get_sys_info_resp->gsm_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }
    }// NO_SRV/NO_PWR_SAVE
  }//End GSM

  /////////////////////////////////////////////////////////
  // WCDMA
  /////////////////////////////////////////////////////////

  if( TARGET_SUPPORTS_WCDMA )
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_WCDMA)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_WCDMA)
    { 
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }

    //TLV 0x13

#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    nas_get_sys_info_resp->wcdma_srv_status_info.srv_status                             = qmi_nas_get_srv_status_from_cmss_event(p_ss_info, stack_index, SYS_SYS_MODE_WCDMA);
#else
    if( stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->wcdma_srv_status_info.srv_status                           = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
    }
    else
    {
      nas_get_sys_info_resp->wcdma_srv_status_info.srv_status                           = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
#endif // FEATURE_MMODE_REPORT_POWERSAVE

    if( stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->wcdma_srv_status_info.true_srv_status                      = (nas_true_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].true_srv_status;
      nas_get_sys_info_resp->wcdma_srv_status_info.is_pref_data_path                    = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_WCDMA ) ;
    }
    else
    {
      nas_get_sys_info_resp->wcdma_srv_status_info.true_srv_status                      = SYS_SRV_STATUS_NO_SRV_V01;
    }
      nas_get_sys_info_resp->wcdma_srv_status_info_valid                                  = TRUE;

    if ( nas_get_sys_info_resp->wcdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         nas_get_sys_info_resp->wcdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 &&
         stack_index != STACK_INDEX_MAX )
    {
      //TLV 0x18
      nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.srv_domain_valid              = TRUE;
      nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.srv_capability_valid          = TRUE;
      nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.is_sys_forbidden_valid        = TRUE;

      nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.srv_domain                  = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_domain;
      nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.srv_capability              = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_capability;
      nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.is_sys_forbidden            = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
        nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.roam_status                 = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
        nas_get_sys_info_resp->wcdma_sys_info.common_sys_info.roam_status_valid             = TRUE;
      }

      nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.lac              = qmi_nas_get_lac( p_ss_info, stack_index );

      if ( nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.lac != QMI_NAS_INVALID_LAC )
      {
        nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.lac_valid        = TRUE;
      }

      nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.cell_id_valid  = TRUE;
      nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.cell_id        = p_ss_info->stack_info[stack_index].cell_info.cell_id;

      if( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->stack_info[stack_index].sys_id.id.plmn ))
      {
        nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.network_id_valid = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].sys_id.id.plmn);
      }

      nas_get_sys_info_resp->wcdma_sys_info.wcdma_specific_sys_info.hs_call_status_valid  = TRUE;
      nas_get_sys_info_resp->wcdma_sys_info.wcdma_specific_sys_info.hs_ind_valid          = TRUE;

      nas_get_sys_info_resp->wcdma_sys_info.wcdma_specific_sys_info.hs_call_status      = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_call_status;
      nas_get_sys_info_resp->wcdma_sys_info.wcdma_specific_sys_info.hs_ind              = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_ind;

      if( p_ss_info->stack_info[stack_index].cell_info.psc != 0xFFFF )
        {
          nas_get_sys_info_resp->wcdma_sys_info.wcdma_specific_sys_info.psc_valid         = TRUE;
        nas_get_sys_info_resp->wcdma_sys_info.wcdma_specific_sys_info.psc               = p_ss_info->stack_info[stack_index].cell_info.psc;
      }

      if( p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
        {
          nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain;
        nas_get_sys_info_resp->wcdma_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->stack_info[stack_index].reg_reject_info.reject_cause;
      }

      nas_get_sys_info_resp->wcdma_sys_info_valid                                         = TRUE;

    // TLV 0x1D additional UMTS sys info
      nas_get_sys_info_resp->wcdma_sys_info2_valid                                        = TRUE;
      nas_get_sys_info_resp->wcdma_sys_info2.geo_sys_idx                                  = p_ss_info->stack_info[stack_index].geo_sys_idx;
      nas_get_sys_info_resp->wcdma_sys_info2.cell_broadcast_cap                           = (nas_cell_broadcast_cap_enum_type_v01) p_ss_info->stack_info[stack_index].cell_bc_info.cell_bc_capability;

    // TLV 0x20 WCDMA Cell Access info
      nas_get_sys_info_resp->wcdma_sys_info3_valid                                        = TRUE;

      if ( p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        nas_get_sys_info_resp->wcdma_sys_info3.cs_bar_status                            = (nas_cell_access_status_e_type_v01) p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status;
        }
        else
        {
          nas_get_sys_info_resp->wcdma_sys_info3.cs_bar_status                            = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
      if ( p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        nas_get_sys_info_resp->wcdma_sys_info3.ps_bar_status                            = (nas_cell_access_status_e_type_v01) p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status;
        }
        else
        {
          nas_get_sys_info_resp->wcdma_sys_info3.ps_bar_status                            = NAS_CELL_ACCESS_UNKNOWN_V01;
      }

    // TLV 0x23 WCDMA Cipher Domain info
      nas_get_sys_info_resp->wcdma_cipher_domain_valid                                    = TRUE;
      nas_get_sys_info_resp->wcdma_cipher_domain                                          = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].cipher_domain;

    // TLV 0x28 WCDMA E-UTRA Status info
      nas_get_sys_info_resp->wcdma_eutra_status_valid                                     = TRUE;
      nas_get_sys_info_resp->wcdma_eutra_status                                           = (nas_eutra_cell_status_enum_type_v01) qmi_nas_eutra_status_cm_2_qmi( p_ss_info->eutra_detect_status );

    // TLV 0x2D WCDMA RAC
      if( p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.rac_or_mme_code != 0xFF )
        {
          nas_get_sys_info_resp->wcdma_rac_valid                                            = TRUE;
        nas_get_sys_info_resp->wcdma_rac                                                  = p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.rac_or_mme_code;
    }

    // TLV 0x32 WCDMA Possible Registration Domain
      if ( p_ss_info->stack_info[stack_index].available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        nas_get_sys_info_resp->wcdma_reg_domain_valid                                     = TRUE;
        nas_get_sys_info_resp->wcdma_reg_domain                                           = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->stack_info[stack_index].available_plmn_type);
    }

      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        nas_get_sys_info_resp->wcdma_voice_status_valid = TRUE;
        nas_get_sys_info_resp->wcdma_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        nas_get_sys_info_resp->wcdma_sms_status_valid = TRUE;
        nas_get_sys_info_resp->wcdma_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }

#ifdef FEATURE_FEMTO_CSG
  if ( qm_efs_csg_supported() )
  {
        if( p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.csg_id != SYS_CSG_ID_INVALID )
      {
        nas_get_sys_info_resp->wcdma_csg_info_valid = TRUE;
          nas_get_sys_info_resp->wcdma_csg_info.id = p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.csg_id;
          nas_get_sys_info_resp->wcdma_csg_info.name_len = MIN(p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.length, NAS_CSG_NAME_MAX_V01);
        memscpy( nas_get_sys_info_resp->wcdma_csg_info.name, 
                 nas_get_sys_info_resp->wcdma_csg_info.name_len,
                   p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.name, 
                 nas_get_sys_info_resp->wcdma_csg_info.name_len);
          QM_MSG_HIGH_2("CM SS Evt csg_id %d, name_len %d", p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.csg_id, p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.length);
      }
      }
#endif
    }
  } // end WCDMA

  /////////////////////////////////////////////////////////
  // LTE
  /////////////////////////////////////////////////////////

  if( TARGET_SUPPORTS_LTE )
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_LTE)
  {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE)
    { 
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }

#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    nas_get_sys_info_resp->lte_srv_status_info.srv_status                                 = qmi_nas_get_srv_status_from_cmss_event(p_ss_info, stack_index, SYS_SYS_MODE_LTE);
#else
    if( stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->lte_srv_status_info.srv_status                               = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;      
    }
    else
    {
      nas_get_sys_info_resp->lte_srv_status_info.srv_status                               = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
#endif // FEATURE_MMODE_REPORT_POWERSAVE

    if( stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->lte_srv_status_info.true_srv_status                          = (nas_true_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].true_srv_status;
      nas_get_sys_info_resp->lte_srv_status_info.is_pref_data_path                        = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_LTE ) ;      
    }
    else
    {
      nas_get_sys_info_resp->lte_srv_status_info.true_srv_status                          = SYS_SRV_STATUS_NO_SRV_V01;
    }
      nas_get_sys_info_resp->lte_srv_status_info_valid                                    = TRUE;

    //TLV 0x19
    if ( nas_get_sys_info_resp->lte_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         nas_get_sys_info_resp->lte_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 &&
         stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->lte_sys_info.common_sys_info.srv_domain_valid                = TRUE;
      nas_get_sys_info_resp->lte_sys_info.common_sys_info.srv_capability_valid            = TRUE;
      nas_get_sys_info_resp->lte_sys_info.common_sys_info.is_sys_forbidden_valid          = TRUE;

      nas_get_sys_info_resp->lte_sys_info.common_sys_info.srv_domain                    = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_domain;
      nas_get_sys_info_resp->lte_sys_info.common_sys_info.srv_capability                = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_capability;
      nas_get_sys_info_resp->lte_sys_info.common_sys_info.is_sys_forbidden              = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
        nas_get_sys_info_resp->lte_sys_info.common_sys_info.roam_status                   = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
        nas_get_sys_info_resp->lte_sys_info.common_sys_info.roam_status_valid               = TRUE;
      }

      nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.lac_valid            = FALSE;                // invalid under LTE
      nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.lac                  = QMI_NAS_INVALID_LAC;

      nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.cell_id_valid    = TRUE;
      nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.cell_id          = p_ss_info->stack_info[stack_index].cell_info.cell_id;

      if( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->stack_info[stack_index].sys_id.id.plmn ))
      {
        nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.network_id_valid = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].sys_id.id.plmn);
      }

      if( p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
        {
          nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain;
        nas_get_sys_info_resp->lte_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->stack_info[stack_index].reg_reject_info.reject_cause;
      }

      // LTE specific params
      nas_get_sys_info_resp->lte_sys_info.lte_specific_sys_info.tac                     = p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.tac;

      if ( IS_TAC_VALID(nas_get_sys_info_resp->lte_sys_info.lte_specific_sys_info.tac) )
      {
      nas_get_sys_info_resp->lte_sys_info.lte_specific_sys_info.tac_valid                 = TRUE;
      }
      else
      {
        nas_get_sys_info_resp->lte_sys_info.lte_specific_sys_info.tac                     = 0;
      }

      nas_get_sys_info_resp->lte_sys_info_valid                                           = TRUE;

    // TLV 0x1E additional LTE sys info
      nas_get_sys_info_resp->lte_sys_info2_valid                                          = TRUE;
      nas_get_sys_info_resp->lte_sys_info2.geo_sys_idx                                    = p_ss_info->stack_info[stack_index].geo_sys_idx;

    // TLV 0x21 voice support on LTE
    // Valid only when LTE is on main stack
      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
    {
        nas_get_sys_info_resp->voice_support_on_lte_valid                                 = TRUE;
        nas_get_sys_info_resp->voice_support_on_lte                                       = p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.voice_support_on_lte;
    }

#ifdef FEATURE_LTE_EMBMS
      // TLV 0x26 eMBMS coverage information // embms supported // now deprecated
      nas_get_sys_info_resp->lte_embms_coverage_valid                                     = TRUE;
      if(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status != SYS_EMBMS_COVERAGE_STATUS_AVAILABLE)
      {
        nas_get_sys_info_resp->lte_embms_coverage                                           = FALSE;
      }
      else
      {
        nas_get_sys_info_resp->lte_embms_coverage                                           = TRUE;
      }

      // TLV 0x46 LTE eMBMS Coverage Info Extended
      nas_get_sys_info_resp->embms_coverage_status_valid = TRUE;
      switch(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status)
      {
      case SYS_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE:
        nas_get_sys_info_resp->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE_V01; break;
      case SYS_EMBMS_COVERAGE_STATUS_AVAILABLE:
        nas_get_sys_info_resp->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_AVAILABLE_V01; break;
      case SYS_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_UEMODE:
        nas_get_sys_info_resp->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_UEMODE_V01; break;
      case SYS_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_E911:
        nas_get_sys_info_resp->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_EMERGENCY_V01; break;
      default:
        nas_get_sys_info_resp->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_UNKNOWN_V01; break;
      }

      // TLV 0x34 eMBMS coverage information // trace id
      nas_get_sys_info_resp->lte_embms_coverage_trace_id_valid                            = TRUE;
      nas_get_sys_info_resp->lte_embms_coverage_trace_id                                  = p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.embms_info.trace_id;
#endif

      //TLV 0x29 lte_ims_voice_avail
      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
          nas_get_sys_info_resp->lte_ims_voice_avail_valid                                = TRUE;
          nas_get_sys_info_resp->lte_ims_voice_avail                                      = p_ss_info->stack_info[stack_index].lte_ims_voice_avail;
      }

      //TLV 0x2A LTE Voice status
      // Valid only when LTE is on main stack
      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        nas_get_sys_info_resp->lte_voice_status_valid                                     = TRUE;
        nas_get_sys_info_resp->lte_voice_status                                           = qmi_nas_map_lte_voice_status_cm_to_qmi(p_ss_info);

        nas_get_sys_info_resp->lte_sms_status_valid= TRUE;
        nas_get_sys_info_resp->lte_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }

      // TLV 0x39 LTE Emergency Bearer Support
      // Assumption: CM will be passing this value for LTE on MAIN stack as well as GW_HYB stack
      nas_get_sys_info_resp->lte_is_eb_supported_valid = TRUE;
      nas_get_sys_info_resp->lte_is_eb_supported = qmi_nas_map_lte_eb_status_cm_to_qmi(p_ss_info->stack_info[stack_index].lte_ims_emerg_avail);

      // TLV 0x3E LTE Emergency Access Barred
        nas_get_sys_info_resp->emergency_access_barred_valid = TRUE;
      nas_get_sys_info_resp->emergency_access_barred = qmi_nas_map_lte_eab_status_cm_to_qmi(p_ss_info->stack_info[stack_index].cell_info.emerg_access_status);

    // TLV 0x31 LTE Possible Registration Domain
      if ( p_ss_info->stack_info[stack_index].available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        nas_get_sys_info_resp->lte_reg_domain_valid                                       = TRUE;
        nas_get_sys_info_resp->lte_reg_domain                                             = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->stack_info[stack_index].available_plmn_type);
    }

      nas_get_sys_info_resp->lte_cell_status_valid                                        = TRUE;

      if ( p_ss_info->stack_info[stack_index].cell_info.lte_cell_access_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_info.lte_cell_access_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        nas_get_sys_info_resp->lte_cell_status                                          = (nas_cell_access_status_e_type_v01) p_ss_info->stack_info[stack_index].cell_info.lte_cell_access_status;
        }
        else
        {
          nas_get_sys_info_resp->lte_cell_status                                          = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
  
#ifdef FEATURE_FEMTO_CSG
  if ( qm_efs_csg_supported() )
  {
        if( p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.csg_id != SYS_CSG_ID_INVALID )
      {
        nas_get_sys_info_resp->lte_csg_info_valid = TRUE;
          nas_get_sys_info_resp->lte_csg_info.id = p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.csg_id;
          nas_get_sys_info_resp->lte_csg_info.name_len = MIN(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.length, NAS_CSG_NAME_MAX_V01);
        memscpy(nas_get_sys_info_resp->lte_csg_info.name, 
                nas_get_sys_info_resp->lte_csg_info.name_len,
                  p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.name, sizeof(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.name));
          QM_MSG_HIGH_2("CM SS Evt csg_id %d, name_len %d", p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.csg_id, p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.length);
      }
      }
#endif
    }
  }// end LTE

  /////////////////////////////////////////////////////////
  // TDSCDMA
  /////////////////////////////////////////////////////////

  if ( TARGET_SUPPORTS_TDS )
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_TDS)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_TDS)
    { 
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }
    
    //TLV 0x24
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    nas_get_sys_info_resp->tdscdma_srv_status_info.srv_status                             = qmi_nas_get_srv_status_from_cmss_event(p_ss_info, stack_index, SYS_SYS_MODE_TDS);
#else
    if( stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->tdscdma_srv_status_info.srv_status                           = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
    }
    else
    {
      nas_get_sys_info_resp->tdscdma_srv_status_info.srv_status                           = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
#endif // FEATURE_MMODE_REPORT_POWERSAVE
    if( stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->tdscdma_srv_status_info.true_srv_status                      = (nas_true_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].true_srv_status;
      nas_get_sys_info_resp->tdscdma_srv_status_info.is_pref_data_path                    = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_TDS );
    }
    else
    {
      nas_get_sys_info_resp->tdscdma_srv_status_info.true_srv_status                      = SYS_SRV_STATUS_NO_SRV_V01;
    }
    nas_get_sys_info_resp->tdscdma_srv_status_info_valid                                  = TRUE;

    //TLV 0x25
    if ( nas_get_sys_info_resp->tdscdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01 &&
         nas_get_sys_info_resp->tdscdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 &&
         stack_index != STACK_INDEX_MAX )
    {
      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.srv_domain_valid            = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.srv_capability_valid        = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.is_sys_forbidden_valid      = TRUE;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.roam_status_valid           = TRUE;
        nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.roam_status                 = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
      }

      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.hs_call_status_valid = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.hs_ind_valid         = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cell_broadcast_cap_valid  = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cs_bar_status_valid = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status_valid = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cipher_domain_valid = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info_valid                                         = TRUE;

      if ( p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
      {
        nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cs_bar_status     = (nas_cell_access_status_e_type_v01) p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status;
      }
      else
      {
        nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cs_bar_status     = NAS_CELL_ACCESS_UNKNOWN_V01;
      }

      if ( p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
      {
        nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status     = (nas_cell_access_status_e_type_v01) p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status;
      }
      else
      {
        nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status     = NAS_CELL_ACCESS_UNKNOWN_V01;
      }

      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.srv_domain                  = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_domain;
      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.srv_capability              = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_capability;
      nas_get_sys_info_resp->tdscdma_sys_info.common_sys_info.is_sys_forbidden            = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      if ( p_ss_info->stack_info[stack_index].cell_info.lac_id != QMI_NAS_INVALID_LAC )
      {
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.lac_valid      = TRUE;
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.lac            = p_ss_info->stack_info[stack_index].cell_info.lac_id;
      }
        
      nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.cell_id_valid  = TRUE;
      nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.cell_id        = p_ss_info->stack_info[stack_index].cell_info.cell_id;

      if ( p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
      {
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain;
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->stack_info[stack_index].reg_reject_info.reject_cause;
      }

      if ( p_ss_info->stack_info[stack_index].mode_info.gw_info.mm_information.plmn_avail )
      {
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.network_id_valid  = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].mode_info.gw_info.mm_information.plmn);
      }
      else if ( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->stack_info[stack_index].sys_id.id.plmn ))
      {
        nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.network_id_valid  = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           nas_get_sys_info_resp->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].sys_id.id.plmn);
      }

      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.hs_call_status       = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_call_status;
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.hs_ind               = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_ind;

      if ( p_ss_info->stack_info[stack_index].cell_info.psc != 0xFFFF )
      {
        nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cell_parameter_id_valid = TRUE;
        nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cell_parameter_id       = p_ss_info->stack_info[stack_index].cell_info.psc;
      }
      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cell_broadcast_cap        = (nas_cell_broadcast_cap_enum_type_v01) p_ss_info->stack_info[stack_index].cell_bc_info.cell_bc_capability;


      nas_get_sys_info_resp->tdscdma_sys_info.tdscdma_specific_sys_info.cipher_domain       = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].cipher_domain;

    // TLV 0x30 TDSCDMA Possible Registration Domain
      if ( p_ss_info->stack_info[stack_index].available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        nas_get_sys_info_resp->tdscdma_reg_domain_valid                                   = TRUE;
        nas_get_sys_info_resp->tdscdma_reg_domain                                         = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->stack_info[stack_index].available_plmn_type);
      }
  
      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        nas_get_sys_info_resp->tdscdma_voice_status_valid = TRUE;
        nas_get_sys_info_resp->tdscdma_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        nas_get_sys_info_resp->tdscdma_sms_status_valid = TRUE;
        nas_get_sys_info_resp->tdscdma_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }
    }
  } // end TDSCDMA

  // TLV 0x27 SIM reject information
  if ( TARGET_SUPPORTS_LTE || TARGET_SUPPORTS_WCDMA ||TARGET_SUPPORTS_GSM || TARGET_SUPPORTS_TDS )
  {
    nas_get_sys_info_resp->sim_rej_info_valid                                             = TRUE;

    if(p_ss_info->stack_info[STACK_INDEX_0].mode_info.gw_info.sim_state == SYS_SIM_STATE_NOT_AVAILABLE )
      {
      nas_get_sys_info_resp->sim_rej_info = (nas_sim_rej_info_enum_type_v01)qmi_nasi_global.sim_state_before_not_avail[asubs_id];
      }
      else
      {
      nas_get_sys_info_resp->sim_rej_info = (nas_sim_rej_info_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].mode_info.gw_info.sim_state;
    }
  }

  // srv_reg_restriction Indication - Global, always returned
  nas_get_sys_info_resp->srv_reg_restriction_valid                                        = TRUE;
  if ( p_ss_info->stack_info[STACK_INDEX_0].available_plmn_type == SYS_REG_DOMAIN_NOT_APPLICABLE )
  {
    nas_get_sys_info_resp->srv_reg_restriction                                            = NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01;
  }
  else
  {
    nas_get_sys_info_resp->srv_reg_restriction                                            = NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01;
  }

  return errval;
}

/*===========================================================================
  FUNCTION qmi_nas_map_lte_voice_status_cm_to_qmi()

  DESCRIPTION
    Maps CM lte_voice_status to QMI_NAS enum type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
nas_lte_voice_status_enum_type_v01  qmi_nas_map_lte_voice_status_cm_to_qmi( cm_mm_msim_ss_info_s_type *p_ss_info )
{
  nas_lte_voice_status_enum_type_v01 retval = NAS_LTE_VOICE_STATUS_NO_VOICE_V01;

  switch( p_ss_info->voice_domain )
  {
    case SYS_CM_DOMAIN_SEL_DOMAIN_NO_VOICE : retval = NAS_LTE_VOICE_STATUS_NO_VOICE_V01;   break;
    case SYS_CM_DOMAIN_SEL_DOMAIN_IMS      : retval = NAS_LTE_VOICE_STATUS_IMS_V01;        break;
    case SYS_CM_DOMAIN_SEL_DOMAIN_1X       : retval = NAS_LTE_VOICE_STATUS_1X_V01;         break;
    case SYS_CM_DOMAIN_SEL_DOMAIN_3GPP     : retval = NAS_LTE_VOICE_STATUS_3GPP_V01;       break;

    default:
      QM_MSG_ERROR_1("sys_cm_domain_sel_domain_e_type type %d not supported", (int) p_ss_info->voice_domain);
      retval = NAS_LTE_VOICE_STATUS_NO_VOICE_V01;
      break;
  }

  return retval;
}

/*===========================================================================
  FUNCTION qmi_nas_map_available_plmn_type_cm_to_qmi()

  DESCRIPTION
    Maps CM lte_voice_status to QMI_NAS enum type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
nas_possible_reg_domain_enum_type_v01 qmi_nas_map_available_plmn_type_cm_to_qmi( sys_reg_domain_e_type available_plmn_type )
{
  nas_possible_reg_domain_enum_type_v01 retval = NAS_POSSIBLE_REG_DOMAIN_NA_V01;

  switch( available_plmn_type )
  {
    case SYS_REG_DOMAIN_NOT_APPLICABLE  : retval = NAS_POSSIBLE_REG_DOMAIN_NA_V01;              break;
    case SYS_REG_DOMAIN_CS_SERVICE_ONLY : retval = NAS_POSSIBLE_REG_DOMAIN_CS_ONLY_V01;         break;
    case SYS_REG_DOMAIN_PS_SERVICE_ONLY : retval = NAS_POSSIBLE_REG_DOMAIN_PS_ONLY_V01;         break;
    case SYS_REG_DOMAIN_CS_PS_SERVICE   : retval = NAS_POSSIBLE_REG_DOMAIN_CS_PS_V01;           break;
    case SYS_REG_DOMAIN_CAMPED_ONLY     : retval = NAS_POSSIBLE_REG_DOMAIN_LIMITED_SERVICE_V01; break;

    default:
      QM_MSG_ERROR_1("sys_reg_domain_e_type type %d not supported", (int) available_plmn_type);
      retval = NAS_POSSIBLE_REG_DOMAIN_NA_V01;
      break;
  }

  return retval;
}

/*===========================================================================
  FUNCTION QMI_NAS_MAP_LTE_EB_STATUS_CM_TO_QMI()

  DESCRIPTION
    Maps CM lte_ims_emerg_avail to QMI_NAS enum type

  RETURN VALUE
    QMI_NAS enum type

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
nas_tri_state_boolean_type_v01 qmi_nas_map_lte_eb_status_cm_to_qmi( sys_ims_lte_emerg_supp_e_type lte_ims_emerg_avail )
{
  nas_tri_state_boolean_type_v01 retval = NAS_TRI_UNKNOWN_V01;

  QM_MSG_LOW_1("sys_ims_lte_emerg_supp_e_type type %d", lte_ims_emerg_avail);

  switch(lte_ims_emerg_avail)
    {
      case SYS_IMS_LTE_EMERG_SUPP_NOT_AVAILABLE: retval = NAS_TRI_FALSE_V01;  break;
      case SYS_IMS_LTE_EMERG_SUPP_AVAILABLE    : retval = NAS_TRI_TRUE_V01;   break;

      default:
        break;
    }

  return retval;
}

/*===========================================================================
  FUNCTION qmi_nas_map_lte_eab_status_cm_to_qmi()

  DESCRIPTION
    Maps CM sys_lte_emerg_access_status_e_type emerg_bar_status to QMI IDL enum type
    nas_tri_state_boolean_type_v01 to indicate network SIB2 Access barring for making emergency calls.

  RETURN VALUE
    QMI IDL enum type nas_tri_state_boolean_type_v01

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
nas_tri_state_boolean_type_v01 qmi_nas_map_lte_eab_status_cm_to_qmi( sys_lte_emerg_access_status_e_type cm_eab_status )
{
  nas_tri_state_boolean_type_v01 retval = NAS_TRI_UNKNOWN_V01;

  QM_MSG_HIGH_1("sys_lte_emerg_access_status_e_type type %d", cm_eab_status); 

  switch(cm_eab_status)
  {
    case SYS_LTE_EMERG_ACCESS_BARRED     : retval = NAS_TRI_TRUE_V01;    break;
    case SYS_LTE_EMERG_ACCESS_ALLOWED    : retval = NAS_TRI_FALSE_V01;   break;

    default:
      break;
  }

  return retval;
}


/*===========================================================================
  FUNCTION QMI_NAS_GEN_SYS_INFO_IND()

  DESCRIPTION
    Generate and send sys info IND message

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_sys_info_ind(
  cm_mm_msim_ss_info_s_type       * p_ss_info,
  qmi_cm_ph_info_s_type          * p_ph_info,
  boolean                      evt_reg_reject
)
{
  dsm_item_type              * indication = NULL;
  sys_modem_as_id_e_type       asubs_id = SYS_MODEM_AS_ID_1;
  int                         clid;
  qmi_nasi_client_state_type *cl_sp;

  nas_sys_info_ind_msg_v01   * new_ind;
  nas_sys_info_ind_msg_v01   * old_ind;

  qmi_cm_ph_info_s_type          * p_new_ph_info = p_ph_info;
  qmi_cm_ph_info_s_type          * p_old_ph_info = &qmi_nasi_global.cm_ph_info;

  boolean                      send_indication;

  uint8 asubs_max = sizeof(qmi_nasi_global.cm_msim_ss_info)/sizeof(qmi_nasi_global.cm_msim_ss_info[0]);

  new_ind = (nas_sys_info_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_sys_info_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  old_ind = (nas_sys_info_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_sys_info_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if( (p_ss_info->asubs_id != SYS_MODEM_AS_ID_NONE) && (p_ss_info->asubs_id < asubs_max) )
  {
    asubs_id = p_ss_info->asubs_id;
  }
  
  if ( new_ind != NULL && old_ind != NULL )
  {
  for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
  {
      send_indication = FALSE;

    cl_sp = qmi_nas_state.client[clid];

      // Check to see if the client exists, AND it wants to receive updates, AND that
	      // if it is a registration rejection event, that the client doesn't wish to suppress sys info notification
      if ( cl_sp != NULL                             &&
           cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
            cl_sp->report_status.report_sys_info &&
            !( evt_reg_reject && cl_sp->report_status.network_reject.suppress_sys_info_on_reject ) &&
             (cl_sp->report_status.bound_subs == (enum qmi_nas_subs_e)asubs_id))
    {
      if ( cl_sp->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY )
      {
        asubs_id      = SYS_MODEM_AS_ID_1;
        p_new_ph_info = p_ph_info;
        p_old_ph_info = &qmi_nasi_global.cm_ph_info;
      }
#ifdef FEATURE_DUAL_SIM
      else if( cl_sp->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
      {
        asubs_id      = SYS_MODEM_AS_ID_2;
        p_new_ph_info = &qmi_nasi_global.cm_ph_info2;
        p_old_ph_info = &qmi_nasi_global.cm_ph_info2;
      }
#endif
#ifdef FEATURE_TRIPLE_SIM
      else if( cl_sp->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
      {
        asubs_id      = SYS_MODEM_AS_ID_3;
        p_new_ph_info = &qmi_nasi_global.cm_ph_info3;
        p_old_ph_info = &qmi_nasi_global.cm_ph_info3;
      }
#endif
        memset( new_ind, 0x00, sizeof( nas_sys_info_ind_msg_v01 ) );
        memset( old_ind, 0x00, sizeof( nas_sys_info_ind_msg_v01 ) );

        qmi_nas_populate_sys_info_ind( p_ss_info,                   p_new_ph_info, new_ind, asubs_id );
        qmi_nas_populate_sys_info_ind( &qmi_nasi_global.cm_msim_ss_info[asubs_id], p_old_ph_info, old_ind, asubs_id );

      if ( !qmi_nasi_global.rcvd_ss_info )
      {
          send_indication = TRUE;
      }
        else if ( memcmp( old_ind, new_ind, sizeof( nas_sys_info_ind_msg_v01) ) ||
                  new_ind->sys_info_no_change_valid                             )
      {
          if ( new_ind->cdma_srv_status_info_valid || new_ind->hdr_srv_status_info_valid              ||
               new_ind->gsm_srv_status_info_valid  || new_ind->wcdma_srv_status_info_valid            ||
               new_ind->lte_srv_status_info_valid  || new_ind->cdma_sys_info_valid                    ||
               new_ind->hdr_sys_info_valid         || new_ind->gsm_sys_info_valid                     ||
               new_ind->wcdma_sys_info_valid       || new_ind->lte_sys_info_valid                     ||
               new_ind->cdma_sys_info2_valid       || new_ind->hdr_sys_info2_valid                    ||
               new_ind->gsm_sys_info2_valid        || new_ind->wcdma_sys_info2_valid                  ||
               new_ind->lte_sys_info2_valid        || new_ind->gsm_sys_info3_valid                    ||
               new_ind->wcdma_sys_info3_valid      || new_ind->voice_support_on_lte_valid             ||
               new_ind->gsm_cipher_domain_valid    || new_ind->wcdma_cipher_domain_valid              ||
               new_ind->sys_info_no_change_valid   || new_ind->tdscdma_srv_status_info_valid          ||
               new_ind->tdscdma_sys_info_valid     || new_ind->lte_embms_coverage_valid               ||
               new_ind->sim_rej_info_valid         || new_ind->wcdma_eutra_status_valid               ||
               new_ind->lte_ims_voice_avail_valid  || new_ind->lte_voice_status_valid                 ||
               new_ind->cdma_reg_zone_valid        || new_ind->gsm_rac_valid                          ||
               new_ind->wcdma_rac_valid            || new_ind->cdma_mcc_resolved_via_sid_lookup_valid ||
               new_ind->srv_reg_restriction_valid  || new_ind->tdscdma_reg_domain_valid               ||
               new_ind->lte_reg_domain_valid       || new_ind->wcdma_reg_domain_valid                 ||
               new_ind->gsm_reg_domain_valid       || new_ind->lte_embms_coverage_trace_id_valid      ||
               new_ind->wcdma_csg_info_valid       || new_ind->embms_coverage_status_valid)
        {
          if( !cl_sp->report_status.limit_sys_info_reporting_mask ||
                qmi_nas_check_sys_info_chg_against_rpt_limits( new_ind, old_ind, cl_sp->report_status.limit_sys_info_reporting_mask) )
          {
              send_indication = TRUE;
            }
          }
          else
          {
            QM_MSG_HIGH_1("qmi_nas_gen_sys_info_ind() information changed but nothing to send %d", clid);
          }
        }
        else
        {
          QM_MSG_LOW_1("qmi_nas_gen_sys_info_ind() sys info indication contents didn't change %d", clid);
        }

        if ( send_indication )
        {
          indication = NULL;                                                                         // Important!  When multiple encode calls may be made.
          if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                             (uint16_t) QMI_NAS_SYS_INFO_IND_MSG_V01, // message_id = 0x004E = ( (qmi_cmd_buf_type *) cmd_buf_p )->cmd_type,
                                             (void *) new_ind,
                                             (uint32_t) sizeof( nas_sys_info_ind_msg_v01 ),
                                             &indication ) )
          {
            qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_SYS_INFO_IND, indication );
      }
      else
      {
            QM_MSG_HIGH_1("qmi_nas_gen_sys_info_ind() idl_message_encode failed, no indication sent %d.", clid);
          }
      }
    }
  }

  if ( !qmi_nasi_global.rcvd_ss_info )
  {
    qmi_nasi_global.rcvd_ss_info = TRUE;
  }

    if ( p_ss_info->stack_info[STACK_INDEX_0].mode_info.gw_info.sim_state != SYS_SIM_STATE_NOT_AVAILABLE )
    {
      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_GSM || p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_WCDMA ||
           p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_LTE || p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_TDS   )
  {
        qmi_nasi_global.sim_state_before_not_avail[asubs_id] = p_ss_info->stack_info[STACK_INDEX_0].mode_info.gw_info.sim_state;
  }
  }
    }
  else
  {
    qmi_voice_mem_error();
  } // endif (both mallocs OK)

  if ( new_ind != NULL ) { modem_mem_free( (void *) new_ind, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( old_ind != NULL ) { modem_mem_free( (void *) old_ind, MODEM_MEM_CLIENT_QMI_MMODE ); }
}


/*===========================================================================
  FUNCTION QMI_NAS_POPULATE_SYS_INFO_IND()

  DESCRIPTION
    <QMI NAS internal use only>
    Helper function to generate qmi_nas_sys_info_type message from a given CM SS and PH info.
    To be used in QMI_NAS_SYS_INFO_IND.

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    cm_ph_info_s_type    CM PH info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_sys_info_ind(
    cm_mm_msim_ss_info_s_type *p_ss_info,
    qmi_cm_ph_info_s_type *p_ph_info,
    nas_sys_info_ind_msg_v01 * ind_msg,
    sys_modem_as_id_e_type asubs_id
  )
{
  enum qm_stack_index_e stack_index=STACK_INDEX_0;
  memset( ind_msg, 0x00, sizeof(nas_sys_info_ind_msg_v01) );
  QM_MSG_HIGH_6("Proc sys_info_ind: asubs_id=%d,no_of_stacks=%d,change_fields[0]=%x, sys_mode[0] %d, srv_status[0] %d, domain[0]=%d", 
	p_ss_info->asubs_id, p_ss_info->number_of_stacks, p_ss_info->stack_info[STACK_INDEX_0].changed_fields,p_ss_info->stack_info[STACK_INDEX_0].sys_mode, p_ss_info->stack_info[STACK_INDEX_0].srv_status, p_ss_info->stack_info[STACK_INDEX_0].srv_domain);

  QM_MSG_HIGH_3("Processing sys_info_ind: sys_mode[1] %d, srv_status[1] %d, domain[1]=%d", p_ss_info->stack_info[STACK_INDEX_1].sys_mode, p_ss_info->stack_info[STACK_INDEX_1].srv_status, p_ss_info->stack_info[STACK_INDEX_1].srv_domain);
  
  
  /////////////////////////////////////////////////////////
  // CDMA
  /////////////////////////////////////////////////////////

  if ( TARGET_SUPPORTS_CDMA && asubs_id == SYS_MODEM_AS_ID_1 )
  {
  
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_CDMA)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks>1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_CDMA)
    { 
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }
    // TLV 0x10
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    ind_msg->cdma_srv_status_info.srv_status                                   = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, stack_index, SYS_SYS_MODE_CDMA );
#else
    if( stack_index != STACK_INDEX_MAX )
    {
       ind_msg->cdma_srv_status_info.srv_status                                   = (nas_service_status_enum_type_v01)p_ss_info->srv_status;
    }
    else
    {
      ind_msg->cdma_srv_status_info.srv_status                                  = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
#endif // FEATURE_MMODE_REPORT_POWERSAVE

    ind_msg->cdma_srv_status_info.is_pref_data_path                            = ( p_ss_info->stack_info[STACK_INDEX_0].cur_idle_digital_mode == SYS_SYS_MODE_CDMA );
    ind_msg->cdma_srv_status_info_valid                                        = TRUE;

    // TLV 0x15
    if ( ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      ind_msg->cdma_sys_info_valid                                             = TRUE;

      ind_msg->cdma_sys_info.common_sys_info.srv_domain_valid                  = TRUE;
      ind_msg->cdma_sys_info.common_sys_info.srv_domain                        = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].srv_domain;

      ind_msg->cdma_sys_info.common_sys_info.srv_capability_valid              = TRUE;
      ind_msg->cdma_sys_info.common_sys_info.srv_capability                    = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].srv_capability;

      if ( p_ss_info->stack_info[STACK_INDEX_0].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      ind_msg->cdma_sys_info.common_sys_info.roam_status_valid                 = TRUE;
        ind_msg->cdma_sys_info.common_sys_info.roam_status                     = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].roam_status;
      }

      ind_msg->cdma_sys_info.common_sys_info.is_sys_forbidden_valid            = TRUE;
      ind_msg->cdma_sys_info.common_sys_info.is_sys_forbidden                  = p_ss_info->stack_info[STACK_INDEX_0].is_sys_forbidden;

      ind_msg->cdma_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match_valid     = TRUE;
      ind_msg->cdma_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match           = p_ss_info->stack_info[STACK_INDEX_0].is_sys_prl_match ;

      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.p_rev_in_use != CM_SS_P_REV_IN_USE_NONE )
      {
        ind_msg->cdma_sys_info.cdma_specific_sys_info.p_rev_in_use_valid       = TRUE;
        ind_msg->cdma_sys_info.cdma_specific_sys_info.p_rev_in_use             = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.p_rev_in_use;
      }

      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.bs_p_rev != CM_SS_BS_P_REV_NONE )
      {
        ind_msg->cdma_sys_info.cdma_specific_sys_info.bs_p_rev_valid           = TRUE;
        ind_msg->cdma_sys_info.cdma_specific_sys_info.bs_p_rev                 = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.bs_p_rev;
      }

      ind_msg->cdma_sys_info.cdma_specific_sys_info.ccs_supported_valid        = TRUE;
      ind_msg->cdma_sys_info.cdma_specific_sys_info.ccs_supported              = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.ccs_supported;

      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_id.id_type == SYS_SYS_ID_TYPE_IS95 )
      {
        ind_msg->cdma_sys_info.cdma_specific_sys_info.cdma_sys_id_valid        = TRUE;
        ind_msg->cdma_sys_info.cdma_specific_sys_info.cdma_sys_id.sid          = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.sid;
        ind_msg->cdma_sys_info.cdma_specific_sys_info.cdma_sys_id.nid          = p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.nid;
      }

      ind_msg->cdma_sys_info.cdma_specific_sys_info.bs_info_valid              = TRUE;
      ind_msg->cdma_sys_info.cdma_specific_sys_info.bs_info.base_id            = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_id;
      ind_msg->cdma_sys_info.cdma_specific_sys_info.bs_info.base_lat           = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_lat;
      ind_msg->cdma_sys_info.cdma_specific_sys_info.bs_info.base_long          = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.base_long;

      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.packet_zone != 0x00)
      {
        ind_msg->cdma_sys_info.cdma_specific_sys_info.packet_zone_valid        = TRUE;
        ind_msg->cdma_sys_info.cdma_specific_sys_info.packet_zone              = p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.packet_zone;
      }

      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_id.id_type == SYS_SYS_ID_TYPE_IS95 )
      {
        if ( p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.mcc == 0 && p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.imsi_11_12 == 0 )
        {
          ind_msg->cdma_sys_info.cdma_specific_sys_info.network_id_valid       = FALSE;
        }
        else
        {
          ind_msg->cdma_sys_info.cdma_specific_sys_info.network_id_valid       = TRUE;
          convert_cdma_mcc_2_ascii_mcc( (char *) ind_msg->cdma_sys_info.cdma_specific_sys_info.network_id.mcc, p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.mcc );        // TODO apply decoding
          convert_cdma_mnc_2_ascii_mnc( (char *) ind_msg->cdma_sys_info.cdma_specific_sys_info.network_id.mnc, p_ss_info->stack_info[STACK_INDEX_0].sys_id.id.is95.imsi_11_12 ); // TODO apply decoding
        }

        if(p_ss_info->current_mcc < 1000)
        {
          ind_msg->cdma_mcc_resolved_via_sid_lookup                            = p_ss_info->current_mcc;
          ind_msg->cdma_mcc_resolved_via_sid_lookup_valid                      = TRUE;
        }
      }
    }

    // TLV 0x1A additional CDMA sys info
    if ( ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      ind_msg->cdma_sys_info2_valid                                            = TRUE;

      ind_msg->cdma_sys_info2.geo_sys_idx                                      = p_ss_info->stack_info[STACK_INDEX_0].geo_sys_idx;
      ind_msg->cdma_sys_info2.reg_prd                                          = p_ss_info->stack_info[STACK_INDEX_0].rat_mode_info.cdma_mode_info.cdma_reg_prd;
    }

    // TLV 0x2C CDMA Reg Zone
    if ( ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      if( p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.reg_zone != CM_SS_REG_ZONE_NONE )
      {
        ind_msg->cdma_reg_zone_valid                                           = TRUE;
        ind_msg->cdma_reg_zone                                                 = ( NAS_004D_CDMA_REG_ZONE_MASK & p_ss_info->stack_info[STACK_INDEX_0].mode_info.cdma_info.reg_zone );
      }
    }

    if ( ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->cdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
      if ( p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_CDMA &&
           ( p_ss_info->stack_info[STACK_INDEX_0].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[STACK_INDEX_0].srv_domain  == SYS_SRV_DOMAIN_CS_PS))         
      {
        ind_msg->cdma_voice_status_valid = TRUE;
        ind_msg->cdma_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        ind_msg->cdma_sms_status_valid = TRUE;
        ind_msg->cdma_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }
    }
  } // end CDMA

  /////////////////////////////////////////////////////////
  // HDR
  /////////////////////////////////////////////////////////

  if( TARGET_SUPPORTS_HDR && asubs_id == SYS_MODEM_AS_ID_1)
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_HDR)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks>1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_HDR)
    { 
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }

    //TLV 0x11
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    ind_msg->hdr_srv_status_info.srv_status                                    = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, stack_index, SYS_SYS_MODE_HDR );
#else
    if( stack_index != STACK_INDEX_MAX )
    {
      ind_msg->hdr_srv_status_info.srv_status                                  = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
    }
    else
    {
      ind_msg->hdr_srv_status_info.srv_status                                  = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
#endif // FEATURE_MMODE_REPORT_POWERSAVE

    if( stack_index != STACK_INDEX_MAX )
    {
      ind_msg->hdr_srv_status_info.is_pref_data_path                             = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_HDR );
    }

    ind_msg->hdr_srv_status_info_valid                                         = TRUE;

    //TLV 0x16
    if ( ind_msg->hdr_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->hdr_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 &&
         stack_index != STACK_INDEX_MAX )
    {
      ind_msg->hdr_sys_info.common_sys_info.srv_domain_valid                   = TRUE;
      ind_msg->hdr_sys_info.common_sys_info.srv_domain                         = SYS_SRV_DOMAIN_PS_ONLY_V01;

      ind_msg->hdr_sys_info.common_sys_info.srv_capability_valid               = TRUE;
      ind_msg->hdr_sys_info.common_sys_info.srv_capability                     = SYS_SRV_DOMAIN_PS_ONLY_V01;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      ind_msg->hdr_sys_info.common_sys_info.roam_status_valid                  = TRUE;
        ind_msg->hdr_sys_info.common_sys_info.roam_status                      = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
      }

      ind_msg->hdr_sys_info.common_sys_info.is_sys_forbidden_valid             = TRUE;
      ind_msg->hdr_sys_info.common_sys_info.is_sys_forbidden                   = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      ind_msg->hdr_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match_valid      = TRUE;
      ind_msg->hdr_sys_info.cdma_hdr_only_sys_info.is_sys_prl_match            = p_ss_info->stack_info[stack_index].is_sys_prl_match ;

      if( p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_personality != SYS_PERSONALITY_NONE )
      {
        ind_msg->hdr_sys_info.hdr_specific_sys_info.hdr_personality_valid      = TRUE;
        ind_msg->hdr_sys_info.hdr_specific_sys_info.hdr_personality            = (nas_hdr_personality_enum_type_v01)p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_personality;
      }

      if( p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_active_prot != SYS_ACTIVE_PROT_NONE )
      {
        ind_msg->hdr_sys_info.hdr_specific_sys_info.hdr_active_prot_valid      = TRUE;
        ind_msg->hdr_sys_info.hdr_specific_sys_info.hdr_active_prot            = (nas_hdr_active_prot_enum_type_v01)p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.hdr_active_prot;
      }

      if ( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_IS856 )
        {
          ind_msg->hdr_sys_info.hdr_specific_sys_info.is856_sys_id_valid       = TRUE;
          memscpy(&ind_msg->hdr_sys_info.hdr_specific_sys_info.is856_sys_id, 
                  NAS_IS_856_MAX_LEN_V01,
                p_ss_info->stack_info[stack_index].sys_id.id.is856, NAS_IS_856_MAX_LEN_V01 );

        }

      ind_msg->hdr_sys_info_valid                                              = TRUE;

    // TLV 0x1B additional HDR sys info
      ind_msg->hdr_sys_info2_valid                                             = TRUE;
      ind_msg->hdr_sys_info2.geo_sys_idx                                       = p_ss_info->stack_info[stack_index].geo_sys_idx;

      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS ) 
      {
        ind_msg->hdr_voice_status_valid = TRUE;
        ind_msg->hdr_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        ind_msg->hdr_sms_status_valid = TRUE;
        ind_msg->hdr_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }

      ind_msg->hdr_subnet_mask_len_valid = TRUE;
      ind_msg->hdr_subnet_mask_len = p_ss_info->stack_info[stack_index].rat_mode_info.hdr_mode_info.subnet_mask_len;
    }
  } // end HDR

  /////////////////////////////////////////////////////////
  // GSM
  /////////////////////////////////////////////////////////

  if( TARGET_SUPPORTS_GSM )
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_GSM)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_GSM)
    {
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }

    //TLV 0x12
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    ind_msg->gsm_srv_status_info.srv_status                      = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, stack_index, SYS_SYS_MODE_GSM );
#else
    if( stack_index != STACK_INDEX_MAX )
    {
      ind_msg->gsm_srv_status_info.srv_status                      = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
    }
    else
    {
      ind_msg->gsm_srv_status_info.srv_status                      = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
#endif // FEATURE_MMODE_REPORT_POWERSAVE

    if( stack_index != STACK_INDEX_MAX )
    {
      ind_msg->gsm_srv_status_info.true_srv_status                 = (nas_true_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].true_srv_status;
      ind_msg->gsm_srv_status_info.is_pref_data_path               = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_GSM );
    }
    else
    {
      ind_msg->gsm_srv_status_info.true_srv_status                 = SYS_SRV_STATUS_NO_SRV_V01;
    }
      ind_msg->gsm_srv_status_info_valid                           = TRUE;

    //TLV 0x17
    if ( ind_msg->gsm_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->gsm_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 &&
          stack_index != STACK_INDEX_MAX)
    {
      ind_msg->gsm_sys_info.common_sys_info.srv_domain_valid       = TRUE;
      ind_msg->gsm_sys_info.common_sys_info.srv_domain             = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_domain;

      ind_msg->gsm_sys_info.common_sys_info.srv_capability_valid   = TRUE;
      ind_msg->gsm_sys_info.common_sys_info.srv_capability         = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_capability;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      ind_msg->gsm_sys_info.common_sys_info.roam_status_valid      = TRUE;
        ind_msg->gsm_sys_info.common_sys_info.roam_status            =  (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
      }

      ind_msg->gsm_sys_info.common_sys_info.is_sys_forbidden_valid = TRUE;
      ind_msg->gsm_sys_info.common_sys_info.is_sys_forbidden       =  p_ss_info->stack_info[stack_index].is_sys_forbidden;

      ind_msg->gsm_sys_info.threegpp_specific_sys_info.lac         = p_ss_info->stack_info[stack_index].sys_id.id.plmn_lac.lac;

      if ( ind_msg->gsm_sys_info.threegpp_specific_sys_info.lac != QMI_NAS_INVALID_LAC )
      {
        ind_msg->gsm_sys_info.threegpp_specific_sys_info.lac_valid = TRUE;
      }

      ind_msg->gsm_sys_info.threegpp_specific_sys_info.cell_id_valid    = TRUE;
      ind_msg->gsm_sys_info.threegpp_specific_sys_info.cell_id          = p_ss_info->stack_info[stack_index].cell_info.cell_id;

      if( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->stack_info[stack_index].sys_id.id.plmn ))
      {
        ind_msg->gsm_sys_info.threegpp_specific_sys_info.network_id_valid = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( (char *) ind_msg->gsm_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           (char *) ind_msg->gsm_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].sys_id.id.plmn );
      }

      if(p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
        {
          ind_msg->gsm_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        ind_msg->gsm_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain;
        ind_msg->gsm_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->stack_info[stack_index].reg_reject_info.reject_cause;
      }

      ind_msg->gsm_sys_info.gsm_specific_sys_info.egprs_supp_valid = TRUE;
      ind_msg->gsm_sys_info.gsm_specific_sys_info.egprs_supp       = p_ss_info->stack_info[stack_index].cell_srv_ind.egprs_supp;

      ind_msg->gsm_sys_info.gsm_specific_sys_info.dtm_supp_valid   = TRUE;
      ind_msg->gsm_sys_info.gsm_specific_sys_info.dtm_supp         = p_ss_info->stack_info[stack_index].cell_srv_ind.dtm_supp;

      ind_msg->gsm_sys_info_valid                                  = TRUE;

    // TLV 0x1C additional GSM sys info
      ind_msg->gsm_sys_info2_valid                                 = TRUE;
      ind_msg->gsm_sys_info2.geo_sys_idx                         = p_ss_info->stack_info[stack_index].geo_sys_idx; // currently there is no gw_geo_sys_idx;
      ind_msg->gsm_sys_info2.cell_broadcast_cap                = (uint32) p_ss_info->stack_info[stack_index].cell_bc_info.cell_bc_capability;

    // TLV 0x1F GSM Cell Access info
      ind_msg->gsm_sys_info3_valid                                 = TRUE;
      if ( p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        ind_msg->gsm_sys_info3.cs_bar_status                     = (uint32) p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status;
        }
        else
        {
          ind_msg->gsm_sys_info3.cs_bar_status                     = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
      
      if ( p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        ind_msg->gsm_sys_info3.ps_bar_status                     = (uint32) p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status;
        }
        else
        {
          ind_msg->gsm_sys_info3.ps_bar_status                     = NAS_CELL_ACCESS_UNKNOWN_V01;
      }

    // TLV 0x22 GSM Cipher Domain info
      ind_msg->gsm_cipher_domain_valid                             = TRUE;
      ind_msg->gsm_cipher_domain                                   = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].cipher_domain;

    // TLV 0x2D GSM RAC
      if( p_ss_info->stack_info[stack_index].rat_mode_info.gsm_mode_info.rac_or_mme_code != 0xFF )
        {
          ind_msg->gsm_rac_valid                                     = TRUE;
        ind_msg->gsm_rac                                           = p_ss_info->stack_info[stack_index].rat_mode_info.gsm_mode_info.rac_or_mme_code;
    }

    // TLV 0x34 GSM Possible Registration Domain
      if( p_ss_info->stack_info[stack_index].available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        ind_msg->gsm_reg_domain_valid                              = TRUE;
        ind_msg->gsm_reg_domain                                    = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->stack_info[stack_index].available_plmn_type );
    }

      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        ind_msg->gsm_voice_status_valid = TRUE;
        ind_msg->gsm_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        ind_msg->gsm_sms_status_valid = TRUE;
        ind_msg->gsm_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }
    }
  }

  /////////////////////////////////////////////////////////
  // WCDMA
  /////////////////////////////////////////////////////////

  if( TARGET_SUPPORTS_WCDMA )
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_WCDMA)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_WCDMA)
    {
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }
  
    //TLV 0x13
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
      ind_msg->wcdma_srv_status_info.srv_status                      = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, stack_index, SYS_SYS_MODE_WCDMA );
#else
    if( stack_index != STACK_INDEX_MAX )
    {
      ind_msg->wcdma_srv_status_info.srv_status                      = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
    }
    else
    {
      ind_msg->wcdma_srv_status_info.srv_status                      = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
#endif // FEATURE_MMODE_REPORT_POWERSAVE

    if( stack_index != STACK_INDEX_MAX )
    {
      ind_msg->wcdma_srv_status_info.true_srv_status                 = (nas_true_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].true_srv_status;
      ind_msg->wcdma_srv_status_info.is_pref_data_path               = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_WCDMA );
    }
    else
    {
      ind_msg->wcdma_srv_status_info.true_srv_status                 = SYS_SRV_STATUS_NO_SRV_V01;
    }
      ind_msg->wcdma_srv_status_info_valid                           = TRUE;

    //TLV 0x18
    if ( ind_msg->wcdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01 &&
         ind_msg->wcdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 &&
         stack_index != STACK_INDEX_MAX)
    {
      ind_msg->wcdma_sys_info.common_sys_info.srv_domain_valid       = TRUE;
      ind_msg->wcdma_sys_info.common_sys_info.srv_domain             = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_domain;

      ind_msg->wcdma_sys_info.common_sys_info.srv_capability_valid   = TRUE;
      ind_msg->wcdma_sys_info.common_sys_info.srv_capability         = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_capability;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
      ind_msg->wcdma_sys_info.common_sys_info.roam_status_valid      = TRUE;
        ind_msg->wcdma_sys_info.common_sys_info.roam_status            = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
      }

      ind_msg->wcdma_sys_info.common_sys_info.is_sys_forbidden_valid = TRUE;
      ind_msg->wcdma_sys_info.common_sys_info.is_sys_forbidden       = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      ind_msg->wcdma_sys_info.threegpp_specific_sys_info.lac         = p_ss_info->stack_info[stack_index].sys_id.id.plmn_lac.lac;
      if ( ind_msg->wcdma_sys_info.threegpp_specific_sys_info.lac != QMI_NAS_INVALID_LAC )
      {
        ind_msg->wcdma_sys_info.threegpp_specific_sys_info.lac_valid = TRUE;
      }

      ind_msg->wcdma_sys_info.threegpp_specific_sys_info.cell_id_valid     = TRUE;
      ind_msg->wcdma_sys_info.threegpp_specific_sys_info.cell_id           = p_ss_info->stack_info[stack_index].cell_info.cell_id;

      if( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->stack_info[stack_index].sys_id.id.plmn ))
      {
        ind_msg->wcdma_sys_info.threegpp_specific_sys_info.network_id_valid  = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( (char *) ind_msg->wcdma_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           (char *) ind_msg->wcdma_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].sys_id.id.plmn);
      }

      ind_msg->wcdma_sys_info.wcdma_specific_sys_info.hs_call_status_valid     = TRUE;
      ind_msg->wcdma_sys_info.wcdma_specific_sys_info.hs_call_status           = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_call_status;

      ind_msg->wcdma_sys_info.wcdma_specific_sys_info.hs_ind_valid             = TRUE;
      ind_msg->wcdma_sys_info.wcdma_specific_sys_info.hs_ind                   = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_ind;

      if( p_ss_info->stack_info[stack_index].cell_info.psc != 0xFFFF )
        {
          ind_msg->wcdma_sys_info.wcdma_specific_sys_info.psc_valid            = TRUE;
        ind_msg->wcdma_sys_info.wcdma_specific_sys_info.psc                  = p_ss_info->stack_info[stack_index].cell_info.psc;
      }

      if( p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
        {
          ind_msg->wcdma_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        ind_msg->wcdma_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain;
        ind_msg->wcdma_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->stack_info[stack_index].reg_reject_info.reject_cause;
      }

      ind_msg->wcdma_sys_info_valid                 = TRUE;

    // TLV 0x1D additional UMTS sys info
      ind_msg->wcdma_sys_info2_valid                = TRUE;
      ind_msg->wcdma_sys_info2.geo_sys_idx        = p_ss_info->stack_info[stack_index].geo_sys_idx;
      ind_msg->wcdma_sys_info2.cell_broadcast_cap = (uint32) p_ss_info->stack_info[stack_index].cell_bc_info.cell_bc_capability;

      ind_msg->wcdma_sys_info3_valid                = TRUE;
      if ( p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
      {
        ind_msg->wcdma_sys_info3.cs_bar_status    = (uint32) p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status;
      }
      else
      {
          ind_msg->wcdma_sys_info3.cs_bar_status    = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
      
      if ( p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        ind_msg->wcdma_sys_info3.ps_bar_status    = (uint32) p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status;
        }
        else
        {
          ind_msg->wcdma_sys_info3.ps_bar_status    = NAS_CELL_ACCESS_UNKNOWN_V01;
      }

      ind_msg->wcdma_cipher_domain_valid            = TRUE;
      ind_msg->wcdma_cipher_domain                  = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].cipher_domain;

      ind_msg->wcdma_eutra_status_valid             = TRUE;
      ind_msg->wcdma_eutra_status                   = (nas_eutra_cell_status_enum_type_v01)qmi_nas_eutra_status_cm_2_qmi( p_ss_info->eutra_detect_status );

      if( p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.rac_or_mme_code != 0xFF )
        {
          ind_msg->wcdma_rac_valid                    = TRUE;
        ind_msg->wcdma_rac                          = p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.rac_or_mme_code;
    }

      if( p_ss_info->stack_info[stack_index].available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        ind_msg->wcdma_reg_domain_valid             = TRUE;
        ind_msg->wcdma_reg_domain                   = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->stack_info[stack_index].available_plmn_type );
    }

      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        ind_msg->wcdma_voice_status_valid = TRUE;
        ind_msg->wcdma_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        ind_msg->wcdma_sms_status_valid = TRUE;
        ind_msg->wcdma_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }

#ifdef FEATURE_FEMTO_CSG
  if ( qm_efs_csg_supported() )
  {
        if( p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.csg_id != SYS_CSG_ID_INVALID )
      {
        ind_msg->wcdma_csg_info_valid = TRUE;
          ind_msg->wcdma_csg_info.id = p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.csg_id;
          ind_msg->wcdma_csg_info.name_len = MIN(p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.length, NAS_CSG_NAME_MAX_V01);
        memscpy(ind_msg->wcdma_csg_info.name, ind_msg->wcdma_csg_info.name_len,
                  p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.name, ind_msg->wcdma_csg_info.name_len );
          QM_MSG_HIGH_2("CM SS Evt csg_id %d, name_len %d", p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.csg_id, p_ss_info->stack_info[stack_index].rat_mode_info.wcdma_mode_info.csg_info.hnb_name.length);
    }
      }
#endif
    }
  } // end WCDMA

  /////////////////////////////////////////////////////////
  // LTE
  /////////////////////////////////////////////////////////

  if( TARGET_SUPPORTS_LTE )
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_LTE)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE)
  {
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }

    //TLV 0x14
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    ind_msg->lte_srv_status_info.srv_status          = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, stack_index, SYS_SYS_MODE_LTE );
#else // FEATURE_MMODE_REPORT_POWERSAVE
    if( stack_index != STACK_INDEX_MAX )
    {
      ind_msg->lte_srv_status_info.srv_status        = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
    }
    else
    {
      ind_msg->lte_srv_status_info.srv_status        = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
#endif // FEATURE_MMODE_REPORT_POWERSAVE

    if(stack_index != STACK_INDEX_MAX)
    {
      ind_msg->lte_srv_status_info.true_srv_status   = (nas_true_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].true_srv_status;
      ind_msg->lte_srv_status_info.is_pref_data_path = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_LTE );
    }
    else
    {
      ind_msg->lte_srv_status_info.true_srv_status   = SYS_SRV_STATUS_NO_SRV_V01;
    }
      ind_msg->lte_srv_status_info_valid             = TRUE;

    //TLV 0x19
    if ( ind_msg->lte_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->lte_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 &&
         stack_index != STACK_INDEX_MAX )
    {
      ind_msg->lte_sys_info.common_sys_info.srv_domain_valid             = TRUE;
      ind_msg->lte_sys_info.common_sys_info.srv_capability_valid         = TRUE;
      ind_msg->lte_sys_info.common_sys_info.is_sys_forbidden_valid       = TRUE;

      ind_msg->lte_sys_info.common_sys_info.srv_domain                 = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_domain;
      ind_msg->lte_sys_info.common_sys_info.srv_capability             = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_capability;
      ind_msg->lte_sys_info.common_sys_info.is_sys_forbidden           = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
        ind_msg->lte_sys_info.common_sys_info.roam_status_valid            = TRUE;
        ind_msg->lte_sys_info.common_sys_info.roam_status                = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
      }

      ind_msg->lte_sys_info.threegpp_specific_sys_info.lac_valid         = FALSE;
      ind_msg->lte_sys_info.threegpp_specific_sys_info.lac               = QMI_NAS_INVALID_LAC;

      ind_msg->lte_sys_info.threegpp_specific_sys_info.cell_id_valid = TRUE;
      ind_msg->lte_sys_info.threegpp_specific_sys_info.cell_id       = p_ss_info->stack_info[stack_index].cell_info.cell_id;

      if( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->stack_info[stack_index].sys_id.id.plmn ))
      {
        ind_msg->lte_sys_info.threegpp_specific_sys_info.network_id_valid = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( (char *) ind_msg->lte_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           (char *) ind_msg->lte_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].sys_id.id.plmn);
      }

      if( p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
        {
          ind_msg->lte_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        ind_msg->lte_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain;
        ind_msg->lte_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->stack_info[stack_index].reg_reject_info.reject_cause;
      }

      // LTE specific params
      ind_msg->lte_sys_info.lte_specific_sys_info.tac       =      p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.tac;
      if ( IS_TAC_VALID( ind_msg->lte_sys_info.lte_specific_sys_info.tac ) )
      {
      ind_msg->lte_sys_info.lte_specific_sys_info.tac_valid = TRUE;
      }
      else
      {
        ind_msg->lte_sys_info.lte_specific_sys_info.tac = 0;
      }

      ind_msg->lte_sys_info_valid                       = TRUE;

    // TLV 0x1E additional LTE sys info
      ind_msg->lte_sys_info2_valid                      = TRUE;

      ind_msg->lte_sys_info2.geo_sys_idx              = p_ss_info->stack_info[stack_index].geo_sys_idx;

    // TLV 0x21 voice support on LTE
      if ( p_ss_info->stack_info[stack_index].srv_domain ==  SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS)
    {
      ind_msg->voice_support_on_lte_valid              = TRUE;
        ind_msg->voice_support_on_lte                    = p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.voice_support_on_lte;
    }

#ifdef FEATURE_LTE_EMBMS
      // TLV 0x27 voice support on LTE (now deprecated)
      ind_msg->lte_embms_coverage_valid                = TRUE;
      if(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status != SYS_EMBMS_COVERAGE_STATUS_AVAILABLE)
      {
        ind_msg->lte_embms_coverage                                           = FALSE;
      }
      else
      {
        ind_msg->lte_embms_coverage                                           = TRUE;
      }

      // TLV 0x47 LTE eMBMS Coverage Info Extended
      ind_msg->embms_coverage_status_valid = TRUE;
      switch(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.embms_info.embms_coverage_status)
      {
      case SYS_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE:
        ind_msg->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE_V01; break;
      case SYS_EMBMS_COVERAGE_STATUS_AVAILABLE:
        ind_msg->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_AVAILABLE_V01; break;
      case SYS_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_UEMODE:
        ind_msg->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_UEMODE_V01; break;
      case SYS_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_E911:
        ind_msg->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_EMERGENCY_V01; break;
      default:
        ind_msg->embms_coverage_status = NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_UNKNOWN_V01; break;
      }

      // TLV 0x35 eMBMS coverage information // trace id
      ind_msg->lte_embms_coverage_trace_id_valid       = TRUE;
      ind_msg->lte_embms_coverage_trace_id             = p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.embms_info.trace_id;
#endif

      // TLV 0x2A voice support on LTE
      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS)
      {
        ind_msg->lte_ims_voice_avail_valid             = TRUE;
        ind_msg->lte_ims_voice_avail                   = p_ss_info->stack_info[stack_index].lte_ims_voice_avail;
      }

      // TLV 0x2B voice support on LTE
      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        ind_msg->lte_voice_status_valid                = TRUE;
        ind_msg->lte_voice_status                      = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_lte_voice_status_cm_to_qmi( p_ss_info );

        ind_msg->lte_sms_status_valid = TRUE;
        ind_msg->lte_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }

      // TLV 0x3A LTE Emergency Bearer Support
      // Assumption: CM will be passing this value for LTE on MAIN stack as well as GW_HYB stack
      ind_msg->lte_is_eb_supported_valid = TRUE;
      ind_msg->lte_is_eb_supported = qmi_nas_map_lte_eb_status_cm_to_qmi(p_ss_info->stack_info[stack_index].lte_ims_emerg_avail);

      // TLV 0x3F LTE Emergency Access Barred
      /* CM MASK checking is not required.
         Checking mask may cause issue( i.e. not sending this TLV) in case of if either PLMN, 
         TAC (in LTE) or LAC (other sys_modes) is out of sync in NAS when RRC reports EAB status.
      */
        ind_msg->emergency_access_barred_valid = TRUE;
      ind_msg->emergency_access_barred = qmi_nas_map_lte_eab_status_cm_to_qmi(p_ss_info->stack_info[stack_index].cell_info.emerg_access_status);

    // TLV 0x32 LTE Possible Registration Domain
     if( p_ss_info->stack_info[stack_index].available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        ind_msg->lte_reg_domain_valid                  = TRUE;
       ind_msg->lte_reg_domain                        = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->stack_info[stack_index].available_plmn_type );
    }

      ind_msg->lte_cell_status_valid                   = TRUE;

     if ( p_ss_info->stack_info[stack_index].cell_info.lte_cell_access_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
          p_ss_info->stack_info[stack_index].cell_info.lte_cell_access_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
       ind_msg->lte_cell_status                     = (nas_cell_access_status_e_type_v01) p_ss_info->stack_info[stack_index].cell_info.lte_cell_access_status;
        }
        else
        {
          ind_msg->lte_cell_status                     = NAS_CELL_ACCESS_UNKNOWN_V01;
        }

#ifdef FEATURE_FEMTO_CSG
  if ( qm_efs_csg_supported() )
  {
    if ( ind_msg->lte_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->lte_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01 )
    {
         if( p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.csg_id != SYS_CSG_ID_INVALID )
      {
        ind_msg->lte_csg_info_valid = TRUE;
           ind_msg->lte_csg_info.id = p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.csg_id;
           ind_msg->lte_csg_info.name_len = MIN(p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.length, NAS_CSG_NAME_MAX_V01);
        memscpy(ind_msg->lte_csg_info.name, ind_msg->lte_csg_info.name_len,
                          p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.name, ind_msg->lte_csg_info.name_len);
           QM_MSG_HIGH_2("CM SS Evt csg_id %d, name_len %d", p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.csg_id, p_ss_info->stack_info[stack_index].rat_mode_info.lte_mode_info.csg_info.hnb_name.length);
      }
      }
    }
#endif
   }
  }// end LTE

  // TLV 0x24 PLMN no change
  // This TLV is not RAT specific
  if( (p_ss_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_NO_CHANGE_MASK) ||
      (p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_EVT_NO_CHANGE_MASK) )
  {
    ind_msg->sys_info_no_change_valid                  = TRUE;
    ind_msg->sys_info_no_change                        = TRUE;
  }

  /////////////////////////////////////////////////////////
  // TDSCDMA
  /////////////////////////////////////////////////////////

  if ( TARGET_SUPPORTS_TDS )
  {
    if(p_ss_info->stack_info[STACK_INDEX_0].is_operational && p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_TDS)
    {
      stack_index = STACK_INDEX_0;
    }
    else if(p_ss_info->number_of_stacks > 1 && p_ss_info->stack_info[STACK_INDEX_1].is_operational && p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_TDS)
    { 
      stack_index = STACK_INDEX_1;
    }
    else
    {
      stack_index = STACK_INDEX_MAX;
    }
    
    //TLV 0x25
#ifdef FEATURE_MMODE_REPORT_POWERSAVE
    ind_msg->tdscdma_srv_status_info.srv_status        = qmi_nas_get_srv_status_from_cmss_event( p_ss_info, stack_index, SYS_SYS_MODE_TDS );
#else
    if( stack_index != STACK_INDEX_MAX )
    {
      ind_msg->tdscdma_srv_status_info.srv_status        = (nas_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].srv_status;
    }
    else
    {
      ind_msg->tdscdma_srv_status_info.srv_status        = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    }
#endif // FEATURE_MMODE_REPORT_POWERSAVE

    if( stack_index != STACK_INDEX_MAX )
    {
      ind_msg->tdscdma_srv_status_info.true_srv_status   = (nas_true_service_status_enum_type_v01)p_ss_info->stack_info[stack_index].true_srv_status;
      ind_msg->tdscdma_srv_status_info.is_pref_data_path = ( p_ss_info->stack_info[stack_index].cur_idle_digital_mode == SYS_SYS_MODE_TDS );
    }
    else
    {
      ind_msg->tdscdma_srv_status_info.true_srv_status   = SYS_SRV_STATUS_NO_SRV_V01;
    }

    ind_msg->tdscdma_srv_status_info_valid             = TRUE;

    //TLV 0x26
    if ( ind_msg->tdscdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_NO_SRV_V01   &&
         ind_msg->tdscdma_srv_status_info.srv_status != NAS_SYS_SRV_STATUS_PWR_SAVE_V01  &&
         stack_index != STACK_INDEX_MAX)
    {
      ind_msg->tdscdma_sys_info.common_sys_info.srv_domain_valid           = TRUE;
      ind_msg->tdscdma_sys_info.common_sys_info.srv_capability_valid       = TRUE;
      ind_msg->tdscdma_sys_info.common_sys_info.is_sys_forbidden_valid     = TRUE;

      if ( p_ss_info->stack_info[stack_index].roam_status != SYS_ROAM_STATUS_UNKNOWN )
      {
        ind_msg->tdscdma_sys_info.common_sys_info.roam_status                = (nas_roam_status_enum_type_v01)p_ss_info->stack_info[stack_index].roam_status;
      ind_msg->tdscdma_sys_info.common_sys_info.roam_status_valid          = TRUE;
      }

      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.hs_call_status_valid = TRUE;
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.hs_ind_valid         = TRUE;
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cell_broadcast_cap_valid  = TRUE;
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cs_bar_status_valid  = TRUE;
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status_valid  = TRUE;
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cipher_domain_valid  = TRUE;
      ind_msg->tdscdma_sys_info_valid                                          = TRUE;

      if ( p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
      {
        ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cs_bar_status      = (uint32) p_ss_info->stack_info[stack_index].cell_access_info.cs_bar_status;
      }
      else
      {
        ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cs_bar_status      = NAS_CELL_ACCESS_UNKNOWN_V01;
      }

      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status_valid  = TRUE;

      if ( p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status >= SYS_CELL_ACCESS_NORMAL_ONLY &&
           p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status <= SYS_CELL_ACCESS_ALL_CALLS   )
        {
        ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status      = (uint32) p_ss_info->stack_info[stack_index].cell_access_info.ps_bar_status;
        }
        else
        {
          ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.ps_bar_status      = NAS_CELL_ACCESS_UNKNOWN_V01;
        }
      
      ind_msg->tdscdma_sys_info.common_sys_info.srv_domain                 = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_domain;
      ind_msg->tdscdma_sys_info.common_sys_info.srv_capability             = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].srv_capability;
      ind_msg->tdscdma_sys_info.common_sys_info.is_sys_forbidden           = p_ss_info->stack_info[stack_index].is_sys_forbidden;

      if ( p_ss_info->stack_info[stack_index].cell_info.lac_id != QMI_NAS_INVALID_LAC )
      {
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.lac_valid     = TRUE;
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.lac           = p_ss_info->stack_info[stack_index].cell_info.lac_id;
      }

      ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.cell_id_valid = TRUE;
      ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.cell_id       = p_ss_info->stack_info[stack_index].cell_info.cell_id;

      if ( p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
      {
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.reg_reject_info_valid             = TRUE;
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.reg_reject_info.reject_srv_domain = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].reg_reject_info.reject_srv_domain;
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.reg_reject_info.rej_cause         = p_ss_info->stack_info[stack_index].reg_reject_info.reject_cause;
      }

      if ( p_ss_info->stack_info[stack_index].mode_info.gw_info.mm_information.plmn_avail )
      {
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.network_id_valid  = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( (char *) ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           (char *) ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].mode_info.gw_info.mm_information.plmn);
      }
      else if ( p_ss_info->stack_info[stack_index].sys_id.id_type == SYS_SYS_ID_TYPE_UMTS && !sys_plmn_id_is_undefined( p_ss_info->stack_info[stack_index].sys_id.id.plmn ))
      {
        ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.network_id_valid  = TRUE;
        convert_3gpp_plmn_2_ascii_mcc_mnc( (char *) ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mcc,
                                           (char *) ind_msg->tdscdma_sys_info.threegpp_specific_sys_info.network_id.mnc,
                                           p_ss_info->stack_info[stack_index].sys_id.id.plmn);
      }
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.hs_call_status       = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_call_status;
      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.hs_ind               = (nas_hs_support_enum_type_v01)p_ss_info->stack_info[stack_index].cell_srv_ind.hs_ind;

      if ( p_ss_info->stack_info[stack_index].cell_info.psc != 0xFFFF )
  {
        ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cell_parameter_id_valid = TRUE;
        ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cell_parameter_id       = p_ss_info->stack_info[stack_index].cell_info.psc;
      }

      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cell_broadcast_cap        = (uint32) p_ss_info->stack_info[stack_index].cell_bc_info.cell_bc_capability;

      ind_msg->tdscdma_sys_info.tdscdma_specific_sys_info.cipher_domain        = (nas_service_domain_enum_type_v01)p_ss_info->stack_info[stack_index].cipher_domain;

    // TLV 0x31 TDSCDMA Possible Registration Domain
      if( p_ss_info->stack_info[stack_index].available_plmn_type != SYS_REG_DOMAIN_NO_SERVICE )
      {
        ind_msg->tdscdma_reg_domain_valid = TRUE;
        ind_msg->tdscdma_reg_domain       = qmi_nas_map_available_plmn_type_cm_to_qmi( p_ss_info->stack_info[stack_index].available_plmn_type );
      }

      if ( p_ss_info->stack_info[stack_index].srv_domain == SYS_SRV_DOMAIN_PS_ONLY || p_ss_info->stack_info[stack_index].srv_domain  == SYS_SRV_DOMAIN_CS_PS )
      {
        ind_msg->tdscdma_voice_status_valid = TRUE;
        ind_msg->tdscdma_voice_status = (nas_lte_voice_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->voice_domain );

        ind_msg->tdscdma_sms_status_valid = TRUE;
        ind_msg->tdscdma_sms_status = (nas_sms_status_enum_type_v01)qmi_nas_map_voice_sms_status_cm_to_qmi( p_ss_info->sms_domain );
      }
    }
  }//End TDS

  // TLV 0x28 SIM reject information
  if ( TARGET_SUPPORTS_LTE || TARGET_SUPPORTS_WCDMA || TARGET_SUPPORTS_GSM || TARGET_SUPPORTS_TDS )
  {
    ind_msg->sim_rej_info_valid      = TRUE;
    if ( p_ss_info->stack_info[STACK_INDEX_0].mode_info.gw_info.sim_state == SYS_SIM_STATE_NOT_AVAILABLE )
        {
      ind_msg->sim_rej_info      = (nas_sim_rej_info_enum_type_v01)qmi_nasi_global.sim_state_before_not_avail[asubs_id];
        }
        else
        {
      ind_msg->sim_rej_info      = (nas_sim_rej_info_enum_type_v01)p_ss_info->stack_info[STACK_INDEX_0].mode_info.gw_info.sim_state;
        }
    }

  // Camp Only Indication - Global, always returned

  ind_msg->srv_reg_restriction_valid = TRUE;

  if( p_ss_info->stack_info[STACK_INDEX_0].available_plmn_type == SYS_REG_DOMAIN_NOT_APPLICABLE )
  {
    ind_msg->srv_reg_restriction     = NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01;
  }
  else
  {
    ind_msg->srv_reg_restriction     = NAS_SRV_REG_RESTRICTION_CAMPED_ONLY_V01;
    }
  }

/*===========================================================================
  FUNCTION QMI_NAS_GET_SIG_INFO()

  DESCRIPTION
    Returns the current signal strength information for all available
    RATs

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_sig_info(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;
  enum qm_subs_e     sub_id = QM_SUBS_MIN;

  nas_get_sig_info_resp_msg_v01 *rsp_msg = NULL;

  sys_modem_as_id_e_type asubs_id = SYS_MODEM_AS_ID_1;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  rsp_msg = (nas_get_sig_info_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_sig_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    qmi_voice_mem_error();
  }
  else
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_sig_info_resp_msg_v01) );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
  
#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
      asubs_id = SYS_MODEM_AS_ID_3;
    }
#endif
#endif
    sub_id = qm_util_map_cm_asubs_to_qm_subs(asubs_id);
    errval = qm_meas_populate_get_sig_info_resp(rsp_msg, sub_id);
    }

  if ( (errval != QMI_ERR_NO_MEMORY_V01) && (cmd_buf_p != NULL) )
  {
  // update result TLV
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01);
    rsp_msg->resp.error  = errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_sig_info_resp_msg_v01),
                                  &response
                                );
  }

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  rsp_msg = NULL;

  return response;
} /* qmi_nasi_get_sig_info */

/*===========================================================================
  FUNCTION QMI_NASI_CONFIG_SIG_INFO()

  DESCRIPTION
    To set thresholds for reporting sig info indication msg

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None
    (This message is DS/DS agnostic)

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_config_sig_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_type_v01                 errval         = QMI_ERR_NONE_V01;
  dsm_item_type                    * response = NULL;
  nas_config_sig_info_req_msg_v01  * req_msg;
  nas_config_sig_info_resp_msg_v01 * rsp_msg;
  qmi_nasi_client_state_type     *nasi_client_sp = (qmi_nasi_client_state_type *)cl_sp;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p,  cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  req_msg = (nas_config_sig_info_req_msg_v01  *) modem_mem_alloc( sizeof(nas_config_sig_info_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_config_sig_info_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_config_sig_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
    {
    memset( req_msg, 0x00, sizeof(nas_config_sig_info_req_msg_v01) );

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *)   req_msg,
                                           (uint32_t) sizeof(nas_config_sig_info_req_msg_v01)
                                         );
      }

  if ( errval == QMI_ERR_NONE_V01 )
      {
    errval = qmi_nas_0050_req_check( req_msg );
      }

  if ( errval == QMI_ERR_NONE_V01 )
      {
    qm_nas_clnt_process_config_sig_info( nasi_client_sp->common.clid, req_msg );
  } // End copy all thresholds

#ifdef FEATURE_LTE
  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( req_msg->lte_sig_rpt_config_valid )
    {
      if ( ! cmapi_set_lte_signal_reporting_config( ( cmapi_lte_signal_reporting_rate_e )req_msg->lte_sig_rpt_config.rpt_rate,
                                                    ( cmapi_lte_signal_averaging_period_e )req_msg->lte_sig_rpt_config.avg_period ) )
      {
        QM_MSG_HIGH("cmapi_set_lte_signal_reporting_config failed");
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
  }
#endif // FEATURE_LTE

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( !qmi_nasi_global.is_set_cm_ph_cmd_signal_strength_delta )
    {
      if (!cm_ph_cmd_signal_strength_delta_lte( qmi_nas_cmph_cmd_cb,
                                                cmd_buf_p,
                                                qmi_nasi_global.cm_clnt_id,
                                                NASI_MIN_SIG_INFO_DELTA, //rssi
                                                NASI_MIN_SIG_INFO_DELTA, //ecio
                                                NASI_MIN_SIG_INFO_DELTA, //io
                                                NASI_MIN_SIG_INFO_DELTA, //sinr
                                                NASI_SIG_STRENGTH_DELTA_NO_CHANGE, //pathloss
                                                NASI_SIG_STRENGTH_DELTA_NO_CHANGE, //cqi
                                                NASI_MIN_SIG_INFO_DELTA, //rsrp
                                                NASI_MIN_SIG_INFO_DELTA)) //rsrq
      {
        QM_MSG_ERROR("Unable to set rssi, ecio, io, sinr, rsrp and rsrq delta");
        errval = QMI_ERR_INTERNAL_V01;
      }
      else
      {
        QM_MSG_HIGH("Response pending for Set rssi, ecio, io, sinr, rsrp and rsrq delta ");
        qmi_nasi_global.is_pending_config_sig_info = TRUE;
      }
    }
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.is_pending_config_sig_info )
  {
    response = (dsm_item_type*) QMI_SVC_RESPONSE_PENDING;
    QM_MSG_HIGH("qmi_nasi_config_sig_info() returning QMI_SVC_RESPONSE_PENDING");
    }
  else if ( rsp_msg == NULL )
    {
    qmi_voice_mem_error();
    }
  else if ( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_config_sig_info_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_config_sig_info_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;

} /* qmi_nasi_config_sig_info() */

/*===========================================================================
  FUNCTION QMI_NAS_GET_ERR_RATE()

  DESCRIPTION
    Returns the error rate information for all available
    RATs

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_err_rate(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;
  enum qm_subs_e     sub_id = QM_SUBS_MIN;

  sys_modem_as_id_e_type asubs_id = SYS_MODEM_AS_ID_1;

  nas_get_err_rate_resp_msg_v01 * rsp_msg = NULL;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  rsp_msg = (nas_get_err_rate_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_err_rate_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    qmi_voice_mem_error();
  }
  else
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_err_rate_resp_msg_v01) );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
      asubs_id = SYS_MODEM_AS_ID_3;
    }
#endif
#endif
    sub_id = qm_util_map_cm_asubs_to_qm_subs(asubs_id);
    errval = qm_meas_populate_get_err_rate_resp(rsp_msg, sub_id);

    }

  if ( errval != QMI_ERR_NO_MEMORY_V01 && (cmd_buf_p != NULL) )
    {
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01);
    rsp_msg->resp.error  = errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *)   rsp_msg,
                                  (uint32_t) sizeof(nas_get_err_rate_resp_msg_v01),
                                  &response
                                );
      }      

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  rsp_msg = NULL;

  return response;
} /* qmi_nasi_get_err_rate */

/*===========================================================================
  FUNCTION QMI_NASI_UPDATE_AKEY_EXT()

  DESCRIPTION
    This command updates AKEY. Prior to performing any operation on the AKEY
    the modem will verify the SPC.  Modem will run authentication on the
    presented AKEY before updating AKEY. Authentication failure will result
    in error in response. On successful operation, the message will update
    NV_A_KEY_I NV item.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_update_akey_ext
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type      *response = NULL;
  qmi_error_e_type   errval    = QMI_ERR_NONE;
  qmi_result_e_type  result;
  boolean            retval;

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  qmi_svc_spc_result_e_type check_spc_result;
  struct nas_005B_req_s     req_msg;
#endif

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  if (TARGET_SUPPORTS_CDMA || TARGET_SUPPORTS_HDR)
  {
    memset(&req_msg, 0, sizeof(req_msg));

    /*-------------------------------------------------------------------------
      Read the incoming message
      -------------------------------------------------------------------------*/

    errval = qmi_nas_005B_req_read(&req_msg, sdu_in);

    /*-------------------------------------------------------------------------
      If request is valid, run authentication using AKEY
      -------------------------------------------------------------------------*/
    if ( errval == QMI_ERR_NONE )
    {
      errval = qmi_nas_005B_req_check(&req_msg);
    }

    if( errval == QMI_ERR_NONE )
    {
      check_spc_result = qmi_svc_check_spc((uint8*)req_msg.t01.spc, TRUE);

      if (check_spc_result == QMI_SVC_SPC_FAIL)
      {
        errval = QMI_ERR_AUTHENTICATION_FAILED;
      }
      else if (check_spc_result == QMI_SVC_SPC_LOCKED)
      {
        errval = QMI_ERR_AUTHENTICATION_LOCK;
      }
      else if (check_spc_result == QMI_SVC_SPC_ERR_INTERNAL)
      {
        errval = QMI_ERR_INTERNAL;
      }
    }

    if ( errval == QMI_ERR_NONE )
    {
      if(auth_validate_a_key(req_msg.t01.akey))
      {
        if (!auth_send_update_a_key_cmd(req_msg.t01.akey, NAS_005B_REQ_AKEY_EXT_ASCII_MAX_SIZE,0))
        {
          QM_MSG_ERROR("AKEY write command could not be given to modem");
          errval = QMI_ERR_INTERNAL;
        }
      }
      else
      {
        errval = QMI_ERR_INVALID_ARG;
      }
    }
  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }
#else
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
#endif // defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv( &response, result, errval );
  CHECK_RETVAL();
  return response;
} /* qmi_nasi_update_akey() */

#if 0
/*===========================================================================
  FUNCTION get_mode_pref()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to generate
    qmi_nas_sys_info_type message from a given CM SS and PH info. To be used
    in QMI_NAS_GET_SYS_INFO

  PARAMETERS
    cm_ph_info_s_type    CM PH info
    access_tech_s        ptr to return value

  RETURN VALUE
    boolean              TRUE / FALSE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean get_mode_pref( qmi_cm_ph_info_s_type *p_ph_info, struct access_tech_s *p )
{
  boolean ret_val = TRUE;

  switch ( p_ph_info->mode_pref )
  {
    case CM_MODE_PREF_DIGITAL_ONLY:              p->c=1; p->h=1; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_AUTOMATIC:                 p->c=1; p->h=1; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_CDMA_ONLY:                 p->c=1; p->h=0; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_HDR_ONLY:                  p->c=0; p->h=1; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_CDMA_AMPS_ONLY:            p->c=1; p->h=0; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_GPS_ONLY:                  p->c=0; p->h=0; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_GSM_ONLY:                  p->c=0; p->h=0; p->g=1; p->w=0; p->l=0; break;
    case CM_MODE_PREF_WCDMA_ONLY:                p->c=0; p->h=0; p->g=0; p->w=1; p->l=0; break;
    case CM_MODE_PREF_ANY_BUT_HDR:               p->c=1; p->h=0; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_GSM_WCDMA_ONLY:            p->c=0; p->h=0; p->g=1; p->w=1; p->l=0; break;
    case CM_MODE_PREF_DIGITAL_LESS_HDR_ONLY:     p->c=1; p->h=0; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_CDMA_HDR_ONLY:             p->c=1; p->h=1; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_CDMA_AMPS_HDR_ONLY:        p->c=1; p->h=1; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_WLAN_ONLY:                 p->c=0; p->h=0; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_CDMA_WLAN:                 p->c=1; p->h=0; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_HDR_WLAN:                  p->c=0; p->h=1; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_CDMA_HDR_WLAN:             p->c=1; p->h=1; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_GSM_WLAN:                  p->c=0; p->h=0; p->g=1; p->w=0; p->l=0; break;
    case CM_MODE_PREF_WCDMA_WLAN:                p->c=0; p->h=0; p->g=0; p->w=1; p->l=0; break;
    case CM_MODE_PREF_GW_WLAN:                   p->c=0; p->h=0; p->g=1; p->w=1; p->l=0; break;
    case CM_MODE_PREF_CDMA_AMPS_HDR_WLAN_ONLY:   p->c=1; p->h=1; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_CDMA_AMPS_WLAN_ONLY:       p->c=1; p->h=0; p->g=0; p->w=0; p->l=0; break;
    case CM_MODE_PREF_ANY_BUT_HDR_WLAN:          p->c=1; p->h=0; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_LTE_ONLY:                  p->c=0; p->h=0; p->g=0; p->w=0; p->l=1; break;
    case CM_MODE_PREF_GWL:                       p->c=0; p->h=0; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_HDR_LTE_ONLY:              p->c=0; p->h=1; p->g=0; p->w=0; p->l=1; break;
    case CM_MODE_PREF_CDMA_HDR_LTE_ONLY:         p->c=1; p->h=1; p->g=0; p->w=0; p->l=1; break;
    case CM_MODE_PREF_CDMA_HDR_GW:               p->c=1; p->h=1; p->g=1; p->w=1; p->l=0; break;
    case CM_MODE_PREF_CDMA_GW:                   p->c=1; p->h=0; p->g=1; p->w=1; p->l=0; break;
    case CM_MODE_PREF_ANY_BUT_WLAN:              p->c=1; p->h=1; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_GWL_WLAN:                  p->c=0; p->h=0; p->g=1; p->w=1; p->l=1; break;
    case CM_MODE_PREF_CDMA_LTE_ONLY:             p->c=1; p->h=0; p->g=0; p->w=0; p->l=1; break;
    case CM_MODE_PREF_ANY_BUT_HDR_LTE:           p->c=1; p->h=0; p->g=1; p->w=1; p->l=0; break;
    // TODO: clarify case CM_MODE_PREF_EMERGENCY:

    default:
      QM_MSG_ERROR_1("unknown mode_pref %d", p_ph_info->mode_pref);
      ret_val = FALSE;
  }

  return ret_val;
}
#endif
/*===========================================================================
  FUNCTION convert_cdma_mcc_2_ascii_mcc()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to generate
    mcc for CDMA.

  PARAMETERS
    p_mcc : ptr to return value (i.e ASCII )


  RETURN VALUE
   none

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void convert_cdma_mcc_2_ascii_mcc( char *p_mcc, word mcc )
{
  unsigned int d1, d2, d3, buf = mcc + 111;

  if ( mcc == 0x3FF ) // wildcard
  {
    *(p_mcc+0) = '3';
    *(p_mcc+1) = 0xFF;
    *(p_mcc+2) = 0xFF;
  }
  else
  {
    d3 = buf % 10;
    buf = ( d3 == 0 ) ? (buf-10)/10 : buf/10;

    d2 = buf % 10;
    buf = ( d2 == 0 ) ? (buf-10)/10 : buf/10;

    d1 = ( buf == 10 ) ? 0 : buf;

    if ( d1<10 && d2<10 && d3<10 )
    {
      *(p_mcc+0) = '0' + d1;
      *(p_mcc+1) = '0' + d2;
      *(p_mcc+2) = '0' + d3;
    }
    else
    {
      QM_MSG_ERROR_3("invalid digits %d %d %d", d1, d2, d3);
      *(p_mcc+0) = 0xFF;
      *(p_mcc+1) = 0xFF;
      *(p_mcc+2) = 0xFF;
    }
  }
}

/*===========================================================================
  FUNCTION convert_cdma_mnc_2_ascii_mnc()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to generate
    mnc for CDMA.

  PARAMETERS
    p_mnc : ptr to return value (i.e ASCII )


  RETURN VALUE
   none

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void convert_cdma_mnc_2_ascii_mnc( char *p_mnc, byte imsi_11_12)
{
  unsigned int d1, d2, buf = imsi_11_12 + 11;

  if ( imsi_11_12 == 0x7F ) // wildcard
  {
    *(p_mnc+0) = '7';
    *(p_mnc+1) = 0xFF;
    *(p_mnc+2) = 0xFF;
  }
  else
  {
    d2 = buf % 10;
    buf = ( d2 == 0 ) ? (buf-10)/10 : buf/10;

    d1 = ( buf == 10 ) ? 0 : buf;

    if ( d1<10 && d2<10 )
    {
     *(p_mnc+0) = '0' + d1;
      *(p_mnc+1) = '0' + d2;
      *(p_mnc+2) = 0xFF;
    }
    else
    {
      QM_MSG_ERROR_2("invalid digits %d %d", d1, d2);
      *(p_mnc+0) = 0xFF;
      *(p_mnc+1) = 0xFF;
      *(p_mnc+2) = 0xFF;
    }
  }
}
/*===========================================================================
  FUNCTION convert_3gpp_plmn_2_ascii_mcc_mnc()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to generate
    3 digit ASCII MCC and MNC values from a givem 3GPP PLMN.

  PARAMETERS
   *p_mcc : ptr to mcc to be returned
   *p_mnc : ptr to mnc to be returned
   *p_plmn: ptr to the input PLMN values

  RETURN VALUE
   none

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void convert_3gpp_plmn_2_ascii_mcc_mnc( char *p_mcc, char *p_mnc, sys_plmn_id_s_type p_plmn)
{
  boolean      plmn_is_undefined;
  boolean      mnc_includes_pcs_digit;
  sys_mcc_type mcc;
  sys_mcc_type mnc;

  sys_plmn_get_mcc_mnc2(p_plmn, &plmn_is_undefined, &mnc_includes_pcs_digit, &mcc, &mnc);

  if( !plmn_is_undefined )
  {
    // MCC
    p_mcc[2] = mcc%10 + '0';
    p_mcc[1] = (mcc/10)%10 + '0';
    p_mcc[0] = (mcc/100)%10 + '0';


    if( mnc == SYS_WILDCARD_MNC)
    {
      p_mnc[2] = 0xFF;
      p_mnc[1] = 0xFF;
      p_mnc[0] = 0xFF;
    }
    else
    {
      // MNC
      if( mnc_includes_pcs_digit )
      {
        p_mnc[2] = mnc%10 + '0';
        p_mnc[1] = (mnc/10)%10 + '0';
        p_mnc[0] = (mnc/100)%10 + '0';
      }
      else
      {
        p_mnc[2] = 0xFF;
        p_mnc[1] = mnc%10 + '0';
        p_mnc[0] = (mnc/10)%10 + '0';
      }
    }
  }
  else
  {
    // Undefined PLMN. Send all 'F' values
    p_mcc[0] = 0xFF;
    p_mcc[1] = 0xFF;
    p_mcc[2] = 0xFF;

    p_mnc[0] = 0xFF;
    p_mnc[1] = 0xFF;
    p_mnc[2] = 0xFF;

    QM_MSG_ERROR("PLMN undefined");
  }
}

#ifdef FEATURE_QMI_NAS_HDR
//===========================================================================
// FUNCTION: qmi_nasi_get_hdr_subtype
//
// DESCRIPTION:
//
// PARAMETERS:
//    sp        : service provided state pointer
//    cmd_buf_p : ptr to cmd buffer
//    cl_sp     : client state pointer
//    sdu_in    : incoming request
//
// RETURN:
//  ptr to response
//===========================================================================
//
static dsm_item_type*  qmi_nasi_get_hdr_subtype
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
   dsm_item_type *response = NULL;
   qmi_error_e_type errval   = QMI_ERR_NONE;
   struct nas_0056_req_s req_msg;
   struct nas_0056_rsp_s rsp_msg;

   uint16 subtype = 0;

   // check for null inputs
   if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in ) {
      QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
      errval = QMI_ERR_INTERNAL;
   }
   else if ( !TARGET_SUPPORTS_HDR ) {
      QM_MSG_ERROR_1("unsupported target %d", qmi_nasi_global.cm_ph_info.mode_capability);
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
   }
   else {
      memset(&req_msg, 0, sizeof(req_msg));

      //====================================================================
      // Read input parameters
      //====================================================================
      errval = qmi_nas_0056_req_read(&req_msg, sdu_in);

      //====================================================================
      // validate input paramteres
      //====================================================================
      if (errval == QMI_ERR_NONE) {
         errval = qmi_nas_0056_req_check(&req_msg);
      }

      //====================================================================
      // Call HDR function to get color code
      //====================================================================
      if (errval == QMI_ERR_NONE) {
#ifndef FEATURE_HDR
         errval = QMI_ERR_NOT_SUPPORTED;
#else
         subtype = hdrcp_scp_get_current_subtype(
                      (hdrhai_protocol_name_enum_type)req_msg.t01.protocol);
#endif
      }
   }

   // Create response message
   memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

   /*
     Note: To preservce backwards compatibility, in case of invalid HDR protocol value
     we will still include the TLV 0x10, with value 0xFFFF hardcoded.
   */
   rsp_msg.t02.result_code =
      (errval == QMI_ERR_NONE || errval == QMI_ERR_INVALID_ARG) ?  QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
   rsp_msg.t02.error_code  = (errval == QMI_ERR_NONE || errval == QMI_ERR_INVALID_ARG) ? QMI_ERR_NONE : errval ;
   rsp_msg.t02_valid = TRUE;

   rsp_msg.t10.subtype = ( errval == QMI_ERR_INVALID_ARG)? 0xFFFF : subtype;
   rsp_msg.t10_valid = (errval == QMI_ERR_NONE || errval == QMI_ERR_INVALID_ARG) ? TRUE : FALSE;

   if ( qmi_nas_0056_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE ) {
     response = NULL;
   }

   return response;
}

//===========================================================================
// FUNCTION: qmi_nasi_get_hdr_color_code
//
// DESCRIPTION:
//
// PARAMETERS:
//    sp        : service provided state pointer
//    cmd_buf_p : ptr to cmd buffer
//    cl_sp     : client state pointer
//    sdu_in    : incoming request
//
// RETURN:
//  ptr to response
//===========================================================================
//
static dsm_item_type*  qmi_nasi_get_hdr_color_code
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response   = NULL;
  qmi_error_e_type      errval     = QMI_ERR_NONE;
  struct nas_0057_rsp_s rsp_msg;

#ifdef FEATURE_HDR
  uint8                 color_code = 0;
  hdrerrno_enum_type err = E_SUCCESS;
#endif

  memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }
  else if ( !TARGET_SUPPORTS_HDR ) {
     QM_MSG_ERROR_1("unsupported target %d", qmi_nasi_global.cm_ph_info.mode_capability);
     errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }
  else {
#ifndef FEATURE_HDR
        errval = QMI_ERR_NOT_SUPPORTED;
#else
     // Call HDR function to get color code
     err = hdrcp_ovhd_get_color_code(&color_code, HDRHAI_EXTERNAL_MODULE);
     if ( err != E_SUCCESS )
     {
        errval = QMI_ERR_INTERNAL;
     }
     else
     {
       rsp_msg.t10.color_code = color_code;
       rsp_msg.t10_valid       = (errval == QMI_ERR_NONE) ? TRUE : FALSE;
     }
#endif
  }

  // Create response message
  rsp_msg.t02.result_code = (errval == QMI_ERR_NONE) ?  QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0057_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
}
#endif // FEATURE_QMI_NAS_HDR


//===========================================================================
// FUNCTION: qmi_nasi_get_cm_acq_mode
//
// DESCRIPTION:
//
// PARAMETERS:
//    sp        : service provided state pointer
//    cmd_buf_p : ptr to cmd buffer
//    cl_sp     : client state pointer
//    sdu_in    : incoming request
//
// RETURN:
//  ptr to response
//===========================================================================
//
static dsm_item_type* qmi_nasi_get_cm_acq_mode
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
   dsm_item_type        *response = NULL;
   qmi_error_e_type      errval   = QMI_ERR_NONE;
   nas_get_current_acq_sys_mode_resp_msg_v01 rsp_msg;

  memset (&rsp_msg, 0x00, sizeof(nas_get_current_acq_sys_mode_resp_msg_v01));


  QM_MSG_HIGH("Received request for GET_CM_ACQ_MODE. Message no longer supported");
  errval = QMI_ERR_NOT_SUPPORTED;

   // Set return status TLV
   rsp_msg.resp.result = (errval == QMI_ERR_NONE) ?  QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
   rsp_msg.resp.error  = (qmi_error_type_v01)errval;
   if(cmd_buf_p != NULL)
   {
     qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                   QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) &rsp_msg,
                                  (uint32_t) sizeof(nas_get_current_acq_sys_mode_resp_msg_v01),
                                  &response
                                );
   }

   return response;
}

#ifdef FEATURE_QMI_NAS_HDR
//===========================================================================
// FUNCTION: qmi_nas_cmd_handler
//
// DESCRIPTION:
//   Generic handler function for QMI NAS event handlers
//
// RETURN:
//   None
//===========================================================================
//
void qmi_nas_cmd_handler( qmi_mmode_cmd_enum_type cmd, void *payload )
{
   int clid;
   qmi_nasi_client_state_type *cl_sp;

   QM_MSG_HIGH("qmi_nas_cmd_handler: Enter");

   if (!payload) {
      QM_MSG_ERROR("NULL cmd param");
      return;
   }

   // Send indication to each QMI instance
  for (clid=0; clid < NASI_MAX_CLIDS; clid++)
   {
    cl_sp = qmi_nas_state.client[clid];

    if (!cl_sp || cl_sp->common.clid == QMI_SVC_CLID_UNUSED) { continue; }

         // Process indication according to payload type
         switch (*((enum qmi_nas_cmd_handler_type*)payload)) {
            case QMI_NAS_CMD_HDR: {
        qmi_nas_hdr_process_evt_payload(cl_sp, payload);
               break;
            }
            default: {
               QM_MSG_HIGH_1("Unhandled QMI NAS cmd type %d", *((uint32*)(payload)));
            }
         } // end_switch
      } // end_for clid
}

//===========================================================================
// FUNCTION: qmi_nas_hdr_process_evt_payload
//
// DESCRIPTION:
//   Process HDR event payload (called once per QMI CLID instance)
//
// RETURN:
//   None
//===========================================================================
//
void qmi_nas_hdr_process_evt_payload( qmi_nasi_client_state_type *cl_sp,
                                      const void *payload)
{
   uint16 id;
   dsm_item_type* dsm_ptr = NULL;
   qmi_error_e_type err_val = QMI_ERR_NONE;
   hdrmc_cb_params_rsp_union_type *parms;


   if (!payload) {
      QM_MSG_ERROR("NULL cmd param");
      return;
   }

   parms = &((struct qmi_nas_cmd_hdr_payload*)(payload))->parms;

   switch (parms->cb_type) {
      case HDRMC_CB_EVENT_UATI_UPDATE: {
         struct nas_0055_ind_s msg;

         if (! REGISTERED(cl_sp, uati) ) {
            return;
         } // not registered

         id = NASI_CMD_VAL_HDR_UATI_UPDATE_IND;
         memset( &msg, 0x00, sizeof(msg) );

         // copy UATI array to our struct
         memscpy(&msg.t01.uati, NAS_UATI_LENGTH,
                       &parms->uati_update.full_uati, NAS_UATI_LENGTH);
         msg.t01_valid = TRUE;
         err_val = qmi_nas_0055_ind_write( &msg, &dsm_ptr );

         break;
      }
      case HDRMC_CB_EVENT_SESSION_CLOSE: {
         struct nas_0054_ind_s msg;

         if (! REGISTERED(cl_sp, session_close) ) {
            return;
         } // not registered

         id = NASI_CMD_VAL_HDR_SESSION_CLOSE_IND;
         memset( &msg, 0x00, sizeof(msg) );

         // copy close_reason to our indication struct
         msg.t01.close_reason = parms->session_close.close_reason;
         msg.t01_valid = TRUE;
         err_val = qmi_nas_0054_ind_write( &msg, &dsm_ptr );

         break;
      }
      default:
         QM_MSG_ERROR_1("Unsupported HDR event", parms->cb_type);
         return;
   }

   if (err_val != QMI_ERR_NONE ) {
      QM_MSG_ERROR("Failed QMI_NAS data translation");
      return;
   }

   // Send indication to this QIM/CLID instance
   qmi_nasi_send_ind( cl_sp, id, dsm_ptr);

}
#endif // FEATURE_QMI_NAS_HDR

/*===========================================================================
  FUNCTION QMI_NASI_SET_RX_DIVERSITY()

  DESCRIPTION
    Message to set Rx diversity

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_rx_diversity
(
  void           *sp,
  void           *cmd_buf_p,
  void           *cl_sp,
  dsm_item_type **sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  struct nas_0059_req_s req_msg;
  struct nas_0059_rsp_s rsp_msg;

  memset( &req_msg, 0x00, sizeof(req_msg) );
  memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_0059_req_read( &req_msg, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_0059_req_check( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    cmapi_err_e_type                   err;
    cmapi_sys_mode_e_type              sys_mode = CMAPI_SYS_MODE_CDMA;

    switch ( req_msg.t01.radio_if )
    {
      case QMI_NAS_RADIO_IF_CDMA20001X:     sys_mode = CMAPI_SYS_MODE_CDMA;  break;
      case QMI_NAS_RADIO_IF_CDMA20001XEVDO: sys_mode = CMAPI_SYS_MODE_HDR;   break;
      case QMI_NAS_RADIO_IF_GSM:            sys_mode = CMAPI_SYS_MODE_GSM;   break;
      case QMI_NAS_RADIO_IF_UMTS:           sys_mode = CMAPI_SYS_MODE_WCDMA; break;
      case QMI_NAS_RADIO_IF_LTE:            sys_mode = CMAPI_SYS_MODE_LTE;   break;
      default:
        // should not come here as qmi_nas_0059_req_check() won't let us
        // adding default just to keep compiler quiet
        break;
    }

    err = cmapi_change_rx_diversity( sys_mode, (cmapi_rx_diversity_bit_mask_e_type)(req_msg.t01.rx_chain_bitmask) );

    if ( err != CMAPI_SUCCESS )
    {
      switch ( err )
      {
        case CMAPI_NO_SERVICE:       errval = QMI_ERR_NO_RADIO;              break;
        case CMAPI_INVALID_SYS_MODE: errval = QMI_ERR_OP_DEVICE_UNSUPPORTED; break;
        case CMAPI_INVALID_PARAM:    errval = QMI_ERR_INVALID_OPERATION;     break;

        default:
          QM_MSG_ERROR_1("cmapi err %d", err);
          errval = QMI_ERR_INTERNAL;
          break;
      }
    }
  }

  // update result TLV
  rsp_msg.t02.result_code = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0059_rsp_write ( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_TX_RX_INFO()

  DESCRIPTION
    Message to retrieve detailed Tx/Rx information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_tx_rx_info
(
  void           *sp,
  void           *cmd_buf_p,
  void           *cl_sp,
  dsm_item_type **sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
  nas_get_tx_rx_info_req_msg_v01 req_msg;
  nas_get_tx_rx_info_resp_msg_v01 *rsp_msg;
  uint8 i;

  rsp_msg = (nas_get_tx_rx_info_resp_msg_v01 *) 
  	modem_mem_alloc( sizeof(nas_get_tx_rx_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    return NULL;
  }
  memset (rsp_msg, 0x00, sizeof(nas_get_tx_rx_info_resp_msg_v01));

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
   // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *) &req_msg,
                                           (uint32_t) sizeof(nas_get_tx_rx_info_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_005A_req_check( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    cmapi_err_e_type         err;
    cmapi_sys_mode_e_type    sys_mode = CMAPI_SYS_MODE_CDMA;
    cmapi_signal_info_s_type signal_info;

    switch ( req_msg.radio_if )
    {
      case QMI_NAS_RADIO_IF_CDMA20001X:     sys_mode = CMAPI_SYS_MODE_CDMA;  break;
      case QMI_NAS_RADIO_IF_CDMA20001XEVDO: sys_mode = CMAPI_SYS_MODE_HDR;   break;
      case QMI_NAS_RADIO_IF_GSM:            sys_mode = CMAPI_SYS_MODE_GSM;   break;
      case QMI_NAS_RADIO_IF_UMTS:           sys_mode = CMAPI_SYS_MODE_WCDMA; break;
      case QMI_NAS_RADIO_IF_LTE:            sys_mode = CMAPI_SYS_MODE_LTE;   break;
      case QMI_NAS_RADIO_IF_TDSCDMA:        sys_mode = CMAPI_SYS_MODE_TDS;   break;
      default:
        // should not come here as qmi_nas_005A_req_check() won't let us
        // adding default just to keep compiler quiet
        break;
    }

    QM_MSG_HIGH_1("Calling cmapi_get_signal_info with sys_mode:%d", sys_mode);
    err = cmapi_get_signal_info( sys_mode, &signal_info );

    if ( err == CMAPI_SUCCESS )
    {
      cmapi_rx_chain_info_s_type *p_sig_info;

      QM_MSG_HIGH_1("cmapi_get_signal_info rx_diversity_indicator:%d", signal_info.rx_power.rx_diversity_indicator);
      if ( signal_info.rx_power.rx_diversity_indicator & CMAPI_BM_RX_CHAIN_0 )
      {
        p_sig_info = &signal_info.rx_power.rx_pwr_chain[CMAPI_RX_CHAIN_0];

        rsp_msg->rx_chain_0.is_radio_tuned = p_sig_info->is_radio_tuned ? 1 : 0;
        rsp_msg->rx_chain_0.rx_pwr         = p_sig_info->rx_pwr;
        rsp_msg->rx_chain_0.ecio           = p_sig_info->ecio * (-1);
        rsp_msg->rx_chain_0.rscp           = p_sig_info->rscp * (-1);
        rsp_msg->rx_chain_0.rsrp           = p_sig_info->rsrp * (-1);
        rsp_msg->rx_chain_0.phase          = p_sig_info->phase;

        rsp_msg->rx_chain_0_valid = TRUE;
      }

      if ( signal_info.rx_power.rx_diversity_indicator & CMAPI_BM_RX_CHAIN_1 )
      {
        p_sig_info = &signal_info.rx_power.rx_pwr_chain[CMAPI_RX_CHAIN_1];

        rsp_msg->rx_chain_1.is_radio_tuned = p_sig_info->is_radio_tuned ? 1 : 0;
        rsp_msg->rx_chain_1.rx_pwr         = p_sig_info->rx_pwr;
        rsp_msg->rx_chain_1.ecio           = p_sig_info->ecio * (-1);
        rsp_msg->rx_chain_1.rscp           = p_sig_info->rscp * (-1);
        rsp_msg->rx_chain_1.rsrp           = p_sig_info->rsrp * (-1);
        rsp_msg->rx_chain_1.phase          = p_sig_info->phase;

        rsp_msg->rx_chain_1_valid = TRUE;
      }

      rsp_msg->tx.is_in_traffic = signal_info.tx_power.is_in_traffic ? 1 : 0;
      rsp_msg->tx.tx_pwr        = signal_info.tx_power.tx_pwr;
      rsp_msg->tx_valid = TRUE;
      if(sys_mode == CMAPI_SYS_MODE_LTE)
      {
        if(
            (signal_info.modulation.lte_modulation.downlink.num_layer > 0) &&
            (signal_info.modulation.lte_modulation.downlink.num_layer < NAS_LTE_MAX_NUM_LAYER)
          )
        {
          rsp_msg->downlink_mod_valid = TRUE;
          rsp_msg->downlink_mod_len = signal_info.modulation.lte_modulation.downlink.num_layer;
          for(i = 0; i < rsp_msg->downlink_mod_len; i++)
          {
            rsp_msg->downlink_mod[i] = (nas_lte_modulation_enum_type_v01)signal_info.modulation.lte_modulation.downlink.modulation[i];
          }
        }
  
        if(
            (signal_info.modulation.lte_modulation.uplink.num_layer > 0) &&
            (signal_info.modulation.lte_modulation.uplink.num_layer < NAS_LTE_MAX_NUM_LAYER)
          )
        {
          rsp_msg->uplink_mod_valid = TRUE;
          rsp_msg->uplink_mod_len = signal_info.modulation.lte_modulation.uplink.num_layer;
          for(i = 0; i < rsp_msg->uplink_mod_len; i++)
          {
            rsp_msg->uplink_mod[i] = (nas_lte_modulation_enum_type_v01)signal_info.modulation.lte_modulation.uplink.modulation[i];
          }
        }
      }

      if ( signal_info.rx_power.rx_diversity_indicator & CMAPI_BM_RX_CHAIN_2 )
      {
        p_sig_info = &signal_info.rx_power.rx_pwr_chain[CMAPI_RX_CHAIN_2];

        rsp_msg->rx_chain_2.is_radio_tuned = p_sig_info->is_radio_tuned ? 1 : 0;
        rsp_msg->rx_chain_2.rx_pwr         = p_sig_info->rx_pwr;
        rsp_msg->rx_chain_2.ecio           = p_sig_info->ecio * (-1);
        rsp_msg->rx_chain_2.rscp           = p_sig_info->rscp * (-1);
        rsp_msg->rx_chain_2.rsrp           = p_sig_info->rsrp * (-1);
        rsp_msg->rx_chain_2.phase          = p_sig_info->phase;

        rsp_msg->rx_chain_2_valid = TRUE;
      }

      if ( signal_info.rx_power.rx_diversity_indicator & CMAPI_BM_RX_CHAIN_3 )
      {
        p_sig_info = &signal_info.rx_power.rx_pwr_chain[CMAPI_RX_CHAIN_3];

        rsp_msg->rx_chain_3.is_radio_tuned = p_sig_info->is_radio_tuned ? 1 : 0;
        rsp_msg->rx_chain_3.rx_pwr         = p_sig_info->rx_pwr;
        rsp_msg->rx_chain_3.ecio           = p_sig_info->ecio * (-1);
        rsp_msg->rx_chain_3.rscp           = p_sig_info->rscp * (-1);
        rsp_msg->rx_chain_3.rsrp           = p_sig_info->rsrp * (-1);
        rsp_msg->rx_chain_3.phase          = p_sig_info->phase;

        rsp_msg->rx_chain_3_valid= TRUE;
      }
    }
    else
    {
      QM_MSG_HIGH_1("cmapi_get_signal_info failed with err %d", err);
      switch ( err )
      {
        case CMAPI_NO_SERVICE:       errval = QMI_ERR_NO_RADIO;              break;
        case CMAPI_INVALID_SYS_MODE: errval = QMI_ERR_OP_DEVICE_UNSUPPORTED; break;

        default:
          QM_MSG_ERROR_1("cmapi err %d", err);
          errval = QMI_ERR_INTERNAL;
          break;
      }
    }
  }

  if(errval != QMI_ERR_NONE)
  {
    memset (rsp_msg, 0x00, sizeof(nas_get_tx_rx_info_resp_msg_v01));
  }

  if( cmd_buf_p != NULL)
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_tx_rx_info_resp_msg_v01),
                                  &response
                                );
  }

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NAS_GEN_MANAGED_ROAMING_IND()

  DESCRIPTION
    Generate a managed roaming indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    cm_ph_info_s_type    CM PH info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_managed_roaming_ind( cm_mm_msim_ss_info_s_type *p_ss_info, qmi_cm_ph_info_s_type *p_ph_info, enum qmi_nas_subs_e bound_subs )
{
  boolean                     send_ind = FALSE;
  nv_item_type                nv_item;
  struct nas_0046_ind_s       ind_msg;

  dsm_item_type              *ind;
  int                         client;
  qmi_nasi_client_state_type *cl_sp;

  memset( &ind_msg, 0x00, sizeof(ind_msg) );

  if( TARGET_SUPPORTS_LTE || TARGET_SUPPORTS_GSM || TARGET_SUPPORTS_WCDMA )
  {
    // Check SS event values
     if( (p_ss_info->stack_info[STACK_INDEX_0].changed_fields & CM_SS_EVT_TRUE_SRV_STATUS_MASK) &&
           ( (p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_GSM) ||
             (p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_WCDMA) ||
             (p_ss_info->stack_info[STACK_INDEX_0].sys_mode == SYS_SYS_MODE_LTE) ) &&
           p_ss_info->stack_info[STACK_INDEX_0].true_srv_status == SYS_SRV_STATUS_LIMITED &&
           p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        send_ind = TRUE;
        ind_msg.t10.radio_if = qmi_nas_sys_mode_2_radio_if( p_ss_info, STACK_INDEX_0, FALSE );
        ind_msg.t10_valid = TRUE;
      }
      else if( p_ss_info->number_of_stacks > 1 &&
               (p_ss_info->stack_info[STACK_INDEX_1].changed_fields & CM_SS_TRUE_SRV_STATUS_MASK) &&
             ( (p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_GSM) ||
             (p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_WCDMA) ||
             (p_ss_info->stack_info[STACK_INDEX_1].sys_mode == SYS_SYS_MODE_LTE) ) &&
           p_ss_info->stack_info[STACK_INDEX_1].true_srv_status == SYS_SRV_STATUS_LIMITED &&
           p_ph_info->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL )
      {
        send_ind = TRUE;
        ind_msg.t10.radio_if = qmi_nas_sys_mode_2_radio_if( p_ss_info, STACK_INDEX_1, FALSE );
        ind_msg.t10_valid = TRUE;
      }

    // Read and check NV only if SS event indicates managed roaming
    // !GPRS && (MGRF || ENS)
    if( send_ind == TRUE )
    {
      if( qmi_mmode_get_nv_item_ext(NV_GPRS_ANITE_GCF_I, &nv_item, (bound_subs ? 1 : 0)) != NV_DONE_S )
      {
        return;
      }
      else if( nv_item.gprs_anite_gcf == TRUE )
      {
        return;
      }

      if( (qmi_mmode_get_nv_item_ext(NV_MGRF_SUPPORTED_I, &nv_item, (bound_subs ? 1 : 0)) != NV_DONE_S) ||
          (nv_item.mgrf_supported == FALSE) )
      {
        if( qmi_mmode_get_nv_item_ext(NV_ENS_ENABLED_I, &nv_item, (bound_subs ? 1 : 0)) != NV_DONE_S )
        {
          return;
        }
        else if( nv_item.ens_enabled == FALSE )
        {
          return;
        }
      }
    }

    // Send indication to clients as all checks have passed
    if( send_ind == TRUE )
    {
      for ( client=0; client<NASI_MAX_CLIDS; client++ )
      {
        cl_sp = qmi_nas_state.client[client];

        if ( cl_sp && cl_sp->common.clid != NASI_CLID_UNUSED && cl_sp->report_status.report_managed_roaming && cl_sp->report_status.bound_subs == bound_subs )
            {
              ind = NULL;

              if ( qmi_nas_0046_ind_write ( &ind_msg, &ind ) == QMI_ERR_NONE )
              {
            qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_MANAGED_ROAMING_IND, ind );
          }
        }
      }
    }
  }
}


/*===========================================================================
  FUNCTION QMI_NASI_GET_DUAL_STANDBY_PREF()

  DESCRIPTION
    Get the Dual Standby Preference of the device.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_dual_standby_pref
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type           *response = NULL;
  qmi_error_type_v01       errval = QMI_ERR_NONE_V01;

  nas_get_dual_standby_pref_resp_msg_v01   *rsp_msg = NULL;

#ifdef FEATURE_DUAL_SIM
  qmi_cm_ph_info_s_type      *p_ph_info = &qmi_nasi_global.cm_ph_info;
#endif

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  rsp_msg = (nas_get_dual_standby_pref_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_dual_standby_pref_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    qmi_voice_mem_error();
  }
  else
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_dual_standby_pref_resp_msg_v01) );
  }


#ifdef FEATURE_DUAL_SIM
  if(errval == QMI_ERR_NONE_V01)
  {
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    if( !qmi_nasi_global.rcvd_ph_info2 )
    {
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    }
    else
    {
      p_ph_info = &qmi_nasi_global.cm_ph_info2;
    }
  }
#ifdef FEATURE_TRIPLE_SIM    
   else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY)
   {
     if( !qmi_nasi_global.rcvd_ph_info3 )
     {
       errval = QMI_ERR_INFO_UNAVAILABLE_V01;
     }
     else
     {
       p_ph_info = &qmi_nasi_global.cm_ph_info3;
     }
   }
#endif
  else if( ((qmi_nasi_client_state_type*)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY )
  {
    if( !qmi_nasi_global.rcvd_ph_info )
    {
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    }
    else
    {
      p_ph_info = &qmi_nasi_global.cm_ph_info;
    }
  }
  else
  {
    QM_MSG_ERROR_1("invalid binding %d", ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs);
    errval = QMI_ERR_INTERNAL_V01;
  }
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH_3("get_dual_standby_pref subs %d standby_pref %d active_subs %d", ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs, p_ph_info->standby_pref, p_ph_info->active_subs);

    qmi_nas_map_standby_pref_cm_to_qmi((uint32*)&rsp_msg->standby_pref, p_ph_info->standby_pref );
    rsp_msg->standby_pref_valid = TRUE;

    rsp_msg->priority_subs       = (nas_subs_type_enum_v01)p_ph_info->priority_subs;
    rsp_msg->priority_subs_valid = TRUE;

    rsp_msg->active_subs = (nas_subs_type_enum_v01)p_ph_info->active_subs;
    rsp_msg->active_subs_valid = TRUE;

    rsp_msg->default_data_subs       = (nas_subs_type_enum_v01)p_ph_info->default_data_subs;
    rsp_msg->default_data_subs_valid = TRUE;

    rsp_msg->default_voice_subs       = (nas_subs_type_enum_v01)p_ph_info->default_voice_subs;
    rsp_msg->default_voice_subs_valid = TRUE;

    rsp_msg->active_subs_mask_valid = TRUE;
    if ( p_ph_info->standby_pref == SYS_MODEM_DS_PREF_NO_STANDBY_PREF )
    {
      rsp_msg->active_subs_mask = 0;
    }
    else if ( p_ph_info->standby_pref == SYS_MODEM_DS_PREF_SINGLE_STANDBY )
    {
#ifdef FEATURE_TRIPLE_SIM
      if ( p_ph_info->active_subs == SYS_MODEM_AS_ID_3 )
      {
        rsp_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_TERTIARY_V01;
      }
      else 
#endif
      if ( p_ph_info->active_subs == SYS_MODEM_AS_ID_2 )
      {
        rsp_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
      }
      else
      {
        rsp_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
      }
    }
    else if ( p_ph_info->standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY ||
              p_ph_info->standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY)
    {
      rsp_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
      rsp_msg->active_subs_mask |= QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( p_ph_info->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY ||
              p_ph_info->standby_pref == SYS_MODEM_DS_PREF_TRIPLE_STANDBY_NO_TUNEAWAY )
    {
      rsp_msg->active_subs_mask = QMI_NAS_ACTIVE_SUB_PRIMARY_V01;
      rsp_msg->active_subs_mask |= QMI_NAS_ACTIVE_SUB_SECONDARY_V01;
      rsp_msg->active_subs_mask |= QMI_NAS_ACTIVE_SUB_TERTIARY_V01;
    }
#endif
    else
    {
      rsp_msg->active_subs_mask_valid = FALSE;
    }
  }

#else /* FEATURE_DUAL_SIM */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* FEATURE_DUAL_SIM */

  if ( (errval != QMI_ERR_NO_MEMORY_V01) && (rsp_msg != NULL) && (cmd_buf_p != NULL) )
  {
  // update result TLV
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01);
    rsp_msg->resp.error  = errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_dual_standby_pref_resp_msg_v01),
                                  &response
                                );
  }

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_dual_standby_pref() */

/*===========================================================================
  FUNCTION QMI_NASI_DETACH_LTE()

  DESCRIPTION
    Message to detach lte

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_detach_lte
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  cm_plmn_blocking_info_s_type plmn_detach;
  dsm_item_type               *response = NULL;
  qmi_error_e_type             errval    = QMI_ERR_NONE;

  plmn_detach.request_pref = CM_PLMN_BLOCKING_PREF_LTE_DETACH_ONLY;

  /* Ignoring callback from command for now */
  if( !cm_ph_cmd_detach_and_plmn_blocking( qmi_nas_cmph_cmd_cb, cmd_buf_p, qmi_nasi_global.cm_clnt_id, plmn_detach ) )
  {
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    struct nas_005D_rsp_s        rsp_msg;

    memset(&rsp_msg, 0, sizeof(rsp_msg));

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_005D_rsp_write ( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
}


/*===========================================================================
  FUNCTION QMI_NASI_BLOCK_LTE_PLMN()

  DESCRIPTION
    Message to set Rx diversity

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_block_lte_plmn
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  cm_plmn_blocking_info_s_type plmn_block;
  struct nas_005E_req_s        req_msg;
  dsm_item_type               *response = NULL;
  qmi_error_e_type             errval    = QMI_ERR_NONE;
  enum qmi_nas_subs_e  as_id = QMI_NAS_SUBS_PRIMARY;

  memset(&req_msg, 0, sizeof(req_msg));
  memset(&plmn_block, 0, sizeof(plmn_block));
  plmn_block.cause = SYS_BLOCK_PLMN_CAUSE_NONE;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }
  if(cl_sp != NULL)
  {
    as_id = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs; 
  }
  if( (as_id >= QMI_NAS_SUBS_MAX) || (as_id <= QMI_NAS_SUBS_NONE) )
  {
    QM_MSG_ERROR("qmi_nasi_block_lte_plmn(): Received invalid as_id from client state pointer.");
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_005E_req_read( &req_msg, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_005E_req_check( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    plmn_block.request_pref = CM_PLMN_BLOCKING_PREF_LTE_DETACH_PLMN_BLOCKING;
    if( !sys_plmn_set_mcc_mnc( req_msg.t01.mnc_includes_pcs_digit, req_msg.t01.mcc, req_msg.t01.mnc, &plmn_block.plmn ) )
    {
      errval = QMI_ERR_INTERNAL;
    }
    else
    {
      if( req_msg.t10_valid )
      {
        plmn_block.blocking_interval = req_msg.t10.blocking_interval_abs;
      }
      else if( req_msg.t11_valid )
      {
        plmn_block.blocking_interval = (uint32)(qmi_nasi_global.t3402_value[as_id] * req_msg.t11.blocking_interval_mult);
      }
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    /* Ignoring callback from command for now */
    if( !cm_ph_cmd_detach_and_plmn_blocking( qmi_nas_cmph_cmd_cb, cmd_buf_p, qmi_nasi_global.cm_clnt_id, plmn_block ) )
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    struct nas_005E_rsp_s        rsp_msg;

    memset(&rsp_msg, 0, sizeof(rsp_msg));

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_005E_rsp_write ( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
}


/*===========================================================================
  FUNCTION QMI_NASI_UNBLOCK_LTE_PLMN()

  DESCRIPTION
    Message to set Rx diversity

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_unblock_lte_plmn
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  cm_plmn_blocking_info_s_type plmn_unblock;
  struct nas_005F_req_s        req_msg;
  dsm_item_type               *response = NULL;
  qmi_error_e_type             errval    = QMI_ERR_NONE;

  memset(&req_msg, 0, sizeof(req_msg));
  memset(&plmn_unblock, 0, sizeof(plmn_unblock));
  plmn_unblock.cause = SYS_BLOCK_PLMN_CAUSE_NONE;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_005F_req_read( &req_msg, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_005F_req_check( &req_msg );
  }

  if ( errval == QMI_ERR_NONE )
  {
    plmn_unblock.request_pref = CM_PLMN_BLOCKING_PREF_PLMN_UNBLOCKING_ONLY;
    if( !sys_plmn_set_mcc_mnc( req_msg.t01.mnc_includes_pcs_digit, req_msg.t01.mcc, req_msg.t01.mnc, &plmn_unblock.plmn ) )
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    /* Ignoring callback from command for now */
    if( !cm_ph_cmd_detach_and_plmn_blocking( qmi_nas_cmph_cmd_cb, cmd_buf_p, qmi_nasi_global.cm_clnt_id, plmn_unblock ) )
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    struct nas_005F_rsp_s        rsp_msg;

    memset(&rsp_msg, 0, sizeof(rsp_msg));

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_005F_rsp_write ( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
}


/*===========================================================================
  FUNCTION QMI_NASI_RESET_LTE_PLMN_BLOCKING()

  DESCRIPTION
    Message to set Rx diversity

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_reset_lte_plmn_blocking
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  cm_plmn_blocking_info_s_type plmn_reset;
  dsm_item_type               *response = NULL;
  qmi_error_e_type             errval    = QMI_ERR_NONE;

  plmn_reset.request_pref = CM_PLMN_BLOCKING_PREF_PLMN_RESET;

  /* Ignoring callback from command for now */
  if( !cm_ph_cmd_detach_and_plmn_blocking( qmi_nas_cmph_cmd_cb, cmd_buf_p, qmi_nasi_global.cm_clnt_id, plmn_reset ) )
  {
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    struct nas_0060_rsp_s        rsp_msg;

    memset(&rsp_msg, 0, sizeof(rsp_msg));

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_0060_rsp_write ( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
}

/*===========================================================================
  FUNCTION qmi_nas_is_different_from_last_sent_name()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to determine if newly available
    network name differens from last sent PLMN Name.
    
  PARAMETERS
    eons: pointer to eons information to compare to.

  RETURN VALUE
   boolean : TRUE if name information differs
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_is_different_from_last_sent_name( 
  mmgsdi_eons_evt_info_type *spn,
  mmgsdi_eons_per_stack_evt_info_type *plmn_name,
  uint8   stack_idx,
  boolean ign_disp
)
{
  struct current_plmn_name_s *name_cache = ((stack_idx == STACK_INDEX_0) ? &qmi_nasi_global.current_plmn_name_cache : &qmi_nasi_global.current_plmn_name_cache_sec_stack);

  if( ign_disp )
  {
    name_cache = ((stack_idx == STACK_INDEX_0) ? &qmi_nasi_global.current_plmn_name_cache_ignore : &qmi_nasi_global.current_plmn_name_cache_sec_stack_ignore);
  }

  if ( ign_disp || spn->display_spn )
  {
    if ( name_cache->srv_prov_name.eons_encoding != spn->spn.eons_encoding ||
         name_cache->srv_prov_name.eons_data.data_len != spn->spn.eons_data.data_len ||
       memcmp( name_cache->srv_prov_name.eons_data.data_ptr, 
                 spn->spn.eons_data.data_ptr, 
                 spn->spn.eons_data.data_len ) )
  {
    return TRUE;
  }
  }

  if ( ign_disp || plmn_name->display_operator_info )
  {
    if ( name_cache->plmn_long_name.plmn_name_spare_bits != plmn_name->operator_info.plmn_long_name.plmn_name_spare_bits ||
         name_cache->plmn_long_name.plmn_name_ci != plmn_name->operator_info.plmn_long_name.plmn_name_ci ||
         name_cache->plmn_long_name.plmn_name.eons_encoding != plmn_name->operator_info.plmn_long_name.plmn_name.eons_encoding ||
         name_cache->plmn_long_name.plmn_name.eons_data.data_len != plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_len ||
       memcmp( name_cache->plmn_long_name.plmn_name.eons_data.data_ptr, 
                 plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_ptr, 
                 plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_len ) )
  {
    return TRUE;
  }

    if ( name_cache->plmn_short_name.plmn_name_spare_bits != plmn_name->operator_info.plmn_short_name.plmn_name_spare_bits ||
         name_cache->plmn_short_name.plmn_name_ci != plmn_name->operator_info.plmn_short_name.plmn_name_ci ||
         name_cache->plmn_short_name.plmn_name.eons_encoding != plmn_name->operator_info.plmn_short_name.plmn_name.eons_encoding ||
         name_cache->plmn_short_name.plmn_name.eons_data.data_len != plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_len ||
       memcmp( name_cache->plmn_short_name.plmn_name.eons_data.data_ptr, 
                 plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_ptr, 
                 plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_len ) )
  {
    return TRUE;
  }
  }
  
  return FALSE;
}

/*===========================================================================
  FUNCTION QMI_NAS_GEN_CURRENT_PLMN_NAME_IND()

  DESCRIPTION
    Generate a current plmn name indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_current_plmn_name_ind(
  cm_mm_msim_ss_info_s_type *p_ss_info,
  mmgsdi_session_type_enum_type session
)
{
  nas_current_plmn_name_ind_msg_v01 *ind_msg;
  nas_current_plmn_name_ind_msg_v01 *ind_msg_sec_stack;  // SGLTE only

  dsm_item_type              *ind, *ind_sec;
  int                         clid;
  qmi_nasi_client_state_type *cl_sp;
  boolean                     send_main = FALSE, send_sec = FALSE;

  ind_msg = (nas_current_plmn_name_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_current_plmn_name_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  ind_msg_sec_stack = (nas_current_plmn_name_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_current_plmn_name_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ind_msg != NULL )
  {
    memset( ind_msg, 0x00, sizeof( nas_current_plmn_name_ind_msg_v01 ) );

    if ( p_ss_info->stack_info[STACK_INDEX_0].srv_status == SYS_SRV_STATUS_SRV )
    {
      QM_MSG_HIGH("Generating current_plmn_name indication");
      send_main = qmi_nas_populate_current_plmn_name_ind( ind_msg, p_ss_info, STACK_INDEX_0, FALSE, session );
    }
    else
    {
      qmi_nasi_global.current_plmn_name_cache.current_plmn_valid = FALSE;
    }
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( ind_msg_sec_stack != NULL )
  {
    memset( ind_msg_sec_stack, 0x00, sizeof( nas_current_plmn_name_ind_msg_v01 ) );

    if ( p_ss_info->number_of_stacks > 1 &&
         p_ss_info->stack_info[STACK_INDEX_1].srv_status == SYS_SRV_STATUS_SRV )
    {
      QM_MSG_HIGH("Generating current_plmn_name indication for second stack info");
      send_sec = qmi_nas_populate_current_plmn_name_ind( ind_msg_sec_stack, p_ss_info, STACK_INDEX_1, FALSE, session );
    }
    else
    {
      qmi_nasi_global.current_plmn_name_cache_sec_stack.current_plmn_valid = FALSE;
    }
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( send_main || send_sec )
  {
    for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
    {
      cl_sp = qmi_nas_state.client[clid];

      if ( cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED )
      {
        QM_MSG_LOW_2(" id %d, ignore %d", clid, cl_sp->report_status.ignore_plmn_display_cond_in_ind);
      }

      if ( cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
           cl_sp->report_status.report_current_plmn_name &&
           (cl_sp->report_status.bound_subs == (enum qmi_nas_subs_e)p_ss_info->asubs_id) &&
           !(cl_sp->report_status.ignore_plmn_display_cond_in_ind || qm_efs_always_return_plmn()) )
      {
        if ( send_main )
        {
          ind = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_INDICATION,
                                                    (uint16_t)QMI_NAS_CURRENT_PLMN_NAME_IND_V01,
                                                    (void *) ind_msg,
                                                    (uint32_t)sizeof(nas_current_plmn_name_ind_msg_v01),
                                                    &ind
                                                  ) )
          {
            qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_CURRENT_PLMN_NAME_IND, ind );
          }
          else
          {
            QM_MSG_ERROR_1("problem writing indication main stack %d", clid);
          }
        }
        if ( send_sec )
        {
          ind_sec = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_INDICATION,
                                                    (uint16_t)QMI_NAS_CURRENT_PLMN_NAME_IND_V01,
                                                    (void *) ind_msg_sec_stack,
                                                    (uint32_t)sizeof(nas_current_plmn_name_ind_msg_v01),
                                                    &ind_sec
                                                  ) )
          {
            qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_CURRENT_PLMN_NAME_IND, ind_sec );
          }
          else
  {
            QM_MSG_ERROR_1("problem writing indication sec stack %d", clid);
          }
  }
      }
    }
  }

  // reset for ignoring display condition
  send_main = send_sec = FALSE;

  if ( ind_msg != NULL )
  {
    memset( ind_msg, 0x00, sizeof( nas_current_plmn_name_ind_msg_v01 ) );

    if ( p_ss_info->stack_info[STACK_INDEX_0].srv_status == SYS_SRV_STATUS_SRV )
    {
      QM_MSG_HIGH("Generating current_plmn_name indication, ignoring disp condition");
      send_main = qmi_nas_populate_current_plmn_name_ind( ind_msg, p_ss_info, STACK_INDEX_0, TRUE, session );
            }
            else
            {
      qmi_nasi_global.current_plmn_name_cache.current_plmn_valid = FALSE;
          }
        }
  else
  {
    /*Not enough memory to allocate QMI_NAS_CURRENT_PLMN_NAME_IND buffer for main stack*/
     qmi_voice_mem_error();
      }

  if ( ind_msg_sec_stack != NULL )
  {
    memset( ind_msg_sec_stack, 0x00, sizeof( nas_current_plmn_name_ind_msg_v01 ) );

    if ( p_ss_info->number_of_stacks > 1 &&
         p_ss_info->stack_info[STACK_INDEX_1].srv_status == SYS_SRV_STATUS_SRV )
    {
      QM_MSG_HIGH("Generating current_plmn_name indication for second stack info, ignoring disp conditon");
      send_sec = qmi_nas_populate_current_plmn_name_ind( ind_msg_sec_stack, p_ss_info, STACK_INDEX_1, TRUE, session );
    }
    else
    {
      qmi_nasi_global.current_plmn_name_cache_sec_stack.current_plmn_valid = FALSE;
    }
  }
  else
  {
    /*Not enough memory to allocate QMI_NAS_CURRENT_PLMN_NAME_IND buffer for sec stack*/
     qmi_voice_mem_error();
  }

  if ( send_main || send_sec )
  {
    for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
    {
      cl_sp = qmi_nas_state.client[clid];

      if ( cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
           cl_sp->report_status.report_current_plmn_name &&
           (cl_sp->report_status.bound_subs == (enum qmi_nas_subs_e)p_ss_info->asubs_id) &&
           (cl_sp->report_status.ignore_plmn_display_cond_in_ind || qm_efs_always_return_plmn()) )
      {
        if ( send_main )
        {
          ind = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_INDICATION,
                                                    (uint16_t)QMI_NAS_CURRENT_PLMN_NAME_IND_V01,
                                                    (void *) ind_msg,
                                                    (uint32_t)sizeof(nas_current_plmn_name_ind_msg_v01),
                                                    &ind
                                                  ) )
          {
            qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_CURRENT_PLMN_NAME_IND, ind );
          }
          else
          {
            QM_MSG_ERROR_1("problem writing indication main stack %d", clid);
          }
        }
        if ( send_sec )
        {
          ind_sec = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_INDICATION,
                                                    (uint16_t)QMI_NAS_CURRENT_PLMN_NAME_IND_V01,
                                                    (void *) ind_msg_sec_stack,
                                                    (uint32_t)sizeof(nas_current_plmn_name_ind_msg_v01),
                                                    &ind_sec
                                                  ) )
          {
            qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_CURRENT_PLMN_NAME_IND, ind_sec );
          }
          else
          {
            QM_MSG_ERROR_1("problem writing indication sec stack %d", clid);
          }
        }
      }
    }
  }

  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( ind_msg_sec_stack != NULL ) { modem_mem_free( (void *) ind_msg_sec_stack, MODEM_MEM_CLIENT_QMI_MMODE ); }
}

/*===========================================================================
  FUNCTION QMI_NAS_POPULATE_CURRENT_PLMN_NAME_IND()

  DESCRIPTION
    Populates a current plmn name indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_populate_current_plmn_name_ind(
  nas_current_plmn_name_ind_msg_v01 *ind_msg,
  cm_mm_msim_ss_info_s_type         *p_ss_info,
  uint8                              stack_idx,
  boolean                            ign_disp,
  mmgsdi_session_type_enum_type      session
)
{
  sys_plmn_id_s_type          plmn;
  sys_mcc_type                mcc;
  sys_mnc_type                mnc;
  boolean                     plmn_undefined, plmn_includes_pcs_digit_ptr;
  mmgsdi_rat_enum_type        rat            = qmi_nas_rat_cm_mode_to_mmgsdi(p_ss_info->stack_info[stack_idx].sys_mode);
  sys_sys_id_s_type           sys_id         = p_ss_info->stack_info[stack_idx].sys_id;
  sys_mm_information_s_type   mm_information = p_ss_info->stack_info[stack_idx].mode_info.gw_info.mm_information;
  sys_lac_type                lac            = p_ss_info->stack_info[stack_idx].sys_mode == SYS_SYS_MODE_LTE ? p_ss_info->stack_info[stack_idx].rat_mode_info.lte_mode_info.tac
                                                                                                             : qmi_nas_get_lac( p_ss_info, stack_idx );
  mmgsdi_eons_evt_info_type  *eons;
  struct current_plmn_name_s *cache          = ign_disp ? &qmi_nasi_global.current_plmn_name_cache_ignore : &qmi_nasi_global.current_plmn_name_cache;
  sys_csg_id_type             csg_id         = qm_util_retrieve_csg_id(p_ss_info, stack_idx);
  uint16 buff_ptr[(NASI_MAX_LEN_NETWORK_NAME/2)];
  int i = 0;
  size_t temp_len = 0;
  uint8 tmp_buf[NAS_ALT_LANG_NAME_LEN_MAX_V01*2] = { 0 };

  // LTE on Nikel
  if( stack_idx == STACK_INDEX_1 )
  {
    cache = ign_disp ? &qmi_nasi_global.current_plmn_name_cache_sec_stack_ignore : &qmi_nasi_global.current_plmn_name_cache_sec_stack;
  }

  plmn = mm_information.plmn_avail ? mm_information.plmn : sys_id.id.plmn;

  QM_MSG_HIGH_3("Retrieving name for %d %d %d", plmn.identity[0], plmn.identity[1], plmn.identity[2]);
  
  if( (eons = qmi_nas_nw_name_find( session, plmn, lac, rat, csg_id )) != NULL )
  {
    mmgsdi_eons_per_stack_evt_info_type *plmn_name = &eons->first_stack_info;
    enum qmi_nas_stack_e eons_info_stack = qmi_nas_nw_name_info_stack( eons, plmn, lac, rat, csg_id );
    QM_MSG_HIGH_3("Using stack %d, stack validity %d, %d", eons_info_stack, eons->first_stack_info.is_valid, eons->sec_stack_info.is_valid);
    if ( eons_info_stack == QMI_NAS_STACK_MAIN )
    {
      plmn_name = &eons->first_stack_info;
    }
    else if ( eons_info_stack == QMI_NAS_STACK_GW_HYB )
    {
      plmn_name = &eons->sec_stack_info;
    }
    else
    {
      QM_MSG_ERROR("EONS information provided did not match requested info");
      return FALSE;
    }

    QM_MSG_HIGH_7("SPN len=%d, short len=%d, long len=%d, Encoding: SPN = %d, short = %d, long = %d, Add names: %d", 
	eons->spn.eons_data.data_len, plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_len, plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_len,
	eons->spn.eons_encoding, plmn_name->operator_info.plmn_short_name.plmn_name.eons_encoding, plmn_name->operator_info.plmn_long_name.plmn_name.eons_encoding,
	plmn_name->operator_info.num_plmn_additional_names);
  
    qm_util_print_bytes( eons->spn.eons_data.data_ptr, eons->spn.eons_data.data_len );
    qm_util_print_bytes( plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_ptr, 
                         plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_len );
    qm_util_print_bytes( plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_ptr, 
                         plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_len );
  
    // Check if newly in service, or compare previous sent message
    if ( cache->current_plmn_valid == FALSE ||
         memcmp( &cache->plmn, &plmn, sizeof(plmn) ) ||
         qmi_nas_is_different_from_last_sent_name( eons, plmn_name, stack_idx, ign_disp ) )
    {
      memscpy( &cache->plmn, sizeof(plmn), &plmn, sizeof(plmn));
      memscpy( &cache->srv_prov_name, sizeof(eons->spn), &eons->spn, sizeof(eons->spn));
      memscpy( &cache->plmn_short_name, sizeof(plmn_name->operator_info.plmn_short_name), &plmn_name->operator_info.plmn_short_name, sizeof(plmn_name->operator_info.plmn_short_name));
      memscpy( &cache->plmn_long_name, sizeof(plmn_name->operator_info.plmn_long_name), &plmn_name->operator_info.plmn_long_name, sizeof(plmn_name->operator_info.plmn_long_name));
      cache->current_plmn_valid = TRUE;

      ind_msg->plmn_id_valid = TRUE;
      sys_plmn_get_mcc_mnc( plmn, &plmn_undefined, &plmn_includes_pcs_digit_ptr, &mcc, &mnc );
      ind_msg->plmn_id.mcc = (uint16) mcc;
      ind_msg->plmn_id.mnc = (uint16) mnc;
      ind_msg->plmn_id.mnc_includes_pcs_digit = plmn_includes_pcs_digit_ptr;

      ind_msg->spn_valid = TRUE;
      ind_msg->spn_ext_valid = TRUE;
      if ( ign_disp || eons->display_spn )
      {
        if( eons->spn.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          ind_msg->spn.spn_enc = NAS_CODING_SCHEME_UCS2_V01;
          ind_msg->spn.spn_len = 2*qm_util_decode_ucs2_80_81_82_encoding( eons->spn.eons_data.data_ptr,
                                                                          eons->spn.eons_data.data_len,
                                                                          buff_ptr,
                                                                          NAS_SPN_LEN_MAX_V01/2 );
          memscpy( (void*)ind_msg->spn.spn, NAS_SPN_LEN_MAX_V01, (void*)buff_ptr, ind_msg->spn.spn_len );
          
          //UCS2 encoding directly maps to UTF16 in the range 0x0000-0xFFFF.
          temp_len = qm_util_decode_ucs2_80_81_82_encoding( eons->spn.eons_data.data_ptr,
                                                            eons->spn.eons_data.data_len,
                                                            buff_ptr,
                                                            NAS_SPN_EXT_LEN_MAX_V01/2 );
          memscpy((void*)ind_msg->spn_ext, NAS_SPN_EXT_LEN_MAX_V01, (void*)buff_ptr, 2*temp_len);
        }
        else if ( eons->spn.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
        {
          ind_msg->spn.spn_enc = NAS_CODING_SCHEME_UCS2_V01; 
          ind_msg->spn.spn_len = eons->spn.eons_data.data_len;
          memscpy( (void*)ind_msg->spn.spn, NAS_SPN_LEN_MAX_V01, (void*)eons->spn.eons_data.data_ptr, eons->spn.eons_data.data_len);
          
          //UCS2 encoding directly maps to UTF16 in the range 0x0000-0xFFFF.
          temp_len = eons->spn.eons_data.data_len/2;
          memscpy( (void*)ind_msg->spn_ext, NAS_SPN_EXT_LEN_MAX_V01, (void*)eons->spn.eons_data.data_ptr, 2*temp_len);
        }
        else
        {
          ind_msg->spn.spn_enc = NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01;
          ind_msg->spn.spn_len = eons->spn.eons_data.data_len;
          memscpy( ind_msg->spn.spn, eons->spn.eons_data.data_len, eons->spn.eons_data.data_ptr, eons->spn.eons_data.data_len);
          
          qm_util_gsm7_to_utf16( eons->spn.eons_data.data_ptr, 
                                 eons->spn.eons_data.data_len,
                                 FALSE,
                                 ind_msg->spn_ext,
                                 NAS_SPN_EXT_LEN_MAX_V01,
                                 &temp_len);
        }
        QM_MSG_HIGH_5("spn_valid=%d, spn_enc=%d, spn_len=%d, spn_ext_valid=%d, spn_ext_len=%d", 
			ind_msg->spn_valid, ind_msg->spn.spn_enc, ind_msg->spn.spn_len, ind_msg->spn_ext_valid, temp_len);   
      }
      else
      {
        ind_msg->spn.spn_enc = NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01;
        ind_msg->spn.spn_len = 0;
      }

      if ( ign_disp || plmn_name->display_operator_info )
      {
        if ( plmn_name->operator_info.plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          ind_msg->short_name_valid = TRUE;
          ind_msg->short_name.plmn_name_ci    = plmn_name->operator_info.plmn_short_name.plmn_name_ci;
          ind_msg->short_name.plmn_spare_bits = plmn_name->operator_info.plmn_short_name.plmn_name_spare_bits;
          ind_msg->short_name.plmn_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
          ind_msg->short_name.plmn_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                                         plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_len,
                                                                                         buff_ptr,
                                                                                         NAS_PLMN_NAME_MAX_V01/2 );
          memscpy( (void*)ind_msg->short_name.plmn_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, ind_msg->short_name.plmn_name_len );
        }
        else if( nasi_convert_mm_info_oper_name( 
                 plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_ptr,
                 plmn_name->operator_info.plmn_short_name.plmn_name.eons_encoding,
                 (char *)ind_msg->short_name.plmn_name,
                 (uint8 *)&ind_msg->short_name.plmn_name_enc,
                 NASI_MAX_LEN_NETWORK_NAME,
                 plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_len) )
        {
          ind_msg->short_name_valid = TRUE;
          ind_msg->short_name.plmn_name_ci    = plmn_name->operator_info.plmn_short_name.plmn_name_ci;
          ind_msg->short_name.plmn_spare_bits = plmn_name->operator_info.plmn_short_name.plmn_name_spare_bits;
          if( (ind_msg->short_name.plmn_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
              (plmn_name->operator_info.plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
            )
          {
            ind_msg->short_name.plmn_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, plmn_name->operator_info.plmn_short_name.plmn_name.eons_data.data_len);
          }
          else
          {
            ind_msg->short_name.plmn_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)ind_msg->short_name.plmn_name, NAS_PLMN_NAME_MAX_V01 ));
          }
        }

        if ( plmn_name->operator_info.plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          ind_msg->long_name_valid = TRUE;
          ind_msg->long_name.plmn_name_ci    = plmn_name->operator_info.plmn_long_name.plmn_name_ci;
          ind_msg->long_name.plmn_spare_bits = plmn_name->operator_info.plmn_long_name.plmn_name_spare_bits;
          ind_msg->long_name.plmn_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
          ind_msg->long_name.plmn_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                                        plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_len,
                                                                                        buff_ptr,
                                                                                        NAS_PLMN_NAME_MAX_V01/2 );
          memscpy( (void*)ind_msg->long_name.plmn_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, ind_msg->long_name.plmn_name_len );
        }
        else if( nasi_convert_mm_info_oper_name( 
            plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_ptr,
            plmn_name->operator_info.plmn_long_name.plmn_name.eons_encoding,
            (char *)ind_msg->long_name.plmn_name,
            (uint8 *)&ind_msg->long_name.plmn_name_enc,
              NASI_MAX_LEN_NETWORK_NAME,
            plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_len) )
        {
          ind_msg->long_name_valid = TRUE;
          ind_msg->long_name.plmn_name_ci    = plmn_name->operator_info.plmn_long_name.plmn_name_ci;
          ind_msg->long_name.plmn_spare_bits = plmn_name->operator_info.plmn_long_name.plmn_name_spare_bits;
          if( (ind_msg->long_name.plmn_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
              (plmn_name->operator_info.plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
            )
          {
            ind_msg->long_name.plmn_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, plmn_name->operator_info.plmn_long_name.plmn_name.eons_data.data_len);
          }
          else
          {
            ind_msg->long_name.plmn_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)ind_msg->long_name.plmn_name, NAS_PLMN_NAME_MAX_V01 ));
          }
        }
      }

#ifdef FEATURE_FEMTO_CSG
      if ( qm_efs_csg_supported() )
      {
        if( plmn_name->operator_info.plmn_id.csg_id != SYS_CSG_ID_INVALID )
        {
          ind_msg->csg_id_valid = TRUE;
          ind_msg->csg_id = plmn_name->operator_info.plmn_id.csg_id;
        }
      }
#endif
    
      ind_msg->eons_display_bit_info_valid = TRUE;
      ind_msg->eons_display_bit_info.is_spn_set = qmi_nas_map_display_bit_mmgsdi_to_qmi( (mmgsdi_eons_rplmn_display_bit_enum_type) eons->spn_display_bit );
      ind_msg->eons_display_bit_info.is_plmn_set = qmi_nas_map_display_bit_mmgsdi_to_qmi( eons->rplmn_display_bit );

      ind_msg->is_home_network_valid = TRUE;
      ind_msg->is_home_network = qmi_nas_map_home_status_mmgsdi_to_qmi( plmn_name->roaming_status );
    
      ind_msg->rat_valid = TRUE;
      ind_msg->rat = (nas_radio_if_enum_v01)qmi_nas_rat_mmgsdi_to_qmi(rat);

      if ( plmn_name->operator_info.plmn_additional_info.info_encoding != MMGSDI_EONS_ENC_INVALID ||
           plmn_name->operator_info.plmn_additional_info.info_data.data_len != 0 ||
           plmn_name->operator_info.plmn_additional_info.info_data.data_ptr != NULL )
      {
        if ( plmn_name->operator_info.plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          ind_msg->addl_info_valid = TRUE;
          ind_msg->addl_info_len = qm_util_decode_ucs2_80_81_82_encoding( 
                                     plmn_name->operator_info.plmn_additional_info.info_data.data_ptr,
                                     plmn_name->operator_info.plmn_additional_info.info_data.data_len,
                                     buff_ptr,
                                     NAS_PLMN_NAME_MAX_V01/2 );
          memscpy( (void*)ind_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, ind_msg->addl_info_len*2 );
        }
        else if ( plmn_name->operator_info.plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2 )
        {
          ind_msg->addl_info_valid = TRUE;
          ind_msg->addl_info_len = plmn_name->operator_info.plmn_additional_info.info_data.data_len/2;
          memscpy( (void*)ind_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)plmn_name->operator_info.plmn_additional_info.info_data.data_ptr, plmn_name->operator_info.plmn_additional_info.info_data.data_len);
          convert_endianness16( (unsigned char*)ind_msg->addl_info, plmn_name->operator_info.plmn_additional_info.info_data.data_len );
        }
        else if ( plmn_name->operator_info.plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED )
        {
          if( !cm_util_gsm7_to_utf16( plmn_name->operator_info.plmn_additional_info.info_data.data_ptr, 
                                      plmn_name->operator_info.plmn_additional_info.info_data.data_len,
                                      FALSE,
                                      ind_msg->addl_info,
                                      NAS_PLMN_NAME_MAX_V01,
                                      (size_t *)&ind_msg->addl_info_len ) )
          {
            ind_msg->addl_info_valid = TRUE;
          }
        }
      }

      ind_msg->nw_name_source_valid = TRUE;
      ind_msg->nw_name_source = qmi_nas_map_nw_name_source_mmgsdi_to_qmi( plmn_name->operator_info.plmn_name_source );

      if ( plmn_name->operator_info.num_plmn_additional_names > 0 )
      {
        ind_msg->lang_plmn_names_valid = TRUE;
        ind_msg->lang_plmn_names_len = MIN(MMGSDI_ADDITIONAL_NAMES_MAX, plmn_name->operator_info.num_plmn_additional_names);
        for ( i = 0; i < ind_msg->lang_plmn_names_len; i++ )
        {
          ind_msg->lang_plmn_names[i].lang_id = qmi_nas_map_lang_id_mmgsdi_to_qmi(plmn_name->operator_info.plmn_additional_names[i].plmn_lang);

          if ( plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
          {
            ind_msg->lang_plmn_names[i].plmn_long_name_len = qm_util_decode_ucs2_80_81_82_encoding( plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                               plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len,
                                                               ind_msg->lang_plmn_names[i].plmn_long_name,
                                                               NAS_ALT_LANG_NAME_LEN_MAX_V01 );
          }
          else if ( plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
          {
            memscpy( tmp_buf, 
                     NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                     plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr, 
                     plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
            convert_endianness16( tmp_buf, 
                                  plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
            memscpy( ind_msg->lang_plmn_names[i].plmn_long_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
            ind_msg->lang_plmn_names[i].plmn_long_name_len = plmn_name->operator_info.plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len/2;
          }

          if ( plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
          {
            ind_msg->lang_plmn_names[i].plmn_short_name_len = qm_util_decode_ucs2_80_81_82_encoding( plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                               plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len,
                                                               ind_msg->lang_plmn_names[i].plmn_short_name,
                                                               NAS_ALT_LANG_NAME_LEN_MAX_V01 );
          }
          else if ( plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
          {
            memscpy( tmp_buf, 
                     NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                     plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr, 
                     plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
            convert_endianness16( tmp_buf, 
                                  plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
            memscpy( ind_msg->lang_plmn_names[i].plmn_short_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
            ind_msg->lang_plmn_names[i].plmn_short_name_len = plmn_name->operator_info.plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len/2;
          }
        }
      }
    }
  }
  
  return ind_msg->plmn_id_valid;
}

/*===========================================================================
  FUNCTION QMI_NASI_CONFIG_EMBMS()

  DESCRIPTION
    Message to request UE to enable/disable eMBMS

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_config_embms
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type               *response = NULL;
  qmi_error_e_type             errval    = QMI_ERR_NONE;
  struct nas_0062_req_s        req_msg;
  struct nas_0062_rsp_s        rsp_msg;
  errno_enum_type              msgr_err;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
    {
    errval = qmi_nas_0062_req_read( &req_msg, sdu_in );
    }

  if ( errval == QMI_ERR_NONE )
    {
    errval = qmi_nas_0062_req_check( &req_msg );
    }

  if ( errval == QMI_ERR_NONE )
  {
    if ( req_msg.t01.enable )
    {
      lte_rrc_embms_enable_req_s msg;

      msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_EMBMS_ENABLE_REQ );

      msg.debug_trace_id = req_msg.t10_valid ? req_msg.t10.trace_id : -1;

      msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
    }
    else
    {
      lte_rrc_embms_disable_req_s msg;

      msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_EMBMS_DISABLE_REQ );

      msg.debug_trace_id = req_msg.t10_valid ? req_msg.t10.trace_id : -1;

      msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
    }

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR_1("LTE_RRC_EMBMS_ENABLE/DISABLE_REQ send fail %d", msgr_err);
    }
  }

  memset(&rsp_msg, 0, sizeof(rsp_msg));

  rsp_msg.t02.result_code = errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( rsp_msg.t02.result_code == QMI_ERR_NONE )
  {
    rsp_msg.t10.trace_id = req_msg.t10.trace_id;
    rsp_msg.t10_valid    = TRUE;
  }

  if ( qmi_nas_0062_rsp_write ( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
}

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_EMBMS_STATUS()

  DESCRIPTION
    Message to query eMBMS status

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_embms_status
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type               *response = NULL;
  qmi_error_e_type             errval    = QMI_ERR_NONE;
  nas_get_embms_status_resp_msg_v01 *rsp_msg;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
  }

  
  rsp_msg = (nas_get_embms_status_resp_msg_v01 *) 
  	modem_mem_alloc( sizeof(nas_get_embms_status_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    return NULL;
  }

  memset(rsp_msg, 0, sizeof(nas_get_embms_status_resp_msg_v01));

#ifdef FEATURE_LTE_EMBMS
  if ( errval == QMI_ERR_NONE )
    {
    rsp_msg->enabled = qmi_nasi_global.embms_status;
    rsp_msg->enabled_valid= TRUE;

    rsp_msg->trace_id = qmi_nasi_global.trace_id;
    rsp_msg->trace_id_valid    = TRUE;
    }
#else
  if( errval == QMI_ERR_NONE )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }
#endif

  if (cmd_buf_p != NULL)
  {
    rsp_msg->resp.result  = errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_embms_status_resp_msg_v01),
                                  &response
                                );
  }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
  }

/*========================================================================
  FUNCTION qmi_nas_msgr_handler

  DESCRIPTION
    process messages received from msgr

  PARAMETERS
    msg pointer in *void. cast to qmi_mmodei_msgr_type before use.
    *void type is to avoid circular reference of headers

  RETURN VALUE
    None
===========================================================================*/
void qmi_nas_msgr_handler( void *param )
{
  qmi_nasi_client_state_type *cl_sp;
#ifdef FEATURE_LTE
#ifdef FEATURE_LTE_EMBMS
  int                         clid;
  struct nas_0064_ind_s       ind_msg;
  dsm_item_type              *ind;
#endif
#endif
  qmi_mmodei_msgr_type       *msg;
  
  ASSERT( param );

  msg = (qmi_mmodei_msgr_type*)param;

  switch ( msg->cmd.hdr.id )
  {
    case MM_CM_MANUAL_SCAN_FAIL_IND:
      QM_MSG_HIGH("MM_CM_MANUAL_SCAN_FAIL_IND");
      qmi_nasi_generate_manual_scan_fail_ind(INST_ID_TO_SYS_AS_ID(msg->cmd.hdr.inst_id));
      break;
   case MM_CM_SET_RPM_PARAMETERS_RSP:
      QM_MSG_HIGH_1("MM_CM_SET_RPM_PARAMETERS_RSP %d", msg->cmd.qmi_nas.set_rpm_parameters_resp.rpm_rsp_ret_val);
      qmi_nasi_generate_set_rpm_parameters_2_rsp( msg );
      break;
    case MM_CM_GET_RPM_PARAMETERS_RSP:
      QM_MSG_HIGH_3("MM_CM_GET_RPM_PARAMETERS_RSP %d %d %d", msg->cmd.qmi_nas.get_rpm_parameters_resp.rpm_rsp_ret_val, msg->cmd.qmi_nas.get_rpm_parameters_resp.lte_rpm_params.max_event_counter, msg->cmd.qmi_nas.get_rpm_parameters_resp.lte_rpm_params.max_event_timer);
      qmi_nasi_generate_get_rpm_parameters_rsp( msg );
      break;
   case GERAN_GRR_MTC_CFG_RSP: 
      QM_MSG_HIGH_1("GERAN_GRR_MTC_CFG_RSP(drx scaling factor) %d", msg->cmd.qmi_nas.drx_scaling_resp_grr.status);
      qmi_nasi_generate_set_drx_scaling_factor_rsp( msg->cmd.qmi_nas.drx_scaling_resp_grr.status );
      break;
#ifdef FEATURE_WCDMA
   case WCDMA_RRC_QMI_MTC_CFG_RSP: 
      QM_MSG_HIGH_1("WCDMA_RRC_QMI_MTC_CFG_CNF(drx scaling factor) %d", msg->cmd.qmi_nas.drx_scaling_resp_wrrc.status);
      qmi_nasi_generate_set_drx_scaling_factor_rsp( msg->cmd.qmi_nas.drx_scaling_resp_wrrc.status );
      break;
#endif
#ifdef FEATURE_LTE
    case LTE_RRC_MTC_CFG_CNF:
      QM_MSG_HIGH_1("LTE_RRC_MTC_CFG_CNF(drx scaling factor) %d", msg->cmd.qmi_nas.drx_scaling_resp.status);
      qmi_nasi_generate_set_drx_scaling_factor_rsp( msg->cmd.qmi_nas.drx_scaling_resp.status );
      break;
#ifdef FEATURE_LTE_EMBMS
    case LTE_RRC_EMBMS_STATUS_CHANGE_IND:
      QM_MSG_HIGH_1("LTE_RRC_EMBMS_STATUS_CHANGE_IND %d", msg->cmd.qmi_nas.embms_status_change_ind.enabled_status);
      ind_msg.t01.enabled = qmi_nasi_global.embms_status = msg->cmd.qmi_nas.embms_status_change_ind.enabled_status;
      ind_msg.t01_valid   = TRUE;
      ind_msg.t10.trace_id = qmi_nasi_global.trace_id = msg->cmd.qmi_nas.embms_status_change_ind.debug_trace_id;
      ind_msg.t10_valid    = TRUE;

      for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
  {
        cl_sp = qmi_nas_state.client[clid];
        if (  cl_sp != NULL &&
              cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
              cl_sp->report_status.report_embms_status &&
              cl_sp->report_status.bound_subs == QMI_NAS_SUBS_PRIMARY ) // LTE can't be 2nd subscription yet
    {
          ind = NULL;

          if ( qmi_nas_0064_ind_write ( &ind_msg, &ind ) == QMI_ERR_NONE )
          {
            (void)qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_EMBMS_STATUS_IND, ind );
    }
    else
    {
            QM_MSG_ERROR_1("problem writing indication %d ", clid);
          }
    }
  }
      break;
#endif   //FEATURE_LTE_EMBMS
    case LTE_CPHY_CA_EVENT_IND:
      QM_MSG_HIGH("Received indication LTE_CPHY_CA_EVENT_IND for CA Event");
      qmi_nas_generate_lte_cphy_ca_ind(&msg->cmd.qmi_nas.cphy_ca_event_ind);
      break;

  case LTE_RRC_EMBMS_SIGNAL_STRENGTH_CNF:
    QM_MSG_HIGH("Received response LTE_RRC_EMBMS_SIGNAL_STRENGTH_CNF for QMI_NAS_GET_EMBMS_SIG and QMI_NAS_GET_EMBMS_SIG_EXT");
      qmi_nasi_generate_get_embms_sig_rsp( msg );
      qmi_nasi_generate_get_embms_sig_ext_rsp( msg );
      break;

    case LTE_RRC_UTC_TIME_UPDATE_IND:
      QM_MSG_HIGH("Received response LTE_RRC_UTC_TIME_UPDATE_IND for LTE_SIB16_NETWORK_TIME");
      qmi_nas_update_lte_sib16_network_time_cache(&msg->cmd.qmi_nas.lte_sib16_nw_time);
      qmi_nas_generate_lte_sib16_network_time_ind();
      break;
#endif  //FEATURE_LTE
#ifdef FEATURE_TDSCDMA
    case TDSCDMA_RRC_GPS_POS_CELL_INFO_RSP:
      qmi_nasi_generate_get_tds_cell_and_position_info_rsp( msg );
      break;

    case TDSCDMA_RRC_SCELL_SIGNAL_STATUS_IND:
      QM_MSG_HIGH("Received TDSCDMA_RRC_SCELL_SIGNAL_STATUS_IND");    
      qm_meas_process_tds_measurement_info( &msg->cmd.qmi_nas.tds_rrc_scell_sig_ind );
      break;
#endif
    case MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_CHANGED_IND:
      QM_MSG_HIGH("MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_CHANGE_IND");
      qmi_nas_gen_ims_pref_status_ind( &msg->cmd.qmi_nas.ims_pref_chg_ind.data );
      break;

    case MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_GET_EXT_RSP:
      QM_MSG_HIGH("MM_DOM_SEL_DOMAIN_SELECTED_LTE_IMS_PREF_GET_EXT_RSP");
      qmi_nas_generate_get_ims_pref_resp( &msg->cmd.qmi_nas.ims_pref_rsp );
      break;

    case MM_CM_AC_EMERGENCY_ENTER_IND:
      QM_MSG_HIGH("received MM_CM_AC_EMERGENCY_ENTER_IND for e911 state enter");
      qmi_nasi_generate_set_e911_state_resp( &msg->cmd.qmi_nas.e911_state_ind );
      break;

    case MM_CM_AC_EMERGENCY_READY_IND:
      QM_MSG_HIGH("received MM_CM_AC_EMERGENCY_READY_IND for e911 state ready");
      qmi_nasi_generate_e911_state_ready_ind( &msg->cmd.qmi_nas.e911_state_ind );
      break;

    case MM_CM_AC_EMERGENCY_EXIT_IND:
      QM_MSG_HIGH("received MM_CM_AC_EMERGENCY_EXIT_IND for e911 state exit");
      qmi_nasi_generate_set_e911_state_resp( &msg->cmd.qmi_nas.e911_state_ind );
      break;

    case MM_CM_SUBSC_CHGND_IND:
      QM_MSG_HIGH("received MM_CM_SUBSC_CHGND_IND");
      qmi_nasi_generate_subscription_change_ind( &msg->cmd.qmi_nas.subscription_change_ind );
      break;
#ifdef FEATURE_LTE
    case LTE_RRC_BAND_PRI_CHANGE_CNF:
      QM_MSG_HIGH("received LTE_RRC_BAND_PRI_CHANGE_CNF for set_lte_band_priority");
      qmi_nasi_generate_set_lte_band_priority_resp( &msg->cmd.qmi_nas.lte_band_pri_cnf );
      break;
        
    case LTE_RRC_GET_BAND_PRI_LIST_CNF:
      QM_MSG_HIGH("received LTE_RRC_GET_BAND_PRI_LIST_CNF for get_lte_band_priority_list");
      qmi_nasi_generate_get_lte_band_priority_list_resp( &msg->cmd.qmi_nas.lte_get_band_pri_list_cnf );
      break;

    case LTE_RRC_DEACTIVATE_CNF:
      QM_MSG_HIGH( "received LTE_RRC_DEACTIVATE_CNF");
      {
        lte_rrc_ac_barring_info_s lte_rrc_ac_barring_info_temp = {0};

        lte_rrc_ac_barring_info_temp.ac_barring_for_emergency_present = FALSE;
        lte_rrc_ac_barring_info_temp.ac_barring_MO_data_present          = FALSE;
        lte_rrc_ac_barring_info_temp.ac_barring_MO_signalling_present   = FALSE;
        
        qmi_nasi_acb_info_ind( &lte_rrc_ac_barring_info_temp );
        //Copying into cache
        qmi_nasi_global.lte_rrc_ac_barring_info_cache = lte_rrc_ac_barring_info_temp;
      }
      break;

    case LTE_RRC_BARRING_UPDATE_IND:
      QM_MSG_HIGH( "received LTE_RRC_BARRING_UPDATE_IND");
      qmi_nasi_ssac_info_ind( &msg->cmd.qmi_nas.lte_barring_ind.ssac_params );
      qmi_nasi_acb_info_ind( &msg->cmd.qmi_nas.lte_barring_ind.ac_barring_info );
      qmi_nasi_ssac_change_info_ind( &msg->cmd.qmi_nas.lte_barring_ind.ssac_params );
	  
      memscpy( &qmi_nasi_global.lte_rrc_ac_barring_info_cache, sizeof(lte_rrc_ac_barring_info_s), &msg->cmd.qmi_nas.lte_barring_ind.ac_barring_info, sizeof(lte_rrc_ac_barring_info_s) );
      memscpy( &qmi_nasi_ssac_info.ssac_cache, sizeof(lte_rrc_ssac_params_s), &msg->cmd.qmi_nas.lte_barring_ind.ssac_params, sizeof(lte_rrc_ssac_params_s) );
      qmi_nasi_ssac_info.is_valid = TRUE;
      break;

      case LTE_RRC_GET_SERV_CELL_SIB_CNF:
      QM_MSG_HIGH_1("Received LTE_RRC_GET_SERV_CELL_SIB_CNF: status = %d", msg->cmd.qmi_nas.lte_get_serv_cell_sib_cnf.status);
      cl_sp = qmi_nasi_get_cl_sp_by_cmd_buf(qmi_nasi_global.get_serv_cell_sib);
      if(cl_sp)
      {
        qmi_nasi_generate_get_serving_cell_sib_resp(&msg->cmd.qmi_nas.lte_get_serv_cell_sib_cnf);
        if(msg->cmd.qmi_nas.lte_get_serv_cell_sib_cnf.status == LTE_RRC_GET_SIB_SUCCESS)
        {
          qmi_nasi_generate_get_serving_cell_sib_ind(&msg->cmd.qmi_nas.lte_get_serv_cell_sib_cnf, cl_sp);
        }
      }
      else
      {
        QM_MSG_MED("NULL cl_sp for LTE_RRC_GET_SERV_CELL_SIB_CNF; no response or indication will be sent.");
      }
      break;
#endif
    case NAS_EMM_T3402_CHANGED_IND:
      QM_MSG_HIGH_1( "received NAS_EMM_T3402_CHANGED_IND, value=%d", msg->cmd.qmi_nas.emm_t3402_changed_ind.t3402_value);
      qmi_nasi_gen_emm_t3402_changed_ind( &msg->cmd.qmi_nas.emm_t3402_changed_ind );
      break;

    case MM_CM_T3346_INFO_IND:
      QM_MSG_HIGH_3("Received MM_CM_T3346_INFO_IND subs: %d rat: %d status: %d", msg->cmd.qmi_nas.t3346_timer_status_change.as_id, msg->cmd.qmi_nas.t3346_timer_status_change.active_rat, msg->cmd.qmi_nas.t3346_timer_status_change.timer_status);
      qmi_nasi_generate_t3346_timer_status_change_ind( msg );
      break;

    case MM_CM_CALL_MODE_IND  :
      QM_MSG_HIGH_2("Received MM_CM_CALL_MODE_IND call_mode: %d subs: %d", msg->cmd.qmi_nas.call_mode_msg.call_mode, msg->cmd.qmi_nas.call_mode_msg.as_id);
      qmi_nasi_generate_call_mode_ind( msg );
      break;

    case LTE_RRC_CELL_LOCK_RSP:
      QM_MSG_HIGH_1("LTE_RRC_CELL_LOCK_RSP, status:%d", msg->cmd.qmi_nas.set_cell_lock_config_resp.status);
      qmi_nasi_set_cell_lock_config_resp( msg->cmd.qmi_nas.set_cell_lock_config_resp.status );
      break;

    case GERAN_GRR_QMI_CELL_INFO_IND:
        QM_MSG_HIGH( "received GCELL Info IND");
        qmi_nasi_gcell_info_ind(&msg->cmd.qmi_nas.geran_cell_info_ind);
		break;

    case GERAN_GRR_QMI_CELL_INFO_RSP:
        QM_MSG_HIGH( "received GCELL Info Response");
        qmi_nasi_generate_gcell_info_resp(&msg->cmd.qmi_nas.geran_cell_info_rsp);
		break;
    default:
      QM_MSG_HIGH_1("not a QMI_NAS handled msg %d", msg->cmd.hdr.id);
      break;
    }
  }

/*========================================================================
  FUNCTION qmi_nas_msgr_register

  DESCRIPTION
    register to msgr messages

  PARAMETERS
    msgr client object pointer

  RETURN VALUE
    None
===========================================================================*/
void qmi_nas_msgr_register( msgr_client_t *msgr_client )
{
  errno_enum_type err;

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_SET_RPM_PARAMETERS_RSP );
  QM_MSG_HIGH_1("MM_CM_SET_RPM_PARAMETERS_RSP register ret %d", err);
  ASSERT( err == E_SUCCESS );
  
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_GET_RPM_PARAMETERS_RSP );
  QM_MSG_HIGH_1("MM_CM_GET_RPM_PARAMETERS_RSP register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_MANUAL_SCAN_FAIL_IND );
  QM_MSG_HIGH_1("MM_CM_MANUAL_SCAN_FAIL_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_MTC_CFG_REQ );
  QM_MSG_HIGH_1("LTE_RRC_MTC_CFG_REQ register ret %d", err);
  ASSERT( err == E_SUCCESS );
  
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_MTC_CFG_CNF );
  QM_MSG_HIGH_1("LTE_RRC_MTC_CFG_CNF register ret %d", err);
  ASSERT( err == E_SUCCESS );
  
#ifdef FEATURE_WCDMA
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, WCDMA_RRC_QMI_MTC_CFG_RSP );
  QM_MSG_HIGH_1("WCDMA_RRC_QMI_MTC_CFG_RSP register ret %d", err);
  ASSERT( err == E_SUCCESS );
#endif

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, GERAN_GRR_MTC_CFG_RSP );
  QM_MSG_HIGH_1("GERAN_GRR_MTC_CFG_RSP register ret %d", err);
  ASSERT( err == E_SUCCESS );
  
#ifdef FEATURE_LTE_EMBMS
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_EMBMS_STATUS_CHANGE_IND );
  QM_MSG_HIGH_1("LTE_RRC_EMBMS_STATUS_CHANGE_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );
#endif


  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_CPHY_CA_EVENT_IND );
  QM_MSG_HIGH_1("LTE_CPHY_CA_EVENT_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_UTC_TIME_UPDATE_IND );
  QM_MSG_HIGH_1("LTE_RRC_UTC_TIME_UPDATE_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_EMBMS_SIGNAL_STRENGTH_CNF );
  QM_MSG_HIGH_1("LTE_RRC_EMBMS_SIGNAL_STRENGTH_CNF register ret %d", err);
  ASSERT( err == E_SUCCESS );

#ifdef FEATURE_TDSCDMA
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, TDSCDMA_RRC_GPS_POS_CELL_INFO_RSP);
  QM_MSG_HIGH_1("TDSCDMA_RRC_GPS_POS_CELL_INFO_RSP register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, TDSCDMA_RRC_SCELL_SIGNAL_STATUS_IND );
  QM_MSG_HIGH_1("TDSCDMA_RRC_SCELL_SIGNAL_STATUS_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );
#endif

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_CHANGED_IND );
  QM_MSG_HIGH_1("MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_CHANGE_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_GET_EXT_RSP );
  QM_MSG_HIGH_1("MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_GET_EXT_RSP register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_AC_EMERGENCY_ENTER_REQ );
  QM_MSG_HIGH_1("MM_CM_AC_EMERGENCY_ENTER_REQ register ret %d", err);
  ASSERT( err == E_SUCCESS );
  
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_AC_EMERGENCY_ENTER_IND );
  QM_MSG_HIGH_1("MM_CM_AC_EMERGENCY_ENTER_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );
  
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_AC_EMERGENCY_READY_IND );
  QM_MSG_HIGH_1("MM_CM_AC_EMERGENCY_READY_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );
  
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_AC_EMERGENCY_EXIT_REQ );
  QM_MSG_HIGH_1("MM_CM_AC_EMERGENCY_EXIT_REQ register ret %d", err);
  ASSERT( err == E_SUCCESS );
  
  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_AC_EMERGENCY_EXIT_IND );
  QM_MSG_HIGH_1("MM_CM_AC_EMERGENCY_EXIT_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_BAND_PRI_CHANGE_CNF );
  QM_MSG_HIGH_1("LTE_RRC_BAND_PRI_CHANGE_CNF register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_GET_BAND_PRI_LIST_CNF );
  QM_MSG_HIGH_1("LTE_RRC_GET_BAND_PRI_LIST_CNF register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_SUBSC_CHGND_IND );
  QM_MSG_HIGH_1("MM_CM_SUBSC_CHGND_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register(MSGR_QMI_NAS,msgr_client,MSGR_ID_REX,LTE_RRC_DEACTIVATE_CNF);
  QM_MSG_HIGH_1( "LTE_RRC_DEACTIVATE_CNF register ret %d", err );
  ASSERT(err == E_SUCCESS);

  err = msgr_register(MSGR_QMI_NAS,msgr_client,MSGR_ID_REX,LTE_RRC_BARRING_UPDATE_IND);
  QM_MSG_HIGH_1( "LTE_RRC_BARRING_UPDATE_IND register ret %d", err );
  ASSERT(err == E_SUCCESS);

  err = msgr_register(MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_GET_SERV_CELL_SIB_CNF);
  QM_MSG_HIGH_1("LTE_RRC_GET_SERV_CELL_SIB_CNF register ret %d", err);
  ASSERT(err == E_SUCCESS);

  err = msgr_register(MSGR_QMI_NAS,msgr_client,MSGR_ID_REX,NAS_EMM_T3402_CHANGED_IND);
  QM_MSG_HIGH_1( "NAS_EMM_T3402_CHANGED_IND register ret %d", err);
  ASSERT(err == E_SUCCESS);

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_T3346_INFO_IND );
  QM_MSG_HIGH_1("MM_CM_T3346_INFO_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, MM_CM_CALL_MODE_IND );
  QM_MSG_HIGH_1("MM_CM_CALL_MODE_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, LTE_RRC_CELL_LOCK_RSP );
  QM_MSG_HIGH_1("LTE_RRC_CELL_LOCK_RSP register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, GERAN_GRR_QMI_CELL_INFO_IND );
  QM_MSG_HIGH_1("GERAN_GRR_QMI_CELL_INFO_IND register ret %d", err);
  ASSERT( err == E_SUCCESS );

  err = msgr_register( MSGR_QMI_NAS, msgr_client, MSGR_ID_REX, GERAN_GRR_QMI_CELL_INFO_RSP );
  QM_MSG_HIGH_1("GERAN_GRR_QMI_CELL_INFO_RSP register ret %d", err);
  ASSERT( err == E_SUCCESS );
}

/*===========================================================================
  FUNCTION qmi_nas_get_lac()

  DESCRIPTION
    <QMI NAS internal use only>Helper function to determine which LAC to use.

  PARAMETERS
    p_ss_info : pointer to cm ss information to pull LAC from
    stack     : used to determine which stack to read LAC from

  RETURN VALUE
   sys_lac_type : the LAC value to use

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
sys_lac_type qmi_nas_get_lac(
  cm_mm_msim_ss_info_s_type *p_ss_info,
  uint8 stack_idx
)
{
  if( stack_idx != STACK_INDEX_MAX )
  {
    return p_ss_info->stack_info[stack_idx].sys_id.id.plmn_lac.lac;
      }

  return QMI_NAS_INVALID_LAC;
    }


/*===========================================================================
  FUNCTION QMI_NAS_GEN_RF_BAND_INFO_IND()

  DESCRIPTION
    Generate a rf band information indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    enum qmi_nas_stack_e          Stack

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_rf_band_info_ind(
  cm_mm_msim_ss_info_s_type *p_ss_info
)
{
  int                         clid, index;
  qmi_nasi_client_state_type *cl_sp;

  for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
  {
    cl_sp = qmi_nas_state.client[clid];

    if (  cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
            cl_sp->report_status.report_rf_band_info_ind &&
            cl_sp->report_status.bound_subs == (enum qmi_nas_subs_e)p_ss_info->asubs_id)
        {
      for( index = 0; index < p_ss_info->number_of_stacks && index < STACK_INDEX_MAX; index++ )
        {
        qmi_nas_send_rf_band_info_ind( p_ss_info, (enum qm_stack_index_e)index, cl_sp, clid );
      }
    }
  }

  if ( !qmi_nasi_global.rcvd_ss_info )
  {
    qmi_nasi_global.rcvd_ss_info = TRUE;
  }
} //qmi_nas_gen_rf_band_info_ind

/*===========================================================================
  FUNCTION QMI_NAS_SEND_RF_BAND_INFO_IND()

  DESCRIPTION
    Populate a rf band information indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    enum qmi_nas_stack_e          Stack
    qmi_nasi_state_type           Nas State
    qmi_nasi_client_state_type    Client
    inst                          NAS Instance
    clid                          Client ID

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_send_rf_band_info_ind(
  cm_mm_msim_ss_info_s_type  *p_ss_info,
  enum qm_stack_index_e  stack,
  qmi_nasi_client_state_type *cl_sp,
  int                         clid
)
{
  nas_rf_band_info_ind_msg_v01     *new_ind_msg, *old_ind_msg;
  boolean new_ind_msg_valid = FALSE;
  boolean send_ind =  FALSE;

  new_ind_msg = (nas_rf_band_info_ind_msg_v01  *) 
  	modem_mem_alloc( sizeof(nas_rf_band_info_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  old_ind_msg = (nas_rf_band_info_ind_msg_v01  *) 
  	modem_mem_alloc( sizeof(nas_rf_band_info_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( new_ind_msg == NULL || old_ind_msg == NULL)
    {
    qmi_voice_mem_error();
    ASSERT(0);
    goto end_send_rf_band_info_ind;
  }

  memset( new_ind_msg, 0x00, sizeof(nas_rf_band_info_ind_msg_v01) );
  memset( old_ind_msg, 0x00, sizeof(nas_rf_band_info_ind_msg_v01) );

  new_ind_msg_valid = qmi_nas_populate_rf_band_info_ind( p_ss_info,     new_ind_msg, stack );
  (void)qmi_nas_populate_rf_band_info_ind( &qmi_nasi_global.cm_msim_ss_info[p_ss_info->asubs_id], old_ind_msg, stack );

  if ( !qmi_nasi_global.rcvd_ss_info )
  {
     send_ind = TRUE;
  }
  else if ( memcmp( old_ind_msg, new_ind_msg, sizeof(nas_rf_band_info_ind_msg_v01) ) )
    {
    if ( new_ind_msg_valid)
      {
       send_ind = TRUE;
    }
    else
    {
      QM_MSG_LOW_1("rf information changed but nothing to send %d", clid);
    }
  }
  else
  {
    QM_MSG_LOW_1("rf info indication contents didn't change %d", clid);
  }

  if ( send_ind )
  {
     dsm_item_type              *ind = NULL;
     if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                  QMI_IDL_INDICATION,
                                                  (uint16_t)NASI_CMD_VAL_RF_BAND_INFO_IND,
                                                  (void *) new_ind_msg,
                                                  (uint32_t)sizeof(nas_rf_band_info_ind_msg_v01),
                                                  &ind
                                                ) )
     {
        qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_RF_BAND_INFO_IND, ind );
     }
     else
     {
        QM_MSG_ERROR_1("problem in writing indication for client %d", clid);
     }
  }
  
end_send_rf_band_info_ind:
  if ( new_ind_msg != NULL ) { modem_mem_free( (void *) new_ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( old_ind_msg != NULL ) { modem_mem_free( (void *) old_ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }  
} // qmi_nas_send_rf_band_info_ind

/*===========================================================================
  FUNCTION QMI_NAS_POPULATE_RF_BAND_INFO_IND()

  DESCRIPTION
    Populate a rf band information indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    struct nas_0066_ind_s         Indication message to populate
    enum qmi_nas_stack_e          Stack

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_populate_rf_band_info_ind(
  cm_mm_msim_ss_info_s_type *p_ss_info,
  nas_rf_band_info_ind_msg_v01 *ind_msg,
  enum qm_stack_index_e stack
)
{
  boolean ret = FALSE;
  if ( qmi_nas_sys_mode_2_radio_if( p_ss_info, stack, FALSE ) != QMI_NAS_RADIO_IF_NONE )
  {
    ind_msg->rf_band_info.radio_if           = (nas_radio_if_enum_v01)qmi_nas_sys_mode_2_radio_if( p_ss_info, stack, FALSE );
    ind_msg->rf_band_info.active_band    = (nas_active_band_enum_v01)qmi_nas_cm_bc_2_qmi_bc( p_ss_info->stack_info[stack].active_band );

    ind_msg->rf_band_info_list_ext.radio_if           = (nas_radio_if_enum_v01)qmi_nas_sys_mode_2_radio_if( p_ss_info, stack, FALSE );
    ind_msg->rf_band_info_list_ext.active_band    = (nas_active_band_enum_v01)qmi_nas_cm_bc_2_qmi_bc( p_ss_info->stack_info[stack].active_band );

    switch ( ind_msg->rf_band_info.radio_if )
    {
      case QMI_NAS_RADIO_IF_CDMA20001X:
        ind_msg->rf_band_info.active_channel             = p_ss_info->stack_info[stack].active_channel;
        ind_msg->rf_band_info_list_ext.active_channel = p_ss_info->stack_info[stack].active_channel;
        break;

      case QMI_NAS_RADIO_IF_CDMA20001XEVDO:
        ind_msg->rf_band_info.active_channel             = p_ss_info->stack_info[stack].active_channel;
        ind_msg->rf_band_info_list_ext.active_channel = p_ss_info->stack_info[stack].active_channel;
        break;

      case QMI_NAS_RADIO_IF_GSM:
#ifdef FEATURE_CM_NEW_RR_CELL_INFO_INTERFACE
        ind_msg->rf_band_info.active_channel             = p_ss_info->stack_info[stack].cell_info.arfcn;
        ind_msg->rf_band_info_list_ext.active_channel = p_ss_info->stack_info[stack].cell_info.arfcn;
#else
        ind_msg->rf_band_info.active_channel             = 0;
        ind_msg->rf_band_info_list_ext.active_channel = 0;
#endif
        break;

      case QMI_NAS_RADIO_IF_UMTS:
      case QMI_NAS_RADIO_IF_TDSCDMA:
        ind_msg->rf_band_info.active_channel             = p_ss_info->stack_info[stack].cell_info.uarfcn_dl;
        ind_msg->rf_band_info_list_ext.active_channel = p_ss_info->stack_info[stack].cell_info.uarfcn_dl;
        break;

      case QMI_NAS_RADIO_IF_LTE:
        ind_msg->rf_band_info.active_channel             = (uint16)p_ss_info->stack_info[stack].cell_info.earfcn_dl;
        ind_msg->rf_band_info_list_ext.active_channel = p_ss_info->stack_info[stack].cell_info.earfcn_dl;
        break;

      default:
        break;
    }
    ind_msg->rf_band_info_list_ext_valid = TRUE;
    ret = TRUE;
  }
  return ret;
} //qmi_nas_populate_rf_band_info_ind

/*===========================================================================
  FUNCTION QMI_NASI_GET_CDMA_POSITION_INFO()

  DESCRIPTION
    Message to get cdma position info

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_cdma_position_info
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  qmi_error_e_type       errval = QMI_ERR_NONE;
  struct nas_0065_rsp_s  rsp_msg;
  dsm_item_type         *response = NULL;

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  mcc_bs_info_type bs = {0};
  int              i, curr;
#endif

  memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
  mccdma_get_cur_bs_info_ext( &bs );

  if ( bs.curr_plt_cnt + bs.nbr_plt_cnt > QMI_NAS_CDMA_POSITION_INFO_MAX )
  {
    QM_MSG_ERROR_2("unexpected bs list len curr %d nbr %d", bs.curr_plt_cnt, bs.nbr_plt_cnt);
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    rsp_msg.t10.ue_in_idle = bs.ue_in_idle;
    rsp_msg.t10.bs_len     = bs.curr_plt_cnt + bs.nbr_plt_cnt;

    for ( i=0, curr=0; i<rsp_msg.t10.bs_len && i<QMI_NAS_CDMA_POSITION_INFO_MAX; i++, curr++ )
    {
      uint64 tmp;

      rsp_msg.t10.bs[i].pilot_type     = ( curr < bs.curr_plt_cnt ) ? QMI_NAS_CDMA_PILOT_CURR_ACT_PLT : QMI_NAS_CDMA_PILOT_NEIGHBOR_PLT;
      rsp_msg.t10.bs[i].sid            = bs.bs_info[i].sid;
      rsp_msg.t10.bs[i].nid            = bs.bs_info[i].nid;
      rsp_msg.t10.bs[i].base_id        = bs.bs_info[i].base_id;
      rsp_msg.t10.bs[i].pilot_pn       = bs.bs_info[i].pilot_pn;
      rsp_msg.t10.bs[i].pilot_strength = bs.bs_info[i].pilot_strength;
      rsp_msg.t10.bs[i].base_lat       = bs.bs_info[i].base_lat;
      rsp_msg.t10.bs[i].base_long      = bs.bs_info[i].base_long;
      tmp  = bs.bs_info[i].msg_time_stamp[1];
      tmp  = tmp << 32;
      tmp |= bs.bs_info[i].msg_time_stamp[0];
      rsp_msg.t10.bs[i].time_stamp     = tmp;
    }

    rsp_msg.t10_valid = TRUE;
  }
#else
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
#endif

  rsp_msg.t02.result_code = errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0065_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NAS_GEN_network_reject_IND()

  DESCRIPTION
    Generate a network reject information indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_network_reject_ind(
  cm_mm_msim_ss_info_s_type *p_ss_info
)
{
  int                         clid, index;
  qmi_nasi_client_state_type *cl_sp;

  for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
  {
    cl_sp = qmi_nas_state.client[clid];

    if (  cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
         cl_sp->report_status.network_reject.report_network_reject_ind &&
         cl_sp->report_status.bound_subs == (enum qmi_nas_subs_e) p_ss_info->asubs_id )
      {
      for( index = 0; index < p_ss_info->number_of_stacks && index < STACK_INDEX_MAX; index++ )
        {
        qmi_nas_send_network_reject_ind( p_ss_info, (enum qm_stack_index_e)index, cl_sp, clid );
      }
    }
  }

  if ( !qmi_nasi_global.rcvd_ss_info )
  {
    qmi_nasi_global.rcvd_ss_info = TRUE;
  }
} //qmi_nas_gen_network_reject_ind

/*===========================================================================
  FUNCTION QMI_NAS_SEND_NETWORK_REJECT_IND()

  DESCRIPTION
    Send a network reject indication if it contains information

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    enum qmi_nas_stack_e          Stack
    qmi_nasi_state_type           Nas State
    qmi_nasi_client_state_type    Client
    inst                          NAS Instance
    clid                          Client ID

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_send_network_reject_ind(
  cm_mm_msim_ss_info_s_type  *p_ss_info,
  enum qm_stack_index_e  stack,
  qmi_nasi_client_state_type *cl_sp,
  int                         clid
)
{
  struct nas_0068_ind_s       ind_msg;
  dsm_item_type              *ind = NULL;

  memset( &ind_msg, 0x00, sizeof(ind_msg) );

  qmi_nas_populate_network_reject_ind( p_ss_info, &ind_msg, stack );

  if ( ind_msg.t01_valid && ind_msg.t02_valid && ind_msg.t03_valid )
  {
    // we have something to send
    if ( qmi_nas_0068_ind_write ( &ind_msg, &ind ) == QMI_ERR_NONE )
    {
      qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_NETWORK_REJECT_IND, ind );
    }
  }
  else
  {
    QM_MSG_HIGH_1("no network reject information %d", clid);
  }
} // qmi_nas_send_network_reject_ind

/*===========================================================================
  FUNCTION QMI_NAS_POPULATE_NETWORK_REJECT_IND()

  DESCRIPTION
    Populate a network reject information indication

  PARAMETERS
    cm_mm_msim_ss_info_s_type CM SS info
    struct nas_0068_ind_s         Indication message to populate
    enum qmi_nas_stack_e          Stack

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_network_reject_ind(
  cm_mm_msim_ss_info_s_type *p_ss_info,
  struct nas_0068_ind_s *ind_msg,
  enum qm_stack_index_e stack
)
{
  boolean is_plmn_undefined, mnc_includes_pcs_digit;
  sys_mcc_type mcc;
  sys_mnc_type mnc;

  QM_MSG_HIGH_3( "Network Reject ind - stack=%d:rej_cause=%d:rej_rat=%d",(uint8)stack, p_ss_info->stack_info[stack].reg_reject_info.reject_cause, p_ss_info->stack_info[stack].reg_reject_info.reg_rej_rat );
  
  if( p_ss_info->stack_info[stack].sys_mode == SYS_SYS_MODE_GSM || p_ss_info->stack_info[stack].sys_mode == SYS_SYS_MODE_WCDMA ||
      p_ss_info->stack_info[stack].sys_mode == SYS_SYS_MODE_LTE || p_ss_info->stack_info[stack].sys_mode == SYS_SYS_MODE_TDS )
    {
      ind_msg->t01_valid = TRUE;
      ind_msg->t01.radio_if = qmi_nas_rat_2_radio_if( p_ss_info->stack_info[stack].reg_reject_info.reg_rej_rat );

    if ( p_ss_info->stack_info[stack].srv_status != SYS_SRV_STATUS_NO_SRV &&
         p_ss_info->stack_info[stack].srv_status != SYS_SRV_STATUS_PWR_SAVE )
      {
      if( p_ss_info->stack_info[stack].reg_reject_info.reject_srv_domain != SYS_SRV_DOMAIN_NONE )
          {
            ind_msg->t02_valid = TRUE;
        ind_msg->t02.reject_srv_domain     = p_ss_info->stack_info[stack].reg_reject_info.reject_srv_domain;

            ind_msg->t03_valid = TRUE;
        ind_msg->t03.rej_cause             = p_ss_info->stack_info[stack].reg_reject_info.reject_cause;

        sys_plmn_get_mcc_mnc(p_ss_info->stack_info[stack].reg_reject_info.plmn,
                               &is_plmn_undefined,
                               &mnc_includes_pcs_digit,
                               &mcc,
                               &mnc );

          if( !is_plmn_undefined )
          {
            ind_msg->t10_valid = TRUE;
            ind_msg->t10.mcc = (uint16) mcc;
            ind_msg->t10.mnc = (uint16) mnc;
            ind_msg->t10.mnc_includes_pcs_digit = mnc_includes_pcs_digit;
          }

#ifdef FEATURE_FEMTO_CSG
          if ( qm_efs_csg_supported() )
          {
          if( p_ss_info->stack_info[stack].reg_reject_info.csg_id != SYS_CSG_ID_INVALID )
          {
            ind_msg->t11_valid = TRUE;
            ind_msg->t11.csg_id = p_ss_info->stack_info[stack].reg_reject_info.csg_id;
          }
          }
#endif
          }
      }
    }
} //qmi_nas_populate_network_reject_ind

/*===========================================================================
  FUNCTION QMI_NASI_FORCE_NETWORK_SEARCH()

  DESCRIPTION
    Force network search procedure

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_force_network_search
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_error_e_type               errval = QMI_ERR_NONE;
  struct nas_0067_rsp_s  rsp_msg;
  dsm_item_type         *response = NULL;

  memset( &rsp_msg, 0x00, sizeof(rsp_msg) );

  if ( qmi_nasi_global.cm_ph_info.oprt_mode == SYS_OPRT_MODE_ONLINE )
  {
    // ignore CM response for now which allows easier management
    // of nested REQ messages
    if ( !cm_ph_cmd_wakeup_from_standby( NULL, NULL, qmi_nasi_global.cm_clnt_id ) )
  {
    errval = QMI_ERR_INTERNAL;
  }
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY;
  }

  rsp_msg.t02.result_code = errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0067_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = NULL;
  }

  return response;
  }

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_PLMN_NAME_RESP()

  DESCRIPTION
    send response for get_plmn_name after mmgsdi callback

  PARAMETERS
    name_cnf : mmgsdi callback information

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_plmn_name_resp( const mmgsdi_session_get_operator_name_cnf_type *name_cnf )
{
  dsm_item_type                        *response = NULL;
  qmi_error_type_v01                    errval = QMI_ERR_NONE_V01;
  nas_get_plmn_name_resp_msg_v01       *rsp_msg;
  struct qmi_nasi_mmgsdi_client_data_s *callback_data = NULL;
  qmi_cmd_buf_type                     *cmd_buf_p = NULL;
  uint16 buff_ptr[(NASI_MAX_LEN_NETWORK_NAME/2)];
  boolean send_all_fields = FALSE;
  int i = 0;
  size_t temp_len = 0;
  uint8 tmp_buf[NAS_ALT_LANG_NAME_LEN_MAX_V01*2] = { 0 };

  callback_data = (struct qmi_nasi_mmgsdi_client_data_s *) name_cnf->response_header.client_data;
  if( callback_data != NULL )
  {
    cmd_buf_p = (qmi_cmd_buf_type *) callback_data->cmd_buf_ptr;
    send_all_fields = callback_data->send_all_info;
  }

  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_HIGH_1("Received NULL cmd_buf in GET_PLMN_NAME callback %x", callback_data);
    if( callback_data != NULL )
    {
      modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
    }
    return;
  }

  rsp_msg = (nas_get_plmn_name_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_plmn_name_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if( rsp_msg != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_plmn_name_resp_msg_v01) );

    if( name_cnf->response_header.mmgsdi_status == MMGSDI_SUCCESS )
    {
      if( name_cnf->plmn_list.num_of_plmn_ids == 1 && name_cnf->plmn_list.plmn_info_ptr != NULL ) // get_plmn_name request a single name
      {
        QM_MSG_HIGH_6("Names found: SPN len=%d, short len=%d, long len=%d, Encoding: SPN = %d, short = %d, long = %d", name_cnf->spn.eons_data.data_len, name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len, 
			name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len,name_cnf->spn.eons_encoding, name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding, 
			name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding);


        qm_util_print_bytes( name_cnf->spn.eons_data.data_ptr, name_cnf->spn.eons_data.data_len );
        qm_util_print_bytes( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr,
                             name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len );
        qm_util_print_bytes( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr,
                             name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len );

        rsp_msg->eons_plmn_name_3gpp_valid = TRUE;
        rsp_msg->spn_ext_valid = TRUE;
        if( name_cnf->spn.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          rsp_msg->eons_plmn_name_3gpp.spn_enc = NAS_CODING_SCHEME_UCS2_V01;
          rsp_msg->eons_plmn_name_3gpp.spn_len = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->spn.eons_data.data_ptr,
                                                                                          name_cnf->spn.eons_data.data_len,
                                                                                          buff_ptr,
                                                                                          NAS_SPN_LEN_MAX_V01/2 );
          memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.spn, NAS_SPN_LEN_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.spn_len );
          
          //UCS2 encoding directly maps to UTF16 in the range 0x0000-0xFFFF.
          temp_len = qm_util_decode_ucs2_80_81_82_encoding( name_cnf->spn.eons_data.data_ptr,
                                                            name_cnf->spn.eons_data.data_len,
                                                            buff_ptr,
                                                            NAS_SPN_EXT_LEN_MAX_V01/2 );
          memscpy((void*)rsp_msg->spn_ext, NAS_SPN_EXT_LEN_MAX_V01, (void*)buff_ptr, 2*temp_len);
        }
        else if ( name_cnf->spn.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
        {
          rsp_msg->eons_plmn_name_3gpp.spn_enc = NAS_CODING_SCHEME_UCS2_V01;
          rsp_msg->eons_plmn_name_3gpp.spn_len = name_cnf->spn.eons_data.data_len;
          memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.spn, NAS_SPN_LEN_MAX_V01, (void*)name_cnf->spn.eons_data.data_ptr, name_cnf->spn.eons_data.data_len );
          
          //UCS2 encoding directly maps to UTF16 in the range 0x0000-0xFFFF.
          temp_len = name_cnf->spn.eons_data.data_len/2;
          memscpy((void*)rsp_msg->spn_ext, NAS_SPN_EXT_LEN_MAX_V01, (void*)name_cnf->spn.eons_data.data_ptr, 2*temp_len);
        }
        else
        {
          rsp_msg->eons_plmn_name_3gpp.spn_enc = NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01;
          rsp_msg->eons_plmn_name_3gpp.spn_len = name_cnf->spn.eons_data.data_len;
          memscpy(rsp_msg->eons_plmn_name_3gpp.spn, name_cnf->spn.eons_data.data_len, 
                       name_cnf->spn.eons_data.data_ptr, name_cnf->spn.eons_data.data_len);
          
          qm_util_gsm7_to_utf16( name_cnf->spn.eons_data.data_ptr,
                                 name_cnf->spn.eons_data.data_len,
                                 FALSE,
                                 rsp_msg->spn_ext,
                                 NAS_SPN_EXT_LEN_MAX_V01,
                                 &temp_len);
        }
        QM_MSG_HIGH_5("eons_plmn_name_3gpp_valid=%d, spn_enc=%d, spn_len=%d, spn_ext_valid=%d, spn_ext_len=%d", 
			rsp_msg->eons_plmn_name_3gpp_valid = TRUE, rsp_msg->eons_plmn_name_3gpp.spn_enc, 
			rsp_msg->eons_plmn_name_3gpp.spn_len, rsp_msg->spn_ext_valid, temp_len);

        if( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          rsp_msg->eons_plmn_name_3gpp.plmn_long_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_ci;
          rsp_msg->eons_plmn_name_3gpp.plmn_long_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_spare_bits;
          rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
          rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                                                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len,
                                                                                                       buff_ptr,
                                                                                                       NASI_MAX_LEN_NETWORK_NAME/2 );
          memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.plmn_long_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len );
        }
        else if( nasi_convert_mm_info_oper_name( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding,
                                                 (char *) rsp_msg->eons_plmn_name_3gpp.plmn_long_name,
                                                 (uint8 *)&rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc,
                                                 NASI_MAX_LEN_NETWORK_NAME,
                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len ) )
        {
          rsp_msg->eons_plmn_name_3gpp.plmn_long_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_ci;
          rsp_msg->eons_plmn_name_3gpp.plmn_long_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_spare_bits;
          if( (rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
              (name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
            )
          {
            rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len);
          }
          else
          {
            rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)rsp_msg->eons_plmn_name_3gpp.plmn_long_name, NAS_PLMN_NAME_MAX_V01 ));
          }
        }

        if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
        {
          rsp_msg->eons_plmn_name_3gpp.plmn_short_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_ci;
          rsp_msg->eons_plmn_name_3gpp.plmn_short_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_spare_bits;
          rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
          rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                                     name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len,
                                                                                     buff_ptr,
                                                                                     NASI_MAX_LEN_NETWORK_NAME/2 );
          memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.plmn_short_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len );
        }
        else if ( nasi_convert_mm_info_oper_name( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                  name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding,
                                                  (char *) rsp_msg->eons_plmn_name_3gpp.plmn_short_name,
                                                  (uint8 *)&rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc,
                                                  NASI_MAX_LEN_NETWORK_NAME,
                                                  name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len ) )
        {
          rsp_msg->eons_plmn_name_3gpp.plmn_short_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_ci;
          rsp_msg->eons_plmn_name_3gpp.plmn_short_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_spare_bits;
          if( (rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
              (name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
            )
          {
            rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len);
          }
          else
          {
            rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)rsp_msg->eons_plmn_name_3gpp.plmn_short_name, NAS_PLMN_NAME_MAX_V01 ));
          }
        }

        if ( send_all_fields )
        {
          rsp_msg->eons_display_bit_info_valid = TRUE;
          rsp_msg->eons_display_bit_info.is_spn_set = qmi_nas_map_display_bit_mmgsdi_to_qmi( (mmgsdi_eons_rplmn_display_bit_enum_type) name_cnf->spn_display_bit );
          rsp_msg->eons_display_bit_info.is_plmn_set = qmi_nas_map_display_bit_mmgsdi_to_qmi( name_cnf->rplmn_display_bit );

          rsp_msg->is_home_network_valid = TRUE;
          rsp_msg->is_home_network = qmi_nas_map_home_status_mmgsdi_to_qmi( name_cnf->roaming_status );
        }

        if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding != MMGSDI_EONS_ENC_INVALID ||
             name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len != 0 ||
             name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr != NULL )
        {
          if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
          {
            rsp_msg->addl_info_valid = TRUE;
            rsp_msg->addl_info_len = qm_util_decode_ucs2_80_81_82_encoding( 
                                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr,
                                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len,
                                       buff_ptr,
                                       NAS_PLMN_NAME_MAX_V01/2 );
            memscpy( (void*)rsp_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->addl_info_len*2 );
          }
          else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2 )
          {
            rsp_msg->addl_info_valid = TRUE;
            rsp_msg->addl_info_len = name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len/2;
            memscpy( (void*)rsp_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len );
            convert_endianness16( (unsigned char*)rsp_msg->addl_info, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len );
          }
          else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED )
          {
            if( !cm_util_gsm7_to_utf16( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr, 
                                        name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len,
                                        FALSE,
                                        rsp_msg->addl_info,
                                        NAS_PLMN_NAME_MAX_V01,
                                        (size_t *)&rsp_msg->addl_info_len ) )
            {
              rsp_msg->addl_info_valid = TRUE;
            }
          }
        }

        rsp_msg->nw_name_source_valid = TRUE;
        rsp_msg->nw_name_source = qmi_nas_map_nw_name_source_mmgsdi_to_qmi( name_cnf->plmn_list.plmn_info_ptr[0].plmn_name_source );

        if ( name_cnf->plmn_list.plmn_info_ptr[0].num_plmn_additional_names > 0 )
        {
          rsp_msg->lang_plmn_names_valid = TRUE;
          rsp_msg->lang_plmn_names_len = MIN(NAS_ALT_LANG_MAX_V01, name_cnf->plmn_list.plmn_info_ptr[0].num_plmn_additional_names);
          for ( i = 0; i < rsp_msg->lang_plmn_names_len; i++ )
          {
            rsp_msg->lang_plmn_names[i].lang_id = qmi_nas_map_lang_id_mmgsdi_to_qmi(name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_lang);

            if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
            {
              rsp_msg->lang_plmn_names[i].plmn_long_name_len = qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len,
                                                                 rsp_msg->lang_plmn_names[i].plmn_long_name,
                                                                 NAS_ALT_LANG_NAME_LEN_MAX_V01 );
            }
            else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
            {
              memscpy( tmp_buf, 
                       NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr, 
                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
              convert_endianness16( tmp_buf, 
                                    name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
              memscpy( rsp_msg->lang_plmn_names[i].plmn_long_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
              rsp_msg->lang_plmn_names[i].plmn_long_name_len = name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len/2;
            }

            if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
            {
              rsp_msg->lang_plmn_names[i].plmn_short_name_len = qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len,
                                                                 rsp_msg->lang_plmn_names[i].plmn_short_name,
                                                                 NAS_ALT_LANG_NAME_LEN_MAX_V01 );
            }
            else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
            {
              memscpy( tmp_buf, 
                       NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr, 
                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
              convert_endianness16( tmp_buf, 
                                    name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
              memscpy( rsp_msg->lang_plmn_names[i].plmn_short_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
              rsp_msg->lang_plmn_names[i].plmn_short_name_len = name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len/2;
            }
        }
      }
    }
    else
    {
        errval = QMI_ERR_INTERNAL_V01;
    }
  }
  else
  {
      errval = QMI_ERR_INTERNAL_V01;
  }

  // Populate TLV 0x02 (Mandatory error code)
    rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;

    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                              QMI_IDL_RESPONSE,
                                              (uint16_t) QMI_NAS_GET_PLMN_NAME_RESP_MSG_V01,
                                              (void *) rsp_msg,
                                              (uint32_t) sizeof( nas_get_plmn_name_resp_msg_v01 ),
                                              &response
                                            ) )
  {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }
  }
  else
  {
    qmi_voice_mem_error();
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }

  if( rsp_msg != NULL ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if( callback_data != NULL ) { modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE ); }
}

/*===========================================================================
  FUNCTION QMI_NAS_COMPARE_MMGSDI_CM_NETWORK_RAT()

  DESCRIPTION
    Compare RAT modes coming from MMGSDI and CM PH EVENT

  PARAMETERS
    rat : mmgsdi RAT received from callback information
    available_rat : RAT received from CM Phone Event


  RETURN VALUE
    True if comparision is success, FALSE otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_compare_mmgsdi_cm_network_rat( mmgsdi_rat_enum_type  rat, sys_radio_access_tech_e_type available_rat)
{
  boolean ret_val = FALSE;
  QM_MSG_MED_2("qmi_nas_compare_mmgsdi_cm_network_rat: mmgsdi rat = %d, cm rat = %d", rat, available_rat);

  switch (rat)
  {
    case MMGSDI_RAT_GSM:
      if( available_rat == SYS_RAT_GSM_RADIO_ACCESS ){ ret_val = TRUE; }
      break;
    case MMGSDI_RAT_UMTS:
      if( available_rat == SYS_RAT_UMTS_RADIO_ACCESS ){ ret_val = TRUE; }
      break;
    case MMGSDI_RAT_LTE:
      if( available_rat == SYS_RAT_LTE_RADIO_ACCESS ){ ret_val = TRUE; }
      break;
    case MMGSDI_RAT_TDS:
      if( available_rat == SYS_RAT_TDS_RADIO_ACCESS ){ ret_val = TRUE; }
      break;
    default:
      break;
  }

  return ret_val;
}


/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_PERFORM_NETWORK_SCAN_RESP_PCI_SCAN()

  DESCRIPTION
    Generate response for perform network scan after mmgsdi callback

  PARAMETERS
    name_cnf : mmgsdi callback information

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_perform_network_scan_resp_pci_scan( sys_found_plmn_list_u_type *plmn_list_rec )
{
  qmi_cmd_buf_type                     *cmd_buf_p = NULL;
  nas_perform_network_scan_resp_msg_v01                *rsp_msg   = NULL;
  dsm_item_type *                       response   = NULL;


  qmi_error_e_type       errval = QMI_ERR_NONE;

  boolean is_plmn_undefined      = FALSE;
  boolean mnc_includes_pcs_digit = FALSE;

  sys_mcc_type mcc                 = 0;
  sys_mnc_type mnc                 = 0;
  int          i                   = 0;
  int pci_loop = 0, plmn_loop = 0;

  // Clear pending network scan global var
  qmi_nasi_global.net_scan_started = FALSE;

  QM_MSG_HIGH("PCI_DEBUG qmi_nasi_generate_perform_network_scan_resp_pci_scan 1");


  rsp_msg = ( nas_perform_network_scan_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_perform_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );


  if( rsp_msg == NULL)
  {
    QM_MSG_ERROR("qmi_nas_cmstats_evt_cb() modem_mem_alloc failed");
    errval = QMI_ERR_NO_MEMORY;
  }

  qm_cbpq_del_invalid_items( QM_CBPQ_QTYPE_NW_SCAN );

  while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_NW_SCAN )) != NULL )
  {
    response = NULL;

    if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
    {
      QM_MSG_ERROR("Queued buffer does not match existing client transaction");
      continue;
    }

    if( errval == QMI_ERR_NONE)
    {
      memset(rsp_msg, 0, sizeof(nas_perform_network_scan_resp_msg_v01));


      rsp_msg->pci_plmn_info_valid = TRUE;
 
      rsp_msg->pci_plmn_info.signal_info.rsrp = plmn_list_rec->pci_plmn_list.signal_info.rsrp;
      rsp_msg->pci_plmn_info.signal_info.rsrp_rx0 = plmn_list_rec->pci_plmn_list.signal_info.rsrp_rx0;
      rsp_msg->pci_plmn_info.signal_info.rsrp_rx1 = plmn_list_rec->pci_plmn_list.signal_info.rsrp_rx1;
      rsp_msg->pci_plmn_info.signal_info.rsrq = plmn_list_rec->pci_plmn_list.signal_info.rsrq;
      rsp_msg->pci_plmn_info.signal_info.rsrq_rx0 = plmn_list_rec->pci_plmn_list.signal_info.rsrq_rx0;
      rsp_msg->pci_plmn_info.signal_info.rsrq_rx1 = plmn_list_rec->pci_plmn_list.signal_info.rsrq_rx1;

      
      rsp_msg->pci_plmn_info.pci_cell_info_len = plmn_list_rec->pci_plmn_list.num_cell;


      QM_MSG_HIGH_1("PCI_DEBUG: CELL INFO LEN %d", rsp_msg->pci_plmn_info.pci_cell_info_len);

       for(pci_loop=0; pci_loop < rsp_msg->pci_plmn_info.pci_cell_info_len;pci_loop++)
       {

        rsp_msg->pci_plmn_info.pci_cell_info[pci_loop].cell_id = plmn_list_rec->pci_plmn_list.cell_info[pci_loop].cell_id;
        rsp_msg->pci_plmn_info.pci_cell_info[pci_loop].freq =  plmn_list_rec->pci_plmn_list.cell_info[pci_loop].freq;
        rsp_msg->pci_plmn_info.pci_cell_info[pci_loop].global_cell_id = plmn_list_rec->pci_plmn_list.cell_info[pci_loop].global_cell_id;
        rsp_msg->pci_plmn_info.pci_cell_info[pci_loop].plmn_len = plmn_list_rec->pci_plmn_list.cell_info[pci_loop].num_plmn;


        for(plmn_loop=0;plmn_loop<rsp_msg->pci_plmn_info.pci_cell_info[pci_loop].plmn_len;plmn_loop++)
          
        {

          sys_plmn_get_mcc_mnc(plmn_list_rec->pci_plmn_list.cell_info[pci_loop].plmn[plmn_loop],
                             &is_plmn_undefined,
                             &mnc_includes_pcs_digit,
                             &mcc,
                             &mnc );
        
          if(!is_plmn_undefined)
          {

             rsp_msg->pci_plmn_info.pci_cell_info[pci_loop].plmn[plmn_loop].mcc = mcc;
             rsp_msg->pci_plmn_info.pci_cell_info[pci_loop].plmn[plmn_loop].mnc = mnc;
             rsp_msg->pci_plmn_info.pci_cell_info[pci_loop].plmn[plmn_loop].mnc_includes_pcs_digit = mnc_includes_pcs_digit;

            QM_MSG_HIGH_3("PCI_DEBUG MCC %d, MNC %d,  mnc_includes_pcs_digit %d",mcc,mnc,mnc_includes_pcs_digit );

          }
        }

       }



      // Populate TLV 0x02 (Mandatory error code)
      rsp_msg->resp.result  = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01;
      rsp_msg->resp.error   = (qmi_error_type_v01)errval;

      response = NULL;

     QM_MSG_HIGH("PCI_DEBUG : encoding message qmi_nasi_generate_perform_network_scan_resp_pci_scan");
     
      if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                         QMI_IDL_RESPONSE,
                                         (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                         (void *) rsp_msg,
                                         (uint32_t) sizeof(nas_perform_network_scan_resp_msg_v01),
                                         &response
                                       ) )
      {
        if( !qmi_nasi_send_response(cmd_buf_p, response) )
        {
          qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );

        }
        QM_MSG_HIGH("PCI_DEBUG : 2 encoding message qmi_nasi_generate_perform_network_scan_resp_pci_scan"); 
      }
      else
      {
        dsm_free_packet(&response);
        qmi_mmode_svc_free_transaction_cmd_buf(&cmd_buf_p);
      }
    } // End if
  }// end while (cmd buf queue is empty)

  if ( rsp_msg ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_PERFORM_NETWORK_SCAN_RESP()

  DESCRIPTION
    Generate response for perform network scan after mmgsdi callback

  PARAMETERS
    name_cnf : mmgsdi callback information

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_perform_network_scan_resp( const mmgsdi_session_get_operator_name_cnf_type *name_cnf )
{
  struct qmi_nasi_mmgsdi_client_data_s *callback_data = NULL;
  qmi_cmd_buf_type                     *cmd_buf_p = NULL;
  nas_perform_network_scan_resp_msg_v01                *rsp_msg   = NULL;
  dsm_item_type *                       response   = NULL;
  sys_detailed_plmn_list_s_type        *available_networks = NULL;

  qmi_error_e_type       errval = QMI_ERR_NONE;

  boolean is_plmn_undefined      = FALSE;
  boolean mnc_includes_pcs_digit = FALSE;
  boolean net_info_available     = FALSE;
  boolean rat_match              = FALSE, rat_match_2 = FALSE;

  int          sys_plmn_list_index = 0;
  int          network_info_index  = 0;
  int          num_networks        = 0;
  sys_mcc_type mcc                 = 0;
  sys_mnc_type mnc                 = 0;
  int          i                   = 0;
  uint8 encoding_type = 0;
  int j = 0;
  uint8 network_name_len = 0;
  uint16 buff_ptr[(NASI_MAX_LEN_NETWORK_NAME/2)];
  boolean is_plmn_2_valid=FALSE;
  sys_plmn_id_s_type current_plmn, current_plmn_2; //initialized for each cmd_buffer
  sys_sys_mode_e_type current_sys_mode = SYS_SYS_MODE_NONE, current_sys_mode_2 = SYS_SYS_MODE_NONE;

  // Initialize for SYS_MODEM_AS_ID_1
  sys_plmn_id_s_type plmn_main_stack = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn_avail ?
                                              qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn :
                                              qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].sys_id.id.plmn ;

  sys_sys_mode_e_type sys_mode_main_stack = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].sys_mode;
  sys_sys_mode_e_type sys_mode_gw_stack   = SYS_SYS_MODE_NONE;

  sys_srv_status_e_type main_stack_srv = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].srv_status;
  sys_srv_status_e_type gw_stack_srv = SYS_SRV_STATUS_NO_SRV;


  // Clear pending network scan global var
  qmi_nasi_global.net_scan_started = FALSE;

  QM_MSG_HIGH_2("generate_perform_network_scan main_stack = %d,srv=%d", sys_mode_main_stack, main_stack_srv);  
  if( qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].number_of_stacks > 1 &&
      qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_mode != SYS_SYS_MODE_HDR )
  {
    sys_mode_gw_stack = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].sys_mode;
    gw_stack_srv = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].srv_status;
    QM_MSG_HIGH_2("generate_perform_network_scan gw_stack = %d,srv=%d", sys_mode_gw_stack, gw_stack_srv);
  }

  rsp_msg = ( nas_perform_network_scan_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_perform_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  callback_data = (struct qmi_nasi_mmgsdi_client_data_s *) name_cnf->response_header.client_data;
  if( callback_data != NULL )
  {
    available_networks = (sys_detailed_plmn_list_s_type *) callback_data->cmd_buf_ptr;
  }
  else
  {
    QM_MSG_ERROR("qmi_nasi_generate_perform_network_scan_resp - callback_data is NULL!");
    errval = QMI_ERR_INTERNAL;
  }

  if( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY;
  }

  qm_cbpq_del_invalid_items( QM_CBPQ_QTYPE_NW_SCAN );

  while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_NW_SCAN )) != NULL )
  {
    response = NULL;
    network_info_index  = 0;

    if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
    {
      QM_MSG_ERROR("Queued buffer does not match existing client transaction");
      continue;
    }

    if( errval == QMI_ERR_NONE)
    {
      memset(rsp_msg, 0, sizeof(nas_perform_network_scan_resp_msg_v01));

      // Update current PLMN based on subscription
#ifdef FEATURE_DUAL_SIM
      if( ((qmi_nasi_client_state_type*)cmd_buf_p->x_p->cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
      {
        current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn_avail ?
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn :
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].sys_id.id.plmn ;
        current_sys_mode = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].sys_mode;
      }
      else
#endif
#ifdef FEATURE_TRIPLE_SIM    
      if( ((qmi_nasi_client_state_type*)cmd_buf_p->x_p->cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
      {
        current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_3].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn_avail ?
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_3].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn :
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_3].stack_info[STACK_INDEX_0].sys_id.id.plmn ;
        current_sys_mode = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_3].stack_info[STACK_INDEX_0].sys_mode;
      }
      else
#endif
      {
        if( qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].number_of_stacks > 1 &&
            qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_mode != SYS_SYS_MODE_HDR )        
        {
          current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.plmn_avail ?
                          qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.plmn :
                          qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_id.id.plmn ;;
          current_sys_mode = sys_mode_gw_stack;

          if( (sys_mode_main_stack == SYS_SYS_MODE_GSM || sys_mode_main_stack == SYS_SYS_MODE_WCDMA || sys_mode_main_stack == SYS_SYS_MODE_TDS || sys_mode_main_stack == SYS_SYS_MODE_LTE) && 
              (main_stack_srv == SYS_SRV_STATUS_SRV) )
          {
            current_plmn_2 = plmn_main_stack;
            current_sys_mode_2 = sys_mode_main_stack;
            is_plmn_2_valid = TRUE;
            QM_MSG_HIGH_1("generate_perform_network_scan is_plmn_2_valid = %d", is_plmn_2_valid);
          }
        }
        else
        {
          current_plmn = plmn_main_stack;
          current_sys_mode = sys_mode_main_stack;
        }
      }

      if( available_networks->length > NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX )
      {
        QM_MSG_ERROR_2("Received %d available networks, max is %d", available_networks->length, NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX);
        num_networks = NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX;
      }
      else
      {
        num_networks = available_networks->length;
      }

      // For every PLMN value in the list of available networks fill in TLVs
      // 0x10, 0x11, and 0x12
      for(sys_plmn_list_index=0; sys_plmn_list_index < num_networks; sys_plmn_list_index++)
      {
        net_info_available = FALSE;

        sys_plmn_get_mcc_mnc(available_networks->info[sys_plmn_list_index].plmn,
                             &is_plmn_undefined,
                             &mnc_includes_pcs_digit,
                             &mcc,
                             &mnc );
        if(!is_plmn_undefined)
        {
          // TLV 0x10 (3GPP NETWORK INFORMATION)
          rsp_msg->nas_3gpp_network_info[network_info_index].mobile_country_code = (uint16) mcc;
          rsp_msg->nas_3gpp_network_info[network_info_index].mobile_network_code = (uint16) mnc;

          rat_match = FALSE, rat_match_2 = FALSE;
          switch ( current_sys_mode )
          {
            case SYS_SYS_MODE_GSM:
              rat_match = ( available_networks->info[sys_plmn_list_index].rat ==  SYS_RAT_GSM_RADIO_ACCESS );
              break;
            case SYS_SYS_MODE_WCDMA:
              rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_UMTS_RADIO_ACCESS );
              break;
            case SYS_SYS_MODE_LTE:
              rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_LTE_RADIO_ACCESS  );
              break;
            case SYS_SYS_MODE_TDS:
              rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_TDS_RADIO_ACCESS  );
              break;
            default:
              QM_MSG_ERROR_1("generate_perform_network_scan no rat match current_sys_mode = %d", current_sys_mode);
              break;
          }
          if( is_plmn_2_valid )
          {
            switch ( current_sys_mode_2 )
          {
              case SYS_SYS_MODE_GSM:
                rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat ==  SYS_RAT_GSM_RADIO_ACCESS );
                break;
              case SYS_SYS_MODE_WCDMA:
                rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_UMTS_RADIO_ACCESS );
                break;
              case SYS_SYS_MODE_LTE:
                rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_LTE_RADIO_ACCESS  );
                break;
              case SYS_SYS_MODE_TDS:
                rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_TDS_RADIO_ACCESS  );
                break;
              default:
                QM_MSG_MED_1("generate_perform_network_scan no rat match current_sys_mode_2 = %d", current_sys_mode_2);
              break;
          }
          }

          if( sys_plmn_match( current_plmn, available_networks->info[sys_plmn_list_index].plmn) &&  rat_match )
          {
            rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_CURRENT_MASK;
          }
          else if (is_plmn_2_valid && rat_match_2 &&
                   sys_plmn_match( current_plmn_2, available_networks->info[sys_plmn_list_index].plmn))
            {
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_CURRENT_MASK;
            }
            else
            {
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_AVAILABLE_MASK;
            }

          switch (available_networks->info[sys_plmn_list_index].list_category)
          {
            case SYS_DETAILED_PLMN_LIST_CATEGORY_HPLMN:
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_HOME_MASK;
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_PREFERRED_MASK;
              break;

            case SYS_DETAILED_PLMN_LIST_CATEGORY_PREFERRED:
            case SYS_DETAILED_PLMN_LIST_CATEGORY_USER_PREFERRED:
            case SYS_DETAILED_PLMN_LIST_CATEGORY_OPERATOR_PREFERRED:
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_ROAM_MASK;
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_PREFERRED_MASK;
                break;

            case SYS_DETAILED_PLMN_LIST_CATEGORY_OTHER:
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_ROAM_MASK;
              rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_NOT_PREFERRED_MASK;
                break;

            default:
                QM_MSG_HIGH_2("Unhandled list_category (%d) for available networks.info[%d]", available_networks->info[sys_plmn_list_index].list_category, sys_plmn_list_index);
                break;
          }

          if(available_networks->info[sys_plmn_list_index].plmn_forbidden)
          {
            rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_FORBIDDEN_MASK;
          }
          else
          {
            rsp_msg->nas_3gpp_network_info[network_info_index].network_status |= NASI_PLMN_STATUS_NOT_FORBIDDEN_MASK;
          }

          if( name_cnf->response_header.mmgsdi_status == MMGSDI_SUCCESS )
          {
            if( name_cnf->plmn_list.plmn_info_ptr != NULL )
            {
              for( i = 0; i < name_cnf->plmn_list.num_of_plmn_ids; i++ )
              {
                if ( !memcmp( name_cnf->plmn_list.plmn_info_ptr[i].plmn_id.plmn_id_val, available_networks->info[sys_plmn_list_index].plmn.identity, sizeof(sys_plmn_id_s_type) ) &&
                      qmi_nas_compare_mmgsdi_cm_network_rat( name_cnf->plmn_list.plmn_info_ptr[i].plmn_id.rat, available_networks->info[sys_plmn_list_index].rat ) )
                {
                  QM_MSG_HIGH_3("Perform net scan PLMN index %d, len %d, encoding %d", i, name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len, name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding);
                  for( j=0; j<name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len; j++ )
                  {
                    QM_MSG_HIGH_1("%d", name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_ptr[j]);
                  }

                  if ( qm_efs_always_return_plmn() )
                  {
                    if ( name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
                    {
                      network_name_len = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                                  name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_len,
                                                                                  buff_ptr,
                                                                                  NASI_MAX_LEN_NETWORK_NAME/2 );
                      memscpy( (void*)rsp_msg->nas_3gpp_network_info[network_info_index].network_description, NASI_MAX_LEN_NETWORK_NAME, (void*)buff_ptr, network_name_len );
                      if ( network_name_len > 0 )
                      {
                        net_info_available = TRUE;
                      }
                    }
                    else
                    {
                      net_info_available = nasi_convert_mm_info_oper_name(
                                             name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                             name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_encoding,
                                             (char *)rsp_msg->nas_3gpp_network_info[network_info_index].network_description,
                                             &encoding_type,
                                             NASI_MAX_LEN_NETWORK_NAME,
                                             name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_len);
                      if( (encoding_type == NAS_CODING_SCHEME_UCS2_V01) ||
                          (name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
                        )
                      {
                        network_name_len  = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_len);
                      }
                      else
                      {
                        network_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char *)rsp_msg->nas_3gpp_network_info[network_info_index].network_description, NAS_PLMN_NAME_MAX_V01 ));
                      }
                    }
                  }
                  else
                  {
                    if ( name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
                    {
                      network_name_len = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                                  name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len,
                                                                                  buff_ptr,
                                                                                  NASI_MAX_LEN_NETWORK_NAME/2 );
                      memscpy( (void*)rsp_msg->nas_3gpp_network_info[network_info_index].network_description, NASI_MAX_LEN_NETWORK_NAME, (void*)buff_ptr, network_name_len );
                      if ( network_name_len > 0 )
                      {
                        net_info_available = TRUE;
                      }
                    }
                    else
                    {
                    net_info_available = nasi_convert_mm_info_oper_name(
                                           name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                           name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding,
                                           (char *)rsp_msg->nas_3gpp_network_info[network_info_index].network_description,
                                           &encoding_type,
                                           NASI_MAX_LEN_NETWORK_NAME,
                                           name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len);
                      if( (encoding_type == NAS_CODING_SCHEME_UCS2_V01) ||
                          (name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
                        )
                      {
                        network_name_len  = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len);
                      }
                      else
                      {
                        network_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char *)rsp_msg->nas_3gpp_network_info[network_info_index].network_description, NAS_PLMN_NAME_MAX_V01 ));
                      }
                    }
                  }

                  rsp_msg->nw_name_source[network_info_index] = qmi_nas_map_nw_name_source_mmgsdi_to_qmi( name_cnf->plmn_list.plmn_info_ptr[i].plmn_name_source );
                  }
                }
              }
            }

          if( !net_info_available)
          {
             QM_MSG_HIGH_1("Could not get Network name for PLN index %d. Sending only mcc,mnc", sys_plmn_list_index);
          }
          //else
          //{
            //rsp_msg->nas_3gpp_network_info[network_info_index].network_description_len = network_name_len;
          //}
          // End of TLV 0x10

          // TLV 0x11 (Network Radio Access Technology)
          rsp_msg->nas_network_radio_access_technology[network_info_index].mcc = (uint16) mcc;
          rsp_msg->nas_network_radio_access_technology[network_info_index].mnc = (uint16) mnc;

          switch ( available_networks->info[sys_plmn_list_index].rat )
          {
            case SYS_RAT_GSM_RADIO_ACCESS:
              rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_GSM;
              break;

            case SYS_RAT_UMTS_RADIO_ACCESS:
              rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_UMTS;
              break;

            case SYS_RAT_LTE_RADIO_ACCESS:
              rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_LTE;
              break;

            case SYS_RAT_TDS_RADIO_ACCESS:
              rsp_msg->nas_network_radio_access_technology[network_info_index].rat = QMI_NAS_RADIO_IF_TDSCDMA;
              break;

             default:
               QM_MSG_HIGH("RAT is not GSM, UMTS, LTE or TDSCDMA");
               break;
          }
          // End of TLV 0x11

          // TLV 0x12 (MNC PCS digit include status)
          rsp_msg->mnc_includes_pcs_digit[network_info_index].mcc = (uint16) mcc;
          rsp_msg->mnc_includes_pcs_digit[network_info_index].mnc = (uint16) mnc;
          rsp_msg->mnc_includes_pcs_digit[network_info_index].mnc_includes_pcs_digit = mnc_includes_pcs_digit;
          // End of TLV 0x12

#ifdef FEATURE_FEMTO_CSG
          if ( qm_efs_csg_supported() )
          {
          // TLV 0x14 (CSG Information)
          QM_MSG_HIGH_1("Efs csg supported with csg_id=%d", available_networks->info[sys_plmn_list_index].csg_info.csg_id);
          if( available_networks->info[sys_plmn_list_index].csg_info.csg_id != SYS_CSG_ID_INVALID )
          {
            rsp_msg->csg_info[network_info_index].mcc = (uint16) mcc;
            rsp_msg->csg_info[network_info_index].mnc = (uint16) mnc;
            rsp_msg->csg_info[network_info_index].csg_info.id = available_networks->info[sys_plmn_list_index].csg_info.csg_id;
            rsp_msg->csg_info[network_info_index].csg_info.name_len = MIN(available_networks->info[sys_plmn_list_index].csg_info.hnb_name.length, NAS_CSG_NAME_MAX_LEN);
            memscpy(rsp_msg->csg_info[network_info_index].csg_info.name, 
                    rsp_msg->csg_info[network_info_index].csg_info.name_len,
                    available_networks->info[sys_plmn_list_index].csg_info.hnb_name.name, 
                    rsp_msg->csg_info[network_info_index].csg_info.name_len);

            //TLV 0x15
            rsp_msg->csg_sig_info[network_info_index].mcc = (uint16) mcc;
            rsp_msg->csg_sig_info[network_info_index].mnc = (uint16) mnc;
            rsp_msg->csg_sig_info[network_info_index].csg_id = available_networks->info[sys_plmn_list_index].csg_info.csg_id;
            rsp_msg->csg_sig_info[network_info_index].signal_strength = available_networks->info[sys_plmn_list_index].signal_strength;
            QM_MSG_HIGH_3("mcc=%d,csg_id=%d,signal_strength=%d", rsp_msg->csg_sig_info[network_info_index].mcc, rsp_msg->csg_sig_info[network_info_index].csg_id, rsp_msg->csg_sig_info[network_info_index].signal_strength);
            switch( available_networks->info[sys_plmn_list_index].list_category )
            {
              case SYS_DETAILED_PLMN_LIST_ALLOWED_CSG:
                rsp_msg->csg_info[network_info_index].csg_list_cat = (nas_csg_list_cat_enum_v01)QMI_NAS_PERFORM_NW_SCAN_CSG_LIST_CAT_ALLOWED;
                break;
              case SYS_DETAILED_PLMN_LIST_OPERATOR_CSG:
                rsp_msg->csg_info[network_info_index].csg_list_cat = (nas_csg_list_cat_enum_v01)QMI_NAS_PERFORM_NW_SCAN_CSG_LIST_CAT_OPERATOR;
                break;
              default:
                rsp_msg->csg_info[network_info_index].csg_list_cat = (nas_csg_list_cat_enum_v01)QMI_NAS_PERFORM_NW_SCAN_CSG_LIST_CAT_UNKNOWN;
                QM_MSG_MED_1("Received list category %d", available_networks->info[sys_plmn_list_index].list_category);
                break;
            }
            QM_MSG_HIGH_3("network %d, csg_id %d, name_len %d", sys_plmn_list_index, available_networks->info[sys_plmn_list_index].csg_info.csg_id, available_networks->info[sys_plmn_list_index].csg_info.hnb_name.length);
          }
          }
#else
        QM_MSG_HIGH("FEATURE_FEMTO_CSG undefined");
#endif

          // Increment network_info_index
          network_info_index++;
        }
        else
        {
          QM_MSG_HIGH_1("PLMN for index %d undefined", sys_plmn_list_index);
        }
      } // End for (all PLMNs in the list populated)

      // Update the # of instances for TLVs 0x10, 0x11, and 0x12
      rsp_msg->nas_3gpp_network_info_len                       = network_info_index;
      rsp_msg->nas_network_radio_access_technology_len = network_info_index;
      rsp_msg->mnc_includes_pcs_digit_len                       = network_info_index;
      rsp_msg->csg_info_len                                             = network_info_index;
      rsp_msg->csg_sig_info_len                                       = network_info_index;
      rsp_msg->nw_name_source_len                                = network_info_index;

      if ( errval == QMI_ERR_NONE )
      {
        // TLV 0x10 will be available at all times. including for num_instances = 0
        // (Gobi backward compatibility)
        rsp_msg->nas_3gpp_network_info_valid = TRUE;

        if( rsp_msg->nas_network_radio_access_technology_len )
        {
          rsp_msg->nas_network_radio_access_technology_valid = TRUE;
        }

        if( rsp_msg->mnc_includes_pcs_digit_len )
        {
          rsp_msg->mnc_includes_pcs_digit_valid = TRUE;
        }

#ifdef FEATURE_FEMTO_CSG
        if ( qm_efs_csg_supported() )
        {
        if( rsp_msg->csg_info_len && (available_networks->info[0].csg_info.csg_id != SYS_CSG_ID_INVALID) )
        {
          rsp_msg->csg_info_valid = TRUE;
        }
        QM_MSG_HIGH_2("TLV 0x15 len=%d,csg_id=%d", rsp_msg->csg_sig_info_len, available_networks->info[0].csg_info.csg_id); 
        if( rsp_msg->csg_sig_info_len && (available_networks->info[0].csg_info.csg_id != SYS_CSG_ID_INVALID) )
        {
          rsp_msg->csg_sig_info_valid = TRUE;
        }
        }
#endif

        rsp_msg->scan_result_valid = TRUE;
        rsp_msg->scan_result = (nas_scan_result_enum_v01)QMI_NAS_SCAN_SUCCESS;

        if ( rsp_msg->nw_name_source_len )
        {
          rsp_msg->nw_name_source_valid = TRUE;
        }
      }

      // Populate TLV 0x02 (Mandatory error code)
      rsp_msg->resp.result  = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01;
      rsp_msg->resp.error   = (qmi_error_type_v01)errval;

      response = NULL;

      if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                         QMI_IDL_RESPONSE,
                                         (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                         (void *) rsp_msg,
                                         (uint32_t) sizeof(nas_perform_network_scan_resp_msg_v01),
                                         &response
                                       ) )
      {
        if( !qmi_nasi_send_response(cmd_buf_p, response) )
        {
          qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );

        }
      }
      else
      {
        dsm_free_packet(&response);
        qmi_mmode_svc_free_transaction_cmd_buf(&cmd_buf_p);
      }
    } // End if
  }// end while (cmd buf queue is empty)

  if ( available_networks != NULL )
  {
    modem_mem_free( available_networks, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  if ( callback_data != NULL )
  {
    modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
  }

  if ( rsp_msg ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_HOME_NETWORK_RESPONSE()

  DESCRIPTION
    Generate Get_home_network response after mmgsdi callback

  PARAMETERS
    name_cnf : mmgsdi information

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_home_network_resp( const mmgsdi_session_get_operator_name_cnf_type *name_cnf )
    {
  struct qmi_nasi_mmgsdi_client_data_s *callback_data = NULL;
  qmi_cmd_buf_type                     *cmd_buf_p = NULL;
  dsm_item_type                        *response  = NULL;
  qmi_error_e_type                      errval = QMI_ERR_NONE;

   nas_get_home_network_resp_msg_v01  *resp_msg;

  struct qmi_nas_mmgsdi_cache_s *p_cache; // shorthand
  qmi_nas_mmgsdi_session_e_type  qmi_session = QMI_NAS_MMGSDI_SESSION_MAX;
  sys_plmn_id_s_type             home_plmn_id;
  boolean                        mnc_includes_pcs_digit = FALSE;
  uint8                          plmn_name_short_encoding;
  int j = 0;

  callback_data = (struct qmi_nasi_mmgsdi_client_data_s *) name_cnf->response_header.client_data;
  if ( callback_data != NULL )
  {
    cmd_buf_p = (qmi_cmd_buf_type *) callback_data->cmd_buf_ptr;
    if (!qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL)
    {
      QM_MSG_HIGH("Received NULL cmd_buf in GET_HOME_NETWORK callback");
    if( callback_data != NULL )
    {
        modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
    }
      return;
    }
  }
  else
  {
    QM_MSG_ERROR("callback_data is NULL!");
    ASSERT(0);
    return;
  }

  resp_msg = (nas_get_home_network_resp_msg_v01 *) 
  	modem_mem_alloc( sizeof( nas_get_home_network_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  if( resp_msg == NULL)
  {
  	qmi_voice_mem_error();
	if( callback_data != NULL )
       {
         modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
       }
	return;
  }
  
  memset(resp_msg, 0, sizeof(nas_get_home_network_resp_msg_v01));

  // Update current PLMN based on subscription
  switch ( ((qmi_nasi_client_state_type*)cmd_buf_p->x_p->cl_sp)->report_status.bound_subs )
  {
  case QMI_NAS_SUBS_PRIMARY:
    qmi_session = QMI_NAS_MMGSDI_GW_PRI_SESSION;
    break;
#ifdef FEATURE_DUAL_SIM
  case QMI_NAS_SUBS_SECONDARY:
    qmi_session = QMI_NAS_MMGSDI_GW_SEC_SESSION;
    break;
#endif
#ifdef FEATURE_TRIPLE_SIM    
  case QMI_NAS_SUBS_TERTIARY:
    qmi_session = QMI_NAS_MMGSDI_GW_TER_SESSION;
    break;
#endif
  default:
    MSG_ERROR("Invalid subs %d", ((qmi_nasi_client_state_type*)cmd_buf_p->x_p->cl_sp)->report_status.bound_subs, 0, 0);
    break;
  }

  /*-----------------------------------------------------------------------
    Home MCC & MNC should be available by now. Copy from global to local
  -----------------------------------------------------------------------*/
  if ( qmi_nas_mmgsdi_is_valid_qmi_session(qmi_session) )
  {
    p_cache = &qmi_nasi_global.mmgsdi.cache[qmi_session]; // shorthand

    if ( p_cache->ef_ad_valid   == QMI_NAS_MMGSDI_VALID &&
         p_cache->ef_imsi_valid == QMI_NAS_MMGSDI_VALID )
    {
      if ( p_cache->ef_imsi[0] == 0xFF && p_cache->ef_imsi[1] == 0xFF && p_cache->ef_imsi[2] == 0xFF )
      {
        QM_MSG_ERROR("Invalid IMSI");
        errval = QMI_ERR_INTERNAL;
      }
      else
      {
        resp_msg->home_network.mobile_country_code = (100 * QMI_NAS_BCD_HIGH_DIGIT(p_cache->ef_imsi[1])) + (10 * QMI_NAS_BCD_LOW_DIGIT(p_cache->ef_imsi[2])) + QMI_NAS_BCD_HIGH_DIGIT(p_cache->ef_imsi[2]);
        resp_msg->home_network.mobile_network_code = (10 * QMI_NAS_BCD_LOW_DIGIT(p_cache->ef_imsi[3])) + QMI_NAS_BCD_HIGH_DIGIT(p_cache->ef_imsi[3]);
  
        // if EF_AD size is 4 or more, 4th byte carries MNC length info
        // marked as optional in 3GPP TS 11.11 V8.14.0 cl. 10.3.18 EFAD
        // marked as mandatory in 3GPP TS 31.102 V8.8.0 cl. 4.2.18 EFAD
        if ( p_cache->ef_ad_size >= 4 )
        {
          if ( (p_cache->ef_ad[3] & 0x0F) == 0x03 ) // MNC length is 3
          {
            resp_msg->home_network.mobile_network_code = (10 * resp_msg->home_network.mobile_network_code) + QMI_NAS_BCD_LOW_DIGIT(p_cache->ef_imsi[4]);
            mnc_includes_pcs_digit = TRUE;
          }
        }
  
        resp_msg->nas_3gpp_mcs_include_digit.is_3gpp_network            = TRUE;
  
        if( resp_msg->home_network.mobile_network_code > 99 )
        {
          resp_msg->nas_3gpp_mcs_include_digit.mnc_includes_pcs_digit  = TRUE;
        }
        else
        {
          resp_msg->nas_3gpp_mcs_include_digit.mnc_includes_pcs_digit  = FALSE;
        }
  
        resp_msg->nas_3gpp_mcs_include_digit_valid = TRUE;
      }
    }
    else
    {
      errval = QMI_ERR_NOT_PROVISIONED;
    }
  }
  else
  {
    errval = QMI_ERR_INTERNAL;
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( sys_plmn_set_mcc_mnc(mnc_includes_pcs_digit, resp_msg->home_network.mobile_country_code, resp_msg->home_network.mobile_network_code, &home_plmn_id) == TRUE )
    {
      if( name_cnf->response_header.mmgsdi_status == MMGSDI_SUCCESS )
      {
        if( name_cnf->plmn_list.num_of_plmn_ids > 0 && name_cnf->plmn_list.plmn_info_ptr != NULL )
        {
          QM_MSG_HIGH_2("get home network len %d, encoding %d", name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len, name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding);
          for( j=0; j<name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len; j++ )
          {
            QM_MSG_HIGH_1("%d", name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr[j]);
          }

          if ( qm_efs_always_return_plmn() )
          {
            if ( !nasi_convert_mm_info_oper_name( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding,
                                                 (char *) resp_msg->home_network.network_description,
                                                 &plmn_name_short_encoding,
                                                 NAS_NETWORK_DESCRIPTION_MAX_V01,
                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len ) )

            {
              QM_MSG_ERROR("qmi_nasi_generate_get_home_network_resp: decoding failed, sending encoded name in response");
              memscpy( resp_msg->home_network.network_description, name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len,
                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr, 
                       name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len );
            }
          }
          else
          {
            if ( !nasi_convert_mm_info_oper_name( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding,
                                                 (char *) resp_msg->home_network.network_description,
                                                 &plmn_name_short_encoding,
                                                 NAS_NETWORK_DESCRIPTION_MAX_V01,
                                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len ) )
  
            {
              QM_MSG_ERROR("qmi_nasi_generate_get_home_network_resp: decoding failed, sending encoded name in response");
            memscpy( resp_msg->home_network.network_description, name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len,
                     name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr, 
                     name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len );
            }
          }

          resp_msg->nas_3gpp_nw_name_source_valid = TRUE;
          resp_msg->nas_3gpp_nw_name_source = qmi_nas_map_nw_name_source_mmgsdi_to_qmi( name_cnf->plmn_list.plmn_info_ptr[0].plmn_name_source );
        }
      }
    }
  }

  resp_msg->resp.error  = (qmi_error_type_v01)errval;
  resp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01;

  if( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t) QMI_NAS_GET_HOME_NETWORK_RESP_MSG_V01,
                                (void *)resp_msg,
                                (uint32_t)sizeof(nas_get_home_network_resp_msg_v01),
                                &response
                              ) )
  {
    if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
       /*Unable to send GET PLMN NAME response*/
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }

  }

  if( resp_msg != NULL ) { modem_mem_free( resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if( callback_data != NULL ) { modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE ); }

}


/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_RTRE_CONFIG_IND()

  DESCRIPTION
    Generate RTRE config indication

  PARAMETERS
    cm_ph_info_s_type *p_ph_info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_rtre_config_ind(
    qmi_cm_ph_info_s_type *p_ph_info
)
{
  int                         clid;
  qmi_nasi_client_state_type *cl_sp;
  dsm_item_type              *ind;

  struct nas_006A_ind_s rtre_config_ind_msg;

  memset( &rtre_config_ind_msg, 0x00, sizeof(rtre_config_ind_msg));

  for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
  {
    cl_sp = qmi_nas_state.client[clid];

    if ( cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
         cl_sp->report_status.report_rtre_config)
    {
      //Check if the ind is to be sent
      if ( p_ph_info->rtre_control != qmi_nasi_global.cm_ph_info.rtre_control ||
           p_ph_info->rtre_config  != qmi_nasi_global.cm_ph_info.rtre_config )
      {
        // Send both TLVs whenever sending this indication
        rtre_config_ind_msg.t10_valid    = TRUE;
        rtre_config_ind_msg.t11_valid    = TRUE;

        // TLV 0x10
        switch( p_ph_info->rtre_control )
        {
          case CM_RTRE_CONTROL_RUIM:
            rtre_config_ind_msg.t10.rtre_cfg  = (uint8)NAS_RTRE_CFG_RUIM_ONLY;
            break;
          case CM_RTRE_CONTROL_NV:
            rtre_config_ind_msg.t10.rtre_cfg  = (uint8)NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY;
            break;
          case CM_RTRE_CONTROL_SIM:
            rtre_config_ind_msg.t10.rtre_cfg  = (uint8)NAS_RTRE_CFG_GSM_ON_1X;
            break;
          default:
            // Unkown RTRE CFG value. Not including the TLV
            QM_MSG_HIGH_1("Unkown rtre control value: %d.", p_ph_info->rtre_control);
            rtre_config_ind_msg.t10_valid    = FALSE;
            break;
        }

        // TLV 0x11
        switch( p_ph_info->rtre_config )
        {
          case CM_RTRE_CONFIG_RUIM_ONLY:
            rtre_config_ind_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_RUIM_ONLY;
            break;
          case CM_RTRE_CONFIG_NV_ONLY:
            rtre_config_ind_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY;
            break;
          case CM_RTRE_CONFIG_RUIM_OR_DROP_BACK:
            rtre_config_ind_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_RUIM_IF_AVAIL;
            break;
          case CM_RTRE_CONFIG_SIM_ACCESS:
            rtre_config_ind_msg.t11.rtre_cfg_pref  = (uint8)NAS_RTRE_CFG_GSM_ON_1X;
            break;
          default:
            // Error in Getting  rtre_pref data
            QM_MSG_HIGH_1("Unkown rtre config value: %d", p_ph_info->rtre_config);
            rtre_config_ind_msg.t11_valid    = FALSE;
            break;
        }
      }
      if( rtre_config_ind_msg.t10_valid || rtre_config_ind_msg.t11_valid)
      {
        ind = NULL;

        if( qmi_nas_006A_ind_write ( &rtre_config_ind_msg, &ind) == QMI_ERR_NONE  )
        {
          (void)qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_RTRE_CONFIG_IND, ind );
        }
      }
    }
  }
} //qmi_nas_generate_rtre_config_ind

/*===========================================================================
  FUNCTION QMI_NASI_GET_MANAGED_ROAMING_CONFIG ()

  DESCRIPTION
    Queries and returns the current managed roaming configuration information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_managed_roaming_config
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
     )
  {
  dsm_item_type *    response = NULL;
  qmi_error_e_type   errval   = QMI_ERR_NONE;
  nv_item_type       nv_item;
  enum qmi_nas_subs_e  as_id;

  struct nas_0069_rsp_s  nas_0069_rsp;
  nv_stat_enum_type      nv_status;

  if( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
    {
    QM_MSG_ERROR_4("qmi_nasi_get_managed_roaming_config: NULL ptr sp:%d cmd_buf_p:%d, cl_sp:%d sdu_in:%d", sp, cmd_buf_p, cl_sp, sdu_in);
  }
  as_id = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
  if( (as_id >= QMI_NAS_SUBS_MAX) || (as_id <= QMI_NAS_SUBS_NONE) )
  {
    QM_MSG_ERROR("qmi_nasi_get_managed_roaming_config(): Received invalid as_id from client state pointer.");
    return response;
  }
  memset(&nas_0069_rsp, 0x00, sizeof(struct nas_0069_rsp_s));

  nv_status = qmi_mmode_get_nv_item_ext (NV_MGRF_SUPPORTED_I, &nv_item,(uint16)as_id);

  if ( nv_status == NV_DONE_S )
      {
    nas_0069_rsp.t10.managed_roaming_supported = (uint8) nv_item.mgrf_supported;
    nas_0069_rsp.t10_valid = TRUE;
      }
      else
      {
    QM_MSG_ERROR_1("qmi_nasi_get_managed_roaming_config: Could not read NV_MGRF_SUPPORTED_I. nv status: %d", nv_status);
    errval = QMI_ERR_INTERNAL;
      }

  nas_0069_rsp.t02.result_code = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  nas_0069_rsp.t02.error_code  = errval;
  nas_0069_rsp.t02_valid       = TRUE;

  if ( qmi_nas_0069_rsp_write( &nas_0069_rsp, &response) != QMI_ERR_NONE )
  {
    response = NULL;
    }

  return response;
  }

/*===========================================================================
  FUNCTION QMI_NASI_GET_CENTRALIZED_EONS_SUPPORT_STATUS ()

  DESCRIPTION
    Queries and returns the status of centralized eons support

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_centralized_eons_support_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
    {
  dsm_item_type *  response = NULL;

  qmi_error_e_type   errval = QMI_ERR_NONE;

  struct nas_006B_rsp_s nas_006B_rsp;

  memset( &nas_006B_rsp, 0x00, sizeof(nas_006B_rsp));

  if ( errval == QMI_ERR_NONE )
  {
    // always return true for centralized eons supported
    nas_006B_rsp.t10.centralized_eons_supported = TRUE;
    nas_006B_rsp.t10_valid = TRUE;
    }

  nas_006B_rsp.t02.result_code = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE;
  nas_006B_rsp.t02.error_code  = errval;
  nas_006B_rsp.t02_valid       = TRUE;

  if ( qmi_nas_006B_rsp_write( &nas_006B_rsp, &response) != QMI_ERR_NONE )
    {
    response = NULL;
  }

  return response;

    }

/*===========================================================================
  FUNCTION QMI_NASI_CONFIG_SIG_INFO2()

  DESCRIPTION
    To set thresholds for reporting sig info indication msg

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None
    (This message is DS/DS agnostic)

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_config_sig_info2
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_nasi_client_state_type        *nasi_client_sp = (qmi_nasi_client_state_type *)cl_sp;
  qmi_error_type_v01                errval          = QMI_ERR_NONE_V01;
  dsm_item_type                     * response      = NULL;
  nas_config_sig_info2_req_msg_v01        * req_msg;
  nas_config_sig_info2_resp_msg_v01       * rsp_msg;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %d cmd_buf_p %d cl_sp %d sdu_in %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  req_msg = (nas_config_sig_info2_req_msg_v01  *) modem_mem_alloc( sizeof(nas_config_sig_info2_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_config_sig_info2_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_config_sig_info2_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
    {
    memset( req_msg, 0x00, sizeof(nas_config_sig_info2_req_msg_v01) );
    }

  if ( errval == QMI_ERR_NONE_V01 )
    {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *)   req_msg,
                                           (uint32_t) sizeof(nas_config_sig_info2_req_msg_v01)
                                         );
    }

  if ( errval == QMI_ERR_NONE_V01 )
    {
    errval = qmi_nas_006C_req_check( req_msg );
    }

  if ( errval == QMI_ERR_NONE_V01 )
    {
    qm_nas_clnt_process_config_sig_info2( nasi_client_sp->common.clid, req_msg );
  } // End copy all thresholds

#ifdef FEATURE_LTE
  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( req_msg->lte_sig_rpt_config_valid )
    {
      if ( ! cmapi_set_lte_signal_reporting_config( ( cmapi_lte_signal_reporting_rate_e )req_msg->lte_sig_rpt_config.rpt_rate,
                                                    ( cmapi_lte_signal_averaging_period_e )req_msg->lte_sig_rpt_config.avg_period ) )
      {
        QM_MSG_HIGH("cmapi_set_lte_signal_reporting_config failed");
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
  }
#endif // FEATURE_LTE

  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( !qmi_nasi_global.is_set_cm_ph_cmd_signal_strength_delta )
    {
      if (!cm_ph_cmd_signal_strength_delta_lte( qmi_nas_cmph_cmd_cb,
                                                cmd_buf_p,
                                                qmi_nasi_global.cm_clnt_id,
                                                NASI_MIN_SIG_INFO_DELTA, //rssi
                                                NASI_MIN_SIG_INFO_DELTA, //ecio
                                                NASI_MIN_SIG_INFO_DELTA, //io
                                                NASI_MIN_SIG_INFO_DELTA, //sinr
                                                NASI_SIG_STRENGTH_DELTA_NO_CHANGE, //pathloss
                                                NASI_SIG_STRENGTH_DELTA_NO_CHANGE, //cqi
                                                NASI_MIN_SIG_INFO_DELTA, //rsrp
                                                NASI_MIN_SIG_INFO_DELTA)) //rsrq
      {
        QM_MSG_ERROR("Unable to set rssi, ecio, io, sinr, rsrp and rsrq delta");
        errval = QMI_ERR_INTERNAL_V01;
      }
      else
      {
        QM_MSG_HIGH("Response pending for Set rssi, ecio, io, sinr, rsrp and rsrq delta ");
        qmi_nasi_global.is_pending_config_sig_info = TRUE;
      }
    }
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.is_pending_config_sig_info )
  {
    response = (dsm_item_type*) QMI_SVC_RESPONSE_PENDING;
    QM_MSG_HIGH("qmi_nasi_config_sig_info2() returning QMI_SVC_RESPONSE_PENDING");
  }
  else if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if ( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_config_sig_info2_resp_msg_v01) );

    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = ( errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_config_sig_info2_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}

#ifdef FEATURE_TDSCDMA
/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_TDS_CELL_AND_POSITION_INFO_RSP ()

  DESCRIPTION
    Returns TDSCDMA Cell and Position information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_tds_cell_and_position_info_rsp
(
 qmi_mmodei_msgr_type * msg_p
)
{
  dsm_item_type *  response = NULL;
  int cell_idx = 0;
  qmi_error_e_type   errval = QMI_ERR_NONE;
  nas_get_tds_cell_and_position_info_resp_msg_v01 *rsp_msg;
  qmi_cmd_buf_type *cmd_buf_p = NULL;

  rsp_msg = (nas_get_tds_cell_and_position_info_resp_msg_v01 *) 
  	modem_mem_alloc( sizeof(nas_get_tds_cell_and_position_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    goto end_get_tds_cell_and_position_info_rsp;
  }
  memset (rsp_msg, 0x00, sizeof(nas_get_tds_cell_and_position_info_resp_msg_v01));


  cmd_buf_p = (qmi_cmd_buf_type *) msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.p_usr_data;

  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_HIGH_1("Received NULL cmd_buf in GET_TDS_CELL_AND_POS_INFO resp: %d", cmd_buf_p);
    goto end_get_tds_cell_and_position_info_rsp;
  }

  if ( errval == QMI_ERR_NONE )
  {
    if ( msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.success_flag )
    {
      // TLV 0x10 cell info
      rsp_msg->tds_cell_info_valid = TRUE;

      rsp_msg->tds_cell_info.plmn.mcc = ( msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mcc[2] +
                                    msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mcc[1] * 10 +
                                    msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mcc[0] * 100);

      if ( msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.num_mnc_digits == 3)
      {
         rsp_msg->tds_cell_info.plmn.mnc_includes_pcs_digit = TRUE;

        rsp_msg->tds_cell_info.plmn.mnc = ( msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mnc[2] +
                                      msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mnc[1] * 10 +
                                      msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mnc[0] * 100 ) ;
      }
      else
      {
        rsp_msg->tds_cell_info.plmn.mnc_includes_pcs_digit = FALSE;
        rsp_msg->tds_cell_info.plmn.mnc = ( msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mnc[1] +
                                      msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.mnc[0] * 10 ) ;
      }

      rsp_msg->tds_cell_info.lac |=  msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.lac[0] ;
      rsp_msg->tds_cell_info.lac <<= 8;
      rsp_msg->tds_cell_info.lac |=  msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.lac[1] ;

      rsp_msg->tds_cell_info.uarfcn  =  msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.uarfcn ;
      rsp_msg->tds_cell_info.cell_id =  msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.cell_id ;
      rsp_msg->tds_cell_info.cell_parameter_id =  msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.cell_parameter_id ;
      rsp_msg->tds_cell_info.pathloss =  msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.pathloss ;
      rsp_msg->tds_cell_info.timing_advance =  (float)((float) msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.timing_advance * 128 / 8.0)/ 1000.0;
      rsp_msg->tds_cell_info.rscp     = (float) msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.serv_cell.rscp / 256.0;

      // Include TLV 0x11 only neighbor cell info available
      if ( msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.nbr_success_flag )
      {
        rsp_msg->tds_nbr_cell_info_valid = TRUE;

        rsp_msg->tds_nbr_cell_info_len = msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.num_ncell;

        for ( cell_idx = 0 ; cell_idx < msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.num_ncell && cell_idx < NAS_TDS_MAX_NBR_CELL_NUM_V01; cell_idx++ )
        {
          rsp_msg->tds_nbr_cell_info[cell_idx].uarfcn = msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.nbr_ncell[cell_idx].uarfcn ;
          rsp_msg->tds_nbr_cell_info[cell_idx].cell_parameter_id = msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.nbr_ncell[cell_idx].cell_parameter_id ;
          rsp_msg->tds_nbr_cell_info[cell_idx].rscp = (float) msg_p->cmd.qmi_nas.tds_cell_and_nbr_pos_info_rsp.nbr_ncell[cell_idx].rscp / 256.0;
        }
      }
    }
    else
    {
      errval = QMI_ERR_INFO_UNAVAILABLE;
    }
  }

  rsp_msg->resp.error  = (qmi_error_type_v01)errval;
  rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

  if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                              QMI_IDL_RESPONSE,
                                              (uint16_t) QMI_NAS_GET_TDS_CELL_AND_POSITION_INFO_RESP_MSG_V01,
                                              (void *) rsp_msg,
                                              (uint32_t) sizeof( nas_get_tds_cell_and_position_info_resp_msg_v01 ),
                                              &response
                                            ) )
  {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
        /*Unable to send GET_TDS_CELL_AND_POSITION_INFO response*/
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }
  
  end_get_tds_cell_and_position_info_rsp:
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}
#endif

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_EMBMS_SIG_RSP ()

  DESCRIPTION
    Returns eMBMS signal strength information

===========================================================================*/
void qmi_nasi_generate_get_embms_sig_rsp( qmi_mmodei_msgr_type * msg_p )
{
  dsm_item_type         *response = NULL;
#ifdef FEATURE_LTE_EMBMS
  int                   i;
#endif
  qmi_error_e_type      errval = QMI_ERR_NONE;
  nas_get_embms_sig_resp_msg_v01 *rsp_msg;
  qmi_cmd_buf_type      *cmd_buf_p = qmi_nasi_global.cmd_buf_p;

  rsp_msg = (nas_get_embms_sig_resp_msg_v01  *) 
  	modem_mem_alloc( sizeof(nas_get_embms_sig_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  
  if ( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    goto end_get_embms_sig_rsp;
  }

  memset( rsp_msg, 0x00, sizeof(nas_get_embms_sig_resp_msg_v01));

  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in QMI_NAS_GET_EMBMS_SIG resp: %d", cmd_buf_p);
    goto end_get_embms_sig_rsp; //nothing to send
  }

#ifdef FEATURE_LTE_EMBMS
  if ( errval == QMI_ERR_NONE )
  {
    rsp_msg->trace_id_valid= TRUE;
    rsp_msg->trace_id = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.debug_trace_id;

    for ( i=0; i<NAS_LTE_EMBMS_MAX_MBSFN_AREA_V01 && i<msg_p->cmd.qmi_nas.embms_sig_cnf_ext.num_mbsfn_areas ; i++ )
    {
      rsp_msg->sig_list[i].area_id      = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].area_id;
      rsp_msg->sig_list[i].snr          = (float)(msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].snr)/8.0;
      //nas_006F_rsp.t11.sig_list[i].signal_level = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].signal_level;

      QM_MSG_HIGH_3("qmi_nasi_generate_get_embms_sig_rsp: area_id = %d, snr = %f, signal_level = %d", rsp_msg->sig_list[i].area_id, rsp_msg->sig_list[i].snr, rsp_msg->sig_list[i].signal_level);
    }
    rsp_msg->sig_list_len = i;
    rsp_msg->sig_list_valid        = TRUE;
  }
#else
  if( errval == QMI_ERR_NONE )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }
#endif

  rsp_msg->resp.result  = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
  rsp_msg->resp.error   = (qmi_error_type_v01)errval;

  if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_get_embms_sig_resp_msg_v01),
                                     &response
                                   ) )
  {
    if( !qmi_nasi_send_response(cmd_buf_p, response) )
    {
        /*Unable to send Network Scan response*/
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
    }
  }
  else
  {
      dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }

end_get_embms_sig_rsp:
  qmi_nasi_global.cmd_buf_p = NULL;
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  	
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_TDS_CELL_AND_POSITION_INFO ()

  DESCRIPTION
    Returns TDSCDMA Cell and Position information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_tds_cell_and_position_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
#ifdef FEATURE_TDSCDMA
  errno_enum_type      msgr_err;
#endif
  nas_get_tds_cell_and_position_info_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_tds_cell_and_position_info_resp_msg_v01 *) 
  	modem_mem_alloc( sizeof(nas_get_tds_cell_and_position_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    ASSERT(0);
    goto end_get_tds_cell_and_position_info;
  }
  memset (rsp_msg, 0x00, sizeof(nas_get_tds_cell_and_position_info_resp_msg_v01));

#ifdef FEATURE_TDSCDMA
  if ( !TARGET_SUPPORTS_TDS )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }

  if ( errval == QMI_ERR_NONE )
    {
    tds_rrc_gps_pos_cell_info_req_type msg;

    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, TDSCDMA_RRC_GPS_POS_CELL_INFO_REQ);

    msg.p_user_data = (void *) cmd_buf_p;

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR_1("TDSCDMA_RRC_GPS_POS_CELL_INFO_REQ send fail %d", msgr_err);
    }

}
#else
  QM_MSG_HIGH("FEATURE_TDSCDMA not defined");
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
#endif

  if ( errval == QMI_ERR_NONE )
    {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
      // Will respond after getting RSP message through MSGR
  }
  else
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_tds_cell_and_position_info_resp_msg_v01),
                                  &response
                                );
  }
end_get_tds_cell_and_position_info:
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_tds_cell_and_position_info() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_HPLMN_IRAT_SEARCH_TIMER()

  DESCRIPTION
    Sets periodic search timer configuration for home-operator specific BPLMN search to LTE.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_set_hplmn_irat_search_timer
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response = NULL;
  qmi_error_e_type   errval = QMI_ERR_NONE;

  struct nas_006E_req_s nas_006E_req;
  struct nas_006E_rsp_s nas_006E_rsp;
  uint32 cm_timer_value = 0xFFFFFFFF;

  memset( &nas_006E_req, 0x00, sizeof(nas_006E_req));
  memset( &nas_006E_rsp, 0x00, sizeof(nas_006E_rsp));

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL;
}

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_006E_req_read( &nas_006E_req, sdu_in );
  }

  if ( errval == QMI_ERR_NONE )
  {
    errval = qmi_nas_006E_req_check( &nas_006E_req );
  }

  if ( errval == QMI_ERR_NONE )
  {
     cm_timer_value = ( nas_006E_req.t01.timer_value < 0xFFFF ) ? 60000*nas_006E_req.t01.timer_value : 0xFFFFFFFF ;

     if( !cm_ph_cmd_set_tl_irat_search_timer_req( qmi_nas_cmph_cmd_cb,
                                                  (void *)cmd_buf_p,
                                                  qmi_nasi_global.cm_clnt_id,
                                                  cm_timer_value ) )
    {
      errval = QMI_ERR_INTERNAL;
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    // wait for cm callback
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    nas_006E_rsp.t02.result_code = QMI_RESULT_FAILURE;
    nas_006E_rsp.t02.error_code  = errval;
    nas_006E_rsp.t02_valid       = TRUE;

    if ( qmi_nas_006E_rsp_write ( &nas_006E_rsp, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }
  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_EMBMS_SIG ()

  DESCRIPTION
    Retrieves eMBMS signal strength information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_embms_sig
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type        *response = NULL;
  qmi_error_e_type      errval = QMI_ERR_NONE;
#ifdef FEATURE_LTE_EMBMS
  errno_enum_type       msgr_err;
#endif
  nas_get_embms_sig_req_msg_v01 req_msg;
  nas_get_embms_sig_resp_msg_v01 rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset( &req_msg, 0x00, sizeof(nas_get_embms_sig_req_msg_v01));
  memset( &rsp_msg, 0x00, sizeof(nas_get_embms_sig_resp_msg_v01));

  if ( qmi_nasi_global.cmd_buf_p == NULL )
  {
    qmi_nasi_global.cmd_buf_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY;
  }

#ifdef FEATURE_LTE_EMBMS
  if (errval == QMI_ERR_NONE)
  {
     // extract information from REQ message
     errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *) &req_msg,
                                           (uint32_t) sizeof(nas_get_embms_sig_req_msg_v01)
                                         );
  }

  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_006F_req_check (&req_msg);
  }

  if ( errval == QMI_ERR_NONE )
  {
    lte_rrc_embms_signal_strength_report_req_s msg;

    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_EMBMS_SIGNAL_STRENGTH_REQ );

    msg.debug_trace_id = req_msg.trace_id_valid? req_msg.trace_id : -1;

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR_1("LTE_RRC_EMBMS_SIGNAL_STRENGTH_REQ send fail %d", msgr_err);
    }
  }
#else
  if( errval == QMI_ERR_NONE )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
  }
#endif

  if ( errval == QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
    QM_MSG_HIGH("Sent response pending for QMI_NAS_GET_EMBMS_SIG to QMI Framework");
    // Will respond after getting RSP message through MSGR
  }
  else
  {
    rsp_msg.resp.result  = (qmi_result_type_v01)QMI_RESULT_FAILURE;
    rsp_msg.resp.error  = (qmi_error_type_v01)errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                (void *) &rsp_msg,
                                (uint32_t) sizeof(nas_get_embms_sig_resp_msg_v01),
                                &response
                              );

    qmi_nasi_global.cmd_buf_p = NULL;
  }
  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_LIMIT_SYS_INFO_IND_REPORTING ()

  DESCRIPTION
    Sets limitations on the reporting of QMI_NAS_SYS_INFO_IND.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_limit_sys_info_ind_reporting
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response  = NULL;
  qmi_nasi_client_state_type *nasi_client_sp;
  qmi_error_e_type            errval = QMI_ERR_NONE;
  struct nas_0070_req_s       req_msg;
  struct nas_0070_rsp_s       rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&req_msg, 0, sizeof(req_msg));
  memset(&rsp_msg, 0, sizeof(rsp_msg));

  nasi_client_sp = (qmi_nasi_client_state_type *) cl_sp;

  errval = qmi_nas_0070_req_read(&req_msg, sdu_in);
  QM_MSG_HIGH_1("TLV 0x01 in QMI_NAS_LIMIT_SYS_INFO_IND_REPORTING %ull", req_msg.t01.limit_sys_info_rpt_chg);

  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_0070_req_check(&req_msg);
  }

  if (errval == QMI_ERR_NONE)
  {
    struct report_status_s *p_rs = &nasi_client_sp->report_status;

    p_rs->limit_sys_info_reporting_mask = req_msg.t01.limit_sys_info_rpt_chg;
  }

  rsp_msg.t02.result_code = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0070_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_NONE;
  }

  return response;
} /* qmi_nasi_limit_sys_info_ind_reporting */


/*===========================================================================
  FUNCTION QMI_NASI_GET_SYS_INFO_IND_REPORTING_LIMIT ()

  DESCRIPTION
    Returns limitations set on QMI_NAS_SYS_INFO_IND reporting.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_sys_info_ind_reporting_limit
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response = NULL;
  qmi_nasi_client_state_type *nasi_client_sp;
  qmi_error_e_type            errval    = QMI_ERR_NONE;
  struct nas_0071_rsp_s       rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&rsp_msg, 0, sizeof(rsp_msg));

  nasi_client_sp = (qmi_nasi_client_state_type *) cl_sp;

  rsp_msg.t01_valid = TRUE;
  rsp_msg.t01.limit_sys_info_rpt_chg = nasi_client_sp->report_status.limit_sys_info_reporting_mask;

  rsp_msg.t02.result_code = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);
  rsp_msg.t02.error_code  = errval;
  rsp_msg.t02_valid       = TRUE;

  if ( qmi_nas_0071_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_NONE;
  }

  return response;
} /* qmi_nasi_get_sys_info_ind_reporting_limit */


/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_SE13_PLMN_NAME_RESP()

  DESCRIPTION
    send response for get_plmn_name after mmgsdi callback

  PARAMETERS
    name_cnf : mmgsdi callback information

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_se13_plmn_name_resp( const mmgsdi_get_se13_plmn_names_cnf_type *name_cnf )
{
  dsm_item_type                        *response = NULL;
  qmi_error_type_v01                    errval = QMI_ERR_NONE_V01;
  nas_get_plmn_name_resp_msg_v01       *rsp_msg;
  struct qmi_nasi_mmgsdi_client_data_s *callback_data = NULL;
  qmi_cmd_buf_type                     *cmd_buf_p = NULL;
  uint16 buff_ptr[(NASI_MAX_LEN_NETWORK_NAME/2)];
  int i = 0;
  uint8 tmp_buf[NAS_ALT_LANG_NAME_LEN_MAX_V01*2] = { 0 };

  callback_data = (struct qmi_nasi_mmgsdi_client_data_s *) name_cnf->response_header.client_data;
  if( callback_data != NULL )
  {
    cmd_buf_p = (qmi_cmd_buf_type *) callback_data->cmd_buf_ptr;
    if ( qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
    {
      rsp_msg = (nas_get_plmn_name_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_plmn_name_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

      if( rsp_msg != NULL )
      {
        memset( rsp_msg, 0x00, sizeof(nas_get_plmn_name_resp_msg_v01) );

      if( name_cnf->response_header.mmgsdi_status == MMGSDI_SUCCESS )
      {
        if( name_cnf->plmn_list.num_of_plmn_ids == 1 && name_cnf->plmn_list.plmn_info_ptr != NULL ) // get_plmn_name request a single name
        {
            QM_MSG_HIGH_4("Names found: short len=%d, long len=%d, Encoding: short = %d, long = %d", name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len, 
				name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len,name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding, 
				name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding);


            qm_util_print_bytes( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr, 
                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len );
            qm_util_print_bytes( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr, 
                                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len );

            rsp_msg->eons_plmn_name_3gpp_valid = TRUE;

            rsp_msg->eons_plmn_name_3gpp.spn_enc = NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01;
            rsp_msg->eons_plmn_name_3gpp.spn_len = 0;

          if( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
          {
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_ci;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_spare_bits;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                                        name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len,
                                                                                        buff_ptr,
                                                                                        NASI_MAX_LEN_NETWORK_NAME/2 );
              memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.plmn_long_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len );
          }
          else if( nasi_convert_mm_info_oper_name( name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_ptr,
                                              name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding,
                                                     (char *) rsp_msg->eons_plmn_name_3gpp.plmn_long_name,
                                                     (uint8 *)&rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc,
                                              NASI_MAX_LEN_NETWORK_NAME,
                                              name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len ) )
          {
            rsp_msg->eons_plmn_name_3gpp.plmn_long_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_ci;
            rsp_msg->eons_plmn_name_3gpp.plmn_long_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name_spare_bits;
            if( (rsp_msg->eons_plmn_name_3gpp.plmn_long_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
                (name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
              )
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, name_cnf->plmn_list.plmn_info_ptr[0].plmn_long_name.plmn_name.eons_data.data_len);
            }
            else
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_long_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)rsp_msg->eons_plmn_name_3gpp.plmn_long_name, NAS_PLMN_NAME_MAX_V01 ));
            }
          }

          if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
          {
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_ci;
              rsp_msg->eons_plmn_name_3gpp.plmn_short_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_spare_bits;
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc   = NAS_CODING_SCHEME_UCS2_V01;
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len   = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                                         name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len,
                                                                                         buff_ptr,
                                                                                         NASI_MAX_LEN_NETWORK_NAME/2 );
              memscpy( (void*)rsp_msg->eons_plmn_name_3gpp.plmn_short_name, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len );
          }
          else if ( nasi_convert_mm_info_oper_name( name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_ptr,
                                               name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding,
                                                      (char *) rsp_msg->eons_plmn_name_3gpp.plmn_short_name,
                                                      (uint8 *)&rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc,
                                               NASI_MAX_LEN_NETWORK_NAME,
                                               name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len ) )
          {
            rsp_msg->eons_plmn_name_3gpp.plmn_short_name_ci    = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_ci;
            rsp_msg->eons_plmn_name_3gpp.plmn_short_spare_bits = name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name_spare_bits;
            if( (rsp_msg->eons_plmn_name_3gpp.plmn_short_name_enc == NAS_CODING_SCHEME_UCS2_V01) ||
                (name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_UNPACKED)
              )
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, name_cnf->plmn_list.plmn_info_ptr[0].plmn_short_name.plmn_name.eons_data.data_len);
            }
            else
            {
              rsp_msg->eons_plmn_name_3gpp.plmn_short_name_len = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, qmi_nas_strnlen( (char*)rsp_msg->eons_plmn_name_3gpp.plmn_short_name, NAS_PLMN_NAME_MAX_V01 ));
            }
          }

            if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding != MMGSDI_EONS_ENC_INVALID ||
                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len != 0 ||
                 name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr != NULL )
            {
              if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
              {
                rsp_msg->addl_info_valid = TRUE;
                rsp_msg->addl_info_len = qm_util_decode_ucs2_80_81_82_encoding( 
                                           name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr,
                                           name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len,
                                           buff_ptr,
                                           NAS_PLMN_NAME_MAX_V01/2 );
                memscpy( (void*)rsp_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)buff_ptr, rsp_msg->addl_info_len*2 );
              }
              else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_UCS2 )
              {
                rsp_msg->addl_info_valid = TRUE;
                rsp_msg->addl_info_len = name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len/2;
                memscpy( (void*)rsp_msg->addl_info, NAS_PLMN_NAME_MAX_V01, (void*)name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len );
                convert_endianness16( (unsigned char*)rsp_msg->addl_info, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len );
              }
              else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_encoding == MMGSDI_EONS_ENC_GSM_7BIT_DEF_ALPHA_PACKED )
              {
                if( !cm_util_gsm7_to_utf16( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_ptr, 
                                            name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_info.info_data.data_len,
                                            FALSE,
                                            rsp_msg->addl_info,
                                            NAS_PLMN_NAME_MAX_V01,
                                            (size_t *)&rsp_msg->addl_info_len ) )
                {
                  rsp_msg->addl_info_valid = TRUE;
                }
              }
            }

          if ( name_cnf->plmn_list.plmn_info_ptr[0].num_plmn_additional_names > 0 )
          {
            rsp_msg->lang_plmn_names_valid = TRUE;
            rsp_msg->lang_plmn_names_len = MIN(NAS_ALT_LANG_MAX_V01, name_cnf->plmn_list.plmn_info_ptr[0].num_plmn_additional_names);
            for ( i = 0; i < rsp_msg->lang_plmn_names_len; i++ )
            {
              rsp_msg->lang_plmn_names[i].lang_id = qmi_nas_map_lang_id_mmgsdi_to_qmi(name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_lang);

              if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
              {
                rsp_msg->lang_plmn_names[i].plmn_long_name_len = qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                   name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len,
                                                                   rsp_msg->lang_plmn_names[i].plmn_long_name,
                                                                   NAS_ALT_LANG_NAME_LEN_MAX_V01 );
              }
              else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
              {
                memscpy( tmp_buf, 
                         NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                         name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_ptr, 
                         name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
                convert_endianness16( tmp_buf, 
                                      name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
                memscpy( rsp_msg->lang_plmn_names[i].plmn_long_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len );
                rsp_msg->lang_plmn_names[i].plmn_long_name_len = name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_long_name.plmn_name.eons_data.data_len/2;
              }

              if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
              {
                rsp_msg->lang_plmn_names[i].plmn_short_name_len = qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                   name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len,
                                                                   rsp_msg->lang_plmn_names[i].plmn_short_name,
                                                                   NAS_ALT_LANG_NAME_LEN_MAX_V01 );
              }
              else if ( name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2 )
              {
                memscpy( tmp_buf, 
                         NAS_ALT_LANG_NAME_LEN_MAX_V01*2,
                         name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_ptr, 
                         name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
                convert_endianness16( tmp_buf, 
                                      name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
                memscpy( rsp_msg->lang_plmn_names[i].plmn_short_name, NAS_ALT_LANG_NAME_LEN_MAX_V01*2, tmp_buf, name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len );
                rsp_msg->lang_plmn_names[i].plmn_short_name_len = name_cnf->plmn_list.plmn_info_ptr[0].plmn_additional_names[i].plmn_short_name.plmn_name.eons_data.data_len/2;
              }
            }
          }
        }
        else
        {
            errval = QMI_ERR_INTERNAL_V01;
        }
      }
      else
      {
          errval = QMI_ERR_INTERNAL_V01;
      }

      // Populate TLV 0x02 (Mandatory error code)
        rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
        rsp_msg->resp.error  = (qmi_error_type_v01)errval;

        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                  QMI_IDL_RESPONSE,
                                                  (uint16_t) QMI_NAS_GET_PLMN_NAME_RESP_MSG_V01,
                                                  (void *) rsp_msg,
                                                  (uint32_t) sizeof( nas_get_plmn_name_resp_msg_v01 ),
                                                  &response
                                                ) )
      {
          if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
        {
            /*Unable to send GET PLMN NAME response*/
            qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
        }
      }
      else
      {
        dsm_free_packet(&response);
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
      }
    }
    else
    {
        qmi_voice_mem_error();
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
      }

      if( rsp_msg != NULL ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
    }
  }
  else
  {
    QM_MSG_ERROR("callback_data is NULL!");
    ASSERT(0);
  }

  if( callback_data != NULL ) { modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE ); }
}

/*===========================================================================
  FUNCTION QMI_NASI_UPDATE_IMS_STATUS()

  DESCRIPTION
    Message to update IMS status to CM

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_update_ims_status
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type               *response = NULL;
  qmi_error_type_v01           errval    = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_update_ims_status_req_msg_v01  *nas_update_ims_req;
  nas_update_ims_status_resp_msg_v01 *nas_update_ims_resp;
  int i;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  nas_update_ims_req  = (nas_update_ims_status_req_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof(nas_update_ims_status_req_msg_v01) );
  nas_update_ims_resp = (nas_update_ims_status_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof(nas_update_ims_status_resp_msg_v01) );

  if ( nas_update_ims_req == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset( nas_update_ims_req, 0x00, sizeof( nas_update_ims_status_req_msg_v01 ) );

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *) nas_update_ims_req,
                                           (uint32_t) sizeof( nas_update_ims_status_req_msg_v01 )
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0072_req_check( nas_update_ims_req );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    for ( i = 0; i < nas_update_ims_req->registration_state_len; i++ )
    {
      cm_domain_sel_update_ims_reg_status_req_msg_type msg;

      msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, MM_DOM_SEL_UPDATE_IMS_REG_STATUS_IND );

      msg.data.system = qmi_nas_radio_if_2_sys_mode(nas_update_ims_req->sys_mode);

      switch ( nas_update_ims_req->registration_state[i].call_type )
      {
        case NAS_CALL_TYPE_E_VOICE_V01:
          msg.data.call_type_mask = CM_CALL_TYPE_VOICE_MASK;
          msg.data.is_registered = nas_update_ims_req->registration_state[i].is_registered;
          break;

        case NAS_CALL_TYPE_E_SMS_V01:
          msg.data.call_type_mask = CM_CALL_TYPE_SMS_MASK;
          msg.data.is_registered = nas_update_ims_req->registration_state[i].is_registered;
          break;

        default:
          QM_MSG_ERROR_1(" Unhandled call type %d", nas_update_ims_req->registration_state[i].call_type);
          errval = QMI_ERR_INTERNAL_V01;
          break;
      }

      msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR_1("UPDATE IMS send fail %d", msgr_err);
      }
    }
  }

  if ( (nas_update_ims_resp != NULL )  && (cmd_buf_p != NULL) )
  {
    memset( nas_update_ims_resp, 0x00, sizeof( nas_update_ims_status_resp_msg_v01 ) );

    nas_update_ims_resp->resp.error  = errval;
    nas_update_ims_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) nas_update_ims_resp,
                                  (uint32_t) sizeof( nas_update_ims_status_resp_msg_v01 ),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( nas_update_ims_req  != NULL ) { QMI_NAS_MEM_FREE( (void *) nas_update_ims_req ); }
  if ( nas_update_ims_resp != NULL ) { QMI_NAS_MEM_FREE( (void *) nas_update_ims_resp ); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_IMS_PREF_STATUS()

  DESCRIPTION
    Message to get IMS preference

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_ims_pref_status
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type               *response = NULL;
  qmi_error_type_v01           errval   = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  nas_get_ims_pref_status_resp_msg_v01 *get_ims_pref_resp;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( qmi_nasi_global.ims_cmd_buf_p == NULL )
  {
    qmi_nasi_global.ims_cmd_buf_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    cm_domain_sel_get_ims_pref_msg_type msg;

    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, MM_DOM_SEL_DOMAIN_SELECTED_IMS_PREF_GET_EXT_REQ );

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("GET_IMS_PREF send fail %d", msgr_err);
    }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    return QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    get_ims_pref_resp = (nas_get_ims_pref_status_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_ims_pref_status_resp_msg_v01 ) );
    if ( ( get_ims_pref_resp != NULL ) && (cmd_buf_p!= NULL) )
    {
      memset( get_ims_pref_resp, 0x00, sizeof( nas_get_ims_pref_status_resp_msg_v01 ) );

      get_ims_pref_resp->resp.error  = errval;
      get_ims_pref_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                    (void *) get_ims_pref_resp,
                                    (uint32_t) sizeof( nas_get_ims_pref_status_resp_msg_v01 ),
                                    &response
                                  );
    }
    else
    {
      qmi_voice_mem_error();
    }

    if ( get_ims_pref_resp != NULL ) { QMI_NAS_MEM_FREE( (void *) get_ims_pref_resp ); }
    qmi_nasi_global.ims_cmd_buf_p = NULL;

    return response;
  }
}

/*===========================================================================
  FUNCTION QMI_NAS_GEN_IMS_PREF_STATUS_IND()

  DESCRIPTION
    Generate a ims preference status indication

  PARAMETERS
    cm_domain_sel_ims_pref_info_s_type    IMS Preference info

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_gen_ims_pref_status_ind(
  cm_domain_sel_ims_pref_info_s_type *ims_pref
)
{
  int                              clid;
  qmi_nasi_client_state_type      *cl_sp;
  nas_ims_pref_status_ind_msg_v01 *nas_ims_pref_ind;
  dsm_item_type                   *ind = NULL;
  boolean                          send_ind;

  nas_ims_pref_ind = (nas_ims_pref_status_ind_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_ims_pref_status_ind_msg_v01 ) );

  if ( nas_ims_pref_ind != NULL )
  {
    memset( nas_ims_pref_ind, 0x00, sizeof(nas_ims_pref_status_ind_msg_v01) );

    send_ind = qmi_nas_populate_ims_pref_status_ind( ims_pref, nas_ims_pref_ind );

    if ( send_ind )
    {
      for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
      {
        cl_sp = qmi_nas_state.client[clid];

        if (  cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
                cl_sp->report_status.report_ims_pref_status)
        {
          ind = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                    QMI_IDL_INDICATION,
                                                    (uint16_t)QMI_NAS_IMS_PREF_STATUS_IND_V01,
                                                    (void *) nas_ims_pref_ind,
                                                    (uint32_t)sizeof(nas_ims_pref_status_ind_msg_v01),
                                                    &ind
                                                  ) )
          {
            qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_IMS_PREF_STATUS_IND, ind );
          }
        }
      }
    }
    else
    {
      QM_MSG_HIGH("ims preference status didnt change");
    }

    QMI_NAS_MEM_FREE( (void *) nas_ims_pref_ind );
  }
  else
  {
    //QM_MSG_ERROR("Unable to alloc space for IMS pref ind");
    qmi_voice_mem_error();
  }
} //qmi_nas_gen_ims_pref_status_ind


/*===========================================================================
  FUNCTION QMI_NAS_POPULATE_IMS_PREF_STATUS_IND()

  DESCRIPTION
    Populate a ims preference status indication

  PARAMETERS
    cm_domain_sel_ims_pref_info_s_type  IMS Preference info
    nas_ims_pref_status_ind_msg_v01     Indication message to populate

  RETURN VALUE
    indicates whether ims pref changed and indication should be sent

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_nas_populate_ims_pref_status_ind(
  cm_domain_sel_ims_pref_info_s_type *ims_pref,
  nas_ims_pref_status_ind_msg_v01    *ind_msg
)
{
  boolean pref_changed = FALSE;
  uint64  pref_mask = 0;

  QM_MSG_HIGH_3("IND resp: sys_mode %d, call_type %d, pref %d", ims_pref->system, ims_pref->call_type_mask, ims_pref->ims_pref_mask);

  switch ( ims_pref->system )
  {
    case SYS_SYS_MODE_LTE:
      QM_MSG_HIGH_2("IND resp: lte_mask_valid %d, lte_call_mask",
        qmi_nasi_global.ims_pref_cache.lte_mask_valid,  qmi_nasi_global.ims_pref_cache.lte_call_mask);
      pref_mask = qmi_nas_convert_pref_to_mask( qmi_nasi_global.ims_pref_cache.lte_call_mask,
                                                ims_pref->call_type_mask,
                                                ims_pref->ims_pref_mask );

      if ( qmi_nasi_global.ims_pref_cache.lte_mask_valid )
      {
        if ( qmi_nasi_global.ims_pref_cache.lte_call_mask != pref_mask )
        {
          pref_changed = TRUE;
          ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_LTE_V01;
          ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.lte_call_mask = pref_mask;
        }
      }
      else
      {
        ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_LTE_V01;
        ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.lte_call_mask = pref_mask;
        qmi_nasi_global.ims_pref_cache.lte_mask_valid = TRUE;
        pref_changed = TRUE;
      }
      break;

    case SYS_SYS_MODE_HDR:
      QM_MSG_HIGH_2("IND resp: hdr_mask_valid %d, hdr_call_mask",
        qmi_nasi_global.ims_pref_cache.hdr_mask_valid,  qmi_nasi_global.ims_pref_cache.hdr_call_mask);
      pref_mask = qmi_nas_convert_pref_to_mask( qmi_nasi_global.ims_pref_cache.hdr_call_mask,
                                                ims_pref->call_type_mask,
                                                ims_pref->ims_pref_mask );

      if ( qmi_nasi_global.ims_pref_cache.hdr_mask_valid )
      {
        if ( qmi_nasi_global.ims_pref_cache.hdr_call_mask != pref_mask )
        {
          pref_changed = TRUE;
          ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_CDMA_1XEVDO_V01;
          ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.hdr_call_mask = pref_mask;
        }
      }
      else
      {
        ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_CDMA_1XEVDO_V01;
        ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.hdr_call_mask = pref_mask;
        qmi_nasi_global.ims_pref_cache.hdr_mask_valid = TRUE;
        pref_changed = TRUE;
      }
      break;

    case SYS_SYS_MODE_GSM:
      QM_MSG_HIGH_2("IND resp: gsm_mask_valid %d, gsm_call_mask",
        qmi_nasi_global.ims_pref_cache.gsm_mask_valid,  qmi_nasi_global.ims_pref_cache.gsm_call_mask);
      pref_mask = qmi_nas_convert_pref_to_mask( qmi_nasi_global.ims_pref_cache.gsm_call_mask,
                                                ims_pref->call_type_mask,
                                                ims_pref->ims_pref_mask );

      if ( qmi_nasi_global.ims_pref_cache.gsm_mask_valid )
      {
        if ( qmi_nasi_global.ims_pref_cache.gsm_call_mask != pref_mask )
        {
          pref_changed = TRUE;
          ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_GSM_V01;
          ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.gsm_call_mask = pref_mask;
        }
      }
      else
      {
        ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_GSM_V01;
        ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.gsm_call_mask = pref_mask;
        qmi_nasi_global.ims_pref_cache.gsm_mask_valid = TRUE;
        pref_changed = TRUE;
      }
      break;

    case SYS_SYS_MODE_WCDMA:
      QM_MSG_HIGH_2("IND resp: wcdma_mask_valid %d, wcdma_call_mask",
        qmi_nasi_global.ims_pref_cache.wcdma_mask_valid,  qmi_nasi_global.ims_pref_cache.wcdma_call_mask);
      pref_mask = qmi_nas_convert_pref_to_mask( qmi_nasi_global.ims_pref_cache.wcdma_call_mask,
                                                ims_pref->call_type_mask,
                                                ims_pref->ims_pref_mask );

      if ( qmi_nasi_global.ims_pref_cache.wcdma_mask_valid )
      {
        if ( qmi_nasi_global.ims_pref_cache.wcdma_call_mask != pref_mask )
        {
          pref_changed = TRUE;
          ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_UMTS_V01;
          ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.wcdma_call_mask = pref_mask;
        }
      }
      else
      {
        ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_UMTS_V01;
        ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.wcdma_call_mask = pref_mask;
        qmi_nasi_global.ims_pref_cache.wcdma_mask_valid = TRUE;
        pref_changed = TRUE;
      }
      break;

  case SYS_SYS_MODE_CDMA:
    QM_MSG_HIGH_2("IND resp: cdma_mask_valid %d, cdma_call_mask",
      qmi_nasi_global.ims_pref_cache.cdma_mask_valid,  qmi_nasi_global.ims_pref_cache.cdma_call_mask);
    pref_mask = qmi_nas_convert_pref_to_mask( qmi_nasi_global.ims_pref_cache.cdma_call_mask,
                                              ims_pref->call_type_mask,
                                              ims_pref->ims_pref_mask );

    if ( qmi_nasi_global.ims_pref_cache.cdma_mask_valid )
    {
      if ( qmi_nasi_global.ims_pref_cache.cdma_call_mask != pref_mask )
      {
        pref_changed = TRUE;
        ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_CDMA_1X_V01;
        ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.cdma_call_mask = pref_mask;
      }
    }
    else
    {
      ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_CDMA_1X_V01;
      ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.cdma_call_mask = pref_mask;
      qmi_nasi_global.ims_pref_cache.cdma_mask_valid = TRUE;
      pref_changed = TRUE;
    }
    break;

  case SYS_SYS_MODE_TDS:
    QM_MSG_HIGH_2("IND resp: tds_mask_valid %d, tds_call_mask",
      qmi_nasi_global.ims_pref_cache.tds_mask_valid,  qmi_nasi_global.ims_pref_cache.tds_call_mask);
    pref_mask = qmi_nas_convert_pref_to_mask( qmi_nasi_global.ims_pref_cache.tds_call_mask,
                                              ims_pref->call_type_mask,
                                              ims_pref->ims_pref_mask );

    if ( qmi_nasi_global.ims_pref_cache.tds_mask_valid )
    {
      if ( qmi_nasi_global.ims_pref_cache.tds_call_mask != pref_mask )
      {
        pref_changed = TRUE;
        ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_TDSCDMA_V01;
        ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.tds_call_mask = pref_mask;
      }
    }
    else
    {
      ind_msg->ims_pref.sys_mode = NAS_RADIO_IF_TDSCDMA_V01;
      ind_msg->ims_pref.ims_pref_call_type = qmi_nasi_global.ims_pref_cache.tds_call_mask = pref_mask;
      qmi_nasi_global.ims_pref_cache.tds_mask_valid = TRUE;
      pref_changed = TRUE;
    }
    break;

    default:
      QM_MSG_ERROR_1("Unsupported SYS MODE %d in ims pref change", ims_pref->system);
      break;
  }

  return pref_changed;
} //qmi_nas_populate_ims_pref_status_ind

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_GET_IMS_PREF_RESP()

  DESCRIPTION
    Populate a ims preference status indication

  PARAMETERS
    cm_domain_sel_ims_pref_info_s_type  IMS Preference info
    nas_ims_pref_status_ind_msg_v01     Indication message to populate

  RETURN VALUE
    indicates whether ims pref changed and indication should be sent

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_get_ims_pref_resp(
  cm_domain_sel_ims_pref_rsp_msg_type_ext *ims_pref
)
{
  dsm_item_type                        *response = NULL;
  qmi_error_type_v01                    errval = QMI_ERR_NONE_V01;
  nas_get_ims_pref_status_resp_msg_v01 *get_ims_pref_resp = NULL;
  qmi_cmd_buf_type                     *cmd_buf_p = qmi_nasi_global.ims_cmd_buf_p;

  if ( cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in GET_IMS_PREF resp: %d", cmd_buf_p);
    qmi_nasi_global.ims_cmd_buf_p = NULL;
    return; //nothing to send
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    get_ims_pref_resp = (nas_get_ims_pref_status_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_ims_pref_status_resp_msg_v01 ) );

    if ( get_ims_pref_resp != NULL )
    {
      memset( get_ims_pref_resp, 0x00, sizeof( nas_get_ims_pref_status_resp_msg_v01 ) );

      QM_MSG_HIGH_3("GET resp: sys_mode %d, voice %d, sms %d", ims_pref->sys_mode_mask, ims_pref->ims_voice_pref_mask, ims_pref->ims_sms_pref_mask);

      if ( ims_pref->sys_mode_mask & SYS_SYS_MODE_MASK_LTE )
      {
        get_ims_pref_resp->ims_pref.sys_mode = NAS_RADIO_IF_LTE_V01;
        if ( ims_pref->ims_voice_pref_mask & SYS_SYS_MODE_MASK_LTE )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_VOICE_V01;
        }

        if ( ims_pref->ims_sms_pref_mask & SYS_SYS_MODE_MASK_LTE )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_SMS_V01;
        }
      }
      else if ( ims_pref->sys_mode_mask & SYS_SYS_MODE_MASK_HDR )
      {
        get_ims_pref_resp->ims_pref.sys_mode = NAS_RADIO_IF_CDMA_1XEVDO_V01;
        if ( ims_pref->ims_voice_pref_mask & SYS_SYS_MODE_MASK_HDR )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_VOICE_V01;
        }

        if ( ims_pref->ims_sms_pref_mask & SYS_SYS_MODE_MASK_HDR )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_SMS_V01;
        }
      }
      else if ( ims_pref->sys_mode_mask & SYS_SYS_MODE_MASK_GSM )
      {
        get_ims_pref_resp->ims_pref.sys_mode = NAS_RADIO_IF_GSM_V01;
        if ( ims_pref->ims_voice_pref_mask & SYS_SYS_MODE_MASK_GSM )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_VOICE_V01;
        }
  
        if ( ims_pref->ims_sms_pref_mask & SYS_SYS_MODE_MASK_GSM )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_SMS_V01;
        }
      }
      else if ( ims_pref->sys_mode_mask & SYS_SYS_MODE_MASK_WCDMA )
      {
        get_ims_pref_resp->ims_pref.sys_mode = NAS_RADIO_IF_UMTS_V01;
        if ( ims_pref->ims_voice_pref_mask & SYS_SYS_MODE_MASK_WCDMA )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_VOICE_V01;
        }
  
        if ( ims_pref->ims_sms_pref_mask & SYS_SYS_MODE_MASK_WCDMA )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_SMS_V01;
        }
      }
      else if ( ims_pref->sys_mode_mask & SYS_SYS_MODE_MASK_CDMA )
      {
        get_ims_pref_resp->ims_pref.sys_mode = NAS_RADIO_IF_CDMA_1X_V01;
        if ( ims_pref->ims_voice_pref_mask & SYS_SYS_MODE_MASK_CDMA )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_VOICE_V01;
        }
  
        if ( ims_pref->ims_sms_pref_mask & SYS_SYS_MODE_MASK_CDMA )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_SMS_V01;
        }
      }
      else if ( ims_pref->sys_mode_mask & SYS_SYS_MODE_MASK_TDS )
      {
        get_ims_pref_resp->ims_pref.sys_mode = NAS_RADIO_IF_TDSCDMA_V01;
        if ( ims_pref->ims_voice_pref_mask & SYS_SYS_MODE_MASK_TDS )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_VOICE_V01;
        }
  
        if ( ims_pref->ims_sms_pref_mask & SYS_SYS_MODE_MASK_TDS )
        {
          get_ims_pref_resp->ims_pref.ims_pref_call_type |= NAS_CALL_TYPE_B_SMS_V01;
        }
      }
      else
      {
        QM_MSG_HIGH_1("Unsupported sys mode %d", ims_pref->sys_mode_mask);
        errval = QMI_ERR_INTERNAL_V01;
      }

      if ( errval == QMI_ERR_NONE_V01 )
      {
        get_ims_pref_resp->ims_pref_valid = TRUE;
      }

      get_ims_pref_resp->resp.error  = errval;
      get_ims_pref_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

      if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                QMI_IDL_RESPONSE,
                                                (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                                (void *) get_ims_pref_resp,
                                                (uint32_t) sizeof( nas_get_ims_pref_status_resp_msg_v01 ),
                                                &response
                                              ) )
      {
        if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
        {
          /*Unable to send GET_IMS_PREF response*/
          qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
        }
      }
    }
    else
    {
      qmi_voice_mem_error();
      qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
    }
  }

  if ( get_ims_pref_resp != NULL ) { QMI_NAS_MEM_FREE( (void *) get_ims_pref_resp ); }
  qmi_nasi_global.ims_cmd_buf_p = NULL;
} //qmi_nas_populate_ims_pref_status_ind

/*===========================================================================
  FUNCTION QMI_NASI_CDMA_AVOID_SYSTEM()

  DESCRIPTION
    Avoid a CDMA system or Clear avoided systems list
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_cdma_avoid_system
( 
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01           errval        = QMI_ERR_NONE_V01;
  nas_cdma_avoid_system_req_msg_v01* req_msg;
  nas_cdma_avoid_system_resp_msg_v01* rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = (nas_cdma_avoid_system_req_msg_v01  *) modem_mem_alloc( sizeof(nas_cdma_avoid_system_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_cdma_avoid_system_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_cdma_avoid_system_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset( req_msg, 0x00, sizeof(nas_cdma_avoid_system_req_msg_v01) );

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                            sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_cdma_avoid_system_req_msg_v01)
                                               );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0076_req_check( req_msg );
  }

  if ( errval == QMI_ERR_NONE_V01 )
          {
    QM_MSG_MED_1("cm_ph_cmd_avoid_sys() with avoid_type=%d", req_msg->avoid_type);
    if(! cm_ph_cmd_avoid_sys( qmi_nas_cmph_cmd_cb,
                              cmd_buf_p,
                              qmi_nasi_global.cm_clnt_id,
                              (cm_ss_avoid_sys_e_type)req_msg->avoid_type,
                              0 /* avoid time is obsolete */) )
            {
      QM_MSG_ERROR("cm_ph_cmd_avoid_sys returned failure");
      errval = QMI_ERR_INTERNAL_V01;
    }
            }

  // take care of result
  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_MED("qmi_nasi_cdma_avoid_system() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
          }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_cdma_avoid_system_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                 QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                                 (void *)rsp_msg,
                                  (uint32_t) sizeof(nas_cdma_avoid_system_resp_msg_v01),
                                                 &response
                                               );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;

} /* qmi_nasi_cdma_avoid_system() */


/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_CDMA_AVOID_SYSTEM_RESP()

  DESCRIPTION
    Called when cmd_cb() supplied in cm_ph_cmd_avoid_system() is called
    by CM. Sends response to control point.

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_cdma_avoid_system_resp
(
  void *               user_data,
  cm_ph_cmd_err_e_type ph_cmd_err
)
{
  dsm_item_type *        response = NULL;
  qmi_cmd_buf_type *     cmd_buf_p;
  boolean                retval = FALSE;
  qmi_error_type_v01     errval   = QMI_ERR_NONE_V01;
  nas_cdma_avoid_system_resp_msg_v01* resp_msg;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  errval = QMI_ERR_NONE_V01;
  cmd_buf_p = (qmi_cmd_buf_type *) user_data;

  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
          {
    return;
  }
  else if(cmd_buf_p == NULL)
            {
    QM_MSG_ERROR("Null cmd_buf ptr");
    return;
            }
  else if ( cmd_buf_p->x_p == NULL )
  {
    QM_MSG_ERROR("null x_p");
    return;
          }

  /*-------------------------------------------------------------------------
    Send SUCCESS or FAILURE response to control point based on ph_cmd_err
  -------------------------------------------------------------------------*/
  switch (ph_cmd_err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE_V01;
      break;

      /* If there is an existing call */
    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE_V01;
      break;

      /*Avoid type is NAS_AVOID_SYS_USERZONE_V01 But
           MS is not in a user zone*/
    case CM_PH_CMD_ERR_SYS_NOT_IN_UZ:
      errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
      break;

      /* Phone is not Online */
    case CM_PH_CMD_ERR_ONLINE_S:
      errval = QMI_ERR_DEVICE_NOT_READY_V01;
      break;

         default:
      errval = QMI_ERR_INTERNAL_V01;
           break;
      }

  resp_msg = (nas_cdma_avoid_system_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_cdma_avoid_system_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_cdma_avoid_system_resp_msg_v01) );
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)(cmd_buf_p->cmd_type),
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_cdma_avoid_system_resp_msg_v01),
                                           &response
                                         );
    }
    else
    {
    qmi_voice_mem_error();
    }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }
  else if ( !qmi_nasi_send_response( cmd_buf_p, response ) )
  {
    QM_MSG_MED("QMI_NAS_CDMA_AVOID_SYSTEM_RESP send failed");
}
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

} /* qmi_nas_generate_cdma_avoid_system_resp() */



/*===========================================================================
  FUNCTION QMI_NASI_GET_CDMA_AVOID_SYSTEM_LIST()

  DESCRIPTION
    Retrieve the avoided systems from EFS

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_get_cdma_avoid_system_list
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response = NULL;
  qmi_error_type_v01           errval        = QMI_ERR_NONE_V01;
  nas_get_cdma_avoid_system_list_resp_msg_v01* rsp_msg;
  uint8 i=0, cnt=0;
  struct
  {
    byte               nam;
    struct
    {
      uint16             sid;
      uint16             nid;
      uint16             mnc;
      uint16             mcc;
    } sys_info[NAS_MAX_CDMA_SYSTEMS_AVOIDED_V01];
  } avoid_sys_list;


  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_cdma_avoid_system_list_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_cdma_avoid_system_list_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    QM_MSG_MED("Fetch the avoid list from EFS");
    memset( rsp_msg, 0x00, sizeof(nas_get_cdma_avoid_system_list_resp_msg_v01) );

    if (qm_util_read_efs("/nv/item_files/modem/mmode/lock_parameters", &avoid_sys_list, sizeof(avoid_sys_list)))
    {
      /* Check if NAM is valid. Only NAM1 is supported currently */
      if(avoid_sys_list.nam == CM_NAM_1)
      {
        rsp_msg->nam1_systems_valid = TRUE;

        for(i=0; i<NAS_MAX_CDMA_SYSTEMS_AVOIDED_V01; i++)
        {
          /* Ignore invalid sid, nid data */
          if( (avoid_sys_list.sys_info[i].sid == SD_WILDCARD_SID) &&
               (avoid_sys_list.sys_info[i].nid == SD_WILDCARD_NID) )
          {
            continue;
          }
          memscpy(&rsp_msg->nam1_systems[cnt++], sizeof(rsp_msg->nam1_systems[cnt++]),
                        &avoid_sys_list.sys_info[i], sizeof(avoid_sys_list.sys_info[i]));          
        }
        rsp_msg->nam1_systems_len = cnt;
        QM_MSG_HIGH_1("Number of avoided systems =%d", cnt);
    }
    else
    {
        QM_MSG_HIGH_1("Invalid NAM value %d from EFS", avoid_sys_list.nam);
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
    else
  {
      QM_MSG_ERROR("EFS read failed");
    errval = QMI_ERR_INTERNAL_V01;
  }

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_cdma_avoid_system_list_resp_msg_v01),
                                  &response
                                );

  }
  else if ( rsp_msg == NULL )
  {
    QM_MSG_ERROR_1("Not enough memory to allocate for QMI_NAS_GET_CDMA_AVOID_SYSTEM_LIST request. %p", rsp_msg);
}

  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;

} /* qmi_nasi_get_cdma_avoid_system_list() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_HPLMN_SEARCH_TIMER ()

  DESCRIPTION
    Sets the HPLMN search timer.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_hplmn_search_timer 
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response  = NULL;
  qmi_error_e_type            errval = QMI_ERR_NONE;
  struct nas_0078_req_s       req_msg;
  uint32                      timer_value = 0;
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  memset(&req_msg, 0, sizeof(req_msg));

  errval = qmi_nas_0078_req_read(&req_msg, sdu_in);

  if (errval == QMI_ERR_NONE)
  {
    errval = qmi_nas_0078_req_check(&req_msg);
  }

  if (errval == QMI_ERR_NONE)
  {
  
#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
      asubs_id = SYS_MODEM_AS_ID_3;
    }
#endif
#endif
    timer_value = req_msg.t01.timer_value;

    if ( !cm_ph_cmd_set_hplmn_timer( qmi_nas_cmph_cmd_cb,
                                     cmd_buf_p,
                                     qmi_nasi_global.cm_clnt_id,
                                     timer_value,
                                     asubs_id ) )
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR("cm_ph_cmd_set_hplmn_timer() failed");
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING; 
  }
  else
  {
    struct nas_0078_rsp_s rsp_msg;
    
    memset( &rsp_msg, 0x00, sizeof(struct nas_0078_rsp_s) );

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_0078_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
} /* qmi_nasi_set_hplmn_search_timer */


/*===========================================================================
  FUNCTION QMI_NASI_GET_HPLMN_SEARCH_TIMER ()

  DESCRIPTION
    Gets the HPLMN search timer.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_hplmn_search_timer 
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response  = NULL;
  qmi_error_e_type            errval = QMI_ERR_NONE;
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  if ( qmi_nasi_global.get_hplmn_cmd_buf_p == NULL )
  {
    qmi_nasi_global.get_hplmn_cmd_buf_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY;
  }
  if (errval == QMI_ERR_NONE)
  {
#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
      asubs_id = SYS_MODEM_AS_ID_3;
    }
#endif
#endif
    if ( !cm_ph_cmd_get_hplmn_timer( qmi_nas_cmph_cmd_cb,
                                     cmd_buf_p,
                                     qmi_nasi_global.cm_clnt_id,
                                     asubs_id ) )
    {
      errval = QMI_ERR_INTERNAL;
      QM_MSG_ERROR("cm_ph_cmd_set_hplmn_timer() failed");
    }
  }

  if ( errval == QMI_ERR_NONE )
  {
    response = QMI_SVC_RESPONSE_PENDING; 
  }
  else
  {
    struct nas_0079_rsp_s rsp_msg;
    
    memset( &rsp_msg, 0x00, sizeof(struct nas_0079_rsp_s) );

    rsp_msg.t02.result_code = QMI_RESULT_FAILURE;
    rsp_msg.t02.error_code  = errval;
    rsp_msg.t02_valid       = TRUE;

    if ( qmi_nas_0079_rsp_write( &rsp_msg, &response ) != QMI_ERR_NONE )
    {
      response = NULL;
    }
  }

  return response;
} /* qmi_nasi_get_hplmn_search_timer */


/*===========================================================================
  FUNCTION QMI_NASI_SET_BUILTIN_PLMN_LIST

  DESCRIPTION
    Set the built in PLMN List on the modem

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_nasi_set_builtin_plmn_list
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *response = NULL;
  qmi_error_type_v01           errval        = QMI_ERR_NONE_V01;
  nas_set_builtin_plmn_list_req_msg_v01* req_msg = NULL;
  nas_set_builtin_plmn_list_resp_msg_v01* rsp_msg = NULL;
  boolean                    wait_for_more_entries = FALSE;
  enum qmi_nas_subs_e as_id    = QMI_NAS_SUBS_PRIMARY;
  uint16                       offset=0;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  //Extract as_id
  as_id  = ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs;
  if( (as_id >= QMI_NAS_SUBS_MAX) || (as_id <= QMI_NAS_SUBS_NONE) )
  {
    QM_MSG_ERROR("qmi_nasi_set_builtin_plmn_list(): Received invalid as_id from client state pointer.");
    return response;
  }

  rsp_msg = (nas_set_builtin_plmn_list_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_builtin_plmn_list_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );


  if( qmi_nasi_global.builtin_plmn_list[as_id].list_op_in_prog )
  {
    errval = QMI_ERR_DEVICE_IN_USE_V01;
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    req_msg  = (nas_set_builtin_plmn_list_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_builtin_plmn_list_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    memset( req_msg, 0x00, sizeof(nas_set_builtin_plmn_list_req_msg_v01) );
    
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t) sizeof(nas_set_builtin_plmn_list_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = (qmi_error_type_v01)qmi_nas_0084_req_check( req_msg );
  }
  
  if (errval == QMI_ERR_NONE_V01)
  {
    //Store the clid so as to send the indication
    qmi_nasi_global.builtin_plmn_list[as_id].clid = ((qmi_nasi_client_state_type *)cl_sp)->common.clid;

    QM_MSG_HIGH_3("QMI_NAS_SET_BUILTIN_PLMN_LIST recv with list_id %d, oplmn len %d on client %d", req_msg->oplmn_list.list_id, req_msg->oplmn_list.oplmn_len, qmi_nasi_global.builtin_plmn_list[as_id].clid);

    //If we have partial list  then add new list to the existing list
    if( qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total > 0 )
    {
      if(qmi_nasi_global.builtin_plmn_list[as_id].list_id == req_msg->oplmn_list.list_id)
      {
        offset = qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total;
        qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total += req_msg->oplmn_list.oplmn_len;
        
        if(req_msg->ind_token_valid)
        {
          qmi_nasi_global.builtin_plmn_list[as_id].ind_tok_valid = TRUE;
          qmi_nasi_global.builtin_plmn_list[as_id].ind_token = req_msg->ind_token;
        }
        if(qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total < req_msg->oplmn_list.total_list_entries)
        {
          wait_for_more_entries = TRUE;
  }

        if( (qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total > req_msg->oplmn_list.total_list_entries) ||
            (qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total > NAS_MAX_BUILTIN_OPLMN_ENTRIES_V01) )
        {
          errval = QMI_ERR_ARG_TOO_LONG_V01;
        }
        else
        {
          QM_MSG_HIGH("Appending the list...");
          qmi_nasi_global.builtin_plmn_list[as_id].list_ptr->oplmn_list_len = qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total;
          memscpy(&qmi_nasi_global.builtin_plmn_list[as_id].list_ptr->oplmn_entry[offset], 
                  (NAS_MAX_BUILTIN_OPLMN_ENTRIES_V01 - offset)*sizeof(nas_oplmn_entry_type_v01),
                  req_msg->oplmn_list.oplmn, (sizeof(nas_oplmn_entry_type_v01)*req_msg->oplmn_list.oplmn_len));
        }
      }
      else
      {
        /* Incorrect list id passed in the second iteration while splitting the large request into multiple small requests 
                    List needs to be sent from beginning again. So clear the context for existing list */
        errval = QMI_ERR_INVALID_ID_V01;
        if(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr != NULL)
        {
          modem_mem_free(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr,MODEM_MEM_CLIENT_QMI_MMODE);
        }
        memset(&qmi_nasi_global.builtin_plmn_list[as_id],0,sizeof(qmi_nasi_global.builtin_plmn_list[as_id]));
      }
    }
    else //Fresh list operation
    {
      qmi_nasi_global.builtin_plmn_list[as_id].list_id = req_msg->oplmn_list.list_id;
      qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total = req_msg->oplmn_list.oplmn_len;
      qmi_nasi_global.builtin_plmn_list[as_id].total_entries = req_msg->oplmn_list.total_list_entries;
      if(req_msg->ind_token_valid)
      {
        qmi_nasi_global.builtin_plmn_list[as_id].ind_tok_valid = TRUE;
        qmi_nasi_global.builtin_plmn_list[as_id].ind_token = req_msg->ind_token;
      }

      if(req_msg->oplmn_list.oplmn_len < req_msg->oplmn_list.total_list_entries)
      {
        wait_for_more_entries = TRUE;
      }
      //Prepare the list
      qmi_nasi_global.builtin_plmn_list[as_id].list_ptr = modem_mem_alloc( sizeof(qmi_nas_builtin_plmn_list_type), MODEM_MEM_CLIENT_QMI_MMODE );
      if( qmi_nasi_global.builtin_plmn_list[as_id].list_ptr != NULL)
      {
        memset(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr, 0, sizeof(qmi_nas_builtin_plmn_list_type));
        qmi_nasi_global.builtin_plmn_list[as_id].list_ptr->oplmn_list_len = req_msg->oplmn_list.oplmn_len;
        //oplmn_len can be 0 and should be treated as CLEAR EFS operation. No need to copy any data if len is 0
        if(req_msg->oplmn_list.oplmn_len != 0)
        {
          QM_MSG_HIGH("Copying the list...");
          memscpy(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr->oplmn_entry, sizeof(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr->oplmn_entry),
                   req_msg->oplmn_list.oplmn, (sizeof(nas_oplmn_entry_type_v01)*req_msg->oplmn_list.oplmn_len));
        }
      }
      else
  {
        errval = QMI_ERR_NO_MEMORY_V01;
      }
      
    }
  }

  if ( (errval == QMI_ERR_NONE_V01) && !wait_for_more_entries && (qmi_nasi_global.builtin_plmn_list[as_id].list_ptr!=NULL))
    {
    qmi_nas_builtin_plmn_list_type *builtin_plmn_list_ptr =  (qmi_nas_builtin_plmn_list_type *)qmi_nasi_global.builtin_plmn_list[as_id].list_ptr;
    mmgsdi_builtin_plmn_list_type mmgsdi_builtin_plmn_list =  {0};

    mmgsdi_return_enum_type mmgsdi_ret = MMGSDI_SUCCESS;
    int i=0;

    for(i=0;i<builtin_plmn_list_ptr->oplmn_list_len;i++)
    {
        QM_MSG_LOW_4("PLMN %d %d %d, Acess Tech %d", builtin_plmn_list_ptr->oplmn_entry[i].plmn_id_val[0], 
                                   builtin_plmn_list_ptr->oplmn_entry[i].plmn_id_val[1], builtin_plmn_list_ptr->oplmn_entry[i].plmn_id_val[2],
                                   builtin_plmn_list_ptr->oplmn_entry[i].access_tech);
      }

    mmgsdi_builtin_plmn_list.num_of_plmn_ids  = builtin_plmn_list_ptr->oplmn_list_len;
    mmgsdi_builtin_plmn_list.plmn_list_ptr    = builtin_plmn_list_ptr->oplmn_list_len ?  (mmgsdi_builtin_plmn_id_type  *)builtin_plmn_list_ptr->oplmn_entry : NULL;
   
    //Calling mmgsdi_set_builtin_plmn_list()...
    if((mmgsdi_ret = mmgsdi_set_builtin_plmn_list(qmi_nasi_global.mmgsdi.client_id, mmgsdi_builtin_plmn_list,
                                                     qmi_nas_mmgsdi_cmd_rsp_cb, (uint32) as_id) ) != MMGSDI_SUCCESS)
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("mmgsdi_set_builtin_plmn_list fail %d", mmgsdi_ret);
    }
    else
    {
      QM_MSG_HIGH_1("mmgsdi_set_builtin_plmn_list sent successfully for as_id %d", as_id);
      qmi_nasi_global.builtin_plmn_list[as_id].list_op_in_prog = TRUE;
    }
  }

  // take care of result
  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_set_builtin_plmn_list_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                 QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                                 (void *)rsp_msg,
                                  (uint32_t) sizeof(nas_set_builtin_plmn_list_resp_msg_v01),
                                                 &response
                                               );
  }

  if(errval != QMI_ERR_NONE_V01)
  {
    //If the list is not being used at lower layers, free it 
    if( !qmi_nasi_global.builtin_plmn_list[as_id].list_op_in_prog )
    {
      if(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr != NULL)
      {
        modem_mem_free(qmi_nasi_global.builtin_plmn_list[as_id].list_ptr,MODEM_MEM_CLIENT_QMI_MMODE);
      }
      memset(&qmi_nasi_global.builtin_plmn_list[as_id],0,sizeof(qmi_nasi_global.builtin_plmn_list[as_id]));
    }
  }
  else
  {
    //If we are waiting for more entries, send an indication for the client to send the next set of plmn entries
    if(wait_for_more_entries)
    {
      qmi_nas_post_internal_builtin_plmn_cmd((uint8)as_id);
    }
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;

} /* qmi_nasi_set_builtin_plmn_list() */



/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_SET_BUILT_PLMN_LIST_IND

  DESCRIPTION
    Set the built in PLMN List on the modem

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_generate_set_builtin_plmn_list_ind(qmi_error_type_v01 err, enum qmi_nas_subs_e as_id)
{
  qmi_nasi_client_state_type      *cl_sp;
 
  nas_set_builtin_plmn_list_ind_msg_v01 *builtin_plmn_list_ind;

  dsm_item_type                   *ind = NULL;
  
  if( (as_id >= QMI_NAS_SUBS_MAX) || (as_id <= QMI_NAS_SUBS_NONE) )
  {
      QM_MSG_ERROR_1("Invalid as_id %d while sending indication.", as_id);
      return;
  }


  builtin_plmn_list_ind = (nas_set_builtin_plmn_list_ind_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_set_builtin_plmn_list_ind_msg_v01 ) );

  if ( builtin_plmn_list_ind != NULL )
  {
    memset( builtin_plmn_list_ind, 0x00, sizeof(*builtin_plmn_list_ind) );

    builtin_plmn_list_ind->error = err;
    QM_MSG_HIGH_2("qmi_nas_generate_set_builtin_plmn_list_ind err %d, as_id %d", err, as_id);

      if(qmi_nasi_global.builtin_plmn_list[as_id].ind_tok_valid)
      {
        builtin_plmn_list_ind->ind_token_valid = TRUE;
        builtin_plmn_list_ind->ind_token = qmi_nasi_global.builtin_plmn_list[as_id].ind_token;
      }
      if(err == QMI_ERR_NONE_V01)
      {
        builtin_plmn_list_ind->received_list_entry_count_valid = TRUE;
        builtin_plmn_list_ind->received_list_entry_count = qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total;
        
        builtin_plmn_list_ind->remaining_list_entry_count_valid = TRUE;
        builtin_plmn_list_ind->remaining_list_entry_count = (qmi_nasi_global.builtin_plmn_list[as_id].total_entries - \
                                                            qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total);
      }
 
    if( (qmi_nasi_global.builtin_plmn_list[as_id].clid > QMI_SVC_CLID_UNUSED) &&
        (qmi_nasi_global.builtin_plmn_list[as_id].clid <= NASI_MAX_CLIDS)
      )
    {
      cl_sp = qmi_nas_state.client[qmi_nasi_global.builtin_plmn_list[as_id].clid-1];

      if(cl_sp != NULL)
      QM_MSG_HIGH_2("builtin_plmn_list_ind to be sent for client %d, as_id %d", qmi_nasi_global.builtin_plmn_list[as_id].clid, as_id);
      else
      QM_MSG_HIGH_1("Client with id %d de-allocated", qmi_nasi_global.builtin_plmn_list[as_id].clid);

      if (  cl_sp && (cl_sp->common.clid != QMI_SVC_CLID_UNUSED) )
      {
        ind = NULL;
        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj, 
                                                  QMI_IDL_INDICATION, 
                                                  (uint16_t)QMI_NAS_SET_BUILTIN_PLMN_LIST_IND_MSG_V01, 
                                                  (void *) builtin_plmn_list_ind,
                                                  (uint32_t)sizeof(nas_set_builtin_plmn_list_ind_msg_v01), 
                                                  &ind
                                                ) )
        {
          qmi_nasi_send_ind( cl_sp, (uint16)NASI_CMD_VAL_SET_BUILTIN_PLMN_LIST, ind );
        }
      }

    }
    else
    {
      QM_MSG_HIGH_1("BUILT IN PLMN LIST IND cannot be sent for client %d", qmi_nasi_global.builtin_plmn_list[as_id].clid);
    }

    //If this is the final result, clear the global context maintained for the builtin plmn
    if((err != QMI_ERR_NONE_V01) ||
        (qmi_nasi_global.builtin_plmn_list[as_id].oplmn_len_total == qmi_nasi_global.builtin_plmn_list[as_id].total_entries) )
    {
      memset(&qmi_nasi_global.builtin_plmn_list[as_id],0,sizeof(qmi_nasi_global.builtin_plmn_list[as_id]));
    }
    QMI_NAS_MEM_FREE( (void *) builtin_plmn_list_ind ); 
  }
  else
  {
    qmi_voice_mem_error();
  }


}/* qmi_nas_generate_set_builtin_plmn_list_ind */

/*===========================================================================
  FUNCTION QMI_NAS_MAP_LTE_SIB16_DLSAVINGTIME_LTE_TO_QMI()

  DESCRIPTION
    This function maps LTE SIB16 Daylight Saving Time to QMI upon receiving MSG Router LTE Event.
    
  PARAMETERS
    dayLightSavingTime : LTE SIB16  Daylight Saving Time data from MSGR

  RETURN VALUE
    QMI_NAS value of daylight savings in uint8 (values are 0, 1 or 2)
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint8 qmi_nas_map_lte_sib16_dlsavingtime_lte_to_qmi( lte_rrc_utc_dayLightSaving_type_e dayLightSavingTime )
  {
  uint8 retval = 0;

  switch(dayLightSavingTime)
    {
    case LTE_UTC_DAYLIGHT_PLUS_ONE:
      retval = 1;
      break;
    case LTE_UTC_DAYLIGHT_PLUS_TWO:
      retval = 2;
          break;
    case LTE_UTC_DAYLIGHT_NONE:
         default:
           break;
      }
    
  return retval;
}

/*===========================================================================
  FUNCTION QMI_NAS_UPDATE_LTE_SIB16_NETWORK_TIME_CACHE()

  DESCRIPTION
    This function updates LTE SIB16 NETWORK TIME CACHE upon receiving MSG Router LTE Event.
    
  PARAMETERS
    lte_sib16_nw_time : Pointer to LTE SIB16 NETWORK TIME data from MSGR

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nas_update_lte_sib16_network_time_cache(lte_rrc_utc_time_update_ind_s *lte_sib16_nw_time)
{
  if(lte_sib16_nw_time)
  {
    qmi_nasi_global.lte_sib16_nw_time_cache.is_valid           = TRUE; 
    qmi_nasi_global.lte_sib16_nw_time_cache.lte_sib16_acquired = lte_sib16_nw_time->utc_sib16_acquired;
    qmi_nasi_global.lte_sib16_nw_time_cache.asubs_id           = lte_sib16_nw_time->as_subs_id;
	
    qmi_nasi_global.lte_sib16_nw_time_cache.lte_dayLightSavingTime_enabled = lte_sib16_nw_time->utc_dayLightSavingTime_enabled;
    qmi_nasi_global.lte_sib16_nw_time_cache.dayLightSavingTime = (uint8)qmi_nas_map_lte_sib16_dlsavingtime_lte_to_qmi(lte_sib16_nw_time->dayLightSavingTime);
	
    qmi_nasi_global.lte_sib16_nw_time_cache.lte_leapSeconds_enabled = lte_sib16_nw_time->utc_leapSeconds_enabled;
    qmi_nasi_global.lte_sib16_nw_time_cache.leapSeconds        = lte_sib16_nw_time->leapSeconds;
	
    qmi_nasi_global.lte_sib16_nw_time_cache.lte_localTimeOffset_enabled = lte_sib16_nw_time->utc_localTimeOffset_enabled;
    qmi_nasi_global.lte_sib16_nw_time_cache.localTimeOffset    = lte_sib16_nw_time->localTimeOffset;

    QM_MSG_HIGH_5("LTE SIB16 NW TIME INFO: sib16_acq = %d, asubs_id = %d, DlSavingsTime = %d, leap_sec = %d, LocalTimeOffset = %d", lte_sib16_nw_time->utc_sib16_acquired, 
		lte_sib16_nw_time->as_subs_id, lte_sib16_nw_time->dayLightSavingTime,lte_sib16_nw_time->leapSeconds, lte_sib16_nw_time->localTimeOffset);
    }
    else
    {
    QM_MSG_ERROR("LTE SIB16 NW TIME Info received from MSGR is NULL");
  }
}


/*===========================================================================
  FUNCTION QMI_NASI_GET_LTE_SIB16_NETWORK_TIME()

  DESCRIPTION
    Retrieve the LTE SIB16 Network time
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_lte_sib16_network_time
( 
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  time_genoff_args_struct_type    time_genoff_args;
  uint64                          abs_time = 0;
  time_julian_type                jul_val;

  nas_get_lte_sib16_network_time_resp_msg_v01 *resp_msg;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp,sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  resp_msg = (nas_get_lte_sib16_network_time_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_lte_sib16_network_time_resp_msg_v01 ) );

  if ( resp_msg != NULL )
  {
    memset( resp_msg, 0x00, sizeof( nas_get_lte_sib16_network_time_resp_msg_v01 ) );

    resp_msg->lte_sib16_acquired_valid = TRUE;
    if(qmi_nasi_global.lte_sib16_nw_time_cache.is_valid)
    {
      resp_msg->lte_sib16_acquired = (qmi_nasi_global.lte_sib16_nw_time_cache.lte_sib16_acquired == TRUE ? NAS_TRI_TRUE_V01 : NAS_TRI_FALSE_V01);
    }
      else
  {
     resp_msg->lte_sib16_acquired = NAS_TRI_UNKNOWN_V01;
  }

    if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_sib16_acquired)
  {
      resp_msg->daylt_sav_adj_valid = qmi_nasi_global.lte_sib16_nw_time_cache.lte_dayLightSavingTime_enabled;
      if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_dayLightSavingTime_enabled == TRUE)
      resp_msg->daylt_sav_adj       = qmi_nasi_global.lte_sib16_nw_time_cache.dayLightSavingTime;

      resp_msg->leap_sec_valid = qmi_nasi_global.lte_sib16_nw_time_cache.lte_leapSeconds_enabled;
      if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_leapSeconds_enabled == TRUE)
      resp_msg->leap_sec            = qmi_nasi_global.lte_sib16_nw_time_cache.leapSeconds;

      resp_msg->time_zone_valid = qmi_nasi_global.lte_sib16_nw_time_cache.lte_localTimeOffset_enabled;
      if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_localTimeOffset_enabled == TRUE)
      resp_msg->time_zone           = qmi_nasi_global.lte_sib16_nw_time_cache.localTimeOffset;

      time_genoff_args.base        = ATS_LTE_HR; 
      time_genoff_args.base_source = TIME_SCLK;
      time_genoff_args.ts_val      = (void*)(&abs_time);  // abs_time is same as msec (format is uint64)
      time_genoff_args.unit        = TIME_MSEC;
      time_genoff_args.operation   = T_GET;

      time_genoff_opr( &time_genoff_args );

      resp_msg->abs_time = abs_time;
      resp_msg->abs_time_valid = TRUE;

      time_jul_from_secs( (uint32)(abs_time/1000), &jul_val ); // convert to julian, first parameter is time in sec since Jan 6, 1980 00:00:00 hrs

      resp_msg->universal_time.year        = jul_val.year;
      resp_msg->universal_time.month       = jul_val.month;
      resp_msg->universal_time.day         = jul_val.day;
      resp_msg->universal_time.hour        = jul_val.hour;
      resp_msg->universal_time.minute      = jul_val.minute;
      resp_msg->universal_time.second      = jul_val.second;
      resp_msg->universal_time.millisecond = (uint16)(abs_time % 1000);
      resp_msg->universal_time.day_of_week = jul_val.day_of_week;
      resp_msg->universal_time_valid       = TRUE;
      }

    resp_msg->resp.error  = errval;
    resp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                  QMI_NAS_GET_LTE_SIB16_NETWORK_TIME_RESP_MSG_V01,
                                  (void *) resp_msg,
                                  (uint32_t) sizeof( nas_get_lte_sib16_network_time_resp_msg_v01 ),
                                    &response
                                  );
    }
    else
    {
    qmi_voice_mem_error();
  }

  if ( resp_msg != NULL ) { QMI_NAS_MEM_FREE( (void *) resp_msg ); }

  return response;
}

/*===========================================================================
  FUNCTION qmi_nas_update_cached_time_info()

  DESCRIPTION
    save NITZ information from NW.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_update_cached_time_info( cm_mm_msim_ss_info_s_type *p_info )
{
  int index;

  for( index = 0; index < p_info->number_of_stacks && index < STACK_INDEX_MAX; index++ )
  {
    QM_MSG_HIGH_2("stack %d, sys_mode=%d", index, p_info->stack_info[index].sys_mode);
    if( p_info->stack_info[index].changed_fields & CM_SS_EVT_CDMA_TIME_CHGD_MASK &&
        ( p_info->stack_info[index].sys_mode == SYS_SYS_MODE_CDMA || p_info->stack_info[index].sys_mode == SYS_SYS_MODE_HDR ) )
  {
      if ( p_info->stack_info[index].mode_info.cdma_info.time_info.sys_mode == SYS_SYS_MODE_CDMA )
    {
        QM_MSG_HIGH_3("CDMA TZ=%d,DST=%d,lp_sec=%d ", p_info->stack_info[index].mode_info.cdma_info.time_info.time.cdma_time.ltm_offset, p_info->stack_info[index].mode_info.cdma_info.time_info.time.cdma_time.daylt_savings, p_info->stack_info[index].mode_info.cdma_info.time_info.time.cdma_time.lp_sec);
      
      qmi_nasi_nitz_time.cdma_cache.is_valid = TRUE;
      qmi_nasi_nitz_time.hdr_cache.is_valid = FALSE;
        qmi_nasi_nitz_time.cdma_cache.lp_sec = p_info->stack_info[index].mode_info.cdma_info.time_info.time.cdma_time.lp_sec;
      // cdma reports in units of 30 min
        qmi_nasi_nitz_time.cdma_cache.time_zone = QMI_NAS_6BIT_2_8BIT( p_info->stack_info[index].mode_info.cdma_info.time_info.time.cdma_time.ltm_offset ) * 2;
        qmi_nasi_nitz_time.cdma_cache.daylt_savings = p_info->stack_info[index].mode_info.cdma_info.time_info.time.cdma_time.daylt_savings;
        QM_MSG_HIGH_1("CDMA Calc TZ=%d", qmi_nasi_nitz_time.cdma_cache.time_zone);
      qmi_nasi_nitz_time.radio_if = QMI_NAS_RADIO_IF_CDMA20001X;
        break;
    }
      else if ( p_info->stack_info[index].mode_info.cdma_info.time_info.sys_mode == SYS_SYS_MODE_HDR )
    {

      qmi_nasi_nitz_time.hdr_cache.is_valid = TRUE;
      qmi_nasi_nitz_time.cdma_cache.is_valid = FALSE;
        qmi_nasi_nitz_time.hdr_cache.lp_sec = p_info->stack_info[index].mode_info.cdma_info.time_info.time.hdr_time.lp_sec;
        qmi_nasi_nitz_time.hdr_cache.time_zone = (uint8)(p_info->stack_info[index].mode_info.cdma_info.time_info.time.hdr_time.ltm_offset/15);
      qmi_nasi_nitz_time.hdr_cache.daylt_savings = NAS_DAYLT_SAV_ADJ_NONE;
        QM_MSG_HIGH_3("HDR TZ=%d,lp_sec=%d,calc TZ=%d", p_info->stack_info[index].mode_info.cdma_info.time_info.time.hdr_time.ltm_offset, p_info->stack_info[index].mode_info.cdma_info.time_info.time.hdr_time.lp_sec, qmi_nasi_nitz_time.hdr_cache.time_zone);
      qmi_nasi_nitz_time.radio_if = QMI_NAS_RADIO_IF_CDMA20001XEVDO;
        break;
    }
  }
    else if( p_info->stack_info[index].changed_fields & CM_SS_EVT_MOBILITY_MGMT_MASK &&
             ( p_info->stack_info[index].sys_mode == SYS_SYS_MODE_GSM || p_info->stack_info[index].sys_mode == SYS_SYS_MODE_WCDMA || 
               p_info->stack_info[index].sys_mode == SYS_SYS_MODE_LTE || p_info->stack_info[index].sys_mode == SYS_SYS_MODE_TDS ) )
  {
    if (!p_info->stack_info[index].mode_info.gw_info.mm_information.univ_time_and_time_zone_avail &&
        !p_info->stack_info[index].mode_info.gw_info.mm_information.time_zone_avail &&
        !p_info->stack_info[index].mode_info.gw_info.mm_information.daylight_saving_adj_avail)
    {
      QM_MSG_HIGH("Mobility management mask set, but no time data available");
      continue;
    }
    qmi_nasi_nitz_time.cdma_cache.is_valid = FALSE;
    qmi_nasi_nitz_time.hdr_cache.is_valid = FALSE;
    qmi_nasi_nitz_time.umts_cache.is_valid = TRUE;
      if ( p_info->stack_info[index].mode_info.gw_info.mm_information.univ_time_and_time_zone_avail )
    {

      qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone_avail = TRUE;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.year = p_info->stack_info[index].mode_info.gw_info.mm_information.univ_time_and_time_zone.year;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.month = p_info->stack_info[index].mode_info.gw_info.mm_information.univ_time_and_time_zone.month;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.day = p_info->stack_info[index].mode_info.gw_info.mm_information.univ_time_and_time_zone.day;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.hour = p_info->stack_info[index].mode_info.gw_info.mm_information.univ_time_and_time_zone.hour;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.minute = p_info->stack_info[index].mode_info.gw_info.mm_information.univ_time_and_time_zone.minute;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.second = p_info->stack_info[index].mode_info.gw_info.mm_information.univ_time_and_time_zone.second;
        qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.time_zone = p_info->stack_info[index].mode_info.gw_info.mm_information.univ_time_and_time_zone.time_zone;

        QM_MSG_HIGH_3("From NW GW time: %d:%d:%d ", p_info->stack_info[index].mode_info.gw_info.mm_information.univ_time_and_time_zone.hour, p_info->stack_info[index].mode_info.gw_info.mm_information.univ_time_and_time_zone.minute, p_info->stack_info[index].mode_info.gw_info.mm_information.univ_time_and_time_zone.second);
    

    }
      else if ( p_info->stack_info[index].mode_info.gw_info.mm_information.time_zone_avail )
    {
      qmi_nasi_nitz_time.umts_cache.time_zone_avail = TRUE;
        qmi_nasi_nitz_time.umts_cache.time_zone = (int8)p_info->stack_info[index].mode_info.gw_info.mm_information.time_zone;
        QM_MSG_HIGH_1("From NW GW only TZ: %d ", p_info->stack_info[index].mode_info.gw_info.mm_information.time_zone);
    
    }

      if ( p_info->stack_info[index].mode_info.gw_info.mm_information.daylight_saving_adj_avail )
    {
      qmi_nasi_nitz_time.umts_cache.daylight_saving_adj_avail = TRUE;
        qmi_nasi_nitz_time.umts_cache.daylight_saving_adj = (uint8)p_info->stack_info[index].mode_info.gw_info.mm_information.daylight_saving_adj;
        QM_MSG_HIGH_1("From NW GW only DST: %d ", p_info->stack_info[index].mode_info.gw_info.mm_information.daylight_saving_adj);
    }
      qmi_nasi_nitz_time.radio_if = (uint8)qmi_nas_sys_mode_2_radio_if( p_info, index, FALSE );
      break;
  }
    else
      {
      QM_MSG_HIGH_2("unexpected bitmask %x %x", (dword)(p_info->stack_info[index].changed_fields & (uint64)0xFFFFFFFF), (dword)(p_info->stack_info[index].changed_fields >> 32));
      }
      }
}

/*===========================================================================
  FUNCTION qmi_nas_get_nitz_time_from_cache()

  DESCRIPTION
    Retrieve the 1x/HDR/GW Network time from Cache
    
  PARAMETERS

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

boolean qmi_nas_get_nitz_time_from_cache(nas_get_network_time_resp_msg_v01 *resp)
{

  time_genoff_args_struct_type time_genoff_args;
  time_julian_type             jul_val;
  time_type                    ts_val_secs; // genoff time in secs
  uint32                       secs; // genoff time in secs temp var
  byte                         lp_sec = 0;
  time_bases_type              time_base  = ATS_RTC;
  

  if ( qmi_nasi_nitz_time.cdma_cache.is_valid )
  {
    time_base = ATS_TOD;
    lp_sec    = qmi_nasi_nitz_time.cdma_cache.lp_sec;
    resp->nas_3gpp2_time_valid = TRUE;
    resp->nas_3gpp2_time.daylt_sav_adj = qmi_nasi_nitz_time.cdma_cache.daylt_savings;
    resp->nas_3gpp2_time.time_zone = qmi_nasi_nitz_time.cdma_cache.time_zone;
    resp->nas_3gpp2_time.radio_if = (nas_radio_if_enum_v01)qmi_nasi_nitz_time.radio_if;
  }
  else if ( qmi_nasi_nitz_time.hdr_cache.is_valid )
  {
    time_base = ATS_TOD;
    lp_sec    = qmi_nasi_nitz_time.hdr_cache.lp_sec;
    resp->nas_3gpp2_time_valid = TRUE;
    resp->nas_3gpp2_time.daylt_sav_adj = qmi_nasi_nitz_time.hdr_cache.daylt_savings;
    resp->nas_3gpp2_time.time_zone = qmi_nasi_nitz_time.hdr_cache.time_zone;
    resp->nas_3gpp2_time.radio_if = (nas_radio_if_enum_v01)qmi_nasi_nitz_time.radio_if;
  }
  else if( qmi_nasi_nitz_time.umts_cache.is_valid )
  {
    time_base = ATS_3GPP;
    resp->nas_3gpp_time.radio_if = (nas_radio_if_enum_v01)qmi_nasi_nitz_time.radio_if;
    resp->nas_3gpp_time_valid = TRUE;
    if(qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone_avail)
    {
      resp->nas_3gpp_time.time_zone = qmi_nasi_nitz_time.umts_cache.univ_time_and_time_zone.time_zone;
      resp->nas_3gpp_time.daylt_sav_adj = NAS_DAYLT_SAV_ADJ_NONE;
    }

    if(qmi_nasi_nitz_time.umts_cache.time_zone_avail)
    {
      resp->nas_3gpp_time.time_zone = qmi_nasi_nitz_time.umts_cache.time_zone;
    }

    if(qmi_nasi_nitz_time.umts_cache.daylight_saving_adj_avail)
    {
      resp->nas_3gpp_time.daylt_sav_adj = qmi_nasi_nitz_time.umts_cache.daylight_saving_adj;
    }
  }
  else
  {
    QM_MSG_ERROR("Invalid Nitz Cache GET_NITZ_TIME response.");
    return FALSE;
  }

  // read time from time service
  time_genoff_args.base        = time_base; 
  time_genoff_args.base_source = TIME_SCLK;
  time_genoff_args.ts_val      = (void *)&ts_val_secs;
  time_genoff_args.unit        = TIME_SECS;
  time_genoff_args.operation   = T_GET;
  
  time_genoff_opr( &time_genoff_args );
  secs  = ts_val_secs[0];
  secs -= lp_sec; // subtract leap seconds
  QM_MSG_HIGH_2("secs %d lp_sec %d", secs, lp_sec);
  
  time_jul_from_secs( secs, &jul_val ); // convert to julian
  
  QM_MSG_HIGH_6("y %d m %d d %d h %d m %d s %d", jul_val.year, jul_val.month, jul_val.day, jul_val.hour, jul_val.minute, jul_val.second);
  if(resp->nas_3gpp2_time_valid)
  { 
    QM_MSG_HIGH_3("TZ %d DST %d lp_sec %d", resp->nas_3gpp2_time.time_zone, resp->nas_3gpp2_time.daylt_sav_adj, lp_sec);
    resp->nas_3gpp2_time.universal_time.year        = jul_val.year;
    resp->nas_3gpp2_time.universal_time.month       = jul_val.month;
    resp->nas_3gpp2_time.universal_time.day         = jul_val.day;
    resp->nas_3gpp2_time.universal_time.hour        = jul_val.hour;
    resp->nas_3gpp2_time.universal_time.minute      = jul_val.minute;
    resp->nas_3gpp2_time.universal_time.second      = jul_val.second;
    resp->nas_3gpp2_time.universal_time.day_of_week = jul_val.day_of_week;
  }
  else if(resp->nas_3gpp_time_valid)
  {
    QM_MSG_HIGH_3("TZ %d DST %d lp_sec %d", resp->nas_3gpp_time.time_zone, resp->nas_3gpp_time.daylt_sav_adj, lp_sec);
    resp->nas_3gpp_time.universal_time.year        = jul_val.year;
    resp->nas_3gpp_time.universal_time.month       = jul_val.month;
    resp->nas_3gpp_time.universal_time.day         = jul_val.day;
    resp->nas_3gpp_time.universal_time.hour        = jul_val.hour;
    resp->nas_3gpp_time.universal_time.minute      = jul_val.minute;
    resp->nas_3gpp_time.universal_time.second      = jul_val.second;
    resp->nas_3gpp_time.universal_time.day_of_week = jul_val.day_of_week;
    }
  else
    {
    QM_MSG_ERROR("Invalid Nitz data in GET_NITZ_TIME response.");
    return FALSE;
  }

  return TRUE;
}

/*===========================================================================
  FUNCTION qmi_nasi_get_network_time()

  DESCRIPTION
    Retrieve the GW/1X/HDR Network time from Cached information.

  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_network_time
( 
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  nas_get_network_time_resp_msg_v01 *resp_msg;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp,sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  resp_msg = (nas_get_network_time_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_network_time_resp_msg_v01 ) );

  if ( resp_msg != NULL )
  {
    memset( resp_msg, 0x00, sizeof( nas_get_network_time_resp_msg_v01 ) );

    if( !qmi_nasi_nitz_time.cdma_cache.is_valid && !qmi_nasi_nitz_time.hdr_cache.is_valid  &&
        !qmi_nasi_nitz_time.umts_cache.is_valid)
    {
      QM_MSG_ERROR("Nitz time information not available from NW");
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    }
    else
    {
      if(!qmi_nas_get_nitz_time_from_cache(resp_msg))
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR_1("Invalid NITZ time cache NW err=%d", errval);
      }
    }

    resp_msg->resp.error  = errval;
    resp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  QMI_NAS_GET_NETWORK_TIME_RESP_MSG_V01,
                                  (void *) resp_msg,
                                  (uint32_t) sizeof( nas_get_network_time_resp_msg_v01 ),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( resp_msg != NULL ) 
  { 
    QMI_NAS_MEM_FREE( (void *) resp_msg ); 
    resp_msg = NULL;
  }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_LTE_SIB16_NETWORK_TIME_IND()

  DESCRIPTION
    Generates and sends the LTE SIB16 Network time IND
    
  PARAMETERS
    None

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nas_generate_lte_sib16_network_time_ind(void)
{
  time_genoff_args_struct_type time_genoff_args;
  time_julian_type             jul_val;
  uint64                       abs_time;

  nas_lte_sib16_network_time_ind_msg_v01        *ind_msg;
  dsm_item_type               *ind;

  int                          client;
  qmi_nasi_client_state_type  *cl_sp;
  enum qmi_nas_subs_e          bound_subs = QMI_NAS_SUBS_PRIMARY;

  ind_msg = (nas_lte_sib16_network_time_ind_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_lte_sib16_network_time_ind_msg_v01 ) );

  if ( ind_msg != NULL )
{  
    memset( ind_msg, 0x00, sizeof( nas_lte_sib16_network_time_ind_msg_v01 ) );

    ind_msg->lte_sib16_acquired = (qmi_nasi_global.lte_sib16_nw_time_cache.lte_sib16_acquired == TRUE ? NAS_TRI_TRUE_V01 : NAS_TRI_FALSE_V01);
    ind_msg->lte_sib16_acquired_valid = TRUE;

    if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_sib16_acquired)
  {
      ind_msg->daylt_sav_adj_valid = qmi_nasi_global.lte_sib16_nw_time_cache.lte_dayLightSavingTime_enabled;
      if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_dayLightSavingTime_enabled == TRUE)
      ind_msg->daylt_sav_adj       = qmi_nasi_global.lte_sib16_nw_time_cache.dayLightSavingTime;

      ind_msg->leap_sec_valid = qmi_nasi_global.lte_sib16_nw_time_cache.lte_leapSeconds_enabled;
      if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_leapSeconds_enabled == TRUE)
      ind_msg->leap_sec            = qmi_nasi_global.lte_sib16_nw_time_cache.leapSeconds;

      ind_msg->time_zone_valid = qmi_nasi_global.lte_sib16_nw_time_cache.lte_localTimeOffset_enabled;
      if(qmi_nasi_global.lte_sib16_nw_time_cache.lte_localTimeOffset_enabled == TRUE)
      ind_msg->time_zone           = qmi_nasi_global.lte_sib16_nw_time_cache.localTimeOffset;

      time_genoff_args.base        = ATS_LTE_HR; 
      time_genoff_args.base_source = TIME_SCLK;
      time_genoff_args.ts_val      = (void*)(&abs_time);  // abs_time is same as msec (format is uint64)
      time_genoff_args.unit        = TIME_MSEC;
      time_genoff_args.operation   = T_GET;

      time_genoff_opr( &time_genoff_args );

      ind_msg->abs_time = abs_time;
      ind_msg->abs_time_valid = TRUE;

      time_jul_from_secs( (uint32)(abs_time/1000), &jul_val ); // convert to julian, first parameter is time in sec since Jan 6, 1980 00:00:00 hrs

      ind_msg->universal_time.year        = jul_val.year;
      ind_msg->universal_time.month       = jul_val.month;
      ind_msg->universal_time.day         = jul_val.day;
      ind_msg->universal_time.hour        = jul_val.hour;
      ind_msg->universal_time.minute      = jul_val.minute;
      ind_msg->universal_time.second      = jul_val.second;
      ind_msg->universal_time.millisecond = (uint16)(abs_time % 1000);
      ind_msg->universal_time.day_of_week = jul_val.day_of_week;
      ind_msg->universal_time_valid = TRUE;

      QM_MSG_HIGH_8("y %d m %d d %d h %d m %d s %d msec %d abs_time %llu", jul_val.year, jul_val.month, jul_val.day,
	  	jul_val.hour, jul_val.minute, jul_val.second, ind_msg->universal_time.millisecond, abs_time);
  }


    for ( client=0; client<NASI_MAX_CLIDS; client++ )
  {
      cl_sp = qmi_nas_state.client[client];

      if ( cl_sp && cl_sp->common.clid != NASI_CLID_UNUSED && cl_sp->report_status.report_lte_sib16_network_time && cl_sp->report_status.bound_subs == bound_subs )
    {
        ind = NULL;
 
        if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                  QMI_IDL_INDICATION,
                                                  QMI_NAS_LTE_SIB16_NETWORK_TIME_IND_V01,
                                                  (void *) ind_msg,
                                                  (uint32_t) sizeof( nas_lte_sib16_network_time_ind_msg_v01 ),
                                                  &ind
                                                )
          )
      {
          qmi_nasi_send_ind( cl_sp, (uint16)QMI_NAS_LTE_SIB16_NETWORK_TIME_IND_V01, ind );
      }
      else
      {
           QM_MSG_ERROR_1("failed to send LTE_SIB16_NETWORK_TIME ind, client %d", client);
        }
      }
    }
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( ind_msg != NULL ) { QMI_NAS_MEM_FREE( (void *) ind_msg ); }
}

/*===========================================================================
  FUNCTION QMI_NASI_SET_LTE_BAND_PRIORITY()

  DESCRIPTION
    Message to set the lte band priority list
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_lte_band_priority
( 
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
  errno_enum_type             msgr_err = E_SUCCESS;
  uint8                       b_cnt = 0;

  nas_set_lte_band_priority_req_msg_v01  *req_msg = NULL;
  nas_set_lte_band_priority_resp_msg_v01 *rsp_msg = NULL;

  lte_rrc_band_pri_change_req_s msg;
  int i;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( qmi_nasi_global.set_lte_band_p == NULL )
  {
    qmi_nasi_global.set_lte_band_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    req_msg = (nas_set_lte_band_priority_req_msg_v01 *) modem_mem_alloc( sizeof(nas_set_lte_band_priority_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0x00, sizeof(nas_set_lte_band_priority_req_msg_v01) );

    
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           QMI_NAS_SET_LTE_BAND_PRIORITY_REQ_MSG_V01,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_lte_band_priority_req_msg_v01)
                                         );
  }
  
  
  if (errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_nas_0080_req_check(req_msg);
    }

  if( errval == QMI_ERR_NONE_V01 )
    {
    memset(&msg, 0x00, sizeof(lte_rrc_band_pri_change_req_s) );

    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_BAND_PRI_CHANGE_REQ );
    QM_MSG_HIGH_1("Number of bands recv = %d", req_msg->band_priority_list_len);

    for ( i = 0; i < MIN(SYS_SBAND_LTE_EUTRAN_BAND_MAX, req_msg->band_priority_list_len); i++ )
    {
      if( (msg.band_priority_list[i] = qmi_nas_qmi_lte_bc_2_sys_lte_bc( req_msg->band_priority_list[i] )) == SYS_SBAND_LTE_EUTRAN_BAND_MAX )
  {
        errval = QMI_ERR_INTERNAL_V01;
        break;
      }
      b_cnt++;
      QM_MSG_HIGH_3("Band%d = %d, rrc band = %d ", b_cnt, req_msg->band_priority_list[i], msg.band_priority_list[i]);
  }

    if ( errval == QMI_ERR_NONE_V01 )
  {
      msg.num_prioritized_bands = b_cnt;
      msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR_1("LTE Band Priority send fail %d", msgr_err);
    }
    else
    {
      response = QMI_SVC_RESPONSE_PENDING;
    }
  }
  }

  if ( errval != QMI_ERR_NONE_V01 )
  {
    rsp_msg = (nas_set_lte_band_priority_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_lte_band_priority_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

    if( rsp_msg != NULL )
    {
      memset(rsp_msg, 0x00, sizeof(nas_set_lte_band_priority_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    QMI_NAS_SET_LTE_BAND_PRIORITY_RESP_MSG_V01,
                                    (void *)rsp_msg,
                                    (uint32_t)sizeof(nas_set_lte_band_priority_resp_msg_v01),
                                    &response
                                  );
      //Free the cmd_buf_p stored
      qmi_nasi_global.set_lte_band_p = NULL;
    }
    else
    {
      qmi_voice_mem_error();
    }
  }

  if ( req_msg != NULL ) { modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_SET_E911_STATE_RESP()

  DESCRIPTION
    Generate and send response for putting modem into enter/exit emergency state
    
  PARAMETERS
    msg_p  Pointer to MSGR data for E911 state info

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_set_lte_band_priority_resp
( 
  lte_rrc_band_pri_change_cnf_s * lte_band_pri_cnf
)
{  
  dsm_item_type *             response = NULL;
  boolean                     retval = FALSE;
  qmi_cmd_buf_type           *cmd_buf_p = qmi_nasi_global.set_lte_band_p;

  nas_set_lte_band_priority_resp_msg_v01 *rsp_msg = NULL;
  
  if ( cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in SET_LTE_BAND_PRIORITY resp: %d", cmd_buf_p);
    qmi_nasi_global.set_lte_band_p = NULL;
    return; //nothing to send
  }
  
  if(lte_band_pri_cnf)
  {
    rsp_msg = (nas_set_lte_band_priority_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_lte_band_priority_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  
    if(rsp_msg)
    {
      memset(rsp_msg, 0, sizeof(nas_set_lte_band_priority_resp_msg_v01) );
      QM_MSG_HIGH_1("LTE band priority conf status recv = %d", lte_band_pri_cnf->status);
  
      if ( lte_band_pri_cnf->status == TRUE )
      {
          rsp_msg->resp.error  = QMI_ERR_NONE_V01;
          rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
      }
      else
      {
        rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
        rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
      }
    
          retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                 QMI_IDL_RESPONSE,
                                             QMI_NAS_SET_LTE_BAND_PRIORITY_RESP_MSG_V01,
                                                 (void *)rsp_msg,
                                             (uint32_t)sizeof(nas_set_lte_band_priority_resp_msg_v01),
                                                 &response
                                               );
          if( retval )
          {
            if( !qmi_nas_clnt_send_response(cmd_buf_p, response) )
            {
          QM_MSG_ERROR_2("Unable to send QMI_NAS_SET_LTE_BAND_PRIORITY resp result %d, cmd_buf_p %x", lte_band_pri_cnf->status, cmd_buf_p);
        }
      }
      //Free the cmd_buf_p stored
      qmi_nasi_global.set_lte_band_p = NULL;
    }
    else
    {
      qmi_voice_mem_error();
    }
    
    if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
  }
  else
  {
    QM_MSG_ERROR("MSGR set_lte_band_pri is NULL, no response sent");
  }
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_EMBMS_SIG_EXT_RSP ()

  DESCRIPTION
    Returns eMBMS signal strength information
    
===========================================================================*/
void qmi_nasi_generate_get_embms_sig_ext_rsp( qmi_mmodei_msgr_type * msg_p )
{
  dsm_item_type         *response = NULL;
#ifdef FEATURE_LTE_EMBMS
  int                                 i, j;
#endif
  qmi_error_type_v01                  errval = QMI_ERR_NONE_V01;
  nas_get_embms_sig_ext_resp_msg_v01 *rsp_msg;
  qmi_cmd_buf_type                   *cmd_buf_p = qmi_nasi_global.embms_ext_cmd_buf_p;

  if ( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in QMI_NAS_GET_EMBMS_SIG_EXT resp: %d", cmd_buf_p);
    qmi_nasi_global.cmd_buf_p = NULL;
    return; //nothing to send
  }

  rsp_msg = (nas_get_embms_sig_ext_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_embms_sig_ext_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg != NULL )
  {
    memset( rsp_msg, 0, sizeof( nas_get_embms_sig_ext_resp_msg_v01 ) );

#ifdef FEATURE_LTE_EMBMS
    if ( errval == QMI_ERR_NONE_V01 )
    {
      rsp_msg->trace_id_valid = TRUE;
      rsp_msg->trace_id = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.debug_trace_id;

      for ( i=0; i<NAS_LTE_EMBMS_MAX_MBSFN_AREA_V01 && i<msg_p->cmd.qmi_nas.embms_sig_cnf_ext.num_mbsfn_areas ; i++ )
      {
        rsp_msg->snr_and_tmgi_list[i].area_id      = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].area_id;
        rsp_msg->snr_and_tmgi_list[i].snr          = (float)(msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].snr)/8.0;

        QM_MSG_HIGH_2("qmi_nasi_generate_get_embms_sig_ext_rsp: area_id = %d, snr = %f", rsp_msg->snr_and_tmgi_list[i].area_id, rsp_msg->snr_and_tmgi_list[i].snr);

        rsp_msg->snr_and_tmgi_list[i].excess_snr = (float)(msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].excess_snr)/8.0;

        for ( j=0; j<NAS_TMGI_BEARER_INFO_MAX_V01 && j<msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].num_active_embms_sessions && j<LTE_EMBMS_MAX_ACTIVE_SESSIONS; j++ )
        {
          rsp_msg->snr_and_tmgi_list[i].tmgi_info[j].mrb_id = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].session_info[j].mrb_id;
          rsp_msg->snr_and_tmgi_list[i].tmgi_info[j].session_id_valid = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].session_info[j].session_info.session_id_present;
          if ( rsp_msg->snr_and_tmgi_list[i].tmgi_info[j].session_id_valid )
          {
            rsp_msg->snr_and_tmgi_list[i].tmgi_info[j].session_id = msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].session_info[j].session_info.session_id;
          }

          memscpy((void*)rsp_msg->snr_and_tmgi_list[i].tmgi_info[j].tmgi_identifier, NAS_EMBMS_TMGI_SVC_ID_SIZE,
                       (void*)&(msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].session_info[j].session_info.tmgi.service_id), NAS_EMBMS_TMGI_SVC_ID_SIZE);

          memscpy((void*)(rsp_msg->snr_and_tmgi_list[i].tmgi_info[j].tmgi_identifier + NAS_EMBMS_TMGI_PLMN_OFFSET), NAS_EMBMS_TMGI_PLMN_ID_SIZE,
                       (void*)&(msg_p->cmd.qmi_nas.embms_sig_cnf_ext.mbsfn_area_info[i].session_info[j].session_info.tmgi.plmn_id.identity), NAS_EMBMS_TMGI_PLMN_ID_SIZE);

        }
        rsp_msg->snr_and_tmgi_list[i].tmgi_info_len = j;
      }
      rsp_msg->snr_and_tmgi_list_len   = i;
      rsp_msg->snr_and_tmgi_list_valid = TRUE;
            }
#else
  if( errval == QMI_ERR_NONE_V01 )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
          }
#endif
  
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    rsp_msg->resp.error  = errval;
         
    if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                 QMI_IDL_RESPONSE,
                                              (uint16_t)QMI_NAS_GET_EMBMS_SIG_EXT_RESP_MSG_V01,
                                                 (void *)rsp_msg,
                                              (uint32_t) sizeof( nas_get_embms_sig_ext_resp_msg_v01 ),
                                                 &response
                                            ) )
    {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
      {
        /*Unable to send GET_EMBMS_SIG_EXT response*/
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
      }
    }
    else
          {
      qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
    }    
  }
  else
            {
    qmi_voice_mem_error();
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
            }
 
  if ( rsp_msg!= NULL ) { modem_mem_free((void*)rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  qmi_nasi_global.cmd_buf_p = NULL;
          }
      
/*===========================================================================
  FUNCTION QMI_NASI_GET_LTE_BAND_PRIORITY_LIST()

  DESCRIPTION
    Message to get the lte band priority list
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_lte_band_priority_list
( 
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01            errval   = QMI_ERR_NONE_V01;
  errno_enum_type             msgr_err = E_SUCCESS;

  nas_get_lte_band_priority_list_resp_msg_v01 *rsp_msg = NULL;

  lte_rrc_get_band_pri_list_req_s msg;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( qmi_nasi_global.get_lte_band_p == NULL )
  {
    qmi_nasi_global.get_lte_band_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
      }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset(&msg, 0x00, sizeof(lte_rrc_get_band_pri_list_req_s) );
    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_GET_BAND_PRI_LIST_REQ );
    msg.lte_band_cap = qmi_nasi_global.cm_ph_info.lte_band_capability;

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("LTE Get Band Priority send fail %d", msgr_err);
    }
    else
    {
      response = QMI_SVC_RESPONSE_PENDING;
      QM_MSG_HIGH("LTE Get Band Priority Sent successfully to LTE-RRC pending response");
    }
    }
  
  if ( errval != QMI_ERR_NONE_V01 )
  {
    rsp_msg = (nas_get_lte_band_priority_list_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_lte_band_priority_list_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

    if( rsp_msg != NULL )
    {
      memset(rsp_msg, 0x00, sizeof(nas_get_lte_band_priority_list_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    QMI_NAS_GET_LTE_BAND_PRIORITY_LIST_RESP_MSG_V01,
                                    (void *)rsp_msg,
                                    (uint32_t)sizeof(nas_get_lte_band_priority_list_resp_msg_v01),
                                    &response
                                  );
      //Free the cmd_buf_p stored
      qmi_nasi_global.get_lte_band_p = NULL;
  }
  else
  {
      qmi_voice_mem_error();
    }
  }

  if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}

/*===========================================================================
  FUNCTION qmi_nasi_generate_get_lte_band_priority_list_resp()

  DESCRIPTION
    Generate and send response for get lte band priority list.
    
  PARAMETERS
    msg_p  

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_lte_band_priority_list_resp
(
  lte_rrc_get_band_pri_list_cnf_s * lte_get_band_pri_cnf
)
{
  dsm_item_type *             response = NULL;
  boolean                     retval = FALSE;
  qmi_cmd_buf_type           *cmd_buf_p = qmi_nasi_global.get_lte_band_p;
  qmi_error_type_v01            errval   = QMI_ERR_NONE_V01;
  nas_get_lte_band_priority_list_resp_msg_v01 *rsp_msg = NULL;
  int i=0;


  if ( cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in GET_LTE_BAND_PRIORITY_LIST resp: %d", cmd_buf_p);
    qmi_nasi_global.get_lte_band_p = NULL;
    return; //nothing to send
  }
  
  if(lte_get_band_pri_cnf)
    {

    QM_MSG_HIGH_2("LTE get band priority conf recv = %d, Supported = %d", lte_get_band_pri_cnf->num_configured_bands, lte_get_band_pri_cnf->num_supported_bands);

    rsp_msg = (nas_get_lte_band_priority_list_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_lte_band_priority_list_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

    if(rsp_msg)
    {
      memset(rsp_msg, 0, sizeof(nas_get_lte_band_priority_list_resp_msg_v01) );

      for ( i = 0; (i<NAS_LTE_BAND_PRIORITY_LIST_MAX_V01)&&(i < MIN(SYS_SBAND_LTE_EUTRAN_BAND_MAX, lte_get_band_pri_cnf->num_configured_bands)); i++ )
      {
        if( (rsp_msg->configured_band_priority_list[i] = qmi_nas_qmi_sys_lte_bc_2_lte_bc( lte_get_band_pri_cnf->configured_band_pri_list[i] )) == NAS_ACTIVE_BAND_ENUM_MAX_ENUM_VAL_V01 )
        {
          errval = QMI_ERR_INTERNAL_V01;
          rsp_msg->configured_band_priority_list_valid = FALSE;
          QM_MSG_ERROR_1("Received Invalid configured band from LTE RRC %d", lte_get_band_pri_cnf->configured_band_pri_list[i]);
          break;
        }
        QM_MSG_HIGH_2("Index=%d : configured band = %d", i, rsp_msg->configured_band_priority_list[i]);
      }

      if (errval == QMI_ERR_NONE_V01 && i > 0)
      {
        rsp_msg->configured_band_priority_list_valid = TRUE;
        rsp_msg->configured_band_priority_list_len = i;
      }

      i = 0;

      for ( i = 0; (i<NAS_LTE_BAND_PRIORITY_LIST_MAX_V01)&&(i < MIN(SYS_SBAND_LTE_EUTRAN_BAND_MAX, lte_get_band_pri_cnf->num_supported_bands)); i++ )
      {
        if( (rsp_msg->supported_band_priority_list[i] = qmi_nas_qmi_sys_lte_bc_2_lte_bc( lte_get_band_pri_cnf->supported_band_pri_list[i] )) == NAS_ACTIVE_BAND_ENUM_MAX_ENUM_VAL_V01 )
        {
          errval = QMI_ERR_INTERNAL_V01;
          rsp_msg->supported_band_priority_list_valid = FALSE;
          QM_MSG_ERROR_1("Received Invalid supported band from LTE RRC %d", lte_get_band_pri_cnf->supported_band_pri_list[i]);
          break;
        }
        QM_MSG_HIGH_2("Index=%d : supported band = %d", i, rsp_msg->supported_band_priority_list[i]);
      }

      if (errval == QMI_ERR_NONE_V01 && i > 0)
      {
        rsp_msg->supported_band_priority_list_valid = TRUE;
        rsp_msg->supported_band_priority_list_len = i;
      }

      
      if ( errval == QMI_ERR_NONE_V01 )
      {
        rsp_msg->resp.error  = QMI_ERR_NONE_V01;
        rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
    }
    else
    {
        rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
        rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
      }
    
      retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_RESPONSE,
                                             QMI_NAS_GET_LTE_BAND_PRIORITY_LIST_RESP_MSG_V01,
                                             (void *)rsp_msg,
                                             (uint32_t)sizeof(nas_get_lte_band_priority_list_resp_msg_v01),
                                             &response
                                           );
      if( retval )
      {
        qmi_nas_clnt_send_response(cmd_buf_p, response);
        /*Send QMI_NAS_GET_LTE_BAND_PRIORITY_LIST resp result*/		
      }
      //Free the cmd_buf_p stored
      qmi_nasi_global.get_lte_band_p = NULL;
    }
    else
    {
      qmi_voice_mem_error();
    }
    
    if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
    }
  else
  {
    QM_MSG_ERROR("MSGR get_lte_band_pri is NULL, no response sent");
  }
}


/*===========================================================================
  FUNCTION QMI_NASI_GET_SERVING_CELL_SIB()

  DESCRIPTION
    Message to get the serving cell sib
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_serving_cell_sib
( 
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type                *response   = NULL;
  qmi_error_type_v01            errval     = QMI_ERR_NONE_V01;
  errno_enum_type               msgr_err   = E_SUCCESS;
  nas_get_serv_cell_sib_req_msg_v01  *req_msg = NULL;
  nas_get_serv_cell_sib_resp_msg_v01 *rsp_msg = NULL;

  lte_rrc_get_serv_cell_sib_req_s msg;


  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_get_serv_cell_sib_req_msg_v01 *)modem_mem_alloc(sizeof(nas_get_serv_cell_sib_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

  if(!TARGET_SUPPORTS_LTE)
  {
    QM_MSG_ERROR("Target not supporting LTE");
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }
  else if(req_msg == NULL)
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
  {
    memset(req_msg, 0x00, sizeof(nas_get_serv_cell_sib_req_msg_v01));
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_mmode_idl_message_decode(qmi_nasi_global.svc_obj,
                                          (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                          sdu_in,
                                          (void *) req_msg,
                                          (uint32_t) sizeof(nas_get_serv_cell_sib_req_msg_v01)
                                         );
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_nas_008F_req_check(req_msg);
  }

  if ( qmi_nasi_global.get_serv_cell_sib == NULL )
  {
    qmi_nasi_global.get_serv_cell_sib = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset(&msg, 0x00, sizeof(lte_rrc_get_serv_cell_sib_req_s) );
    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_GET_SERV_CELL_SIB_REQ );
    msg.sib_num = req_msg->sib_num;
    QM_MSG_HIGH_1("sending sib_num = %d", msg.sib_num);

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("Get Serving Cell SIB send fail %d", msgr_err);
    }
    else
    {
      response = QMI_SVC_RESPONSE_PENDING;
      QM_MSG_HIGH("Get Serving Cell SIB sent successfully to LTE-RRC pending response");
    }
  }
  
  if ( errval != QMI_ERR_NONE_V01 )
  {
    rsp_msg = (nas_get_serv_cell_sib_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_serv_cell_sib_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

    if( rsp_msg != NULL )
    {
      memset(rsp_msg, 0x00, sizeof(nas_get_serv_cell_sib_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

     qmi_mmode_idl_message_encode(qmi_nasi_global.svc_obj,
                                       QMI_IDL_RESPONSE,
                                       QMI_NAS_GET_SERV_CELL_SIB_RESP_MSG_V01,
                                       (void *)rsp_msg,
                                       (uint32_t)sizeof(nas_get_serv_cell_sib_resp_msg_v01),
                                       &response
                                      );

      //Free the cmd_buf_p stored
      qmi_nasi_global.get_serv_cell_sib = NULL;
    }
    else
    {
      qmi_voice_mem_error();
    }
  }

  if ( req_msg != NULL ) { modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}


/*===========================================================================
  FUNCTION qmi_nasi_generate_get_serving_cell_sib_resp()

  DESCRIPTION
    Generate and send response for get serving cell SIB.
    
  PARAMETERS
    msg_p  

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_serving_cell_sib_resp
(
  lte_rrc_get_serv_cell_sib_cnf_s* lte_get_serv_cell_cnf
)
{
  dsm_item_type                        *response     = NULL;
  boolean                               retval       = FALSE;
  qmi_cmd_buf_type                     *cmd_buf_p    = qmi_nasi_global.get_serv_cell_sib;
  nas_get_serv_cell_sib_resp_msg_v01   *rsp_msg      = NULL;
  msgr_attach_struct_type *att_ptr;
  dsm_item_type *dsm_ptr;


  if(
      (cmd_buf_p == NULL) ||
      (cmd_buf_p->x_p == NULL)
    )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in GET_SERV_CELL_SIB resp: %d", cmd_buf_p);
    qmi_nasi_global.get_serv_cell_sib = NULL;
    return; //nothing to send
  }

  if(lte_get_serv_cell_cnf)
  {
    QM_MSG_HIGH_1("LTE get serving cell conf recv: lte_get_serv_cell_cnf->status = %d", lte_get_serv_cell_cnf->status);

    rsp_msg = (nas_get_serv_cell_sib_resp_msg_v01 *)modem_mem_alloc(sizeof(nas_get_serv_cell_sib_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE);

    if(rsp_msg)
    {
      memset(rsp_msg, 0, sizeof(nas_get_serv_cell_sib_resp_msg_v01));

      if(lte_get_serv_cell_cnf->status == LTE_RRC_GET_SIB_SUCCESS)
      {
        if(msgr_get_num_attach(&(lte_get_serv_cell_cnf->msgr_hdr)) == 1)
        {
          att_ptr = msgr_get_attach(&(lte_get_serv_cell_cnf->msgr_hdr), 0);
          msgr_get_dsm_attach(att_ptr, &dsm_ptr);
          if(dsm_ptr != NULL)
          {
            rsp_msg->total_size_valid   = TRUE;
            rsp_msg->total_size = dsm_length_packet(dsm_ptr);
          }
          else
          {
            QM_MSG_ERROR("Received a NULL dsm_ptr.");
            rsp_msg->resp.result   = QMI_RESULT_FAILURE_V01;
            rsp_msg->resp.error    = QMI_ERR_INTERNAL_V01;
          }
        }
        else
        {
          QM_MSG_ERROR_1("Invalid value for num_attach = %d.", msgr_get_num_attach(&(lte_get_serv_cell_cnf->msgr_hdr)));
          rsp_msg->resp.result   = QMI_RESULT_FAILURE_V01;
          rsp_msg->resp.error    = QMI_ERR_INTERNAL_V01;
        }
      }
      else
      {
        QM_MSG_ERROR_1("lte_get_serv_cell_cnf->status = %d.", lte_get_serv_cell_cnf->status);
        rsp_msg->resp.result   = QMI_RESULT_FAILURE_V01;
        rsp_msg->resp.error    = QMI_ERR_INTERNAL_V01;
      }

      retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_RESPONSE,
                                             QMI_NAS_GET_SERV_CELL_SIB_RESP_MSG_V01,
                                             (void *)rsp_msg,
                                             (uint32_t)sizeof(nas_get_serv_cell_sib_resp_msg_v01),
                                             &response
                                           );
      if( retval )
      {
        qmi_nas_clnt_send_response(cmd_buf_p, response);
        /*Send QMI_NAS_GET_SERV_CELL_SIB resp result*/
      }

      //Free the cmd_buf_p stored
      qmi_nasi_global.get_serv_cell_sib = NULL;
    }
    else
    {
      qmi_voice_mem_error();
    }
    
    if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
    }
  else
  {
    QM_MSG_ERROR("MSGR get_serv_cell_sib is NULL, no response sent");
  }
}



/*===========================================================================
  FUNCTION qmi_nasi_generate_get_serving_cell_sib_ind()

  DESCRIPTION
    Generate and send indication for get serving cell SIB.
    
  PARAMETERS
    msg_p  

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_get_serving_cell_sib_ind
(
  lte_rrc_get_serv_cell_sib_cnf_s *lte_get_serv_cell_cnf,
  qmi_nasi_client_state_type      *cl_sp
)
{
  nas_get_serv_cell_sib_ind_msg_v01   *ind_msg;
  dsm_item_type                       *ind = NULL;
  msgr_attach_struct_type             *att_ptr;
  dsm_item_type                       *dsm_ptr;
  uint16                               total_size, partial_pkt_size;
  uint8                                i, num_full_pkts;


  ind_msg = (nas_get_serv_cell_sib_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_get_serv_cell_sib_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if(ind_msg != NULL)
  {
    if(lte_get_serv_cell_cnf->status == LTE_RRC_GET_SIB_SUCCESS)
    {
      if(msgr_get_num_attach(&(lte_get_serv_cell_cnf->msgr_hdr)) == 1)
      {
        total_size = 0;
        att_ptr = msgr_get_attach(&(lte_get_serv_cell_cnf->msgr_hdr), 0);
        msgr_get_dsm_attach(att_ptr, &dsm_ptr);
        if(dsm_ptr != NULL)
        {
          total_size = dsm_length_packet(dsm_ptr);
        }
        num_full_pkts = (uint8)(total_size / NAS_GET_SERV_CELL_SIB_MAX_V01);
        partial_pkt_size = (uint16)(total_size % NAS_GET_SERV_CELL_SIB_MAX_V01);

        //Populate the packets with data
        for(i = 0; i < num_full_pkts; i++)
        {
          memset(ind_msg, 0, sizeof(nas_get_serv_cell_sib_ind_msg_v01));
          ind_msg->sequence = i;
          ind_msg->sib_pkt_len = dsm_pullup(&dsm_ptr, ind_msg->sib_pkt, (uint16)NAS_GET_SERV_CELL_SIB_MAX_V01);
          QM_MSG_HIGH_2("get_serv_cell_sib_ind: sequence = %d, sib_pkt_len = %d", ind_msg->sequence, ind_msg->sib_pkt_len);

          if(
              (cl_sp) &&
              (cl_sp->common.clid != QMI_SVC_CLID_UNUSED)
            )
          {
            ind = NULL;
            if(TRUE == qmi_mmode_idl_message_encode(qmi_nasi_global.svc_obj, 
                                                    QMI_IDL_INDICATION, 
                                                    (uint16_t)QMI_NAS_GET_SERV_CELL_SIB_IND_MSG_V01, 
                                                    (void *) ind_msg,
                                                    (uint32_t)sizeof(nas_get_serv_cell_sib_ind_msg_v01), 
                                                    &ind
                                                   )
              )
            {
              qm_nas_clnt_send_ind(cl_sp->common.clid, NASI_CMD_VAL_GET_SERVING_CELL_SIB, ind);
            }
            /*Else, False returned by qmi_mmode_idl_message_encode(). No indication sent*/
          }
        }

        //Populate the last packet with any pending data
        if(partial_pkt_size > 0)
        {
          memset(ind_msg, 0, sizeof(nas_get_serv_cell_sib_ind_msg_v01));
          ind_msg->sequence = i;
          ind_msg->sib_pkt_len = dsm_pullup(&dsm_ptr, ind_msg->sib_pkt, (uint16)partial_pkt_size);
          QM_MSG_HIGH_2("get_serv_cell_sib_ind: sequence = %d, sib_pkt_len = %d", ind_msg->sequence, ind_msg->sib_pkt_len);

          if(
              (cl_sp) &&
              (cl_sp->common.clid != QMI_SVC_CLID_UNUSED)
            )
          {
            ind = NULL;
            if(TRUE == qmi_mmode_idl_message_encode(qmi_nasi_global.svc_obj, 
                                                    QMI_IDL_INDICATION, 
                                                    (uint16_t)QMI_NAS_GET_SERV_CELL_SIB_IND_MSG_V01, 
                                                    (void *) ind_msg,
                                                    (uint32_t)sizeof(nas_get_serv_cell_sib_ind_msg_v01), 
                                                    &ind
                                                   )
              )
            {
              qm_nas_clnt_send_ind(cl_sp->common.clid, NASI_CMD_VAL_GET_SERVING_CELL_SIB, ind);
            }
            else
            {
              QM_MSG_ERROR("False returned by qmi_mmode_idl_message_encode(). No indication sent.");
            }
          }
        }
      }
    }

    modem_mem_free((void *)ind_msg,  MODEM_MEM_CLIENT_QMI_MMODE);
  }
  else
  {
    qmi_voice_mem_error();
  }
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_EMBMS_SIG_EXT ()

  DESCRIPTION
    Retrieves eMBMS signal strength information
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_embms_sig_ext
( 
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
#ifdef FEATURE_LTE_EMBMS
  errno_enum_type       msgr_err;
  nas_get_embms_sig_ext_req_msg_v01  *req_msg;
#endif
  nas_get_embms_sig_ext_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_embms_sig_ext_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_embms_sig_ext_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( qmi_nasi_global.cmd_buf_p == NULL )
  {
    qmi_nasi_global.embms_ext_cmd_buf_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

#ifdef FEATURE_LTE_EMBMS
  req_msg = (nas_get_embms_sig_ext_req_msg_v01 *) modem_mem_alloc( sizeof( nas_get_embms_sig_ext_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset( req_msg, 0, sizeof( nas_get_embms_sig_ext_req_msg_v01 ) );
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_GET_EMBMS_SIG_EXT_REQ_MSG_V01,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_get_embms_sig_ext_req_msg_v01)
                                         );

  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0081_req_check ( req_msg );
  }

  if( errval == QMI_ERR_NONE_V01 )
  {
    lte_rrc_embms_signal_strength_report_req_s msg;

    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_EMBMS_SIGNAL_STRENGTH_REQ );

    msg.debug_trace_id = req_msg->trace_id_valid ? req_msg->trace_id : -1;

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR_1("LTE_RRC_EMBMS_SIGNAL_STRENGTH_REQ send fail %d", msgr_err);
    }
  }
#else
  if( errval == QMI_ERR_NONE_V01 )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }
#endif

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
    QM_MSG_HIGH("Sent response pending for QMI_NAS_GET_EMBMS_SIG to QMI Framework");
    // Will respond after getting RSP message through MSGR
  }
  else
  {
  if ( rsp_msg != NULL )
  {
      memset( rsp_msg, 0, sizeof( nas_get_embms_sig_ext_resp_msg_v01 ) );

      rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    rsp_msg->resp.error  = errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                    (uint16_t)QMI_NAS_GET_EMBMS_SIG_EXT_RESP_MSG_V01,
                                  (void *) rsp_msg,
                                    (uint32_t) sizeof( nas_get_embms_sig_ext_resp_msg_v01 ),
                                  &response
                                );
  }
    else
    {
      qmi_voice_mem_error();
    }
  }

#ifdef FEATURE_LTE_EMBMS
  if ( req_msg!= NULL ) { modem_mem_free((void*)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
#endif
  if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_CONFIG_PLMN_NAME_IND_REPORTING()

  DESCRIPTION
    Message to configure the current_plmn_name_ind sending, whether to use
    legacy behavior or ignoring display condition.
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_config_plmn_name_ind_reporting
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type              *response = NULL;
  qmi_nasi_client_state_type *nasi_client_sp;
  qmi_error_type_v01          errval    = QMI_ERR_NONE_V01;

  nas_config_plmn_name_ind_reporting_req_msg_v01  *req_msg = NULL;
  nas_config_plmn_name_ind_reporting_resp_msg_v01 *rsp_msg = NULL;

  if ( sp == NULL || cmd_buf_p == NULL || cl_sp == NULL || sdu_in == NULL )
  {
    QM_MSG_ERROR_4("null ptr sp %p cmd_buf_p %p cl_sp %p sdu_in %p", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  nasi_client_sp = (qmi_nasi_client_state_type *) cl_sp;

  req_msg = (nas_config_plmn_name_ind_reporting_req_msg_v01 *) modem_mem_alloc( sizeof(nas_config_plmn_name_ind_reporting_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if( req_msg == NULL )
    {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if(errval == QMI_ERR_NONE_V01)
      {
    memset(req_msg, 0x00, sizeof(nas_config_plmn_name_ind_reporting_req_msg_v01) );

    
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_CONFIG_PLMN_NAME_IND_REPORTING_REQ_MSG_V01,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_config_plmn_name_ind_reporting_req_msg_v01)
                                         );
      }
  
  if (errval == QMI_ERR_NONE_V01)
      {
    errval = qmi_nas_0075_req_check(req_msg);
    }

  if (errval == QMI_ERR_NONE_V01)
    {
    struct report_status_s *p_rs = &nasi_client_sp->report_status;

    p_rs->ignore_plmn_display_cond_in_ind = req_msg->send_all_information ? TRUE : FALSE ;
          }

  rsp_msg = (nas_config_plmn_name_ind_reporting_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_config_plmn_name_ind_reporting_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if( rsp_msg != NULL )
    {
    memset(rsp_msg, 0x00, sizeof(nas_config_plmn_name_ind_reporting_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)QMI_NAS_CONFIG_PLMN_NAME_IND_REPORTING_RESP_MSG_V01,
                                  (void *)rsp_msg,
                                  (uint32_t)sizeof(nas_config_plmn_name_ind_reporting_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( req_msg != NULL ) { modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( rsp_msg != NULL ) { modem_mem_free((void *)rsp_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_SUBSCRIPTION_INFO()

  DESCRIPTION
    Provides current subscription information
    
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_get_subscription_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  nas_get_subscription_info_resp_msg_v01 * rsp_msg;
#ifdef FEATURE_DUAL_SIM
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
#endif

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_subscription_info_resp_msg_v01 *) 
  	        modem_mem_alloc( sizeof(nas_get_subscription_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_subscription_info_resp_msg_v01) );

#ifdef FEATURE_DUAL_SIM
    if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
    {
      asubs_id = SYS_MODEM_AS_ID_2;
    }
#ifdef FEATURE_TRIPLE_SIM
    else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
    {
      asubs_id = SYS_MODEM_AS_ID_3;
    }
#endif
    rsp_msg->resp.error  = QMI_ERR_NONE_V01;
    rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;

    rsp_msg->is_active = 
      qmi_nasi_global.subs_info[asubs_id].is_operational ? NAS_SUBSCRIPTION_ACTIVE_V01 : NAS_SUBSCRIPTION_NOT_ACTIVE_V01;

    rsp_msg->is_default_data_subs = qmi_nasi_global.subs_info[asubs_id].is_default_data ;
    rsp_msg->is_priority_subs = qmi_nasi_global.subs_info[asubs_id].is_priority_subs ? NAS_PRIORITY_SUBSCRIPTION_TRUE_V01: NAS_PRIORITY_SUBSCRIPTION_FALSE_V01;
    rsp_msg->voice_system_id = qmi_nasi_global.subs_info[asubs_id].hw_id[SYS_VSID_APP_CS_VOICE];
    rsp_msg->lte_voice_system_id = qmi_nasi_global.subs_info[asubs_id].hw_id[SYS_VSID_APP_IMS_LTE];
    rsp_msg->wlan_voice_system_id = qmi_nasi_global.subs_info[asubs_id].hw_id[SYS_VSID_APP_IMS_WLAN];
    
    rsp_msg->is_active_valid = TRUE;
    rsp_msg->is_default_data_subs_valid = TRUE;
    rsp_msg->is_priority_subs_valid = TRUE;
    rsp_msg->voice_system_id_valid = TRUE;
    rsp_msg->lte_voice_system_id_valid = TRUE;
    rsp_msg->wlan_voice_system_id_valid = TRUE;

    if(rsp_msg->is_default_data_subs)
    {
      rsp_msg->dds_type = (nas_dds_type_enum_v01)qmi_nasi_global.subs_info[asubs_id].dds_switch_type;
      rsp_msg->dds_type_valid = TRUE;
    }
    
    QM_MSG_HIGH_5("is_operational:%d, is_default_data_subs:%d, is_priority_subs:%d, asubs_id:%d, voice_system_id:%d", 
	rsp_msg->is_active, rsp_msg->is_default_data_subs, rsp_msg->is_priority_subs, asubs_id, rsp_msg->voice_system_id);
    
#else
    rsp_msg->resp.error  = QMI_ERR_NOT_SUPPORTED_V01;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    QM_MSG_HIGH("NOT SUPPORTED");
#endif

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_subscription_info_resp_msg_v01),
                                  &response
                                );
  }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NAS_SET_DRX_RESP() 

  DESCRIPTION
    Send response for SET_DRX
        
  PARAMETERS
    p_cmd_buf   : user data
    err         : error type
    
  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_set_drx_resp(qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type ph_cmd_err)
{
  dsm_item_type *response = NULL;
  qmi_error_e_type          errval;
  qmi_result_e_type         result;
  boolean                   retval;
  qmi_cmd_buf_type          *cmd_buf_p;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  errval = QMI_ERR_NONE;
  cmd_buf_p = (qmi_cmd_buf_type *) p_cmd_buf;

  if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in SET_DRX callback");
    return;
  }

  switch (ph_cmd_err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE;
      break;

    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS 
                                   : QMI_RESULT_FAILURE);
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
	/*Unable to send qmi_nas_set_drx_resp response*/
  }
}

/*===========================================================================
  FUNCTION QMI_NASI_SET_DRX ()

  DESCRIPTION
    Sets the DRX.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_drx 
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

  nas_set_drx_req_msg_v01  * req_msg;
  nas_set_drx_resp_msg_v01 * rsp_msg;
  sys_drx_cn_coefficient_s1_e_type drx_coeff;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_set_drx_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_drx_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_drx_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_drx_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_drx_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_SET_DRX_REQ_MSG_V01,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_drx_req_msg_v01)
                                         );
  }

  // check for error in REQ message
  if (errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_nas_0088_req_check( req_msg );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    drx_coeff = (sys_drx_cn_coefficient_s1_e_type) req_msg->drx;

    if ( !cm_ph_cmd_set_drx_req( qmi_nas_cmph_cmd_cb,
                                 cmd_buf_p,
                                 qmi_nasi_global.cm_clnt_id,
                                 drx_coeff ) )
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR("cm_ph_cmd_set_drx_req() failed");
    }
  }

  // take care of result
  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_set_drx() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_set_drx_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) QMI_NAS_SET_DRX_RESP_MSG_V01,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_drx_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_set_drx */

/*===========================================================================
  FUNCTION QMI_NAS_GET_DRX_RESP()

  DESCRIPTION
    Send response for GET_DRX
        
  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type
    
  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_get_drx_resp( sys_drx_cn_coefficient_s1_e_type drx_coefficient )
{
  dsm_item_type *           response = NULL;
  qmi_error_type_v01        errval = QMI_ERR_NONE_V01;
  nas_get_drx_resp_msg_v01 *rsp_msg;
  qmi_cmd_buf_type         *cmd_buf_p = qmi_nasi_global.get_drx_cmd_buf_p;

  if ( cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in GET_DRX resp: %d", cmd_buf_p);
    qmi_nasi_global.get_drx_cmd_buf_p = NULL;
    return; //nothing to send
  }

  rsp_msg = (nas_get_drx_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_drx_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
    qmi_nasi_global.get_drx_cmd_buf_p = NULL;
    return;
  }

  memset( rsp_msg, 0x00, sizeof(nas_get_drx_resp_msg_v01) );

  if ( errval == QMI_ERR_NONE_V01 )
  {
    rsp_msg->drx = (nas_drx_enum_v01) drx_coefficient;
    rsp_msg->drx_valid = TRUE;
  }

  rsp_msg->resp.error  = errval;
  rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;


  if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_RESPONSE,
                                     (uint16_t) QMI_NAS_GET_DRX_RESP_MSG_V01,
                                     (void *) rsp_msg,
                                     (uint32_t) sizeof(nas_get_drx_resp_msg_v01),
                                     &response
                                   ) )
  {
    qmi_nasi_send_response( cmd_buf_p, response);
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }

  if( rsp_msg ) { modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  qmi_nasi_global.get_drx_cmd_buf_p = NULL;
} /* qmi_nas_get_drx_resp() */

/*===========================================================================
  FUNCTION QMI_NAS_GET_DRX_ERR_RESP() 

  DESCRIPTION
    Send error response for GET_DRX
        
  PARAMETERS
    p_cmd_buf   : user data
    err         : error type
    
  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_get_drx_err_resp(qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type ph_cmd_err)
{
  dsm_item_type *response = NULL;
  boolean                   retval;
  qmi_cmd_buf_type          *cmd_buf_p = (qmi_cmd_buf_type *) p_cmd_buf;

  if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) || cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_HIGH("Received NULL cmd_buf in GET_DRX callback");
    qmi_nasi_global.get_drx_cmd_buf_p = NULL;
    return;
  }

  /*-------------------------------------------------------------------------
    If no error reported, then Don't send any response now. Response will be 
    sent when corresponding CM event(GET_DRX_CNF) occurs
  -------------------------------------------------------------------------*/
  if (ph_cmd_err == CM_PH_CMD_ERR_NOERR)
  {
    return;
  }

  retval = qmi_svc_put_result_tlv(&response, QMI_RESULT_FAILURE, QMI_ERR_INTERNAL);
  if (FALSE == retval)
  {
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nasi_send_response( cmd_buf_p, response);
	/*Send qmi_nas_get_drx_resp response*/
  }

  qmi_nasi_global.get_drx_cmd_buf_p = NULL;
}

/*===========================================================================
  FUNCTION QMI_NASI_GET_DRX ()

  DESCRIPTION
    Gets the DRX.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_drx 
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  if ( qmi_nasi_global.get_drx_cmd_buf_p == NULL )
  {
    qmi_nasi_global.get_drx_cmd_buf_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    if ( !cm_ph_cmd_get_drx_req( qmi_nas_cmph_cmd_cb,
                                 cmd_buf_p,
                                 qmi_nasi_global.cm_clnt_id ) )
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR("cm_ph_cmd_get_drx_req() failed");
    }
  }

  // take care of result
  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH("qmi_nasi_get_drx() returning QMI_SVC_RESPONSE_PENDING");
    response = (dsm_item_type *) QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    nas_get_drx_resp_msg_v01 * rsp_msg;
    rsp_msg = (nas_get_drx_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_drx_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    if ( rsp_msg == NULL )
    {
      qmi_voice_mem_error();
    }
    else
    {
      memset( rsp_msg, 0x00, sizeof(nas_get_drx_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t) QMI_NAS_GET_DRX_RESP_MSG_V01,
                                    (void *) rsp_msg,
                                    (uint32_t) sizeof(nas_get_drx_resp_msg_v01),
                                    &response
                                  );

      modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    }

    qmi_nasi_global.get_drx_cmd_buf_p = NULL;
  }

  return response;
} /* qmi_nasi_get_drx */

/*===========================================================================
  FUNCTION QMI_NASI_SSAC_INFO_IND()

  DESCRIPTION
    Generate and send SSAC info indication
    
  PARAMETERS
    msg_p  Pointer to MSGR data for ssac params info

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_ssac_info_ind
(
  lte_rrc_ssac_params_s * ssac_ind
)
{
  int                              clid;
  qmi_nasi_client_state_type      *cl_sp;
  nas_ssac_info_ind_msg_v01 *ind_msg;
  dsm_item_type                   *ind = NULL;

  ind_msg = (nas_ssac_info_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_ssac_info_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ind_msg != NULL )
  {
    memset( ind_msg, 0x00, sizeof(nas_ssac_info_ind_msg_v01) );

    QM_MSG_HIGH_4("SSAC INFO IND: barring_factor_voice %d, barring_time %d, barring_factor_video %d,barring_time %d", 
		ssac_ind->barring_factor_mmtel_voice, ssac_ind->barring_time_mmtel_voice,ssac_ind->barring_factor_mmtel_video, ssac_ind->barring_time_mmtel_video);

    if(ssac_ind->barring_time_mmtel_voice == QMI_NAS_SSAC_INVALID_BARR_TIME )
    {
      ssac_ind->barring_factor_mmtel_voice = 100;
      ssac_ind->barring_time_mmtel_voice = 0;
      ind_msg->ssac_info.barring_factor_voice = 100;
      ind_msg->ssac_info.barring_time_voice = 0;
    }
    else 
    {
      if(ssac_ind->barring_time_mmtel_voice == 0xFFFF)
      {
        ind_msg->ssac_info.barring_time_voice = 0;
      }
      else
      {
        ind_msg->ssac_info.barring_time_voice = ssac_ind->barring_time_mmtel_voice;
      }
      if(ssac_ind->barring_factor_mmtel_voice == 0xFF)
      {
        ind_msg->ssac_info.barring_factor_voice = 100;
      }
      else
      {
        ind_msg->ssac_info.barring_factor_voice = ssac_ind->barring_factor_mmtel_voice;
      }
    }
    if(ssac_ind->barring_time_mmtel_video == QMI_NAS_SSAC_INVALID_BARR_TIME )
    {
      ssac_ind->barring_factor_mmtel_video = 100;
      ssac_ind->barring_time_mmtel_video = 0;
      ind_msg->ssac_info.barring_factor_video = 100;
      ind_msg->ssac_info.barring_time_video = 0;
    }
    else 
    {
      if(ssac_ind->barring_time_mmtel_video == 0xFFFF)
      {
        ind_msg->ssac_info.barring_time_video = 0;
      }
      else
      {
    ind_msg->ssac_info.barring_time_video = ssac_ind->barring_time_mmtel_video;
      }
      if(ssac_ind->barring_factor_mmtel_video == 0xFF)
      {
        ind_msg->ssac_info.barring_factor_video = 100;
      }
      else
      {
        ind_msg->ssac_info.barring_factor_video = ssac_ind->barring_factor_mmtel_video;
      }
    }

    ind_msg->ssac_info_valid = TRUE;

      for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
      {
        cl_sp = qmi_nas_state.client[clid];

        if (  cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
              cl_sp->report_status.report_ssac_info )
        {
          ind = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj, 
                                                    QMI_IDL_INDICATION, 
                                                    (uint16_t)QMI_NAS_SSAC_INFO_IND_V01, 
                                                    (void *) ind_msg,
                                                    (uint32_t)sizeof(nas_ssac_info_ind_msg_v01), 
                                                    &ind
                                                  ) )
          {
            qm_nas_clnt_send_ind( cl_sp->common.clid, NASI_CMD_VAL_SSAC_INFO_IND, ind );
          }
        }
      }


    modem_mem_free((void *)ind_msg,  MODEM_MEM_CLIENT_QMI_MMODE);
  }
  else
  {
    qmi_voice_mem_error();
  }
}

/*===========================================================================
  FUNCTION FILTER_PERIODIC_CSG_NETWORKS_TO_SCAN()

  DESCRIPTION
    Given QMI_NAS_CSG_SEARCH_SELECTION_CONFIG_REQ with network_type,
    filter mask based on networks supported by target,
    masking off bits of unsupported networks.

  PARAMETERS
    network_type - Bitmask representing the network types to scan. Values:
      Bit 1 -- UMTS
      Bit 2 -- LTE

  RETURN VALUE
    modified network scan mask (see parameter above)

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint8 filter_periodic_csg_networks_to_scan( uint8 network_type )
{
  // mask off network scan bits that the target does not support

  if ( ! TARGET_SUPPORTS_GSM   ) { network_type &= ~ NAS_NETWORK_TYPE_GSM_ONLY_V01;   }

  if ( ! TARGET_SUPPORTS_WCDMA ) { network_type &= ~ NAS_NETWORK_TYPE_WCDMA_ONLY_V01; }

  if ( ! TARGET_SUPPORTS_LTE   ) { network_type &= ~ NAS_NETWORK_TYPE_LTE_ONLY_V01;   }

  // NOTE:  NI-3.2 and beyond supports TD-SCDMA, so we test and mask it, like the RATS above.

  if ( ! TARGET_SUPPORTS_TDS   ) { network_type &= ~ NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01;   }

  // NOTE:  For pre-NI-3.2, TD-SCDMA is not supported, so we need to mask off the bit for TDS network scan also

  network_type &= ( NAS_NETWORK_TYPE_WCDMA_ONLY_V01 | NAS_NETWORK_TYPE_LTE_ONLY_V01 );

  QM_MSG_HIGH_2("mode_capability = %d,network_type=%d", qmi_nasi_global.cm_ph_info.mode_capability, network_type);

  return network_type;
}

/*===========================================================================
  FUNCTION QMI_NASI_CSG_SEARCH_SELECTION_CONFIG()

  DESCRIPTION
    Configures and triggers Periodic CSG search.and selection.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_csg_search_selection_config
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type             * response = NULL;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
  boolean                     retval   = TRUE;
  nas_csg_search_selection_config_req_msg_v01  * req_msg;
  nas_csg_search_selection_config_resp_msg_v01 * rsp_msg;
  int                         i;
  cm_mode_pref_e_type         mode_pref = CM_MODE_PREF_WCDMA_LTE;
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
  cm_network_list_type_e_type list_type = CM_NETWORK_LIST_CSG_USER;
  cm_band_pref_e_type         umts_band_pref     = CM_BAND_PREF_ANY,
                              lte_band_pref = CM_BAND_PREF_LTE_ANY;
  errno_enum_type              msgr_err;
  uint8                       filtered_network_type;
  mmode_qmi_nas_csg_search_select_config_cmd_msg_type csg_search_sel_config;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_csg_search_selection_config_req_msg_v01*) modem_mem_alloc( sizeof(nas_csg_search_selection_config_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_csg_search_selection_config_resp_msg_v01*) modem_mem_alloc( sizeof(nas_csg_search_selection_config_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#ifdef FEATURE_TRIPLE_SIM
   else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
   {
     asubs_id = SYS_MODEM_AS_ID_3;
   }
#endif
#endif
  if ( ! TARGET_SUPPORTS_WCDMA && ! TARGET_SUPPORTS_LTE )
  {
    QM_MSG_ERROR("Target not supporting UMTS/LTE");
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
  {
    memset( req_msg, 0x00, sizeof(nas_csg_search_selection_config_req_msg_v01) );
    memset( &csg_search_sel_config, 0x00, sizeof(mmode_qmi_nas_csg_search_select_config_cmd_msg_type));
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_csg_search_selection_config_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_008A_req_check( req_msg );
  }


  if ( errval == QMI_ERR_NONE_V01 )
  {
    
    if( req_msg->network_type_valid )
    {
      if ( req_msg->network_type == 0 )
      {
        mode_pref = CM_MODE_PREF_NO_CHANGE;
      }
      else
      {
        filtered_network_type = filter_periodic_csg_networks_to_scan( req_msg->network_type );
        retval = FALSE; // assume no match, until proven otherwise by the loop below...
        for( i = 0 ; i < QMI_NAS_ARR_SIZE(qmi_nas_allowed_network_types) ; i++ )
        {
          if ( filtered_network_type == qmi_nas_allowed_network_types[i].network_type )
          {
            mode_pref = qmi_nas_allowed_network_types[i].cm_val;
            retval = TRUE; // a match has been found, proceed as before.
            break;
          }
        }

        if ( !retval ) 
        { 
          errval = QMI_ERR_INVALID_OPERATION_V01;
        }

        QM_MSG_HIGH_3("qmi_nasi_search_select_config() network_type = %d, filtered = %d, change = %d.", req_msg->network_type, filtered_network_type, req_msg->network_type ^ filtered_network_type);
      }
    }

    QM_MSG_HIGH_3("network_type_valid = %d mode_pref = %d retval = %d (T/F)", req_msg->network_type_valid, mode_pref, retval);
    if ( req_msg->umts_band_pref_valid )
    {
      umts_band_pref = (cm_band_pref_e_type) req_msg->umts_band_pref;
    }
    if ( req_msg->lte_band_pref_valid )
    {
      lte_band_pref = (cm_band_pref_e_type) req_msg->lte_band_pref;
    }
  }

if (errval == QMI_ERR_NONE_V01)
{
    msgr_init_hdr( (msgr_hdr_struct_type*)&csg_search_sel_config, MSGR_QMI_NAS, QMI_NAS_CSG_SEARCH_SELECTION_CONFIG_CMD );
    csg_search_sel_config.csg_search_select_config_req.asubs_id = asubs_id;
    csg_search_sel_config.csg_search_select_config_req.select_config = req_msg->selection_config_type;
    csg_search_sel_config.csg_search_select_config_req.network_type = mode_pref;
    csg_search_sel_config.csg_search_select_config_req.list_type = list_type;
    csg_search_sel_config.csg_search_select_config_req.umts_band_pref = umts_band_pref;
    csg_search_sel_config.csg_search_select_config_req.lte_band_pref = lte_band_pref;
    if( req_msg->search_type_valid )
    {
      csg_search_sel_config.csg_search_select_config_req.search_mode = req_msg->search_type;
    }
    else
    {
      csg_search_sel_config.csg_search_select_config_req.search_mode = 1; //Home+Roaming
    }

    if(req_msg->search_timer_valid)
    {
      csg_search_sel_config.csg_search_select_config_req.search_timer = req_msg->search_timer;
    }

    QM_MSG_HIGH_8("asubs_id = %d select_config = %d nw_type = %d, list_type = %d umts_band = %ld retval = %d, lte_band =%ld,Search timer = %d", 
		asubs_id, req_msg->selection_config_type, mode_pref,list_type, umts_band_pref, csg_search_sel_config.csg_search_select_config_req.search_mode,
		lte_band_pref, csg_search_sel_config.csg_search_select_config_req.search_timer);

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&csg_search_sel_config, sizeof(csg_search_sel_config) );

    if(msgr_err != E_SUCCESS)
    {
       QM_MSG_ERROR_1("Error sending QMI_NAS_CSG_SEARCH_SELECTION_CONFIG_CMD response %d", msgr_err);
       errval = QMI_ERR_MALFORMED_MSG_V01;
    }
}

if ( rsp_msg != NULL )
{
  memset(rsp_msg, 0, sizeof(nas_csg_search_selection_config_resp_msg_v01) );
  rsp_msg->resp.error  = errval;
  rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

  qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                QMI_IDL_RESPONSE,
                                (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                (void *)rsp_msg,
                                (uint32_t)sizeof(nas_csg_search_selection_config_resp_msg_v01),
                                &response
                              );
}
else
{
  qmi_voice_mem_error();
}

if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg,  MODEM_MEM_CLIENT_QMI_MMODE); }
if ( rsp_msg != NULL ){ modem_mem_free((void *)rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

return response;

}
/*===========================================================================
  FUNCTION qmi_nasi_csg_immediate_search_selection()

  DESCRIPTION
   Triggers immediate CSG search.and selection based on configured params.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_csg_immediate_search_selection
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type             * response = NULL;
  nas_csg_immediate_search_selection_resp_msg_v01 *rsp_msg;
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
  mmode_qmi_nas_csg_immediate_search_select_cmd_msg_type csg_trigger;
  errno_enum_type              msgr_err;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
  
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_csg_immediate_search_selection_resp_msg_v01*) modem_mem_alloc( sizeof(nas_csg_immediate_search_selection_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if(rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#ifdef FEATURE_TRIPLE_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
  {
    asubs_id = SYS_MODEM_AS_ID_3;
  }
#endif
#endif
  if ( ! TARGET_SUPPORTS_WCDMA && ! TARGET_SUPPORTS_LTE )
  {
    QM_MSG_ERROR("Target not supporting UMTS/LTE");
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    msgr_init_hdr( (msgr_hdr_struct_type*)&csg_trigger, MSGR_QMI_NAS, QMI_NAS_CSG_IMMEDIATE_SEARCH_SELECTION_CMD );
    csg_trigger.csg_immediate_search_select_req.asubs_id = asubs_id;
    QM_MSG_HIGH_1("Sending asubs_id = %d select_config = %d network_type = %d", asubs_id);
    msgr_err = msgr_send( (msgr_hdr_struct_type*)&csg_trigger, sizeof(csg_trigger) );

    if(msgr_err != E_SUCCESS)
    {
      QM_MSG_ERROR_1("Error sending QMI_NAS_CSG_IMMEDIATE_SEARCH_SELECTION_CMD response %d", msgr_err);
      errval = QMI_ERR_MALFORMED_MSG_V01;
    }
  }
  
  if ( rsp_msg != NULL )
  {
    memset(rsp_msg, 0, sizeof(nas_csg_immediate_search_selection_resp_msg_v01) );
    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
  
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                  (void *)rsp_msg,
                                  (uint32_t)sizeof(nas_csg_immediate_search_selection_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
   /*Not enough memory to allocate for QMI_NAS_CSG_SEARCH_SELECT_CONFIG response*/
  }
  
  if ( rsp_msg != NULL ){ modem_mem_free((void *)rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  
  return response;

}

/*===========================================================================
  FUNCTION qmi_nasi_get_csg_search_selection_config()

  DESCRIPTION
   Get CSG search.and selection params.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_csg_search_selection_config
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type             * response = NULL;
  nas_get_csg_search_selection_configuration_resp_msg_v01 *rsp_msg;
  qmi_error_type_v01          errval   = QMI_ERR_NONE_V01;
  mcfg_fs_status_e_type status;
  int i=0;
  qmi_nas_csg_search_select_config_s_type csg_search_select_config;
  boolean retval=FALSE;
  uint8 network_type=0;
  
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  rsp_msg = (nas_get_csg_search_selection_configuration_resp_msg_v01*) modem_mem_alloc( sizeof(nas_get_csg_search_selection_configuration_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if(rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( ! TARGET_SUPPORTS_WCDMA && ! TARGET_SUPPORTS_LTE )
  {
    QM_MSG_ERROR("Target not supporting UMTS/LTE");
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if ( rsp_msg != NULL )
  {
  memset(rsp_msg, 0, sizeof(nas_get_csg_search_selection_configuration_resp_msg_v01) );
  memset(&csg_search_select_config,0,sizeof(csg_search_select_config));

  // read efs file and mark is_efs_read as TRUE so that EFS file is not attempted to read next time
  status = mcfg_fs_read (QMI_NAS_TUI_CSG_CONFIG_EFS_FILE, (void *)&csg_search_select_config, (uint32) sizeof(qmi_nas_csg_search_select_config_s_type), MCFG_FS_TYPE_EFS, MCFG_FS_SUBID_0 );
  
  if( status == MCFG_FS_STATUS_OK )
  {
      QM_MSG_HIGH_7("CSG interval %d in minutes, mode=%d, list type %d,network_type=%d, band_pref %ld,lte_band=%ld,select_config = %d", 
	  	csg_search_select_config.search_timer, csg_search_select_config.search_mode, csg_search_select_config.list_type, csg_search_select_config.network_type,
	  	csg_search_select_config.umts_band_pref, csg_search_select_config.lte_band_pref, csg_search_select_config.select_config);
    rsp_msg->search_timer_valid = TRUE;
    rsp_msg->search_timer = csg_search_select_config.search_timer;
    rsp_msg->search_type_valid = TRUE;
    rsp_msg->search_type = csg_search_select_config.search_mode;
    rsp_msg->umts_band_pref_valid = TRUE;
    rsp_msg->umts_band_pref = csg_search_select_config.umts_band_pref;
    rsp_msg->lte_band_pref_valid = TRUE;
    rsp_msg->lte_band_pref = csg_search_select_config.lte_band_pref;
    rsp_msg->selection_config_type_valid = TRUE;
    rsp_msg->selection_config_type = csg_search_select_config.select_config;

    for( i = 0 ; i < QMI_NAS_ARR_SIZE(qmi_nas_allowed_network_types) ; i++ )
    {
      if ( csg_search_select_config.network_type == qmi_nas_allowed_network_types[i].cm_val)
      {
        network_type = qmi_nas_allowed_network_types[i].network_type;
        retval = TRUE; // a match has been found, proceed as before.
        break;
      }
    }
    if(retval == TRUE)
    {
      rsp_msg->network_type_valid = TRUE;
      rsp_msg->network_type = network_type;
    }
  }
  else
  {
    QM_MSG_ERROR_1("efs_get QMI_NAS_TUI_CSG_CONFIG_EFS_FILE read failed status %d", status);
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
  
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                  (void *)rsp_msg,
                                  (uint32_t)sizeof(nas_get_csg_search_selection_configuration_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }
  
  if ( rsp_msg != NULL ){ modem_mem_free((void *)rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  
  return response;

}

/*===========================================================================
  FUNCTION QMI_NASI_PERFORM_INCREMENTAL_NETWORK_SCAN()

  DESCRIPTION
    Performs the network scan and gives results incrementally.
    
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    Pointer to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_nasi_perform_incremental_network_scan 
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_type_v01  errval   = QMI_ERR_NONE_V01;
  boolean              retval = TRUE;
  nas_perform_incremental_network_scan_req_msg_v01  * req_msg;
  nas_perform_incremental_network_scan_resp_msg_v01 * rsp_msg;
  int i;
  cm_mode_pref_e_type mode_pref = CM_MODE_PREF_GWL;
  sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;
  cm_network_list_type_e_type list_type = CM_NETWORK_LIST_AVAILABLE;

  uint8                       filtered_network_type;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_perform_incremental_network_scan_req_msg_v01  *) 
  	        modem_mem_alloc( sizeof(nas_perform_incremental_network_scan_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_perform_incremental_network_scan_resp_msg_v01 *) 
  	        modem_mem_alloc( sizeof(nas_perform_incremental_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

#ifdef FEATURE_DUAL_SIM
  if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
  {
    asubs_id = SYS_MODEM_AS_ID_2;
  }
#ifdef FEATURE_TRIPLE_SIM
  else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
  {
    asubs_id = SYS_MODEM_AS_ID_3;
  }
#endif
#endif
  if ( !TARGET_SUPPORTS_GSM && !TARGET_SUPPORTS_WCDMA && !TARGET_SUPPORTS_LTE && !TARGET_SUPPORTS_TDS )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }
  else
  {
    memset( req_msg, 0x00, sizeof(nas_perform_network_scan_req_msg_v01) );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_perform_incremental_network_scan_req_msg_v01)
                                         );
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = qmi_nas_0085_req_check( req_msg );
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    if ( qmi_nasi_global.net_scan_started )
    {
      errval = QMI_ERR_DEVICE_IN_USE_V01;
      QM_MSG_HIGH_2( "Net scan ongoing on subscription:%d, %d", qmi_nasi_global.net_scan_asubs_id, asubs_id );
    }
    else
    {
      if( req_msg->network_type_valid )
      {
        if ( req_msg->network_type == 0 )
        {
          mode_pref = CM_MODE_PREF_NO_CHANGE;
        }
        else
        {
          filtered_network_type = filter_networks_to_scan( req_msg->network_type );
          retval = FALSE; // assume no match, until proven otherwise by the loop below...

          for( i = 0; i < QMI_NAS_ARR_SIZE(qmi_nas_allowed_network_types); i++ )
          {
            if ( filtered_network_type == qmi_nas_allowed_network_types[i].network_type )
            {
              mode_pref = qmi_nas_allowed_network_types[i].cm_val;
              retval = TRUE; // a match has been found, proceed as before.
              break;
            }
          }
          if ( ! retval ) { errval = QMI_ERR_INTERNAL_V01; }
          QM_MSG_HIGH_3( "qmi_nasi_perform_network_scan() network_type = %d, filtered = %d, change = %d.",
                     req_msg->network_type, filtered_network_type, req_msg->network_type ^ filtered_network_type );
        }
      }

      QM_MSG_HIGH_3( "network_type_valid = %d mode_pref = %d retval = %d (T/F)", req_msg->network_type_valid, mode_pref, retval );

      if( req_msg->scan_type_valid )
      {
        if( req_msg->scan_type == NAS_SCAN_TYPE_CSG_V01 )
        {
#ifdef FEATURE_FEMTO_CSG
          list_type = CM_NETWORK_LIST_CSG;
#else
          errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif
        }

        else if(req_msg->scan_type == NAS_SCAN_TYPE_MODE_PREF_V01)
        {
          list_type = CM_NETWORK_LIST_WITH_MAX_CAP;
        }
      }

      if ( errval == QMI_ERR_NONE_V01 )
      {
        if ( asubs_id == SYS_MODEM_AS_ID_1 )
        {
          retval = cm_ph_cmd_get_networks(qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, list_type, mode_pref);
        }
#if defined(FEATURE_DUAL_SIM) || defined(FEATURE_TRIPLE_SIM) 
        else 
        {
          retval = cm_ph_cmd_get_networks_per_subs(qmi_nas_cmph_cmd_cb, NULL, qmi_nasi_global.cm_clnt_id, list_type, mode_pref, asubs_id );
        }
#endif
      }

      if ( retval )
      {
        qm_cbpq_add ( QM_CBPQ_QTYPE_NW_SCAN, cmd_buf_p, ((qmi_nasi_client_state_type *)cl_sp)->common.clid );
			
        QM_MSG_HIGH( "Starting Incremental Net Scan, waiting for response");
        qmi_nasi_global.net_scan_started = TRUE;
        qmi_nasi_global.net_scan_asubs_id = asubs_id;
        qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_INPROGRESS;
        qmi_nasi_global.incremental_net_scan_clid = ((qmi_nasi_client_state_type *)cl_sp)->common.clid;
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
      }
    }
  }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
    // shall react to CM_PH_CMD_GET_NETWORKS and CM_PH_EVENT_AVAILABLE_NETWORKS_CONF later
  } 
  else  if ( rsp_msg == NULL )
  {
    qmi_voice_mem_error();
  }
  else if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_perform_incremental_network_scan_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_perform_incremental_network_scan_resp_msg_v01),
                                  &response
                                );
  }
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_PERFORM_INCREMENTAL_NETWORK_SCAN_IND()

  DESCRIPTION
    Generate indication for perform incremental network scan after mmgsdi callback

  PARAMETERS
    name_cnf : mmgsdi callback information

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_perform_incremental_network_scan_ind(const mmgsdi_session_get_operator_name_cnf_type * name_cnf)
{
  nas_perform_incremental_network_scan_ind_msg_v01  *ind_msg   = NULL;
  dsm_item_type                  * indication      = NULL;
  qmi_nasi_client_state_type     *cl_sp = NULL;

  sys_detailed_plmn_list_s_type        *available_networks = NULL;
  struct qmi_nasi_mmgsdi_client_data_s *callback_data = NULL;

  qmi_error_e_type       errval = QMI_ERR_NONE;

  boolean is_plmn_undefined      = FALSE;
  boolean mnc_includes_pcs_digit = FALSE;
  boolean net_info_available     = FALSE;
  boolean rat_match              = FALSE, rat_match_2 = FALSE;

  int          sys_plmn_list_index = 0;
  int          network_info_index  = 0;
  int          csg_network_info_index  = 0;
  int          num_networks        = 0;
  sys_mcc_type mcc                 = 0;
  sys_mnc_type mnc                 = 0;
  int          i                   = 0;
  uint8 encoding_type = 0;
  int j = 0;
  uint8 network_name_len = 0;
  uint16 buff_ptr[(NASI_MAX_LEN_NETWORK_NAME/2)];
  boolean is_plmn_2_valid=FALSE;
  sys_plmn_id_s_type current_plmn, current_plmn_2; //initialized for each cmd_buffer
  sys_sys_mode_e_type current_sys_mode = SYS_SYS_MODE_NONE, current_sys_mode_2 = SYS_SYS_MODE_NONE;

  sys_plmn_id_s_type plmn_main_stack = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn_avail ?
                                              qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn :
                                              qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].sys_id.id.plmn ;

  sys_sys_mode_e_type sys_mode_main_stack = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].sys_mode;
  sys_sys_mode_e_type sys_mode_gw_stack   = SYS_SYS_MODE_NONE;

  sys_srv_status_e_type main_stack_srv = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].srv_status;
  sys_srv_status_e_type gw_stack_srv = SYS_SRV_STATUS_NO_SRV;

  //Get the client cl_sp
  if ( qmi_nasi_global.incremental_net_scan_clid > QMI_SVC_CLID_UNUSED &&
       qmi_nasi_global.incremental_net_scan_clid <= NASI_MAX_CLIDS)
  {
     cl_sp = qmi_nas_state.client[qmi_nasi_global.incremental_net_scan_clid-1];
     if(cl_sp == NULL)
     {
       QM_MSG_HIGH_2( "qmi_nasi_generate_perform_incremental_network_scan_ind - cl_sp is NULL(%d),clid:%d!",
              cl_sp,qmi_nasi_global.incremental_net_scan_clid);
       errval = QMI_ERR_INVALID_CLIENT_ID;
     }
  }
  else
  {
    QM_MSG_HIGH_2( "qmi_nasi_generate_perform_incremental_network_scan_ind - invalid clid:%d ",
              cl_sp,qmi_nasi_global.incremental_net_scan_clid);
    errval = QMI_ERR_INVALID_CLIENT_ID;
  }

  QM_MSG_HIGH_2( "generate_perform_incremental_network_scan main_stack = %d,srv=%d", sys_mode_main_stack, main_stack_srv );  
  if( qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].number_of_stacks > 1 &&
      qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_mode != SYS_SYS_MODE_HDR )
  {
    sys_mode_gw_stack = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].sys_mode;
    gw_stack_srv = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_0].srv_status;
    QM_MSG_HIGH_2( "generate_perform_incremental_network_scan gw_stack = %d,srv=%d", sys_mode_gw_stack, gw_stack_srv );
  }

  callback_data = (struct qmi_nasi_mmgsdi_client_data_s *) name_cnf->response_header.client_data;
  if( callback_data != NULL )
  {
    available_networks = (sys_detailed_plmn_list_s_type *) callback_data->cmd_buf_ptr;
  }
  else
  {
    QM_MSG_ERROR( "qmi_nasi_generate_perform_incremental_network_scan_ind - callback_data is NULL!");
    errval = QMI_ERR_INTERNAL;
  }

  ind_msg = ( nas_perform_incremental_network_scan_ind_msg_v01 *) modem_mem_alloc( 
                                           sizeof(nas_perform_incremental_network_scan_ind_msg_v01), 
                                           MODEM_MEM_CLIENT_QMI_MMODE );
  if( ind_msg == NULL)
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY;
  }

  if( errval == QMI_ERR_NONE )
  {
    memset(ind_msg, 0, sizeof(nas_perform_incremental_network_scan_ind_msg_v01));

    // Update current PLMN based on subscription
    if( qmi_nasi_global.net_scan_asubs_id == SYS_MODEM_AS_ID_2 )
    {
        current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn_avail ?
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].mode_info.gw_info.mm_information.plmn :
                       qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].sys_id.id.plmn ;
        current_sys_mode = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_2].stack_info[STACK_INDEX_0].sys_mode;
    }
    else 
    {
        if( qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].number_of_stacks > 1 &&
            qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_mode != SYS_SYS_MODE_HDR )        
        {
          current_plmn = qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.plmn_avail ?
                          qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].mode_info.gw_info.mm_information.plmn :
                          qmi_nasi_global.cm_msim_ss_info[SYS_MODEM_AS_ID_1].stack_info[STACK_INDEX_1].sys_id.id.plmn ;;
          current_sys_mode = sys_mode_gw_stack;

          if( (sys_mode_main_stack == SYS_SYS_MODE_GSM || sys_mode_main_stack == SYS_SYS_MODE_WCDMA || sys_mode_main_stack == SYS_SYS_MODE_TDS || sys_mode_main_stack == SYS_SYS_MODE_LTE) && 
              (main_stack_srv == SYS_SRV_STATUS_SRV) )
          {
            current_plmn_2 = plmn_main_stack;
            current_sys_mode_2 = sys_mode_main_stack;
            is_plmn_2_valid = TRUE;
            QM_MSG_HIGH_1( "generate_perform_incremental_network_scan is_plmn_2_valid = %d", is_plmn_2_valid );
          }
        }
      else
      {
        current_plmn = plmn_main_stack;
        current_sys_mode = sys_mode_main_stack;
      }
    }

    if( available_networks->length > NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX )
    {
      QM_MSG_ERROR_2( "Received %d available networks, max is %d", available_networks->length, NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX );
      num_networks = NAS_PERFORM_NET_SCAN_3GPP_NW_INFO_LIST_MAX;
    }
    else
    {
      num_networks = available_networks->length;
    }

    // For every PLMN value in the list of available networks fill in TLVs
      // 0x10, 0x11
    for(sys_plmn_list_index=0; sys_plmn_list_index < num_networks; sys_plmn_list_index++)
    {
      net_info_available = FALSE;
      sys_plmn_get_mcc_mnc(available_networks->info[sys_plmn_list_index].plmn,
                           &is_plmn_undefined,
                           &mnc_includes_pcs_digit,
                           &mcc,
                           &mnc ); 
      if(!is_plmn_undefined)
      {
        // TLV 0x10 (3GPP NETWORK INFORMATION)
        ind_msg->nas_network_scan_info[network_info_index].mobile_country_code = (uint16) mcc;
        ind_msg->nas_network_scan_info[network_info_index].mobile_network_code = (uint16) mnc;
        rat_match = FALSE, rat_match_2 = FALSE;
        switch ( current_sys_mode )
        {
          case SYS_SYS_MODE_GSM:
            rat_match = ( available_networks->info[sys_plmn_list_index].rat ==  SYS_RAT_GSM_RADIO_ACCESS );
            break;
          case SYS_SYS_MODE_WCDMA:        
            rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_UMTS_RADIO_ACCESS );
            break;
          case SYS_SYS_MODE_LTE:
            rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_LTE_RADIO_ACCESS  );
            break;
          case SYS_SYS_MODE_TDS:
            rat_match = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_TDS_RADIO_ACCESS  );
            break;
          default:
              QM_MSG_ERROR_1( "generate_perform_incremental_network_scan no rat match current_sys_mode = %d", current_sys_mode);
              break;
        }
        if( is_plmn_2_valid )
        {
          switch ( current_sys_mode_2 )
          {
            case SYS_SYS_MODE_GSM:
              rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat ==  SYS_RAT_GSM_RADIO_ACCESS );
              break;
            case SYS_SYS_MODE_WCDMA:
              rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_UMTS_RADIO_ACCESS );
              break;
            case SYS_SYS_MODE_LTE:
              rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_LTE_RADIO_ACCESS  );
              break;
            case SYS_SYS_MODE_TDS:
              rat_match_2 = ( available_networks->info[sys_plmn_list_index].rat == SYS_RAT_TDS_RADIO_ACCESS  );
              break;
            default:
              QM_MSG_HIGH_1( "generate_perform_incremental_network_scan no rat match current_sys_mode_2 = %d", current_sys_mode_2);
              break;
          }
        }

        if( sys_plmn_match( current_plmn, available_networks->info[sys_plmn_list_index].plmn) &&  rat_match )
        {
          ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_CURRENT_MASK;
        }
        else if (is_plmn_2_valid && rat_match_2 &&
                 sys_plmn_match( current_plmn_2, available_networks->info[sys_plmn_list_index].plmn))
        {
          ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_CURRENT_MASK;
        }
        else
        {
          ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_AVAILABLE_MASK;
        }
        switch (available_networks->info[sys_plmn_list_index].list_category)
        {
          case SYS_DETAILED_PLMN_LIST_CATEGORY_HPLMN:         
            ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_HOME_MASK;
            ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_PREFERRED_MASK;
            break;
             
          case SYS_DETAILED_PLMN_LIST_CATEGORY_PREFERRED:
          case SYS_DETAILED_PLMN_LIST_CATEGORY_USER_PREFERRED:
          case SYS_DETAILED_PLMN_LIST_CATEGORY_OPERATOR_PREFERRED:
            ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_ROAM_MASK;
            ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_PREFERRED_MASK;
              break;

          case SYS_DETAILED_PLMN_LIST_CATEGORY_OTHER:
            ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_ROAM_MASK;
            ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_NOT_PREFERRED_MASK;
              break;

          default:
              QM_MSG_HIGH_2( "Unhandled list_category (%d) for available networks.info[%d]", 
                  available_networks->info[sys_plmn_list_index].list_category, sys_plmn_list_index);
              break;
        }

        if(available_networks->info[sys_plmn_list_index].plmn_forbidden)
        {
          ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_FORBIDDEN_MASK;
        }
        else
        {
          ind_msg->nas_network_scan_info[network_info_index].network_status |= NASI_PLMN_STATUS_NOT_FORBIDDEN_MASK;
        }

        if( name_cnf->response_header.mmgsdi_status == MMGSDI_SUCCESS )
        {
          if( name_cnf->plmn_list.plmn_info_ptr != NULL )
          {
            for( i = 0; i < name_cnf->plmn_list.num_of_plmn_ids; i++ )
            {
              if ( !memcmp( name_cnf->plmn_list.plmn_info_ptr[i].plmn_id.plmn_id_val, available_networks->info[sys_plmn_list_index].plmn.identity, sizeof(sys_plmn_id_s_type) ) && 
                    qmi_nas_compare_mmgsdi_cm_network_rat( name_cnf->plmn_list.plmn_info_ptr[i].plmn_id.rat, available_networks->info[sys_plmn_list_index].rat ) )
              {
                QM_MSG_HIGH_3("Perform net scan PLMN index %d, len %d, encoding %d", i, name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len, name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding );
                for( j=0; j<name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len; j++ )
                {
                  QM_MSG_HIGH_1("%d", name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_ptr[j] );
                }
                if ( qm_efs_always_return_plmn() )
                {
                  if ( name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
                  {
                    network_name_len = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                                                                name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_len,
                                                                                buff_ptr,
                                                                                NASI_MAX_LEN_NETWORK_NAME/2 );
                    memscpy( (void*)ind_msg->nas_network_scan_info[network_info_index].network_description, NASI_MAX_LEN_NETWORK_NAME, (void*)buff_ptr, network_name_len );
                    if ( network_name_len > 0 )
                    {
                      net_info_available = TRUE;
                    }
                  }
                  else
                  {
                    net_info_available = nasi_convert_mm_info_oper_name(
                                           name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_ptr,
                                           name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_encoding,
                                           (char *)ind_msg->nas_network_scan_info[network_info_index].network_description,
                                           &encoding_type,
                                           NASI_MAX_LEN_NETWORK_NAME,
                                           name_cnf->plmn_list.plmn_info_ptr[i].plmn_long_name.plmn_name.eons_data.data_len);
                    network_name_len  = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, strlen((char *)ind_msg->nas_network_scan_info[network_info_index].network_description));
                  }
                }
                else
                {
                  if ( name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding == MMGSDI_EONS_ENC_UCS2_PACKED )
                  {
                    network_name_len = 2*qm_util_decode_ucs2_80_81_82_encoding( name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                                                                name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len,
                                                                                buff_ptr,
                                                                                NASI_MAX_LEN_NETWORK_NAME/2 );
                    memscpy( (void*)ind_msg->nas_network_scan_info[network_info_index].network_description, NASI_MAX_LEN_NETWORK_NAME, (void*)buff_ptr, network_name_len );
                    if ( network_name_len > 0 )
                    {
                      net_info_available = TRUE;
                    }
                  }
                  else
                  {
                    net_info_available = nasi_convert_mm_info_oper_name( 
                                         name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_ptr,
                                         name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_encoding,
                                         (char *)ind_msg->nas_network_scan_info[network_info_index].network_description,
                                         &encoding_type,
                                         NASI_MAX_LEN_NETWORK_NAME,
                                         name_cnf->plmn_list.plmn_info_ptr[i].plmn_short_name.plmn_name.eons_data.data_len);
                    network_name_len  = (uint8)MIN(NASI_MAX_LEN_NETWORK_NAME, strlen((char *)ind_msg->nas_network_scan_info[network_info_index].network_description));
                  }
                }
              }
            }
          }
        }

        if( !net_info_available)
        {
           QM_MSG_HIGH_1( "Could not get Network name for PLMN index %d. Sending only mcc,mnc", sys_plmn_list_index);         
        }

        switch ( available_networks->info[sys_plmn_list_index].rat )
        {
          case SYS_RAT_GSM_RADIO_ACCESS:  
            ind_msg->nas_network_scan_info[network_info_index].rat = QMI_NAS_RADIO_IF_GSM;   
            break;

          case SYS_RAT_UMTS_RADIO_ACCESS:  
            ind_msg->nas_network_scan_info[network_info_index].rat = QMI_NAS_RADIO_IF_UMTS;
            break;

          case SYS_RAT_LTE_RADIO_ACCESS: 
            ind_msg->nas_network_scan_info[network_info_index].rat = QMI_NAS_RADIO_IF_LTE; 
            break;

          case SYS_RAT_TDS_RADIO_ACCESS: 
            ind_msg->nas_network_scan_info[network_info_index].rat = QMI_NAS_RADIO_IF_TDSCDMA; 
            break;

           default:                                                   
             QM_MSG_HIGH( "RAT is not GSM, UMTS, LTE or TDSCDMA");
             break;
        }
        ind_msg->nas_network_scan_info[network_info_index].mnc_includes_pcs_digit = mnc_includes_pcs_digit;

#ifdef FEATURE_FEMTO_CSG
        if ( qm_efs_csg_supported() )
        {
          // TLV 0x14 (CSG Information)
          QM_MSG_HIGH_1( "Efs csg supported with csg_id=%d", available_networks->info[sys_plmn_list_index].csg_info.csg_id);
          if( available_networks->info[sys_plmn_list_index].csg_info.csg_id != SYS_CSG_ID_INVALID )
          {
            ind_msg->csg_info[csg_network_info_index].mcc = (uint16) mcc;
            ind_msg->csg_info[csg_network_info_index].mnc = (uint16) mnc;
            ind_msg->csg_info[csg_network_info_index].csg_info.id = available_networks->info[sys_plmn_list_index].csg_info.csg_id;
            ind_msg->csg_info[csg_network_info_index].csg_info.name_len = MIN(available_networks->info[sys_plmn_list_index].csg_info.hnb_name.length, NAS_CSG_NAME_MAX_LEN);
            memscpy(ind_msg->csg_info[csg_network_info_index].csg_info.name, 
                    ind_msg->csg_info[csg_network_info_index].csg_info.name_len,
                    available_networks->info[sys_plmn_list_index].csg_info.hnb_name.name, 
                    ind_msg->csg_info[csg_network_info_index].csg_info.name_len);

            switch( available_networks->info[sys_plmn_list_index].list_category )
            {
              case SYS_DETAILED_PLMN_LIST_ALLOWED_CSG:
                ind_msg->csg_info[csg_network_info_index].csg_list_cat = NAS_CSG_LIST_CAT_ALLOWED_V01;
                break;
              case SYS_DETAILED_PLMN_LIST_OPERATOR_CSG:
                ind_msg->csg_info[csg_network_info_index].csg_list_cat = NAS_CSG_LIST_CAT_OPERATOR_V01;
                break;
              default:
                ind_msg->csg_info[csg_network_info_index].csg_list_cat = NAS_CSG_LIST_CAT_UNKNOWN_V01;
                QM_MSG_HIGH_1("Received list category %d", available_networks->info[sys_plmn_list_index].list_category );
                break;
            }
            csg_network_info_index++;
            QM_MSG_HIGH_3("network %d, csg_id %d, name_len %d", sys_plmn_list_index, available_networks->info[sys_plmn_list_index].csg_info.csg_id, available_networks->info[sys_plmn_list_index].csg_info.hnb_name.length );
          }
        }
#endif
        // Increment network_info_index
        network_info_index++;
      }
      else
      {
        QM_MSG_HIGH_1( "PLMN for index %d undefined", sys_plmn_list_index);
      }
    } // End for (all PLMNs in the list populated)

    ind_msg->nas_network_scan_info_len = network_info_index; 
    ind_msg->csg_info_len              = csg_network_info_index;

    if ( errval == QMI_ERR_NONE )
    {
      ind_msg->nas_network_scan_info_valid = TRUE;

#ifdef FEATURE_FEMTO_CSG
      if( qm_efs_csg_supported() && ind_msg->csg_info_len )
      {
        ind_msg->csg_info_valid = TRUE;
      }
#endif
      if(qmi_nasi_global.incremental_net_scan_status == QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_INPROGRESS)
      {
        ind_msg->scan_status = NAS_SCAN_STATUS_PARTIAL_V01;
      }
      else
      {
        if( qmi_nasi_global.incremental_net_scan_status == QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_DONE )
        {
          ind_msg->scan_status = NAS_SCAN_STATUS_COMPLETE_V01;
        }
        else if( qmi_nasi_global.incremental_net_scan_status == QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_AS_ABORT )
        {
          ind_msg->scan_status = NAS_SCAN_STATUS_ABORT_V01;
        }
        else
        {
          QM_MSG_ERROR_1("Not Handled %d ",qmi_nasi_global.incremental_net_scan_status);
        }
        // Clear pending network scan global var
        qmi_nasi_global.net_scan_started = FALSE;
        qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE;
      }
    }
    if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                       QMI_IDL_INDICATION,
                                       (uint16_t) QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_IND_MSG_V01, // message_id = 0x0085 for _IND
                                       (void *)   ind_msg,
                                       (uint32_t) sizeof(nas_perform_incremental_network_scan_ind_msg_v01),
                                       &indication ) )
    {
      qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_PERFORM_INCREMENTAL_NETWORK_SCAN, indication );
    }
				
  } // End if

  if ( available_networks != NULL )
  {
    modem_mem_free( available_networks, MODEM_MEM_CLIENT_QMI_MMODE );
  }
  if ( callback_data != NULL )
  {
    modem_mem_free( callback_data, MODEM_MEM_CLIENT_QMI_MMODE );
  }

  if ( ind_msg )
  {
    // Free heap mem for unpacked response struct
    modem_mem_free( ind_msg, MODEM_MEM_CLIENT_QMI_MMODE );
  }
}

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_PERFORM_INCREMENTAL_NETWORK_SCAN_ERR_IND()

  DESCRIPTION
    Called when error_cb() supplied in cm_ph_cmd_get_networks() is called 
    by CM. Sends error response to control point if error is reported by CM
    
  PARAMETERS
    ph_cmd_err  : Error type

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_perform_incremental_network_scan_err_ind
(
  nas_scan_status_enum_v01 scan_status
)
{
  nas_perform_incremental_network_scan_ind_msg_v01 *ind_msg   = NULL;
  dsm_item_type                                    *indication = NULL;
  qmi_nasi_client_state_type                       *cl_sp = NULL;
  qmi_error_e_type       errval = QMI_ERR_NONE;
	
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  qmi_nasi_global.net_scan_started = FALSE;
  qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE;


  //Get the client cl_sp
  if ( qmi_nasi_global.incremental_net_scan_clid > QMI_SVC_CLID_UNUSED &&
       qmi_nasi_global.incremental_net_scan_clid <= NASI_MAX_CLIDS)
  {
     cl_sp = qmi_nas_state.client[qmi_nasi_global.incremental_net_scan_clid-1];
     if(cl_sp == NULL)
     {
       QM_MSG_HIGH_2( "qmi_nasi_generate_perform_incremental_network_scan_err_ind - cl_sp is NULL(%d),clid:%d!",
              cl_sp,qmi_nasi_global.incremental_net_scan_clid);
       errval = QMI_ERR_INVALID_CLIENT_ID;
     }
  }
  else
  {
    QM_MSG_HIGH_1( "qmi_nasi_generate_perform_incremental_network_scan_err_ind - invalid clid:%d ",
              qmi_nasi_global.incremental_net_scan_clid);
    errval = QMI_ERR_INVALID_CLIENT_ID;
  }

  if ( errval != QMI_ERR_NONE) { return; };


  // Allocating heap mem.
  ind_msg = (nas_perform_incremental_network_scan_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_perform_incremental_network_scan_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  if( ind_msg == NULL)
  {
    qmi_voice_mem_error(); 
    return;
   }

  memset(ind_msg, 0, sizeof(nas_perform_incremental_network_scan_ind_msg_v01));

  /*-------------------------------------------------------------------------
    Return response with appropriate error code
  -------------------------------------------------------------------------*/

  ind_msg->scan_status = scan_status;

  /*-------------------------------------------------------------------------
    Complete pending network_scan transaction
  -------------------------------------------------------------------------*/
  indication = NULL;
  if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                     QMI_IDL_INDICATION,
                                     (uint16_t) QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_IND_MSG_V01, // message_id = 0x0085 for _IND
                                     (void *)   ind_msg,
                                     (uint32_t) sizeof(nas_perform_incremental_network_scan_ind_msg_v01),
                                     &indication ) )
  {
    qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_PERFORM_INCREMENTAL_NETWORK_SCAN, indication );
    QM_MSG_HIGH_1("Sending network scan indication with scan status %d",ind_msg->scan_status);
  }

  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

} /* qmi_nasi_generate_perform_incremental_network_scan_err_ind() */

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_PERFORM_INCREMENTAL_NETWORK_SCAN_RESP()

  DESCRIPTION
    Called when error_cb() supplied in cm_ph_cmd_get_networks() is called 
    by CM. Sends error response to control point if error is reported by CM
    
  PARAMETERS
    ph_cmd_err  : Error type

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_perform_incremental_network_scan_resp ( 
void *               user_data,
cm_ph_cmd_err_e_type ph_cmd_err
)
{
  dsm_item_type      *response = NULL;
  nas_perform_incremental_network_scan_resp_msg_v01 *rsp_msg = NULL;
  qmi_cmd_buf_type   *cmd_buf_p;
  qmi_error_e_type    errval;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  /*-------------------------------------------------------------------------
    Return response with appropriate error code
  -------------------------------------------------------------------------*/
  switch (ph_cmd_err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE;
      break;
			
    case CM_PH_CMD_ERR_NET_TYPE_P:
      errval = QMI_ERR_INVALID_OPERATION;
      break;

    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE;
      break;
			
    default:
      errval = QMI_ERR_INTERNAL;
      break;
  }
  if( errval != QMI_ERR_NONE )
  {
    qmi_nasi_global.net_scan_started = FALSE;
    qmi_nasi_global.incremental_net_scan_status = QMI_NAS_INCREMENTAL_NET_SCAN_STATUS_NONE;
  }

  /*-------------------------------------------------------------------------
    Complete pending network_scan transaction
  -------------------------------------------------------------------------*/
  rsp_msg = (nas_perform_incremental_network_scan_resp_msg_v01 *) 
  modem_mem_alloc( sizeof(nas_perform_incremental_network_scan_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if( rsp_msg == NULL)
  {
    qmi_voice_mem_error();
    return;
  }

  memset( rsp_msg, 0x00, sizeof(nas_perform_incremental_network_scan_resp_msg_v01) );

  rsp_msg->resp.error  = (qmi_error_type_v01)errval;
  rsp_msg->resp.result = (errval == QMI_ERR_NONE) ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

  while( (cmd_buf_p = qm_cbpq_get( QM_CBPQ_QTYPE_NW_SCAN )) != NULL )
  {
    if( !qmi_nas_validate_cmd_buf_p( cmd_buf_p, &qmi_nas_state ) )
    {
      continue;
    }

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_perform_incremental_network_scan_resp_msg_v01),
                                  &response
                                );
		
      qmi_nasi_send_response( cmd_buf_p, response);
     /*Send Network Scan response*/
  }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
}

/*===========================================================================
  FUNCTION qmi_nasi_get_lte_embms_info()

  DESCRIPTION
    Retrieve the LTE EMBMS statistics information.
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_lte_embms_info
( 
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  nas_get_lte_embms_info_resp_msg_v01 *resp_msg;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4( "null ptr in qmi_nasi_get_lte_embms_info %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in );

    errval = QMI_ERR_INTERNAL_V01;
  }


  resp_msg = (nas_get_lte_embms_info_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_lte_embms_info_resp_msg_v01 ) );

  if ( resp_msg != NULL )
  {
    memset( resp_msg, 0x00, sizeof( nas_get_lte_embms_info_resp_msg_v01 ) );

#ifdef FEATURE_LTE
  if ( errval == QMI_ERR_NONE_V01 )
  {
    cmapi_lte_eMBPS_info_s embms_info;
    uint8 i=0,j=0;
    memset( &embms_info, 0x00, sizeof( embms_info ) );
    cmapi_lte_get_eMBMS_info( &embms_info );

    QM_MSG_HIGH_5( "coverage status=%d,pmch_data_mcs=%d,num_active_embms_comb=%d, num_mbsfn_areas=%d,num_area=%d", 
		embms_info.eMBMS_coverage_status, embms_info.datamcs.num_pmch_datamcs_info, embms_info.mac_active.num_active_embms_comb,embms_info.pmch.mbsfn_snr_info.num_mbsfn_areas, embms_info.pmch.pmch_bler_info.num_area );

    resp_msg->coverage_status_valid = TRUE;
    resp_msg->coverage_status = embms_info.eMBMS_coverage_status;

    resp_msg->pmch_data_mcs_len = MIN(embms_info.datamcs.num_pmch_datamcs_info,NAS_LTE_ACTIVE_PMCH_MAX_V01);
    for(i=0;i < resp_msg->pmch_data_mcs_len;i++)
    {
      resp_msg->pmch_data_mcs[i].mbsfn_area_id = embms_info.datamcs.pmch_datamcs[i].mbsfn_area_id;
      resp_msg->pmch_data_mcs[i].pmch_id = embms_info.datamcs.pmch_datamcs[i].pmch_id;
      resp_msg->pmch_data_mcs[i].data_mcs = embms_info.datamcs.pmch_datamcs[i].datamcs;
    }
    if(resp_msg->pmch_data_mcs_len > 0)
    {
      resp_msg->pmch_data_mcs_valid = TRUE;
    }

    resp_msg->is_active_tmgi_valid_valid = TRUE;
    resp_msg->is_active_tmgi_valid = embms_info.pmch.is_valid;

    resp_msg->mbsfn_area_signal_data_len = MIN(embms_info.pmch.mbsfn_snr_info.num_mbsfn_areas,NAS_LTE_EMBMS_MBSFN_AREAS_MAX_V01);
    for(i=0;i<resp_msg->mbsfn_area_signal_data_len;i++)
    {
      resp_msg->mbsfn_area_signal_data[i].area_id = embms_info.pmch.mbsfn_snr_info.mbsfn_area_signal_strength[i].area_id;
      resp_msg->mbsfn_area_signal_data[i].snr = embms_info.pmch.mbsfn_snr_info.mbsfn_area_signal_strength[i].snr;
      resp_msg->mbsfn_area_signal_data[i].excess_snr = embms_info.pmch.mbsfn_snr_info.mbsfn_area_signal_strength[i].excess_snr;
      resp_msg->mbsfn_area_signal_data[i].signal_level = embms_info.pmch.mbsfn_snr_info.mbsfn_area_signal_strength[i].signal_level;
    }
    if( resp_msg->mbsfn_area_signal_data_len > 0 )
    {
      resp_msg->mbsfn_area_signal_data_valid = TRUE;
    }

    resp_msg->pmch_bler_info_len = MIN(embms_info.pmch.pmch_bler_info.num_area,NAS_LTE_EMBMS_MBSFN_AREAS_MAX_V01);
    for(i=0;i<resp_msg->pmch_bler_info_len;i++)
    {
      resp_msg->pmch_bler_info[i].area_id = embms_info.pmch.pmch_bler_info.pmch_bler_per_area[i].area_id;
      resp_msg->pmch_bler_info[i].pmch_bler_len = MIN(embms_info.pmch.pmch_bler_info.pmch_bler_per_area[i].num_pmch,NAS_LTE_PMCH_PER_MBSFN_AREA_MAX_V01);
      for(j=0;j<resp_msg->pmch_bler_info[i].pmch_bler_len;j++)
      {
        resp_msg->pmch_bler_info[i].pmch_bler[j].pmch_id = embms_info.pmch.pmch_bler_info.pmch_bler_per_area[i].pmch_bler[j].pmch_id;
        resp_msg->pmch_bler_info[i].pmch_bler[j].num_crc_pass = embms_info.pmch.pmch_bler_info.pmch_bler_per_area[i].pmch_bler[j].num_crc_pass;
        resp_msg->pmch_bler_info[i].pmch_bler[j].num_crc_fail = embms_info.pmch.pmch_bler_info.pmch_bler_per_area[i].pmch_bler[j].num_crc_fail;
      }
    }
    if( resp_msg->pmch_bler_info_len > 0 )
    {
      resp_msg->pmch_bler_info_valid = TRUE;
    }

    resp_msg->mtch_info_len = MIN(embms_info.mac_active.num_active_embms_comb,NAS_LTE_EMBMS_ACTIVE_SESSIONS_MAX_V01);
    for(i=0;i<resp_msg->mtch_info_len;i++)
    {
      resp_msg->mtch_info[i].area_id = embms_info.mac_active.mtch_info_arr[i].area_id;
      resp_msg->mtch_info[i].pmch_id = embms_info.mac_active.mtch_info_arr[i].pmch_id;
      resp_msg->mtch_info[i].lc_id= embms_info.mac_active.mtch_info_arr[i].lc_id;
      resp_msg->mtch_info[i].num_mtch_tb_bytes = embms_info.mac_active.mtch_info_arr[i].num_mtch_tb_bytes;
    }
    if( resp_msg->mtch_info_len > 0 )
    {
      resp_msg->mtch_info_valid = TRUE;
    }

  }
#else
  if ( errval == QMI_ERR_NONE_V01 )
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  }
#endif

    resp_msg->resp.error  = errval;
    resp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  QMI_NAS_GET_LTE_EMBMS_INFO_RESP_MSG_V01,
                                  (void *) resp_msg,
                                  (uint32_t) sizeof( nas_get_lte_embms_info_resp_msg_v01 ),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( resp_msg != NULL ) 
  { 
    QMI_NAS_MEM_FREE( (void *) resp_msg ); 
    resp_msg = NULL;
  }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_SSAC_CHANGE_INFO_IND()

  DESCRIPTION
    Generate and change in SSAC info indication (which includes both idle and connected mode)
    
  PARAMETERS
    msg_p  Pointer to MSGR data for ssac params info

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_ssac_change_info_ind
(
  lte_rrc_ssac_params_s * ssac_params
)
{
  int                              clid;
  qmi_nasi_client_state_type      *cl_sp;
  nas_ssac_change_info_ind_msg_v01 *ind_msg;
  dsm_item_type                   *ind = NULL;

  ind_msg = (nas_ssac_change_info_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_ssac_change_info_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( ind_msg != NULL )
  {
    memset( ind_msg, 0x00, sizeof(nas_ssac_change_info_ind_msg_v01) );

    QM_MSG_HIGH_5( "SSAC CHANGE INFO IND Voice:is valid=%d barring_factor_voice %d, barring_time %d, sib2_barring_factor_voice %d, sib2_barring_time %d",
		ssac_params->ssac_param_voice_valid, ssac_params->barring_factor_mmtel_voice, ssac_params->barring_time_mmtel_voice, ssac_params->sib2_barring_factor_mmtel_voice, ssac_params->sib2_barring_time_mmtel_voice );
    QM_MSG_HIGH_5( "SSAC CHANGE INFO IND Video:is valid=%d  barring_factor_video %d, barring_time %d, sib2_barring_factor_video %d, sib2_barring_time %d",
		ssac_params->ssac_param_video_valid, ssac_params->barring_factor_mmtel_video, ssac_params->barring_time_mmtel_video,ssac_params->sib2_barring_factor_mmtel_video, ssac_params->sib2_barring_time_mmtel_video);

    if ( !qmi_nasi_ssac_info.is_valid || memcmp(&qmi_nasi_ssac_info.ssac_cache, ssac_params, sizeof(lte_rrc_ssac_params_s)) )
    {
    ind_msg->ssac_voice_info_valid = TRUE;
    ind_msg->ssac_video_info_valid = TRUE;
    ind_msg->ssac_voice_info.barring_factor_voice = ssac_params->barring_factor_mmtel_voice;
    ind_msg->ssac_voice_info.barring_time_voice = ssac_params->barring_time_mmtel_voice;
    ind_msg->ssac_video_info.barring_factor_video = ssac_params->barring_factor_mmtel_video;
    ind_msg->ssac_video_info.barring_time_video = ssac_params->barring_time_mmtel_video;

    ind_msg->sib2_ssac_voice_info_valid = TRUE;
    ind_msg->sib2_ssac_video_info_valid = TRUE;
    ind_msg->sib2_ssac_voice_info.sib2_barring_factor_voice = ssac_params->sib2_barring_factor_mmtel_voice;
    ind_msg->sib2_ssac_voice_info.sib2_barring_time_voice = ssac_params->sib2_barring_time_mmtel_voice;
    ind_msg->sib2_ssac_video_info.sib2_barring_factor_video = ssac_params->sib2_barring_factor_mmtel_video;
    ind_msg->sib2_ssac_video_info.sib2_barring_time_video = ssac_params->sib2_barring_time_mmtel_video;

      //Sending SSAC_CHANGE_INFO_IND
	  
      for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
      {
        cl_sp = qmi_nas_state.client[clid];

        if (  cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
              (cl_sp->report_status.report_ssac_change_info || cl_sp->report_status.report_ssac_info) )
        {
          ind = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj, 
                                                    QMI_IDL_INDICATION, 
                                                    (uint16_t)QMI_NAS_SSAC_CHANGE_INFO_IND_V01, 
                                                    (void *) ind_msg,
                                                    (uint32_t)sizeof(nas_ssac_change_info_ind_msg_v01), 
                                                    &ind
                                                  ) )
          {
            qm_nas_clnt_send_ind( cl_sp->common.clid, QMI_NAS_SSAC_CHANGE_INFO_IND_V01, ind );
          }
        }
      }
    }
    else
    {
      QM_MSG_HIGH( "SSAC info did not change - not sending indication" );
    }
    modem_mem_free((void *)ind_msg,  MODEM_MEM_CLIENT_QMI_MMODE);
  }
  else
  {
    qmi_voice_mem_error();
  }
}

/*===========================================================================
  FUNCTION qmi_nasi_gen_emm_t3402_changed_ind()

  DESCRIPTION
    Generate the T3402 timer changed indicatio
    
  PARAMETERS
    msg_p  Pointer to MSGR data for T3402 info

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_gen_emm_t3402_changed_ind
(
  emm_t3402_changed_ind_s_type * timer_val
)
{
  int                               clid;
  qmi_nasi_client_state_type        *cl_sp;
  nas_emm_t3402_changed_ind_msg_v01 ind_msg;
  dsm_item_type                     *ind = NULL;
  enum qmi_nas_subs_e  as_id;

  memset( &ind_msg, 0x00, sizeof(nas_emm_t3402_changed_ind_msg_v01) );
  ind_msg.t3402_timer_val_valid = TRUE;
  ind_msg.t3402_timer_val = timer_val-> t3402_value;

  as_id = (enum qmi_nas_subs_e)INST_ID_TO_SYS_AS_ID(timer_val->msg_hdr.inst_id);
  if( (as_id >= QMI_NAS_SUBS_MAX) || (as_id <= QMI_NAS_SUBS_NONE) )
  {
    QM_MSG_ERROR("qmi_nasi_gen_emm_t3402_changed_ind(): Received invalid as_id from NAS.");
    as_id = QMI_NAS_SUBS_PRIMARY;
  }

  qmi_nasi_global.t3402_value[as_id] = timer_val-> t3402_value;

  for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
  {
    cl_sp = qmi_nas_state.client[clid];

    if (  cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
          cl_sp->report_status.report_t3402_timer_change )
    {
      ind = NULL;
      if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj, 
                                                QMI_IDL_INDICATION, 
                                                (uint16_t)QMI_NAS_EMM_T3402_CHANGED_IND_V01, 
                                                (void *) &ind_msg,
                                                (uint32_t)sizeof(nas_emm_t3402_changed_ind_msg_v01), 
                                                &ind
                                              ) )
      {
        qm_nas_clnt_send_ind( cl_sp->common.clid, QMI_NAS_EMM_T3402_CHANGED_IND_V01, ind );
      }
    }
  }
}

/*===========================================================================
  FUNCTION qmi_nasi_get_ssac_info()

  DESCRIPTION
    Retrieve the LTE SSAC cached information.
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_ssac_info
( 
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *             response = NULL;
  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  nas_get_ssac_info_resp_msg_v01 *resp_msg;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4( "null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp ,  sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  resp_msg = (nas_get_ssac_info_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_ssac_info_resp_msg_v01 ) );

  if ( resp_msg != NULL )
  {
    memset( resp_msg, 0x00, sizeof( nas_get_ssac_info_resp_msg_v01 ) );

    if( !qmi_nasi_ssac_info.is_valid )
    {
      QM_MSG_ERROR( "SSAC information not available from LTE-RRC" );
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    }
    else
    {
      //Sending both the optional TLV's always when success.
      resp_msg->ssac_voice_info_valid = TRUE;
      resp_msg->ssac_video_info_valid = TRUE;
      resp_msg->ssac_voice_info.barring_factor_voice = qmi_nasi_ssac_info.ssac_cache.barring_factor_mmtel_voice;
      resp_msg->ssac_video_info.barring_factor_video = qmi_nasi_ssac_info.ssac_cache.barring_factor_mmtel_video;
      resp_msg->ssac_voice_info.barring_time_voice = qmi_nasi_ssac_info.ssac_cache.barring_time_mmtel_voice;
      resp_msg->ssac_video_info.barring_time_video = qmi_nasi_ssac_info.ssac_cache.barring_time_mmtel_video;
	  
      resp_msg->sib2_ssac_voice_info_valid = TRUE;
      resp_msg->sib2_ssac_video_info_valid = TRUE;
      resp_msg->sib2_ssac_voice_info.sib2_barring_factor_voice = qmi_nasi_ssac_info.ssac_cache.sib2_barring_factor_mmtel_voice;
      resp_msg->sib2_ssac_video_info.sib2_barring_factor_video = qmi_nasi_ssac_info.ssac_cache.sib2_barring_factor_mmtel_video;
      resp_msg->sib2_ssac_voice_info.sib2_barring_time_voice = qmi_nasi_ssac_info.ssac_cache.sib2_barring_time_mmtel_voice;
      resp_msg->sib2_ssac_video_info.sib2_barring_time_video = qmi_nasi_ssac_info.ssac_cache.sib2_barring_time_mmtel_video;
    }

    resp_msg->resp.error  = errval;
    resp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  QMI_NAS_GET_SSAC_INFO_RESP_MSG_V01,
                                  (void *) resp_msg,
                                  (uint32_t) sizeof( nas_get_ssac_info_resp_msg_v01 ),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( resp_msg != NULL ) 
  { 
    QMI_NAS_MEM_FREE( (void *) resp_msg ); 
    resp_msg = NULL;
  }

  return response;
}
/*===========================================================================
  FUNCTION qmi_nasi_set_periodic_search_allowed()

  DESCRIPTION
    Enable/Disable periodic search.
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
dsm_item_type* qmi_nasi_set_periodic_search_allowed
(
     void *            sp,
     void *            cmd_buf_p,
     void *            cl_sp, 
     dsm_item_type **  sdu_in
)
{
   dsm_item_type     *response = NULL;
   qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

   nas_set_periodic_search_allowed_req_msg_v01  * req_msg;
   nas_set_periodic_search_allowed_resp_msg_v01 * rsp_msg;
   sys_modem_as_id_e_type      asubs_id = SYS_MODEM_AS_ID_1;

   ASSERT(sp);
   ASSERT(cmd_buf_p);
   ASSERT(cl_sp);
   ASSERT(sdu_in);
   
   if ( ! TARGET_SUPPORTS_GSM && ! TARGET_SUPPORTS_WCDMA && ! TARGET_SUPPORTS_LTE && ! TARGET_SUPPORTS_TDS )
   {
     QM_MSG_ERROR("OP UNSUPPORTED");
     errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
   }

#ifdef FEATURE_DUAL_SIM
   if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
   {
     asubs_id = SYS_MODEM_AS_ID_2;
   }
#ifdef FEATURE_TRIPLE_SIM
   else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
   {
      asubs_id = SYS_MODEM_AS_ID_3;
   }
#endif
#endif
   req_msg = (nas_set_periodic_search_allowed_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_periodic_search_allowed_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
   rsp_msg = (nas_set_periodic_search_allowed_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_periodic_search_allowed_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

   if ( req_msg == NULL )
   {
      qmi_voice_mem_error();
      errval = QMI_ERR_NO_MEMORY_V01;
   }

   if ( errval == QMI_ERR_NONE_V01 )
   {
      memset ( req_msg, 0x00, sizeof(nas_set_periodic_search_allowed_req_msg_v01) );

      // extract information from REQ message
      errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                    (uint16_t)QMI_NAS_SET_PERIODIC_SEARCH_ALLOWED_REQ_MSG_V01,
                                    sdu_in,
                                    (void *) req_msg,
                                    (uint32_t) sizeof(nas_set_periodic_search_allowed_req_msg_v01)
                                  );
   }

   // check for error in REQ message
   if (errval == QMI_ERR_NONE_V01)
   {
      errval = qmi_nas_0092_req_check( req_msg );
   }

   if (errval == QMI_ERR_NONE_V01)
   {
      QM_MSG_HIGH("Calling policyman_set_periodic_plmn_search_allowed()");
      policyman_set_periodic_plmn_search_allowed(asubs_id, req_msg->allowed);
   }

   if ( rsp_msg == NULL )
   {
      qmi_voice_mem_error();
   }
   else if( cmd_buf_p != NULL )
   {
      memset( rsp_msg, 0x00, sizeof(nas_set_periodic_search_allowed_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                           QMI_IDL_RESPONSE,
                           (uint16_t) QMI_NAS_SET_PERIODIC_SEARCH_ALLOWED_RESP_MSG_V01,
                           (void *) rsp_msg,
                           (uint32_t) sizeof(nas_set_periodic_search_allowed_resp_msg_v01),
                           &response
                         );
   }
   else
   {
      QM_MSG_ERROR("cmd_buf_p is NULL");
   }

   if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
   if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

   return response;
}

/*===========================================================================
  FUNCTION qmi_nas_map_ac_barring_factor_lte_to_qmi()

  DESCRIPTION
    
  PARAMETERS

  RETURN VALUE
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
uint8_t qmi_nas_map_ac_barring_factor_lte_to_qmi(lte_rrc_ac_barring_factor_e ac_barring_factor_lte)
{
  uint8_t ac_barring_factor_qmi = 0xFF;

  switch(ac_barring_factor_lte)
  {
  case LTE_RRC_AC_BARRING_FACTOR_P00:
    ac_barring_factor_qmi = 0; // 0.00 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P05:
    ac_barring_factor_qmi = 5; // 0.05 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P10:
    ac_barring_factor_qmi = 10; // 0.10 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P15:
    ac_barring_factor_qmi = 15; // 0.15 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P20:
    ac_barring_factor_qmi = 20; // 0.20 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P25:
    ac_barring_factor_qmi = 25; // 0.25 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P30:
    ac_barring_factor_qmi = 30; // 0.30 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P40:
    ac_barring_factor_qmi = 40; // 0.40 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P50:
    ac_barring_factor_qmi = 50; // 0.50 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P60:
    ac_barring_factor_qmi = 60; // 0.60 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P70:
    ac_barring_factor_qmi = 70; // 0.70 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P75:
    ac_barring_factor_qmi = 75; // 0.75 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P80:
    ac_barring_factor_qmi = 80; // 0.80 * 100
    break;
  case LTE_RRC_AC_BARRING_FACTOR_P85:
      ac_barring_factor_qmi = 85; // 0.85 * 100
      break;
  case LTE_RRC_AC_BARRING_FACTOR_P90:
      ac_barring_factor_qmi = 90; // 0.90 * 100
      break;
  case LTE_RRC_AC_BARRING_FACTOR_P95:
      ac_barring_factor_qmi = 95; // 0.95 * 100
      break;
  case LTE_RRC_AC_BARRING_FACTOR_INVALID:
  default:
    ac_barring_factor_qmi = 0xFF;
    break;
  }
  return ac_barring_factor_qmi;
}

/*===========================================================================
  FUNCTION qmi_nas_populate_acb_info_ind()

  DESCRIPTION
    <QMI NAS internal use only>
    Helper function to generate qmi_nas_acb_info_ind type message from a given ac barring info.
    To be used in QMI_NAS_ACB_INFO_IND.

  PARAMETERS
    lte_rrc_ac_barring_info_s  LTE ACB info type
    nas_acb_info_ind_msg_v01   QMI NAS ACB Info Ind type

  RETURN VALUE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nas_populate_acb_info_ind
(
    lte_rrc_ac_barring_info_s *acb_info_ind,
    nas_acb_info_ind_msg_v01  *ind_msg
)
{
    QM_MSG_HIGH_3( "ACB INFO :: emergency_present:%d, MO_data_present:%d, MO_signalling_present:%d", 
                              acb_info_ind->ac_barring_for_emergency_present,
                              acb_info_ind->ac_barring_MO_data_present,
                              acb_info_ind->ac_barring_MO_signalling_present );

    ind_msg->ac_barring_for_emergency_valid   =  acb_info_ind->ac_barring_for_emergency_present;
    if( acb_info_ind->ac_barring_for_emergency_present ) 
    {
      QM_MSG_HIGH_1( "ACB INFO :: ac_barring_for_emergency:%d",acb_info_ind->ac_barring_for_emergency);
      ind_msg->ac_barring_for_emergency            =  acb_info_ind->ac_barring_for_emergency;
    }

    ind_msg->ac_barring_mo_data_valid             =  acb_info_ind->ac_barring_MO_data_present;
    if(acb_info_ind->ac_barring_MO_data_present)
    {
    
      QM_MSG_HIGH_3( "ACB INFO :: ac_barring_mo_data(%d,%d,%d) ", 
                                acb_info_ind->ac_barring_MO_data.ac_barring_factor,
                                acb_info_ind->ac_barring_MO_data.barring_time, 
                                acb_info_ind->ac_barring_MO_data.ac_barring_for_special_AC );
      // ac_barring_factorin multiple of 100s
      ind_msg->ac_barring_mo_data.ac_barring_factor = 
           qmi_nas_map_ac_barring_factor_lte_to_qmi( acb_info_ind->ac_barring_MO_data.ac_barring_factor);

      ind_msg->ac_barring_mo_data.ac_barring_time   = (uint16_t)acb_info_ind->ac_barring_MO_data.barring_time;
      if(acb_info_ind->ac_barring_MO_data.ac_barring_for_special_AC_present)
      {
         ind_msg->ac_barring_mo_data.ac_barring_for_special_ac =(uint8_t)acb_info_ind->ac_barring_MO_data.ac_barring_for_special_AC;
      }
      else
      {
         ind_msg->ac_barring_mo_data.ac_barring_for_special_ac = 0xFF; //Indicates ac_barring_for_special_ac is not available
      }
    }

    ind_msg->ac_barring_mo_signalling_valid      =  acb_info_ind->ac_barring_MO_signalling_present;
    if(acb_info_ind->ac_barring_MO_signalling_present)
    {
      QM_MSG_HIGH_3( "ACB INFO :: ac_barring_mo_signalling(%d,%d,%d) ", 
                                acb_info_ind->ac_barring_MO_signalling.ac_barring_factor, 
                                acb_info_ind->ac_barring_MO_signalling.barring_time, 
                                acb_info_ind->ac_barring_MO_signalling.ac_barring_for_special_AC );
      // ac_barring_factorin multiple of 100s
      ind_msg->ac_barring_mo_signalling.ac_barring_factor = 
          qmi_nas_map_ac_barring_factor_lte_to_qmi( acb_info_ind->ac_barring_MO_signalling.ac_barring_factor);
      
      ind_msg->ac_barring_mo_signalling.ac_barring_time   = (uint16_t)acb_info_ind->ac_barring_MO_signalling.barring_time;
      if(acb_info_ind->ac_barring_MO_signalling.ac_barring_for_special_AC_present)
      {
         ind_msg->ac_barring_mo_signalling.ac_barring_for_special_ac =(uint8_t)acb_info_ind->ac_barring_MO_signalling.ac_barring_for_special_AC;
      }
      else
      {
         ind_msg->ac_barring_mo_signalling.ac_barring_for_special_ac = 0xFF; //Indicates ac_barring_for_special_ac is not available
      }
    }
}

/*===========================================================================
  FUNCTION QMI_NASI_ACB_INFO_IND()

  DESCRIPTION
    Generate and send ACB(Access Class Barring) info indication
    
  PARAMETERS
    msg_p  Pointer to MSGR data for ssac params info

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_acb_info_ind
(
  lte_rrc_ac_barring_info_s * acb_info_ind 
)
{
  int                              clid;
  qmi_nasi_client_state_type      *cl_sp;
  nas_acb_info_ind_msg_v01        *new_ind_msg;
  nas_acb_info_ind_msg_v01        *old_ind_msg;
  dsm_item_type                   *ind = NULL;

  new_ind_msg = (nas_acb_info_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_acb_info_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  old_ind_msg = (nas_acb_info_ind_msg_v01 *) modem_mem_alloc( sizeof(nas_acb_info_ind_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );


  if ( new_ind_msg != NULL  && old_ind_msg != NULL )
  {
    memset( new_ind_msg, 0x00, sizeof(nas_acb_info_ind_msg_v01) );
    memset( old_ind_msg, 0x00, sizeof(nas_acb_info_ind_msg_v01) );

    QM_MSG_HIGH( "ACB INFO :: Populating ACB Indication from Previous Cache Info");
    qmi_nas_populate_acb_info_ind(   &qmi_nasi_global.lte_rrc_ac_barring_info_cache, old_ind_msg);
    QM_MSG_HIGH( "ACB INFO :: Populating ACB Indication from Current Info");
    qmi_nas_populate_acb_info_ind( acb_info_ind, new_ind_msg);
    
    if(memcmp(old_ind_msg, new_ind_msg, sizeof(nas_acb_info_ind_msg_v01)))
    {
      for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
      {
        cl_sp = qmi_nas_state.client[clid];
  
        if (  cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
              cl_sp->report_status.reg_acb_info_change )
        {
        
          QM_MSG_HIGH_1( "ACB INFO :: Sending qmi_nasi_acb_info_ind() for clid:%d", clid);
          ind = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj, 
                                                    QMI_IDL_INDICATION, 
                                                    (uint16_t)QMI_NAS_ACB_INFO_IND_V01, 
                                                    (void *) new_ind_msg,
                                                    (uint32_t)sizeof(nas_acb_info_ind_msg_v01), 
                                                    &ind
                                                  ) )
          {
            qm_nas_clnt_send_ind( cl_sp->common.clid, QMI_NAS_ACB_INFO_IND_V01, ind );
          }
        }
      }
    }
	/*Else, No change in the ACB Info*/
    modem_mem_free((void *)new_ind_msg,  MODEM_MEM_CLIENT_QMI_MMODE);
    modem_mem_free((void *)old_ind_msg,  MODEM_MEM_CLIENT_QMI_MMODE);
  }
  else
  {
    qmi_voice_mem_error();
  }
}
/*===========================================================================
  FUNCTION qmi_nasi_get_acb_info()

  DESCRIPTION
    Retrieve the LTE ACB(Access Class Barring) cached information.
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_acb_info  
  (
    void *            sp,
    void *            cmd_buf_p,
    void *            cl_sp, 
    dsm_item_type **  sdu_in
  )
  {
    dsm_item_type     *response = NULL;
    qmi_error_type_v01 errval = QMI_ERR_NONE_V01;
    nas_get_acb_info_resp_msg_v01 * rsp_msg;
  
    ASSERT(sp);
    ASSERT(cmd_buf_p);
    ASSERT(cl_sp);
    ASSERT(sdu_in);

    rsp_msg = (nas_get_acb_info_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_acb_info_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    if ( rsp_msg == NULL )
    {
      qmi_voice_mem_error();
    }
    else
    {
      lte_rrc_ac_barring_info_s *acb_info_ind = &qmi_nasi_global.lte_rrc_ac_barring_info_cache; 

      memset( rsp_msg, 0x00, sizeof(nas_get_acb_info_resp_msg_v01) );
      
      QM_MSG_HIGH_3( "ACB INFO :: emergency_present:%d, MO_data_present:%d, MO_signalling_present:%d", 
                                acb_info_ind->ac_barring_for_emergency_present,
                                acb_info_ind->ac_barring_MO_data_present,
                                acb_info_ind->ac_barring_MO_signalling_present );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
      
      rsp_msg->ac_barring_for_emergency_valid   =  acb_info_ind->ac_barring_for_emergency_present;
      if( acb_info_ind->ac_barring_for_emergency_present ) 
      {
        rsp_msg->ac_barring_for_emergency            =  acb_info_ind->ac_barring_for_emergency;
      }
      
      rsp_msg->ac_barring_mo_data_valid             =  acb_info_ind->ac_barring_MO_data_present;
      if(acb_info_ind->ac_barring_MO_data_present)
      {
      
        QM_MSG_HIGH_3( "ACB INFO :: ac_barring_mo_data(%d,%d,%d) ", 
                                  acb_info_ind->ac_barring_MO_data.ac_barring_factor,
                                  acb_info_ind->ac_barring_MO_data.barring_time, 
                                  acb_info_ind->ac_barring_MO_data.ac_barring_for_special_AC );

        rsp_msg->ac_barring_mo_data.ac_barring_factor = 
          qmi_nas_map_ac_barring_factor_lte_to_qmi(acb_info_ind->ac_barring_MO_data.ac_barring_factor);
        
        rsp_msg->ac_barring_mo_data.ac_barring_time   = (uint16_t)acb_info_ind->ac_barring_MO_data.barring_time;
        if(acb_info_ind->ac_barring_MO_data.ac_barring_for_special_AC_present)
        {
           rsp_msg->ac_barring_mo_data.ac_barring_for_special_ac =(uint8_t)acb_info_ind->ac_barring_MO_data.ac_barring_for_special_AC;
        }
        else
        {
           rsp_msg->ac_barring_mo_data.ac_barring_for_special_ac = 0xFF; //Indicates ac_barring_for_special_ac is not available
        }
      }
      
      rsp_msg->ac_barring_mo_signalling_valid      =  acb_info_ind->ac_barring_MO_signalling_present;
      if(acb_info_ind->ac_barring_MO_signalling_present)
      {
        QM_MSG_HIGH_3( "ACB INFO :: ac_barring_mo_signalling(%d,%d,%d) ", 
                                  acb_info_ind->ac_barring_MO_signalling.ac_barring_factor, 
                                  acb_info_ind->ac_barring_MO_signalling.barring_time, 
                                  acb_info_ind->ac_barring_MO_signalling.ac_barring_for_special_AC );

        rsp_msg->ac_barring_mo_signalling.ac_barring_factor = 
            qmi_nas_map_ac_barring_factor_lte_to_qmi(acb_info_ind->ac_barring_MO_signalling.ac_barring_factor);
        
        rsp_msg->ac_barring_mo_signalling.ac_barring_time   = (uint16_t)acb_info_ind->ac_barring_MO_signalling.barring_time;
        if(acb_info_ind->ac_barring_MO_signalling.ac_barring_for_special_AC_present)
        {
           rsp_msg->ac_barring_mo_signalling.ac_barring_for_special_ac =(uint8_t)acb_info_ind->ac_barring_MO_signalling.ac_barring_for_special_AC;
        }
        else
        {
           rsp_msg->ac_barring_mo_signalling.ac_barring_for_special_ac = 0xFF; //Indicates ac_barring_for_special_ac is not available
        }
      }


      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t) QMI_NAS_GET_ACB_INFO_RESP_MSG_V01,
                                    (void *) rsp_msg,
                                    (uint32_t) sizeof(nas_get_acb_info_resp_msg_v01),
                                    &response
                                  );

      modem_mem_free( rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    }

  
    return response;
  } /* qmi_nasi_get_acb_info */

/*===========================================================================
  FUNCTION QMI_NASI_SET_DATA_SUBS_PRIORITY()

  DESCRIPTION
    This message configures data priority
    for the client's bound subscription.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_data_subs_priority(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_type_v01                     errval            = QMI_ERR_NONE_V01;
  nas_set_data_subs_priority_resp_msg_v01 *resp_msg;

  nas_set_data_subs_priority_req_msg_v01  *req_msg;

  qmi_nasi_client_state_type *    client;
  client = (qmi_nasi_client_state_type*)cl_sp;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_set_data_subs_priority_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_data_subs_priority_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  req_msg  = (nas_set_data_subs_priority_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_data_subs_priority_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0, sizeof(nas_set_data_subs_priority_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_data_subs_priority_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
      QM_MSG_HIGH_3("set_data_subs_priority() - client %d subs %d priority %d", client->common.clid, client->report_status.bound_subs, qmi_nasi_global.data_subs_priority[(int)(client->report_status.bound_subs)]);

      if(cm_ph_cmd_set_data_priority_per_subs(qmi_nas_cmph_cmd_cb,
                                              cmd_buf_p,
                                              qmi_nasi_global.cm_clnt_id,
                                              (sys_data_priority_e_type)(req_msg->data_subs_priority),
                                              (sys_modem_as_id_e_type)client->report_status.bound_subs))
      {
        QM_MSG_HIGH("set_data_subs_priority() - cm_ph_cmd_set_data_priority_per_subs sent, awaiting response");
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
        /*cm_ph_cmd_set_data_priority_per_subs() failed*/
      }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    if ( resp_msg != NULL )
    {
      memset(resp_msg, 0, sizeof(nas_set_data_subs_priority_resp_msg_v01) );
      resp_msg->resp.error  = errval;
      resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
    
      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                    (void *)resp_msg,
                                    (uint32_t)sizeof(nas_set_data_subs_priority_resp_msg_v01),
                                    &response
                                  );
    }
    else
    {
      qmi_voice_mem_error();
    }
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NAS_SET_DATA_SUBS_PRIORITY_RESP()

  DESCRIPTION
    Send response for SET_DATA_SUBS_PRIORITY_REQ

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_set_data_subs_priority_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *                         response = NULL;
  qmi_error_type_v01                      errval   = QMI_ERR_NONE_V01;
  boolean                                 retval   = TRUE;
  nas_set_data_subs_priority_resp_msg_v01 *resp_msg;

  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf || !p_cmd_buf->x_p )
  {
    QM_MSG_ERROR("Null cmd_buf ptr");
    return;
  }

  errval = ( err == CM_PH_CMD_ERR_NOERR ) ? QMI_ERR_NONE_V01 : QMI_ERR_INTERNAL_V01;

  resp_msg = (nas_set_data_subs_priority_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_data_subs_priority_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_data_subs_priority_resp_msg_v01) );
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)((qmi_cmd_buf_type*)p_cmd_buf)->cmd_type,
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_set_data_subs_priority_resp_msg_v01),
                                           &response
                                         );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &p_cmd_buf );
  }
  else 
  {
    qmi_nasi_send_response( p_cmd_buf, response );
  }
  
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nas_set_data_subs_priority_resp() */

/*===========================================================================
  FUNCTION qmi_nasi_get_data_subs_priority()

  DESCRIPTION
    Retrieve the cached data priority for
    the client's bound subscruption.
    
  PARAMETERS
    sp            : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp        : client state pointer
    sdu_in       : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_data_subs_priority
( 
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type *                 response = NULL;
  qmi_error_type_v01              errval = QMI_ERR_NONE_V01;
  nas_get_data_subs_priority_resp_msg_v01 *resp_msg;
  qmi_nasi_client_state_type *    client;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4( "null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in );
    errval = QMI_ERR_INTERNAL_V01;
  }

  client = (qmi_nasi_client_state_type*)cl_sp;

  resp_msg = (nas_get_data_subs_priority_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_get_data_subs_priority_resp_msg_v01 ) );

  if ( (resp_msg != NULL) && (client != NULL) )
  {
    QM_MSG_HIGH_2("In qmi_nasi_get_data_subs_priority(): clid=%d, bound_subs=%d", client->common.clid, client->report_status.bound_subs);
    memset( resp_msg, 0x00, sizeof( nas_get_data_subs_priority_resp_msg_v01 ) );

    if (errval == QMI_ERR_NONE_V01)
    {
      resp_msg->data_subs_priority_valid = TRUE;
      resp_msg->data_subs_priority = (nas_data_subs_priority_enum_v01)qmi_nasi_global.data_subs_priority[(int)(client->report_status.bound_subs)];
    }
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) QMI_NAS_GET_DATA_SUBS_PRIORITY_REQ_MSG_V01,
                                  (void *) resp_msg,
                                  (uint32_t) sizeof( nas_get_data_subs_priority_resp_msg_v01 ),
                                  &response
                                );
	/*Else, get_data_subs_priority() - Failed to encode*/

  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( resp_msg != NULL ) 
  { 
    QMI_NAS_MEM_FREE( (void *) resp_msg ); 
    resp_msg = NULL;
  }

  return response;
} /* qmi_nasi_get_data_subs_priority() */

/*===========================================================================
  FUNCTION QMI_NAS_GEN_DATA_SUBS_PRIORITY_IND()

  DESCRIPTION
    generate QMI_NAS_ATA_SUBS_PRIORITY_IND

  PARAMETERS
    pointer to new CM PH event
===========================================================================*/
void qmi_nas_gen_data_subs_priority_ind( qmi_cm_ph_info_s_type *p_info )
{
  nas_data_subs_priority_ind_msg_v01    *ind_msg;
  dsm_item_type                         *ind;
  qmi_nasi_client_state_type            *cl_sp;
  int                                   client;

  QM_MSG_HIGH_2("data_subs_priority_ind() - subs: %d, priority: %d", p_info->asubs_id, p_info->priority_subs);

  ind_msg = (nas_data_subs_priority_ind_msg_v01 *) modem_mem_alloc( sizeof( nas_data_subs_priority_ind_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if(ind_msg != NULL)
  {
    memset( ind_msg, 0x00, sizeof(nas_data_subs_priority_ind_msg_v01) );
    for ( client=0; client < NASI_MAX_CLIDS; client++ )
    {
      cl_sp = qmi_nas_state.client[client];

      if ( cl_sp && cl_sp->common.clid != NASI_CLID_UNUSED && 
           cl_sp->report_status.bound_subs == p_info->asubs_id &&
           qmi_nasi_global.data_subs_priority[(int)(p_info->asubs_id)] != p_info->priority_type &&
           cl_sp->report_status.report_data_priority_subs_change ) 
      {
           QM_MSG_HIGH_1("data_subs_priority_ind() - sending to client %d", client);
           ind_msg->data_subs_priority_valid = TRUE;
           ind_msg->data_subs_priority = (nas_data_subs_priority_enum_v01) p_info->priority_type;
           ind = NULL;
           if ( qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                             QMI_IDL_INDICATION,
                                             (uint16_t) QMI_NAS_DATA_SUBS_PRIORITY_IND_MSG_V01,
                                             (void *) ind_msg,
                                             (uint32_t) sizeof( nas_data_subs_priority_ind_msg_v01 ),
                                             &ind ) )
          {
            qmi_nasi_send_ind( cl_sp, NASI_CMD_VAL_DATA_SUBS_PRIORITY_IND, ind );
          }
         /*else, Encoding has failed*/
      }
    }
  }
  else
  {
    qmi_voice_mem_error();
  }

  qmi_nasi_global.data_subs_priority[(int)(p_info->asubs_id)] = p_info->priority_type;

  if ( ind_msg != NULL ) { modem_mem_free( (void *) ind_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nas_gen_data_subs_priority_ind() */

/*===========================================================================
  FUNCTION qmi_nas_set_srvcc_resp()

  DESCRIPTION
    Send response for SET_SRVCC

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_set_srvcc_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *                         response = NULL;
  qmi_error_type_v01                      errval   = QMI_ERR_NONE_V01;
  boolean                                 retval   = TRUE;
  nas_set_srvcc_resp_msg_v01 *resp_msg;

  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf || !p_cmd_buf->x_p )
  {
    QM_MSG_ERROR("Null cmd_buf ptr");
    return;
  }

  errval = ( err == CM_PH_CMD_ERR_NOERR ) ? QMI_ERR_NONE_V01 : QMI_ERR_INTERNAL_V01;

  if(err == CM_PH_CMD_ERR_OPRT_MODE_S)
  {
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
  }

  resp_msg = (nas_set_srvcc_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_srvcc_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_srvcc_resp_msg_v01) );
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)((qmi_cmd_buf_type*)p_cmd_buf)->cmd_type,
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_set_srvcc_resp_msg_v01),
                                           &response
                                         );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &p_cmd_buf );
  }
  else qmi_nasi_send_response( p_cmd_buf, response );
  
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nas_set_srvcc_resp() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_SRVCC()

  DESCRIPTION
    This message configures data priority
    for the client's bound subscription.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_srvcc(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_type_v01                     errval            = QMI_ERR_NONE_V01;
  nas_set_srvcc_resp_msg_v01 *resp_msg;

  nas_set_srvcc_req_msg_v01  *req_msg;

  qmi_nasi_client_state_type *    client;
  client = (qmi_nasi_client_state_type*)cl_sp;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_set_srvcc_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_srvcc_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  req_msg  = (nas_set_srvcc_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_srvcc_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0, sizeof(nas_set_srvcc_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_srvcc_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    QM_MSG_ERROR("NAS was not initialized qmi_nasi_set_srvcc request");
    errval = QMI_ERR_INTERNAL_V01;
  }

  if( errval == QMI_ERR_NONE_V01 && req_msg != NULL && req_msg->srvcc_status != TRUE && req_msg->srvcc_status != FALSE)
  {
    QM_MSG_ERROR_1("Recieved qmi_nasi_set_srvcc request with srvcc_status=%d",req_msg->srvcc_status);
    errval = QMI_ERR_INVALID_ARG_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
      QM_MSG_HIGH_3("set_srvcc_req() - client %d subs %d srvcc_status=%d", client->common.clid, client->report_status.bound_subs, req_msg->srvcc_status);

      if(cm_set_srvcc_capability(qmi_nas_cmph_cmd_cb,
                                              cmd_buf_p,
                                              qmi_nasi_global.cm_clnt_id,
                                              (sys_modem_as_id_e_type)client->report_status.bound_subs,
                                               req_msg->srvcc_status))
      {
        QM_MSG_HIGH("set_data_subs_priority() - cm_ph_cmd_set_data_priority_per_subs sent, awaiting response");
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("cm_ph_cmd_set_data_priority_per_subs() failed");
      }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    if ( resp_msg != NULL )
    {
      memset(resp_msg, 0, sizeof(nas_set_srvcc_resp_msg_v01) );
      resp_msg->resp.error  = errval;
      resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
    
      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                    (void *)resp_msg,
                                    (uint32_t)sizeof(nas_set_srvcc_resp_msg_v01),
                                    &response
                                  );
    }
    else
    {
      qmi_voice_mem_error();
    }
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
}

/*===========================================================================
  FUNCTION QMI_NASI_SET_BSR_TIMER()

  DESCRIPTION
    This message sets the BSR value of the NV item NV_SD_CFG_ITEMS_I 

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_bsr_timer(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_e_type                       errval            = QMI_ERR_NONE;
  nas_set_bsr_timer_resp_msg_v01 *resp_msg;

  nas_set_bsr_timer_req_msg_v01  *req_msg;

  nv_stat_enum_type retval;
  nv_item_type data;
  
  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_set_bsr_timer_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_bsr_timer_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  req_msg  = (nas_set_bsr_timer_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_bsr_timer_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  
  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY;
  }

  if( errval == QMI_ERR_NONE)
  {
    memset(req_msg, 0, sizeof(nas_set_bsr_timer_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_bsr_timer_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL;
  }

  if( errval == QMI_ERR_NONE && req_msg->bsr_value > 600)
  {
    QM_MSG_ERROR_1("Invalid value for BSR timer set request - %d", req_msg->bsr_value);
    errval = QMI_ERR_INVALID_ARG;
  }
  
  if ( errval == QMI_ERR_NONE )
  {
	  retval = qm_nv_get(NV_SD_CFG_ITEMS_I, &data, 0);
	  
      if(retval != NV_DONE_S)
      {
        QM_MSG_ERROR_1("Failed to retreive current BSR timer value - %d", retval);
		errval = QMI_ERR_INTERNAL;
      }
  }
  
  if ( errval == QMI_ERR_NONE )
  {
      QM_MSG_HIGH_2("Setting BSR Timer value - Old %d New %d", data.sd_cfg_items.items[1], req_msg->bsr_value);
	  
      data.sd_cfg_items.items[1] = req_msg->bsr_value;
	  
	  retval = qm_nv_put(NV_SD_CFG_ITEMS_I, &data, 0);
	  
	  if(retval != NV_DONE_S)
      {
        QM_MSG_ERROR_1("Failed to set BSR timer value - %d", retval);
		errval = QMI_ERR_INTERNAL;
      }
  }
  

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_bsr_timer_resp_msg_v01) );
    resp_msg->resp.error  = (qmi_error_type_v01)errval;
	if ( errval == QMI_ERR_NONE )
	{
	  resp_msg->delayed_until_reset_valid = TRUE;
	  resp_msg->delayed_until_reset = qm_nv_bsr_changed();
	  resp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
	}
	else
	{
	  resp_msg->delayed_until_reset_valid = FALSE;
	  resp_msg->resp.result = QMI_RESULT_FAILURE_V01;
	}
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                  (void *)resp_msg,
                                  (uint32_t)sizeof(nas_set_bsr_timer_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_set_bsr_timer() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_BSR_TIMER()

  DESCRIPTION
    This message retreives the BSR value of the NV item NV_SD_CFG_ITEMS_I 

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_bsr_timer(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_e_type                       errval            = QMI_ERR_NONE;
  nas_get_bsr_timer_resp_msg_v01 *resp_msg;

  nas_get_bsr_timer_req_msg_v01  *req_msg;

  nv_stat_enum_type retval;
  nv_item_type data;
  
  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_get_bsr_timer_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_get_bsr_timer_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  req_msg  = (nas_get_bsr_timer_req_msg_v01  *) modem_mem_alloc( sizeof( nas_get_bsr_timer_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  
  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY;
  }

  if( errval == QMI_ERR_NONE)
  {
    memset(req_msg, 0, sizeof(nas_get_bsr_timer_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_get_bsr_timer_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL;
  }
  
  if ( errval == QMI_ERR_NONE )
  {
	  retval = qm_nv_get(NV_SD_CFG_ITEMS_I, &data, 0);
	  
      if(retval != NV_DONE_S)
      {
        QM_MSG_ERROR_1("Failed to retreive current BSR timer value - %d", retval);
		errval = QMI_ERR_INTERNAL;
      }
	  else
	  {
        QM_MSG_HIGH_1("Successfully retreived BSR Timer value - %d", data.sd_cfg_items.items[1]);
	  }
  }
  
  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_get_bsr_timer_resp_msg_v01) );
    resp_msg->resp.error  = (qmi_error_type_v01)errval;
	if ( errval == QMI_ERR_NONE )
	{
	  resp_msg->bsr_value_valid = TRUE;
	  resp_msg->bsr_value = data.sd_cfg_items.items[1];
	  resp_msg->delayed_until_reset_valid = TRUE;
	  resp_msg->delayed_until_reset = qm_nv_bsr_changed();
	  resp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
	}
	else
	{
	  resp_msg->bsr_value_valid = FALSE;
	  resp_msg->resp.result = QMI_RESULT_FAILURE_V01;
	}
	
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                  (void *)resp_msg,
                                  (uint32_t)sizeof(nas_get_bsr_timer_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_get_bsr_timer() */


/*===========================================================================
  FUNCTION QMI_NASI_SET_MCC()

  DESCRIPTION
    This message communicates MCC, status and confidence
    values to PM to help speed up network scan times

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_mcc(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_type_v01                     errval            = QMI_ERR_NONE_V01;
  nas_set_mcc_resp_msg_v01 *resp_msg;

  nas_set_mcc_req_msg_v01  *req_msg;

  policyman_status_t pm_response;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_set_mcc_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_mcc_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  req_msg  = (nas_set_mcc_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_mcc_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0, sizeof(nas_set_mcc_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_set_mcc_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
      QM_MSG_HIGH_3("set_mcc() - MCC %d Confidence %d Status %d", req_msg->mcc, req_msg->confidence, req_msg->mcc_status);

      pm_response = policyman_set_hlos_mcc((sys_mcc_type)req_msg->mcc,
                                            (uint32_t)req_msg->confidence,
                                            (uint32_t)req_msg->mcc_status);


      if(pm_response == POLICYMAN_STATUS_SUCCESS)
      {
        QM_MSG_HIGH("set_mcc() - policyman_set_hlos_mcc() successful");
      }
      else
      {
        switch(pm_response)
        {
            case POLICYMAN_STATUS_ERR_NOT_READY: errval = QMI_ERR_DEVICE_NOT_READY_V01; break;             /**< policyman is not ready */
            case POLICYMAN_STATUS_ERR_INVALID_ARGS: errval = QMI_ERR_INVALID_ARG_V01; break;          /**< call was made with invalid arguments */
            case POLICYMAN_STATUS_ERR_MALFORMED_XML: errval = QMI_ERR_MALFORMED_MSG_V01; break;         /**< XML in config file for policy is not well-formed */
            default: errval = QMI_ERR_INTERNAL_V01; break;
        }
        QM_MSG_ERROR_1("set_mcc() - policyman_set_hlos_mcc() failed %d", pm_response);
      }
  }

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_mcc_resp_msg_v01) );
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                  (void *)resp_msg,
                                  (uint32_t)sizeof(nas_set_mcc_resp_msg_v01),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_set_mcc() */

/*===========================================================================
  FUNCTION QMI_NASI_AVOID_TUNEAWAY_REQ()

  DESCRIPTION
    Request to block/unblock  tuneaway on other sub when AP IMS
	call ongoing

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_avoid_tuneaway_req(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                          *response          = NULL;
  qmi_error_type_v01                     errval            = QMI_ERR_NONE_V01;
  nas_avoid_tuneaway_resp_msg_v01 *resp_msg;

  nas_avoid_tuneaway_req_msg_v01  *req_msg;

  qmi_nasi_client_state_type *    client;
  client = (qmi_nasi_client_state_type*)cl_sp;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null pointer error %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    return NULL;
  }

  resp_msg = (nas_avoid_tuneaway_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_avoid_tuneaway_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  req_msg  = (nas_avoid_tuneaway_req_msg_v01  *) modem_mem_alloc( sizeof( nas_avoid_tuneaway_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if( errval == QMI_ERR_NONE_V01)
  {
    memset(req_msg, 0, sizeof(nas_avoid_tuneaway_req_msg_v01));

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *)req_msg,
                                           (uint32_t)sizeof(nas_avoid_tuneaway_req_msg_v01)
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 && qmi_nasi_global.inited != INIT_STATE_INITIALIZED )
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
      QM_MSG_HIGH_3("qmi_nasi_avoid_tuneaway_req() - client %d subs %d tuneaway %d", client->common.clid, client->report_status.bound_subs, req_msg->trm_priority);

      if(cm_ph_set_trm_priority(qmi_nas_cmph_cmd_cb,
                                cmd_buf_p,
                                qmi_nasi_global.cm_clnt_id,
                                (sys_modem_as_id_e_type)client->report_status.bound_subs,
                                req_msg->trm_priority))
      {
        QM_MSG_HIGH("qmi_nasi_avoid_tuneaway_req() - cm_ph_set_trm_priority sent, awaiting response");
      }
      else
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR("cm_ph_set_trm_priority() failed");
      }
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    response = QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    if ( resp_msg != NULL )
    {
      memset(resp_msg, 0, sizeof(nas_avoid_tuneaway_resp_msg_v01) );
      resp_msg->resp.error  = errval;
      resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );
    
      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                    (void *)resp_msg,
                                    (uint32_t)sizeof(nas_avoid_tuneaway_resp_msg_v01),
                                    &response
                                  );
    }
    else
    {
      qmi_voice_mem_error();
    }
  }

  if ( req_msg  != NULL ){ modem_mem_free((void *)req_msg, MODEM_MEM_CLIENT_QMI_MMODE); }
  if ( resp_msg != NULL ){ modem_mem_free((void *)resp_msg, MODEM_MEM_CLIENT_QMI_MMODE); }

  return response;
} /* qmi_nasi_avoid_tuneaway_req() */

/*===========================================================================
  FUNCTION QMI_NASI_AVOID_TUNEAWAY_RESP()

  DESCRIPTION
    Send response for AVOID_TUNEAWAY_REQ

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_avoid_tuneaway_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *                         response = NULL;
  qmi_error_type_v01                      errval   = QMI_ERR_NONE_V01;
  boolean                                 retval   = TRUE;
  nas_avoid_tuneaway_resp_msg_v01 *resp_msg;

  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf || !p_cmd_buf->x_p )
  {
    QM_MSG_ERROR("Null cmd_buf ptr");
    return;
  }

  switch (err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE_V01;
      break;

    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE_V01;
      break;

    case CM_PH_CMD_ERR_PLMN_P:
      errval = QMI_ERR_NO_NETWORK_FOUND_V01;
      break;

    case CM_PH_CMD_ERR_SYS_SEL_PREF_S:
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
      break;

    case CM_PH_CMD_ERR_API_NOT_SUPPORTED_S:
    case CM_PH_CMD_ERR_PS_LOCAL_DETACH_NOT_ALLOWED_S:
    case CM_PH_CMD_ERR_FUNCTION_NOT_APPLICABLE:
      errval = QMI_ERR_INVALID_OPERATION_V01;
      break;

    default:
      errval = QMI_ERR_INTERNAL_V01;
      break;
  }

  resp_msg = (nas_avoid_tuneaway_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_avoid_tuneaway_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_avoid_tuneaway_resp_msg_v01) );
    resp_msg->resp.error  = errval;
    resp_msg->resp.result = (errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01: QMI_RESULT_FAILURE_V01 );

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)((qmi_cmd_buf_type*)p_cmd_buf)->cmd_type,
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_avoid_tuneaway_resp_msg_v01),
                                           &response
                                         );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &p_cmd_buf );
  }
  else if ( !qmi_nasi_send_response( p_cmd_buf, response ) )
  {
    QM_MSG_MED("QMI_NAS_AVOID_TUNEAWAY_RESP send failed");
  }
  
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nasi_avoid_tuneaway_resp() */
/*===========================================================================
  FUNCTION QMI_NASI_SET_DRX_SCALING_FACTOR ()

  DESCRIPTION
    Changes how often the device initiates a DRX cycle.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_drx_scaling_factor
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
  
  lte_rrc_mtc_cfg_req_s msg;
  geran_grr_mtc_cfg_req_t msg_g;
  wcdma_rrc_qmi_mtc_cfg_req_type msg_w;
  errno_enum_type      msgr_err;
  
  nas_set_drx_scaling_factor_req_msg_v01  *req_msg;
  nas_set_drx_scaling_factor_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = (nas_set_drx_scaling_factor_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_drx_scaling_factor_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_drx_scaling_factor_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_drx_scaling_factor_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    qmi_voice_mem_error();
    return response;
  }
  else if(rsp_msg == NULL)
  {
    modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    qmi_voice_mem_error();
    return response;
  }
  
  memset(req_msg, 0, sizeof(nas_set_drx_scaling_factor_req_msg_v01));
  memset(rsp_msg, 0, sizeof(nas_set_drx_scaling_factor_resp_msg_v01));

  if(qmi_efs_drx_scaling_enabled() != MCFG_FS_STATUS_OK)
  {
    QM_MSG_ERROR("enable_drx_scaling_skip_meas efs check failed for QMI_NASI_SET_DRX_SCALING_FACTOR response");
    errval = QMI_ERR_INTERNAL;
  }
  
  if(errval == QMI_ERR_NONE)
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                         sdu_in,
                                         (void *)req_msg,
                                         (uint32_t)sizeof(nas_set_drx_scaling_factor_req_msg_v01)
                                       );
    if (errval != QMI_ERR_NONE)
      QM_MSG_ERROR_1("Not able to parse QMI_NASI_SET_DRX_SCALING_FACTOR request: %d", errval);
  }
  
  if(errval == QMI_ERR_NONE && (req_msg->radio_access_technology != NAS_RADIO_IF_LTE_V01 
                                && req_msg->radio_access_technology != NAS_RADIO_IF_GSM_V01
                                && req_msg->radio_access_technology != NAS_RADIO_IF_UMTS_V01))
  {
    QM_MSG_ERROR("DRX scaling factor only applicable to LTE - GSM - WCDMA in QMI_NASI_SET_DRX_SCALING_FACTOR request");
    errval = QMI_ERR_NOT_SUPPORTED;
  }

  if(errval == QMI_ERR_NONE && req_msg->drx_scaling_factor_valid == FALSE && req_msg->skip_idle_meas_valid == FALSE)
  {
    QM_MSG_ERROR("No DRX scaling factor or skip_idle_meas boolean is present in QMI_NASI_SET_DRX_SCALING_FACTOR request");
    errval = QMI_ERR_MALFORMED_MSG;
  }
  
  if(errval == QMI_ERR_NONE && req_msg->drx_scaling_factor_valid == TRUE && (req_msg->drx_scaling_factor == 0 || req_msg->drx_scaling_factor > 10))
  {
    QM_MSG_ERROR_1("Invalid DRX scaling factor in QMI_NASI_SET_DRX_SCALING_FACTOR request: %d", req_msg->drx_scaling_factor);
    errval = QMI_ERR_MALFORMED_MSG;
  }
  
  if ( qmi_nasi_global.set_drx_scaling_cmd_buf_p != NULL )
  {
    QM_MSG_ERROR("Already processing a QMI_NASI_SET_DRX_SCALING_FACTOR request");
    errval = QMI_ERR_DEVICE_NOT_READY;
  }
  
  if(errval == QMI_ERR_NONE)
  {
    QM_MSG_HIGH_3("QMI_NASI_SET_DRX_SCALING_FACTOR request - scaling factor: %d skip_idle_meas_valid: %d, skip_idle_meas: %d", req_msg->drx_scaling_factor, req_msg->skip_idle_meas_valid, req_msg->skip_idle_meas);
    switch (req_msg->radio_access_technology)
    {
      case NAS_RADIO_IF_LTE_V01:
      {
    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_MTC_CFG_REQ);
    if(req_msg->drx_scaling_factor_valid == TRUE)
    {
      msg.drx_scaling_factor_valid = TRUE;
      msg.drx_scaling_factor = (uint8_t)req_msg->drx_scaling_factor;
    }
    else
    {
      msg.drx_scaling_factor_valid = FALSE;
    }
	
    if(req_msg->skip_idle_meas_valid == TRUE)
    {
      msg.skip_idle_srch_meas_valid = TRUE;
      msg.skip_idle_srch_meas = req_msg->skip_idle_meas;
    }
    else
    {
      msg.skip_idle_srch_meas_valid = FALSE;
    }
       msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
       break;
      }
      case NAS_RADIO_IF_GSM_V01:
      {
       msgr_init_hdr( (msgr_hdr_struct_type*)&msg_g, MSGR_QMI_NAS, GERAN_GRR_MTC_CFG_REQ);
       if(req_msg->drx_scaling_factor_valid == TRUE)
       {
          msg_g.drx_scaling_factor_valid = TRUE;
	      msg_g.drx_scaling_factor = (uint8_t)req_msg->drx_scaling_factor;
       }
       else
       {
	     msg_g.drx_scaling_factor_valid = FALSE;
       }

       if(req_msg->skip_idle_meas_valid == TRUE)
       {
          msg_g.skip_idle_mode_meas_valid = TRUE;
          msg_g.skip_idle_mode_meas = req_msg->skip_idle_meas;
       }
       else
       {
          msg_g.skip_idle_mode_meas_valid = FALSE;
       }
       msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg_g, sizeof(msg_g) );
       break;
      }
case NAS_RADIO_IF_UMTS_V01:
     {
        msgr_init_hdr( (msgr_hdr_struct_type*)&msg_w, MSGR_QMI_NAS, WCDMA_RRC_QMI_MTC_CFG_REQ);
        if(req_msg->drx_scaling_factor_valid == TRUE)
        {
        msg_w.drx_scaling_factor_valid = TRUE;
        msg_w.drx_scaling_factor = (uint8_t)req_msg->drx_scaling_factor;
        }
        else
        {
        msg_w.drx_scaling_factor_valid = FALSE;
        }
        
        if(req_msg->skip_idle_meas_valid == TRUE)
        {
        msg_w.skip_idle_srch_meas_valid = TRUE;
        msg_w.skip_idle_srch_meas = req_msg->skip_idle_meas;
        }
        else
        {
        msg_w.skip_idle_srch_meas_valid = FALSE;
        }
        msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg_w, sizeof(msg_w) );
        break;
     }
     default:
     break;
    }	
	
    if ( msgr_err != E_SUCCESS )
    {
      QM_MSG_ERROR_1("QMI_NASI_SET_DRX_SCALING_FACTOR send fail %d", msgr_err);
      errval = QMI_ERR_INTERNAL;
    }
    else
    {
      qmi_nasi_global.set_drx_scaling_cmd_buf_p = cmd_buf_p;
    }
  }
  

  if ( errval == QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
	
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_drx_scaling_factor_resp_msg_v01),
                                  &response
                                );
  }
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  return response;
  
} /* qmi_nasi_set_drx_scaling_factor() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_DRX_SCALING_FACTOR ()

  DESCRIPTION
    Returns result of setting a new DRX scaling factor.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_set_drx_scaling_factor_rsp
(
 errno_enum_type status
)
{
  qmi_cmd_buf_type *cmd_buf_p = qmi_nasi_global.set_drx_scaling_cmd_buf_p;
  dsm_item_type *  response = NULL;
  nas_set_drx_scaling_factor_resp_msg_v01 *rsp_msg;

  qmi_nasi_global.set_drx_scaling_cmd_buf_p = NULL;

  if(cmd_buf_p == NULL)
  {
    QM_MSG_ERROR("Cant find client for QMI_NASI_SET_DRX_SCALING_FACTOR resp");
    return;
  }
  
  rsp_msg = (nas_set_drx_scaling_factor_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_drx_scaling_factor_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
   qmi_voice_mem_error();
    return;
  }
  
  memset (rsp_msg, 0x00, sizeof(nas_set_drx_scaling_factor_resp_msg_v01));

  if(status == E_SUCCESS)
  {
    rsp_msg->resp.error  = QMI_ERR_NONE_V01;
    rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
  }
  else
  {
    rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
  }
  
  if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                            QMI_IDL_RESPONSE,
                                            (uint16_t) QMI_NAS_SET_DRX_SCALING_FACTOR_RESP_MSG_V01,
                                            (void *) rsp_msg,
                                            (uint32_t) sizeof( nas_set_drx_scaling_factor_resp_msg_v01 ),
                                            &response
                                           ) )
  {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
        /*Unable to send QMI_NASI_SET_DRX_SCALING_FACTOR response*/
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }
  
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

} /* qmi_nasi_generate_set_drx_scaling_factor_rsp() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_DATA_ROAMING_STATUS ()

  DESCRIPTION
    Sets the Data roaming status, which requires power cycle to take effect.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_data_roaming_status 
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

  nas_set_data_roaming_req_msg_v01  * req_msg = NULL;
  nas_set_data_roaming_resp_msg_v01 * rsp_msg = NULL;

  enum qmi_nas_subs_e subs;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  subs = ((qmi_nasi_client_state_type*)cl_sp)->report_status.bound_subs;

  req_msg = (nas_set_data_roaming_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_data_roaming_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    qmi_voice_mem_error();
    return NULL;
  }

  if(qmi_nasi_global.data_roam_temp_valid)
  {
    QM_MSG_ERROR_2("QMI_NAS_SET_DATA_ROAMING response already pending - pending sub %d, curr sub %d", qmi_nasi_global.data_roam_temp_subs, subs);
    errval = QMI_ERR_DEVICE_IN_USE_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_data_roaming_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_SET_DATA_ROAMING_REQ_MSG_V01,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_data_roaming_req_msg_v01)
                                         );
  }

  // check for error in REQ message
  if (errval == QMI_ERR_NONE_V01)
  {
    errval = qmi_nas_009A_req_check( req_msg );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH_2("calling cm_ph_cmd_data_roaming_per_subs() - roam %d subs %d", req_msg->data_roam_status, subs);
    if ( !cm_ph_cmd_data_roaming_per_subs( qmi_nas_cmph_cmd_cb, cmd_buf_p, qmi_nasi_global.cm_clnt_id, (sys_data_roaming_e_type)req_msg->data_roam_status, (sys_modem_as_id_e_type)subs ) )
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR("cm_ph_cmd_data_roaming_per_subs() failed");
    }
    else
    {
      qmi_nasi_global.data_roam_temp = (sys_data_roaming_e_type)req_msg->data_roam_status;
      qmi_nasi_global.data_roam_temp_subs = subs;
      qmi_nasi_global.data_roam_temp_valid = TRUE;
      response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
    }
  }

  // take care of result if error
  if( cmd_buf_p != NULL && errval != QMI_ERR_NONE_V01 )
  {
    rsp_msg = (nas_set_data_roaming_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_data_roaming_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    if ( rsp_msg == NULL)
    {
      qmi_voice_mem_error();
      if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
      return NULL;
    }
    else
    {
      memset( rsp_msg, 0x00, sizeof(nas_set_data_roaming_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
      rsp_msg->pending_device_reset_valid = FALSE;

      QM_MSG_HIGH_1("Set Data roaming status with error=%d", (uint16)errval);
      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t) QMI_NAS_SET_DATA_ROAMING_RESP_MSG_V01,
                                    (void *) rsp_msg,
                                    (uint32_t) sizeof(nas_set_data_roaming_resp_msg_v01),
                                    &response
                                  );
    }
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_set_data_roaming_status */

/*===========================================================================
  FUNCTION QMI_NASI_SET_DATA_ROAMING_STATUS_RESP()

  DESCRIPTION
    Send response for SET_DATA_ROAMING

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_set_data_roaming_status_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *                         response = NULL;
  qmi_error_type_v01                      errval   = QMI_ERR_NONE_V01;
  boolean                                 retval   = TRUE;
  nas_set_data_roaming_resp_msg_v01 *resp_msg;

  qmi_nasi_global.data_roam_temp_valid = FALSE;
  
  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf || !p_cmd_buf->x_p )
  {
    /*Null cmd_buf ptr*/
    return;
  }

  switch (err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE_V01;
      break;

    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE_V01;
      break;

    case CM_PH_CMD_ERR_PLMN_P:
      errval = QMI_ERR_NO_NETWORK_FOUND_V01;
      break;

    case CM_PH_CMD_ERR_SYS_SEL_PREF_S:
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
      break;

    case CM_PH_CMD_ERR_API_NOT_SUPPORTED_S:
    case CM_PH_CMD_ERR_PS_LOCAL_DETACH_NOT_ALLOWED_S:
    case CM_PH_CMD_ERR_FUNCTION_NOT_APPLICABLE:
      errval = QMI_ERR_INVALID_OPERATION_V01;
      break;

    default:
      errval = QMI_ERR_INTERNAL_V01;
      break;
  }
  
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH_2("QMI_NASI_SET_DATA_ROAMING_STATUS_RESP successful - subs %d roam %d", qmi_nasi_global.data_roam_temp_subs, qmi_nasi_global.data_roam_temp);
    qmi_nasi_global.data_roam_cache_valid[qmi_nasi_global.data_roam_temp_subs] = TRUE;
    qmi_nasi_global.data_roam_cache[qmi_nasi_global.data_roam_temp_subs] = qmi_nasi_global.data_roam_temp;
  }

  resp_msg = (nas_set_data_roaming_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_data_roaming_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_data_roaming_resp_msg_v01) );

    resp_msg->resp.error  = errval;
    if(errval == QMI_ERR_NONE_V01)
    {
      resp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
      resp_msg->pending_device_reset_valid = TRUE;
      resp_msg->pending_device_reset = FALSE;
    }
    else
    {
      resp_msg->resp.result = QMI_RESULT_FAILURE_V01;
      resp_msg->pending_device_reset_valid = FALSE;
    }

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)((qmi_cmd_buf_type*)p_cmd_buf)->cmd_type,
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_set_data_roaming_resp_msg_v01),
                                           &response
                                         );
  }
  else
  {
    QM_MSG_ERROR("Not enough memory to allocate for QMI_NAS_AVOID_TUNEAWAY response");
  }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &p_cmd_buf );
  }
  else if ( !qmi_nasi_send_response( p_cmd_buf, response ) )
  {
    QM_MSG_MED("QMI_NASI_SET_DATA_ROAMING_STATUS_RESP send failed");
  }
  
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nasi_set_data_roaming_status_resp */

/*===========================================================================
  FUNCTION QMI_NASI_GET_DATA_ROAMING_STATUS ()

  DESCRIPTION
    Sets the Data roaming status, which requires power cycle to take effect.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_data_roaming_status 
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

  nas_get_data_roaming_req_msg_v01  * req_msg;
  nas_get_data_roaming_resp_msg_v01 * rsp_msg;
  
  enum qmi_nas_subs_e subs;
  
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  
  subs = ((qmi_nasi_client_state_type*)cl_sp)->report_status.bound_subs;

  if ((subs <= QMI_NAS_SUBS_NONE) || (subs >= QMI_NAS_SUBS_MAX))
  {
    QM_MSG_ERROR_1("qmi_nasi_get_data_roaming_status: unsupported subs %d", subs);
    return NULL;
  }

  req_msg = (nas_get_data_roaming_req_msg_v01  *) modem_mem_alloc( sizeof(nas_get_data_roaming_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_data_roaming_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_data_roaming_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL || rsp_msg == NULL )
  {
    QM_MSG_ERROR_2("Not enough memory to allocate for QMI_NAS_GET_DATA_ROAMING request/response. %p %p", req_msg, rsp_msg);
    if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
    if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
    return NULL;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_get_data_roaming_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_GET_DATA_ROAMING_REQ_MSG_V01,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_data_roaming_req_msg_v01)
                                         );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    if(!qmi_nasi_global.data_roam_cache_valid[subs])
    {
      errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
      QM_MSG_ERROR_1("data_roam_cache not initialized for subs %d", subs);
    }
  }

  // take care of result
  if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_data_roaming_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    if(rsp_msg->resp.error == QMI_ERR_NONE_V01)
    {
      rsp_msg->data_roam_status_valid = TRUE;
      rsp_msg->data_roam_status = (nas_data_roaming_enum_v01)qmi_nasi_global.data_roam_cache[subs];
      rsp_msg->pending_device_reset_valid = TRUE;
      rsp_msg->pending_device_reset = FALSE;
    }

    QM_MSG_HIGH_3("Get Data roaming status with error=%d, data roam status=%d subs=%d", (uint16)errval,(uint32)qmi_nasi_global.data_roam_cache[subs], subs);
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) QMI_NAS_GET_DATA_ROAMING_RESP_MSG_V01,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_data_roaming_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_set_data_roaming_status */

/*===========================================================================
  FUNCTION QMI_NASI_SET_RPM_PARAMETERS ()

  DESCRIPTION
    Changes Radio Policy Manager details if it is active

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_rpm_parameters
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
  
  cm_mm_set_rpm_parameters_req_s_type msg;
  errno_enum_type      msgr_err;
  
  nas_set_rpm_parameters_req_msg_v01  *req_msg;
  nas_set_rpm_parameters_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = (nas_set_rpm_parameters_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_rpm_parameters_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_rpm_parameters_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_rpm_parameters_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_PARAMETERS request*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return response;
  }
  else if(rsp_msg == NULL)
  {
    modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_PARAMETERS response*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return response;
  }
  
  memset(req_msg, 0, sizeof(nas_set_rpm_parameters_req_msg_v01));
  memset(rsp_msg, 0, sizeof(nas_set_rpm_parameters_resp_msg_v01));
  
  if(errval == QMI_ERR_NONE)
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                         sdu_in,
                                         (void *)req_msg,
                                         (uint32_t)sizeof(nas_set_rpm_parameters_req_msg_v01)
                                       );
    if (errval != QMI_ERR_NONE)
      QM_MSG_ERROR_1("Not able to parse QMI_NASI_SET_RPM_PARAMETERS request: %d", errval);
  }
  
  if(errval == QMI_ERR_NONE && (req_msg->max_resets < 1 || req_msg->max_resets > 16))
  {
    QM_MSG_ERROR_1("max resets must be a value between 1 and 16: %d", req_msg->max_resets);
    errval = QMI_ERR_INVALID_ARG;
  }

  if(errval == QMI_ERR_NONE && (req_msg->avg_reject_time < 1 || req_msg->avg_reject_time > 360))
  {
    QM_MSG_ERROR_1("average reject time must be a value between 0 and 360 seconds: %d", req_msg->avg_reject_time);
    errval = QMI_ERR_INVALID_ARG;
  }
  
  if ( qmi_nasi_global.rpm_parameters_cmd_buf_p != NULL )
  {
    QM_MSG_ERROR("Already processing a QMI_NASI_SET_RPM_PARAMETERS or QMI_NASI_GET_RPM_PARAMETERS request");
    errval = QMI_ERR_DEVICE_NOT_READY;
  }
  
  if(errval == QMI_ERR_NONE)
  {
    QM_MSG_HIGH_2("QMI_NASI_SET_RPM_PARAMETERS request - max_resets: %d, avg_reject_time: %d", req_msg->max_resets, req_msg->avg_reject_time);
  
    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, MM_CM_SET_RPM_PARAMETERS_REQ);
	
    msg.lte_rpm_params.max_event_counter = req_msg->max_resets;
    msg.lte_rpm_params.max_event_timer = req_msg->avg_reject_time;
	
    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
	
    if ( msgr_err != E_SUCCESS )
    {
      QM_MSG_ERROR_1("QMI_NASI_SET_RPM_PARAMETERS send fail %d", msgr_err);
      errval = QMI_ERR_INTERNAL;
    }
    else
    {
      qmi_nasi_global.rpm_parameters_cmd_buf_p = cmd_buf_p;
    }
  }
  

  if ( errval == QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
	
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_rpm_parameters_resp_msg_v01),
                                  &response
                                );
  }
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  return response;
  
} /* qmi_nasi_set_rpm_parameters() */

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_SET_RPM_PARAMETERS_RSP ()

  DESCRIPTION
    Returns result of setting Radio Policy Manager details.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_set_rpm_parameters_rsp
(
 qmi_mmodei_msgr_type * msg_p
)
{
  qmi_cmd_buf_type *cmd_buf_p = qmi_nasi_global.rpm_parameters_cmd_buf_p;
  dsm_item_type *  response = NULL;
  nas_set_rpm_parameters_resp_msg_v01 *rsp_msg;

  qmi_nasi_global.rpm_parameters_cmd_buf_p = NULL;

  if(cmd_buf_p == NULL)
  {
    QM_MSG_ERROR("Cant find client for QMI_NASI_SET_RPM_PARAMETERS resp");
    return;
  }
  
  rsp_msg = (nas_set_rpm_parameters_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_rpm_parameters_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_PARAMETERS resp*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return;
  }
  
  memset (rsp_msg, 0x00, sizeof(nas_set_rpm_parameters_resp_msg_v01));

  if(msg_p->cmd.qmi_nas.set_rpm_parameters_resp.rpm_rsp_ret_val == CM_RPM_SUCCESS_RPM_ENABLED)
  {
    rsp_msg->resp.error  = QMI_ERR_NONE_V01;
    rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
  }
  else
  {
    rsp_msg->resp.error  = QMI_ERR_INCOMPATIBLE_STATE_V01;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
  }
  
  if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                            QMI_IDL_RESPONSE,
                                            (uint16_t) QMI_NAS_SET_RPM_PARAMETERS_RESP_MSG_V01,
                                            (void *) rsp_msg,
                                            (uint32_t) sizeof( nas_set_rpm_parameters_resp_msg_v01 ),
                                            &response
                                           ) )
  {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
        /*Unable to send QMI_NASI_SET_RPM_PARAMETERS response*/
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }
  
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

} /* qmi_nasi_generate_set_rpm_parameters_rsp() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_RPM_PARAMETERS_2 ()

  DESCRIPTION
    Changes Radio Policy Manager details if it is active

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_rpm_parameters_2
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
  
  cm_mm_set_rpm_parameters_req_s_type msg;
  errno_enum_type      msgr_err;
  
  nas_set_rpm_parameters_2_req_msg_v01  *req_msg;
  nas_set_rpm_parameters_2_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = (nas_set_rpm_parameters_2_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_rpm_parameters_2_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_rpm_parameters_2_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_rpm_parameters_2_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_PARAMETERS_2 request*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return response;
  }
  else if(rsp_msg == NULL)
  {
    modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_PARAMETERS_2 response*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return response;
  }
  
  memset(req_msg, 0, sizeof(nas_set_rpm_parameters_2_req_msg_v01));
  memset(rsp_msg, 0, sizeof(nas_set_rpm_parameters_2_resp_msg_v01));
  
  if(errval == QMI_ERR_NONE)
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                         sdu_in,
                                         (void *)req_msg,
                                         (uint32_t)sizeof(nas_set_rpm_parameters_2_req_msg_v01)
                                       );
    if (errval != QMI_ERR_NONE)
      QM_MSG_ERROR_1("Not able to parse QMI_NASI_SET_RPM_PARAMETERS_2 request: %d", errval);
  }
  
  if(errval == QMI_ERR_NONE && (req_msg->max_event_counter < 1 || req_msg->max_event_counter > 16))
  {
    QM_MSG_ERROR_1("max event counter must be a value between 1 and 16: %d", req_msg->max_event_counter);
    errval = QMI_ERR_INVALID_ARG;
  }

  if(errval == QMI_ERR_NONE && (req_msg->max_event_time < 1 || req_msg->max_event_time > 360))
  {
    QM_MSG_ERROR_1("max event time must be a value between 0 and 360 seconds: %d", req_msg->max_event_time);
    errval = QMI_ERR_INVALID_ARG;
  }
  
  if ( qmi_nasi_global.rpm_parameters_cmd_buf_p != NULL )
  {
    QM_MSG_ERROR("Already processing a QMI_NASI_SET_RPM_PARAMETERS, QMI_NASI_SET_RPM_PARAMETER_2 or QMI_NASI_GET_RPM_PARAMETERS request");
    errval = QMI_ERR_DEVICE_NOT_READY;
  }
  
  if(errval == QMI_ERR_NONE)
  {
    QM_MSG_HIGH_2("QMI_NASI_SET_RPM_PARAMETERS_2 request - max_event_counter: %d, max_event_time: %d", req_msg->max_event_counter, req_msg->max_event_time);
  
    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, MM_CM_SET_RPM_PARAMETERS_REQ);

    msg.lte_rpm_params.max_event_counter = req_msg->max_event_counter;
    msg.lte_rpm_params.max_event_timer = req_msg->max_event_time;

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

    if ( msgr_err != E_SUCCESS )
    {
      QM_MSG_ERROR_1("QMI_NASI_SET_RPM_PARAMETERS_2 send fail %d", msgr_err);
      errval = QMI_ERR_INTERNAL;
    }
    else
    {
      qmi_nasi_global.rpm_parameters_cmd_buf_p = cmd_buf_p;
    }
  }
  

  if ( errval == QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_rpm_parameters_2_resp_msg_v01),
                                  &response
                                );
  }
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  return response;
  
} /* qmi_nasi_set_rpm_parameters_2() */

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_SET_RPM_PARAMETERS_RSP_2 ()

  DESCRIPTION
    Returns result of setting Radio Policy Manager details.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_set_rpm_parameters_2_rsp
(
 qmi_mmodei_msgr_type * msg_p
)
{
  qmi_cmd_buf_type *cmd_buf_p = qmi_nasi_global.rpm_parameters_cmd_buf_p;
  dsm_item_type *  response = NULL;
  nas_set_rpm_parameters_2_resp_msg_v01 *rsp_msg;

  qmi_nasi_global.rpm_parameters_cmd_buf_p = NULL;

  if(cmd_buf_p == NULL)
  {
    QM_MSG_ERROR("Cant find client for QMI_NASI_SET_RPM_PARAMETERS_2 resp");
    return;
  }
  
  rsp_msg = (nas_set_rpm_parameters_2_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_rpm_parameters_2_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_PARAMETERS_2 resp*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return;
  }
  
  memset (rsp_msg, 0x00, sizeof(nas_set_rpm_parameters_2_resp_msg_v01));

  if(msg_p->cmd.qmi_nas.set_rpm_parameters_resp.rpm_rsp_ret_val == CM_RPM_SUCCESS_RPM_ENABLED)
  {
    rsp_msg->resp.error  = QMI_ERR_NONE_V01;
    rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
  }
  else
  {
    rsp_msg->resp.error  = QMI_ERR_INCOMPATIBLE_STATE_V01;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
  }
  
  if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                            QMI_IDL_RESPONSE,
                                            (uint16_t) QMI_NAS_SET_RPM_PARAMETERS_2_RESP_MSG_V01,
                                            (void *) rsp_msg,
                                            (uint32_t) sizeof( nas_set_rpm_parameters_2_resp_msg_v01 ),
                                            &response
                                           ) )
  {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
        /*Unable to send QMI_NASI_SET_RPM_PARAMETERS response*/
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }
  
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

} /* qmi_nasi_generate_set_rpm_parameters_2_rsp() */

/*===========================================================================
  FUNCTION QMI_NASI_GET_RPM_PARAMETERS ()

  DESCRIPTION
    Retrieves Radio Policy Manager details if it is active

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_rpm_parameters
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
  
  lte_rrc_mtc_cfg_req_s msg;
  errno_enum_type      msgr_err;
  
  nas_get_rpm_parameters_req_msg_v01  *req_msg;
  nas_get_rpm_parameters_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = (nas_get_rpm_parameters_req_msg_v01  *) modem_mem_alloc( sizeof( nas_get_rpm_parameters_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_rpm_parameters_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_rpm_parameters_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    /*Not enough memory to allocate for QMI_NASI_GET_RPM_PARAMETERS request*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return response;
  }
  else if(rsp_msg == NULL)
  {
    modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    /*Not enough memory to allocate for QMI_NASI_GET_RPM_PARAMETERS response*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return response;
  }
  
  memset(req_msg, 0, sizeof(nas_get_rpm_parameters_req_msg_v01));
  memset(rsp_msg, 0, sizeof(nas_get_rpm_parameters_resp_msg_v01));
  
  if(errval == QMI_ERR_NONE)
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                         sdu_in,
                                         (void *)req_msg,
                                         (uint32_t)sizeof(nas_get_rpm_parameters_req_msg_v01)
                                       );
    if (errval != QMI_ERR_NONE)
      QM_MSG_ERROR_1("Not able to parse QMI_NASI_GET_RPM_PARAMETERS request: %d", errval);
  }
  
  if ( qmi_nasi_global.rpm_parameters_cmd_buf_p != NULL )
  {
    QM_MSG_ERROR("Already processing a QMI_NASI_GET_RPM_PARAMETERS or QMI_NASI_GET_RPM_PARAMETERS request");
    errval = QMI_ERR_DEVICE_NOT_READY;
  }
  
  if(errval == QMI_ERR_NONE)
  {
    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, MM_CM_GET_RPM_PARAMETERS_REQ);

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
	
    if ( msgr_err != E_SUCCESS )
    {
      QM_MSG_ERROR_1("QMI_NASI_GET_RPM_PARAMETERS send fail %d", msgr_err);
      errval = QMI_ERR_INTERNAL;
    }
    else
    {
      qmi_nasi_global.rpm_parameters_cmd_buf_p = cmd_buf_p;
    }
  }
  

  if ( errval == QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
	
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_rpm_parameters_resp_msg_v01),
                                  &response
                                );
  }
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  return response;
  
} /* qmi_nasi_get_rpm_parameters() */

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_RPM_PARAMETERS_RSP ()

  DESCRIPTION
    Returns result of retrieving Radio Policy Manager details.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_get_rpm_parameters_rsp
(
 qmi_mmodei_msgr_type * msg_p
)
{
  qmi_cmd_buf_type *cmd_buf_p = qmi_nasi_global.rpm_parameters_cmd_buf_p;
  dsm_item_type *  response = NULL;
  nas_get_rpm_parameters_resp_msg_v01 *rsp_msg;

  qmi_nasi_global.rpm_parameters_cmd_buf_p = NULL;

  if(cmd_buf_p == NULL)
  {
    QM_MSG_ERROR("Cant find client for QMI_NASI_GET_RPM_PARAMETERS resp");
    return;
  }
  
  rsp_msg = (nas_get_rpm_parameters_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_rpm_parameters_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    /*Not enough memory to allocate for QMI_NASI_GET_RPM_PARAMETERS resp*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return;
  }
  
  memset (rsp_msg, 0x00, sizeof(nas_get_rpm_parameters_resp_msg_v01));

  if(msg_p->cmd.qmi_nas.get_rpm_parameters_resp.rpm_rsp_ret_val == CM_RPM_SUCCESS_RPM_ENABLED)
  {
    if (msg_p->cmd.qmi_nas.get_rpm_parameters_resp.lte_rpm_params.max_event_counter < 1 || msg_p->cmd.qmi_nas.get_rpm_parameters_resp.lte_rpm_params.max_event_counter > 16)
	{
      QM_MSG_ERROR_1("received invalid max_event_counter value (must be a value between 1 and 16): %d", msg_p->cmd.qmi_nas.get_rpm_parameters_resp.lte_rpm_params.max_event_counter);
	  rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
      rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
	}
    else if (msg_p->cmd.qmi_nas.get_rpm_parameters_resp.lte_rpm_params.max_event_timer > 360)
	{
      QM_MSG_ERROR_1("received invalid max_event_timer value (must be a value between 1 and 360 seconds): %d", msg_p->cmd.qmi_nas.get_rpm_parameters_resp.lte_rpm_params.max_event_timer);
	  rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
      rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
	}
	else
	{
      rsp_msg->max_event_counter_valid= TRUE;
      rsp_msg->max_event_counter = msg_p->cmd.qmi_nas.get_rpm_parameters_resp.lte_rpm_params.max_event_counter;
      rsp_msg->max_event_time_valid = TRUE;
      rsp_msg->max_event_time = msg_p->cmd.qmi_nas.get_rpm_parameters_resp.lte_rpm_params.max_event_timer;
          rsp_msg->rpm_state_valid = TRUE;
          rsp_msg->rpm_state = TRUE;
          rsp_msg->resp.error  = QMI_ERR_NONE_V01;
          rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
	}
  }
  else
  {
    QM_MSG_HIGH("radio policy manager not enabled");
    rsp_msg->rpm_state_valid = TRUE;
    rsp_msg->rpm_state = FALSE;
    rsp_msg->resp.error  = QMI_ERR_NONE_V01;
    rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
  }
  
  if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                            QMI_IDL_RESPONSE,
                                            (uint16_t) QMI_NAS_GET_RPM_PARAMETERS_RESP_MSG_V01,
                                            (void *) rsp_msg,
                                            (uint32_t) sizeof( nas_get_rpm_parameters_resp_msg_v01 ),
                                            &response
                                           ) )
  {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
        /*Unable to send QMI_NASI_GET_RPM_PARAMETERS response*/
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }
  
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

} /* qmi_nasi_generate_get_rpm_parameters_rsp() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_RPM_STATE ()

  DESCRIPTION
    Enables or disables Radio Policy Manager

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_rpm_state
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
  
  cm_mm_set_rpm_config_req_s_type msg;
  errno_enum_type      msgr_err;
  
  nas_set_rpm_state_req_msg_v01  *req_msg;
  nas_set_rpm_state_resp_msg_v01 *rsp_msg;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg  = (nas_set_rpm_state_req_msg_v01  *) modem_mem_alloc( sizeof( nas_set_rpm_state_req_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_rpm_state_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_rpm_state_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_STATE request*/
    QM_MSG_ERROR("Not enough memory to allocate");
    return response;
  }
  else if(rsp_msg == NULL)
  {
    modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE );
    /*Not enough memory to allocate for QMI_NASI_SET_RPM_STATE response*/
    return response;
  }
  
  memset(req_msg, 0, sizeof(nas_set_rpm_state_req_msg_v01));
  memset(rsp_msg, 0, sizeof(nas_set_rpm_state_resp_msg_v01));
  
  if(errval == QMI_ERR_NONE)
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                         sdu_in,
                                         (void *)req_msg,
                                         (uint32_t)sizeof(nas_set_rpm_state_req_msg_v01)
                                       );
    if (errval != QMI_ERR_NONE)
      QM_MSG_ERROR_1("Not able to parse QMI_NASI_SET_RPM_STATE request: %d", errval);
  }
  
  if(errval == QMI_ERR_NONE)
  {
    QM_MSG_HIGH_1("QMI_NASI_SET_RPM_STATE request - %d", req_msg->rpm_state);
  
    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, MM_CM_SET_RPM_CONFIG_REQ);
	
    msg.lte_rpm_config = req_msg->rpm_state;
  }
  
  if(errval == QMI_ERR_NONE)
  {
    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
	
    if ( msgr_err != E_SUCCESS )
    {
      QM_MSG_ERROR_1("QMI_NASI_SET_RPM_STATE send fail %d", msgr_err);
      errval = QMI_ERR_INTERNAL;
    }
  }
  
  rsp_msg->resp.error  = (qmi_error_type_v01)errval;
  rsp_msg->resp.result = errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

  qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
							    QMI_IDL_RESPONSE,
							    (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
							    (void *) rsp_msg,
							    (uint32_t) sizeof(nas_set_rpm_state_resp_msg_v01),
							    &response
							  );
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  return response;
  
} /* qmi_nasi_set_rpm_state() */

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_GET_CSP_PLMN_MODE_BIT_RESP()

  DESCRIPTION
    Send response for QMI_NAS_GET_CSP_PLMN_MODE_BIT 

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

void qmi_nasi_generate_get_csp_plmn_mode_bit_resp( void )
{
  dsm_item_type *             response = NULL;
  boolean                     retval = FALSE;
  qmi_result_e_type           result;
  qmi_error_e_type            errval   = QMI_ERR_NONE;
  struct nas_003B_rsp_s msg;

  qmi_cmd_buf_type              *cmd_buf_p = qmi_nasi_global.mmgsdi.csp_req_buffer;
  qmi_nas_mmgsdi_session_e_type qmi_session = qmi_nasi_global.mmgsdi.csp_req_buffer_session;

  ASSERT(cmd_buf_p);
  if(qmi_session < QMI_NAS_MMGSDI_SESSION_MIN || qmi_session > QMI_NAS_MMGSDI_SESSION_MAX)
  {
    QM_MSG_ERROR_1("invalid qmi session %d", qmi_session);
    ASSERT(FALSE);
  }

  if ( cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in QMI_NAS_GET_CSP_PLMN_MODE_BIT resp: %d", cmd_buf_p);
    qmi_nasi_global.mmgsdi.csp_req_buffer_valid = FALSE;
    qmi_nasi_global.mmgsdi.csp_req_buffer = NULL;
    return; //nothing to send
  }

  memset (&msg, 0x00, sizeof(msg));

  if ( errval == QMI_ERR_NONE )
  {
    if(!qmi_nasi_get_csp_plmn_mode_val( qmi_session, &errval, &msg.t10.plmn_mode ))
    {
      QM_MSG_ERROR("EF not ready for read");
      errval = QMI_ERR_INTERNAL;
    }
  }

  // pack response message

  if ( errval == QMI_ERR_NONE )
  {
    msg.t10_valid = TRUE;
    if ( !qmi_svc_put_param_tlv( &response, NAS_003B_RSP_T10, sizeof(msg.t10.plmn_mode), &msg.t10.plmn_mode ) )
    {
      QM_MSG_ERROR("error while packaging response");
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }

  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS : QMI_RESULT_FAILURE);

  if ((errval != QMI_ERR_NONE) && (response != NULL))
  {
    dsm_free_packet(&response);
  }
  retval = qmi_svc_put_result_tlv(&response, result, errval);
  if (FALSE == retval) 
  { 
    dsm_free_packet(&response);
  }
  else 
  {
    qmi_nas_clnt_send_response(cmd_buf_p, response);
	/*Send QMI_NAS_GET_CSP_PLMN_MODE_BIT resp result*/
  }

  //Free the cmd_buf_p stored
  qmi_nasi_global.mmgsdi.csp_req_buffer_valid = FALSE;
  qmi_nasi_global.mmgsdi.csp_req_buffer = NULL;
  
} /* qmi_nasi_generate_get_csp_plmn_mode_bit_resp */

/*===========================================================================
  FUNCTION QMI_NASI_GENERATE_MANUAL_SCAN_FAIL_IND()

  DESCRIPTION
    Generate a QMI_NAS_MANUAL_SCAN_FAIL_IND indication message
    
  PARAMETERS
    msg_p  Pointer to MSGR data for ssac params info

  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_generate_manual_scan_fail_ind( sys_modem_as_id_e_type asid )
{
  int                              clid;
  qmi_nasi_client_state_type      *cl_sp;

  if(qm_efs_modem_centric_solution_disabled())
  {
    QM_MSG_HIGH( "Modem centric sol enabled: Sending QMI_NAS_MANUAL_SCAN_FAIL_IND");  
    for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
    {
      cl_sp = qmi_nas_state.client[clid];

      if (  cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED &&
            (cl_sp->report_status.report_manual_scan_fail) &&
             cl_sp->report_status.bound_subs == asid )
      {
        qm_nas_clnt_send_ind( cl_sp->common.clid, QMI_NAS_MANUAL_SCAN_FAIL_IND_MSG_V01, NULL );
      }
    }
  }
  /*Else, NV73671 (Disable Modem Centric solution) is disabled or missing*/
} /* qmi_nasi_generate_manual_scan_fail_ind() */

/*===========================================================================
  FUNCTION QMI_NASI_SET_CELL_LOCK_CONFIG ()

  DESCRIPTION
    Set the cell list to limit the service acquisition.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_cell_lock_config
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type       *response = NULL;
  qmi_error_e_type     errval = QMI_ERR_NONE;
  nas_set_cell_lock_config_resp_msg_v01 *rsp_msg = NULL;
  nas_set_cell_lock_config_req_msg_v01 *req_msg;
  errno_enum_type      msgr_err = E_SUCCESS;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  req_msg = (nas_set_cell_lock_config_req_msg_v01 *) modem_mem_alloc( sizeof(nas_set_cell_lock_config_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_set_cell_lock_config_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_cell_lock_config_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if( req_msg == NULL || rsp_msg == NULL)
  {
    QM_MSG_ERROR("Not enough memory to allocate ");
    errval = QMI_ERR_NO_MEMORY;
  }
  else
  {
    memset(req_msg, 0, sizeof(nas_set_cell_lock_config_req_msg_v01));
    memset(rsp_msg, 0, sizeof(nas_set_cell_lock_config_resp_msg_v01));
  }

  if ( (errval == QMI_ERR_NONE) && qmi_nasi_global.set_cell_lock_config_req_buf_p != NULL )
  {
    QM_MSG_ERROR("Already processing a QMI_NASI_SET_CELL_LOCK_CONFIG request");
    errval = QMI_ERR_DEVICE_NOT_READY;
  }

  if(errval == QMI_ERR_NONE)
  {
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                         (uint16_t)((qmi_cmd_buf_type*)cmd_buf_p)->cmd_type,
                                         sdu_in,
                                         (void *)req_msg,
                                         (uint32_t)sizeof(nas_set_cell_lock_config_req_msg_v01)
                                       );
    if (errval != QMI_ERR_NONE)
    {
      QM_MSG_ERROR_1("Not able to parse QMI_NASI_SET_CELL_LOCK_CONFIG request: %d", errval);
    } 
    else if(req_msg->cell_list_len > LTE_RRC_MAX_NUM_CELL_LOCK)
    {
      QM_MSG_ERROR_2("More cell entries than expected, cell_list_len: %d, max: %d", req_msg->cell_list_len, LTE_RRC_MAX_NUM_CELL_LOCK);
      errval = QMI_ERR_ARG_TOO_LONG;
    }
  }


  if(errval == QMI_ERR_NONE)
  {
    lte_rrc_cell_lock_req_s msg;
    int cell_list_index = 0;

    msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, LTE_RRC_CELL_LOCK_REQ );

    msg.num_cell_id = req_msg->cell_list_len;
    for (cell_list_index = 0; cell_list_index < msg.num_cell_id; cell_list_index++)
    {
      msg.cell_id_list[cell_list_index].phy_cell_id = req_msg->cell_list[cell_list_index].pci;
      msg.cell_id_list[cell_list_index].freq        = req_msg->cell_list[cell_list_index].freq;
    }

    msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );
    QM_MSG_HIGH_1("SET_CELL_LOCK_CONFIG request msgr_err:%d ", msgr_err);
    if ( msgr_err != E_SUCCESS )
    {
      errval = QMI_ERR_INTERNAL;
    }
    else
    {
      qmi_nasi_global.set_cell_lock_config_req_buf_p = cmd_buf_p;
    }
  }
 
  if ( errval == QMI_ERR_NONE )
  {
    response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
  }
  else if(rsp_msg)
  {
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    rsp_msg->resp.error  = (qmi_error_type_v01)errval;

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_set_cell_lock_config_resp_msg_v01),
                                  &response
                                );
  }
  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;  
} /* qmi_nasi_set_cell_lock_config() */


/*===========================================================================
  FUNCTION qmi_nasi_set_cell_lock_config_resp()

  DESCRIPTION
    Returns status of set cell lock config request.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_set_cell_lock_config_resp 
(
  lte_rrc_cell_lock_status_e status
)
{
  qmi_cmd_buf_type *cmd_buf_p = qmi_nasi_global.set_cell_lock_config_req_buf_p;
  dsm_item_type *  response = NULL;
  nas_set_cell_lock_config_resp_msg_v01 *rsp_msg;

  qmi_nasi_global.set_cell_lock_config_req_buf_p = NULL;

  if(cmd_buf_p == NULL)
  {
    QM_MSG_ERROR("Cant find client for QMI_NASI_SET_CELL_LOCK_CONFIG_RESP ");
    return;
  }
  
  rsp_msg = (nas_set_cell_lock_config_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_cell_lock_config_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( rsp_msg == NULL)
  {
    QM_MSG_ERROR("Not enough memory to allocate for QMI_NASI_SET_CELL_LOCK_CONFIG_RESP");
    return;
  }
  
  memset (rsp_msg, 0x00, sizeof(nas_set_cell_lock_config_resp_msg_v01));

  if( status == LTE_RRC_CELL_LOCK_STATUS_SUCCESS)
  {
    rsp_msg->resp.error  = QMI_ERR_NONE_V01;
    rsp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
  }
  else
  {
    rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;
    switch(status)
    {
      case LTE_RRC_CELL_LOCK_STATUS_FAIL_LTE_ACTIVE:
        rsp_msg->resp.error  = QMI_ERR_INCOMPATIBLE_STATE_V01;
        break;
      case LTE_RRC_CELL_LOCK_STATUS_FAIL_OTHER:
      default:
        rsp_msg->resp.error  = QMI_ERR_INTERNAL_V01;
        break;
    }
  }

  if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                            QMI_IDL_RESPONSE,
                                            (uint16_t) QMI_NAS_SET_CELL_LOCK_CONFIG_RESP_MSG_V01,
                                            (void *) rsp_msg,
                                            (uint32_t) sizeof( nas_set_cell_lock_config_resp_msg_v01 ),
                                            &response
                                           ) )
  {
      if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
    {
        QM_MSG_ERROR("Unable to send QMI_NAS_SET_CELL_LOCK_CONFIG_RESP");
        qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
    }
  }
  else
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
  }
  
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

} /* qmi_nasi_set_cell_lock_config_resp() */
/*===========================================================================
  FUNCTION QMI_NASI_SET_VOICE_ROAMING_STATUS ()

  DESCRIPTION
    Sets the Voice roaming status of the device. Allows the user to enable or disable the Voice roaming status.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_set_voice_roaming_status 
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

  nas_set_voice_roaming_req_msg_v01  * req_msg = NULL;
  nas_set_voice_roaming_resp_msg_v01 * rsp_msg = NULL;

  enum qmi_nas_subs_e subs = QMI_NAS_SUBS_NONE;

  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);

  subs = ((qmi_nasi_client_state_type*)cl_sp)->report_status.bound_subs;

  req_msg = (nas_set_voice_roaming_req_msg_v01  *) modem_mem_alloc( sizeof(nas_set_voice_roaming_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL)
  {
    qmi_voice_mem_error();
    return NULL;
  }

  if(qmi_nasi_global.voice_roam_temp_valid)
  {
    QM_MSG_ERROR_2("QMI_NAS_SET_DATA_ROAMING response already pending - pending sub %d, curr sub %d", qmi_nasi_global.voice_roam_temp_subs, subs);
    errval = QMI_ERR_DEVICE_IN_USE_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_set_voice_roaming_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_SET_VOICE_ROAMING_REQ_MSG_V01,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_set_voice_roaming_req_msg_v01)
                                         );
  }


  if (errval == QMI_ERR_NONE_V01)
  {

  	cm_set_roaming_pref_param_s_type  roaming_pref;
    QM_MSG_HIGH_2("calling cm_ph_cmd_data_roaming_per_subs() - roam %d subs %d", req_msg->international_voice_roaming_allowed, subs);

    roaming_pref.cmd_type = CM_ROAMING_PREF_CMD_INTERNATIONAL_VOICE;
	roaming_pref.roaming_allowed = req_msg->international_voice_roaming_allowed;
	
    if ( !cm_ph_cmd_set_roaming_pref_per_subs( qmi_nas_cmph_cmd_cb, cmd_buf_p, qmi_nasi_global.cm_clnt_id, roaming_pref, (sys_modem_as_id_e_type)subs ) )
    {
      errval = QMI_ERR_INTERNAL_V01;
      QM_MSG_ERROR("cm_ph_cmd_set_roaming_pref_per_subs() failed");
    }
    else
    {
      qmi_nasi_global.voice_roam_temp = req_msg->international_voice_roaming_allowed;
      qmi_nasi_global.voice_roam_temp_subs = subs;
      qmi_nasi_global.voice_roam_temp_valid = TRUE;
      response = (dsm_item_type*)QMI_SVC_RESPONSE_PENDING;
    }
  }

  // take care of result if error
  if( cmd_buf_p != NULL && errval != QMI_ERR_NONE_V01 )
  {
    rsp_msg = (nas_set_voice_roaming_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_set_voice_roaming_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
    if ( rsp_msg == NULL)
    {
      qmi_voice_mem_error();
      if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
      return NULL;
    }
    else
    {
      memset( rsp_msg, 0x00, sizeof(nas_set_voice_roaming_resp_msg_v01) );

      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = QMI_RESULT_FAILURE_V01;

      QM_MSG_HIGH_1("Set Voice roaming status with error=%d", (uint16)errval);
      qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                    QMI_IDL_RESPONSE,
                                    (uint16_t) QMI_NAS_SET_VOICE_ROAMING_RESP_MSG_V01,
                                    (void *) rsp_msg,
                                    (uint32_t) sizeof(nas_set_voice_roaming_resp_msg_v01),
                                    &response
                                  );
    }
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_set_voice_roaming_status */

/*===========================================================================
  FUNCTION QMI_NASI_SET_VOICE_ROAMING_STATUS_RESP()

  DESCRIPTION
    Send response for SET_VOICE_ROAMING

  PARAMETERS
    user_data   : user data
    ph_cmd_err  : error type

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_set_voice_roaming_status_resp( qmi_cmd_buf_type *p_cmd_buf, cm_ph_cmd_err_e_type err )
{
  dsm_item_type *                         response = NULL;
  qmi_error_type_v01                      errval   = QMI_ERR_NONE_V01;
  boolean                                 retval   = TRUE;
  nas_set_voice_roaming_resp_msg_v01 *resp_msg = NULL;

  qmi_nasi_global.voice_roam_temp_valid = FALSE;
  
  if ( !qmi_nas_validate_cmd_buf_p( p_cmd_buf, &qmi_nas_state ) || !p_cmd_buf || !p_cmd_buf->x_p )
  {
    /*Null cmd_buf ptr*/
    return;
  }

  switch (err)
  {
    case CM_PH_CMD_ERR_NOERR:
      errval = QMI_ERR_NONE_V01;
      break;

    case CM_PH_CMD_ERR_IN_USE_S:
      errval = QMI_ERR_DEVICE_IN_USE_V01;
      break;

    case CM_PH_CMD_ERR_PLMN_P:
      errval = QMI_ERR_NO_NETWORK_FOUND_V01;
      break;

    case CM_PH_CMD_ERR_SYS_SEL_PREF_S:
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
      break;

    case CM_PH_CMD_ERR_API_NOT_SUPPORTED_S:
    case CM_PH_CMD_ERR_PS_LOCAL_DETACH_NOT_ALLOWED_S:
    case CM_PH_CMD_ERR_FUNCTION_NOT_APPLICABLE:
      errval = QMI_ERR_INVALID_OPERATION_V01;
      break;

    default:
      errval = QMI_ERR_INTERNAL_V01;
      break;
  }
  
  if(errval == QMI_ERR_NONE_V01)
  {
    QM_MSG_HIGH_2("QMI_NASI_SET_VOICE_ROAMING_STATUS_RESP successful - subs %d roam %d", 
		           qmi_nasi_global.voice_roam_temp_subs, qmi_nasi_global.voice_roam_temp);
    qmi_nasi_global.voice_roam_cache_valid[qmi_nasi_global.voice_roam_temp_subs] = TRUE;
    qmi_nasi_global.voice_roam_cache[qmi_nasi_global.voice_roam_temp_subs] = qmi_nasi_global.voice_roam_temp;
  }

  resp_msg = (nas_set_voice_roaming_resp_msg_v01 *) modem_mem_alloc( sizeof( nas_set_voice_roaming_resp_msg_v01 ), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( resp_msg != NULL )
  {
    memset(resp_msg, 0, sizeof(nas_set_voice_roaming_resp_msg_v01) );

    resp_msg->resp.error  = errval;
    if(errval == QMI_ERR_NONE_V01)
    {
      resp_msg->resp.result = QMI_RESULT_SUCCESS_V01;
	  resp_msg->resp.error = errval;
    }
    else
    {
      resp_msg->resp.result = QMI_RESULT_FAILURE_V01;
	  resp_msg->resp.error = errval;
    }

    retval = qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                           QMI_IDL_RESPONSE,
                                           (uint16_t)((qmi_cmd_buf_type*)p_cmd_buf)->cmd_type,
                                           (void *)resp_msg,
                                           (uint32_t)sizeof(nas_set_voice_roaming_resp_msg_v01),
                                           &response
                                         );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( !retval )
  {
    dsm_free_packet(&response);
    qmi_mmode_svc_free_transaction_cmd_buf( &p_cmd_buf );
  }
  else if ( !qmi_nasi_send_response( p_cmd_buf, response ) )
  {
    QM_MSG_MED("QMI_NASI_SET_VOICE_ROAMING_STATUS_RESP send failed");
  }
  
  if ( resp_msg != NULL ) { modem_mem_free( (void *) resp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
} /* qmi_nasi_set_voice_roaming_status_resp */

/*===========================================================================
  FUNCTION QMI_NASI_GET_VOICE_ROAMING_STATUS ()

  DESCRIPTION
    This API lets the user query for the Current voice roaming status.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_get_voice_roaming_status 
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp, 
  dsm_item_type **  sdu_in
)
{
  dsm_item_type     *response = NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;

  nas_get_voice_roaming_req_msg_v01  * req_msg = NULL;
  nas_get_voice_roaming_resp_msg_v01 * rsp_msg = NULL;
  
  enum qmi_nas_subs_e subs = QMI_NAS_SUBS_NONE;
  
  ASSERT(sp);
  ASSERT(cmd_buf_p);
  ASSERT(cl_sp);
  ASSERT(sdu_in);
  
  subs = ((qmi_nasi_client_state_type*)cl_sp)->report_status.bound_subs;

  if ((subs <= QMI_NAS_SUBS_NONE) || (subs >= QMI_NAS_SUBS_MAX))
  {
    QM_MSG_ERROR_1("qmi_nasi_get_voice_roaming_status: unsupported subs %d", subs);
    return NULL;
  }

  req_msg = (nas_get_voice_roaming_req_msg_v01  *) modem_mem_alloc( sizeof(nas_get_voice_roaming_req_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );
  rsp_msg = (nas_get_voice_roaming_resp_msg_v01 *) modem_mem_alloc( sizeof(nas_get_voice_roaming_resp_msg_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( req_msg == NULL || rsp_msg == NULL )
  {
    qmi_voice_mem_error();
    if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
    if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
    return NULL;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset ( req_msg, 0x00, sizeof(nas_get_voice_roaming_req_msg_v01) );

    // extract information from REQ message
    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t)QMI_NAS_GET_VOICE_ROAMING_REQ_MSG_V01,
                                           sdu_in,
                                           (void *) req_msg,
                                           (uint32_t) sizeof(nas_get_voice_roaming_req_msg_v01)
                                         );
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    if(!qmi_nasi_global.voice_roam_cache_valid[subs])
    {
      errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
      QM_MSG_ERROR_1("voice_roam_cache not initialized for subs %d", subs);
    }
  }

  // take care of result
  if( cmd_buf_p != NULL )
  {
    memset( rsp_msg, 0x00, sizeof(nas_get_voice_roaming_resp_msg_v01) );

    rsp_msg->resp.error  = errval;
    rsp_msg->resp.result = errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    if(rsp_msg->resp.error == QMI_ERR_NONE_V01)
    {
      rsp_msg->international_voice_roaming_allowed_valid = TRUE;
      rsp_msg->international_voice_roaming_allowed = qmi_nasi_global.voice_roam_cache[subs];
    }

    QM_MSG_HIGH_3("Get Voice roaming status with error=%d, voice roam status=%d subs=%d", (uint16)errval,
		          (uint32)qmi_nasi_global.voice_roam_cache[subs], subs);
    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t)QMI_NAS_GET_VOICE_ROAMING_RESP_MSG_V01,
                                  (void *) rsp_msg,
                                  (uint32_t) sizeof(nas_get_voice_roaming_resp_msg_v01),
                                  &response
                                );
  }

  if ( req_msg != NULL ) { modem_mem_free( (void *) req_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }
  if ( rsp_msg != NULL ) { modem_mem_free( (void *) rsp_msg, MODEM_MEM_CLIENT_QMI_MMODE ); }

  return response;
} /* qmi_nasi_get_voice_roaming_status */
/*===========================================================================
  FUNCTION QMI_NASI_GCELL_INFO_IND()

  DESCRIPTION
    Generates and sends the GERAN Cell Information.

  PARAMETERS
    None

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_nasi_gcell_info_ind
(
	geran_grr_qmi_cell_info_ind_t *gcell_info_ind
)
{
  int                              clid;
  qmi_nasi_client_state_type      *cl_sp;
  nas_gcell_info_ind_v01          *ind_msg;
  dsm_item_type                   *ind = NULL;
  sys_modem_as_id_e_type           asid = SYS_MODEM_AS_ID_1;
  ind_msg = (nas_gcell_info_ind_v01 *) modem_mem_alloc( sizeof(nas_gcell_info_ind_v01), MODEM_MEM_CLIENT_QMI_MMODE );

  if ( gcell_info_ind != NULL && ind_msg!= NULL)
  {
      memset( ind_msg, 0x00, sizeof(nas_gcell_info_ind_v01) );
	
      memscpy(&ind_msg->uid_camped_cell,sizeof(gcell_info_ind->uid_camped_cell),&gcell_info_ind->uid_camped_cell,sizeof(gcell_info_ind->uid_camped_cell));


      //TLV 0x10
	  ind_msg->broadcast_si_mask_valid       = gcell_info_ind->si_mask_valid;
          if(ind_msg->broadcast_si_mask_valid){
	  ind_msg->broadcast_si_mask	         = (uint16)gcell_info_ind->broadcast_si_mask;}

	  ind_msg->si1_cell_allocation_valid	= TRUE;
	  ind_msg->si1_cell_allocation_len	= (uint8)gcell_info_ind->si1_ca_length;
	  memscpy(&ind_msg->si1_cell_allocation,sizeof(gcell_info_ind->si1_cell_allocation),&gcell_info_ind->si1_cell_allocation,sizeof(gcell_info_ind->si1_cell_allocation));
	  
	  ind_msg->ra_color_valid		= TRUE;
	  ind_msg->ra_color			= (uint8)gcell_info_ind->ra_color;

	  ind_msg->reselection_offset_valid	= TRUE;
	  ind_msg->reselection_offset		= (uint8)gcell_info_ind->reselection_offset;

      ind_msg->t3212_valid			= TRUE;
	  ind_msg->t3212			= (uint8)gcell_info_ind->t3212;

	  ind_msg->rx_lev_min_valid		= TRUE;
	  ind_msg->rx_lev_min			= (uint8)gcell_info_ind->rx_lev_min;
      
	  ind_msg->si13_position_valid		= TRUE;
	  ind_msg->si13_position		= (uint8)gcell_info_ind->si13_position;

	  ind_msg->MSCR_valid			= TRUE;
	  ind_msg->MSCR				= (uint8)gcell_info_ind->MSCR;

	  ind_msg->mandatory_si_status_valid	= TRUE;
	  ind_msg->mandatory_si_status		= gcell_info_ind->mandatory_si_status;

	  asid = INST_ID_TO_SYS_AS_ID(gcell_info_ind->hdr.inst_id);
      for ( clid=0; clid<NASI_MAX_CLIDS; clid++ )
      {
        cl_sp = qmi_nas_state.client[clid];

        if (  cl_sp && cl_sp->common.clid != QMI_SVC_CLID_UNUSED && 
	      cl_sp->report_status.bound_subs == asid &&
              cl_sp->report_status.report_gcell_info_ind )
        {
          ind = NULL;
          if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj, 
                                                    QMI_IDL_INDICATION, 
                                                    (uint16_t)QMI_NAS_GCELL_INFO_IND_V01, 
                                                    (void *) ind_msg,
                                                    (uint16_t)sizeof(nas_gcell_info_ind_v01), 
                                                    &ind ) )
          {
            qm_nas_clnt_send_ind( cl_sp->common.clid,QMI_NAS_GCELL_INFO_IND_V01, ind );
          }
        }
      }
    modem_mem_free((void *)ind_msg,  MODEM_MEM_CLIENT_QMI_MMODE);
  }
  else
  {
    qmi_voice_mem_error();
  }
}/* qmi_nasi_gcell_info_ind() */

/*===========================================================================
  FUNCTION QMI_NASI_GCELL_INFO_REQ()

  DESCRIPTION
    Request to GR to get information about current camped GERAN Cell

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_gcell_info_req
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type               *response = NULL;
  qmi_error_type_v01           errval    = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err = 1;
  sys_modem_as_id_e_type asubs_id = SYS_MODEM_AS_ID_1;
  nas_gcell_info_resp_msg_v01 *nas_gcell_info_resp;


  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  if ( qmi_nasi_global.gcell_info_cmd_buf_p == NULL )
  {
    qmi_nasi_global.gcell_info_cmd_buf_p = cmd_buf_p;
  }
  else
  {
    errval = QMI_ERR_DEVICE_NOT_READY_V01;
    QM_MSG_MED("Already an instance of GERAN Cell Info Req in cmd_buf");
  }


  if ( errval == QMI_ERR_NONE_V01 )
  {
  // Assigning asub_id
     #ifdef FEATURE_DUAL_SIM
     if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
     {
       asubs_id = SYS_MODEM_AS_ID_2;
     }
     #ifdef FEATURE_TRIPLE_SIM
     else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
     {
       asubs_id = SYS_MODEM_AS_ID_3;
     }
     #endif//FEATURE_TRIPLE_SIM
     #endif//FEATURE_DUAL_SIM

     QM_MSG_MED_1("Gcell Info Request for SUB: %d",asubs_id);

      geran_grr_qmi_cell_info_req_t msg;
      memset(&msg, 0x00, sizeof(geran_grr_qmi_cell_info_req_t) );
      msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, GERAN_GRR_QMI_CELL_INFO_REQ );
      msgr_init_hdr_inst( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, GERAN_GRR_QMI_CELL_INFO_REQ, SYS_AS_ID_TO_INST_ID(asubs_id));
      msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR_1(" GERAN Cell Info Req send fail %d", msgr_err);
      }
   }
  if ( errval == QMI_ERR_NONE_V01 )
  {
    return QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
	   nas_gcell_info_resp = (nas_gcell_info_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof(nas_gcell_info_resp_msg_v01) );
		if ( (nas_gcell_info_resp != NULL )  && (cmd_buf_p != NULL) )
		{
			memset( nas_gcell_info_resp, 0x00, sizeof( nas_gcell_info_resp_msg_v01 ) );

			nas_gcell_info_resp->resp.error  = errval;
			nas_gcell_info_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

			qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  QMI_NAS_GCELL_INFO_RESP_V01,
                                  (void *) nas_gcell_info_resp,
                                  (uint32_t) sizeof( nas_gcell_info_resp_msg_v01 ),
                                  &response);
		}
		else
		{
			qmi_voice_mem_error();
		}
  if ( nas_gcell_info_resp != NULL ) { QMI_NAS_MEM_FREE( (void *) nas_gcell_info_resp ); }
  return response;
 }
}/*qmi_nasi_gcell_info_req()*/

/*===========================================================================
  FUNCTION QMI_NAS_GENERATE_GCELL_INFO_RESP()

  DESCRIPTION


  PARAMETERS
    geran_grr_qmi_cell_info_rsp_t  Response from GERAN GRR

  RETURN VALUE
    

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_nasi_generate_gcell_info_resp
(
  geran_grr_qmi_cell_info_rsp_t  *geran_cell_info_rsp
)
 {
  dsm_item_type                        *response = NULL;
  qmi_error_type_v01                    errval = QMI_ERR_NONE_V01;
  nas_gcell_info_resp_msg_v01          *rsp_msg = NULL;
  qmi_cmd_buf_type                     *cmd_buf_p = qmi_nasi_global.gcell_info_cmd_buf_p;

  if ( cmd_buf_p == NULL || cmd_buf_p->x_p == NULL )
  {
    QM_MSG_ERROR_1("Received NULL cmd_buf in GCELL INFO resp: %d", cmd_buf_p);
    qmi_nasi_global.gcell_info_cmd_buf_p = NULL;
    return; //nothing to send
  }

  if ( geran_cell_info_rsp != NULL )
  {
    QM_MSG_HIGH_1("Recieved RSP for GERAN Cell Information for SUB %d",INST_ID_TO_SYS_AS_ID(geran_cell_info_rsp->hdr.inst_id));
    rsp_msg= (nas_gcell_info_resp_msg_v01 *) QMI_NAS_MEM_ALLOC( sizeof( nas_gcell_info_resp_msg_v01 ) );

    if ( rsp_msg != NULL )
    {
      memset( rsp_msg, 0x00, sizeof( nas_gcell_info_resp_msg_v01 ) );


      memscpy(&rsp_msg->uid_camped_cell,sizeof(geran_cell_info_rsp->uid_camped_cell),&geran_cell_info_rsp->uid_camped_cell,sizeof(geran_cell_info_rsp->uid_camped_cell));

      //TLV 0x10
	  rsp_msg->broadcast_si_mask_valid		= geran_cell_info_rsp->si_mask_valid;
          if(rsp_msg->broadcast_si_mask_valid){
	  rsp_msg->broadcast_si_mask	                = (uint16)geran_cell_info_rsp->broadcast_si_mask;}


      //TLV 0x11
	  rsp_msg->si1_cell_allocation_valid	= TRUE;
	  rsp_msg->si1_cell_allocation_len	= (uint8)geran_cell_info_rsp->si1_ca_length;
	  memscpy(&rsp_msg->si1_cell_allocation,sizeof(geran_cell_info_rsp->si1_cell_allocation),&geran_cell_info_rsp->si1_cell_allocation,sizeof(geran_cell_info_rsp->si1_cell_allocation));

      //TLV 0x12
	  rsp_msg->ra_color_valid		= TRUE;
	  rsp_msg->ra_color			= (uint8)geran_cell_info_rsp->ra_color;

      //TLV 0x13
	  rsp_msg->reselection_offset_valid	= TRUE;
	  rsp_msg->reselection_offset		= (uint8)geran_cell_info_rsp->reselection_offset;

      //TLV 0x14
      rsp_msg->t3212_valid			= TRUE;
	  rsp_msg->t3212			= (uint8)geran_cell_info_rsp->t3212;

      //TLV 0x15
	  rsp_msg->rx_lev_min_valid		= TRUE;
	  rsp_msg->rx_lev_min			= (uint8)geran_cell_info_rsp->rx_lev_min;
      
      //TLV 0x16
	  rsp_msg->si13_position_valid		= TRUE;
	  rsp_msg->si13_position		= (uint8)geran_cell_info_rsp->si13_position;

      //TLV 0x17
	  rsp_msg->MSCR_valid			= TRUE;
	  rsp_msg->MSCR				= (uint8)geran_cell_info_rsp->MSCR;

      //TLV 0x18
	  rsp_msg->mandatory_si_status_valid	= TRUE;
	  rsp_msg->mandatory_si_status		= geran_cell_info_rsp->mandatory_si_status;
      
      rsp_msg->resp.error  = errval;
      rsp_msg->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

      if( TRUE == qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                                QMI_IDL_RESPONSE,
                                                (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                                (void *) rsp_msg,
                                                (uint32_t) sizeof( nas_gcell_info_resp_msg_v01 ),
                                                &response
                                              ) )
      {
        if( FALSE == qmi_nasi_send_response( cmd_buf_p, response ) )
        {
          QM_MSG_MED("Unable to send GERAN Cell Info response");
          qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
        }
      }
    }
    else
    {
      qmi_voice_mem_error();
      qmi_mmode_svc_free_transaction_cmd_buf( &cmd_buf_p );
    }
  }
  if ( rsp_msg != NULL ) { QMI_NAS_MEM_FREE( (void *) rsp_msg ); }
  qmi_nasi_global.gcell_info_cmd_buf_p = NULL;
}


 /*===========================================================================
  FUNCTION QMI_NASI_BAR_GCELL_REQ()

  DESCRIPTION

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_nasi_bar_gcell_req
(
  void *           sp,
  void *           cmd_buf_p,
  void *           cl_sp,
  dsm_item_type ** sdu_in
)
{
  dsm_item_type               *response = NULL;
  qmi_error_type_v01           errval    = QMI_ERR_NONE_V01;
  errno_enum_type              msgr_err;
  sys_modem_as_id_e_type asubs_id = SYS_MODEM_AS_ID_1;
  nas_bar_gcell_req_v01  *nas_bar_gcell_req;
  nas_bar_gcell_resp_v01 *nas_bar_gcell_resp;

  if ( !sp || !cmd_buf_p || !cl_sp || !sdu_in )
  {
    QM_MSG_ERROR_4("null ptr %d %d %d %d", sp, cmd_buf_p, cl_sp, sdu_in);
    errval = QMI_ERR_INTERNAL_V01;
  }

  nas_bar_gcell_req  = (nas_bar_gcell_req_v01 *) QMI_NAS_MEM_ALLOC( sizeof(nas_bar_gcell_req_v01) );
  nas_bar_gcell_resp = (nas_bar_gcell_resp_v01 *) QMI_NAS_MEM_ALLOC( sizeof(nas_bar_gcell_resp_v01) );

  if ( nas_bar_gcell_req == NULL )
  {
    qmi_voice_mem_error();
    errval = QMI_ERR_NO_MEMORY_V01;
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
    memset( nas_bar_gcell_req, 0x00, sizeof( nas_bar_gcell_req_v01 ) );

    errval = qmi_mmode_idl_message_decode( qmi_nasi_global.svc_obj,
                                           (uint16_t) ((qmi_cmd_buf_type*) cmd_buf_p)->cmd_type,
                                           sdu_in,
                                           (void *) nas_bar_gcell_req,
                                           (uint32_t) sizeof( nas_bar_gcell_req_v01 )
                                         );
  }

  if ( errval == QMI_ERR_NONE_V01 )
  {
     #ifdef FEATURE_DUAL_SIM
     if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_SECONDARY )
     {
         asubs_id = SYS_MODEM_AS_ID_2;
     }
     #ifdef FEATURE_TRIPLE_SIM
     else if ( ((qmi_nasi_client_state_type *)cl_sp)->report_status.bound_subs == QMI_NAS_SUBS_TERTIARY )
     {
          asubs_id = SYS_MODEM_AS_ID_3;
     }
     #endif//FEATURE_TRIPLE_SIM
     #endif//FEATURE_DUAL_SIM

      QM_MSG_MED_1("Gcell Bar Request for SUB: %d",asubs_id);

      geran_grr_fake_gcell_action_req_t msg;
      memset(&msg, 0x00, sizeof(geran_grr_fake_gcell_action_req_t) );
      msgr_init_hdr( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, GERAN_GRR_FAKE_GCELL_ACTION_REQ );
      msgr_init_hdr_inst( (msgr_hdr_struct_type*)&msg, MSGR_QMI_NAS, GERAN_GRR_FAKE_GCELL_ACTION_REQ, SYS_AS_ID_TO_INST_ID(asubs_id));
      msg.arfcn = nas_bar_gcell_req->uid_camped_cell.arfcn;
      msg.bsic = nas_bar_gcell_req->uid_camped_cell.bsic;
      msg.barred_time = nas_bar_gcell_req->bar_time;
      memscpy(&msg.plmn_id,sizeof(nas_bar_gcell_req->uid_camped_cell.plmn_id),&nas_bar_gcell_req->uid_camped_cell.plmn_id,sizeof(nas_bar_gcell_req->uid_camped_cell.plmn_id));
      msg.cell_id = nas_bar_gcell_req->uid_camped_cell.cell_id;
      msg.location_area_code = nas_bar_gcell_req->uid_camped_cell.location_area_code;
      msgr_err = msgr_send( (msgr_hdr_struct_type*)&msg, sizeof(msg) );

      if ( msgr_err != E_SUCCESS )
      {
        errval = QMI_ERR_INTERNAL_V01;
        QM_MSG_ERROR_1("Bar GERAN CELL Req send fail %d", msgr_err);
      }
    }

  if ( (nas_bar_gcell_resp != NULL )  && (cmd_buf_p != NULL) )
  {
    memset( nas_bar_gcell_resp, 0x00, sizeof( nas_bar_gcell_resp_v01 ) );

    nas_bar_gcell_resp->resp.error  = errval;
    nas_bar_gcell_resp->resp.result = ( errval == QMI_ERR_NONE_V01 ? QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01 );

    qmi_mmode_idl_message_encode( qmi_nasi_global.svc_obj,
                                  QMI_IDL_RESPONSE,
                                  (uint16_t) ( (qmi_cmd_buf_type*) cmd_buf_p )->cmd_type,
                                  (void *) nas_bar_gcell_resp,
                                  (uint32_t) sizeof( nas_bar_gcell_resp_v01 ),
                                  &response
                                );
  }
  else
  {
    qmi_voice_mem_error();
  }

  if ( nas_bar_gcell_req  != NULL ) { QMI_NAS_MEM_FREE( (void *) nas_bar_gcell_req ); }
  if ( nas_bar_gcell_resp != NULL ) { QMI_NAS_MEM_FREE( (void *) nas_bar_gcell_resp ); }

  return response;
}/*qmi_nasi_bar_gcell_req*/