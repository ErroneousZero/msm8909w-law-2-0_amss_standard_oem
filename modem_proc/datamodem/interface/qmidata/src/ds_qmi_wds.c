/*===========================================================================

                         D S _ Q M I _ W D S . C

DESCRIPTION

 The Data Services Qualcomm Wireless Data Services MSM Interface source file.

EXTERNALIZED FUNCTIONS

  qmi_wds_init()
    Register the Wireless Data Service with QMUX for all applicable QMI links.

  qmi_wds_pkt_srvc_status_ind()
    Indicates the state of the network connection

  qmi_wds_generate_channel_rate_ind()
    Called when the channel rate changes.

Copyright (c) 2004-2016 Qualcomm Technologies Incorporated.
All Rights Reserved.
Qualcomm Confidential and Proprietary
===========================================================================*/
/*===========================================================================

                      EDIT HISTORY FOR FILE

  $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/datamodem/interface/qmidata/src/ds_qmi_wds.c#1 $
  $DateTime: 2016/12/13 08:00:03 $ $Author: mplcsds1 $

when        who    what, where, why
--------    ---    ---------------------------------------------------------- 
03/25/15    skc    Provided new API to create unique address
11/19/14    skc    Removing unused function wdsi_get_fmc_iface_ptr()
11/18/14    skc    Removing FEATURE_UW_FMC
10/21/14    sk     QMI-DMS Service QCSI migration.
09/11/14    tk     Fixed compilation errors in LTE compile out flavor.
07/23/14    sah    Fixed compilation errors for 1x compiled out build flavor.
06/30/14    ss     New event added: IFACE_EXTENDED_IP_CONFIG_EX_EV
05/28/14    wc     Fixed wds unbind race condtion
04/09/14    gk     Fixed wdsi_get_data_bearer_tech to have more valid RATs and decoupled 
                   latest messages from its dependancy
04/09/14    ash    Added Prefix Delegation support.
03/25/14    sah    Fixed issue with QMI_WDS_CONTROL_PENDING_DUN_CALL_MSG.
03/10/14    vrk    CM SS events handling for SGLTE+G CM redesign
02/28/14    wc     Support $QCRMCALL
02/25/14    vrk    Fix for no response on WDSI_DUN_CTRL_EVENT_SILENT_REDIAL event
02/13/14    vrk    Corrected to send get_runtime_settings failure response on V6 Error
01/17/14    wc     Support same default EP id for two different control channels
11/01/13    rk     Removed feature mobileap.
09/27/13    wc     Support dynamic port configuration
08/02/13    sah    Fix to fetch tx and rx ok bytes stats in DUN call info.
06/17/13    ms     Fixed compiler warnings.
06/03/13    sd     ATCoP decoupling changes
03/29/13    svj    New APIs to modify and query attach pdn list 
01/05/13    svj    Addr family TLV addition to get_last_data_call_status msg 
01/28/13    svj    New TLV added to extended_ip_config indication message
01/02/13    svj    Fix for crash due to toggling enable/disable auconnect in the 
                   start/stop network interface requests 
12/10/12    sn     Support PDN sharing over single rmnet 
12/04/12    rev    Fixed Kw errors.
12/03/12    wc     Support QMI_WDS_BIND_DATA_PORT
11/16/12    svj    Added support for Operator Reserved Protocol Information 
10/31/12    ssb    Dun Call Entitlement support using PS_SYS Interface
10/31/12    wc     Migrate to new framework. Memory optimization
10/16/12    svj    Fix for wds_get_pdn_throttle_info_req_msg crash on invalid tech types 
10/16/12    sb     Fix for crash due to misaligned address
09/10/12    sb     Added Len checks for QMI TLVs
09/06/12    pgm    Support for different APNS in Dual-IP.
08/10/12    ab     Added support for TDSCDMA| HSUPA for QMI
08/13/12    wc     eMBMS phase III
08/06/12    gk     Added support for QMI service to log what messages/TLVs  
                   are supported on this branch.
07/31/12    sb     Fixed KW Errors.
06/27/12    wc     Fix wrong PBM record
06/06/12    sb     Fix to gracefully handle attempts to connect on more than 5 pdn's.
05/14/12    sb     Fixed KW Warnings.
04/30/12    sa     Added support for WARNING tlv in TMGI list ind.
04/15/12    wc     Check client release before generating pkt_stats indication
03/14/12    wc     Always send data call status indication
03/09/12    sj     Remove references to CNE-DSD and deduce preferred_data_system 
                   from data system status 
02/28/12    sj     Add support for TDSCDMA  
03/09/12    wc     Add FMC support
03/09/12    wc     Add pkt dropped count statistics and reset message
03/01/12    sa     Changes for Set/Get autoconnect and updating efs.
03/01/12    kk     Fix to clean up RmNet and WDS states coherently.
02/21/12    wc     mainline eMBMS
02/07/12    sj     Generate channel_rate ind after call disconnect
02/10/12    rt     Added support for SoftAPv6
02/08/12    vs     Added support for 3GPP IPv6 over PPP
02/09/12    am     Moved all softap messages to QCMAP.
01/20/12    wc     Added QMI_WDS_GET_LTE_ATTACH_PARAMS
12/27/11    wc     De-featurize FEATURE_DATA_FUSION_PS_ARBITRATION_MGR
11/07/11    wc     Add get_preferred_data_system/get_last_data_call_status
11/01/11    am     NAT data path changes for split arch.
10/04/11    sa     Q6 free floating changes for QMI.
09/19/11    wc     Clear v6 guard timer and save the addr in UM DB if queried.
07/14/11    sj     Check UIM status and PIN1 related status before proceeding 
                   with MIP related functions. 
07/26/11    ua     Fixed Data Call status indication for Tethered calls.
07/18/11    sa     Fix to avoid memory mis-alignment of the structure in DCC.
07/11/11    kk     Added support for data_call_type TLV in data_call_status
                   indication. 
06/21/11    kk     Added support for DUN entitlement and silent redial control.
06/15/11    sa     Fixed compiler warning.
06/10/11    sa     Verifying the ext tech pref values with all possible values.. 
06/03/11    wc     Fixed wrong IPv6 gateway address in qmi_wds_get_runtime_settings
05/25/11    wc     Support persistent/non-persistent profile creation
05/05/11    sa     Fix to send Invalid arg error in case of wrong extended
                   technology preference.
04/21/11    sa     Fix to send correct TYPE in respnse pkt when PCSCF server
                   count is zero.
04/12/11    kk     Fix to send proper error message for malformed profile
                   create/modify requests.
03/18/11    kk     Fix to allow APN override on non-default profiles.
03/13/11    nl     Added reserved values to QMI commands.
02/10/11    kk     Added support for APN string in ROUTE_LOOK_UP.
01/07/11    cp     Fix to get the mtu value from the base Iface.
12/22/10    asn    Allow QMI data call status ind for EPC Iface up/dn events
12/17/10    kk     Added log messages before ASSERTs.
12/17/10    kk     Removing DCC command buffer dependency from QMI services.
12/06/10    asn    Correct TLV IDs for REQ and IND
09/13/10    kk     Fix to allow IPv6 PCSCF addresses in GET_RUNTIME_SETTINGS.
07/15/10    asn    Support for Arbitration - round II
07/09/10    asn    Support for Arbitration
06/19/10    vs     Changes for Dual IP support over single QMI instance
06/30/09    pp     Renamed s6_addr w/ ps_s6_addr in all occurrences.
06/24/09    am     Renamed hton/ntoh macros with ps_ prefix.
04/14/09    rt     Added new error codes.
02/19/09    am     DS Task De-coupling effort and introduction of DCC task.
05/01/08    mct    Added TLVs to support IPv6/MIPv6.
10/20/07    ks     Added PCSCF Server and FQDN query.
10/01/07    mct    Added support for IPv6 RmNet.
06/05/07    ks     Added qmi_wds_set_call_status_handler() to register cback
                   fn to be called when call comes up or is torn down.
05/28/07    ks     Added support for runtime_settings api
12/1/06     ks     now supporting specific auth preference for pap and chap.
09/21/06    ks     Unbind all clients for a particular wds instance when the
                   call ends and corresponding iface goes to DOWN state.
09/05/06    ks     Added auth override support for cdma targets.
09/05/06    ks     Fixed issues in previous go_active go_dormant checkin.
09/02/06    jd     Added WDS_GO_ACTIVE and WDS_GO_DORMANT for AST builds only
08/23/06    ks     Changes to support multiple qmi/rmnet instances.
07/20/06    ks     Added support for WDS Abort request.
07/06/06    ks     Clean up.
04/18/06    ks     Made profile_list a mandatory TLV.
03/15/06    ks     Mapping auth pref received in SNI to umtsps auth type.
03/13/06    jd     Defer sending SNI response until Um is successfully up
03/13/06    ks     Changed parsing of requests to return error for fixed
                   length tlvs when tlv lengh passed is incorrect.
03/13/06    ks     Changed QMI_ERR_INVALID_ARG to QMI_ERR_MALFORMED_MSG.
                   Added reporting of some new error codes.
03/06/06    ks     Returning QMI_ERR_INVALID_ARG if a malformed TLV is
                   received.
12/11/05    jd     Support message bundling, remove command buffers from
                   pending queues upon client reset.
12/02/05    ks     Updated WDS minor version.
12/02/05    ks     Added new commnads for profiles. Added support for using
                   profiles in Start Network Interface
10/27/05    ks     Fixed compile warning.
09/13/05    jd     Make sure transactions aren't freed while being processed
09/09/05    jd     Added support for async transactions and authentication
                   credentials TLV in start network interface
08/15/05    ks     Return error when all optional TLVs are absent for messages
                   which don't have any mandatory TLVs.
06/27/05    jd     Use rex timer services instead of pstimer
                   Ensure client IDs are not doubly allocated on wraparound
06/20/05    jd     Send Gateway IP address in little-endian order
05/31/05   jd/ks   Code review updates
05/11/05    ks     Code review comments and clean up.
03/18/05    ks     Removed Power State Masks
11/21/04    jd/ks  Created module
===========================================================================*/

/*===========================================================================

                          INCLUDE FILES FOR MODULE

===========================================================================*/
#include "datamodem_variation.h"
#include "comdef.h"
#include "customer.h"

#include <stdio.h>
#include <string.h>
#include <stringl/stringl.h>

#include "amssassert.h"
#include "dsm.h"

#include "timer.h"
#include "ps_byte.h"
#include "ps_iface.h"
#include "ps_ifacei.h"
#include "ps_phys_link.h"
#include "ps_sys.h"
#include "ps_sys_conf.h"
#include "ps_sys_event.h"
#include "ps_sys_ioctl.h"
#include "ds_rmnet_meta_sm.h"
#include "ds_rmnet_v4_sm.h"
#include "ds_rmnet_xport.h"
#include "ds_qmap.h"
#include "ds_rmnet_utils.h"
#include "ds_qmi_cflog.h"
#include "ds_rev_ip_transport_hdlr.h"

#include "qmi_framework.h"
#include "ds_qmux.h"
#include "ds_qmux_ext.h"
#include "ds_qmi_if.h"
#include "ds_qmi_fw_common.h"
#include "ds_qmi_wds.h"
#include "ds_qmi_svc.h"
#include "ds_qmi_defs.h"
#include "ds_qmi_task.h"
#include "ds_qmi_dms.h"

#include "ds_qmi_wds_pbm.h"
#include "ds_qmi_nv_util.h"

#include "ps_route.h"

#ifdef FEATURE_DATA_PS_IPV6
#include "ps_iface_addr_v6.h"
#include "ps_ifacei_addr_v6.h"
#include "ps_ifacei_addr_mgmt.h"
#endif /* FEATURE_DATA_PS_IPV6 */

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
#include "dsat707mip_api.h"
#include "ds707_extif.h"
#include "ds707_pkt_mgr.h"
#if defined(FEATURE_DS_MOBILE_IP)
#include "dsmip.h"
#include "dsmip_api.h"
#endif /* defined(FEATURE_DS_MOBILE_IP) */
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  #include "ds_qmi_wds_umts.h"
  #include "ds_3gpp_hdlr.h"
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(TDSCDMA*/
#if defined(FEATURE_DATA_LTE)
#include "ds_qmi_wds_lte.h"  /* ps_sys.h is already included in ds_qmi_wds_lte.h */
#else
#include "ps_sys.h"
#endif /* defined(FEATURE_DATA_LTE) */

#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  #include "dsumts_rmsm.h"
#endif /* defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */

#include "time_svc.h"
#include "qw.h"

#include "dss_iface_ioctl.h"
#include "dhcp_client.h"
#ifdef FEATURE_DATA_PS_IPV6
#include "dhcp6_client.h"
#endif /* FEATURE_DATA_PS_IPV6 */
#include "ps_acl.h"

#include "dcc_task_defs.h"
#include "dcc_task_svc.h"

#include "ds_qmi_wds_profile.h"
#include "ps_stat_iface.h"

#include "ds3gdsdif.h"
#include "ds_Utils_DebugMsg.h"

#include "ps_system_heap.h"
#include "dserrno.h"

#include "secips.h"

#ifdef FEATURE_DATA_PS_IPV6
extern void rmnet_v6_sm_clear_guard_timer
(
  rmnet_instance_e_type  instance
);
#endif /* FEATURE_DATA_PS_IPV6 */


#ifdef FEATURE_MMGSDI_SESSION_LIB
  #include "mmgsdilib.h"
  #include "mmgsdisessionlib.h"
#endif /* FEATURE_MMGSDI_SESSION_LIB */

#include "qmi_si.h"
#include "qmi_idl_lib.h"
#include "common_v01.h"
#include "wireless_data_service_v01.h"
#include "wireless_data_service_impl_v01.h"

#include "event_defs.h"
#include "event.h"           /* For logging DIAG event and event codes      */
#include "ps_utils.h"

#include "ps_iface_defs.h"

/*===========================================================================

                               DEFINITIONS

===========================================================================*/

/*---------------------------------------------------------------------------
  Service configuration
  - WDS service version is 1.67
---------------------------------------------------------------------------*/
#define WDSI_BASE_VER_MAJOR  (1)
#define WDSI_BASE_VER_MINOR  (67)

#define WDSI_ADDENDUM_VER_MAJOR  (0)
#define WDSI_ADDENDUM_VER_MINOR  (0)

/* We use this double-word in qw_set so we can tell the difference between
 * uninitialized (0) and invalid (-1) */
#define QMI_WDSI_CALL_DURATION_INVALID_DW  (0xFFFFFFFF)

/* For better readability of qw_cmp() */
#define QMI_WDSI_QW_CMP_EQUAL  0
#define QMI_WDSI_QW_CMP_GT     1
#define QMI_WDSI_QW_CMP_LT    -1

/*---------------------------------------------------------------------------
  Message-internal TLV type field values
---------------------------------------------------------------------------*/
/*Route lookup Params*/
#define WDSI_PRM_TYPE_PS_IFACE_NAME_TYPE_LEN            (0x0A)
#define WDSI_PRM_TYPE_APN_STRING                        (0x14)
#define WDSI_PRM_TYPE_IP_FAMILY_PREF                    (0x19)
#define WDSI_PRM_TYPE_IP_FAMILY_PREF_LEN                (0x01)
#define WDSI_PRM_TYPE_EXT_TECH_PREF                     (0x34)
#define WDSI_PRM_TYPE_EXT_TECH_PREF_LEN                 (0x02)
#define WDSI_PRM_TYPE_UMTS_PROFILE_INDEX_LEN            (0x01)
#define WDSI_PRM_TYPE_CDMA_PROFILE_INDEX_LEN            (0x01)
#define WDSI_PRM_TYPE_UMTS_PROFILE_INDEX                (0x31)
#define WDSI_PRM_TYPE_CDMA_PROFILE_INDEX                (0x32)
#define WDSI_PRM_TYPE_RMNET_META_SM_LOOK_UP_TYPE_LEN     (0x01)


#define WDSI_PRM_TYPE_QMI_INSTANCE                      (0x10)
#define WDSI_PRM_TYPE_ARB_INFO                          (0x11)
#define WDSI_PRM_TYPE_RL_EP_ID                          (0x12)
#define WDSI_PRM_TYPE_RL_MUX_ID                         (0x13)

#define WDSI_SPC_SIZ         (NV_SEC_CODE_SIZE)
#define WDSI_MIP_SETTING_MODE_MAX      (2)
#define WDSI_MIP_SETTING_RETRY_INT_MAX (4)

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
#if defined(FEATURE_DS_MOBILE_IP)
#define WDSI_MIP_PROF_INDEX_MAX  (NV_DS_MIP_MAX_NUM_PROF)
#endif /* defined(FEATURE_DS_MOBILE_IP) */
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

/* MIP Setting GET/SET TLV's */
#define WDSI_PRM_TYPE_MIP_SETTING_MODE                  (0x10)
#define WDSI_PRM_TYPE_MIP_SETTING_RETRY_COUNT           (0x11)
#define WDSI_PRM_TYPE_MIP_SETTING_RETRY_INT             (0x12)
#define WDSI_PRM_TYPE_MIP_SETTING_RE_REG_PER            (0x13)
#define WDSI_PRM_TYPE_MIP_SETTING_RE_REG_IF_TRAF        (0x14)
#define WDSI_PRM_TYPE_MIP_SETTING_QC_DORM_HANDOFF       (0x15)
#define WDSI_PRM_TYPE_MIP_SETTING_RFC2002BIS_MN_HA      (0x16)

#define WDSI_PROFILE_EVENT_ALL                            (0xFF)

/*Indication Register TLV*/
#define WDSI_PRM_TYPE_REPORT_PROFILE_EVENT                (0x19)

/*Roaming Info TLV*/
#define WDSI_PRM_TYPE_ROAMING_INFO                        (0x10)

/* MCAST Reason code*/
#define WDSI_PRM_TYPE_MCAST_REASON_CODE (0x10)

/* Set LTE Data Call TLVs */
#define WDSI_PRM_TYPE_DL_THRPT_TIMER             (0x01)
#define WDSI_PRM_TYPE_DL_THROUGHPUT_INFO         (0x10)
#define WDSI_PRM_TYPE_DL_THROUGHPUT_CONFIDENCE_LEVEL  (0x11)
#define WDSI_PRM_TYPE_MIN_DL_THRPT_TIMER         (0x10)
typedef enum
{
  QMI_WDS_MIP_KEY_UNSET                           = 0,
  QMI_WDS_MIP_KEY_DEFAULT                         = 1,
  QMI_WDS_MIP_KEY_NOTDEFAULT                      = 2,
  QMI_WDS_MIP_KEY_MAX      /* DO NOT USE. Used for bounds check */
} qmi_wds_mip_key_e_type;

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
/* Enum of possible return codes for set EVDO Page Monitor Period (PMP) from 
   MH */
typedef enum
{
  QMI_WDSI_EVDO_PMP_SUCCESS                         = 0,
  QMI_WDSI_EVDO_PMP_REQUEST_REJECTED                = 1,
  QMI_WDSI_EVDO_PMP_REQUEST_FAILED_TX               = 2,
  QMI_WDSI_EVDO_PMP_NOT_SUPPORTED                   = 3,
  QMI_WDSI_EVDO_PMP_NO_NET                          = 4
} qmi_wdsi_evdo_pmp_result_e_type;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

#ifdef FEATURE_DATA_LTE
typedef enum
{
  QMI_WDSI_DATA_PATH_HARWARE,   
    /* Hardware data path */

  QMI_WDSI_DATA_PATH_SOFTWARE,
    /* Software data path */

}qmi_wdsi_data_path_type;
#endif /* FEATURE_DATA_LTE */

typedef enum 
{
  QMI_WDSI_SUBS_DEFAULT     = 0x0000,  /* Default Data Subscription */
  QMI_WDSI_SUBS_PRIMARY     = 0x0001,  /* Primary */
  QMI_WDSI_SUBS_SECONDARY   = 0x0002,  /* Secondary */
  QMI_WDSI_SUBS_TERTIARY    = 0x0003,  /* Tertiary */
  QMI_WDSI_SUBS_MAX,                   /* Max supp subs */
  QMI_WDSI_SUBS_DONT_CARE   = 0x00FF   /* Don't care subs */
} qmi_wdsi_subs_enum_type;

/*---------------------------------------------------------------------------
  TLV type field values for Internal QMI messages
---------------------------------------------------------------------------*/

/* Set Internal Runtime Settings */
#define WDSI_PRM_TYPE_SET_HOLDDOWN                      (0x10)
#define WDSI_PRM_TYPE_SET_1X_DORM_TIMER                 (0x11)
#define WDSI_PRM_TYPE_SET_1X_SESSION_TIMER              (0x12)
#define WDSI_PRM_TYPE_SET_HDR_1X_HANDDOWN_OPT           (0x13)
#define WDSI_PRM_TYPE_SET_HYSTERISIS_ACTIVATION_TIMER   (0x14)
#define WDSI_PRM_TYPE_SET_HDR_SLOT_CYCLE_INDEX          (0x15)
#define WDSI_PRM_TYPE_SET_HDR_HPT                       (0x16)
#define WDSI_PRM_TYPE_SET_HDR_REV0_RATE_INERTIA         (0x17)

#ifdef FEATURE_DATA_PS_DHCPV6
#define WDSI_MAX_IPV6_PREFIX_LEN                        (16)
#define WDSI_MAX_IPV6_PREFIX_LENGTH_IN_BITS             (128)
#endif /* FEATURE_DATA_PS_DHCPV6 */
/*---------------------------------------------------------------------------
  Message-internal Value constants
---------------------------------------------------------------------------*/
#define WDSI_IPV6_DEFAULT_PREFIX_LEN                    (64) // 64 bits

/*---------------------------------------------------------------------------
  Authentication Preference Mask
---------------------------------------------------------------------------*/
#define WDSI_AUTH_PREF_PAP_MASK   0x01
#define WDSI_AUTH_PREF_CHAP_MASK  0x02

#define WDSI_AUTH_PREF_VALID_MASK  (WDSI_AUTH_PREF_PAP_MASK | \
                                    WDSI_AUTH_PREF_CHAP_MASK)

#define QMI_WDS_MAX_PCSCF_SERVERS  (0x06)
#define QMI_WDS_MAX_DOMAIN_NAMES   (0x06)

#define WDS_GLOBAL_PKT_DATA_HANDLE  ((void *) (0xFFFFFFFFLU))

/*---------------------------------------------------------------------------
  Pkt statistics masks
---------------------------------------------------------------------------*/
#define WDSI_STAT_MASK_NONE                             (0x00000000)
#define WDSI_STAT_MASK_TX_GOOD_NW                       (0x00000001)
#define WDSI_STAT_MASK_RX_GOOD_NW                       (0x00000002)
#define WDSI_STAT_MASK_TX_DISCARD_NW                    (0x00000004)
#define WDSI_STAT_MASK_RX_DISCARD_NW                    (0x00000008)
#define WDSI_STAT_MASK_TX_OUT_OF_MEM_NW                 (0x00000010)
#define WDSI_STAT_MASK_RX_OUT_OF_MEM_NW                 (0x00000020)
#define WDSI_STAT_MASK_TX_OK_BYTES                      (0x00000040)
#define WDSI_STAT_MASK_RX_OK_BYTES                      (0x00000080)
#define WDSI_STAT_MASK_TX_DROPPED                       (0X00000100)
#define WDSI_STAT_MASK_RX_DROPPED                       (0x00000200)
#define WDSI_STAT_VALUE_UNAVAILABLE                     (0xFFFFFFFF)

/* DUN call control timeout value (in seconds) */
#define WDSI_DUN_CALL_CONTROL_WAIT_PERIOD (10)

/*---------------------------------------------------------------------------
  WDSI_SYS_NETWORK_MAX represent max networks available. We only report 
  3gpp & 3gpp2.
---------------------------------------------------------------------------*/

#define WDSI_SYS_NETWORK_MAX PS_SYS_NETWORK_3GPP2 + 1


/*---------------------------------------------------------------------------
  Macro used in command handlers (common)
---------------------------------------------------------------------------*/
#define CHECK_RETVAL()  if (FALSE == retval) { dsm_free_packet(&response); \
                                               return NULL; }

#define HANDLE_IND_FAILURE() dsm_free_packet(&ind); \
                             return
/* Macro used to update the total active time.  Pass in a time_type variable
 * which will be used as an intermediary variable for calculations */
#define QMI_INCREMENT_TOTAL_ACTIVE_TIME(time_var)   \
  if (0 != wds_sp->last_active_start_time[0] ||           \
      0 != wds_sp->last_active_start_time[1])             \
  {                                                       \
    time_get_uptime_ms(time_var);                              \
    qw_sub(time_var,                                      \
           time_var,                                      \
           wds_sp->last_active_start_time);               \
    qw_add(wds_sp->total_active_time,                     \
           wds_sp->total_active_time,                     \
           time_var);                                     \
    qw_set(wds_sp->last_active_start_time, 0, 0);         \
  }

/* Macro used to update the DUN total active time.  Pass in a time_type variable
 * which will be used as an intermediary variable for calculations */
#define QMI_INCREMENT_DUN_TOTAL_ACTIVE_TIME(time_var)               \
  if (0 != qmi_wdsi_global.modem_dun_last_active_start_time[0] ||   \
      0 != qmi_wdsi_global.modem_dun_last_active_start_time[1])     \
  {                                                                 \
    time_get_uptime_ms(time_var);                                   \
    qw_sub(time_var,                                                \
           time_var,                                                \
           qmi_wdsi_global.modem_dun_last_active_start_time);       \
    qw_add(qmi_wdsi_global.modem_dun_total_active_time,             \
           qmi_wdsi_global.modem_dun_total_active_time,             \
           time_var);                                               \
    qw_set(qmi_wdsi_global.modem_dun_last_active_start_time, 0, 0); \
  }

/* Macros to return the Um interface pointer if a specific call type is up,
 * otherwise NULL */
#define QMI_WDSI_RMNET_UM_IFACE(wds_sp) ((wds_sp->pkt_svc_state == QMI_WDS_CONN_DISCONNECTED) ? NULL : wds_sp->um_iface_ptr)
#define QMI_WDSI_DUN_UM_IFACE(wds_global) ((wds_global.dun_state == QMI_WDS_CONN_DISCONNECTED) ? NULL : wds_global.modem_dun_um_iface_ptr)

#define QMI_WDS_MIP_ERR_CODE_MASK                        (0x00010000)

/*===========================================================================

                                DATA TYPES

===========================================================================*/
/*---------------------------------------------------------------------------
  MODEM STATUS event types
---------------------------------------------------------------------------*/
typedef enum
{
  WDSI_REPORT_MODEM_STATUS_EV_CONN_STATUS = 0x00000001,
  WDSI_REPORT_MODEM_STATUS_EV_PKT_STATS   = 0x00000002,
  WDSI_REPORT_MODEM_STATUS_EV_DORM_STATUS = 0x00000004,
  WDSI_REPORT_MODEM_STATUS_EV_DATA_BEARER = 0x00000008,
  WDSI_REPORT_MODEM_STATUS_EV_CH_RATE     = 0x00000010,
  WDSI_REPORT_MODEM_STATUS_WIDTH          = 0x7FFFFFFF  /* forces enum values to 32 bits */
} qmi_wdsi_report_modem_status_ev_e_type;


/*---------------------------------------------------------------------------
  WDS Event report indication bitmask values
---------------------------------------------------------------------------*/
typedef enum
{
  WDSI_REPORT_STATUS_EV_CH_RATE          = 0x00000001,
  WDSI_REPORT_STATUS_EV_PKT_STATS        = 0x00000002,
  WDSI_REPORT_STATUS_EV_DORM_STATUS      = 0x00000004,
  WDSI_REPORT_STATUS_EV_DATA_BEARER      = 0x00000008,
  WDSI_REPORT_STATUS_EV_CURR_DATA_BEARER = 0x00000010,
  WDSI_REPORT_STATUS_MIP_STATUS          = 0x00000020,
  WDSI_REPORT_STATUS_DATA_CALL_STATUS     = 0x00000080,
  WDSI_REPORT_STATUS_PREFERRED_DATA_STATUS    = 0x00000100,
  WDSI_REPORT_STATUS_EVDO_PAGE_MONITOR_PERIOD_CHANGE  = 0x00000200,
  WDSI_REPORT_STATUS_DATA_SYSTEM_STATUS       = 0x00000400,
  WDSI_REPORT_STATUS_UPLINK_FLOW_CONTROL = 0x00000800,
  WDSI_REPORT_STATUS_ADDITIONAL_PDN_FILTERS_REMOVAL   = 0x00001000,
  WDSI_REPORT_STATUS_DELAY_DORMANCY   = 0x00002000,
  WDSI_REPORT_WIDTH         = 0x7FFFFFFF  /* forces enum values to 32 bits */
} qmi_wdsi_report_status_ev_e_type;

/*---------------------------------------------------------------------------
  WDS call end reason enum type
---------------------------------------------------------------------------*/
typedef enum
{
  QMI_WDS_CALL_END_REASON_MIN                     = 0,
  QMI_WDS_CALL_END_REASON_UNSPECIFIED             = 1,
  QMI_WDS_CALL_END_REASON_CLIENT_END              = 2,
  QMI_WDS_CALL_END_REASON_NO_SRV                  = 3,
  QMI_WDS_CALL_END_REASON_FADE                    = 4,
  QMI_WDS_CALL_END_REASON_REL_NORMAL              = 5,
  QMI_WDS_CALL_END_REASON_ACC_IN_PROG             = 6,
  QMI_WDS_CALL_END_REASON_ACC_FAIL                = 7,
  QMI_WDS_CALL_END_REASON_REDIR_OR_HANDOFF        = 8,
  QMI_WDS_CALL_END_REASON_CLOSE_IN_PROGRESS                   = 9,
  QMI_WDS_CALL_END_REASON_AUTH_FAILED                         = 10,
  QMI_WDS_CALL_END_REASON_INTERNAL_CALL_END                   = 11,
  QMI_WDS_CALL_END_REASON_INTERNAL_ERROR                      = 12,
  QMI_WDS_CALL_END_REASON_INTERNAL_UNKNOWN_CAUSE_CODE         = 13,

/* CDMA specific call-end reasons from CM */
  QMI_WDS_CALL_END_REASON_CDMA_LOCK                 = 500,
  QMI_WDS_CALL_END_REASON_INTERCEPT                 = 501,
  QMI_WDS_CALL_END_REASON_REORDER                   = 502,
  QMI_WDS_CALL_END_REASON_REL_SO_REJ                = 503,
  QMI_WDS_CALL_END_REASON_INCOM_CALL                = 504,
  QMI_WDS_CALL_END_REASON_ALERT_STOP                = 505,
  QMI_WDS_CALL_END_REASON_ACTIVATION                = 506,
  QMI_WDS_CALL_END_REASON_MAX_ACCESS_PROBE          = 507,
  QMI_WDS_CALL_END_REASON_CCS_NOT_SUPPORTED_BY_BS   = 508,
  QMI_WDS_CALL_END_REASON_NO_RESPONSE_FROM_BS       = 509,
  QMI_WDS_CALL_END_REASON_REJECTED_BY_BS            = 510,
  QMI_WDS_CALL_END_REASON_INCOMPATIBLE              = 511,
  QMI_WDS_CALL_END_REASON_ALREADY_IN_TC             = 512,
  QMI_WDS_CALL_END_REASON_USER_CALL_ORIG_DURING_GPS = 513,
  QMI_WDS_CALL_END_REASON_USER_CALL_ORIG_DURING_SMS = 514,
  QMI_WDS_CALL_END_REASON_NO_CDMA_SRV               = 515,

/* GSM/WCDMA specific call-end reasons from CM */
  QMI_WDS_CALL_END_REASON_CONF_FAILED          = 1000,
  QMI_WDS_CALL_END_REASON_INCOM_REJ            = 1001,
  QMI_WDS_CALL_END_REASON_NO_GW_SRV            = 1002,
  QMI_WDS_CALL_END_REASON_NETWORK_END          = 1003,
  QMI_WDS_CALL_END_REASON_LLC_SNDCP_FAILURE    = 1004,
  QMI_WDS_CALL_END_REASON_INSUFFICIENT_RESOURCES = 1005,
  QMI_WDS_CALL_END_REASON_OPTION_TEMP_OOO      = 1006,
  QMI_WDS_CALL_END_REASON_NSAPI_ALREADY_USED   = 1007,
  QMI_WDS_CALL_END_REASON_REGULAR_DEACTIVATION = 1008,
  QMI_WDS_CALL_END_REASON_NETWORK_FAILURE      = 1009,
  QMI_WDS_CALL_END_REASON_UMTS_REATTACH_REQ    = 1010,
  QMI_WDS_CALL_END_REASON_PROTOCOL_ERROR       = 1011,
  QMI_WDS_CALL_END_REASON_OPERATOR_DETERMINED_BARRING         = 1012,
  QMI_WDS_CALL_END_REASON_UNKNOWN_APN                         = 1013,
  QMI_WDS_CALL_END_REASON_UNKNOWN_PDP                         = 1014,
  QMI_WDS_CALL_END_REASON_GGSN_REJECT                         = 1015,
  QMI_WDS_CALL_END_REASON_ACTIVATION_REJECT                   = 1016,
  QMI_WDS_CALL_END_REASON_OPTION_NOT_SUPPORTED                = 1017,
  QMI_WDS_CALL_END_REASON_OPTION_UNSUBSCRIBED                 = 1018,
  QMI_WDS_CALL_END_REASON_QOS_NOT_ACCEPTED                    = 1019,
  QMI_WDS_CALL_END_REASON_TFT_SEMANTIC_ERROR                  = 1020,
  QMI_WDS_CALL_END_REASON_TFT_SYNTAX_ERROR                    = 1021,
  QMI_WDS_CALL_END_REASON_UNKNOWN_PDP_CONTEXT                 = 1022,
  QMI_WDS_CALL_END_REASON_FILTER_SEMANTIC_ERROR               = 1023,
  QMI_WDS_CALL_END_REASON_FILTER_SYNTAX_ERROR                 = 1024,
  QMI_WDS_CALL_END_REASON_PDP_WITHOUT_ACTIVE_TFT              = 1025,
  QMI_WDS_CALL_END_REASON_INVALID_TRANSACTION_ID              = 1026,
  QMI_WDS_CALL_END_REASON_MESSAGE_INCORRECT_SEMANTIC          = 1027,
  QMI_WDS_CALL_END_REASON_INVALID_MANDATORY_INFO              = 1028,
  QMI_WDS_CALL_END_REASON_MESSAGE_TYPE_UNSUPPORTED            = 1029,
  QMI_WDS_CALL_END_REASON_MSG_TYPE_NONCOMPATIBLE_STATE        = 1030,
  QMI_WDS_CALL_END_REASON_UNKNOWN_INFO_ELEMENT                = 1031,
  QMI_WDS_CALL_END_REASON_CONDITIONAL_IE_ERROR                = 1032,
  QMI_WDS_CALL_END_REASON_MSG_AND_PROTOCOL_STATE_UNCOMPATIBLE = 1033,
  QMI_WDS_CALL_END_REASON_APN_TYPE_CONFLICT                   = 1034,
  QMI_WDS_CALL_END_REASON_NO_GPRS_CONTEXT                     = 1035,
  QMI_WDS_CALL_END_REASON_FEATURE_NOT_SUPPORTED               = 1036,
  QMI_WDS_CALL_END_REASON_ILLEGAL_MS                          = 1037,
  QMI_WDS_CALL_END_REASON_ILLEGAL_ME                          = 1038,
  QMI_WDS_CALL_END_REASON_GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED = 1039,
  QMI_WDS_CALL_END_REASON_GPRS_SERVICES_NOT_ALLOWED           = 1040,
  QMI_WDS_CALL_END_REASON_MS_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK = 1041,
  QMI_WDS_CALL_END_REASON_IMPLICITLY_DETACHED                 = 1042,
  QMI_WDS_CALL_END_REASON_PLMN_NOT_ALLOWED                    = 1043,
  QMI_WDS_CALL_END_REASON_LA_NOT_ALLOWED                      = 1044,
  QMI_WDS_CALL_END_REASON_GPRS_SERVICES_NOT_ALLOWED_IN_THIS_PLMN = 1045,
  QMI_WDS_CALL_END_REASON_PDP_DUPLICATE                       = 1046,
  QMI_WDS_CALL_END_REASON_UE_RAT_CHANGE                       = 1047,
  QMI_WDS_CALL_END_REASON_APP_PREEMPTED                       = 1048,
  QMI_WDS_CALL_END_REASON_CONGESTION                          = 1049,
  QMI_WDS_CALL_END_REASON_NO_PDP_CONTEXT_ACTIVATED            = 1050,
  QMI_WDS_CALL_END_REASON_ACCESS_CLASS_DSAC_REJECTION         = 1051,



/* HDR specific call-end reasons from CM */
  QMI_WDS_CALL_END_REASON_CD_GEN_OR_BUSY          = 1500,
  QMI_WDS_CALL_END_REASON_CD_BILL_OR_AUTH         = 1501,
  QMI_WDS_CALL_END_REASON_CHG_HDR                 = 1502,
  QMI_WDS_CALL_END_REASON_EXIT_HDR                = 1503,
  QMI_WDS_CALL_END_REASON_HDR_NO_SESSION          = 1504,
  QMI_WDS_CALL_END_REASON_HDR_ORIG_DURING_GPS_FIX = 1505,
  QMI_WDS_CALL_END_REASON_HDR_CS_TIMEOUT          = 1506,
  QMI_WDS_CALL_END_REASON_HDR_RELEASED_BY_CM      = 1507,

  QMI_WDS_CALL_END_REASON_MAX      /* DO NOT USE. Used for bounds check */
} qmi_wds_call_end_reason_e_type;


/*---------------------------------------------------------------------------
  Data Bearer Technology enum type
---------------------------------------------------------------------------*/
typedef enum
{
  QMI_WDS_BEARER_TECH_UNKNOWN        = 0, /* Not published */
  QMI_WDS_BEARER_TECH_CDMA20001x     = 1,
  QMI_WDS_BEARER_TECH_CDMA_EVDO_REV0 = 2,
  QMI_WDS_BEARER_TECH_GPRS           = 3,
  QMI_WDS_BEARER_TECH_UMTS           = 4, /* For WCDMA */
  QMI_WDS_BEARER_TECH_CDMA_EVDO_REVA = 5,
  QMI_WDS_BEARER_TECH_EDGE           = 6,
  QMI_WDS_BEARER_TECH_HSDPA_WCDMA    = 7,
  QMI_WDS_BEARER_TECH_WCDMA_HSUPA    = 8,
  QMI_WDS_BEARER_TECH_HSDPA_HSUPA    = 9,
  QMI_WDS_BEARER_TECH_LTE            = 10,
  QMI_WDS_BEARER_TECH_CDMA_EVDO_EHRPD = 11,
  QMI_WDS_BEARER_TECH_HSDPAPLUS_WCDMA = 12,
  QMI_WDS_BEARER_TECH_HSDPAPLUS_HSUPA = 13,
  QMI_WDS_BEARER_TECH_DCHSDPAPLUS_WCDMA = 14,
  QMI_WDS_BEARER_TECH_DCHSDPAPLUS_HSUPA = 15,
  QMI_WDS_BEARER_TECH_HSDPAPLUS_64QAM   = 16,
  QMI_WDS_BEARER_TECH_HSDPAPLUS_64QAM_HSUPA = 17,
  QMI_WDS_BEARER_TECH_TDSCDMA         = 18,
  QMI_WDS_BEARER_TECH_TDSCDMA_HSDPA   = 19,
  QMI_WDS_BEARER_TECH_TDSCDMA_HSUPA   = 20,
  QMI_WDS_BEARER_TECH_IWLAN_S2B       = 21,  /* Adding this only for callhistory records */
  QMI_WDS_BEARER_TECH_NULL           = 0xFF /* Not published */
} qmi_wds_bearer_tech_e_type;


/*---------------------------------------------------------------------------
  WDS Internal Iface event enum type
---------------------------------------------------------------------------*/
typedef enum
{
  WDSI_INT_IF_EV_NONE                     = 0x0000,
  WDSI_INT_IF_EV_OUTAGE_NOTIFICATION      = 0x0001,
  WDSI_INT_IF_EV_EXT_IPCONFIG             = 0x0002,
  WDSI_INT_IF_EV_HDR_RATE_INERTIA_SUCCESS = 0x0003,
  WDSI_INT_IF_EV_HDR_RATE_INERTIA_FAILURE = 0x0004,
  WDSI_INT_IF_EV_HDR_SM_SUCCESS           = 0x0005,
  WDSI_INT_IF_EV_HDR_SM_FAILURE           = 0x0006,
  WDSI_INT_IF_EV_HDR_SM_SESS_CHANGE       = 0x0007,
  WDSI_INT_IF_EV_RF_CONDITIONS            = 0x0008,
  WDSI_INT_IF_EV_DOS_ACK                  = 0x0009,
  WDSI_INT_IF_EV_MAX,
  WDSI_INT_IF_EV_WIDTH           = 0xFFFF /* forces enum values to 16 bits */
} qmi_wdsi_int_if_ev_e_type;

/*---------------------------------------------------------------------------
  REQUESTED INTERNAL RUNTIME SETTINGS BIT enum type
---------------------------------------------------------------------------*/
typedef enum
{
  QMI_WDSI_REQ_OPER_BIT0_RF_CONDITIONS               = 0x00,
  QMI_WDSI_REQ_OPER_BIT1_1X_DORM_TIMER               = 0x01,
  QMI_WDSI_REQ_OPER_BIT2_1X_SESSION_TIMER            = 0x02,
  QMI_WDSI_REQ_OPER_BIT3_HDR_1X_HANDDOWN_OPT         = 0x03,
  QMI_WDSI_REQ_OPER_BIT4_HYSTERISIS_ACTIVATION_TIMER = 0x04,
  QMI_WDSI_REQ_OPER_BIT5_HDR_EIDLE_SM_OPT            = 0x05,
  QMI_WDSI_REQ_OPER_BIT6_SDB_SUPPORT                 = 0x06,
  QMI_WDSI_REQ_OPER_MAX
} qmi_wdsi_req_oper_bit_e_type;

#define WDSI_REQ_OPER_ALL_BITS   (0xFFFFFFFF)

/* QMI autoconnect settings and roaming settings */
typedef enum
{
  QMI_WDS_AUTOCONNECT_DISABLED           = RMNET_AUTOCONNECT_DISABLED,
  QMI_WDS_AUTOCONNECT_ENABLED            = RMNET_AUTOCONNECT_ENABLED,
  QMI_WDS_AUTOCONNECT_PAUSED             = RMNET_AUTOCONNECT_PAUSED,
  QMI_WDS_AUTOCONNECT_MAX
} qmi_wdsi_autoconnect_setting_e_type;

typedef enum
{
  QMI_WDS_AUTOCONNECT_ROAM_SETTING_ALWAYS   = RMNET_AUTOCONNECT_ROAM_SETTING_ALWAYS,
  QMI_WDS_AUTOCONNECT_ROAM_SETTING_HOME_ONLY= RMNET_AUTOCONNECT_ROAM_SETTING_HOME_ONLY,
  QMI_WDS_AUTOCONNECT_ROAM_SETTING_MAX      = RMNET_AUTOCONNECT_ROAM_SETTING_MAX
} qmi_wdsi_autoconnect_roam_setting_e_type;

typedef enum
{
  QMI_WDS_IP_VERSION_IPV4 = 0x04,
  QMI_WDS_IP_VERSION_IPV6 = 0x06
} qmi_wdsi_ip_version_e_type;

typedef enum
{
  QMI_WDS_PROTO_TCP = 0x01,
  QMI_WDS_PROTO_UDP = 0x02,
  QMI_WDS_PROTO_TCP_UDP = 0x03
} qmi_wdsi_protocol_e_type;

typedef enum
{
  WDSI_CMD_VAL_RESET                        = 0x0000,
  WDSI_CMD_VAL_SET_EVENT_REPORT             = 0x0001,
  WDSI_CMD_VAL_ABORT                        = 0x0002,
  WDSI_CMD_VAL_INDICATION_REGISTER          = 0x0003,
  WDSI_CMD_VAL_START_NETWORK_INTERFACE      = 0x0020,
  WDSI_CMD_VAL_STOP_NETWORK_INTERFACE       = 0x0021,
  WDSI_CMD_VAL_GET_PKT_SRVC_STATUS          = 0x0022,
  WDSI_CMD_VAL_GET_CURRENT_CHANNEL_RATE     = 0x0023,
  WDSI_CMD_VAL_GET_PKT_STATISTICS           = 0x0024,
  WDSI_CMD_VAL_GO_DORMANT                   = 0x0025,
  WDSI_CMD_VAL_GO_ACTIVE                    = 0x0026,
  WDSI_CMD_VAL_CREATE_PROFILE               = 0x0027,
  WDSI_CMD_VAL_MODIFY_PROFILE_SETTINGS      = 0x0028,
  WDSI_CMD_VAL_DELETE_PROFILE               = 0x0029,
  WDSI_CMD_VAL_GET_PROFILE_LIST             = 0x002A,
  WDSI_CMD_VAL_GET_PROFILE_SETTINGS         = 0x002B,
  WDSI_CMD_VAL_GET_DEFAULT_PROFILE_SETTINGS = 0x002C,
  WDSI_CMD_VAL_GET_RUNTIME_SETTINGS         = 0x002D,
  WDSI_CMD_VAL_SET_MIP_MODE                 = 0x002E,
  WDSI_CMD_VAL_GET_MIP_MODE                 = 0x002F,
  WDSI_CMD_VAL_GET_DORMANCY_STATUS          = 0x0030,
#ifdef FEATURE_DATA_QMI_MCAST
  WDSI_CMD_VAL_INITIATE_MCAST_JOIN          = 0x0031,
  WDSI_CMD_VAL_INITIATE_MCAST_LEAVE         = 0x0032,
  WDSI_CMD_VAL_GET_MCAST_STATUS             = 0x0033,
#endif /* FEATURE_DATA_QMI_MCAST */
  WDSI_CMD_VAL_GET_AUTOCONNECT_SETTING      = 0x0034,
  WDSI_CMD_VAL_GET_CALL_DURATION            = 0x0035,
  /* unused -reserved                       = 0x0036, */
  WDSI_CMD_VAL_GET_DATA_BEARER_TECHNOLOGY   = 0x0037,
  WDSI_CMD_VAL_GET_DUN_CALL_INFO            = 0x0038,
#ifdef FEATURE_DATA_QMI_MCAST
  WDSI_CMD_VAL_MBMS_MCAST_CONTEXT_ACT       = 0x0039,
  WDSI_CMD_VAL_MBMS_MCAST_CONTEXT_DEACT     = 0x003A,
  WDSI_CMD_VAL_GET_MBMS_MCAST_CONTEXT_STATUS= 0x003B,
#endif /* FEATURE_DATA_QMI_MCAST */
  WDSI_CMD_VAL_GET_ACTIVE_MIP_PROFILE       = 0x003C,
  WDSI_CMD_VAL_SET_ACTIVE_MIP_PROFILE       = 0x003D,
  WDSI_CMD_VAL_GET_MIP_PROFILE              = 0x003E,
  WDSI_CMD_VAL_SET_MIP_PROFILE              = 0x003F,
  WDSI_CMD_VAL_GET_MIP_SETTINGS             = 0x0040,
  WDSI_CMD_VAL_SET_MIP_SETTINGS             = 0x0041,
  WDSI_CMD_VAL_GET_LAST_MIP_STATUS          = 0x0042,
  /*reserved 0x0043*/
  WDSI_CMD_VAL_GET_CURRENT_DATA_BEARER_TECHNOLOGY = 0x0044,
  WDSI_CMD_VAL_CALL_HISTORY_LIST            = 0x0045,
  WDSI_CMD_VAL_CALL_HISTORY_READ            = 0x0046,
  WDSI_CMD_VAL_CALL_HISTORY_DELETE          = 0x0047,
  WDSI_CMD_VAL_CALL_HISTORY_MAX_SIZE        = 0x0048,
  WDSI_CMD_VAL_GET_DEFAULT_PROFILE_NUM      = 0x0049,
  WDSI_CMD_VAL_SET_DEFAULT_PROFILE_NUM      = 0x004A,
  WDSI_CMD_VAL_RESET_PROFILE_TO_DEFAULT     = 0x004B,
  WDSI_CMD_VAL_RESET_PROFILE_PARAM_TO_INVALID = 0x004C,
  WDSI_CMD_VAL_SET_CLIENT_IP_PREF           = 0x004D,
  WDSI_CMD_VAL_FMC_SET_TUNNEL_PARAMS        = 0x004E,
  WDSI_CMD_VAL_FMC_CLEAR_TUNNEL_PARAMS      = 0x004F,
  WDSI_CMD_VAL_FMC_GET_TUNNEL_PARAMS        = 0x0050,
  WDSI_CMD_VAL_SET_AUTOCONNECT_SETTING      = 0x0051,
  WDSI_CMD_VAL_GET_DNS_SETTING              = 0x0052,
  WDSI_CMD_VAL_SET_DNS_SETTING              = 0x0053,
  WDSI_CMD_VAL_GET_PRE_DORMANCY_CDMA_SETTINGS = 0x0054,
  WDSI_CMD_VAL_SET_CAM_TIMER                  = 0x0055,
  WDSI_CMD_VAL_GET_CAM_TIMER                  = 0x0056,
  WDSI_CMD_VAL_SET_SCRM                       = 0x0057,
  WDSI_CMD_VAL_GET_SCRM                       = 0x0058,
  WDSI_CMD_VAL_SET_RDUD                       = 0x0059,
  WDSI_CMD_VAL_GET_RDUD                       = 0x005A,
  WDSI_CMD_VAL_GET_SIP_MIP_CALL_TYPE          = 0x005B,
  WDSI_CMD_VAL_SET_EVDO_PAGE_MONITOR_PERIOD   = 0x005C,
  WDSI_CMD_VAL_SET_EVDO_FORCE_LONG_SLEEP      = 0x005D,
  WDSI_CMD_VAL_GET_EVDO_PAGE_MONITOR_PERIOD   = 0x005E,
  WDSI_CMD_VAL_GET_CALL_THROTTLE_INFO         = 0x005F,
  WDSI_CMD_VAL_GET_NSAPI                      = 0x0060,
  WDSI_CMD_VAL_SET_DUN_CTRL_PREF            = 0x0061,
  WDSI_CMD_VAL_GET_DUN_CTRL_PREF            = 0x0062,
  WDSI_CMD_VAL_SET_DUN_CTRL_EVENT_REPORT    = 0x0063,
  WDSI_CMD_VAL_CONTROL_PENDING_DUN_CALL     = 0x0064,
  WDSI_CMD_VAL_EMBMS_TMGI_ACTIVATE            = 0x0065,
  WDSI_CMD_VAL_EMBMS_TMGI_DEACTIVATE          = 0x0066,
  WDSI_CMD_VAL_EMBMS_TMGI_LIST_QUERY          = 0x0067,
  WDSI_CMD_VAL_EMBMS_TMGI_LIST_IND            = 0x0068,
  WDSI_CMD_VAL_GET_PREFERRED_DATA_SYSTEM    = 0x0069,
  WDSI_CMD_VAL_GET_LAST_DATA_CALL_STATUS    = 0x006A,
  WDSI_CMD_VAL_GET_CURRENT_DATA_SYSTEM_STATUS = 0x006B,
  WDSI_CMD_VAL_GET_PDN_THROTTLE_INFO          = 0x006C,
  WDSI_CMD_VAL_GET_LTE_ATTACH_PARAMS          = 0x0085,
  WDSI_CMD_VAL_RESET_PKT_STATISTICS           = 0x0086,
  WDSI_CMD_VAL_GET_FLOW_CONTROL_STATUS        = 0x0087,
  WDSI_CMD_VAL_EMBMS_TMGI_ACT_DEACT           = 0x0088,
  WDSI_CMD_VAL_BIND_DATA_PORT                 = 0x0089,
  WDSI_CMD_VAL_SET_ADDITIONAL_PDN_FILTER      = 0x008A,
  WDSI_CMD_VAL_REMOVE_ADDITIONAL_PDN_FILTER   = 0x008B,
  WDSI_CMD_VAL_EXTENDED_IP_CONFIG_IND         = 0X008C,
#ifdef FEATURE_DATA_WLAN_MAPCON
  WDSI_CMD_VAL_REV_IP_TRANSPORT_CONNECTION_IND_REG  = 0x008D,
  WDSI_CMD_VAL_REV_IP_TRANSPORT_CONNECTION_IND      = 0x008E,
  WDSI_CMD_VAL_GET_IPSEC_STATIC_SA_CONFIG           = 0x008F,
  WDSI_CMD_VAL_REV_IP_TRANSPORT_CONFIG_COMPLETE     = 0x0090,
  WDSI_CMD_VAL_GET_DATA_BEARER_TECHNOLOGY_EX        = 0x0091,
#endif /* FEATURE_DATA_WLAN_MAPCON */
#ifdef FEATURE_DATA_LTE
  WDSI_CMD_VAL_GET_LTE_MAX_ATTACH_PDN_NUM     = 0x0092,
  WDSI_CMD_VAL_SET_LTE_ATTACH_PDN_LIST        = 0x0093,
  WDSI_CMD_VAL_GET_LTE_ATTACH_PDN_LIST        = 0x0094,
  WDSI_CMD_VAL_LTE_ATTACH_PDN_LIST_IND        = 0x0095,
  WDSI_CMD_VAL_SET_LTE_DATA_RETRY             = 0x0096,
  WDSI_CMD_VAL_GET_LTE_DATA_RETRY             = 0x0097,
  WDSI_CMD_VAL_SET_LTE_ATTACH_TYPE            = 0x0098,
  WDSI_CMD_VAL_GET_LTE_ATTACH_TYPE            = 0x0099,
  WDSI_CMD_VAL_UPDATE_LTE_ATTACH_PDN_LIST_PROFILES  = 0x009F,
#endif /* FEATURE_DATA_LTE */
#ifdef FEATURE_EPC_HANDOFF
  WDSI_CMD_VAL_HANDOFF_INFORMATION_IND        = 0x009B,
#endif /* FEATURE_EPC_HANDOFF */
#ifdef FEATURE_DATA_LTE
  WDSI_CMD_VAL_SET_DATA_PATH                  = 0x009C,
  WDSI_CMD_VAL_GET_DATA_PATH                  = 0x009D,
#endif /* FEATURE_DATA_LTE */
#ifdef FEATURE_DATA_EMBMS
  WDSI_CMD_VAL_EMBMS_SAI_LIST_QUERY           = 0x00A0,
  WDSI_CMD_VAL_EMBMS_SAI_LIST_IND             = 0x00A1,
#endif /* FEATURE_DATA_EMBMS */
  WDSI_CMD_VAL_BIND_MUX_DATA_PORT             = 0x00A2,
  WDSI_CMD_VAL_SET_THRPT_INFO_IND_FREQ        = 0x00A3,
  WDSI_CMD_VAL_GET_LAST_THRPT_INFO            = 0x00A4,
  WDSI_CMD_VAL_THRPT_INFO_IND                 = 0x00A5,
#ifdef FEATURE_DATA_WLAN_MAPCON
  WDSI_CMD_VAL_INITIATE_ESP_REKEY             = 0x00A6,
#endif /* FEATURE_DATA_WLAN_MAPCON */
  WDSI_CMD_VAL_PROFILE_EVT_REG                = 0x00A7,
  WDSI_CMD_VAL_PROFILE_EVT_IND                = 0x00A8,
  WDSI_CMD_VAL_GET_CAPABILITIES               = 0x00A9,
  WDSI_CMD_VAL_GET_ROAMING_INFO               = 0x00AA,
  WDSI_CMD_VAL_ROAMING_INFO_IND               = 0x00AB,
#ifdef FEATURE_DATA_PS_DHCPV6
  WDSI_CMD_VAL_GET_DELEGATED_IPV6_PREFIX      = 0x00AC,
  WDSI_CMD_VAL_REMOVE_DELEGATED_IPV6_PREFIX   = 0x00AD,
#endif /* FEATURE_DATA_PS_DHCPV6 */
  WDSI_CMD_VAL_ABORT_GO_DORMANT               = 0x00AE,
  WDSI_CMD_VAL_BIND_SUBSCRIPTION              = 0x00AF,
  WDSI_CMD_VAL_GET_BIND_SUBSCRIPTION          = 0x00B0,
  WDSI_CMD_VAL_SET_LTE_DATA_CALL_TYPE         = 0x00B1,
  WDSI_CMD_VAL_SET_DL_THRPT_INFO_IND_FREQ     = 0x00B2,
  WDSI_CMD_VAL_DL_THRPT_INFO_IND              = 0x00B3,
  WDSI_CMD_VAL_GET_MIN_DL_THRPT_INFO_PARAMS   = 0x00B4,
  WDSI_CMD_VAL_EMBMS_CONTENT_DESC_UPDATE      = 0x00B5,
  WDSI_CMD_VAL_EMBMS_CONTENT_DESC_CONTROL_IND = 0x00B6,
  WDSI_CMD_VAL_APN_PARAM_CHANGED_IND          = 0x00B9,
  WDSI_CMD_VAL_SET_SILENT_REDIAL              = 0x00BA,
  WDSI_CMD_VAL_KEEP_ALIVE_DATA_SESSION        = 0x00C3,
/* QC EXTERNAL QMI COMMAND RANGE IS 0x0000 - 0x5555.
   Add the next external QMI Command here */

/* VENDOR SPECIFIC QMI COMMAND RANGE IS 0x5556 - 0xAAAA.
   IMPORTANT!
   Add the vendor specific QMI Commands within this range only to avoid
   conflicts with QC QMI commands that would get released in future */

/* RESERVED QC QMI COMMAND RANGE IS 0xAAAB - 0xFFFE */
  WDSI_CMD_VAL_GET_GATEWAY_ADDR          = 0xF222,
/* Internal QMI Commands must be added in DECREASING ORDER from Below */
/*RESERVED                                   = 0xFFF0,*/
/*RESERVED                                   = 0xFFF1,*/
  WDSI_CMD_VAL_ROUTE_LOOK_UP                 = 0xFFF2,
#ifdef FEATURE_DATA_QMI_MCAST
  WDSI_CMD_VAL_INITIATE_MCAST_REG_EX         = 0xFFF3,
  WDSI_CMD_VAL_INITIATE_MCAST_LEAVE_EX       = 0xFFF4,
  WDSI_CMD_VAL_INITIATE_MCAST_JOIN_EX        = 0xFFF5,
#endif /* FEATURE_DATA_QMI_MCAST */
  WDSI_CMD_VAL_BCMCS_BOM_CACHING_SETUP       = 0xFFF6,
  WDSI_CMD_VAL_BCMCS_ENABLE_HANDOFF_REG      = 0xFFF7,
  WDSI_CMD_VAL_BCMCS_DB_UPDATE               = 0xFFF8,
  WDSI_CMD_VAL_MT_DEREG_CB                   = 0xFFF9,
  WDSI_CMD_VAL_MT_REG_CB                     = 0xFFFA,
  WDSI_CMD_VAL_REFRESH_DHCP_CONFIG_INFO      = 0xFFFB,
  WDSI_CMD_VAL_SET_INTERNAL_RUNTIME_SETTINGS = 0xFFFC,
  WDSI_CMD_VAL_GET_INTERNAL_RUNTIME_SETTINGS = 0xFFFD,
  WDSI_CMD_VAL_INTERNAL_IFACE_EV_REGISTER    = 0xFFFE,
  WDSI_CMD_VAL_WIDTH                     = 0xFFFF
} qmi_wdsi_cmd_val_e_type;

/* QMI data bearer technology structure definition for new format */
typedef struct
{
  uint32                 rat_mask;
  uint32                 so_mask;
  ps_iface_network_type  current_nw;
} qmi_wdsi_curr_data_bearer_tech_type;

#define CURR_DATA_BEARER_TLV_SIZE (9)
#define CURR_DATA_BEARER_TLV_OFFSET_CURR_NW (0)
#define CURR_DATA_BEARER_TLV_OFFSET_RAT_MASK (1)
#define CURR_DATA_BEARER_TLV_OFFSET_SO_MASK (5)
/* This union type contains the curr_data_bearer_tech TLV in the intended
 * form. We use the "byte_array" to populate the data. The "data" type is
 * to be used for debugging purposes. */
typedef PACKED union PACKED_POST
{
  PACKED struct PACKED_POST
  {
    ps_iface_network_type  current_nw;
    uint32                 rat_mask;
    uint32                 so_mask;
  } data;
  PACKED struct PACKED_POST
  {
    byte string[CURR_DATA_BEARER_TLV_SIZE];
  } byte_array;
} qmi_wdsi_curr_data_bearer_tech_tlv_type;

/* Current Data System status structure definition */
typedef PACKED struct PACKED_POST
{
  uint8  preferred_network;
  uint8  network_info_len;       
  PACKED struct PACKED_POST
  {
    uint8    network;
    uint32   rat_mask;
    uint32   so_mask;
  } network_info[WDSI_SYS_NETWORK_MAX];
} qmi_wdsi_curr_data_system_status_type;

/* Bearer tech ex structure definition */
typedef PACKED struct PACKED_POST
{
  uint32    technology;
  uint32    rat_value;
  uint64    so_mask;
} qmi_wdsi_bearer_tech_ex_type;

/* Below Families are related to limited data system status TLV
   When client wants the system status indication to be limited,
   only the RAT changes from RAT belonging to different family
   would be sent out.
*/
/**
  WCDMA RAT MASK FAMILY
 */
#define FAMILY_3GPP_WCDMA_RATS \
(PS_SYS_RAT_3GPP_WCDMA | PS_SYS_RAT_3GPP_HSDPA | \
 PS_SYS_RAT_3GPP_HSUPA | PS_SYS_RAT_3GPP_HSDPAPLUS | \
 PS_SYS_RAT_3GPP_DC_HSDPAPLUS | PS_SYS_RAT_3GPP_64_QAM)
 
/**
  GSM RAT MASK FAMILY
 */ 
#define FAMILY_3GPP_GSM_RATS \
(PS_SYS_RAT_3GPP_GPRS | PS_SYS_RAT_3GPP_EDGE)

/**
  LTE RAT MASK FAMILY
 */ 
#define FAMILY_3GPP_LTE_RATS PS_SYS_RAT_3GPP_LTE

/**
  TDSCDMA RAT MASK FAMILY
 */ 
#define FAMILY_3GPP_TDSCDMA_RATS PS_SYS_RAT_3GPP_TDSCDMA

#define BYTE_BY_BYTE_COPY(a,offset,b) \
  ((a)[offset]) = (byte)((b)&0xff);\
  ((a)[offset+1]) = (byte)(((b)>>8)&0xff);\
  ((a)[offset+2]) = (byte)(((b)>>16)&0xff);\
  ((a)[offset+3]) = (byte)(((b)>>24)&0xff);

/* MACRO to populate the curr_data_bearer_tech TLV from the actual struct.
 * Takes the pointer to the actual struct and the TLV to be populated as
 * the two arguments. */
#define COPY_DATA_BEARER_STRUCT_TO_TLV(str,tlv) \
  memset( &(tlv), 0, sizeof(tlv) );\
  ((tlv).byte_array.string[CURR_DATA_BEARER_TLV_OFFSET_CURR_NW]) = (byte)((str)->current_nw);\
  BYTE_BY_BYTE_COPY((tlv).byte_array.string,CURR_DATA_BEARER_TLV_OFFSET_RAT_MASK,((str)->rat_mask));\
  BYTE_BY_BYTE_COPY((tlv).byte_array.string,CURR_DATA_BEARER_TLV_OFFSET_SO_MASK,((str)->so_mask));

typedef enum
{
  WDSI_IPV4_STATE  = 0x00,
  WDSI_IPV6_STATE  = 0x01,
  WDSI_MAX_STATE
} qmi_wdsi_state_e_type;
typedef enum
{

   WDSI_CALL_UKNOWN = 0x00,
   WDSI_CALL_ACTIVATED = 0x01,
   WDSI_CALL_TERMINATED = 0x02
}qmi_wdsi_call_status;

typedef enum
{
  WDSI_DATA_CALL_NONE           = 0x0,
  WDSI_DATA_CALL_EMBEDDED       = 0x1,
  WDSI_DATA_CALL_TETHERED_RMNET = 0x2,
  WDSI_DATA_CALL_TETHERED_DUN   = 0x4,
  WDSI_DATA_CALL_MODEM_EMBEDDED = 0x8,
  WDSI_DATA_CALL_MAX
} qmi_wdsi_data_call_e_type;

typedef enum
{
   WDSI_SYSTEM_UNKNOWN = 0x0,
   WDSI_SYSTEM_1X = 0x1,
   WDSI_SYSTEM_EVDO = 0x2,
   WDSI_SYSTEM_GPRS = 0x3,
   WDSI_SYSTEM_WCDMA = 0x4,
   WDSI_SYSTEM_LTE = 0x5,
   WDSI_SYSTEM_TDSCDMA = 0x6   
}qmi_wdsi_preferred_system;

/* DUN call control event type - used in DUN_CTRL_EVENT_REPORT_IND and
 * while posting commands from RMSM callback. */
typedef enum
{
  WDSI_DUN_CTRL_EVENT_INVALID        = 0x0,
  WDSI_DUN_CTRL_EVENT_CALL_PROCESSED = 0x1,
  WDSI_DUN_CTRL_EVENT_ENTITLEMENT    = 0x2,
  WDSI_DUN_CTRL_EVENT_SILENT_REDIAL  = 0x3,
  WDSI_DUN_CTRL_EVENT_TIMER_EXPIRY   = 0x4,
  WDSI_DUN_CTRL_EVENT_MAX
} qmi_wdsi_dun_ctrl_event_e_type;

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
/* Range of possible slot cycle values that can be returned by MH and conveyed
   back to the application. A subset of these are valid as an input on set 
   EVDO Page Monitor Period */
typedef enum
{
  WDSI_EVDO_SLOT_CYCLE_6_MSECS              = 0x00,
  WDSI_EVDO_SLOT_CYCLE_13_MSECS             = 0x01,
  WDSI_EVDO_SLOT_CYCLE_26_MSECS             = 0x02,
  WDSI_EVDO_SLOT_CYCLE_53_MSECS             = 0x03,
  WDSI_EVDO_SLOT_CYCLE_106_MSECS            = 0x04,
  WDSI_EVDO_SLOT_CYCLE_213_MSECS            = 0x05,
  WDSI_EVDO_SLOT_CYCLE_426_MSECS            = 0x06,
  WDSI_EVDO_SLOT_CYCLE_1280_MSECS           = 0x07,
  WDSI_EVDO_SLOT_CYCLE_2560_MSECS           = 0x08,
  WDSI_EVDO_SLOT_CYCLE_5120_MSECS           = 0x09,
  WDSI_EVDO_SLOT_CYCLE_10240_MSECS          = 0x0A,
  WDSI_EVDO_SLOT_CYCLE_20480_MSECS          = 0x0B,
  WDSI_EVDO_SLOT_CYCLE_40960_MSECS          = 0x0C,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_6_MSECS   = 0x0D,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_7_MSECS   = 0x0E,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_8_MSECS   = 0x0F,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_9_MSECS   = 0x10,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_10_MSECS  = 0x11,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_11_MSECS  = 0x12,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_12_MSECS  = 0x13,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_13_MSECS  = 0x14,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_14_MSECS  = 0x15,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_15_MSECS  = 0x16,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_16_MSECS  = 0x17,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_17_MSECS  = 0x18,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_18_MSECS  = 0x19,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_19_MSECS  = 0x1A,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_20_MSECS  = 0x1B,
  WDSI_EVDO_SLOT_CYCLE_1280_TIMES_21_MSECS  = 0x1C,
  WDSI_EVDO_SLOT_CYCLE_INVALID              = 0xFE,
  WDSI_EVDO_SLOT_CYCLE_DEFAULT              = 0xFF
}qmi_wdsi_evdo_slot_cycle_e_type;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

typedef enum {
  WDSI_FORCE_REASON_DEFAULT = 0,
  WDSI_FORCE_REASON_ABORT = 1,
  WDSI_FORCE_REASON_AUTOCONNECT = 2
} qmi_wdsi_force_type;

/* Parameters related to reverse IP transport connection indication */
typedef enum {
  WDSI_REV_IP_TRANSPORT_DISCONNECTED = 0x00000000,
  WDSI_REV_IP_TRANSPORT_CONNECTED    = 0x00000001
} qmi_wdsi_rev_ip_transport_connection_status_enum;

/*---------------------------------------------------------------------------
  QMI Wireless Data Service instance state definition &
  Wireless Data Service client state definition
---------------------------------------------------------------------------*/
typedef struct
{
  uint32 rx_pkts;
  uint32 tx_pkts;
  uint64 rx_bytes;
  uint64 tx_bytes;
  uint32 rx_pkts_dropped;
  uint32 tx_pkts_dropped;
} qmi_wdsi_stats_type;

typedef struct {
  uint8     source;
  uint64    date;
  uint32    ipv4_addr;
  uint8     tech_type_e;
  uint8     phone_num_len;
  char      phone_num[QMI_PBM_PHONENUM_MAX_LEN];
  boolean   has_connected;
} qmi_wdsi_callhist_data_temp_s_type;

PACKED typedef struct PACKED_POST
{
  uint8 evdo_page_monitor_period;
  boolean evdo_force_long_sleep;
} qmi_wdsi_evdo_page_monitor_period;

/* Structure for reporting List Of Removed Filters */
typedef PACKED struct PACKED_POST
{
  uint8    num_filters;
  uint32 fltr_handles[PS_IFACE_MAX_OPT_FILTER_ENTRIES];
} qmi_wdsi_additional_pdn_filters_removed_type;

/*---------------------------------------------------------------------------
  Profile Configuration bitmask
---------------------------------------------------------------------------*/
#define QMI_WDS_MASK_PROFILE_3GPP   (0x01)
#define QMI_WDS_MASK_PROFILE_3GPP2  (0x02)
#define QMI_WDS_MASK_PROFILE_EPC    (0x04)
#define QMI_WDS_MASK_PROFILE_ALL    (0xFF)

/* Structure for Reporting List Of Profile Events */
typedef PACKED struct PACKED_POST
{
  ds_profile_cb_handle_type   ds_reg_profile_hndl_list[DS_PROFILE_TECH_MAX][DS_PROFILE_ACTIVE_SUBSCRIPTION_MAX];
  boolean             is_registered_ds_profile_events;
} qmi_wdsi_profile_cb_list_type;

/*Structure for node(s) of Profile Change Event List*/
typedef PACKED struct PACKED_POST
{
  uint8    num_configs;
  PACKED struct PACKED_POST
  {
    uint8    profile_type;
    uint8    profile_num;
  }config_tuple[0];
} qmi_wdsi_profile_change_evt_type;

/* Structure for storing DS-Profile Handles of Profile callback Reg */
typedef PACKED struct PACKED_POST
{
  uint8                             report_on_tech_mask;
  qmi_wdsi_profile_change_evt_type *profile_change_evt_list;
} qmi_wdsi_profile_config_list_type;

typedef struct qmi_wdsi_client_state_s
{
  qmi_common_client_state_type   common;        // must be first since we alias
  struct qmi_wdsi_client_state_s * next;        // Link to next client
  uint8                          wds_inst;      // Current (binding) WDS instance
  uint8                          orig_qmi_inst; // Original QMI instance
  boolean                        net_bound;     // TRUE if client has called StartNI
  qmi_ip_family_e_type           bound_ip_type;
  qmi_wdsi_state_e_type          current_wds_state;
  boolean                        dormancy_abortable; //Flag for validating dormancy client
  qmi_wdsi_subs_enum_type        subscription_id; //Subs id of the client

  timer_type  pkt_stats_timer;
  timer_type  dun_stats_timer;

  struct
  {
    uint32      ind_mask;              /* current call status indications  */
    uint8       pkt_stats_period;      /* periodicity of call status ind's */
    boolean     report_ch_rate;
    boolean     report_data_bearer;    // Deprecated
    boolean     report_dormancy_status;
    boolean     report_curr_data_bearer;
    boolean     report_dun_conn_status;
    boolean     report_mip_status;
    boolean     report_data_call_status_change;
    boolean     report_preferred_data_system;
    boolean     report_evdo_page_monitor_period_change;
    boolean     report_data_system_status;
    boolean     report_limited_data_system_status;

    boolean     report_uplink_flow_ctrl;
    qmi_wdsi_stats_type stats_last_rpt;
    qmi_wds_dormancy_status_e_type      last_dorm_rpt;
    boolean     report_dun_call_processed;
    boolean     report_tmgi_list;
    boolean     suppress_pkt_ind;
    boolean     report_additional_pdn_fltrs_removal;
    boolean     report_extended_ip_config;
    boolean     report_rev_ip_transport_connection_ind;
    boolean     report_data_bearer_ex;
#ifdef FEATURE_DATA_LTE
    boolean     report_attach_pdn_list_change;
#endif /* FEATURE_DATA_LTE */
#ifdef FEATURE_EPC_HANDOFF
    boolean     report_handoff_information_change;
#endif /* FEATURE_EPC_HANDOFF */
#ifdef FEATURE_DATA_EMBMS
    boolean     report_sai_list;
#endif /* FEATURE_DATA_EMBMS */
    boolean     report_profile_change_events;
    boolean     report_thrpt_info_change;
    boolean     report_roaming_info_change;
    boolean     report_dl_thrpt_info_change;
    boolean     report_embms_content_desc_change;
    boolean     report_apn_param_changed;
    boolean     report_delay_dormancy_result;
  } report_status;

  uint32 internal_iface_ev_reg_mask;

  struct
  {
    uint64      tx_bytes;
    uint64      rx_bytes;
    uint32      ind_mask;              /* current call status indications  */
    uint8       pkt_stats_period;      /* periodicity of call status ind's */
    boolean     ch_rate;
    boolean     data_bearer;
    boolean     dorm_status;
    /* conn_status is part of the RMNET report_status struct */

    /* cache all IND values except packet stats, which are sent periodically */
    qmi_wds_conn_status_e_type      last_conn_status;
    qmi_wds_bearer_tech_e_type      last_data_bearer;
    qmi_wds_dormancy_status_e_type  last_dorm_rpt;
    uint32                          last_tx_rate;
    uint32                          last_rx_rate;
  } modem_rpt_status;

  /* eMBMS pending query request */
  qmi_cmd_buf_type * tmgi_active_list_cmd_buf_p;
  qmi_cmd_buf_type * tmgi_avail_list_cmd_buf_p;
 #ifdef FEATURE_DATA_EMBMS
  qmi_cmd_buf_type * sai_list_cmd_buf_p;
#endif /* FEATURE_DATA_EMBMS */

  /* Profile Change Event */
  qmi_wdsi_profile_config_list_type config_evt_list;
  /* Interval at which dl thrpt reporting is desired */
  uint32                            downlink_report_interval;
} qmi_wdsi_client_state_type;


/*---------------------------------------------------------------------------
  Structure to maintain WDS state
---------------------------------------------------------------------------*/
typedef struct qmi_wdsi_state_s
{
  qmi_wdsi_client_state_type *client_list;
  qmi_wds_conn_status_e_type  pkt_svc_state;
  qmi_ip_family_e_type        cur_ip_call_type;
  q_type                      sni_pend_q;
  qmi_cmd_buf_type           *stop_ni_cmd_buf_p;
  qmi_wds_call_end_reason_e_type call_end_reason;
  uint32                      call_end_reason_verbose;
  boolean                     is_primary_state;
#ifdef FEATURE_DATA_WLAN_MAPCON
  ds_sys_system_status_info_type curr_data_bearer_cache;
  ds_sys_system_status_info_type last_data_bearer_cache;
#else
  qmi_wdsi_curr_data_bearer_tech_type   curr_data_bearer_cache;
  qmi_wdsi_curr_data_bearer_tech_type   last_data_bearer_cache;
#endif /* FEATURE_DATA_WLAN_MAPCON */
  boolean                     is_last_data_bearer_cache_set;
  uint32                      current_tx_rate;
  uint32                      current_rx_rate;
  /*-------------------------------------------------------------------------
    Network Interface callback buffers
  -------------------------------------------------------------------------*/
  void *net_iface_configuring_buf_ptr;/* Event buf for NET Iface CONFIGURING */
  void *net_iface_down_buf_ptr;       /* Event buf for NET Iface DOWN      */
  void *net_iface_authenticating_buf_ptr;       /* Event buf for
                                                   NET Iface AUTHENTICATING*/

  /*-------------------------------------------------------------------------
    UM Interface callback buffers
  -------------------------------------------------------------------------*/
  void *um_iface_mcast_reg_success_buf_ptr;
  void *um_iface_mcast_reg_failure_buf_ptr;
  void *um_iface_mcast_dereg_buf_ptr;
  void *um_iface_mbms_cont_act_success_buf_ptr;
  void *um_iface_mbms_cont_act_failure_buf_ptr;
  void *um_iface_mbms_cont_deact_success_buf_ptr;
  void *um_iface_mbms_cont_deact_failure_buf_ptr;
  void *um_iface_mcast_status_ex_buf_ptr;
  void *um_iface_outage_notification_buf_ptr;
  void *um_iface_ext_ipconfig_buf_ptr;
  void *um_iface_ext_ipconfig_ex_buf_ptr;
  void *um_iface_hdr_rate_inertia_succ_buf_ptr;
  void *um_iface_hdr_rate_inertia_fail_buf_ptr;
  void *um_iface_hdr_sm_succ_buf_ptr;
  void *um_iface_hdr_sm_fail_buf_ptr;
  void *um_iface_hdr_sm_sess_change_buf_ptr;
  void *um_iface_rf_conditions_buf_ptr;
  void *um_iface_mt_request_buf_ptr;
  void *um_iface_fast_dormancy_status_buf_ptr;
  void *um_iface_embms_tmgi_activated_buf_ptr;
  void *um_iface_embms_tmgi_deactivated_buf_ptr;
  void *um_iface_embms_tmgi_act_deact_buf_ptr;
  void *um_iface_embms_active_tmgi_list_buf_ptr;
  void *um_iface_embms_available_tmgi_list_buf_ptr;
  void *um_iface_embms_warning_tmgi_list_buf_ptr;
  void *um_iface_apn_param_changed_buf_ptr;

#ifdef FEATURE_EPC_HANDOFF
  void *um_iface_handoff_init_buf_ptr;
  void *um_iface_handoff_success_buf_ptr;
  void *um_iface_handoff_failure_buf_ptr;
#endif /* FEATURE_EPC_HANDOFF */

#ifdef FEATURE_DATA_EMBMS
  void *um_iface_embms_sai_list_buf_ptr;
#endif /* FEATURE_DATA_EMBMS */
  void *um_iface_embms_content_desc_buf_ptr;
  /*-------------------------------------------------------------------------
    WLAN/EPDG Interface callback buffers
  -------------------------------------------------------------------------*/
  void *wlan_iface_configuring_buf_ptr;
  void *wlan_iface_down_buf_ptr;
  void *wlan_iface_rev_ip_transport_config_buf_ptr;

  /*-------------------------------------------------------------------------
    UM Phys_Link callback buffers
  -------------------------------------------------------------------------*/
  void *um_phys_link_up_buf_ptr;       /* buf: UM Phys link UP   */
  void *um_phys_link_down_buf_ptr;     /* buf: UM Phys link DOWN  */
  void *um_phys_link_dos_ack_buf_ptr;  /* buf: UM Phys link DOS ACK */
  ps_iface_type *um_iface_ptr;
  ps_iface_type *rmnet_iface_ptr;
  ps_iface_type *wlan_iface_ptr;
  ps_phys_link_type *um_iface_phys_link_ptr; /* cache um iface physlink */

  struct wlan_tx_s 
  {
    boolean                     wlan_tx_pending;
    uint32                      wlan_tx_id;
    ps_iface_ioctl_reverse_ip_transport_conn_enum_type conn;
  } wlan_tx;

  boolean                     is_mcast_inst;
  /* boolean to indicate whether registered for mcast evor not */
  boolean                     reg_mcast_iface_ev;
  boolean                     reg_rmnet_iface_ev;
  boolean                     reg_um_iface_ev;

  uint8                       num_mcast_reqs;
  time_type                   call_connect_time;
  time_type                   last_call_duration;
  time_type                   last_call_active_duration;
  time_type                   last_active_start_time;
  time_type                   total_active_time;

  boolean                     internal_iface_ev_reg;
#ifdef FEATURE_EPC_HANDOFF
  boolean                     handoff_iface_ev_reg;
#endif /* FEATURE_EPC_HANDOFF */

  /* eMBMS flags */
  boolean                     is_embms_inst;
  boolean                     reg_embms_iface_ev;

  /* Counter needed to limit the PDN filters on a RmNet port */
  uint8                       additional_pdn_fltrs_count;
  /* temp data to store call history info until written */
  qmi_wdsi_callhist_data_temp_s_type callhist_data;

  /* Cached uplink flow control status */
  boolean                         uplink_flow_ctrl;
  uint16                          uplink_fc_seq_num;

  struct
  {
    uint32                    ep_id;
    uint8                     mux_id;
    boolean                   is_reversed;
    rmnet_instance_e_type     rmnet_inst;
    qmi_wdsi_subs_enum_type   subscription_id; //Subs id on which call is up
  } binding;

  struct wds_constants_s
  {
    uint8                  wds_inst;
    boolean                is_default;
  } constants;
} qmi_wdsi_state_type;

typedef struct
{
  uint64       txed_bytes;
  uint64       rxed_bytes;
} qmi_wdsi_data_byte_count_type;

static struct
{
  boolean inited;

  qmi_wds_call_status_cb_f_type  call_status_cb; /* callback for call status */
  qmi_wds_swap_instances_cb_f_type  swap_instances_cb;

  /* modem status - only CONNECTED or DISCONNECTED */
  qmi_wds_conn_status_e_type      dun_state;
  qmi_wdsi_subs_enum_type         dun_subs_id;/* DUN call subs id */

  /* DUN needs its own channel rate cache since it is independent of RMNET */
  uint32 dun_tx_rate;
  uint32 dun_rx_rate;

  /* DUN call timers and 'last' variables */
  time_type modem_dun_call_connect_time;
  time_type modem_dun_call_end_time;

  time_type modem_dun_last_active_start_time;
  time_type modem_dun_total_active_time;

  qmi_wds_call_end_reason_e_type modem_dun_last_call_end_reason;
  time_type  modem_dun_last_call_active_duration;
  qmi_wdsi_data_byte_count_type modem_dun_last_call_data_count;
  qmi_wds_bearer_tech_e_type modem_dun_last_data_bearer;

  /*caches um iface ptr for DUN call to poll data bearer*/
  ps_iface_type * modem_dun_um_iface_ptr;

  /*caches iface ptr for DUN call SIO iface*/
  ps_iface_type * modem_dun_iface_ptr;

  /*buffers to store UP, ROUTEABLE and DOWN events used filter DUN calls*/
  void *dun_iface_up_ev_buf_ptr;
  void *dun_iface_routeable_ev_buf_ptr;
  void *dun_iface_down_ev_buf_ptr;
  void *dun_iface_active_in_use_ev_buf_ptr;
  void *dun_iface_out_of_use_ev_buf_ptr;

  void *dun_um_phys_link_up_buf_ptr;       /* buf: UM Phys link UP   */
  void *dun_um_phys_link_down_buf_ptr;     /* buf: UM Phys link DOWN  */

  ps_phys_link_type *dun_um_iface_phys_link_ptr; /* cache um iface physlink */

/* Event buf for BEARER TECH CHANGE */
  void *um_iface_bearer_tech_change_buf_ptr;

  /* temp data to store call history info until written */
  qmi_wdsi_callhist_data_temp_s_type callhist_data;

  q_type                      call_thr_pend_q;
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  q_type                      evdo_pmp_pend_q;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  struct
  {
    /* Basic DUN control parameters */
    boolean                     is_active;
    qmi_wdsi_client_state_type *ctrl_cl_sp;
    boolean                     enable_dun_control;
    boolean                     allow_dun_call;
    /* Event report preference of the controlling control point */
    struct
    {
      boolean  report_entitlement_event;
      boolean  report_silent_redial_event;
    } report_status;
    /* Pending DUN call info */
    struct
    {
      boolean                        is_valid;
      qmi_wdsi_dun_ctrl_event_e_type event_type;
      ps_sys_tech_enum_type          tech_type;
      ps_iface_net_down_reason_type  net_down_reason;
      unsigned char                  cb_data;
    } call_info;
    uint8                            pending_call_id;
  } dun_ctrl_info;
  timer_type dun_call_control_timer; /* DUN call control timer */

  /* caches last call status */
  qmi_wdsi_call_status last_data_call_status;
  qmi_wdsi_data_call_e_type last_data_call_type;
  qmi_wdsi_curr_data_system_status_type last_data_system_status;
  uint32                    last_data_call_addr_family;

  qmi_wdsi_profile_cb_list_type   profile_reg_list;

  uint32 num_flow_enable;
  uint32 num_flow_disable;

} qmi_wdsi_global = {0,};

#define WDSI_MAX_MCAST_SESSIONS  (40) //SYS_BCMCS_MAX_FLOWS
#define WDSI_MAX_MCAST_FLOWS_PER_REQUEST  (PS_IFACE_MAX_MCAST_FLOWS)

typedef PACKED struct PACKED_POST
{
  ip_addr_enum_type ip_addr_type;
  PACKED union PACKED_POST
  {
    uint32 v4;
    uint64 v6[2];
  } addr;
  uint16            port;
} qmi_wdsi_packed_ip_addr_port_type;

typedef PACKED struct PACKED_POST
{
  uint8             num_addrs;
  qmi_wdsi_packed_ip_addr_port_type
                                bcmcs_addr[WDSI_MAX_MCAST_FLOWS_PER_REQUEST];
} qmi_wdsi_bcmcs_addr_info_type;

// Port ID enum
typedef enum {
  QMI_WDS_VALID_SIO_PORT_ID      = 0x0000, 
  QMI_WDS_END_POINT_ID           = 0x0001
} qmi_wds_valid_port_enum_type;

// Throughput quality enum
typedef enum {
  QMI_WDS_HIGHER_THROUGHPUT_UNKNOWN,
  QMI_WDS_HIGHER_THROUGHPUT_NOT_POSSIBLE,
  QMI_WDS_HIGHER_THROUGHPUT_POSSIBLE
} qmi_wds_throughput_quality_enum_type;

/**
  @brief Data type to be used to represent per bearer
         throughput info
*/
typedef PACKED struct PACKED_POST
{
  uint32 bearer_rlp_mac_id;
  uint32 bearer_uplink_actual_rate;
  uint32 bearer_uplink_queue_size;
  boolean is_default_bearer;
} qmi_wds_bearer_throughput_info_type;

typedef PACKED struct PACKED_POST
{
  uint8 num_bearers; 
  qmi_wds_bearer_throughput_info_type bearer_trpt_info[DS_SYS_MAX_BEARER];
} qmi_wds_bearer_throughput_info_list_type;

typedef PACKED struct PACKED_POST
{
  uint8 apn_len;
  char  apn_string[DS_UMTS_MAX_APN_STRING_LEN];
  uint32 ip_type;
  uint32 tech_type;
  uint32 subscription;
  uint32 uplink_actual_rate;
  uint32 uplink_allowed_rate;
  uint32 uplink_queue_size;
  uint32 throughput_quality;
  uint32 valid_port;
  uint16 data_port;
  uint32 ep_type;
  uint32 peripheral_iface_id;
  uint8  mux_id;
  qmi_wds_bearer_throughput_info_list_type bearer_list;
} qmi_wds_trpt_info_type;

typedef PACKED struct PACKED_POST
{
  uint8  num_trpt_info; /* Num of tprt info in the list */
  qmi_wds_trpt_info_type trpt_info[PS_SYS_MAX_NUM_THROUGHPUT_INFO];
} qmi_wds_trpt_info_list_type;

typedef PACKED struct PACKED_POST
{
  uint32 downlink_allowed_rate;
  uint8  confidence_level;
} qmi_wds_downlink_thrpt_info_type;

#ifdef FEATURE_DATA_QMI_MCAST
  typedef enum
  {
    WDSI_MCAST_REG_SUCCESS =  0x01,
    WDSI_MCAST_REG_FAILURE =  0x02,
    WDSI_MCAST_DEREG       =  0x03,
    WDSI_MCAST_STATUS_EX   =  0x04
  } wdsi_mcast_status_e_type;

  typedef enum
  {
    WDSI_MBMS_MCAST_CONT_ACT_SUCCESS =  0x01,
    WDSI_MBMS_MCAST_CONT_ACT_FAILURE =  0x02,
    WDSI_MBMS_MCAST_CONT_DEACT_SUCCESS =  0x03,
    WDSI_MBMS_MCAST_CONT_DEACT_FAILURE =  0x04
  } wdsi_mbms_mcast_cont_status_e_type;

  typedef struct
  {
    ps_iface_mcast_handle_type    handle;
    qmi_wdsi_client_state_type *  cl_sp;
  } qmi_wdsi_mcast_info_type;

  static qmi_wdsi_mcast_info_type
                              wds_mcast_info[WDSI_MAX_MCAST_SESSIONS] = {{0,}};

  typedef PACKED struct PACKED_POST
  {
    qmi_wdsi_packed_ip_addr_port_type                 ip_addr_port;
    ps_iface_ioctl_mcast_join_ex_req_flags_enum_type  mcast_request_flags;
  } qmi_wdsi_mcast_join_ex_flow_info_type;

  typedef PACKED struct PACKED_POST
  {
    uint8             num_flows;
    qmi_wdsi_mcast_join_ex_flow_info_type
                           mcast_flow_info[WDSI_MAX_MCAST_FLOWS_PER_REQUEST];
  } qmi_wdsi_mcast_join_ex_input_type;
#endif /* FEATURE_DATA_QMI_MCAST */

typedef struct
{
  ps_iface_mt_handle_type      handle;
  qmi_wdsi_client_state_type * cl_sp;
  ps_iface_type              * iface_ptr;
} qmi_wdsi_mt_handle_type;

#define WDSI_MAX_MT_CBS  (32) // DSUMTSPS_MT_MAX_CB
static qmi_wdsi_mt_handle_type wds_mt_handle_list[WDSI_MAX_MT_CBS] = {{0,}};

/*---------------------------------------------------------------------------
  Temporary global memory (scratch pad for WDS)
---------------------------------------------------------------------------*/
typedef union
{
  ip_addr_type pcscf_addr[QMI_WDS_MAX_PCSCF_SERVERS];
  ps_iface_domain_name_type pcscf_fqdn[QMI_WDS_MAX_PCSCF_SERVERS];
  ps_iface_domain_name_type domain_name_search_list[QMI_WDS_MAX_DOMAIN_NAMES];
  ps_iface_op_reserved_pco_type protocol_reserved_info;
#ifdef FEATURE_DATA_QMI_MCAST
  byte qmi_wdsi_mcast_join_ex_input_info[
                                  sizeof(qmi_wdsi_mcast_join_ex_input_type)];
#endif /* FEATURE_DATA_QMI_MCAST */
  byte qmi_wds_bcmcs_addr_info_buff[sizeof(qmi_wdsi_bcmcs_addr_info_type)];
} qmi_wds_temp_info_type;

static qmi_wds_temp_info_type wds_temp;

/* This is the default QMI_WDS command buffer. Make sure that it does not grow
 * beyond 512 bytes. In case you need a command buffer larger than 512 bytes,
 * declare a separate structure. */
typedef struct
{
  uint16  cmd_id; /* qmi_cmd_id_e_type */
  uint32  subscription_id;
  union
  {
    struct
    {
      uint8 clid;
    } send_pkt_stats;

    struct
    {
      ps_phys_link_type          *phys_link_ptr;
      ps_iface_event_enum_type   event;
      ps_iface_event_info_u_type event_info;
      void                       *user_data_ptr;
    } phys_link_status;

    struct
    {
      ps_iface_type              *iface_ptr;
      ps_iface_event_enum_type   event;
      ps_iface_event_info_u_type event_info;
      void                       *wds_sp;
    } iface_info;

    struct
    {
      ps_iface_event_enum_type     event;
      ps_iface_type               *iface_ptr;
      ps_iface_event_info_u_type   event_info;
      ps_iface_name_enum_type      iface_name;
    } dun_call_info;

    struct
    {
      uint32     new_pref_system;
    } pref_system;

    struct
    {
      uint32     status;
      uint8      call_type;
    } data_call_status;

#ifdef FEATURE_DATA_IS707
    struct
    {
      ds707_call_throttle_info throttled_delay;
      int16          ps_errno;
    } call_throttle_info;
#endif /*FEATURE_DATA_IS707*/

    struct
    {
      qmi_wdsi_dun_ctrl_event_e_type event_type;
      ps_sys_tech_enum_type          tech_type;
      unsigned char                  cb_data;
      boolean                        call_allowed;
      ps_iface_net_down_reason_type  net_down_reason;
    } dun_ctrl_event_info;

    qmi_wdsi_evdo_page_monitor_period epmp;

    struct
    {
      int16     evt;
      ps_hdr_slotted_mode_failure_code_enum_type   failure_code;
    } set_evdo_pmp_info;

    qmi_wdsi_curr_data_system_status_type data_system_status;

    struct
    {
      uint32                          ep_id;
      uint8                           mux_id;
      uint8                           is_v6;
      boolean                         uplink_flow_ctrl;
    } flow_ctrl;

    struct
    {
      uint16    num_instances;
    } init_cb;

    struct
    {
      qmi_framework_common_msg_hdr_type    common_msg_hdr;
    } clid_cb;

    struct
    {
      qmi_framework_msg_hdr_type    msg_hdr;
      dsm_item_type             *   sdu_in;
    } cmd_hdlr_cb;

    struct
    {
      ps_iface_type              *iface_ptr;
      ps_iface_event_enum_type   event;
      ps_iface_event_info_u_type event_info;
      void                       *wds_sp;
    }wlan_evt_info;

    struct
    {
      ds_profile_event_etype          event;
      uint32                          profile_count;
      ds_profile_changes_info       * profiles_changes;
    }profile_evt_info;

#ifdef FEATURE_DATA_LTE
    qmi_wds_lte_attach_pdn_list_type lte_attach_pdn_list;
#endif /* FEATURE_DATA_LTE */
    ps_sys_throughput_info_list_type   * thrpt_info_list;

    ps_sys_roaming_disallowed_info_type  * roaming_info_list;

    ps_sys_event_outage_notification_type outage_info;
    
    ps_sys_dl_throughput_info_type     dl_thrpt_info;

    struct
     {
       void              *cl_sp;
     }rev_ip_conn_info;

  } data;
} qmi_wdsi_cmd_buf_type;

qmi_idl_service_object_type 	wds_svc_obj;

/* Data call type is a two-byte TLV.
 *   leading byte  - a = call_type i.e. EMBEDDED / TETHERED
 *   trailing byte - b = call_sub_type i.e. RMNET / DUN / NONE */
typedef PACKED struct PACKED_POST
{
  uint8       call_type;
  uint8       call_sub_type;
} qmi_wdsi_data_call_type;

#define WDSI_CALL_TYPE_NONE     (0x0)
#define WDSI_CALL_TYPE_EMBEDDED (0x1)
#define WDSI_CALL_TYPE_TETHERED (0x2)
#define WDSI_CALL_TYPE_MODEM_EMBEDDED (0x3)

#define WDSI_CALL_SUB_TYPE_NONE  (0x0)
#define WDSI_CALL_SUB_TYPE_RMNET (0x1)
#define WDSI_CALL_SUB_TYPE_DUN   (0x2)

/*--------------------------------------------------------------------------
  Queue structure to keep track of clients that have requested to set the
  EVDO page monitor period and are expecting the EVDO page monitor period change
  result indication.
---------------------------------------------------------------------------*/
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
typedef struct
{
  q_link_type                   link;  //must be first
  qmi_wdsi_client_state_type *  cl_sp;
}evdo_pmp_pend_q_type;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

/*--------------------------------------------------------------------------
  eMBMS data structures
---------------------------------------------------------------------------*/
typedef enum
{
  WDSI_TMGI_STATUS_SUCCESS    = 0x00000000
} qmi_wdsi_tmgi_status_e_type;

typedef enum
{
  WDSI_TMGI_LIST_TYPE_ACTIVE    = 0x00,
  WDSI_TMGI_LIST_TYPE_AVAILABLE = 0x01,
  WDSI_TMGI_LIST_TYPE_OOS_WARNING = 0x02
} qmi_wdsi_tmgi_list_e_type;

#define WDSI_MAX_TMGI_NUM  (128)
#define WDSI_MAX_TMGI_EARFCN     PS_IFACE_EMBMS_MAX_NUM_FREQUENCY_TO_SRCH
#ifdef FEATURE_DATA_EMBMS
#define WDSI_MAX_SAI             PS_IFACE_EMBMS_MAX_NUM_SAI_TO_SRCH  
#define WDSI_MAX_SAI_NUM_FREQ    PS_IFACE_EMBMS_MAX_NUM_FREQ_FOR_SAI_INFO 
#endif /* FEATURE_DATA_EMBMS */

#define WDSI_TMGI_LEN        (8)
#define WDSI_TMGI_BYTE_LEN   (6)

#define WDSI_TYPE_2_BYTE_EARFCN  (2)
#define WDSI_TYPE_4_BYTE_EARFCN  (4)

typedef PACKED struct PACKED_POST
{
  byte    tmgi[6];
  uint8   session_id_valid;
  uint8   session_id;
} qmi_wdsi_tmgi_type;

typedef PACKED struct PACKED_POST
{
  uint8              tmgi_list_type;
  uint8              tmgi_list_len;
  qmi_wdsi_tmgi_type tmgi_list[WDSI_MAX_TMGI_NUM];
} qmi_wdsi_tmgi_list_type;

typedef PACKED struct PACKED_POST
{
  uint8   num_earfcn;
  uint16  earfcn[WDSI_MAX_TMGI_EARFCN];
} qmi_wdsi_earfcn_list_type;

typedef PACKED struct PACKED_POST
{
  uint8   num_earfcn;
  uint32  extended_earfcn[WDSI_MAX_TMGI_EARFCN];
} qmi_wdsi_earfcn_list_ex_type;

#ifdef FEATURE_DATA_EMBMS
typedef PACKED struct PACKED_POST
{
  uint8   num_sai;
  uint32  sai[WDSI_MAX_SAI];
} qmi_wdsi_sai_list_type;

typedef PACKED struct PACKED_POST
{
  uint16                    frequency;             
  boolean                   is_serving_frequency;  
  uint8                     num_sais;              
  uint32                    sai_list[PS_IFACE_EMBMS_MAX_NUM_SAI_TO_SRCH];  
}qmi_wdsi_frequency_sai_info_type;

#endif /* FEATURE_DATA_EMBMS */

typedef PACKED struct PACKED_POST
{
  uint32                    frequency;             
  boolean                   is_serving_frequency;  
  uint8                     num_sais;              
  uint32                    sai_list[PS_IFACE_EMBMS_MAX_NUM_SAI_TO_SRCH];  
}qmi_wdsi_ex_frequency_sai_info_type;

typedef PACKED struct PACKED_POST
{
  uint32    addr_family;
  uint8     ip_addr_len;
  uint8     ip_addr[16];
}qmi_wdsi_ip_addr_type;

typedef enum
{
  QMI_WDS_CLIENT_TYPE_NONE     = 0,
  QMI_WDS_CLIENT_TYPE_TETHERED = 1
} qmi_wds_client_type;

#define WDSI_MAX_TIMER_INTERVAL (0xFFFFFFFF)
/*===========================================================================

                               INTERNAL DATA

===========================================================================*/

/*---------------------------------------------------------------------------
  QMI_WDS service command handlers
  forward declarations & cmd handler dispatch table definition
---------------------------------------------------------------------------*/
static dsm_item_type*  qmi_wdsi_reset(void*, void*, void*, dsm_item_type **);
static dsm_item_type*  qmi_wdsi_set_event_report(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_abort(void*, void*, void*, dsm_item_type **);
static dsm_item_type*  qmi_wdsi_indication_register(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_start_network_interface(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_stop_network_interface(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_pkt_srvc_status(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_current_channel_rate(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_pkt_statistics(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_go_dormant(void*,
                                           void*,
                                           void*,
                                           dsm_item_type**);
static dsm_item_type*  qmi_wdsi_go_active(void*,
                                           void*,
                                           void*,
                                           dsm_item_type**);
static dsm_item_type*  qmi_wdsi_abort_go_dormant(void*,
                                           void*,
                                           void*,
                                           dsm_item_type**);
static dsm_item_type*  qmi_wdsi_create_profile(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_modify_profile_settings(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_delete_profile(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_profile_list(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_profile_settings(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_default_profile_settings(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_default_profile_num(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_set_default_profile_num(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_reset_profile_to_default(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_reset_profile_param_to_invalid(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_runtime_settings(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_set_mip_mode(void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_mip_mode(void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_dormancy_status(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_autoconnect_setting(void*,
                                                        void*,
                                                        void*,
                                                        dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_call_duration(void*,
                                                  void*,
                                                  void*,
                                                  dsm_item_type **);
static dsm_item_type*  qmi_wdsi_get_dun_call_info(void*,
                                                  void*,
                                                  void*,
                                                  dsm_item_type **);
static dsm_item_type*  qmi_wdsi_get_current_data_bearer_technology(
                                                           void*,
                                                           void*,
                                                           void*,
                                                           dsm_item_type **);

#ifdef FEATURE_DATA_WLAN_MAPCON
static dsm_item_type*  qmi_wdsi_get_data_bearer_technology_ex(
                                                           void*,
                                                           void*,
                                                           void*,
                                                           dsm_item_type **);
#endif /* FEATURE_DATA_WLAN_MAPCON */

static dsm_item_type*  qmi_wdsi_route_look_up(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);

static dsm_item_type*  qmi_wdsi_internal_iface_ev_reg( void*,
                                                       void*,
                                                       void*,
                                                       dsm_item_type** );
static dsm_item_type*  qmi_wdsi_get_internal_runtime_settings(
                                                           void*,
                                                           void*,
                                                           void*,
                                                           dsm_item_type** );
static dsm_item_type*  qmi_wdsi_set_internal_runtime_settings(
                                                           void*,
                                                           void*,
                                                           void*,
                                                           dsm_item_type** );
static dsm_item_type*  qmi_wdsi_refresh_dhcp_config_info( void*,
                                                          void*,
                                                          void*,
                                                          dsm_item_type** );

static dsm_item_type*  qmi_wdsi_get_active_mip_profile( void*,
                                                        void *,
                                                        void*,
                                                        dsm_item_type**);
static dsm_item_type*  qmi_wdsi_set_active_mip_profile( void*,
                                                        void*,
                                                        void*,
                                                        dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_mip_profile(  void*,
                                                  void*,
                                                  void*,
                                                  dsm_item_type**);
static dsm_item_type*  qmi_wdsi_set_mip_profile(  void*,
                                                  void*,
                                                  void*,
                                                  dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_mip_settings( void*,
                                                  void*,
                                                  void*,
                                                  dsm_item_type**);
static dsm_item_type*  qmi_wdsi_set_mip_settings(  void*,
                                                   void*,
                                                   void*,
                                                   dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_last_mip_status( void*,
                                                     void*,
                                                     void*,
                                                     dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_data_bearer_technology( void*,
                                                     void*,
                                                     void*,
                                                     dsm_item_type**);

static void wdsi_dun_iface_ev_cb( ps_iface_type             *this_iface_ptr,
                                      ps_iface_event_enum_type   event,
                                      ps_iface_event_info_u_type event_info,
                                      void                      *user_data_ptr );

static dsm_item_type*  qmi_wdsi_call_history_list( void*,
                                                       void*,
                                                       void*,
                                                       dsm_item_type**);
static dsm_item_type*  qmi_wdsi_call_history_read( void*,
                                                   void*,
                                                   void*,
                                                   dsm_item_type**);
static dsm_item_type*  qmi_wdsi_call_history_delete( void*,
                                                     void*,
                                                     void*,
                                                     dsm_item_type**);
static dsm_item_type*  qmi_wdsi_call_history_max_size( void*,
                                                       void*,
                                                       void*,
                                                       dsm_item_type**);
static dsm_item_type*  qmi_wdsi_fmc_set_tunnel_params(
                                               void*,
                                               void*,
                                               void*,
                                               dsm_item_type** );
static dsm_item_type*  qmi_wdsi_fmc_clear_tunnel_params(
                                               void*,
                                               void*,
                                               void*,
                                               dsm_item_type** );

static dsm_item_type*  qmi_wdsi_fmc_get_tunnel_params(
                                               void*,
                                               void*,
                                               void*,
                                               dsm_item_type** );
static dsm_item_type*  qmi_wdsi_set_autoconnect_setting(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_dns_setting(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_set_dns_setting(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);

static dsm_item_type * qmi_wdsi_set_client_ip_pref
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in );

static dsm_item_type*  qmi_wdsi_get_pre_dormancy_cdma_settings(
                                                            void*,
                                                            void*,
                                                            void*,
                                                            dsm_item_type**);
static dsm_item_type*  qmi_wdsi_set_cam_timer(
                                           void*,
                                           void*,
                                           void*,
                                           dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_cam_timer(
                                           void*,
                                           void*,
                                           void*,
                                           dsm_item_type**);
static dsm_item_type*  qmi_wdsi_set_scrm(
                                      void*,
                                      void*,
                                      void*,
                                      dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_scrm(
                                      void*,
                                      void*,
                                      void*,
                                      dsm_item_type**);
static dsm_item_type*  qmi_wdsi_set_rdud(
                                      void*,
                                      void*,
                                      void*,
                                      dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_rdud(
                                      void*,
                                      void*,
                                      void*,
                                      dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_sip_mip_call_type(
                                                void*,
                                                void*,
                                                void*,
                                                dsm_item_type**);
static dsm_item_type*  qmi_wdsi_set_evdo_page_monitor_period(
                                                  void*,
                                                  void*,
                                                  void*,
                                                  dsm_item_type**);
static dsm_item_type*  qmi_wdsi_set_evdo_force_long_sleep(
                                                  void*,
                                                  void*,
                                                  void*,
                                                  dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_evdo_page_monitor_period(
                                                  void*,
                                                  void*,
                                                  void*,
                                                  dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_call_throttle_info(
                                                    void*,
                                                    void*,
                                                    void*,
                                                    dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_nsapi(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

static dsm_item_type*  qmi_wdsi_set_dun_ctrl_pref(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_dun_ctrl_pref(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);
static dsm_item_type*  qmi_wdsi_set_dun_ctrl_event_report(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);
static dsm_item_type*  qmi_wdsi_control_pending_dun_call(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_preferred_data_system(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
static dsm_item_type*  qmi_wdsi_get_last_data_call_status(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);

static dsm_item_type*  qmi_wdsi_get_current_data_system_status( 
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

static dsm_item_type*  qmi_wdsi_get_pdn_throttle_info( 
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);

static dsm_item_type*  qmi_wdsi_get_lte_attach_params( 
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);

static dsm_item_type*  qmi_wdsi_reset_pkt_statistics( 
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);

static dsm_item_type*  qmi_wdsi_embms_tmgi_activate(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

static dsm_item_type*  qmi_wdsi_embms_tmgi_deactivate(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

static dsm_item_type* qmi_wdsi_embms_tmgi_act_deact(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

static dsm_item_type*  qmi_wdsi_embms_tmgi_list_query(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

static dsm_item_type*  qmi_wdsi_get_flow_control_status(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

static dsm_item_type*  qmi_wdsi_bind_data_port(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

#ifdef FEATURE_DATA_LTE
static dsm_item_type*  qmi_wdsi_set_data_path( 
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);

static dsm_item_type*  qmi_wdsi_get_data_path( 
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);
#endif /* FEATURE_DATA_LTE */
#ifdef FEATURE_DATA_WLAN_MAPCON
static dsm_item_type*  qmi_wdsi_rev_ip_transport_connection_ind_reg(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);

static dsm_item_type*  qmi_wdsi_get_ipsec_static_sa_config(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);

static dsm_item_type*  qmi_wdsi_rev_ip_transport_config_complete(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);

static dsm_item_type*  qmi_wdsi_initiate_esp_rekey(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);

#endif /* FEATURE_DATA_WLAN_MAPCON */

#ifdef FEATURE_DATA_EMBMS
static dsm_item_type*  qmi_wdsi_embms_sai_list_query(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);
#endif /* FEATURE_DATA_EMBMS */

static dsm_item_type*  qmi_wdsi_bind_mux_data_port(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);
static dsm_item_type*  qmi_wdsi_configure_profile_event_list(
                                             void*,
                                             void*,
                                             void*,
                                             dsm_item_type**);

static dsm_item_type*  qmi_wdsi_set_throughput_info_ind_freq(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

static dsm_item_type*  qmi_wdsi_get_last_throughput_info(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

static dsm_item_type*  qmi_wdsi_get_roaming_info(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

#ifdef FEATURE_DATA_PS_DHCPV6
static dsm_item_type*  qmi_wdsi_remove_delegated_ipv6_prefix(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**); 

static dsm_item_type*  qmi_wdsi_get_delegated_ipv6_prefix(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**); 

static dsm_item_type*  qmi_wdsi_bind_subscription(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**); 

static dsm_item_type*  qmi_wdsi_get_bind_subscription(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**); 
#endif /* FEATURE_DATA_PS_DHCPV6 */

static dsm_item_type*  qmi_wdsi_get_capabilities(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

static dsm_item_type*  qmi_wdsi_set_lte_data_call_type(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**); 

static dsm_item_type*  qmi_wdsi_set_dl_thrpt_info_ind_freq(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**); 

static dsm_item_type*  qmi_wdsi_get_downlink_throughput_info_params(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**); 

static dsm_item_type*  qmi_wdsi_embms_content_desc_update(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**); 

static dsm_item_type * qmi_wdsi_set_silent_redial(
                                       void *,
                                       void *,
                                       void *,
                                       dsm_item_type **);

static dsm_item_type*  qmi_wdsi_keep_alive_data_session(
                                       void*,
                                       void*,
                                       void*,
                                       dsm_item_type**);

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
static void qmi_wdsi_evdo_page_monitor_period_changed_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
);

void qmi_wdsi_set_evdo_pmp_cb(int16 evt, 
                 ps_hdr_slotted_mode_failure_code_enum_type* failure_code);
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

#define WDSI_PARSER(f)   #f,f

#define WDS_HDLR(a,b)  QMI_SVC_HDLR( a, (qmi_svc_hdlr_ftype) b )

static qmi_svc_cmd_hdlr_type  qmi_wdsi_cmd_callbacks[] =
{
  WDS_HDLR( WDSI_CMD_VAL_RESET,
            qmi_wdsi_reset),
  WDS_HDLR( WDSI_CMD_VAL_SET_EVENT_REPORT,
            qmi_wdsi_set_event_report),
  WDS_HDLR( WDSI_CMD_VAL_ABORT,
            qmi_wdsi_abort),
  WDS_HDLR( WDSI_CMD_VAL_INDICATION_REGISTER,
            qmi_wdsi_indication_register),
  WDS_HDLR( WDSI_CMD_VAL_START_NETWORK_INTERFACE,
            qmi_wdsi_start_network_interface),
  WDS_HDLR( WDSI_CMD_VAL_STOP_NETWORK_INTERFACE,
            qmi_wdsi_stop_network_interface),
  WDS_HDLR( WDSI_CMD_VAL_GET_PKT_SRVC_STATUS,
            qmi_wdsi_get_pkt_srvc_status),
  WDS_HDLR( WDSI_CMD_VAL_GET_CURRENT_CHANNEL_RATE,
            qmi_wdsi_get_current_channel_rate),
  WDS_HDLR( WDSI_CMD_VAL_GET_PKT_STATISTICS,
            qmi_wdsi_get_pkt_statistics),
  WDS_HDLR( WDSI_CMD_VAL_CREATE_PROFILE,
            qmi_wdsi_create_profile),
  WDS_HDLR( WDSI_CMD_VAL_MODIFY_PROFILE_SETTINGS,
            qmi_wdsi_modify_profile_settings),
  WDS_HDLR( WDSI_CMD_VAL_DELETE_PROFILE,
            qmi_wdsi_delete_profile),
  WDS_HDLR( WDSI_CMD_VAL_GET_PROFILE_LIST,
            qmi_wdsi_get_profile_list),
  WDS_HDLR( WDSI_CMD_VAL_GET_PROFILE_SETTINGS,
            qmi_wdsi_get_profile_settings),
  WDS_HDLR( WDSI_CMD_VAL_GET_DEFAULT_PROFILE_SETTINGS,
            qmi_wdsi_get_default_profile_settings),
  WDS_HDLR( WDSI_CMD_VAL_GET_RUNTIME_SETTINGS,
            qmi_wdsi_get_runtime_settings),
  WDS_HDLR( WDSI_CMD_VAL_SET_MIP_MODE,
            qmi_wdsi_set_mip_mode),
  WDS_HDLR( WDSI_CMD_VAL_GET_MIP_MODE,
            qmi_wdsi_get_mip_mode),
  WDS_HDLR( WDSI_CMD_VAL_GET_DORMANCY_STATUS,
            qmi_wdsi_get_dormancy_status),
  WDS_HDLR( WDSI_CMD_VAL_GO_DORMANT,
            qmi_wdsi_go_dormant),
  WDS_HDLR( WDSI_CMD_VAL_GO_ACTIVE,
            qmi_wdsi_go_active)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_ACTIVE_MIP_PROFILE,
            qmi_wdsi_get_active_mip_profile)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_ACTIVE_MIP_PROFILE,
            qmi_wdsi_set_active_mip_profile)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_MIP_PROFILE,
            qmi_wdsi_get_mip_profile)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_MIP_PROFILE,
            qmi_wdsi_set_mip_profile)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_MIP_SETTINGS,
            qmi_wdsi_get_mip_settings)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_MIP_SETTINGS,
            qmi_wdsi_set_mip_settings)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_LAST_MIP_STATUS,
            qmi_wdsi_get_last_mip_status)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_AUTOCONNECT_SETTING,
            qmi_wdsi_get_autoconnect_setting)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_CALL_DURATION,
             qmi_wdsi_get_call_duration)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_DATA_BEARER_TECHNOLOGY,
            qmi_wdsi_get_data_bearer_technology)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_DUN_CALL_INFO,
            qmi_wdsi_get_dun_call_info)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_CURRENT_DATA_BEARER_TECHNOLOGY,
             qmi_wdsi_get_current_data_bearer_technology)
  ,WDS_HDLR( WDSI_CMD_VAL_CALL_HISTORY_LIST,
             qmi_wdsi_call_history_list)
  ,WDS_HDLR( WDSI_CMD_VAL_CALL_HISTORY_READ,
             qmi_wdsi_call_history_read)
  ,WDS_HDLR( WDSI_CMD_VAL_CALL_HISTORY_DELETE,
             qmi_wdsi_call_history_delete)
  ,WDS_HDLR( WDSI_CMD_VAL_CALL_HISTORY_MAX_SIZE,
             qmi_wdsi_call_history_max_size)
  ,WDS_HDLR( WDSI_CMD_VAL_ROUTE_LOOK_UP,
            qmi_wdsi_route_look_up)
  ,WDS_HDLR( WDSI_CMD_VAL_INTERNAL_IFACE_EV_REGISTER,
             qmi_wdsi_internal_iface_ev_reg)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_INTERNAL_RUNTIME_SETTINGS,
            qmi_wdsi_get_internal_runtime_settings)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_INTERNAL_RUNTIME_SETTINGS,
            qmi_wdsi_set_internal_runtime_settings)
  ,WDS_HDLR( WDSI_CMD_VAL_REFRESH_DHCP_CONFIG_INFO,
             qmi_wdsi_refresh_dhcp_config_info)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_DEFAULT_PROFILE_NUM,
            qmi_wdsi_get_default_profile_num)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_DEFAULT_PROFILE_NUM,
            qmi_wdsi_set_default_profile_num)
  ,WDS_HDLR( WDSI_CMD_VAL_RESET_PROFILE_TO_DEFAULT,
            qmi_wdsi_reset_profile_to_default)
  ,WDS_HDLR( WDSI_CMD_VAL_RESET_PROFILE_PARAM_TO_INVALID,
            qmi_wdsi_reset_profile_param_to_invalid)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_CLIENT_IP_PREF,
            qmi_wdsi_set_client_ip_pref)
  ,WDS_HDLR( WDSI_CMD_VAL_FMC_SET_TUNNEL_PARAMS,
            qmi_wdsi_fmc_set_tunnel_params)
  ,WDS_HDLR( WDSI_CMD_VAL_FMC_CLEAR_TUNNEL_PARAMS,
            qmi_wdsi_fmc_clear_tunnel_params)
  ,WDS_HDLR( WDSI_CMD_VAL_FMC_GET_TUNNEL_PARAMS,
            qmi_wdsi_fmc_get_tunnel_params)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_AUTOCONNECT_SETTING,
             qmi_wdsi_set_autoconnect_setting)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_DNS_SETTING,
             qmi_wdsi_get_dns_setting)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_DNS_SETTING,
             qmi_wdsi_set_dns_setting)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_PRE_DORMANCY_CDMA_SETTINGS,
             qmi_wdsi_get_pre_dormancy_cdma_settings)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_CAM_TIMER,
             qmi_wdsi_set_cam_timer)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_CAM_TIMER,
             qmi_wdsi_get_cam_timer)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_SCRM,
             qmi_wdsi_set_scrm)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_SCRM,
             qmi_wdsi_get_scrm)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_RDUD,
             qmi_wdsi_set_rdud)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_RDUD,
             qmi_wdsi_get_rdud)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_SIP_MIP_CALL_TYPE,
             qmi_wdsi_get_sip_mip_call_type)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_EVDO_PAGE_MONITOR_PERIOD,
             qmi_wdsi_set_evdo_page_monitor_period)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_EVDO_FORCE_LONG_SLEEP,
             qmi_wdsi_set_evdo_force_long_sleep)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_EVDO_PAGE_MONITOR_PERIOD,
             qmi_wdsi_get_evdo_page_monitor_period)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_CALL_THROTTLE_INFO,
             qmi_wdsi_get_call_throttle_info)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_NSAPI,
             qmi_wdsi_get_nsapi)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_DUN_CTRL_PREF,
             qmi_wdsi_set_dun_ctrl_pref)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_DUN_CTRL_PREF,
             qmi_wdsi_get_dun_ctrl_pref)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_DUN_CTRL_EVENT_REPORT,
             qmi_wdsi_set_dun_ctrl_event_report)
  ,WDS_HDLR( WDSI_CMD_VAL_CONTROL_PENDING_DUN_CALL,
             qmi_wdsi_control_pending_dun_call)
  ,WDS_HDLR( WDSI_CMD_VAL_EMBMS_TMGI_ACTIVATE,
             qmi_wdsi_embms_tmgi_activate)
  ,WDS_HDLR( WDSI_CMD_VAL_EMBMS_TMGI_DEACTIVATE,
             qmi_wdsi_embms_tmgi_deactivate)
  ,WDS_HDLR( WDSI_CMD_VAL_EMBMS_TMGI_LIST_QUERY,
             qmi_wdsi_embms_tmgi_list_query)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_PREFERRED_DATA_SYSTEM,
             qmi_wdsi_get_preferred_data_system)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_LAST_DATA_CALL_STATUS,
             qmi_wdsi_get_last_data_call_status)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_CURRENT_DATA_SYSTEM_STATUS,
             qmi_wdsi_get_current_data_system_status)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_PDN_THROTTLE_INFO,
             qmi_wdsi_get_pdn_throttle_info)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_LTE_ATTACH_PARAMS,
             qmi_wdsi_get_lte_attach_params)
  ,WDS_HDLR( WDSI_CMD_VAL_RESET_PKT_STATISTICS,
             qmi_wdsi_reset_pkt_statistics)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_FLOW_CONTROL_STATUS,
             qmi_wdsi_get_flow_control_status)
  ,WDS_HDLR( WDSI_CMD_VAL_EMBMS_TMGI_ACT_DEACT,
             qmi_wdsi_embms_tmgi_act_deact)
  ,WDS_HDLR( WDSI_CMD_VAL_BIND_DATA_PORT,
             qmi_wdsi_bind_data_port)
#ifdef FEATURE_DATA_WLAN_MAPCON
  ,WDS_HDLR( WDSI_CMD_VAL_REV_IP_TRANSPORT_CONNECTION_IND_REG,
             qmi_wdsi_rev_ip_transport_connection_ind_reg) 
  ,WDS_HDLR( WDSI_CMD_VAL_GET_IPSEC_STATIC_SA_CONFIG,
             qmi_wdsi_get_ipsec_static_sa_config) 
  ,WDS_HDLR( WDSI_CMD_VAL_REV_IP_TRANSPORT_CONFIG_COMPLETE,
             qmi_wdsi_rev_ip_transport_config_complete) 
  ,WDS_HDLR( WDSI_CMD_VAL_GET_DATA_BEARER_TECHNOLOGY_EX,
             qmi_wdsi_get_data_bearer_technology_ex)
#endif /* FEATURE_DATA_WLAN_MAPCON */
#ifdef FEATURE_DATA_LTE
  ,WDS_HDLR( WDSI_CMD_VAL_GET_LTE_MAX_ATTACH_PDN_NUM,
            qmi_wds_get_lte_max_attach_pdn_list_num)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_LTE_ATTACH_PDN_LIST,
             qmi_wds_set_lte_attach_pdn_list)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_LTE_ATTACH_PDN_LIST,
             qmi_wds_get_lte_attach_pdn_list)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_LTE_DATA_RETRY,
             qmi_wds_set_lte_data_retry)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_LTE_DATA_RETRY,
             qmi_wds_get_lte_data_retry)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_LTE_ATTACH_TYPE,
             qmi_wds_set_lte_attach_type)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_LTE_ATTACH_TYPE,
             qmi_wds_get_lte_attach_type)
  ,WDS_HDLR( WDSI_CMD_VAL_UPDATE_LTE_ATTACH_PDN_LIST_PROFILES,
             qmi_wds_update_lte_attach_pdn_list_profiles)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_DATA_PATH,
             qmi_wdsi_set_data_path)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_DATA_PATH,
             qmi_wdsi_get_data_path)
#endif /* FEATURE_DATA_LTE */
#ifdef FEATURE_DATA_EMBMS
  ,WDS_HDLR( WDSI_CMD_VAL_EMBMS_SAI_LIST_QUERY,
             qmi_wdsi_embms_sai_list_query)
#endif /* FEATURE_DATA_EMBMS */
  ,WDS_HDLR( WDSI_CMD_VAL_BIND_MUX_DATA_PORT,
             qmi_wdsi_bind_mux_data_port)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_THRPT_INFO_IND_FREQ,
             qmi_wdsi_set_throughput_info_ind_freq)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_LAST_THRPT_INFO,
             qmi_wdsi_get_last_throughput_info)
#ifdef FEATURE_DATA_WLAN_MAPCON
  ,WDS_HDLR( WDSI_CMD_VAL_INITIATE_ESP_REKEY,
             qmi_wdsi_initiate_esp_rekey)
#endif /* FEATURE_DATA_WLAN_MAPCON */
  ,WDS_HDLR( WDSI_CMD_VAL_PROFILE_EVT_REG,
             qmi_wdsi_configure_profile_event_list)
  ,WDS_HDLR(   WDSI_CMD_VAL_GET_ROAMING_INFO,
               qmi_wdsi_get_roaming_info)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_CAPABILITIES,
             qmi_wdsi_get_capabilities)
#ifdef FEATURE_DATA_PS_DHCPV6
  ,WDS_HDLR( WDSI_CMD_VAL_GET_DELEGATED_IPV6_PREFIX,
             qmi_wdsi_get_delegated_ipv6_prefix)
  ,WDS_HDLR( WDSI_CMD_VAL_REMOVE_DELEGATED_IPV6_PREFIX,
             qmi_wdsi_remove_delegated_ipv6_prefix)
#endif /* FEATURE_DATA_PS_DHCPV6 */
  ,WDS_HDLR( WDSI_CMD_VAL_ABORT_GO_DORMANT,
             qmi_wdsi_abort_go_dormant)
  ,WDS_HDLR( WDSI_CMD_VAL_BIND_SUBSCRIPTION,
             qmi_wdsi_bind_subscription)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_BIND_SUBSCRIPTION,
             qmi_wdsi_get_bind_subscription)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_LTE_DATA_CALL_TYPE,
             qmi_wdsi_set_lte_data_call_type)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_DL_THRPT_INFO_IND_FREQ,
             qmi_wdsi_set_dl_thrpt_info_ind_freq)
  ,WDS_HDLR( WDSI_CMD_VAL_GET_MIN_DL_THRPT_INFO_PARAMS,
             qmi_wdsi_get_downlink_throughput_info_params)
  ,WDS_HDLR( WDSI_CMD_VAL_EMBMS_CONTENT_DESC_UPDATE,
             qmi_wdsi_embms_content_desc_update)
  ,WDS_HDLR( WDSI_CMD_VAL_SET_SILENT_REDIAL,
             qmi_wdsi_set_silent_redial)
  ,WDS_HDLR( WDSI_CMD_VAL_KEEP_ALIVE_DATA_SESSION,
            qmi_wdsi_keep_alive_data_session)
};

static ps_iface_type * qmi_wdsi_get_um_stat_iface
(
  ps_iface_type * rm_iface_ptr
);

static boolean qmi_wdsi_get_dun_data_count
(
  qmi_wdsi_data_byte_count_type * data_count
);

int16 qmi_wdsi_update_downlink_throughput_interval
(
  qmi_wdsi_client_state_type  * cl_sp_in,
  boolean                       client_inited,
  int16                       * ps_errno
);
/*---------------------------------------------------------------------------
  Each QMI link (usb, BT etc) has its own WDS state. The first
  QMI_INSTANCE_MAX instances are for legacy non-binding clients. Others
  are reserved for binding MUX clients. 
---------------------------------------------------------------------------*/
#define WDS_INSTANCE_MAX  (QMI_INSTANCE_MAX + 20)
static qmi_wdsi_state_type  * qmi_wds_state[WDSI_MAX_STATE][WDS_INSTANCE_MAX];

/*---------------------------------------------------------------------------
  QMI framework callback definition
---------------------------------------------------------------------------*/
static boolean qmi_wdsi_alloc_clid_cb
(
  qmi_framework_common_msg_hdr_type * svc_common_hdr  
);

static void qmi_wdsi_dealloc_clid_cb
(
  qmi_framework_common_msg_hdr_type * svc_common_hdr 
); 

static void qmi_wdsi_init_cb
(
  uint16 num_instances
);

static void qmi_wdsi_cmd_hdlr_cb
( 
  qmi_framework_msg_hdr_type* msg_hdr,
  dsm_item_type ** sdu 
);

/*---------------------------------------------------------------------------
  QMI framework command handler
---------------------------------------------------------------------------*/
static void qmi_wdsi_process_svc_init
(
  uint16 num_instances
);

static void qmi_wdsi_process_alloc_clid
(
  qmi_framework_common_msg_hdr_type * common_msg_hdr
);

static void qmi_wdsi_process_dealloc_clid
(
  qmi_framework_common_msg_hdr_type * common_msg_hdr
);

static void qmi_wdsi_process_cmd_hdlr
(
  qmi_framework_msg_hdr_type * msg_hdr,
  dsm_item_type * sdu 
);

static void qmi_wdsi_initialize_client
(
  qmi_wdsi_client_state_type  * cl_sp,
  uint8                         wds_inst,
  uint8                         clid
);

static boolean qmi_wdsi_send_response
(
  qmi_cmd_buf_type           * cmd_buf_p,
  dsm_item_type              * msg_ptr
);

static boolean qmi_wdsi_send_ind
(
  qmi_wdsi_state_type        * wds_sp,
  qmi_wdsi_client_state_type * client_sp,
  uint16                       cmd_type,
  uint32                       ind_size,
  void                       * ind_msg,
  boolean                      encoding_flag
);

static boolean qmi_wdsi_inst_bind
(
  uint8    wds_inst,
  uint32   ep_id,
  uint8    mux_id,
  boolean  is_reversed
);

static boolean qmi_wdsi_inst_unbind
(
  uint8    wds_inst
);

/*---------------------------------------------------------------------------
  QMI_WS instance configurations
---------------------------------------------------------------------------*/
static void qmi_wdsi_reset_client(void *);

static void qmi_wdsi_update_client(void *);

static void qmi_wdsi_sync_clients(uint8 inst);

static ds_qmi_fw_svc_cfg_type  qmi_wdsi_cfg;


/*===========================================================================

                   INTERNAL FUNCTION FORWARD DECLARATIONS

===========================================================================*/
static void qmi_wdsi_event_report_ind
(
  void *                                sp,
  uint8                                 clid,
  uint32                                event_mask,
  uint32                                tx_rate,
  uint32                                rx_rate,
  qmi_wdsi_stats_type *                 stats,
  qmi_wds_bearer_tech_e_type            data_bearer_tech,
  uint8                                 mip_status,
  qmi_wds_dormancy_status_e_type        dormancy_status,
  qmi_wdsi_curr_data_bearer_tech_type * curr_data_bearer_tech,
  uint32                                preferred_data_system,
  qmi_wdsi_call_status                  call_status,
  qmi_wdsi_data_call_e_type             data_call_type,
  uint8                                 addr_family,
  qmi_wdsi_evdo_page_monitor_period   * evdo_page_monitor_period,
  qmi_wdsi_curr_data_system_status_type * data_system_status,
  qmi_wdsi_additional_pdn_filters_removed_type * fltrs_removed,
  wds_delay_dormancy_result_type_v01           * delay_dorm_result
);

static qmi_wdsi_state_type *  qmi_wdsi_get_wds_sp_by_cl_sp(
                                qmi_wdsi_client_state_type *);

static qmi_wdsi_client_state_type * qmi_wdsi_get_cl_sp_by_clid_debug(qmi_wdsi_state_type *,uint8,int);
#define qmi_wdsi_get_cl_sp_by_clid(wds_sp,clid) qmi_wdsi_get_cl_sp_by_clid_debug(wds_sp,clid,__LINE__)

static boolean qmi_wdsi_net_if_bound(qmi_wdsi_state_type *);
static qmi_error_type_v01 qmi_wdsi_stop_net_iface_client
(
  qmi_wdsi_client_state_type *,
  qmi_wdsi_force_type ,
  boolean *
);
static void qmi_wdsi_set_pkt_stats_reports
(
  qmi_wdsi_client_state_type *,
  uint8,
  uint32
);
static void qmi_wdsi_pkt_stats_timer_cb(timer_cb_data_type);

static dsm_item_type *  wdsi_gen_start_network_interface_response
(
  qmi_error_type_v01  errval,
  void *            pkt_data_handle,
  qmi_wds_call_end_reason_e_type call_end_reason,
  uint32            call_end_reason_verbose,
  uint32            net_down_ep_id,
  uint8             net_down_mux_id
);

static void wdsi_net_iface_ev_cb
(
  ps_iface_type             *this_iface_ptr,
  ps_iface_event_enum_type   event,
  ps_iface_event_info_u_type event_info,
  void                      *user_data_ptr
);

static void wdsi_wlan_iface_ev_cb
(
  ps_iface_type             *this_iface_ptr,
  ps_iface_event_enum_type   event,
  ps_iface_event_info_u_type event_info,
  void                      *user_data_ptr
);

static void wdsi_um_phys_link_ev_hdlr_cb
(
  ps_phys_link_type            *this_phys_link_ptr,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  void                         *user_data_ptr
);

static void wdsi_dun_um_phys_link_ev_hdlr_cb
(
  ps_phys_link_type            *this_phys_link_ptr,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  void                         *user_data_ptr
);

static void wdsi_start_net_attempt_complete
(
  qmi_wdsi_state_type *  wds_sp,
  qmi_error_type_v01     errval
);

static void wdsi_stop_net_attempt_complete
(
  qmi_wdsi_state_type *  wds_sp
);

static void wdsi_media_connected(qmi_wdsi_state_type *, boolean);
static void wdsi_media_disconnected(qmi_wdsi_state_type *);
static uint8 wdsi_get_instance_from_wds_sp(void *);
static uint8 wdsi_get_inst_from_ep_and_mux_id (uint32, uint8);
static uint8 wdsi_get_unbound_inst(uint32, uint8, boolean);
static void wdsi_reg_um_phys_link_ev
(
  qmi_wdsi_state_type      * wds_sp
);
static void wdsi_dereg_um_phys_link_ev
(
  qmi_wdsi_state_type      * wds_sp
);
static void wdsi_reg_dun_um_phys_link_ev
(
  ps_iface_type            * um_iface_ptr
);
static void wdsi_dereg_dun_um_phys_link_ev
(
  ps_iface_type            * um_iface_ptr
);
static qmi_wds_call_end_reason_e_type qmi_wdsi_map_wds_call_end_reason
(
  ps_iface_net_down_reason_type iface_call_end_reason
);

void qmi_wdsi_generate_dormancy_status_ind
(
  void *                         sp,
  qmi_wds_dormancy_status_e_type dormancy_status
);

static qmi_wdsi_curr_data_bearer_tech_type wdsi_get_curr_data_bearer_tech
(
  ps_iface_bearer_technology_type bearer_tech_info
);

static void qmi_wdsi_dun_set_pkt_stats_reports
(
  qmi_wdsi_client_state_type *  cl_sp,
  uint8                         stat_ind_period,
  uint32                        stat_mask
);

static void qmi_wdsi_dun_stats_timer_cb(timer_cb_data_type);

void qmi_wdsi_generate_data_bearer_tech_ind
(
  qmi_wdsi_state_type *       wds_sp,
  qmi_wds_bearer_tech_e_type  data_bearer_tech
);

void qmi_wdsi_generate_dun_data_bearer_tech_ind
(
  qmi_wds_bearer_tech_e_type  data_bearer_tech
);

static qmi_wds_bearer_tech_e_type wdsi_get_data_bearer_tech
(
  qmi_wdsi_curr_data_bearer_tech_type bearer_tech_info
);

#ifndef FEATURE_DATA_WLAN_MAPCON
static boolean wdsi_data_bearer_tech_is_valid
(
  qmi_wdsi_curr_data_bearer_tech_type bearer_tech_info
);
#endif /* FEATURE_DATA_WLAN_MAPCON */

#ifdef FEATURE_DATA_WLAN_MAPCON
static void wdsi_get_current_data_bearer_tech
(
  ds_sys_system_status_info_type bearer_tech_ex_info,
  qmi_wdsi_curr_data_bearer_tech_type* data_bearer_tech
);

static boolean wdsi_add_rev_ip_connected_ind_params
(
  ps_iface_type                                    *this_iface_ptr,
  wds_reverse_ip_transport_connection_ind_msg_v01  *indication
);
#endif /* FEATURE_DATA_WLAN_MAPCON */

static void qmi_wdsi_generate_dun_channel_rate_ind
(
  qmi_if_ch_rate_trigger_e_type event,
  uint32                        subs_id
);

void qmi_wdsi_generate_dun_dormancy_status_ind
(
  qmi_wds_dormancy_status_e_type dormancy_status
);

static void qmi_wdsi_pbm_add
(
  qmi_wdsi_state_type   *wds_sp
);

#ifdef FEATURE_DATA_QMI_MCAST
static void qmi_wdsi_mcast_status_ind
(
  qmi_wdsi_state_type  *              wds_sp,
  qmi_wdsi_client_state_type *        cl_sp,
  qmi_wdsi_cmd_val_e_type             cmd,
  uint32                              mcast_handle,
  uint8                               mcast_status,
  ps_iface_mcast_info_code_enum_type  info_code
);

static void wdsi_reg_iface_mcast_event
(
  qmi_wdsi_state_type *  wds_sp
);

static void wdsi_dereg_iface_mcast_event
(
  qmi_wdsi_state_type *  wds_sp
);
#endif /* FEATURE_DATA_QMI_MCAST */

#ifdef FEATURE_EPC_HANDOFF
static void wdsi_reg_iface_handoff_event
(
  qmi_wdsi_state_type *  wds_sp
);
static void wdsi_dereg_iface_handoff_event
(
  qmi_wdsi_state_type *  wds_sp
);
static void qmi_wdsi_generate_handoff_ev_ind
(
   qmi_wdsi_state_type         * wds_sp,
   ps_iface_event_enum_type      event,
   ps_iface_event_info_u_type    event_info
);
#endif /* FEATURE_EPC_HANDOFF */
static void wdsi_reg_iface_embms_event
(
  qmi_wdsi_state_type *  wds_sp
);
static void wdsi_dereg_iface_embms_event
(
  qmi_wdsi_state_type *  wds_sp
);
static void wdsi_request_available_embms_events
(
  qmi_wdsi_state_type *  wds_sp
);
static boolean wdsi_copy_tmgi_list_from_event
(
  ps_iface_event_enum_type   event,
  ps_iface_event_info_u_type * event_info,
  qmi_wdsi_cmd_buf_type      * cmd_ptr
);
#ifdef FEATURE_DATA_EMBMS
static boolean wdsi_copy_sai_list_from_event
(
  ps_iface_event_enum_type     event,
  ps_iface_event_info_u_type * event_info,
  qmi_wdsi_cmd_buf_type      * cmd_ptr
);
#endif /* FEATURE_DATA_EMBMS */
static boolean wdsi_copy_embms_content_desc_update
(
  ps_iface_event_enum_type     event,
  ps_iface_event_info_u_type * event_info,
  qmi_wdsi_cmd_buf_type      * cmd_ptr
);
static void qmi_wdsi_generate_embms_ev_ind
(
   qmi_wdsi_state_type         * wds_sp,
   ps_iface_event_enum_type      event,
   ps_iface_event_info_u_type    event_info
);
static void qmi_wdsi_tmgi_status_ind
(
  qmi_wdsi_state_type         * wds_sp,
  qmi_wdsi_client_state_type  * cl_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info
);
static void qmi_wdsi_tmgi_act_deact_ind
(
  qmi_wdsi_state_type         * wds_sp,
  qmi_wdsi_client_state_type  * cl_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info
);
static void qmi_wdsi_tmgi_list_ind
(
  qmi_wdsi_state_type         * wds_sp,
  qmi_wdsi_client_state_type  * cl_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  boolean                       modem_inited
);
#ifdef FEATURE_DATA_EMBMS
static void qmi_wdsi_sai_list_ind
(
  qmi_wdsi_state_type         * wds_sp,
  qmi_wdsi_client_state_type  * cl_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  boolean                       modem_inited
);
#endif /* FEATURE_DATA_EMBMS */
static void qmi_wdsi_embms_content_desc_control_ind
(
  qmi_wdsi_state_type         * wds_sp,
  qmi_wdsi_client_state_type  * cl_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  boolean                       modem_inited
);
static void wdsi_tmgi_send_response(
  qmi_cmd_buf_type            * cmd_buf_p,
  dsm_item_type               * response,
  qmi_error_type_v01            errval,
  boolean                       is_result_needed);

static void wdsi_tmgi_clean_pend_req(
  qmi_wdsi_state_type         * wds_sp,
  qmi_error_type_v01            errval);

static void wdsi_um_iface_ev_cb
(
  ps_iface_type             *iface_ptr,
  ps_iface_event_enum_type   event,
  ps_iface_event_info_u_type event_info,
  void                      *user_data_ptr
);

void qmi_wdsi_generate_internal_iface_ev_ind
(
  qmi_wdsi_state_type *      wds_sp,
  qmi_wdsi_int_if_ev_e_type  event,
  ps_iface_event_info_u_type event_info
);

static void qmi_wdsi_internal_iface_ev_ind
(
  qmi_wdsi_state_type *          wds_sp,
  qmi_wdsi_client_state_type *   cl_sp,
  qmi_wdsi_int_if_ev_e_type       event,
  ps_iface_event_info_u_type     event_info
);
static void wdsi_reg_internal_um_iface_ev
(
  qmi_wdsi_state_type      * wds_sp
);
static void wdsi_reg_um_iface_ev
(
  qmi_wdsi_state_type      * wds_sp
);
static void wdsi_dereg_internal_um_iface_ev
(
  qmi_wdsi_state_type      * wds_sp
);
static void wdsi_dereg_um_iface_ev
(
  qmi_wdsi_state_type      * wds_sp
);

static void wdsi_dereg_wlan_iface_ev
(
  qmi_wdsi_state_type      * wds_sp
);

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
void qmi_wds_call_thr_hdlr
(
  void    *call_throttle_info,
  int16    ps_errno
);
static dsm_item_type * qmi_wdsi_gen_call_throttle_info_response
(
  ds707_call_throttle_info             call_throttle_info,
  qmi_error_type_v01                   errval
);
static void qmi_wdsi_call_throttle_info_request_complete
(
  ds707_call_throttle_info             call_throttle_info,
  int16                                ps_errno
);
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

static void wdsi_alloc_event_cback_buf
(
  qmi_wdsi_state_type      * wds_sp
);

static void wdsi_alloc_wlan_event_cback_buf
(
  qmi_wdsi_state_type      * wds_sp
);

static void wdsi_data_system_status_change_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
);

#if (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && (defined(FEATURE_DS_MOBILE_IP))
#if defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE)
#ifdef FEATURE_MMGSDI_SESSION_LIB
static qmi_error_type_v01 qmi_wdsi_check_uim_access_status
(
  void
);
#endif /* FEATURE_MMGSDI_SESSION_LIB */
#endif /* defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */
#endif /* (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && (defined(FEATURE_DS_MOBILE_IP))*/

static void qmi_wdsi_generate_pkt_stats_ind( uint8 );
static void qmi_wdsi_generate_dun_pkt_stats_ind( uint8 );

static void qmi_wdsi_process_um_iface_event
(
  ps_iface_type            *,
  ps_iface_event_enum_type  ,
  ps_iface_event_info_u_type,
  void                     *
);

static void qmi_wdsi_process_phys_link_event
(
  ps_phys_link_type           *,
  ps_iface_event_enum_type     ,
  ps_iface_event_info_u_type   ,
  void                        *
);

static void qmi_wdsi_process_dun_phys_link_event
(
  ps_phys_link_type           *,
  ps_iface_event_enum_type     ,
  ps_iface_event_info_u_type   ,
  void                        *
);

static void qmi_wdsi_generate_dun_call_info_ind
(
  ps_iface_event_enum_type   ,
  ps_iface_type             *,
  ps_iface_event_info_u_type ,
  ps_iface_name_enum_type
);

static void qmi_wdsi_process_wlan_iface_evt
(
  ps_iface_event_enum_type   ,
  ps_iface_type             *,
  ps_iface_event_info_u_type ,
  void *
);

static void qmi_wdsi_process_data_call_status_change(uint32,
                                                     qmi_wdsi_data_call_e_type,
                                                     uint8,
                                                     uint32);


static void qmi_wdsi_generate_data_system_status_ind
(
  qmi_wdsi_curr_data_system_status_type  data_system_status,
  uint32                                 subscription_id
);
static void qmi_wdsi_generate_extended_ip_config_ev_ind
(
  qmi_wdsi_state_type                       *wds_sp,
  ps_iface_ioctl_extended_ip_config_ex_type  config_change_mask
);
static void qmi_wdsi_extended_ip_config_ev_ind
(
  qmi_wdsi_state_type         * wds_sp,
  uint8                                      cl_id,
  ps_iface_ioctl_extended_ip_config_ex_type  config_change_mask
);

#ifdef FEATURE_DATA_LTE
static void qmi_wdsi_generate_lte_attach_pdn_list_change_ind
(
   qmi_wds_lte_attach_pdn_list_type lte_attach_pdn_list,
   uint32   subscription_id
);
static void qmi_wdsi_lte_attach_pdn_list_change_ind
(
  qmi_wdsi_state_type               * wds_sp,
  uint8                               cl_id,
  qmi_wds_lte_attach_pdn_list_type * lte_attach_pdn_list
);
#endif /* FEATURE_DATA_LTE */

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
static void qmi_wdsi_generate_evdo_pmp_change_ind
(
  qmi_wdsi_evdo_page_monitor_period epmp,
  uint32                            subs_id
);
static void qmi_wdsi_generate_evdo_pmp_result_ind(int16 evt, 
       ps_hdr_slotted_mode_failure_code_enum_type failure_code);
static uint8  wdsi_xlate_app_scm_to_hdr_enum (uint8  app_scm);
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

static uint32 wdsi_xlate_data_system_status_to_pref_data_sys
(
  uint8            preferred_network,
  uint32           rat_mask
);

static void qmi_wdsi_process_cmd(void *);

static void *qmi_wdsi_get_cmd_buf(qmi_cmd_id_e_type);

static qmi_error_type_v01 qmi_wdsi_validate_ip_family_pref(uint8  ip_family_pref);

#define qmi_wdsi_free_cmd_buf(buf_ptr) PS_SYSTEM_HEAP_MEM_FREE(buf_ptr)

static void qmi_wdsi_get_rmnet_data_call_type
(
  qmi_wdsi_data_call_e_type *,
  rmnet_instance_e_type 
);

static qmi_error_type_v01  qmi_wdsi_map_mh_failure_reason_debug( int16, int);
#define qmi_wdsi_map_mh_failure_reason(ps_errno) qmi_wdsi_map_mh_failure_reason_debug(ps_errno,__LINE__)

static void qmi_wdsi_entitlement_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
);

static void qmi_wdsi_silent_redial_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
);

#ifdef FEATURE_DATA_LTE
static void qmi_wdsi_lte_attach_pdn_list_change_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
);
#endif /* FEATURE_DATA_LTE */

#define CHECK_TRUE(val) ((val)? TRUE: FALSE)

static void qmi_wdsi_process_dun_rmsm_event(
                               qmi_wdsi_dun_ctrl_event_e_type, boolean,
                               ps_sys_tech_enum_type, unsigned char, 
                               ps_iface_net_down_reason_type,
                               uint32 );

static void qmi_wdsi_dun_ctrl_call_complete_ind(boolean, uint32);

static void qmi_wdsi_generate_dun_ctrl_ind(
                           qmi_wdsi_state_type*, qmi_wdsi_client_state_type*,
                           qmi_wdsi_dun_ctrl_event_e_type, boolean );

static void qmi_wdsi_init_dun_ctrl_pref_to_default(void);

static void qmi_wdsi_dun_ctrl_call_cleanup(uint32);

static void qmi_wdsi_dun_call_control_timer_cb(timer_cb_data_type);

static void qmi_wdsi_process_flow_ctrl_event 
(
   uint32                     ep_id,
   uint8                      mux_id,
   uint8                      is_v6,
   boolean                    uplink_flow_ctrl,
   boolean                    call_ending
);

static void qmi_wdsi_generate_flow_ctrl_ind
(
  qmi_wdsi_state_type *       wds_sp,
  boolean                     uplink_flow_ctrl,
  uint16                      fc_seq_num
);

static void wdsi_profile_change_cb
(
  ds_profile_event_etype          event,
  unsigned int                    profile_count,
  ds_profile_changes_info       * profiles_changes,
  void                          * user_data,
  ds_profile_subs_etype           subs_id
);

static void wdsi_process_profile_changed_event
(
  ds_profile_event_etype              event,
  uint32                              profile_count,
  ds_profile_changes_info           * profiles_changes,
  uint32                              subs_id
);
static void qmi_wdsi_thrpt_info_change_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
);

static void qmi_wdsi_roaming_info_change_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
);

static void qmi_wdsi_generate_rev_ip_connected_ind
(
  void           * cl_sp
);

static void qmi_wdsi_generate_roaming_info_change_ind
(
  ps_sys_roaming_disallowed_info_type           * roaming_info_list,
  uint32                                          subscription_id
);

static void qmi_wdsi_generate_thrpt_info_change_ind
(
  ps_sys_throughput_info_list_type  * thrpt_info_list,
  uint32                              subscription_id
);

static void qmi_wdsi_thrpt_info_list_change_ind
(
  qmi_wdsi_state_type *                 wds_sp,
  uint8                                 cl_id,
  ps_sys_throughput_info_list_type   *  thrpt_info_list
);

static boolean qmi_wdsi_convert_throughput_info
(
   ps_sys_throughput_info_list_type  *  thrpt_info_list,
   uint32 *                             throughput_info_len,
   wds_throughput_info_type_v01*        thrpt_info
);

static boolean qmi_wdsi_process_bind_data_port
(
  qmi_wdsi_client_state_type  * cl_sp,
  uint8                         bind_inst
);

static boolean qmi_wdsi_verify_client_subs
(
  qmi_wdsi_client_state_type         * cl_sp,
  uint32                               event_subs_id,
  boolean                              call_specific
);

static void qmi_wdsi_reg_ps_sys_events
(  
  void
);

static void qmi_wdsi_outage_notification_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
);

static void qmi_wdsi_generate_outage_notifcation_ind
(
   ps_sys_event_outage_notification_type outage_info,
   uint32                                subscription_id
);

static void qmi_wdsi_dl_thrpt_info_change_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
);

static void qmi_wdsi_generate_dl_thrpt_info_change_ind
(
  ps_sys_dl_throughput_info_type    dl_thrpt_info,
  uint32                            subscription_id
);

static void qmi_wdsi_dl_thrpt_info_list_change_ind
(
  qmi_wdsi_state_type *                 wds_sp,
  uint8                                 cl_id,
  ps_sys_dl_throughput_info_type      * dl_thrpt_info_ptr
);

static void qmi_wdsi_generate_apn_param_changed_ind
(
   qmi_wdsi_state_type         * wds_sp,
   ps_iface_event_enum_type      event,
   ps_iface_event_info_u_type    event_info
);

/*===========================================================================

                        EXTERNAL FUNCTION DEFINITIONS

===========================================================================*/

/*===========================================================================
  FUNCTION QMI_WDSI_INIT_INT()

  DESCRIPTION
    Initialize WDS Service for one QMI instance

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_init_int
(
  uint8                 wds_inst,
  qmi_wdsi_state_type * wds_sp,
  uint8                 is_default
)
{
   ps_iface_event_enum_type      err_ev = IFACE_EVENT_MAX;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset( wds_sp, 0, sizeof(qmi_wdsi_state_type) );

  wds_sp->pkt_svc_state = QMI_WDS_CONN_DISCONNECTED;
  memset (&wds_sp->sni_pend_q, 0, sizeof(q_type));
  (void) q_init( &wds_sp->sni_pend_q );
  wds_sp->stop_ni_cmd_buf_p = NULL;

  /*-------------------------------------------------------------------------
    Initialize the ps_iface/phys_link cback buf_ptrs for Um Iface, Net Iface
    and Physlink event handling.
  -------------------------------------------------------------------------*/
  wdsi_alloc_event_cback_buf( wds_sp );

  /*-------------------------------------------------------------------------
    Allocate extra buffers for reverse IP transport. This is only needed
    for WDS states in the MUX section (inst >= QMI_INSTANCE_MAX).
  -------------------------------------------------------------------------*/
  if (wds_inst >= QMI_INSTANCE_MAX)
  {
    wdsi_alloc_wlan_event_cback_buf( wds_sp );
  }
  /*-------------------------------------------------------------------------
    Register at power up for interested IFACE events which are not tied to
    a data call
  -------------------------------------------------------------------------*/
  do
  {
     if(0 != ps_iface_event_cback_reg(NULL,
                                      IFACE_MT_REQUEST_EV,
                                      wds_sp->um_iface_mt_request_buf_ptr ) )
     {
        err_ev = IFACE_MT_REQUEST_EV;
        break;
     }
  }while(0);
 
  if(err_ev != IFACE_EVENT_MAX)
  {
    LOG_MSG_ERROR_1("Couldn't register for Iface Event %d",err_ev);
    ASSERT(0);
    return;
  }

  wds_sp->constants.wds_inst = wds_inst;
  wds_sp->constants.is_default = is_default;
  wds_sp->binding.rmnet_inst = RMNET_INSTANCE_MAX;
  wds_sp->binding.subscription_id = QMI_WDSI_SUBS_DEFAULT;

  if (is_default)
  {
    wds_sp->is_primary_state = TRUE;
    wds_sp->cur_ip_call_type = QMI_AF_INET;
  }
  else
  {
    wds_sp->is_primary_state = FALSE;
    wds_sp->cur_ip_call_type = QMI_AF_INET6;
  }

  wds_sp->uplink_flow_ctrl = FALSE;
  wds_sp->uplink_fc_seq_num = 0;

} /* qmi_wdsi_init_int() */

/*===========================================================================
  FUNCTION QMI_WDS_INIT()

  DESCRIPTION
    Register the Wireless Data Service with QMUX for all applicable QMI links

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_wds_init
(
  void
)
{
  qmi_framework_err_e_type        reg_result;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    Setting QMI WDS service command handler with dcc task process
  -------------------------------------------------------------------------*/
  qmi_task_set_svc_cmd_handler(QMUX_SERVICE_WDS, qmi_wdsi_process_cmd);

  /*-------------------------------------------------------------------------
    QMI WDS service configuration setup
  -------------------------------------------------------------------------*/
  memset(&qmi_wdsi_cfg, 0, sizeof(qmi_wdsi_cfg));

  qmi_wdsi_cfg.fw_cfg.base_version.major     = WDSI_BASE_VER_MAJOR;
  qmi_wdsi_cfg.fw_cfg.base_version.minor     = WDSI_BASE_VER_MINOR;
  qmi_wdsi_cfg.fw_cfg.addendum_version.major = WDSI_ADDENDUM_VER_MAJOR;
  qmi_wdsi_cfg.fw_cfg.addendum_version.minor = WDSI_ADDENDUM_VER_MINOR;

  qmi_wdsi_cfg.fw_cfg.cbs.alloc_clid         = qmi_wdsi_alloc_clid_cb;
  qmi_wdsi_cfg.fw_cfg.cbs.dealloc_clid       = qmi_wdsi_dealloc_clid_cb;
  qmi_wdsi_cfg.fw_cfg.cbs.init_cback         = qmi_wdsi_init_cb;
  qmi_wdsi_cfg.fw_cfg.cbs.cmd_hdlr           = qmi_wdsi_cmd_hdlr_cb;
  
  qmi_wdsi_cfg.cmd_hdlr_array    = qmi_wdsi_cmd_callbacks;
  qmi_wdsi_cfg.cmd_num_entries   = sizeof(qmi_wdsi_cmd_callbacks) /
                                   sizeof(qmi_wdsi_cmd_callbacks[0]);

  /*-------------------------------------------------------------------------
    Calling QMI Framework API to register the service with Framework
  -------------------------------------------------------------------------*/
  reg_result = qmi_framework_reg_service( QMUX_SERVICE_WDS, &qmi_wdsi_cfg.fw_cfg );

  if (reg_result != QMI_FRAMEWORK_ERR_NONE)
  {
    return;
  }

  wds_svc_obj = wds_get_service_object_v01();
  (void) qmi_si_register_object ( wds_svc_obj,
                                  0, /* Service Instance */
                                  wds_get_service_impl_v01() );

  qmi_wdsi_cfg.registered = TRUE;
  LOG_MSG_INFO1_0("QMI WDS service init: service registered with QMI Framework");

} /* qmi_wds_init() */

/*===========================================================================
FUNCTION QMI_WDSI_INIT_CB()

  DESCRIPTION
  Function gets called from framework whenever the QMI WDS service registers with
  framework. This function posts a DCC command for the service to handle this
  callback.
    
  PARAMETERS
  num_instances : getting Num of QMI instances at run time.

  RETURN VALUE
  None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_init_cb
(
  uint16 num_instances
)
{
  qmi_wdsi_cmd_buf_type * cmd_ptr;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)
                 qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_INIT_CB);
  if( cmd_ptr == NULL)
  {
    return;
  }

  memset(cmd_ptr, 0, sizeof(qmi_wdsi_cmd_buf_type));
  cmd_ptr->cmd_id = QMI_CMD_WDS_INIT_CB;
  cmd_ptr->data.init_cb.num_instances = num_instances;

  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);

} /* qmi_wdsi_init_cb() */

/*===========================================================================
FUNCTION QMI_WDSI_ALLOC_CLID_CB()

DESCRIPTION
  Function gets called from framework whenever a clid is allocated by the
  framework for QMI WDS service. This function posts a DCC command for the
  service to handle this callback.

PARAMETERS
  common_msg_hdr  : QMI Framework common msg hdr

RETURN VALUE
  Boolean : TRUE if the clid set properly
          : FALSE, otherwise
DEPENDENCIES
  None

SIDE EFFECTS
  None
===========================================================================*/
static boolean qmi_wdsi_alloc_clid_cb
(  
  qmi_framework_common_msg_hdr_type * common_msg_hdr  
)
{
  qmi_wdsi_cmd_buf_type * cmd_ptr;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(common_msg_hdr);

  LOG_MSG_INFO3_2("qmi_wdsi_alloc_clid_cb: clid: %d, QMI inst: %d",
                  common_msg_hdr->client_id, common_msg_hdr->qmi_instance);

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)
                qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_ALLOC_CLID_CB);
  if(cmd_ptr == NULL)
  {
    return FALSE;
  }

  memset(cmd_ptr, 0, sizeof(qmi_wdsi_cmd_buf_type));
  cmd_ptr->cmd_id = QMI_CMD_WDS_ALLOC_CLID_CB;
  cmd_ptr->data.clid_cb.common_msg_hdr = *common_msg_hdr;

  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
  return TRUE;

} /* qmi_wdsi_alloc_clid_cb() */

/*===========================================================================
FUNCTION QMI_WDSI_DEALLOC_CLID_CB()

DESCRIPTION 
  Function gets called from framework whenever a clid is deallocated by the
  framework for QMI WDS service. This function posts a DCC command for the
  service to handle this callback.

PARAMETERS
  common_msg_hdr  : QMI Framework common msg hdr

RETURN VALUE
  None
 
DEPENDENCIES
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_dealloc_clid_cb
(  
  qmi_framework_common_msg_hdr_type * common_msg_hdr  
)
{
  qmi_wdsi_cmd_buf_type * cmd_ptr;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(common_msg_hdr);
  LOG_MSG_INFO3_2("QMI WDS dealloc clid cb: clid: %d, QMI inst: %d",
                  common_msg_hdr->client_id, common_msg_hdr->qmi_instance);

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)
                qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_DEALLOC_CLID_CB);
  if( cmd_ptr == NULL)
  {
    return;
  }

  memset(cmd_ptr, 0, sizeof(qmi_wdsi_cmd_buf_type));
  cmd_ptr->cmd_id = QMI_CMD_WDS_DEALLOC_CLID_CB;
  cmd_ptr->data.clid_cb.common_msg_hdr = *common_msg_hdr;

  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);

} /* qmi_wdsi_dealloc_clid_cb */

/*===========================================================================
  FUNCTION QMI_WDSI_CMD_HDLR_CB()

  DESCRIPTION
    Function gets called from framework whenever a new QMI WDS request
    message is received. This function posts a DCC command for the
    service to handle this callback.

  PARAMETERS
    msg_hdr  :  msg hdr
    sdu : dsm item
 
  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void  qmi_wdsi_cmd_hdlr_cb
( 
  qmi_framework_msg_hdr_type * msg_hdr,
  dsm_item_type             ** sdu 
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(msg_hdr);
  LOG_MSG_INFO3_3("qmi_wdsi_cmd_hdlr_cb: clid: %d, QMI inst: %d, tx_id: %d",
                  msg_hdr->common_hdr.client_id,
                  msg_hdr->common_hdr.qmi_instance,
                  msg_hdr->common_hdr.transaction_id);
  
  cmd_ptr = (qmi_wdsi_cmd_buf_type *)
                 qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_CMD_HDLR_CB);
  if( cmd_ptr == NULL)
  {
    return;
  }

  memset(cmd_ptr, 0, sizeof(qmi_wdsi_cmd_buf_type));
  cmd_ptr->cmd_id = QMI_CMD_WDS_CMD_HDLR_CB;
  cmd_ptr->data.cmd_hdlr_cb.msg_hdr = *msg_hdr;
  cmd_ptr->data.cmd_hdlr_cb.sdu_in  = *sdu;

  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);

} /* qmi_wdsi_cmd_hdlr_cb() */

/*===========================================================================
  FUNCTION QMI_WDSI_PROCESS_SVC_INIT()

  DESCRIPTION
    This function processes a init callback request and intialize the service
    related infos.

  PARAMETERS
    num_instances:  nnumber of QMI Instances

  RETURN VALUE
    None

  DEPENDENCIES
    QMI WDS must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_process_svc_init
(
  uint16 num_instances
)
{
  ps_iface_event_enum_type      err_ev = IFACE_EVENT_MAX;
  boolean                       is_err = FALSE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* check that num_instances is within range in case ASSERT is removed */
  if (num_instances > QMI_INSTANCE_MAX)
  {
    LOG_MSG_ERROR_1("QMI num inst out of range (%d)!", num_instances);
    ASSERT(0);
    return;
  }

  if (qmi_wdsi_global.inited == FALSE)
  {
    qmi_wdsi_global.dun_state = QMI_WDS_CONN_DISCONNECTED;
    qmi_wdsi_global.dun_subs_id = QMI_WDSI_SUBS_DEFAULT;

    ds_qmi_cflog_amss_call("ps_iface_alloc_event_cback_buf(5 times)");
    do
    {
       qmi_wdsi_global.dun_iface_up_ev_buf_ptr =
          ps_iface_alloc_event_cback_buf( wdsi_dun_iface_ev_cb, NULL );
       if(qmi_wdsi_global.dun_iface_up_ev_buf_ptr == NULL)
       {
         is_err = TRUE;
         break;
       }

       qmi_wdsi_global.dun_iface_routeable_ev_buf_ptr =
         ps_iface_alloc_event_cback_buf( wdsi_dun_iface_ev_cb, NULL );
       if(qmi_wdsi_global.dun_iface_routeable_ev_buf_ptr == NULL)
       {
         is_err = TRUE;
         break;
       }
   
       qmi_wdsi_global.dun_iface_down_ev_buf_ptr =
         ps_iface_alloc_event_cback_buf( wdsi_dun_iface_ev_cb, NULL );
       if(qmi_wdsi_global.dun_iface_down_ev_buf_ptr == NULL)
       {
         is_err = TRUE;
         break;
       }
   
       qmi_wdsi_global.dun_iface_active_in_use_ev_buf_ptr =
            ps_iface_alloc_event_cback_buf( wdsi_dun_iface_ev_cb, NULL );
          if(qmi_wdsi_global.dun_iface_active_in_use_ev_buf_ptr == NULL)
       {
         is_err = TRUE;
         break;
       }

       qmi_wdsi_global.dun_iface_out_of_use_ev_buf_ptr =
            ps_iface_alloc_event_cback_buf( wdsi_dun_iface_ev_cb, NULL );
       if(qmi_wdsi_global.dun_iface_out_of_use_ev_buf_ptr == NULL)
       {
         is_err = TRUE;
         break;
       }
   
       qmi_wdsi_global.um_iface_bearer_tech_change_buf_ptr =
         ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, NULL );
          if(qmi_wdsi_global.um_iface_bearer_tech_change_buf_ptr == NULL)
       {
         is_err = TRUE;
         break;
       }
   }while(0);

   if (is_err == TRUE)
   {
     ASSERT(0);
   }

   do{  
       if(0 != ps_iface_event_cback_reg( NULL,
                                         IFACE_UP_EV,
                                         qmi_wdsi_global.dun_iface_up_ev_buf_ptr ) )
       {
          /*update err_ev and print at once*/
          err_ev = IFACE_UP_EV;
          break;
       }
   
       if(0 != ps_iface_event_cback_reg( NULL,
                                         IFACE_ROUTEABLE_EV,
                                         qmi_wdsi_global.dun_iface_routeable_ev_buf_ptr ) )
       {
          err_ev = IFACE_ROUTEABLE_EV;
          break; 
       }

       if(0 != ps_iface_event_cback_reg( NULL,
                                         IFACE_DOWN_EV,
                                         qmi_wdsi_global.dun_iface_down_ev_buf_ptr ) )
       {
          err_ev = IFACE_DOWN_EV;
          break; 
       }
   
       if(0 != ps_iface_event_cback_reg(NULL,
                                        IFACE_ACTIVE_OUT_OF_USE_EV,
                                        qmi_wdsi_global.dun_iface_out_of_use_ev_buf_ptr ) )
       {
          err_ev = IFACE_ACTIVE_OUT_OF_USE_EV;
          break; 
       }

       if(0 != ps_iface_event_cback_reg( NULL,
                                         IFACE_ACTIVE_IN_USE_EV,
                                         qmi_wdsi_global.dun_iface_active_in_use_ev_buf_ptr ) )
       {
           err_ev = IFACE_ACTIVE_IN_USE_EV;
           break;
       }
   
      #ifdef FEATURE_DATA_WLAN_MAPCON
       if(0 != ps_iface_event_cback_reg(NULL,
                                        IFACE_BEARER_TECH_EX_CHANGED_EV,
                                        qmi_wdsi_global.um_iface_bearer_tech_change_buf_ptr
                                        ) )
         {
           err_ev = IFACE_BEARER_TECH_EX_CHANGED_EV;
           break; 
         }
      #else
          if(0 != ps_iface_event_cback_reg(NULL,
                                        IFACE_BEARER_TECH_CHANGED_EV,
                                        qmi_wdsi_global.um_iface_bearer_tech_change_buf_ptr
                                        ) )
         {
            err_ev = IFACE_BEARER_TECH_CHANGED_EV;
            break; 
         }
    #endif /* FEATURE_DATA_WLAN_MAPCON */
    }while(0);
   
    if(err_ev != IFACE_EVENT_MAX)
    {
      LOG_MSG_ERROR_1("Couldn't register for UM Iface event %d",err_ev);
      ASSERT( 0 );
      return;
    }

    /*---------------------------------------------------------------------
      Initialize the DUN phys_link cback buf_ptrs for Um phys_link event handling.
      Events are registered later when the call comes up.
     ---------------------------------------------------------------------*/
    ds_qmi_cflog_amss_call("ps_phys_link_alloc_event_cback_buf(2 times)");
    qmi_wdsi_global.dun_um_phys_link_up_buf_ptr =
    ps_phys_link_alloc_event_cback_buf( wdsi_dun_um_phys_link_ev_hdlr_cb,
                                        (void *) &qmi_wdsi_global );
    ASSERT(qmi_wdsi_global.dun_um_phys_link_up_buf_ptr);

    qmi_wdsi_global.dun_um_phys_link_down_buf_ptr =
    ps_phys_link_alloc_event_cback_buf( wdsi_dun_um_phys_link_ev_hdlr_cb,
                                        (void *) &qmi_wdsi_global );
    ASSERT(qmi_wdsi_global.dun_um_phys_link_down_buf_ptr);


    /*-------------------------------------------------------------------------
      Register at power up for interested System Events.
    -------------------------------------------------------------------------*/
    qmi_wdsi_reg_ps_sys_events();

    memset (&qmi_wdsi_global.call_thr_pend_q, 0, sizeof(q_type));
    (void) q_init( &qmi_wdsi_global.call_thr_pend_q );

  #if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)

    memset (&qmi_wdsi_global.evdo_pmp_pend_q, 0, sizeof(q_type));
    (void) q_init( &qmi_wdsi_global.evdo_pmp_pend_q );
  #endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

    /* Initialize the DUN parameters to sane defaults. */
    qmi_wdsi_init_dun_ctrl_pref_to_default();

    /* Initialize the DUN call control timer */
    timer_def( &(qmi_wdsi_global.dun_call_control_timer),
               NULL,
               rex_self(),
               0,
               qmi_wdsi_dun_call_control_timer_cb,
               (timer_cb_data_type)0);

    /* QMI instance state init is postphoned until a client is registered  */
    qmi_wdsi_global.inited = TRUE;
  }

} /* qmi_wdsi_process_svc_init() */

/*===========================================================================
  FUNCTION QMI_WDSI_CHECK_AND_ALLOC_WDS_SP()

  DESCRIPTION
    This function check and allocates wds state for both v4 and v6 instance.

  PARAMETERS
    wds_inst: WDS instance

  RETURN VALUE
    TRUE: Success. FALSE: Failure  

  DEPENDENCIES

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_wdsi_check_and_alloc_wds_sp
(
  uint32   wds_inst
)
{
  qmi_wdsi_state_type * v4_sp;
  qmi_wdsi_state_type * v6_sp;
  boolean ret_val = FALSE;
/*-------------------------------------------------------------------------*/

  if (wds_inst >= WDS_INSTANCE_MAX)
  {
    LOG_MSG_ERROR_1("Invalid wds inst %d", wds_inst);
    ASSERT(0);
    ret_val = FALSE;
    goto send_result;
  }

  // Check if WDS states are already allocated
  if ( (qmi_wds_state[WDSI_IPV4_STATE][wds_inst] != NULL) &&
       (qmi_wds_state[WDSI_IPV6_STATE][wds_inst] != NULL) )
  {
    ret_val = TRUE;
    goto send_result;
  }

  // Allocate both V4 and V6 WDS states
  PS_SYSTEM_HEAP_MEM_ALLOC(v4_sp, sizeof(qmi_wdsi_state_type),
                           qmi_wdsi_state_type*);
  if (v4_sp == NULL)
  {
    ret_val = FALSE;
    goto send_result;
  }

  PS_SYSTEM_HEAP_MEM_ALLOC(v6_sp, sizeof(qmi_wdsi_state_type),
                           qmi_wdsi_state_type*);
  if (v6_sp == NULL)
  {
    PS_SYSTEM_HEAP_MEM_FREE(v4_sp);
    ret_val = FALSE;
    goto send_result;
  }

  qmi_wdsi_init_int((uint8)wds_inst, v4_sp, 1);
  qmi_wdsi_init_int((uint8)wds_inst, v6_sp, 0);

  qmi_wds_state[WDSI_IPV4_STATE][wds_inst] = v4_sp;
  qmi_wds_state[WDSI_IPV6_STATE][wds_inst] = v6_sp;
  ret_val = TRUE;

send_result:
  LOG_MSG_INFO1_2("qmi_wdsi_check_and_alloc_wds_sp: qmi_inst:%d, ret_val:%d",wds_inst,ret_val);
  return ret_val;

} /* qmi_wdsi_check_and_alloc_wds_sp() */

/*===========================================================================
  FUNCTION WDSI_ALLOC_CLID()

  DESCRIPTION
    This function allocates and initialize the new client state for the
    allocated client ID.

  PARAMETERS
    common_msg_hdr: data buffer containing the clid alloc request.

  RETURN VALUE
    TURE:  Success
    FALSE: Failure

  DEPENDENCIES
    QMI WDS must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static boolean wdsi_alloc_clid
(
  qmi_framework_common_msg_hdr_type * common_msg_hdr,
  qmi_error_type_v01                * errval
)
{
  qmi_wdsi_state_type          * wds_sp_v4;
  qmi_wdsi_state_type          * wds_sp_v6;
  qmi_wdsi_client_state_type   * cl_sp;  
/*-------------------------------------------------------------------------*/

  if ( (common_msg_hdr == NULL) ||
       (common_msg_hdr->service != QMUX_SERVICE_WDS) ||
       (common_msg_hdr->qmi_instance >= QMI_INSTANCE_MAX) ||
       (common_msg_hdr->client_id == QMI_SVC_CLID_UNUSED) ||
       (common_msg_hdr->client_id >= QMI_FRAMEWORK_SVC_MAX_CLIENTS) ||
       (errval == NULL) )
  {
    DATA_ERR_FATAL("Invalid common_msg_hdr");
    return FALSE;
  }

  // Allocate WDS states if neccessary
  if ( !qmi_wdsi_check_and_alloc_wds_sp(common_msg_hdr->qmi_instance) )
  {
    *errval = QMI_ERR_INTERNAL_V01;
    return FALSE;
  }

  wds_sp_v4 = qmi_wds_state[WDSI_IPV4_STATE][common_msg_hdr->qmi_instance];
  wds_sp_v6 = qmi_wds_state[WDSI_IPV6_STATE][common_msg_hdr->qmi_instance];

  // Check if client already exists
  cl_sp = qmi_wdsi_get_cl_sp_by_clid(NULL, common_msg_hdr->client_id);
  if (cl_sp != NULL)
  {
    LOG_MSG_ERROR_1("clid %d exists", common_msg_hdr->client_id);
    *errval = QMI_ERR_INTERNAL_V01;
    ASSERT(0);
    return FALSE;
  }

  PS_SYSTEM_HEAP_MEM_ALLOC(cl_sp, sizeof(qmi_wdsi_client_state_type),
                           qmi_wdsi_client_state_type*);
  if (cl_sp)
  {
    qmi_wdsi_initialize_client(cl_sp,
        (uint8)common_msg_hdr->qmi_instance, common_msg_hdr->client_id);

    // Link the client to the head of the client list
    cl_sp->next = wds_sp_v4->client_list;
    wds_sp_v4->client_list = cl_sp;

    // V4 and V6 WDS states share same clients
    wds_sp_v6->client_list = cl_sp;

    LOG_MSG_INFO2_3("Allocated WDS clid %d WDS inst %d cl_sp %p",
                    cl_sp->common.clid, cl_sp->wds_inst, cl_sp );
  }
  else
  {
    LOG_MSG_ERROR_0("Failed to allocate WDS cl_sp" );
    *errval = QMI_ERR_NO_MEMORY_V01;
    return FALSE;
  }

  return TRUE;

} /* wdsi_alloc_clid() */

/*===========================================================================
  FUNCTION QMI_WDSI_PROCESS_ALLOC_CLID()

  DESCRIPTION
    This function process the client alloc callback request.

  PARAMETERS
    common_msg_hdr: data buffer containing the clid alloc request.

  RETURN VALUE
    None

  DEPENDENCIES
    QMI WDS must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_process_alloc_clid
(
  qmi_framework_common_msg_hdr_type * common_msg_hdr
)
{
  qmi_result_type_v01             result = QMI_RESULT_FAILURE_V01; 
  uint32                        ep_id;
  uint8                         bind_inst;
  qmi_wdsi_client_state_type  * cl_sp;
  qmi_error_type_v01            errval = QMI_ERR_NONE_V01;
/*-------------------------------------------------------------------------*/

  if (common_msg_hdr != NULL &&
      common_msg_hdr->qmi_instance < QMI_INSTANCE_MAX)
  {
    result = wdsi_alloc_clid(common_msg_hdr, &errval) ?
                         QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;
    if (result != QMI_RESULT_SUCCESS_V01)
    {
      goto send_result;
    }

    // Do default binding
    ep_id = qmux_get_default_ep_id_from_inst(common_msg_hdr->qmi_instance);
    if (ep_id == 0)
    {
      goto send_result;
    }

    bind_inst = qmux_get_inst_from_ep_id(ep_id);
    qmi_wdsi_inst_bind(bind_inst, ep_id, 0, FALSE);

    if (bind_inst != (uint8)common_msg_hdr->qmi_instance)
    {
      // In case two control channels have the same default ep_id, 
      // bind the client to the first channel
      cl_sp = qmi_wdsi_get_cl_sp_by_clid(NULL, common_msg_hdr->client_id);
      qmi_wdsi_process_bind_data_port(cl_sp, bind_inst);
    }
  }

send_result:
  /* Notifying the clid allocation back to client via QMI Framework */
  qmi_framework_svc_send_alloc_clid_result_ex(result, common_msg_hdr, errval);

} /* qmi_wdsi_process_alloc_clid() */

/*===========================================================================
  FUNCTION WDSI_DEALLOC_CLID()

  DESCRIPTION
    This function reset and deallocates the client state for
    the allocated client ID.

  PARAMETERS
    common_msg_hdr: data buffer containing the clid dealloc request.
 
  RETURN VALUE
    TRUE:  Success
    FALSE: Failure

  DEPENDENCIES
    QMI WDS must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static boolean wdsi_dealloc_clid
(
  qmi_framework_common_msg_hdr_type * common_msg_hdr,
  qmi_error_type_v01                * errval
)
{
  qmi_wdsi_state_type         * wds_sp_v4;
  qmi_wdsi_state_type         * wds_sp_v6;
  qmi_wdsi_client_state_type  * cl_sp;   
  qmi_wdsi_client_state_type  * cl_sp_prev;
/*-------------------------------------------------------------------------*/

  if ( (common_msg_hdr == NULL) ||
       (common_msg_hdr->service != QMUX_SERVICE_WDS) ||
       (common_msg_hdr->qmi_instance >= WDS_INSTANCE_MAX) ||
       (common_msg_hdr->client_id == QMI_SVC_CLID_UNUSED) ||
       (common_msg_hdr->client_id >= QMI_FRAMEWORK_SVC_MAX_CLIENTS) ||
       (errval == NULL))
  {
    DATA_ERR_FATAL("Invalid common_msg_hdr");
    return FALSE;
  }

  wds_sp_v4 = qmi_wds_state[WDSI_IPV4_STATE][common_msg_hdr->qmi_instance];
  wds_sp_v6 = qmi_wds_state[WDSI_IPV6_STATE][common_msg_hdr->qmi_instance];
  if (wds_sp_v4 == NULL || wds_sp_v6 == NULL)
  {
    LOG_MSG_ERROR_1("WDS state %d is not initialized",
                    common_msg_hdr->qmi_instance);
    *errval = QMI_ERR_INTERNAL_V01;
    return FALSE;
  }

  cl_sp_prev = NULL;
  cl_sp = wds_sp_v4->client_list;
  while (cl_sp != NULL)
  {
    if (cl_sp->common.clid == common_msg_hdr->client_id)
    {
      qmi_wdsi_reset_client(cl_sp);

      q_destroy(&cl_sp->common.x_free_q);
      q_destroy(&cl_sp->common.cmd_free_q);

      // Unlink the client from client list
      if (cl_sp_prev == NULL)
      {
        wds_sp_v4->client_list = cl_sp->next;
      }
      else
      {
        cl_sp_prev->next = cl_sp->next;
      }

      // WDS V4 and V6 states share same clients
      wds_sp_v6->client_list = wds_sp_v4->client_list;

      PS_SYSTEM_HEAP_MEM_FREE(cl_sp);

      LOG_MSG_INFO2_2( "Released WDS clid %d WDS inst %d",
                       common_msg_hdr->client_id,
                       common_msg_hdr->qmi_instance );

      // Unbind WDS if all clients and calls are released
      if ( (wds_sp_v4->client_list == NULL) &&
           (!rmnet_meta_sm_in_call(wds_sp_v4->binding.rmnet_inst)) &&
           (!rmnet_meta_sm_in_call(wds_sp_v6->binding.rmnet_inst)) )
      {
        qmi_wdsi_inst_unbind((uint8)common_msg_hdr->qmi_instance);
      }

      return TRUE;
    }

    cl_sp_prev = cl_sp;
    cl_sp = cl_sp->next;
  }

  LOG_MSG_ERROR_1("Can't find clid %d!", common_msg_hdr->client_id);
  *errval = QMI_ERR_INVALID_CLIENT_ID_V01;
  return FALSE;

} /* wdsi_dealloc_clid() */

/*===========================================================================
  FUNCTION QMI_WDSI_PROCESS_DEALLOC_CLID()

  DESCRIPTION
    This function process the client dealloc callback request.

  PARAMETERS
    common_msg_hdr:  data buffer containing the clid dealloc request.
 
  RETURN VALUE
    None

  DEPENDENCIES
    QMI WDS must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_process_dealloc_clid
(
  qmi_framework_common_msg_hdr_type * common_msg_hdr
)
{
  qmi_wdsi_client_state_type  * cl_sp;
  qmi_result_type_v01             result = QMI_RESULT_FAILURE_V01;
  uint8                         orig_qmi_inst;
  qmi_error_type_v01            errval = QMI_ERR_NONE_V01;
/*-------------------------------------------------------------------------*/

  if (common_msg_hdr == NULL)
  {
    errval = QMI_ERR_INTERNAL_V01;
    DATA_ERR_FATAL("Invalid common_msg_hdr");
    goto send_result;
  }

  cl_sp = qmi_wdsi_get_cl_sp_by_clid(NULL, common_msg_hdr->client_id);
  if (cl_sp == NULL)
  {
    errval = QMI_ERR_INVALID_CLIENT_ID_V01;
    goto send_result;
  }

  if (cl_sp->orig_qmi_inst != common_msg_hdr->qmi_instance)
  {
    LOG_MSG_ERROR_3("QMI inst mismatch. clid %d inst %d orig_qmi_inst %d",
                    common_msg_hdr->client_id,
                    common_msg_hdr->qmi_instance,
                    cl_sp->orig_qmi_inst);
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  orig_qmi_inst = cl_sp->orig_qmi_inst;
  common_msg_hdr->qmi_instance = cl_sp->wds_inst;

  result = wdsi_dealloc_clid(common_msg_hdr, &errval) ?
                         QMI_RESULT_SUCCESS_V01 : QMI_RESULT_FAILURE_V01;

  common_msg_hdr->qmi_instance = orig_qmi_inst;

send_result:
  /* Notifying the clid deallocation back to client via QMI Framework */
  qmi_framework_svc_send_dealloc_clid_result_ex(result, common_msg_hdr, errval);

} /* qmi_wdsi_process_dealloc_clid() */

/*===========================================================================
  FUNCTION QMI_WDSI_INITIALIZE_CLIENT()

  DESCRIPTION
    Initialize the new client state for the given client state ptr.
    
  PARAMETERS
    cl_sp :  client state pointer
    wds_inst: WDS instance
    clid:     client id
    
  RETURN VALUE
    None
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_initialize_client
(
  qmi_wdsi_client_state_type  * cl_sp,
  uint8                         wds_inst,
  uint8                         clid
)
{
  qmi_wdsi_state_type *   wds_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( (cl_sp == NULL) || (wds_inst >= WDS_INSTANCE_MAX) ||
       (qmi_wds_state[WDSI_IPV4_STATE][wds_inst] == NULL) ||
       (qmi_wds_state[WDSI_IPV6_STATE][wds_inst] == NULL) )
  {
    DATA_ERR_FATAL("Invalid parameters");
    return;
  }

  memset(cl_sp, 0, sizeof(qmi_wdsi_client_state_type));

  cl_sp->wds_inst       = wds_inst;
  cl_sp->orig_qmi_inst  = wds_inst;
  cl_sp->common.clid    = clid;
  cl_sp->subscription_id = QMI_WDSI_SUBS_DONT_CARE;

  if (qmi_wds_state[WDSI_IPV4_STATE][wds_inst]->is_primary_state)
  {
    wds_sp = qmi_wds_state[WDSI_IPV4_STATE][wds_inst];
    cl_sp->current_wds_state = WDSI_IPV4_STATE;
  }
  else
  {
    wds_sp = qmi_wds_state[WDSI_IPV6_STATE][wds_inst];
    cl_sp->current_wds_state = WDSI_IPV6_STATE;
  }

  /*-----------------------------------------------------------------------
    initialize client state non-zero fields
      - define a timer for packet statistics
      - initialize async command buffers and put them in the free queue
  -----------------------------------------------------------------------*/
  timer_def( &cl_sp->pkt_stats_timer,
             NULL,
             rex_self(),
             0,
             qmi_wdsi_pkt_stats_timer_cb,
             (timer_cb_data_type) clid );
  timer_def( &cl_sp->dun_stats_timer,
             NULL,
             rex_self(),
             0,
             qmi_wdsi_dun_stats_timer_cb,
             (timer_cb_data_type) clid );

  ds_qmi_fw_common_cl_init(wds_sp, &cl_sp->common);

  /* Initialize eMBMS requst queues */
  cl_sp->tmgi_active_list_cmd_buf_p = NULL;
  cl_sp->tmgi_avail_list_cmd_buf_p = NULL;

} /* qmi_wdsi_initialize_client() */

/*===========================================================================
  FUNCTION QMI_WDSI_PROCESS_CMD_HDLR()

  DESCRIPTION
    This function process the service command handler request callback.
    This function creates a transaction and dispatches to the appropriate
    message handler
    
  PARAMETERS
    msg_hdr:  Framework message header for the request.
    sdu_in : request

  RETURN VALUE
    None

  DEPENDENCIES
    QMI WDS must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_process_cmd_hdlr
(
  qmi_framework_msg_hdr_type * msg_hdr,
  dsm_item_type              * sdu 
)
{
  qmi_wdsi_state_type         * wds_sp;
  qmi_wdsi_client_state_type  * cl_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( (msg_hdr == NULL) || (sdu == NULL) ||
       (msg_hdr->common_hdr.qmi_instance >= QMI_INSTANCE_MAX) )
  {
    DATA_ERR_FATAL("Invalid parameters");
    dsm_free_packet(&sdu);
    return;
  }

  cl_sp = qmi_wdsi_get_cl_sp_by_clid(NULL, msg_hdr->common_hdr.client_id);
  if (cl_sp == NULL)
  {
    dsm_free_packet(&sdu);
    return;
  }

  if (cl_sp->orig_qmi_inst != msg_hdr->common_hdr.qmi_instance)
  {
    LOG_MSG_ERROR_3("QMI inst mismatch. clid %d inst %d orig_qmi_inst %d",
                    msg_hdr->common_hdr.client_id,
                    msg_hdr->common_hdr.qmi_instance,
                    cl_sp->orig_qmi_inst);
    dsm_free_packet(&sdu);
    return;
  }

  LOG_MSG_INFO2_2("Client %d is bound to WDS inst %d",
                  cl_sp->common.clid, cl_sp->wds_inst);

  // This wds_sp is the one that the client actually binds to
  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);

  ds_qmi_fw_recv(&qmi_wdsi_cfg, wds_sp, msg_hdr, &cl_sp->common, sdu);

} /* qmi_wdsi_process_cmd_hdlr() */

/*===========================================================================
  FUNCTION QMI_WDSI_PROCESS_BIND_DATA_PORT()

  DESCRIPTION
    This function process the WDS client bind command. The client on the
    original instance will be released and a new client with the same clid
    will be allocated on the binding instance.
    
  PARAMETERS
    clid:         client ID
    orig_inst:    orignal qmi instance
    bind_inst:    binding qmi instance

  RETURN VALUE
    None

  DEPENDENCIES
    QMI WDS must already have been initialized and registered with Framework

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_wdsi_process_bind_data_port
(
  qmi_wdsi_client_state_type  * cl_sp,
  uint8                         bind_inst
)
{
  qmi_wdsi_state_type         * curr_wds_sp_v4;
  qmi_wdsi_state_type         * curr_wds_sp_v6;
  qmi_wdsi_state_type         * bind_wds_sp_v4;
  qmi_wdsi_state_type         * bind_wds_sp_v6;
  qmi_wdsi_client_state_type  * cl_sp_prev;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (cl_sp == NULL || bind_inst >= WDS_INSTANCE_MAX ||
      cl_sp->wds_inst >= WDS_INSTANCE_MAX)
  {
    ASSERT(0);
    return FALSE;
  }

  curr_wds_sp_v4 = qmi_wds_state[WDSI_IPV4_STATE][cl_sp->wds_inst];
  curr_wds_sp_v6 = qmi_wds_state[WDSI_IPV6_STATE][cl_sp->wds_inst];

  bind_wds_sp_v4 = qmi_wds_state[WDSI_IPV4_STATE][bind_inst];
  bind_wds_sp_v6 = qmi_wds_state[WDSI_IPV6_STATE][bind_inst];

  if (curr_wds_sp_v4 == NULL || curr_wds_sp_v6 == NULL ||
      bind_wds_sp_v4 == NULL || bind_wds_sp_v6 == NULL)
  {
    ASSERT(0);
    return FALSE;
  }

  LOG_MSG_INFO1_3("Binding clid %d from inst %d to inst %d",
                  cl_sp->common.clid, cl_sp->wds_inst, bind_inst);

  // Reset the client
  qmi_wdsi_reset_client(cl_sp);

  // Remove the client from the current inst
  if (curr_wds_sp_v4->client_list == cl_sp)
  {
    curr_wds_sp_v4->client_list = cl_sp->next;
    curr_wds_sp_v6->client_list = cl_sp->next;

    // Unbind WDS if all clients and calls are released
    if ( (curr_wds_sp_v4->client_list == NULL) &&
         (!rmnet_meta_sm_in_call(curr_wds_sp_v4->binding.rmnet_inst)) &&
         (!rmnet_meta_sm_in_call(curr_wds_sp_v6->binding.rmnet_inst)) )
    {
      qmi_wdsi_inst_unbind(cl_sp->wds_inst);
    }
  }
  else
  {
    cl_sp_prev = curr_wds_sp_v4->client_list;
    while (cl_sp_prev != NULL)
    {
      if (cl_sp_prev->next == cl_sp)
      {
        break;
      }
      cl_sp_prev = cl_sp_prev->next;
    }
    if (cl_sp_prev == NULL)
    {
      LOG_MSG_ERROR_2("Client %d not found in WDS inst %d",
                      cl_sp->common.clid, cl_sp->wds_inst);
      return FALSE;
    }
    cl_sp_prev->next = cl_sp->next;
  }

  // Update the client
  cl_sp->wds_inst = bind_inst;
  if (bind_wds_sp_v4->is_primary_state)
  {
    cl_sp->current_wds_state = WDSI_IPV4_STATE;
  }
  else
  {
    cl_sp->current_wds_state = WDSI_IPV6_STATE;
  }
  qmi_wdsi_update_client(cl_sp);

  // Move the client to the binding inst
  cl_sp->next = bind_wds_sp_v4->client_list;
  bind_wds_sp_v4->client_list = cl_sp;
  bind_wds_sp_v6->client_list = cl_sp;

  return TRUE;

} /* qmi_wdsi_process_bind_data_port() */

/*===========================================================================
  FUNCTION QMI_WDSI_SEND_RESPONSE()

  DESCRIPTION
    This function sends a WDS response message.
    
  PARAMETERS
    cmd_buf_p: cmd_buf pointer
    msg_ptr: response data pointer

  RETURN VALUE
    TRUE: success. FALSE otherwise.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_wdsi_send_response
(
  qmi_cmd_buf_type           * cmd_buf_p,
  dsm_item_type              * msg_ptr
)
{
  qmi_wdsi_client_state_type       * cl_sp;
  qmi_framework_common_msg_hdr_type  common_hdr;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( (cmd_buf_p == NULL) || (msg_ptr == NULL) ||
       (cmd_buf_p->x_p == NULL) || (cmd_buf_p->x_p->cl_sp == NULL) )
  {
    DATA_ERR_FATAL("Invalid parameters");
    return FALSE;
  }

  cl_sp = (qmi_wdsi_client_state_type *)cmd_buf_p->x_p->cl_sp;

  common_hdr.service        = QMUX_SERVICE_WDS;
  common_hdr.client_id      = cl_sp->common.clid;
  common_hdr.transaction_id = cmd_buf_p->x_p->x_id;
  common_hdr.qmi_instance   = cl_sp->orig_qmi_inst;

  return ds_qmi_fw_send_response(&common_hdr, cmd_buf_p, msg_ptr);

} /* qmi_wdsi_send_response() */

/*===========================================================================
  FUNCTION QMI_WDSI_SEND_IND()

  DESCRIPTION
    This function sends a WDS indication message.
    
  PARAMETERS
    wds_sp: wds state pointer
    client_sp: wds client state pointer
    cmd_type: indication cmd type 
    ind_size: size of ind_msg
    ind_msg : indication data pointer
    encoding_flag:to indicate whether to encode ind_msg or not

  RETURN VALUE
    TRUE: success. FALSE otherwise.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_wdsi_send_ind
(
  qmi_wdsi_state_type        * wds_sp,
  qmi_wdsi_client_state_type * client_sp,
  uint16                       cmd_type,
  uint32                       ind_size,
  void*                        ind_msg,
  boolean                      encoding_flag
)
{
  qmi_framework_common_msg_hdr_type  common_hdr;
  dsm_item_type*                     ind = NULL;
  dsm_item_type*                     dup_ind = NULL;
  uint16                             len = 0;
  boolean                            ret = TRUE;
  qmi_wdsi_client_state_type       * cl_sp = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (client_sp == NULL && wds_sp == NULL)
  {
    DATA_ERR_FATAL("Invalid parameters");
    return FALSE;
  }

  common_hdr.service        = QMUX_SERVICE_WDS;
  common_hdr.transaction_id = 0; // Ignored in indication
  if(  encoding_flag == TRUE)
  {
    //Encode and send indication
    if(!qmi_svc_idl_message_encode(wds_svc_obj,
                                  QMI_IDL_INDICATION,
                                  cmd_type,
                                  ind_msg,
                                  ind_size,
                                  &ind))
    {
      LOG_MSG_ERROR_1("encoding failed for ind %d",cmd_type);
      return FALSE;
    }
  }
  else
  {
    ind = (dsm_item_type*)ind_msg;
  }

  /* For broadcast ind, convert it to unicast */
  if (client_sp == NULL)
  {
    len = (uint16)dsm_length_packet(ind);

    cl_sp = wds_sp->client_list;
    while ( (cl_sp != NULL) && (ret == TRUE) )
    {
      /* For legacy clients always send indication.
       * Otherwise send the ind only when IP type matches
       */
      if ( (!cl_sp->report_status.suppress_pkt_ind) &&
               (cl_sp->bound_ip_type == QMI_AF_ANY ||
                wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp)) &&
                (qmi_wdsi_verify_client_subs(cl_sp,
                                             wds_sp->binding.subscription_id, 
                                             TRUE)) )
      {
        common_hdr.client_id    = cl_sp->common.clid;
        common_hdr.qmi_instance = cl_sp->orig_qmi_inst;

        dup_ind = NULL;
        if (PS_UTILS_DSM_DUP_PACKET(&dup_ind, ind, 0, len) == len)
        {
          ret = ds_qmi_fw_send_ind(&common_hdr, cmd_type, dup_ind);
        }
        else
        {
          ret = FALSE;
        }
      } /* if (wds_sp == ...) */
      cl_sp = cl_sp->next;
    } /* while */

    dsm_free_packet(&ind);
  }
  else
  {
    common_hdr.client_id    = client_sp->common.clid;
    common_hdr.qmi_instance = client_sp->orig_qmi_inst;

    ret = ds_qmi_fw_send_ind(&common_hdr, cmd_type, ind);
  }
  if(ret != TRUE)
  {
    LOG_MSG_INFO2_1 ("Unable to send %d indication",cmd_type);
  }
  return ret;

} /* qmi_wdsi_send_ind() */

/*===========================================================================
  FUNCTION QMI_WDSI_INST_BIND()

  DESCRIPTION
    This function binds a WDS instance.
    
  PARAMETERS
    wds_inst:     WDS instance to bind
    ep_id:        EP id
    mux_id:       MUX id
    is_reversed:  binds to a reversed instance

  RETURN VALUE
    TRUE: success. FALSE otherwise.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_wdsi_inst_bind
(
  uint8    wds_inst,
  uint32   ep_id,
  uint8    mux_id,
  boolean  is_reversed
)
{
  qmi_wdsi_state_type  * wds_sp_v4;
  qmi_wdsi_state_type  * wds_sp_v6;
  boolean                result = FALSE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (wds_inst >= WDS_INSTANCE_MAX)
  {
    ASSERT(0);
    return FALSE;
  }

  if (!qmi_wdsi_check_and_alloc_wds_sp(wds_inst))
  {
    LOG_MSG_ERROR_1("Failed to alloc wds sp %d", wds_inst);
    return FALSE;
  }

  wds_sp_v4 = qmi_wds_state[WDSI_IPV4_STATE][wds_inst];
  wds_sp_v6 = qmi_wds_state[WDSI_IPV6_STATE][wds_inst];

  if ( (wds_sp_v4->binding.ep_id != ep_id) ||
       (wds_sp_v4->binding.mux_id != mux_id) ||
       (wds_sp_v4->binding.is_reversed != is_reversed) )
  {
    // If the existing binding of WDS inst doesn't match the required
    // binding, the WDS inst must be an unbound inst
    ASSERT(wds_sp_v4->binding.ep_id == 0);

    // Bind rmnet
    if (is_reversed)
    {
#ifdef FEATURE_DATA_WLAN_MAPCON
      result = rev_ip_transport_bind(ep_id, mux_id);
#endif /* FEATURE_DATA_WLAN_MAPCON */
      wds_sp_v4->binding.rmnet_inst = RMNET_INSTANCE_MAX;
      wds_sp_v6->binding.rmnet_inst = RMNET_INSTANCE_MAX;
    }
    else
    {
      result = rmnet_meta_sm_bind(ep_id, mux_id);
      if (result)
      {
        wds_sp_v4->binding.rmnet_inst = rmnet_inst_from_ep_and_mux_id(
                ep_id, mux_id, wds_sp_v4->constants.is_default);
        wds_sp_v6->binding.rmnet_inst = rmnet_inst_from_ep_and_mux_id(
                ep_id, mux_id, wds_sp_v6->constants.is_default);
        rmnet_meta_sm_set_subs_id(wds_sp_v4->binding.rmnet_inst,
                                  QMI_WDSI_SUBS_DEFAULT);
      }
      else
      {
        wds_sp_v4->binding.rmnet_inst = RMNET_INSTANCE_MAX;
        wds_sp_v6->binding.rmnet_inst = RMNET_INSTANCE_MAX;
      }
    }

    // Check result then do WDS binding. One exception is if ep_id == 0
    // which means the control channel has no default data channel. In
    // this case we do WDS binding without RmNet binding.
    if (result || (ep_id == 0 && mux_id == 0 && is_reversed == FALSE))
    {
      // Bind wds instance
      wds_sp_v4->binding.ep_id       = ep_id;
      wds_sp_v4->binding.mux_id      = mux_id;
      wds_sp_v4->binding.is_reversed = is_reversed;

      wds_sp_v6->binding.ep_id       = ep_id;
      wds_sp_v6->binding.mux_id      = mux_id;
      wds_sp_v6->binding.is_reversed = is_reversed;

      LOG_MSG_INFO1_3("Binding WDS inst %d to ep_id 0x%x mux_id %d",
                      wds_inst, ep_id, mux_id);
      return TRUE;
    }
    else
    {
      LOG_MSG_ERROR_3("Failed to bind WDS inst %d to ep_id 0x%x mux_id %d",
                      wds_inst, ep_id, mux_id);
      return FALSE;
    }
  }

  return TRUE;

} /* qmi_wdsi_inst_bind() */

/*===========================================================================
  FUNCTION QMI_WDSI_INST_UNBIND()

  DESCRIPTION
    This function unbinds a WDS instance.
    
  PARAMETERS
    wds_inst:  WDS instance to unbind

  RETURN VALUE
    TRUE: success. FALSE otherwise.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_wdsi_inst_unbind
(
  uint8    wds_inst
)
{
  qmi_wdsi_state_type  * wds_sp_v4;
  qmi_wdsi_state_type  * wds_sp_v6;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (wds_inst >= WDS_INSTANCE_MAX)
  {
    ASSERT(0);
    return FALSE;
  }

  wds_sp_v4 = qmi_wds_state[WDSI_IPV4_STATE][wds_inst];
  wds_sp_v6 = qmi_wds_state[WDSI_IPV6_STATE][wds_inst];
  if (wds_sp_v4 == NULL || wds_sp_v6 == NULL)
  {
    ASSERT(0);
    return FALSE;
  }

  if (wds_sp_v4->binding.ep_id == 0)
  {
    return TRUE;
  }

  // Unbind rmnet
  if (wds_sp_v4->binding.is_reversed)
  {
#ifdef FEATURE_DATA_WLAN_MAPCON
    rev_ip_transport_unbind(
               wds_sp_v4->binding.ep_id, wds_sp_v4->binding.mux_id);
#endif /* FEATURE_DATA_WLAN_MAPCON */
  }
  else
  {
    rmnet_meta_sm_unbind(
               wds_sp_v4->binding.ep_id, wds_sp_v4->binding.mux_id);
  }

  wds_sp_v4->binding.rmnet_inst = RMNET_INSTANCE_MAX;
  wds_sp_v6->binding.rmnet_inst = RMNET_INSTANCE_MAX;

  // Unbind wds instance
  wds_sp_v4->binding.ep_id       = 0;
  wds_sp_v4->binding.mux_id      = 0;
  wds_sp_v4->binding.is_reversed = FALSE;

  wds_sp_v6->binding.ep_id       = 0;
  wds_sp_v6->binding.mux_id      = 0;
  wds_sp_v6->binding.is_reversed = FALSE;

  // Reset FC seq num, the instance could be re-used by another mux_id
  wds_sp_v4->uplink_fc_seq_num = 0;
  wds_sp_v6->uplink_fc_seq_num = 0;
  wds_sp_v4->uplink_flow_ctrl = FALSE;
  wds_sp_v6->uplink_flow_ctrl = FALSE;

  LOG_MSG_INFO1_1("WDS inst %d unbound", wds_inst);

  return TRUE;

} /* qmi_wdsi_inst_unbind() */

/*===========================================================================
  FUNCTION QMI_WDS_SET_CALL_STATUS_HANDLER()

  DESCRIPTION
    Specify the callback function that should be invoked when the call comes
    UP or is torn DOWN

  PARAMETERS
    call_status_cb : call back function

  RETURN VALUE
    None

  DEPENDENCIES
    qmi_wds_init() must have been called previously

  SIDE EFFECTS
    None
===========================================================================*/
void  qmi_wds_set_call_status_handler
(
  qmi_wds_call_status_cb_f_type  call_status_cb
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(call_status_cb);

  qmi_wdsi_global.call_status_cb = call_status_cb;
} /* qmi_wds_set_call_status_handler */

/*===========================================================================
  FUNCTION QMI_WDS_SET_SWAP_INSTANCE_HANDLER()

  DESCRIPTION
   Specify the callback function for QMI QoS so that WDS can invoke it
   when default instance is changed.

  PARAMETERS
    qmi_wds_swap_instances_cb_f_type - callback function

  RETURN VALUE
    None

  DEPENDENCIES
    qmi_wds_init() must have been called previously

  SIDE EFFECTS
    None
===========================================================================*/
void  qmi_wds_set_swap_instance_handler
(
  qmi_wds_swap_instances_cb_f_type  swap_instances_cb
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(swap_instances_cb);

  qmi_wdsi_global.swap_instances_cb = swap_instances_cb;
} /* qmi_wds_set_swap_instance_handler() */


/*===========================================================================
  FUNCTION QMI_WDS_PKT_SRVC_STATUS_IND()

  DESCRIPTION
    Indicates the state of the network connection

  PARAMETERS
    sp            : service provided state pointer (user data)
    clid          : clientID
    conn_status   : connection status
    reconfig_reqd : reconfiguration required or not

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wds_pkt_srvc_status_ind
(
  void *                      sp,
  qmi_wdsi_client_state_type * cl_sp,
  qmi_wds_conn_status_e_type  conn_status,
  boolean                     reconfig_reqd
)
{
  qmi_wdsi_state_type *  wds_sp;
  wds_pkt_srvc_status_ind_msg_v01 indication;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;

  /*-------------------------------------------------------------------------
    save the indicated state for response to polls
  -------------------------------------------------------------------------*/
  wds_sp->pkt_svc_state = conn_status;

  /*-------------------------------------------------------------------------
    build indication from the back to the front
  -------------------------------------------------------------------------*/
  memset(&indication,0,sizeof(wds_pkt_srvc_status_ind_msg_v01));

  // Bearer ID
  if ( (wds_sp->pkt_svc_state == QMI_WDS_CONN_CONNECTED) &&
       (wds_sp->um_iface_phys_link_ptr != NULL) )
  {
    indication.bearer_id_valid = TRUE;
    indication.bearer_id = PS_PHYS_LINK_GET_BEARER_ID(
                            wds_sp->um_iface_phys_link_ptr);
  }

  //Tech name
  if ( (wds_sp->pkt_svc_state == QMI_WDS_CONN_CONNECTED) &&
       (wds_sp->um_iface_ptr != NULL) &&
       (PS_IFACE_IS_VALID(wds_sp->um_iface_ptr)) )
  {
    indication.tech_name = (wds_technology_name_enum_v01)
          (PS_IFACE_GET_NAME_FROM_ID(PS_IFACE_GET_ID(wds_sp->um_iface_ptr)));
    indication.tech_name_valid  = TRUE;
  }

  //IP family
  indication.ip_family_valid = TRUE;
  indication.ip_family = (wds_ip_family_enum_v01)wds_sp->cur_ip_call_type;

  //Call end reason
  if ( QMI_WDS_CONN_DISCONNECTED == wds_sp->pkt_svc_state )
  {
    indication.verbose_call_end_reason_valid = TRUE;
    indication.verbose_call_end_reason.call_end_reason_type = 
     (wds_verbose_call_end_reason_type_enum_v01)(wds_sp->call_end_reason_verbose >> 16);
    indication.verbose_call_end_reason.call_end_reason = 
     (uint16)(0x0000FFFF&wds_sp->call_end_reason_verbose);
    indication.call_end_reason_valid = TRUE;
    indication.call_end_reason = 
     (wds_call_end_reason_enum_v01)wds_sp->call_end_reason;
    }

  //connection status
  indication.status.connection_status = (wds_connection_status_enum_v01)conn_status;
  indication.status.reconfiguration_required = reconfig_reqd;

  //Encode and send indication
  qmi_wdsi_send_ind(sp, cl_sp, QMI_WDS_PKT_SRVC_STATUS_IND_V01,
		sizeof(wds_pkt_srvc_status_ind_msg_v01),&indication,TRUE);
} /* qmi_wds_pkt_srvc_status_ind() */

/*===========================================================================
  FUNCTION QMI_WDS_DUN_CALL_INFO_IND()

  DESCRIPTION
    Sends a broadcast indication showing the state of the modem connection

  PARAMETERS
    sp            : service provided state pointer (user data)
    clid          : clientID = broadcast
    conn_status   : connection status

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wds_dun_call_info_ind
(
  void *                          sp,
  uint8                           clid,
  uint32                          event_type,
  qmi_wds_dormancy_status_e_type  dormancy_status,
  qmi_wds_bearer_tech_e_type      data_bearer,
  uint32                          tx_rate,
  uint32                          rx_rate,
  qmi_wds_conn_status_e_type      conn_status
)
{
  uint8  connection_status;
  qmi_wdsi_state_type *   wds_sp;
  qmi_wdsi_client_state_type * cl_sp;
  qmi_wdsi_data_byte_count_type        data_count;
  wds_dun_call_info_ind_msg_v01 indication;
  boolean resp_flag = FALSE;/* this is used to check if any TLV's 
                              are valid and indication needs to be sent*/

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);

  LOG_MSG_INFO2_0 ("Sending DUN call info indication.");
  memset(&indication,0,sizeof(wds_dun_call_info_ind_msg_v01));
  /*-------------------------------------------------------------------------
    build indication from the back to the front
  -------------------------------------------------------------------------*/
  wds_sp = (qmi_wdsi_state_type *) sp;

  cl_sp = qmi_wdsi_get_cl_sp_by_clid(wds_sp, clid);

  if (event_type & WDSI_REPORT_MODEM_STATUS_EV_CH_RATE)
  {
    indication.channel_rate_valid = TRUE;
    indication.channel_rate.current_channel_tx_rate = tx_rate;
    indication.channel_rate.current_channel_rx_rate = rx_rate;
    resp_flag = TRUE;
  }

  /*-------------------------------------------------------------------------
    Event causing indication is Change in Data Bearer
  -------------------------------------------------------------------------*/
  if (event_type & WDSI_REPORT_MODEM_STATUS_EV_DATA_BEARER)
  {
    LOG_MSG_INFO2_2 ("Indicate Data bearer change (= %d) for clid=%d",
                     data_bearer, clid);
    indication.data_beare_technology_valid = TRUE;
    indication.data_beare_technology = (wds_data_bearer_tech_enum_v01)data_bearer;
    resp_flag = TRUE;
  }

  /*-------------------------------------------------------------------------
    Event causing indication is Change in Dormancy Status
  -------------------------------------------------------------------------*/
  if (event_type & WDSI_REPORT_MODEM_STATUS_EV_DORM_STATUS)
  {
    LOG_MSG_INFO2_2 ("Indicate Dormancy Status (= %d) clid=%d",
                     dormancy_status, clid);
    indication.dormancy_status_valid = TRUE;
    indication.dormancy_status = (wds_dormancy_status_enum_v01)dormancy_status;
    resp_flag = TRUE;	
  }

  /*-------------------------------------------------------------------------
    return byte statistics
  -------------------------------------------------------------------------*/
  if( event_type & WDSI_REPORT_MODEM_STATUS_EV_PKT_STATS)
  {
    if (!qmi_wdsi_get_dun_data_count(&data_count))
    {
      LOG_MSG_ERROR_0("Not sending DUN pkt stats IND, couldn't get byte count");
      return;
    }
    else
    {
      ASSERT(cl_sp);

      if ((data_count.txed_bytes != cl_sp->modem_rpt_status.tx_bytes) &&
          (cl_sp->modem_rpt_status.ind_mask &  WDSI_STAT_MASK_TX_OK_BYTES)) 
      {
        indication.tx_ok_bytes_count_valid = TRUE;
        indication.tx_ok_bytes_count = data_count.txed_bytes;
        cl_sp->modem_rpt_status.tx_bytes = data_count.txed_bytes;
        resp_flag = TRUE;		
      }
      if ((data_count.rxed_bytes != cl_sp->modem_rpt_status.rx_bytes) &&
          (cl_sp->modem_rpt_status.ind_mask &  WDSI_STAT_MASK_RX_OK_BYTES)) 
        {
        indication.rx_ok_bytes_count_valid = TRUE;
        indication.rx_ok_bytes_count = data_count.rxed_bytes;
        cl_sp->modem_rpt_status.rx_bytes = data_count.rxed_bytes;
        resp_flag = TRUE;		
      }
    }
  }

    // return last dun call end reason even if in a call
  if(event_type & WDSI_REPORT_MODEM_STATUS_EV_CONN_STATUS)
  {
    /*-------------------------------------------------------------------------
      Add the call end reason if we are indicating a disconnection
    -------------------------------------------------------------------------*/
    if ( QMI_WDS_CONN_DISCONNECTED == conn_status )
    {
      indication.call_end_reason_valid = TRUE;
      indication.call_end_reason = (wds_call_end_reason_enum_v01)
                   qmi_wdsi_global.modem_dun_last_call_end_reason;
    }
    connection_status  = conn_status;
    indication.modem_connection_status_valid = TRUE;
    indication.modem_connection_status = (wds_connection_status_enum_v01)connection_status;
    resp_flag = TRUE;	 
  }
  if( resp_flag == TRUE)
  {
    qmi_wdsi_send_ind(sp, cl_sp, QMI_WDS_DUN_CALL_INFO_IND_V01, 
         sizeof(wds_dun_call_info_ind_msg_v01),&indication,TRUE);
  }
  else
  {
    LOG_MSG_INFO2_1("Not sending modem status indication,no TLVs added - Mask %d",event_type);
  }

} /* qmi_wds_dun_call_info_ind() */

/*===========================================================================
FUNCTION  QMI_WDSI_GENERATE_DUN_CALL_INFO_IND

DESCRIPTION
  Send out a connection status event if the DUN connection status has
  changed.

PARAMETERS
  conn_status - connected or disconnected

DEPENDENCIES
  None

RETURNS
  None

SIDE EFFECTS
  None

===========================================================================*/
void qmi_wdsi_generate_dun_call_info_ind
(
  ps_iface_event_enum_type   event,
  ps_iface_type             *iface_ptr,
  ps_iface_event_info_u_type event_info,
  ps_iface_name_enum_type    iface_name
)
{
  qmi_wdsi_state_type *         wds_sp;
  qmi_wdsi_client_state_type *  cl_sp;
  uint8                         state;
  uint8                         inst;

  time_type                       time;
  ps_iface_bearer_technology_type bearer_tech;
  sint15                          ps_errno;

  qmi_wdsi_curr_data_bearer_tech_type curr_data_bearer;
  ps_iface_name_enum_type       tech_name = iface_name;
  acl_proc_id_type              um_iface_proc_id = 0;
  qmi_wdsi_data_byte_count_type      data_count;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(qmi_wdsi_global.inited == FALSE)
  {
    /* QMI is not initialized, (Net device not enumerated) so ignore */
    LOG_MSG_INFO2_0("Ignoring DUN notification, since qmi not initialized");
    return;
  }
  if (!PS_IFACE_IS_VALID(iface_ptr))
  {
    LOG_MSG_ERROR_0("Invalid iface_ptr in DUN call info event handler");
    return;
  }

  /* Ignore events on RmNet ifaces */
  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }
      if( wds_sp->rmnet_iface_ptr == iface_ptr )
      {
        LOG_MSG_INFO2_0("Ignoring RmNet iface event in DUN event handler");
        return;
      }
    } /* for each instance */
  } /* for each state */

  LOG_MSG_INFO2_3(" qmi_wdsi_generate_dun_call_info_ind Event [%d] Iface Name [0x%x], Tech Name [0x%x]",
                  event, iface_ptr->name, tech_name);
   
  /*Send the up indication for either dun(sio iface) or modem embedded call. 
    We wont recieve in_use event for dun. RmNet tethered/embedded call
    notification will be sent based on events on RmNet iface from
    wdsi_net_iface_ev_cb() after media connect/disconnect.*/
  if (event == IFACE_UP_EV || event == IFACE_ROUTEABLE_EV || 
      event == IFACE_ACTIVE_IN_USE_EV)
  {
    /* Dun Call*/
    if (tech_name == SIO_IFACE)
    {
      if (qmi_wdsi_global.dun_state == QMI_WDS_CONN_DISCONNECTED)
      {
        LOG_MSG_INFO2_1("DUN call connected (event=%d)", event);
        qmi_wdsi_global.dun_state = QMI_WDS_CONN_CONNECTED;
        qmi_wdsi_global.modem_dun_iface_ptr = iface_ptr;
        time_get_uptime_ms( qmi_wdsi_global.modem_dun_call_connect_time );

        if (!PS_IFACE_IS_VALID(iface_ptr->iface_private.tx_bridge_ptr))
        {
          LOG_MSG_ERROR_1("SIO_IFACE is not bridged to a valid iface_ptr! tx_bridge_ptr = 0x%x",
                          iface_ptr->iface_private.tx_bridge_ptr);
        }
        else
        {
          qmi_wdsi_global.modem_dun_um_iface_ptr =
            iface_ptr->iface_private.tx_bridge_ptr;
          LOG_MSG_INFO2_1("Set modem_dun_um_iface_ptr from bridged iface 0x%x",
                          iface_ptr->iface_private.tx_bridge_ptr);
        }
        qw_set(qmi_wdsi_global.modem_dun_total_active_time, 0, 0);

        /* Fetch current data bearer tech */
        if (ps_iface_ioctl(qmi_wdsi_global.modem_dun_um_iface_ptr,
                           PS_IFACE_IOCTL_GET_BEARER_TECHNOLOGY,
                           &bearer_tech,
                           &ps_errno) == 0)
        {
          curr_data_bearer = wdsi_get_curr_data_bearer_tech(bearer_tech);
        }
        else
        {
          LOG_MSG_ERROR_1("Couldn't get data bearer tech at DUN connection IOCTL gave errno %d",
                          ps_errno);
          memset(&curr_data_bearer, 0, sizeof(curr_data_bearer));
        }

        if (NULL != qmi_wdsi_global.modem_dun_um_iface_ptr)
        {
          /* Initialize the DUN last used data bearer cache */
          qmi_wdsi_global.modem_dun_last_data_bearer = wdsi_get_data_bearer_tech(
                                                                curr_data_bearer);

          qmi_wdsi_global.callhist_data.has_connected = TRUE;
          qmi_wdsi_global.callhist_data.tech_type_e =
                      qmi_wdsi_global.modem_dun_last_data_bearer;
          qmi_wdsi_global.callhist_data.ipv4_addr =
                      PS_IFACE_IP_V4_ADDR(qmi_wdsi_global.modem_dun_um_iface_ptr);
          qmi_wdsi_global.callhist_data.ipv4_addr =
                      ps_ntohl(qmi_wdsi_global.callhist_data.ipv4_addr);
        }

        /*---------------------------------------------------------------------
            Register for desired events with Um_Phys_link and
            Um Iface Bearer Tech Change event
        ---------------------------------------------------------------------*/
        /* modem UM iface stored in global */
        wdsi_reg_dun_um_phys_link_ev(qmi_wdsi_global.modem_dun_um_iface_ptr);
        qmi_wdsi_global.dun_subs_id = 
          PS_IFACE_GET_SUBS_ID(qmi_wdsi_global.modem_dun_um_iface_ptr);

        /* Data call status (UP) indication for DUN calls is sent when the
         * corresponding RM(SIO) iface comes up. */
        qmi_wdsi_process_data_call_status_change(WDSI_CALL_ACTIVATED,
                                                 WDSI_DATA_CALL_TETHERED_DUN,
                ps_iface_get_addr_family(qmi_wdsi_global.modem_dun_um_iface_ptr),
                                                 qmi_wdsi_global.dun_subs_id);
      }
      else
      {
        LOG_MSG_INFO1_1("Recvd iface event %d but already connected", event);
        return;
      }
    }

    /* Modem Embedded Call */
    else if (tech_name == CDMA_SN_IFACE || tech_name == UMTS_IFACE)
    {
      um_iface_proc_id = PS_IFACE_GET_PROC_ID(iface_ptr);
      LOG_MSG_INFO2_2("Proc id for Um Iface 0x%x is 0x%x",
                      iface_ptr, um_iface_proc_id);

      /*Proc id is 1 for dun calls*/
      if(um_iface_proc_id == 0x1)        
      {
        /* CDMA SIP DUN calls do not properly set the bridged iface ptr, so
         * need to handle the routeable event on the Um iface */
        if (event == IFACE_ROUTEABLE_EV &&
            tech_name == CDMA_SN_IFACE)
        {
          qmi_wdsi_global.modem_dun_um_iface_ptr = iface_ptr;
          LOG_MSG_INFO2_1("Set modem_dun_um_iface_ptr from CDMA_SN ROUTEABLE ev to 0x%x",
                          iface_ptr);
        }
      }
      else if ( ( (um_iface_proc_id == PS_IFACE_PROC_ID_LOCAL) ||
                  (um_iface_proc_id == PS_IFACE_PROC_ID_ANY) ) )
      {
        /* This is to avoid duplicate indications for non-attach pdn. When 
           iface is brought up initialially we get iface in use since 
           ref count is one and then iface up indication sent by modehandler.
           So to avoid two indication, we have the check below
           */
  	if( (event == IFACE_UP_EV && 
             event_info.iface_up_info.is_iface_in_use != TRUE) ||
            (event == IFACE_ACTIVE_IN_USE_EV && 
             event_info.iface_up_info.state != IFACE_UP))
        {
          LOG_MSG_INFO2_3("Ignoring iface event %d on iface 0x%x iface state %d",
                          event, iface_ptr, iface_ptr->iface_private.state);
          return;
        }        
        qmi_wdsi_process_data_call_status_change(WDSI_CALL_ACTIVATED,
                                                 WDSI_DATA_CALL_MODEM_EMBEDDED,
                                                 ps_iface_get_addr_family(iface_ptr),
                                                 qmi_wdsi_global.dun_subs_id);       
      }
      else
      {
        LOG_MSG_ERROR_2("Proc id for Um Iface 0x%x is 0x%x",
                        iface_ptr, um_iface_proc_id);
      }               

      return;                
    }    
  }
  /*Send terminated status for dun or modem embedded call. RmNet 
    tethered/embedded call notification will be sent based on
    events on RmNet iface from wdsi_net_iface_ev_cb()
    after media connect/disconnect.*/
  else if (event == IFACE_DOWN_EV || event == IFACE_ACTIVE_OUT_OF_USE_EV)
  {
    /* DUN call terminated */
    if (iface_ptr == qmi_wdsi_global.modem_dun_iface_ptr)
    {
      LOG_MSG_INFO2_1("DUN call disconnected, netdown reason 0x%x",
                      event_info.iface_down_info.netdown_reason);
      if (!qmi_wdsi_get_dun_data_count(&data_count))
      {
        LOG_MSG_ERROR_0("Couldn't get data count at DUN disconnect");
      }

      qmi_wdsi_global.modem_dun_last_call_data_count.txed_bytes = data_count.txed_bytes;
      qmi_wdsi_global.modem_dun_last_call_data_count.rxed_bytes = data_count.rxed_bytes;
      qmi_wdsi_global.dun_state = QMI_WDS_CONN_DISCONNECTED;
      qmi_wdsi_global.modem_dun_iface_ptr = NULL;
      time_get_uptime_ms( qmi_wdsi_global.modem_dun_call_end_time );

      QMI_INCREMENT_DUN_TOTAL_ACTIVE_TIME(time);
      qw_equ(qmi_wdsi_global.modem_dun_last_call_active_duration,
             qmi_wdsi_global.modem_dun_total_active_time);

      qmi_wdsi_pbm_add(NULL);

      /*---------------------------------------------------------------------
          De-register for desired events with Um_Phys_link and Um Iface Bearer
          Tech Change event
      ---------------------------------------------------------------------*/
      /* modem UM iface stored in global */
      wdsi_dereg_dun_um_phys_link_ev(qmi_wdsi_global.modem_dun_um_iface_ptr);

      qmi_wdsi_global.modem_dun_um_iface_ptr = NULL;

      /* Data call status (DOWN) indication for DUN calls is sent when the 
       * corresponding RM(SIO) iface goes down. */
      qmi_wdsi_process_data_call_status_change(WDSI_CALL_TERMINATED,
                                               WDSI_DATA_CALL_TETHERED_DUN,
                                               event_info.iface_down_info.addr_family,
                                               qmi_wdsi_global.dun_subs_id);
      /* General channel_rate indication when call is disconnected */ 
      qmi_wdsi_generate_dun_channel_rate_ind(QMI_IF_CH_RATE_TRIGGER_DATA_BEARER_CHANGE,
                                             qmi_wdsi_global.dun_subs_id);
    }
    else
    {
      LOG_MSG_INFO1_3("Got DOWN_EV on non-DUN iface_ptr 0x%x name 0x%x:%d",
                      iface_ptr, tech_name, iface_ptr->instance);

      if (iface_ptr == qmi_wdsi_global.modem_dun_um_iface_ptr)
      {
        /* Save netdown reason from Um iface, SIO_IFACE will be going down soon */
        qmi_wdsi_global.modem_dun_last_call_end_reason =
                          qmi_wdsi_map_wds_call_end_reason(
                              event_info.iface_down_info.netdown_reason
                          );
        LOG_MSG_INFO2_2("Saved DUN Um iface netdown reason 0x%x mapped to QMI end reason %d",
                        event_info.iface_down_info.netdown_reason,
                        qmi_wdsi_global.modem_dun_last_call_end_reason);
      }

      if (tech_name == CDMA_SN_IFACE || tech_name == UMTS_IFACE)
      {
        if(event == IFACE_DOWN_EV || event == IFACE_ACTIVE_OUT_OF_USE_EV)
        {
          um_iface_proc_id = event_info.iface_down_info.proc_id;                    
        }
        
        if (um_iface_proc_id == PS_IFACE_PROC_ID_LOCAL || 
            um_iface_proc_id == PS_IFACE_PROC_ID_ANY)
        {	   
          /* Data call status (Terminated) indication for Embedded calls is sent when the
           * corresponding UM iface goes down. */
          qmi_wdsi_process_data_call_status_change(WDSI_CALL_TERMINATED,
                                                   WDSI_DATA_CALL_MODEM_EMBEDDED,
                                                   event_info.iface_down_info.addr_family,
                                                   PS_IFACE_GET_SUBS_ID(iface_ptr));
        }  
        else
        {          
          LOG_MSG_ERROR_2("Proc id for Um Iface 0x%x is 0x%x",
                          iface_ptr, um_iface_proc_id);
          return;
        }
      }
      return;
    }
  }
  else
  {
    LOG_MSG_INFO2_3("Ignored event %d  tech %d from iface 0x%x",
                    event, tech_name, iface_ptr->instance);
    return;
  }

  /* iterate through all QMI_WDS instances (both IPv4 and IPv6) to find any that
     are active.  If found, clear 'last call duration' and search for clients
     registered for DUN connection status reports to send and IND to.*/
  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }

      if (qmi_wdsi_global.dun_state == QMI_WDS_CONN_DISCONNECTED)
      {
        /* Invalidate the RMNET last call active duration value since the last
         * call was now made with DUN. */
        qw_set(wds_sp->last_call_active_duration,
               QMI_WDSI_CALL_DURATION_INVALID_DW,
               QMI_WDSI_CALL_DURATION_INVALID_DW);
        qw_set(wds_sp->last_call_duration,
               QMI_WDSI_CALL_DURATION_INVALID_DW,
               QMI_WDSI_CALL_DURATION_INVALID_DW);

        /* clear 'last' RMNET parameters since current call is DUN */
        memset( (void *) &(wds_sp->last_data_bearer_cache),
                0,
                sizeof(qmi_wdsi_curr_data_bearer_tech_type) );
      }

      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if (cl_sp->report_status.report_dun_conn_status && 
            cl_sp->modem_rpt_status.last_conn_status != qmi_wdsi_global.dun_state &&
            qmi_wdsi_verify_client_subs(cl_sp,qmi_wdsi_global.dun_subs_id, TRUE))
        {
          qmi_wds_dun_call_info_ind(wds_sp,
                                    cl_sp->common.clid,
                                    (uint32)
                                    WDSI_REPORT_MODEM_STATUS_EV_CONN_STATUS,
                                    QMI_WDS_TRAFFIC_CH_UNKNOWN,
                                    QMI_WDS_BEARER_TECH_UNKNOWN,
                                    0,
                                    0,
                                    qmi_wdsi_global.dun_state
                                   );
          cl_sp->modem_rpt_status.last_conn_status = qmi_wdsi_global.dun_state;
        }

        if (qmi_wdsi_global.dun_state == QMI_WDS_CONN_DISCONNECTED)
        {
          /* Clear out last-send byte statistic IND's to ensure empty IND's are
             sent to this client the next time the call is connected.*/
          if (cl_sp->modem_rpt_status.rx_bytes || 
              cl_sp->modem_rpt_status.tx_bytes)
          {
            LOG_MSG_INFO2_1("Client %d DUN byte stat's IND non-zero, clearing",
                            cl_sp->common.clid);
            cl_sp->modem_rpt_status.rx_bytes = 0;
            cl_sp->modem_rpt_status.tx_bytes = 0;
          }
          /* Reset last_dorm_rpt for each cl_sp */
          cl_sp->modem_rpt_status.last_dorm_rpt = QMI_WDS_TRAFFIC_CH_UNKNOWN;
        }
        cl_sp = cl_sp->next;
      } /* for each client */
    } /* for each instance */
  } /* for each state */
} /* qmi_wdsi_generate_dun_call_info_ind() */

/*===========================================================================
FUNCTION  WDSI_ADD_REV_IP_CONNECTED_IND_PARAMS

DESCRIPTION
  Adds parameters needed for the reverse IP transport connected indication.

PARAMETERS
  this_iface_ptr - WLAN/EPDG iface ptr
  indication     - wds_reverse_ip_transport_connection_ind_msg_v01 type

DEPENDENCIES
  None

RETURNS
  TRUE - SUCCESS
  FALSE - FAILURE

SIDE EFFECTS
  None

===========================================================================*/
static boolean wdsi_add_rev_ip_connected_ind_params
(
  ps_iface_type                                   *this_iface_ptr,
  wds_reverse_ip_transport_connection_ind_msg_v01  *indication
)
{
  ps_iface_name_enum_type      iface_name;
  ps_iface_ioctl_is_ipsec_sa_shared_type sa_shared;
  sint15                       ps_errno;

  LOG_MSG_INFO2_0( "Generate Rev IP connected Ind" );

  iface_name = (ps_iface_name_enum_type)
          (PS_IFACE_GET_NAME_FROM_ID(PS_IFACE_GET_ID(this_iface_ptr)));
  /* Figure out IP address */
   if (ps_iface_addr_family_is_v4(this_iface_ptr))
    {
      indication->ipv4_addr_valid = TRUE;
      indication->ipv4_addr = ps_ntohl(PS_IFACE_IP_V4_ADDR(this_iface_ptr));
      // Figure out subnet mask and add
    }
    else
    {
      ps_ip_addr_type ipv6_addr;
      ipv6_addr.type = IFACE_IPV6_ADDR_FAMILY;
      ps_iface_get_addr(this_iface_ptr,
                        &ipv6_addr);
      indication->ipv6_addr_valid = TRUE;
      memscpy(indication->ipv6_addr.ipv6_addr,
              sizeof(indication->ipv6_addr.ipv6_addr),
              ipv6_addr.addr.v6.in6_u.u6_addr8,
              sizeof(ipv6_addr.addr.v6.in6_u.u6_addr8));
        indication->ipv6_addr.ipv6_prefix_length = WDSI_IPV6_DEFAULT_PREFIX_LEN;
    }

    /* If EPDG IFACE figure out if it is_shared */
    if (IWLAN_S2B_IFACE == iface_name)
    {
      if (ps_iface_ioctl(this_iface_ptr,
                         PS_IFACE_IOCTL_IS_IPSEC_SA_SHARED,
                         &sa_shared,
                         &ps_errno) == 0)
      {
        indication->is_shared_valid = TRUE;
        indication->is_shared = sa_shared.is_shared;
      }
      else
      {
        LOG_MSG_ERROR_1("Couldn't get IPSEC Params, IOCTL gave errno %d",
                        ps_errno);
      }
    }
  return TRUE;
}

/*===========================================================================
FUNCTION  QMI_WDSI_PROCESS_WLAN_IFACE_EVT

DESCRIPTION
  Processes events generated by WLAN/EPDG IFACE and sends out indications if required.

PARAMETERS
  conn_status - connected or disconnected

DEPENDENCIES
  None

RETURNS
  None

SIDE EFFECTS
  None

===========================================================================*/
static void qmi_wdsi_process_wlan_iface_evt
(
  ps_iface_event_enum_type   event,
  ps_iface_type             *this_iface_ptr,
  ps_iface_event_info_u_type event_info,
  void                      *user_data_ptr
)
{
  qmi_wdsi_state_type *        wds_sp;
  ps_iface_name_enum_type      iface_name;
  wds_reverse_ip_transport_connection_ind_msg_v01 indication;
  uint32                       conn_status = WDSI_REV_IP_TRANSPORT_DISCONNECTED;
#ifdef FEATURE_DATA_WLAN_MAPCON
  qmi_wdsi_client_state_type * cl_sp;
#endif /* FEATURE_DATA_WLAN_MAPCON */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (user_data_ptr && this_iface_ptr);

  wds_sp = (qmi_wdsi_state_type *) user_data_ptr;
  memset(&indication,0,sizeof(wds_reverse_ip_transport_connection_ind_msg_v01));
  LOG_MSG_INFO2_2( "Processing iface ev %d from WLAN/EPDG i/f 0x%x",
                   event, this_iface_ptr );

  iface_name = (ps_iface_name_enum_type)
          (PS_IFACE_GET_NAME_FROM_ID(PS_IFACE_GET_ID(this_iface_ptr)));
  /*-------------------------------------------------------------------------
    Act on Iface events.
  -------------------------------------------------------------------------*/
  switch( event )
  {
    case IFACE_CONFIGURING_EV:
    {
      /* If the IFACE is going from DOWN to CONFIGURING, we do not need to send
         any indication. However if it goes from UP to CONFIGURING (eg in rekeying)
         then we need to send a DISCONNECTED indication to allow AP side to clean up*/
      if (IFACE_UP != event_info.state) 
      {
        LOG_MSG_INFO2_1( "Ignoring Config evt for WLAN/EPDG i/f since previous state is not UP, state=%d",
                         event_info.state );
        return;
      }
      /* Send Disconnected if previous state is UP */
      LOG_MSG_INFO2_0( "Generate Disconnected ind " );
      conn_status = WDSI_REV_IP_TRANSPORT_DISCONNECTED;
      break;
    }
    case IFACE_REVERSE_IP_TRANSPORT_CONFIG_EV:
    {
      if (!wdsi_add_rev_ip_connected_ind_params(this_iface_ptr, &indication))
      { 
        return;
      }
      conn_status = WDSI_REV_IP_TRANSPORT_CONNECTED;
      break;
    }
    case IFACE_DOWN_EV:
    {
      /*Deregister for IFACE events*/
      wdsi_dereg_wlan_iface_ev(wds_sp);
      wds_sp->wlan_iface_ptr = NULL;
      /* Check previous indication sent for WLAN/EPDG IFACE */
      if ((wds_sp->wlan_tx.wlan_tx_id > 0) && 
          (wds_sp->wlan_tx.conn == 
           (ps_iface_ioctl_reverse_ip_transport_conn_enum_type)WDSI_REV_IP_TRANSPORT_DISCONNECTED))
      {
        LOG_MSG_INFO2_0( "Disconnected indication already sent, not sending another one" );
        return;
      }
      /* Send Disconnected IND */
      LOG_MSG_INFO2_0( "Generate Rev IP disconnected Ind" );
      conn_status = WDSI_REV_IP_TRANSPORT_DISCONNECTED;
      break;
    }
    default:
    {
      /* We shouldnt be coming here at all since we already checked for valid
         event before posting command to DCC */
      LOG_MSG_ERROR_1( "Invalid iface ev %d, Dropping it ", event );
      ASSERT(0);
      return;
    }
  }

  /* Add the common TLVs */
  indication.tech_name_valid = TRUE;
  indication.tech_name = (wds_technology_name_enum_v01)iface_name;

  /* Generate and add tx id */
  wds_sp->wlan_tx.wlan_tx_id++;
  indication.transaction_id = wds_sp->wlan_tx.wlan_tx_id;
  wds_sp->wlan_tx.wlan_tx_pending = TRUE;
  wds_sp->wlan_tx.conn = (ps_iface_ioctl_reverse_ip_transport_conn_enum_type)conn_status;
  indication.rev_ip_transport_conn_status = conn_status;

#ifdef FEATURE_DATA_WLAN_MAPCON
  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
    if ((wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp)) &&
        (cl_sp->report_status.report_rev_ip_transport_connection_ind))
    {
      //TODO: Verify client subs here when WLAN supports multi subs
      LOG_MSG_INFO2_1( "Sending Rev IP Ind to client %d", cl_sp->common.clid );
      qmi_wdsi_send_ind(wds_sp, cl_sp, QMI_WDS_REVERSE_IP_TRANSPORT_CONNECTION_IND_V01, 
            sizeof(wds_reverse_ip_transport_connection_ind_msg_v01),&indication,TRUE);
    }
    cl_sp = cl_sp->next;
  } /* while */
#endif /* FEATURE_DATA_WLAN_MAPCON */
} /* qmi_wdsi_process_wlan_iface_evt */


/*===========================================================================
  FUNCTION QMI_WDS_GENERATE_CHANNEL_RATE_IND()

  DESCRIPTION
    Called when the channel rate changes.
    Causes wds_event_report_ind to be sent

  PARAMETERS
    event  : Event that causes channel rate ind to be sent out
    is_v4  : IP tyoe flag
    subs_id: Subscription identifier

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_wds_generate_channel_rate_ind
(
  qmi_if_ch_rate_trigger_e_type event,
  boolean is_v4,
  uint32  subs_id
)
{
  qmi_wdsi_client_state_type *  cl_sp;
  qmi_wdsi_state_type *         wds_sp;
  uint8                         wds_inst;
  uint32                        cur_tx_rate;
  uint32                        cur_rx_rate;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    When any call is up (RMNET on any instance or DUN), don't send this type
    of indication based off an SS change; use only the data bearer change
  -------------------------------------------------------------------------*/
  if (event == QMI_IF_CH_RATE_TRIGGER_SS_CHANGE)
  {
    /* Need DUN IND call here as there is no other way to trigger SS_CHANGE
       IND's for DUN. DATA_BEARER_CHANGE IND's for DUN call this function
       directly, so those IND's are already handled. */
    qmi_wdsi_generate_dun_channel_rate_ind(event, subs_id);

    for (wds_inst=0; wds_inst<WDS_INSTANCE_MAX; wds_inst++)
    {
      if( TRUE == is_v4 )
      {
        wds_sp = qmi_wds_state[WDSI_IPV4_STATE][wds_inst];
      }
      else
      {
        wds_sp = qmi_wds_state[WDSI_IPV6_STATE][wds_inst];
      }

      if (wds_sp == NULL)
      {
        continue;
      }

      if (wds_sp->pkt_svc_state != QMI_WDS_CONN_DISCONNECTED)
      {
        LOG_MSG_INFO2_1("Rmnet call up on instance %d", wds_inst);
        return;
      }
    }
  }

  /*-------------------------------------------------------------------------
    Report channel rate change to all clients that have registered for it
  -------------------------------------------------------------------------*/
  for (wds_inst = 0; wds_inst < WDS_INSTANCE_MAX; wds_inst++)
  {
    if( TRUE == is_v4 )
    {
      wds_sp = qmi_wds_state[WDSI_IPV4_STATE][wds_inst];
    }
    else
    {
      wds_sp = qmi_wds_state[WDSI_IPV6_STATE][wds_inst];
    }

    if (wds_sp == NULL)
    {
      continue;
    }

    qmi_if_get_max_channel_rate(wds_sp->um_iface_ptr,
                                &cur_tx_rate, &cur_rx_rate);

    /* Skip sending indications if the value matches our cache */
    if (wds_sp->current_rx_rate == cur_rx_rate &&
        wds_sp->current_tx_rate == cur_tx_rate)
    {
      continue;
    }

    LOG_MSG_INFO2_6 ("channel rates (RMNET pkt_svc_state = %d): tx %d, rx %d"
                     "last reported rates (inst %d): tx %d, rx %d",
                     wds_sp->pkt_svc_state,
                     cur_tx_rate,
                     cur_rx_rate,
                     wds_inst,
                     wds_sp->current_tx_rate,
                     wds_sp->current_rx_rate);

    wds_sp->current_rx_rate = cur_rx_rate;
    wds_sp->current_tx_rate = cur_tx_rate;

    cl_sp = wds_sp->client_list;
    while (cl_sp != NULL)
    {
      if (cl_sp->report_status.report_ch_rate &&
          qmi_wdsi_verify_client_subs(cl_sp, subs_id, TRUE))
      {
        qmi_wdsi_event_report_ind(qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp),
                                  cl_sp->common.clid,
                                  WDSI_REPORT_STATUS_EV_CH_RATE,
                                  cur_tx_rate,
                                  cur_rx_rate,
                                  NULL,
                                  QMI_WDS_BEARER_TECH_UNKNOWN,
                                  0,
                                  QMI_WDS_TRAFFIC_CH_UNKNOWN,
                                  NULL,
                                  0,
                                  WDSI_CALL_UKNOWN,
                                  WDSI_DATA_CALL_NONE,                                  
                                  0,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);

      }
      cl_sp = cl_sp->next;
    }
  }
} /* qmi_wds_generate_channel_rate_ind() */

/*===========================================================================
  FUNCTION QMI_WDSI_GENERATE_DUN_CHANNEL_RATE_IND()

  DESCRIPTION
    Called when the channel rate changes and causes dun_call_info_ind to be
    sent.

    NOTE: This function should only be called for DATA_BEARER_CHANGE events if
          the event happened on the DUN iface!

  PARAMETERS
    event  : Event that causes channel rate ind to be sent out
    subs_id: Subscription identifier

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_generate_dun_channel_rate_ind
(
  qmi_if_ch_rate_trigger_e_type event,
  uint32                        subs_id

)
{
  qmi_wdsi_client_state_type *  cl_sp;
  qmi_wdsi_state_type *         wds_sp;
  uint8                         state;
  uint8                         inst;

  uint32                        cur_tx_rate;
  uint32                        cur_rx_rate;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  LOG_MSG_INFO2_1( "Recvd DUN channel rate (event=%d)", event );

  /* When DUN is disconnected, only generate events from SS change; this
   * suppresses duplicate INDs and ensures we are using the most accurate
   * information for the call state. */
  if (event == QMI_IF_CH_RATE_TRIGGER_SS_CHANGE &&
      qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED)
  {
    LOG_MSG_INFO2_0( "DUN state incorrect, do not send IND" );
    return;
  }

  qmi_if_get_max_channel_rate(QMI_WDSI_DUN_UM_IFACE(qmi_wdsi_global),
                              &cur_tx_rate, &cur_rx_rate);
  LOG_MSG_INFO2_2("channel rates (DUN): tx %d, rx %d",
                  cur_tx_rate, cur_rx_rate);
  LOG_MSG_INFO2_2("last reported rates: tx %d, rx %d",
                  qmi_wdsi_global.dun_tx_rate, qmi_wdsi_global.dun_rx_rate);
  if (cur_rx_rate == qmi_wdsi_global.dun_rx_rate &&
      cur_tx_rate == qmi_wdsi_global.dun_tx_rate)
  {
    return;
  }
  qmi_wdsi_global.dun_rx_rate = cur_rx_rate;
  qmi_wdsi_global.dun_tx_rate = cur_tx_rate;

  /*-------------------------------------------------------------------------
    Report channel rate change to all clients that have registered for it
  -------------------------------------------------------------------------*/
  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }

      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if (cl_sp->modem_rpt_status.ch_rate && 
            (cl_sp->modem_rpt_status.last_tx_rate != cur_tx_rate ||
             cl_sp->modem_rpt_status.last_rx_rate != cur_rx_rate) &&
             qmi_wdsi_verify_client_subs(cl_sp, subs_id, TRUE) )
        {
          qmi_wds_dun_call_info_ind(wds_sp,
                                    cl_sp->common.clid,
                                    (uint32)WDSI_REPORT_MODEM_STATUS_EV_CH_RATE,
                                    QMI_WDS_TRAFFIC_CH_UNKNOWN,
                                    QMI_WDS_BEARER_TECH_UNKNOWN,
                                    cur_tx_rate,
                                    cur_rx_rate,
                                    (qmi_wds_conn_status_e_type) 0);
          cl_sp->modem_rpt_status.last_tx_rate = cur_tx_rate;
          cl_sp->modem_rpt_status.last_rx_rate = cur_rx_rate;
        }
        cl_sp = cl_sp->next;
      } /* for each client */
    } /* for each instance */
  } /* for each state */
} /* qmi_wdsi_generate_dun_channel_rate_ind() */


/*===========================================================================
  FUNCTION QMI_WDSI_GENERATE_PKT_STATS_IND()

  DESCRIPTION
    Called when the timer for pkt_stats timer expires, to update pkt stats
    Causes Event_report_ind to be sent

  PARAMETERS
    cmd_data :  WDS client state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_generate_pkt_stats_ind
(
  uint8  clid 
)
{
  qmi_wdsi_client_state_type *  cl_sp;
  qmi_wdsi_state_type *         wds_sp;
  ps_iface_type *               ps_iface_ptr;
  ps_iface_type *               stat_iface_ptr;
  qmi_wdsi_stats_type           wds_stats = {0};
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cl_sp = qmi_wdsi_get_cl_sp_by_clid(NULL, clid);
  if (cl_sp == NULL)
  {
    LOG_MSG_INFO2_1("Couldn't find clid %d, not sending pkt stats", clid);
    return;
  }

  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);
  if (wds_sp == NULL)
  {
    LOG_MSG_ERROR_1 ("Couldn't find WDS service state! (%x)", cl_sp);
    return;
  }

  ps_iface_ptr = rmnet_meta_sm_iface(wds_sp->binding.rmnet_inst);

  /*-------------------------------------------------------------------------
    Generate pkts statistic indication  for registered clients
  -------------------------------------------------------------------------*/
  if(PS_IFACE_IS_VALID(ps_iface_ptr))
  {
    stat_iface_ptr = qmi_wdsi_get_um_stat_iface(ps_iface_ptr);
    /* we query the um iface, hence tx/rx perspective is swapped*/
    if((E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_PKTS_RX, stat_iface_ptr, &wds_stats.tx_pkts, 4))
     ||(E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_PKTS_TX, stat_iface_ptr, &wds_stats.rx_pkts, 4))
     ||(E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_BYTES_RX, stat_iface_ptr, &wds_stats.tx_bytes, 8))
     ||(E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_BYTES_TX, stat_iface_ptr, &wds_stats.rx_bytes, 8))
     ||(E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_PKTS_DROPPED_RX, stat_iface_ptr, &wds_stats.tx_pkts_dropped, 4))
     ||(E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_PKTS_DROPPED_TX, stat_iface_ptr, &wds_stats.rx_pkts_dropped, 4))
       )
    {
      LOG_MSG_ERROR_1("Unable to get stats for ps_iface_ptr 0x%x!",
                      ps_iface_ptr);
      return;
    }
    
    if( ((cl_sp->report_status.ind_mask & WDSI_STAT_MASK_TX_GOOD_NW) &&
         (wds_stats.rx_pkts != cl_sp->report_status.stats_last_rpt.rx_pkts))   ||
        ((cl_sp->report_status.ind_mask & WDSI_STAT_MASK_RX_GOOD_NW) &&
         (wds_stats.tx_pkts != cl_sp->report_status.stats_last_rpt.tx_pkts))   ||
        ((cl_sp->report_status.ind_mask & WDSI_STAT_MASK_TX_OK_BYTES) &&
         (wds_stats.rx_bytes != cl_sp->report_status.stats_last_rpt.rx_bytes)) ||
        ((cl_sp->report_status.ind_mask & WDSI_STAT_MASK_RX_OK_BYTES) &&
         (wds_stats.tx_bytes != cl_sp->report_status.stats_last_rpt.tx_bytes)) ||
        ((cl_sp->report_status.ind_mask & WDSI_STAT_MASK_TX_DROPPED) &&
         (wds_stats.rx_pkts_dropped != cl_sp->report_status.stats_last_rpt.rx_pkts_dropped)) ||
        ((cl_sp->report_status.ind_mask & WDSI_STAT_MASK_RX_DROPPED) &&
         (wds_stats.tx_pkts_dropped != cl_sp->report_status.stats_last_rpt.tx_pkts_dropped))
      )
      {
      qmi_wdsi_event_report_ind(wds_sp,
                                cl_sp->common.clid,
                                WDSI_REPORT_STATUS_EV_PKT_STATS,
                                0,
                                0,
                                &wds_stats,
                                QMI_WDS_BEARER_TECH_UNKNOWN,
                                0,
                                QMI_WDS_TRAFFIC_CH_UNKNOWN,
                                NULL,
                                0,
                                WDSI_CALL_UKNOWN,
                                WDSI_DATA_CALL_NONE,                                
                                0,
                                NULL,
                                NULL,
                                NULL,
                                NULL);
    }
  }
  else
  {
    LOG_MSG_INFO1_1 ("Transfer statistics timeout for clid %d while if down!",
                     cl_sp->common.clid);
  }
} /* qmi_wdsi_generate_pkt_stats_ind() */


/*===========================================================================
  FUNCTION QMI_WDSI_GENERATE_DUN_PKT_STATS_IND()

  DESCRIPTION
    Called when the timer for dun_stats_timer timer expires, to update
    pkt stats
    Causes DUN_CALL_INFO_IND to be sent

  PARAMETERS
    cmd_data :  WDS client state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_wdsi_generate_dun_pkt_stats_ind
(
  uint8  clid
)
{
  qmi_wdsi_client_state_type *  cl_sp;
  qmi_wdsi_state_type *         wds_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cl_sp = qmi_wdsi_get_cl_sp_by_clid(NULL, clid);
  if (cl_sp == NULL)
  {
    LOG_MSG_INFO2_1("Couldn't find clid %d, not sending dun pkt stats", clid);
    return;
  }

  LOG_MSG_INFO2_1("Recvd new DUN pkt statistics (%d)",
                  qmi_wdsi_global.dun_state);

  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);
  if (wds_sp == NULL)
  {
    LOG_MSG_ERROR_1 ("Couldn't find WDS service state! (%x)", cl_sp);
    return;
  }

  if(qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED && 
     qmi_wdsi_verify_client_subs(cl_sp, qmi_wdsi_global.dun_subs_id, TRUE))
  {
    /* send modem status ind to send byte statistics */
    qmi_wds_dun_call_info_ind(wds_sp,
                              cl_sp->common.clid,
                              (uint32)WDSI_REPORT_MODEM_STATUS_EV_PKT_STATS,
                              QMI_WDS_TRAFFIC_CH_UNKNOWN,
                              QMI_WDS_BEARER_TECH_UNKNOWN,
                              0,
                              0,
                              (qmi_wds_conn_status_e_type) 0);
  }
  else
  {
    LOG_MSG_INFO2_1("Transfer statistics timeout for clid %d while DUN if down!",
                    cl_sp->common.clid);
  }
} /* qmi_wdsi_generate_dun_pkt_stats_ind() */

/*===========================================================================
  FUNCTION QMI_WDSI_PROCESS_PHYS_LINK_EVENT()

  DESCRIPTION
    This function is called from DCC task and is used to process phys link
    events on UM iface. WDSI_UM_PHYS_LINK_EV_HDLR_CB() posts a QMI command to
    handle these events in the DCC task. This function reports the
    dormancy status (1=dormant, 2=active) based on phys_link events down and
    up respectively.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_process_phys_link_event
(
  ps_phys_link_type            *this_phys_link_ptr,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  void                         *user_data_ptr
)
{
  qmi_wdsi_state_type *  wds_sp;
  qmi_wds_dormancy_status_e_type dormancy_status;
  time_type                      time;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT (user_data_ptr);
  wds_sp = (qmi_wdsi_state_type *)user_data_ptr;
  /*-------------------------------------------------------------------------
    Act on change in phys link state (up/down)
    - Up: indicate traffic channel active
    - Down: indicate traffic channel dormant
  -------------------------------------------------------------------------*/
  dormancy_status = QMI_WDS_TRAFFIC_CH_DORMANT;

  LOG_MSG_INFO1_1( "Physlink ev %d occured (Traffic channel status changed)",
                   event );

  switch( event )
  {
    case PHYS_LINK_UP_EV:
    {
     /*---------------------------------------------------------------------
       Indicate that traffic channel is active
      ---------------------------------------------------------------------*/
      dormancy_status = QMI_WDS_TRAFFIC_CH_ACTIVE;
      qmi_wdsi_generate_dormancy_status_ind(user_data_ptr, dormancy_status);

      time_get_uptime_ms( wds_sp->last_active_start_time );
      break;
    }

    case PHYS_LINK_DOWN_EV:
    {
     /*---------------------------------------------------------------------
       Indicate that traffic channel is dormant
      ---------------------------------------------------------------------*/
      dormancy_status = QMI_WDS_TRAFFIC_CH_DORMANT;
      qmi_wdsi_generate_dormancy_status_ind(user_data_ptr, dormancy_status);

      QMI_INCREMENT_TOTAL_ACTIVE_TIME(time);
      break;
    }

    case PHYS_LINK_707_DOS_ACK_EV:
    {
     /*---------------------------------------------------------------------
       Indicate that DOS ACK Event has occured
      ---------------------------------------------------------------------*/
      qmi_wdsi_generate_internal_iface_ev_ind( wds_sp,
                                               WDSI_INT_IF_EV_DOS_ACK,
                                               event_info );
      break;
    }

    default:
    {
      LOG_MSG_ERROR_1("Unregistered event %d recvd, ignoring", event);
      break;
    }
  } /* switch( event ) */

} /* qmi_wdsi_process_phys_link_event() */

/*===========================================================================
  FUNCTION QMI_WDSI_PROCESS_DUN_PHYS_LINK_EVENT()

  DESCRIPTION
    This function is called from DCC task and is used to process phys link
    events on UM iface. WDSI_DUN_UM_PHYS_LINK_EV_HDLR_CB() posts a QMI command to
    handle these events in the DCC task. This function reports the
    dormancy status (1=dormant, 2=active) based on phys_link events down and
    up respectively.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_process_dun_phys_link_event
(
  ps_phys_link_type            *this_phys_link_ptr,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  void                         *user_data_ptr
)
{
  qmi_wds_dormancy_status_e_type dormancy_status;
  time_type                      time;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    Act on change in phys link state (up/down)
    - Up: indicate traffic channel active
    - Down: indicate traffic channel dormant
  -------------------------------------------------------------------------*/
  dormancy_status = QMI_WDS_TRAFFIC_CH_DORMANT;

  LOG_MSG_INFO1_1( "Physlink ev %d occured (Traffic channel status changed)",
                   event );

  switch( event )
  {
    case PHYS_LINK_UP_EV:
    {
     /*---------------------------------------------------------------------
       Indicate that traffic channel is active
      ---------------------------------------------------------------------*/
      dormancy_status = QMI_WDS_TRAFFIC_CH_ACTIVE;
      qmi_wdsi_generate_dun_dormancy_status_ind(dormancy_status);

      time_get_uptime_ms( qmi_wdsi_global.modem_dun_last_active_start_time );
      break;
    }

    case PHYS_LINK_DOWN_EV:
    {
     /*---------------------------------------------------------------------
       Indicate that traffic channel is dormant
      ---------------------------------------------------------------------*/
      dormancy_status = QMI_WDS_TRAFFIC_CH_DORMANT;
      qmi_wdsi_generate_dun_dormancy_status_ind(dormancy_status);

      QMI_INCREMENT_DUN_TOTAL_ACTIVE_TIME(time);
      break;
    }

    default:
    {
      break;
    }
  } /* switch( event ) */

} /* qmi_wdsi_process_dun_phys_link_event() */

#define QMI_WDS_AUTOCONNECT_BACKOFF_TIMER_MIN_VALUE  1
/*===========================================================================
  FUNCTION QMI_WDS_PROCESS_OPRT_MODE()

  DESCRIPTION
    Process needed actions for operation mode change event from CM
    Called when Operating Mode Change in CM_PH event is received.

  PARAMETERS
    oprt_mode :  Operating mode

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_wds_process_oprt_mode
(
  sys_oprt_mode_e_type             oprt_mode
)
{
  rmnet_instance_e_type  rm_instance;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  LOG_MSG_INFO2_1("Enter qmi_wds_process_oprt_mode = (%d)", oprt_mode);
  switch (oprt_mode)
  {
    case SYS_OPRT_MODE_ONLINE:
      /* Set Rmnet autoconenct timer as minimum so that the autoconnect
      ** procedure can happend right away after entering ONLine
      */
      for (rm_instance = RMNET_INSTANCE_MIN; rm_instance < RMNET_INSTANCE_MAX; 
                                                                   rm_instance++)
      {
        rmnet_meta_sm_set_autoconnect_delay_timer (rm_instance ,
                                 QMI_WDS_AUTOCONNECT_BACKOFF_TIMER_MIN_VALUE);
      } /* for() */
      break;

    default:
      break;

  } /* switch()*/

} /* qmi_wds_process_oprt_mode() */

/*===========================================================================
  FUNCTION QMI_WDS_BRINGUP_ON_REV_IP_TRANSPORT_INSTANCE()

  DESCRIPTION
    Performs initialization needed for WDS instance on which Reverse IP transport is
    being set up

  PARAMETERS
    iface_ptr :  iface ptr thats being brought up by MH for which reverse data path
                 needs to be setup
    wds_inst  : WDS Instance on which Reverse IP Transport is to be established

  RETURN VALUE
    0 on Failure
    1 on Succes

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_wds_bringup_on_rev_ip_transport_instance
(
  ps_iface_type *             iface_ptr,
  uint32                      ep_id,
  uint8                       mux_id
)
{
  qmi_wdsi_state_type      * wds_sp;
  uint8                      wds_inst;
  ps_iface_event_enum_type      err_ev = IFACE_EVENT_MAX;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_inst = wdsi_get_inst_from_ep_and_mux_id(ep_id, mux_id);
  if (wds_inst >= WDS_INSTANCE_MAX)
  {
    LOG_MSG_ERROR_2("Unable to get wds inst from ep_id 0x%x, mux_id %d",
                    ep_id, mux_id);
    return FALSE;
  }

  ASSERT(iface_ptr);

  if (PS_IFACE_IS_ADDR_FAMILY_V4(iface_ptr))
  {
    wds_sp = qmi_wds_state[WDSI_IPV4_STATE][wds_inst];
  }
  else
  {
    wds_sp = qmi_wds_state[WDSI_IPV6_STATE][wds_inst];
  }

  /* Check that wds_sp is valid, it could be NULL if no client is allocated */
  if (!wds_sp)
  {
    LOG_MSG_ERROR_0("Couldn't register for WLAN/EPDG iface events since no WDS client allocated!");
    return FALSE;
  }

  ASSERT(wds_sp->binding.is_reversed);

  do
  {
    /* Register for intereted events on WLAN/EPDG iface */
    if(0 != ps_iface_event_cback_reg(iface_ptr,
                                   IFACE_CONFIGURING_EV,
                                   wds_sp->wlan_iface_configuring_buf_ptr))
    {
        err_ev = IFACE_CONFIGURING_EV;
        break; 
    }

    if(0 != ps_iface_event_cback_reg(iface_ptr,
                                     IFACE_DOWN_EV,
                                     wds_sp->wlan_iface_down_buf_ptr))
    {
        err_ev = IFACE_DOWN_EV;
        break; 
    }

    if(0 != ps_iface_event_cback_reg(iface_ptr,
                                     IFACE_REVERSE_IP_TRANSPORT_CONFIG_EV,
                                     wds_sp->wlan_iface_rev_ip_transport_config_buf_ptr))
    {
        err_ev = IFACE_REVERSE_IP_TRANSPORT_CONFIG_EV;
        break; 
    }
  }while(0);

  if(err_ev != IFACE_EVENT_MAX)
  {
    LOG_MSG_ERROR_1("Couldn't register for WLAN/EPDG iface event: %d!",err_ev);
    ASSERT(0);
    return FALSE;
  }

  wds_sp->wlan_iface_ptr = iface_ptr;

  return TRUE;
} /* qmi_wds_bringup_on_rev_ip_transport_instance */

/*===========================================================================

                             INTERNAL FUNCTIONS

===========================================================================*/

/*===========================================================================
  FUNCTION QMI_WDSI_SNI_ABORT_HDLR()

  DESCRIPTION
    Abort handler for the Start Network Interface Operation

  PARAMETERS
    wds_sp     : Service provided state pointer
    cmd_buf_p  : Ptr to the cmd buf to be aborted

  RETURN VALUE
    TRUE       : Abort succeeded
    FALSE      : Abort Failed

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_wdsi_sni_abort_hdlr
(
  qmi_wdsi_state_type *  wds_sp,
  qmi_cmd_buf_type *     cmd_buf_p
)
{
  qmi_cmd_buf_type *  aborted_cmd_buf_p;
  dsm_item_type *     aborted_cmd_response;
  wds_abort_resp_msg_v01 resp_msg;
  boolean             retval;
  boolean             pending_resp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    extract cmd_buf_p under queue function (mutexed) to ensure that
     CM task concurrent cm_network_scan_cb doesn't mess things up.
  -------------------------------------------------------------------------*/
  memset(&resp_msg,0,sizeof(resp_msg));
  aborted_cmd_buf_p =
    q_linear_delete_new(
      &wds_sp->sni_pend_q,
      (q_compare_func_type) qmi_svc_cmd_buf_belongs_to_client_transaction,
      cmd_buf_p,
      (q_action_func_type) NULL,
      NULL);

  if(aborted_cmd_buf_p == NULL)
  {
    LOG_MSG_INFO1_0("SNI completed but response still pending transaction"
                    "completion!");
    return FALSE; //cmd already completed can't be aborted
  }

  (void)qmi_wdsi_stop_net_iface_client(
                (qmi_wdsi_client_state_type *)aborted_cmd_buf_p->x_p->cl_sp,
                 WDSI_FORCE_REASON_ABORT, &pending_resp );

#ifdef FEATURE_DATA_QMI_MCAST
  /*-------------------------------------------------------------------------
    make sure to clear out mcast_inst flag when appropriate,
    as SNI is being aborted
  -------------------------------------------------------------------------*/
  if(wds_sp->is_mcast_inst == TRUE)
  {
    /*-----------------------------------------------------------------------
      IF no other client using this wds instance then set boolean to false
    -----------------------------------------------------------------------*/
    if (!qmi_wdsi_net_if_bound( wds_sp ))
    {
      /* dereg events as aborting */
      if(wds_sp->reg_mcast_iface_ev == TRUE)
      {
        wdsi_dereg_iface_mcast_event(wds_sp);
      }
      wds_sp->is_mcast_inst = FALSE;
    }
  }
#endif /* FEATURE_DATA_QMI_MCAST */

  /* Deregister eMBMS events if no client using it */
  if (wds_sp->is_embms_inst == TRUE)
  {
    if (!qmi_wdsi_net_if_bound(wds_sp))
    {
      wdsi_dereg_iface_embms_event(wds_sp);
      wds_sp->is_embms_inst = FALSE;
    }
  }

  /*-----------------------------------------------------------------------
    Send a response for the aborted cmd with ERR_ABORTED
  -----------------------------------------------------------------------*/
  retval = QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_ABORT_RESP_V01,
                                        &resp_msg,
                                        sizeof(resp_msg),
                                        QMI_ERR_ABORTED_V01,
                                        &aborted_cmd_response);
  if( retval != TRUE )
  {
    ds_qmi_fw_free_cmd_buf(&aborted_cmd_buf_p);
    return FALSE;
  }

  if ( FALSE == qmi_wdsi_send_response(
                     aborted_cmd_buf_p, aborted_cmd_response) )
  {
    LOG_MSG_INFO2_0 ("Unable to send SNI response");
    dsm_free_packet(&aborted_cmd_response);
    ds_qmi_fw_free_cmd_buf(&aborted_cmd_buf_p);
  }

  return TRUE;
} /* qmi_wdsi_sni_abort_hdlr() */



/*===========================================================================
  FUNCTION QMI_WDSI_ABORT()

  DESCRIPTION
    Abort an outstanding WDS command specified by transaction ID

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_abort
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              *  response;
  qmi_wdsi_state_type        *  wds_sp;
  qmi_wdsi_client_state_type *  wds_client_sp;
  qmi_error_type_v01   errval;
  boolean            got_atleast_one_abortable_cmd;
  uint8              tx_ix;
  uint8              cmd;
  wds_abort_req_msg_v01  req_msg;
  wds_abort_resp_msg_v01 resp_msg;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&req_msg,0,sizeof(wds_abort_req_msg_v01));
  memset(&resp_msg,0,sizeof(wds_abort_resp_msg_v01));

  wds_sp = (qmi_wdsi_state_type *) sp;
  wds_client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  /*-------------------------------------------------------------------------
    Parse the incoming message
  -------------------------------------------------------------------------*/
  errval   = QMI_ERR_NONE_V01;
  response = NULL;
  got_atleast_one_abortable_cmd = FALSE;
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_ABORT_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(wds_abort_req_msg_v01));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  
  /*-------------------------------------------------------------------------
    Allow tx_id 0 to support QCCI clients.
    Search all transcations and abort the SNI request if found.
  -------------------------------------------------------------------------*/
  if (req_msg.tx_id == 0 )
  {
    for (tx_ix = 0; tx_ix < MAX_PENDING_TRANSACTIONS; tx_ix++)
    {
      if (wds_client_sp->common.transactions[tx_ix].x_id != 0)
      {
        for (cmd = 0; cmd < wds_client_sp->common.transactions[tx_ix].n_cmds; cmd++)
        {
          if (wds_client_sp->common.transactions[tx_ix].cmd_list[cmd]->cmd_type ==
                     WDSI_CMD_VAL_START_NETWORK_INTERFACE)
          {
            LOG_MSG_INFO2_1("Found SNI with tx_id %d",
                            wds_client_sp->common.transactions[tx_ix].x_id);
            if (TRUE != qmi_wdsi_sni_abort_hdlr(
                   wds_sp,
                   wds_client_sp->common.transactions[tx_ix].cmd_list[cmd]))
            {
              errval = QMI_ERR_UNABORTABLE_TRANSACTION_V01;
            }
            goto send_result;
          }
        }
      }
    }
    LOG_MSG_INFO2_0("No SNI found!");
    errval = QMI_ERR_INVALID_TX_ID_V01;
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    If request is valid, abort the specified transaction
  -------------------------------------------------------------------------*/
  for(tx_ix=0; tx_ix<MAX_PENDING_TRANSACTIONS; tx_ix++)
  {
    if(wds_client_sp->common.transactions[tx_ix].x_id == req_msg.tx_id)
    {
      break;
    }
  }

  if(MAX_PENDING_TRANSACTIONS == tx_ix)
  {
    LOG_MSG_INFO2_1( "Transaction (%x) not outstanding - can't abort!",
                     req_msg.tx_id );
    errval = QMI_ERR_INVALID_TX_ID_V01;
    goto send_result;
  }

  for(cmd=0; cmd<wds_client_sp->common.transactions[tx_ix].n_cmds; cmd++)
  {
    if(wds_client_sp->common.transactions[tx_ix].cmd_list[cmd]->cmd_type ==
                                    WDSI_CMD_VAL_START_NETWORK_INTERFACE)
    {
      if(TRUE == qmi_wdsi_sni_abort_hdlr(
                   wds_sp,
                   wds_client_sp->common.transactions[tx_ix].cmd_list[cmd]))
      {
        got_atleast_one_abortable_cmd = TRUE;
      }
    }
  }

  if(got_atleast_one_abortable_cmd == FALSE)
  {
    errval = QMI_ERR_UNABORTABLE_TRANSACTION_V01;
    goto send_result;
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_ABORT_RESP_V01,
                           &resp_msg,
                           sizeof(resp_msg),
                           errval,
                           &response);
  return response;

} /* qmi_wdsi_abort() */



/*===========================================================================
  FUNCTION QMI_WDSI_RESET()

  DESCRIPTION
    Reset the issuing client's WDS state

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response or NULL if none.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_reset
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *              response;
  wds_reset_resp_msg_v01       resp_msg;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  memset(&resp_msg,0,sizeof(wds_reset_resp_msg_v01));
  /*-------------------------------------------------------------------------
    Reset the client's state
  -------------------------------------------------------------------------*/
  qmi_wdsi_reset_client(cl_sp);

  /*-------------------------------------------------------------------------
    No error possible in reset, so result is success
  -------------------------------------------------------------------------*/
  response = NULL;

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_RESET_RESP_V01,
                           &resp_msg,
                           sizeof(resp_msg),
                           QMI_ERR_NONE_V01,
                           &response);
    return response;
} /* qmi_wdsi_reset() */


/*===========================================================================
  FUNCTION QMI_WDSI_INDICATION_REGISTER()

  DESCRIPTION
    Set the conditions for indication reporting

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_indication_register
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_indication_register_req_msg_v01 req_msg;
  wds_indication_register_resp_msg_v01 resp_msg;

  qmi_wdsi_client_state_type *  wds_client_sp;
#ifdef FEATURE_EPC_HANDOFF
  qmi_wdsi_state_type *  wds_sp;
  qmi_wdsi_state_type *  wds_sp_2 = NULL;
#endif /* FEATURE_EPC_HANDOFF */
  qmi_error_type_v01   errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  wds_client_sp = (qmi_wdsi_client_state_type *)cl_sp;
#ifdef FEATURE_EPC_HANDOFF
  wds_sp = (qmi_wdsi_state_type *)sp;
#endif /* FEATURE_EPC_HANDOFF */

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_INDICATION_REGISTER_REQ_V01,
  	                                   sdu_in,
  	                                   &req_msg,
  	                                   sizeof(req_msg));

  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    If ALL optional TLVs are absent return error or else carry on and
    process the request. (Needed since NO mandatory TLVs)
  -------------------------------------------------------------------------*/
  if (req_msg.report_embms_tmgi_list_valid)
  {
    wds_client_sp->report_status.report_tmgi_list =
                            req_msg.report_embms_tmgi_list ? TRUE : FALSE;
  }

  if (req_msg.suppress_pkt_srvc_ind_valid)
  {
    wds_client_sp->report_status.suppress_pkt_ind =
                            req_msg.suppress_pkt_srvc_ind? TRUE : FALSE;
  }

  if (req_msg.report_extended_ip_config_change_valid)
  {
    wds_client_sp->report_status.report_extended_ip_config =
                            req_msg.report_extended_ip_config_change ? TRUE : FALSE;
  }
#ifdef FEATURE_DATA_LTE
  if (req_msg.report_lte_attach_pdn_list_change_valid)
  {
    wds_client_sp->report_status.report_attach_pdn_list_change =
                            req_msg.report_lte_attach_pdn_list_change ? TRUE : FALSE;
  }
#endif /* FEATURE_DATA_LTE */
 
#ifdef FEATURE_EPC_HANDOFF
  if (req_msg.report_handoff_information_valid)
  {
    wds_client_sp->report_status.report_handoff_information_change =
                            req_msg.report_handoff_information ? TRUE : FALSE;
    if(wds_client_sp->wds_inst < WDS_INSTANCE_MAX)
    {
      if( wds_client_sp->current_wds_state == WDSI_IPV4_STATE)
      {
          wds_sp_2 = qmi_wds_state[WDSI_IPV6_STATE][wds_client_sp->wds_inst];
      }
      else
      {
          wds_sp_2 = qmi_wds_state[WDSI_IPV4_STATE][wds_client_sp->wds_inst];
      }
    }
    if (FALSE == wds_sp->handoff_iface_ev_reg)
    {
      /* First request from client to register for handoff iface events */
      wds_sp->handoff_iface_ev_reg = TRUE;
      if (wds_sp->pkt_svc_state == QMI_WDS_CONN_CONNECTED)
      {
        /* Call is up. Register for handoff iface events */
        LOG_MSG_INFO2_0 ("Client requests handoff iface event registration for the "
                         "first time after call is up");
        wdsi_reg_iface_handoff_event( wds_sp );
      }
      if(wds_sp_2 != NULL)
      {
        /* First request from client to register for handoff iface events */
        wds_sp_2->handoff_iface_ev_reg = TRUE;
        LOG_MSG_INFO2_0("setting handoff event reg true for wds_sp");
        if (wds_sp_2->pkt_svc_state == QMI_WDS_CONN_CONNECTED)
        {
          /* Call is up. Register for handoff iface events */
          LOG_MSG_INFO2_0("Client requests handoff iface event registration for the "
                   "first time after call is up");
          wdsi_reg_iface_handoff_event( wds_sp_2 );
        }
      }
    }
  }
#endif /* FEATURE_EPC_HANDOFF */

#ifdef FEATURE_DATA_EMBMS
  if (req_msg.report_embms_sai_list_valid)
  {
    wds_client_sp->report_status.report_sai_list =
                            req_msg.report_embms_sai_list ? TRUE : FALSE;
  }
#endif /* FEATURE_DATA_EMBMS */
 
  if (req_msg.report_profile_changed_events_valid)
  {
    wds_client_sp->report_status.report_profile_change_events =
                            req_msg.report_profile_changed_events  ? TRUE : FALSE;
  }
 
  if (req_msg.report_throughput_valid)
  {
    wds_client_sp->report_status.report_thrpt_info_change =
                            req_msg.report_throughput ? TRUE : FALSE;
  }

  if (req_msg.report_roaming_apn_list_valid)
  {
    wds_client_sp->report_status.report_roaming_info_change =
                            req_msg.report_roaming_apn_list ? TRUE : FALSE;
  }

  if (req_msg.report_dl_throughput_valid)
  {
    wds_client_sp->report_status.report_dl_thrpt_info_change =
                            req_msg.report_dl_throughput ? TRUE : FALSE;
  }

  if (req_msg.report_embms_content_desc_control)
  {
    wds_client_sp->report_status.report_embms_content_desc_change =
                            req_msg.report_embms_content_desc_control ? TRUE : FALSE;
  }

  if(req_msg.report_apn_param_change_info_valid)
  {
    wds_client_sp->report_status.report_apn_param_changed = 
                            req_msg.report_apn_param_change_info ? TRUE : FALSE;
  }

  send_result:

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_EVENT_REPORT_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;

} /* qmi_wdsi_indication_register() */


/*===========================================================================
  FUNCTION QMI_WDSI_START_NETWORK_INTERFACE()

  DESCRIPTION
    To bind a control point to the WWAN device's data session

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type *  qmi_wdsi_start_network_interface
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *       wds_sp;
  qmi_wdsi_client_state_type *  wds_client_sp;
  rmnet_meta_sm_network_info_type  *sni_params;
  ps_iface_type *             um_iface_ptr1;
  ps_iface_type *             um_iface_ptr2;
  qmi_error_type_v01          errval;
  boolean                     start_call;
  boolean                     enable_autoconnect;
  uint8                       tech_pref;
  uint16                      ext_tech_pref;
  uint8                       umts_profile_id;
  uint16                      umts_default_profile_num = 0;
  uint16                      cdma_default_profile_num = 0;
  uint8                       profile_family = 0;
  uint8                       inst = 0, temp = 0;
  rmnet_meta_sm_arb_info_type arb_info;
  uint16                      packet_filter_id;
  uint32                      subs_id = 0;
  wds_start_network_interface_req_msg_v01 *req_msg = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset( &arb_info, 0, sizeof(rmnet_meta_sm_arb_info_type) );
  wds_sp = (qmi_wdsi_state_type *) sp;
  wds_client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  inst = wdsi_get_instance_from_wds_sp(sp);

  ASSERT(inst < WDS_INSTANCE_MAX);

  /*-------------------------------------------------------------------------
    Parse command
  -------------------------------------------------------------------------*/
  errval         = QMI_ERR_NONE_V01;
  enable_autoconnect = FALSE;
  tech_pref = WDS_TECH_PREF_ANY;
  ext_tech_pref = 0;

  /* Validate that request is not sent on a reverse IP transport instance */
  if (wds_sp->binding.is_reversed ||
      wds_sp->binding.rmnet_inst >= RMNET_INSTANCE_MAX)
  {
    errval = QMI_ERR_INVALID_OPERATION_V01;
    LOG_MSG_ERROR_1("SNI request sent on non-binding instance %d", inst);
    return wdsi_gen_start_network_interface_response( errval,
                                                      wds_client_sp,
                                                      QMI_WDS_CALL_END_REASON_MIN,
                                                      0, 0, 0 );
  }

  /*-------------------------------------------------------------------------
    Initialize sni_params
    set the profile id to default profile, so that default profile is used
    if the config profile TLV is absent.
    tech_pref is ANY (WWAN_GROUP as of now)
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC(sni_params,
                sizeof(rmnet_meta_sm_network_info_type),
                           rmnet_meta_sm_network_info_type*); 

  if (NULL == sni_params)
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    return wdsi_gen_start_network_interface_response( errval,
                                                      wds_client_sp,
                                                      QMI_WDS_CALL_END_REASON_MIN,
                                                      0, 0 , 0 );

  }

  memset(sni_params, 0, sizeof(rmnet_meta_sm_network_info_type));

  subs_id = qmi_wdsi_resolve_client_subs(wds_client_sp);

  profile_family = WDS_PROFILE_RMNET_FAMILY;
  (void) qmi_wds_profile_retrieve_default_profile_num(WDS_PROFILE_TYPE_3GPP,
                                                      profile_family,
                                                      &umts_default_profile_num, 
                                                      subs_id);
  umts_profile_id = (uint8)umts_default_profile_num;

  /* No Profile Family for 3GPP2 */
  profile_family = 0;
  (void) qmi_wds_profile_retrieve_default_profile_num(WDS_PROFILE_TYPE_3GPP2,
                                                      profile_family,
                                                      &cdma_default_profile_num,
                                                      subs_id);
  sni_params->cdma_profile_num = (uint8)cdma_default_profile_num;

  sni_params->tech_pref        = WWAN_GROUP;
  sni_params->ip_family_pref   = wds_sp->cur_ip_call_type;
  sni_params->subscription_id  = subs_id;

  LOG_MSG_INFO2_1("SNI req on subs %d ", sni_params->subscription_id);

  PS_SYSTEM_HEAP_MEM_ALLOC(req_msg,sizeof(wds_start_network_interface_req_msg_v01),
                           wds_start_network_interface_req_msg_v01*);
  if(req_msg == NULL)
  {
    PS_SYSTEM_HEAP_MEM_FREE(sni_params);
    return wdsi_gen_start_network_interface_response( QMI_ERR_NO_MEMORY_V01,
                                                      wds_client_sp,
                                                      QMI_WDS_CALL_END_REASON_INTERNAL_ERROR,
                                                      0, 0 , 0 );
  }
  memset(req_msg,0,sizeof(wds_start_network_interface_req_msg_v01));
  
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_START_NETWORK_INTERFACE_REQ_V01,
                                       sdu_in,
                                       req_msg,
                                       sizeof(wds_start_network_interface_req_msg_v01));
  if(errval != QMI_ERR_NONE_V01)
  {
    PS_SYSTEM_HEAP_MEM_FREE(sni_params);
    PS_SYSTEM_HEAP_MEM_FREE(req_msg);
    return wdsi_gen_start_network_interface_response( errval,
                                                      wds_client_sp,
                                                      QMI_WDS_CALL_END_REASON_INTERNAL_ERROR,
                                                      0, 0 , 0 );
  }
  if(req_msg->technology_preference_valid)
  {
    tech_pref = req_msg->technology_preference;
  }
  if(req_msg->profile_index_valid)
  {
    umts_profile_id = req_msg->profile_index;
  }
  if(req_msg->profile_index_3gpp2_valid)
  {
    sni_params->cdma_profile_num = req_msg->profile_index_3gpp2;
  }
  if(req_msg->primary_DNS_IPv4_address_preference_valid)
  {
    sni_params->cfg_info.ipcp_info.primary_dns = 
                    req_msg->primary_DNS_IPv4_address_preference;
    sni_params->cfg_info.valid_fields |= NET_CFG_PRM_PRI_DNS_MASK;
  }
  if(req_msg->secondary_DNS_IPv4_address_preference_valid)
  {
    sni_params->cfg_info.valid_fields |= NET_CFG_PRM_SEC_DNS_MASK;
    sni_params->cfg_info.ipcp_info.secondary_dns = 
                    req_msg->secondary_DNS_IPv4_address_preference;
  }
  if(req_msg->primary_nbns_address_pref_valid)
  {
    sni_params->cfg_info.valid_fields |= NET_CFG_PRM_PRI_NBNS_MASK;
    sni_params->cfg_info.ipcp_info.primary_nbns = 
                    req_msg->primary_nbns_address_pref;
  }
  if(req_msg->secondary_nbns_address_pref_valid)
  {
    sni_params->cfg_info.valid_fields |= NET_CFG_PRM_SEC_NBNS_MASK;
    sni_params->cfg_info.ipcp_info.secondary_nbns = 
                    req_msg->secondary_nbns_address_pref;
  }
  if(req_msg->ipv4_address_pref_valid)
  {
    sni_params->cfg_info.valid_fields |= NET_CFG_PRM_IP_ADDR_MASK;
    sni_params->cfg_info.ipcp_info.ip_address = 
                                  req_msg->ipv4_address_pref;
  }
  if(req_msg->authentication_preference_valid)
  {
    sni_params->cfg_info.valid_fields |= NET_CFG_PRM_AUTH_PREF_MASK;
    sni_params->cfg_info.auth_info.auth_type = req_msg->authentication_preference;
  }
  if(req_msg->username_valid)
  {
    if(strlen(req_msg->username) <= 
       sizeof(sni_params->cfg_info.auth_info.params.user_id_info))
    {
      sni_params->cfg_info.valid_fields |= NET_CFG_PRM_AUTH_USERNAME_MASK;
      sni_params->cfg_info.auth_info.params.user_id_len = 
                  (uint8)strlen(req_msg->username);
      strlcpy(sni_params->cfg_info.auth_info.params.user_id_info,
              req_msg->username,sizeof(sni_params->cfg_info.auth_info.params.user_id_info));
    }
    else
    {
      errval = QMI_ERR_ARG_TOO_LONG_V01;
      goto send_result;
    }
  }
  if(req_msg->password_valid)
  { 
    if(strlen(req_msg->password) <= 
              sizeof(sni_params->cfg_info.auth_info.params.passwd_info))
    {
      sni_params->cfg_info.valid_fields |= NET_CFG_PRM_AUTH_PASSWORD_MASK;
      sni_params->cfg_info.auth_info.params.passwd_len = 
                 (uint8) strlen(req_msg->password);
      strlcpy(sni_params->cfg_info.auth_info.params.passwd_info,
              req_msg->password,sizeof(sni_params->cfg_info.auth_info.params.passwd_info));
    }
    else
    {
      errval = QMI_ERR_ARG_TOO_LONG_V01;
      goto send_result;
    }
  }
  if(req_msg->apn_name_valid)
  {
    if (strlen(req_msg->apn_name) <= sizeof(sni_params->apn.name))
    {
      sni_params->apn.length = (uint8)strlen(req_msg->apn_name);
      strlcpy(sni_params->apn.name,req_msg->apn_name,sizeof(sni_params->apn.name));
    }
    else
    {
      errval = QMI_ERR_ARG_TOO_LONG_V01;
      goto send_result;
    }
  }
  if(req_msg->ip_family_preference_valid)
  {
    sni_params->ip_family_pref = req_msg->ip_family_preference;
  }
  if(req_msg->enable_autoconnect_valid)
  {
    enable_autoconnect = req_msg->enable_autoconnect;
  }
  if(req_msg->ext_technology_preference_valid)
  {
    ext_tech_pref = req_msg->ext_technology_preference;
  }
  if(req_msg->call_type_valid)
  {
    sni_params->call_type = req_msg->call_type;
  }
#ifdef FEATURE_DATA_LTE  
  if(req_msg->handoff_context_valid)
  {
    sni_params->is_handoff_context_valid = TRUE;
  }
#endif /* FEATURE_DATA_LTE */
  if(req_msg->ips_id_valid)
  {
    sni_params->ips_id = req_msg->ips_id;
  }

  if(req_msg->apn_type_valid)
  {
    sni_params->apn_type = req_msg->apn_type;
  }
  sni_params->umts_profile_num = (uint16)umts_profile_id;
  /* validate the IP family preference */
  if ((errval = qmi_wdsi_validate_ip_family_pref(sni_params->ip_family_pref))
                                                                != QMI_ERR_NONE_V01) 
  {
    goto send_result;
  }

  if( QMI_AF_ANY != wds_client_sp->bound_ip_type )
  {
    // if this is not legacy client
    //
    //because we have one instance always assigned to v4 and another always to v6
    //non-legacy clients are already in correct instance before SNI is issued
    if( QMI_AF_UNSPEC != sni_params->ip_family_pref && QMI_AF_ANY != sni_params->ip_family_pref &&
        sni_params->ip_family_pref != wds_client_sp->bound_ip_type )
    {
      LOG_MSG_INFO2_0("Invalid value of IP family in SNI");
      errval = QMI_ERR_INVALID_IP_FAMILY_PREF_V01;
      goto send_result;
    }
    sni_params->ip_family_pref = wds_client_sp->bound_ip_type;

  }else // if this is indeed legacy client then we might need to switch the instance
        // V6 brough up by default client
        // V4 brough up by new client
        // V6 terminated
        // V4 requested by default client
        // need to switch instance with V4 call up to be default instance
  {
    //first check if default instance already in a call, if it is then
    //proceed with processing. If it is not in a call then
    // 1. if default instance has same IP family as SNI param: proceeed with the call
    // 2. else if default instance IP family != SNI param : switch default to another instance

    // TODO: a special case to consider what if default instance has a call up but none
    // none of the default clients are in a call? this way default clients are stuck in this instance
    if(wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED)
    {
      if( QMI_AF_UNSPEC != sni_params->ip_family_pref && QMI_AF_ANY != sni_params->ip_family_pref
          && sni_params->ip_family_pref != wds_sp->cur_ip_call_type )
      {
        // if another legacy client already attempting to start a call on this WDS state then
        // default instance cannot be switched and this attempt should fail.
        if( qmi_wdsi_net_if_bound( wds_sp ) )
        {
          LOG_MSG_INFO2_0("Another client is already starting a different type of IP call on the primary WDS state.");
          errval = QMI_ERR_INVALID_IP_FAMILY_PREF_V01;
          goto send_result;
        }
        temp = qmi_wds_state[WDSI_IPV4_STATE][inst]->is_primary_state;
        qmi_wds_state[WDSI_IPV4_STATE][inst]->is_primary_state = qmi_wds_state[WDSI_IPV6_STATE][inst]->is_primary_state;
        qmi_wds_state[WDSI_IPV6_STATE][inst]->is_primary_state = temp;
        qmi_wdsi_sync_clients(inst);
        // watch out for race condition
        if(qmi_wdsi_global.swap_instances_cb != NULL)
        {
          qmi_wdsi_global.swap_instances_cb(wds_sp->binding.ep_id, wds_sp->binding.mux_id);
        }
        wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(wds_client_sp);
        ASSERT(wds_sp);
      }
    }
  }

  /* Validate call type */
  if ( sni_params->call_type >= RMNET_CALL_TYPE_MAX )
  {
    LOG_MSG_INFO2_1 ("Invalid SNI call type %d", sni_params->call_type);
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

#ifdef FEATURE_DATA_LTE
  /* Validate handoff context */
  if (sni_params->is_handoff_context_valid)
  {
    LOG_MSG_INFO1_1("Handoff context value set, bearer_ip_type [%d]",
                    req_msg->handoff_context.bearer_ip_type);
    switch(req_msg->handoff_context.bearer_ip_type)
    {
      case WDS_IP_SUPPORT_TYPE_IPV4_V01: //V4 only
      {
        sni_params->handoff_context.bearer_ip_type = PS_IFACE_BEARER_IP_V4_ONLY;
        sni_params->handoff_context.pdn_ip_config.iface_ipv4_config.is_ip_cfg_valid = TRUE;
        sni_params->handoff_context.pdn_ip_config.iface_ipv4_config.ip_addr.type = IPV4_ADDR;
        sni_params->handoff_context.pdn_ip_config.iface_ipv4_config.ip_addr.addr.v4.ps_s_addr = 
          ps_htonl(req_msg->handoff_context.ipv4_addr);
        IPV4_ADDR_MSG(sni_params->handoff_context.pdn_ip_config.iface_ipv4_config.ip_addr.addr.v4.ps_s_addr);
        break;
      }
      case WDS_IP_SUPPORT_TYPE_IPV6_V01: // V6 only
      {
        sni_params->handoff_context.bearer_ip_type = PS_IFACE_BEARER_IP_V6_ONLY;
        sni_params->handoff_context.pdn_ip_config.iface_ipv6_config.is_ip_cfg_valid = TRUE;
        sni_params->handoff_context.pdn_ip_config.iface_ipv6_config.ip_addr.type = IPV6_ADDR;
        memscpy(&(sni_params->handoff_context.pdn_ip_config.iface_ipv6_config.ip_addr.addr.v6.in6_u.u6_addr8),
                sizeof(sni_params->handoff_context.pdn_ip_config.iface_ipv6_config.ip_addr.addr.v6.in6_u.u6_addr8),
                req_msg->handoff_context.ipv6_address,
                sizeof(req_msg->handoff_context.ipv6_address));
        IPV6_ADDR_MSG(sni_params->handoff_context.pdn_ip_config.iface_ipv6_config.ip_addr.addr.v6.in6_u.u6_addr64);
        break;
      }  
      case WDS_IP_SUPPORT_TYPE_IPV4V6_V01: //V4V6 
      {
        sni_params->handoff_context.bearer_ip_type = PS_IFACE_BEARER_IP_DUAL_BEARER;
        sni_params->handoff_context.pdn_ip_config.iface_ipv4_config.is_ip_cfg_valid = TRUE;
        sni_params->handoff_context.pdn_ip_config.iface_ipv4_config.ip_addr.type = IPV4_ADDR;
        sni_params->handoff_context.pdn_ip_config.iface_ipv4_config.ip_addr.addr.v4.ps_s_addr = 
          ps_htonl(req_msg->handoff_context.ipv4_addr);
        sni_params->handoff_context.pdn_ip_config.iface_ipv6_config.is_ip_cfg_valid = TRUE;
        sni_params->handoff_context.pdn_ip_config.iface_ipv6_config.ip_addr.type = IPV6_ADDR;
        memscpy(&(sni_params->handoff_context.pdn_ip_config.iface_ipv6_config.ip_addr.addr.v6.in6_u.u6_addr8),
                sizeof(sni_params->handoff_context.pdn_ip_config.iface_ipv6_config.ip_addr.addr.v6.in6_u.u6_addr8),
                req_msg->handoff_context.ipv6_address,
                sizeof(req_msg->handoff_context.ipv6_address));
        IPV4_ADDR_MSG(sni_params->handoff_context.pdn_ip_config.iface_ipv4_config.ip_addr.addr.v4.ps_s_addr);
        IPV6_ADDR_MSG(sni_params->handoff_context.pdn_ip_config.iface_ipv6_config.ip_addr.addr.v6.in6_u.u6_addr64);
        break;
      }   
      default:  
        LOG_MSG_ERROR_1 ("Invalid bearer_ip_type %d!",
                         req_msg->handoff_context.bearer_ip_type);
        errval = QMI_ERR_INVALID_ARG_V01;
        goto send_result;
    }
    //Cannot handoff a call on a WDS instance on which call is already up
    if (qmi_wdsi_net_if_bound( wds_sp ))
    {
      LOG_MSG_ERROR_0 ("Invalid attempt to handoff call!");
      errval = QMI_ERR_INVALID_OPERATION_V01;
      goto send_result;
    }
  }
#endif /* FEATURE_DATA_LTE */

  /*-------------------------------------------------------------------------
    If we get a SNI request, when auto_connect is enabled, send NO_EFFECT
    in response
  -------------------------------------------------------------------------*/
  if(rmnet_meta_sm_is_auto_connect_enabled(wds_sp->binding.rmnet_inst) ==
       TRUE)
  {
    LOG_MSG_INFO2_0 ("Auto connect is enabled, hence SNI has no effect!");
    errval = QMI_ERR_NO_EFFECT_V01;
    goto send_result;
  }

  if (wds_client_sp->net_bound)
  {
    LOG_MSG_INFO2_1 ("Network interface already started by clid %d!",
                     wds_client_sp->common.clid);
    errval = QMI_ERR_NO_EFFECT_V01;
    /*-----------------------------------------------------------------------
      command did not result in bringing up the call for this client.
    -----------------------------------------------------------------------*/
    goto send_result;
  }
  LOG_MSG_INFO2_1( "Client %d starts the network interface",
                   wds_client_sp->common.clid );

  if(enable_autoconnect == TRUE)
  {
    if (!qmi_svc_ext_allow_auto_connect())
    {
      errval = QMI_ERR_ACCESS_DENIED_V01;
      goto send_result;
    }

    if (FALSE == rmnet_meta_sm_enable_auto_connect(wds_sp->binding.rmnet_inst, TRUE))
    {
      LOG_MSG_ERROR_0( "Could not enable autoconnect" );
    }
  }
  /* Extended tech pref value, if present, overrides tech_pref TLV */
  if (ext_tech_pref != 0)
  {
    if((ext_tech_pref == CDMA_SN_IFACE)    || (ext_tech_pref == UMTS_IFACE) ||
       (ext_tech_pref == DVBH_IFACE)       || (ext_tech_pref == MBMS_IFACE) ||
       (ext_tech_pref == CDMA_BCAST_IFACE) || (ext_tech_pref == FLO_IFACE)  ||
       (ext_tech_pref == WWAN_GROUP)       || (ext_tech_pref == ANY_IFACE_GROUP) ||
       (ext_tech_pref == CDMA_AN_IFACE)    || (ext_tech_pref == IFACE_3GPP2_GROUP) ||
       (ext_tech_pref == IFACE_3GPP_GROUP) || (ext_tech_pref == SLIP_IFACE) ||
       (ext_tech_pref == EMBMS_IFACE)      || (ext_tech_pref == ANY_DEFAULT_GROUP) ||
       (ext_tech_pref = MODEM_LINK_LOCAL_IFACE) )
    {
    /* Simply assign the value sent in the request to the sni_params */
    sni_params->tech_pref = (ps_iface_name_enum_type) ext_tech_pref;
    }
    else
    {
      LOG_MSG_INFO2_0("Invalid value of Ext. Technology Preference in SNI");
      errval = QMI_ERR_INVALID_ARG_V01;
      goto send_result;
    }
  }
  else
  {
    /*-----------------------------------------------------------------------
      Extended tech pref TLV is not present. Use Tech Pref TLV if present.
      Clear out any undefined bits in tech_pref
    -----------------------------------------------------------------------*/
    tech_pref &= WDS_TECH_PREF_ANY;

    if( (tech_pref & WDS_TECH_PREF_ANY) == 0 )
    {
      LOG_MSG_INFO2_0("Invalid value of Technology Preference in SNI");
      errval = QMI_ERR_INVALID_TECH_PREF_V01;
      goto send_result;
    }

    if (tech_pref == WDS_TECH_PREF_UMTS)
    {
      sni_params->tech_pref = UMTS_IFACE;
    }

    if (tech_pref == WDS_TECH_PREF_CDMA)
    {
      sni_params->tech_pref = CDMA_SN_IFACE;
    }
  }

  /*-------------------------------------------------------------------------
    If call is already up or pending, verify policy 
  -------------------------------------------------------------------------*/
  if (qmi_wdsi_net_if_bound(wds_sp))
  {
    // um_iface_ptr1 is the existing or pending um iface.
    // The previous request may be still pending in the DCC queue
    um_iface_ptr1 = rmnet_meta_sm_get_um_iface_ex(
                           wds_sp->binding.rmnet_inst);

    // um_iface_ptr2 is the um iface calculated from this request
    um_iface_ptr2 = rmnet_meta_smi_get_um_iface_ptr(
                           sni_params,
                           RMNET_RT_LK_UP_TYPE_IFACE,
                           NULL,
                           &arb_info);

    if (um_iface_ptr1 == um_iface_ptr2 && wds_sp->um_iface_ptr == NULL)
    {
      // Policy matches, but call is not up, continue to queue the request
      LOG_MSG_INFO1_0("Net Iface pending and policy matches");
    }
    else
    {
      // Send response right away for below cases
      if (um_iface_ptr1 != um_iface_ptr2)
      {
        // Policy doesn't match
        LOG_MSG_INFO1_0("Net Iface already up or pending, but policy does NOT match");
        errval = QMI_ERR_POLICY_MISMATCH_V01;
      }
      else
      {
        // Policy matches and call is already up
        LOG_MSG_INFO2_0("Net Iface already up and policy matches");
        wds_client_sp->net_bound = TRUE;
        errval = QMI_ERR_NONE_V01;
      }
      goto send_result;
    }
  }

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  if ( (sni_params->tech_pref == UMTS_IFACE) ||
       (sni_params->tech_pref == WWAN_GROUP) )
  {
    /*-----------------------------------------------------------------------
      FOR UMTS - Before bringing up the call validate the pdp-type in the
      given profile. Fail the call if the PDP type is PPP as Rmnet doesn't
      support PDP_PPP
    -----------------------------------------------------------------------*/
    errval = qmi_wds_profile_umts_validate_pdp_type((uint8)sni_params->umts_profile_num,
		                                             subs_id);

    if(errval != QMI_ERR_NONE_V01)
    {
      if(sni_params->tech_pref == UMTS_IFACE)
      {
        goto send_result;
      }
      /*---------------------------------------------------------------------
        Initialize the errval to QMI_ERR_NONE so that other techs can be
        tried.
       --------------------------------------------------------------------*/
      errval = QMI_ERR_NONE_V01;
    }
  }
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)*/


  if(req_msg->authentication_preference_valid)
  {
    /* clear any unknown auth pref bits */
    sni_params->cfg_info.auth_info.auth_type &= WDSI_AUTH_PREF_VALID_MASK;
  }

  /*-------------------------------------------------------------------------
    If we've hit an error, return it now before binding the
    WWAN RMSM to start call.
  -------------------------------------------------------------------------*/
  if (errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    Check if a Stop is already in process. Return Close in progress error.
  -------------------------------------------------------------------------*/
  if (wds_sp->stop_ni_cmd_buf_p != NULL)
  {
    LOG_MSG_INFO1_0("Stop Network Command already in Queue");
    errval = QMI_ERR_CALL_FAILED_V01;
    PS_SYSTEM_HEAP_MEM_FREE(sni_params);
    PS_SYSTEM_HEAP_MEM_FREE(req_msg);
    return wdsi_gen_start_network_interface_response(
                                   errval,
                                   wds_client_sp,
                                   QMI_WDS_CALL_END_REASON_CLOSE_IN_PROGRESS,
                                   PS_NET_DOWN_REASON_CLOSE_IN_PROGRESS,
                                   0, 0);
  }

  /*-------------------------------------------------------------------------
    Check if there is a free iface available or all are already in use..
  -------------------------------------------------------------------------*/
  if(FALSE == rmnet_meta_sm_is_iface_avail())
  {
    LOG_MSG_INFO1_0 ("No free rmnet iface available");
    errval = QMI_ERR_INTERFACE_NOT_FOUND_V01;
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    Cache whether we'll have to kick the rmnet_sm before binding this client
    to the network interface.
  -------------------------------------------------------------------------*/
  start_call = !qmi_wdsi_net_if_bound( wds_sp );

  /*-------------------------------------------------------------------------
    Queue command buffer in the "pending Start network interface requests"
    queue.

    Defer response until we know whether the call attempt failed or succeeded

    Call is successful if we get a ROUTEABLE event on Rm interface
    Call is unsuccessful if we get a DOWN event on Rm interface
  -------------------------------------------------------------------------*/
  LOG_MSG_INFO2_2("Client %d bound to net interface (wds_sp) %x",
                  wds_client_sp->common.clid, wds_sp);
  wds_client_sp->net_bound = TRUE;
  q_put( &wds_sp->sni_pend_q, &(((qmi_cmd_buf_type *)cmd_buf_p)->link) );

  if (start_call)
  {
  #ifdef FEATURE_DATA_QMI_MCAST
    if( (sni_params->tech_pref == DVBH_IFACE) ||
        (sni_params->tech_pref == MBMS_IFACE) ||
        (sni_params->tech_pref == CDMA_BCAST_IFACE) ||
        (sni_params->tech_pref == FLO_IFACE) )
    {
      wds_sp->is_mcast_inst = TRUE;
    }
    else
    {
      wds_sp->is_mcast_inst = FALSE;
    }
  #endif /* FEATURE_DATA_QMI_MCAST */

    wds_sp->is_embms_inst = (sni_params->tech_pref == EMBMS_IFACE ? TRUE : FALSE);

    /*-------------------------------------------------------------------------
     * Set packet filters
    -------------------------------------------------------------------------*/
    packet_filter_id = IPS_ID_TO_FILTER_ID(
                          req_msg->ips_id_valid, sni_params->ips_id, inst);
    sni_params->packet_filter_id = packet_filter_id;

    /*-----------------------------------------------------------------------
      This is the first client to start the network interface.
      - save the sni params in rmnet_info so that they can be used in
        route_get() and bring_up() to pass relevant info to mode handler
      - post event to WWAN RMSM to start the call

      if auto conn enabled, ignore all sni params except profile num
    -----------------------------------------------------------------------*/
    if(enable_autoconnect == FALSE)
    {
      rmnet_meta_sm_set_network_cfg_params(wds_sp->binding.rmnet_inst,
                                           sni_params);
    }

    /* Set the subs id on which the call is up to the wds instance */
    wds_sp->binding.subscription_id = 
      qmi_wdsi_resolve_client_subs(wds_client_sp);
    rmnet_meta_sm_set_subs_id(wds_sp->binding.rmnet_inst,
                              wds_sp->binding.subscription_id);
    LOG_MSG_INFO1_2("Start rmnet call on instance %d subs %d", 
                     wds_sp->binding.rmnet_inst, 
                     wds_sp->binding.subscription_id);

    rmnet_meta_sm_post_event(wds_sp->binding.rmnet_inst,
                             RMNET_META_SM_RM_DEV_START_PKT_EV);
  }

  PS_SYSTEM_HEAP_MEM_FREE(sni_params);
  PS_SYSTEM_HEAP_MEM_FREE(req_msg);
  return QMI_SVC_RESPONSE_PENDING;

  send_result:
    PS_SYSTEM_HEAP_MEM_FREE(sni_params);
    PS_SYSTEM_HEAP_MEM_FREE(req_msg);
    return wdsi_gen_start_network_interface_response( errval,
                                                      wds_client_sp,
                                                      QMI_WDS_CALL_END_REASON_MIN,
                                                      0, 0, 0 );
} /* qmi_wdsi_start_network_interface() */


/*===========================================================================
  FUNCTION QMI_WDSI_ROUTE_LOOK_UP()

  DESCRIPTION
    To bind a control point to the WWAN device's data session

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type *  qmi_wdsi_route_look_up
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  struct
  {
    rmnet_meta_sm_route_look_up_e_type rt_lk_type;
  } v_in_reqd;

  PACKED struct PACKED_POST
  {
    ps_iface_id_type         um_iface_id;
    uint32                   iface_priority;
    ps_iface_name_enum_type  iface_name;
  } v_out_reqd;

  PACKED struct PACKED_POST
  {
    uint32  iface_priority_mask;
    uint8   is_iface_arb_candidate;    /* boolean */
  } v_out_arb;

  qmi_wdsi_state_type  * wds_sp;
  ps_iface_type        * um_iface_ptr;
  dsm_item_type        * response;
  rmnet_meta_sm_network_info_type  *sni_params = NULL;
  acl_policy_info_type        *acl_policy_info = NULL;
  qmi_error_type_v01          errval;
  qmi_result_type_v01           result;
  boolean                     retval;
  uint8                       type;
  uint16                      len = 0;
  uint16                      expected_len;
  void *                      value;
  boolean                     got_v_in_reqd;
  uint8                       umts_profile_id;
  uint16                      umts_default_profile_num = 0;
  uint16                      cdma_default_profile_num = 0;
  uint8                       profile_family = 0;
  rmnet_meta_sm_arb_info_type arb_info;
  qmi_ep_id_type              qmi_ep_id;
  uint32                      ep_id;
  uint8                       mux_id;
  qmi_wdsi_client_state_type *  wds_client_sp = NULL;
  uint32                      subs_id = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  wds_client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  memset( &v_out_arb, 0, sizeof(v_out_arb) );
  /*-------------------------------------------------------------------------
    Parse command
  -------------------------------------------------------------------------*/
  errval = QMI_ERR_NONE_V01;
  response = NULL;
  got_v_in_reqd = FALSE;

  /*-------------------------------------------------------------------------
    Initialize sni_params
    set the profile id to default profile, so that default profile is used
    if the config profile TLV is absent.
    tech_pref is ANY (WWAN_GROUP as of now)
  -------------------------------------------------------------------------*/
  
  PS_SYSTEM_HEAP_MEM_ALLOC(sni_params,
                sizeof(rmnet_meta_sm_network_info_type),
                rmnet_meta_sm_network_info_type*); 

   if (NULL == sni_params)
   {
      errval = QMI_ERR_NO_MEMORY_V01;
      goto send_result;
   }
  memset(sni_params, 0, sizeof(rmnet_meta_sm_network_info_type));

   PS_SYSTEM_HEAP_MEM_ALLOC(acl_policy_info,
                    sizeof(acl_policy_info_type),
                    acl_policy_info_type*);

   if (NULL == acl_policy_info)
   {
      errval = QMI_ERR_NO_MEMORY_V01;
      goto send_result;
   }
  memset(acl_policy_info, 0, sizeof(acl_policy_info_type));

  memset(&v_in_reqd, 0, sizeof(v_in_reqd));

  subs_id = qmi_wdsi_resolve_client_subs(wds_client_sp);

  profile_family = WDS_PROFILE_RMNET_FAMILY;
  (void) qmi_wds_profile_retrieve_default_profile_num(WDS_PROFILE_TYPE_3GPP,
                                                      profile_family,
                                                      &umts_default_profile_num,
                                                      subs_id);
  umts_profile_id = (uint8)umts_default_profile_num;

  profile_family = 0;
  (void) qmi_wds_profile_retrieve_default_profile_num(WDS_PROFILE_TYPE_3GPP2,
                                                      profile_family,
                                                      &cdma_default_profile_num,
                                                      subs_id);
  sni_params->cdma_profile_num = (uint8)cdma_default_profile_num;

  sni_params->tech_pref        = WWAN_GROUP;
  sni_params->ip_family_pref   = wds_sp->cur_ip_call_type;
  sni_params->call_type        = RMNET_CALL_TYPE_EMBEDDED;
  sni_params->subscription_id  = subs_id;

  LOG_MSG_INFO2_1("RL on subs %d ", sni_params->subscription_id);
  while (*sdu_in)
  {
    if( !qmi_svc_get_tl( sdu_in, &type, &len ) )
    {
      /*---------------------------------------------------------------------
        If get_tl() fails it continues and reaches the end of pkt
        (contents will be null) and terminates
      ---------------------------------------------------------------------*/
      continue;
    }

    // special value 0 = variable length or don't care (unrecognzied TLV)
    expected_len = 0;
    value = NULL;
    switch (type)
    {
      case QMI_TYPE_REQUIRED_PARAMETERS:
        expected_len = WDSI_PRM_TYPE_RMNET_META_SM_LOOK_UP_TYPE_LEN;
        value = &v_in_reqd;
        got_v_in_reqd = TRUE;
        break;

      case WDSI_PRM_TYPE_UMTS_PROFILE_INDEX:
        expected_len = WDSI_PRM_TYPE_UMTS_PROFILE_INDEX_LEN;
        value = &umts_profile_id;
        break;

      case WDSI_PRM_TYPE_CDMA_PROFILE_INDEX:
        expected_len = WDSI_PRM_TYPE_CDMA_PROFILE_INDEX_LEN;
        value = &sni_params->cdma_profile_num;
        break;

      case WDSI_PRM_TYPE_EXT_TECH_PREF:
        expected_len = WDSI_PRM_TYPE_EXT_TECH_PREF_LEN;
        value = &sni_params->tech_pref;
        break;

      case WDSI_PRM_TYPE_IP_FAMILY_PREF:
        expected_len = WDSI_PRM_TYPE_IP_FAMILY_PREF_LEN;
        value = &sni_params->ip_family_pref;
        break;

      case WDSI_PRM_TYPE_APN_STRING:
        expected_len = 0;
        if (len <= sizeof(sni_params->apn.name))
        {
          value = sni_params->apn.name;
          sni_params->apn.length = (uint8) len;
        }
        else
        {
          errval = QMI_ERR_ARG_TOO_LONG_V01;
          goto send_result;
        }
        break;

      default:
        LOG_MSG_INFO2_1 ("Unrecognized TLV type (%d)", type);
        break;
    }

    if(!qmi_svc_validate_type_length( type,
                                      len,
                                      expected_len,
                                      FILE_ID_DS_QMI_WDS,__LINE__)  )
    {
      errval = QMI_ERR_MALFORMED_MSG_V01;
      goto send_result;
    }

    /*-----------------------------------------------------------------------
      If type is unrecognized, value will be NULL, and qmi_svc_dsm_pullup will
      free the unrecognized value, i.e. we skip past unrecognized TLVs
    -----------------------------------------------------------------------*/
    if(len != PS_UTILS_DSM_PULLUP( sdu_in, value, len  ))
    {
      errval = QMI_ERR_MALFORMED_MSG_V01;
      goto send_result;
    }
  }

  if(got_v_in_reqd == FALSE)
  {
    errval = QMI_ERR_MISSING_ARG_V01;
    goto send_result;
  }

  if (v_in_reqd.rt_lk_type >= RMNET_RT_LK_UP_TYPE_MAX)
  {
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  sni_params->umts_profile_num = (uint16)umts_profile_id;

  /* validate the IP family preference */
  if ((errval = qmi_wdsi_validate_ip_family_pref(sni_params->ip_family_pref))
                                                                != QMI_ERR_NONE_V01) 
  {
    goto send_result;
  }

  arb_info.iface_priority_mask    = 0;
  arb_info.is_iface_arb_candidate = 0; /* FALSE */

  /* do route get for look up only */
  um_iface_ptr = rmnet_meta_smi_get_um_iface_ptr(
                                           sni_params,
                                           v_in_reqd.rt_lk_type,
                                           acl_policy_info,
                                           &arb_info);

  if(um_iface_ptr == NULL)
  {
    errval = QMI_ERR_INTERFACE_NOT_FOUND_V01;
    goto send_result;
  }

  v_out_reqd.um_iface_id = PS_IFACE_GET_ID(um_iface_ptr);
  v_out_reqd.iface_priority = acl_policy_info->rt_result.priority;
  v_out_reqd.iface_name = (ps_iface_name_enum_type)
                           PS_IFACE_GET_NAME_FROM_ID(v_out_reqd.um_iface_id);

  v_out_arb.iface_priority_mask    = arb_info.iface_priority_mask;
  v_out_arb.is_iface_arb_candidate = arb_info.is_iface_arb_candidate; /* FALSE */

  /* check if a QMI call is up using this UM iface and if so return the
     ep_id/mux_id on which the call is up.
     Needed for LA, since LA Conn Mgr may bring up a call on this UM iface
     then when DSS tries to bring up a call using the same policy, it will
     result in the same UM iface handle, but DSS does not know which instance
     to send SNI on.
     DSS would know that for the case when it brought up the 1st call as well */

  if (rmnet_meta_sm_um_iface_in_use(um_iface_ptr, &ep_id, &mux_id))
  {
    qmi_ep_id.ep_type  = (ep_id & 0xFF000000) >> 24;
    qmi_ep_id.iface_id = (ep_id & 0x00FFFFFF);

    if ( FALSE == qmi_svc_put_param_tlv( &response,
                                        WDSI_PRM_TYPE_RL_MUX_ID,
                                        sizeof(uint8),
                                        &mux_id) )
    {
      errval = QMI_ERR_NO_MEMORY_V01;
      dsm_free_packet(&response);
      goto send_result;
    }

    if ( FALSE == qmi_svc_put_param_tlv( &response,
                                        WDSI_PRM_TYPE_RL_EP_ID,
                                        sizeof(qmi_ep_id),
                                        &qmi_ep_id) )
    {
      errval = QMI_ERR_NO_MEMORY_V01;
      dsm_free_packet(&response);
      goto send_result;
    }
  }

  if( FALSE == qmi_svc_put_param_tlv( &response,
                                      WDSI_PRM_TYPE_ARB_INFO,
                                      sizeof (v_out_arb),
                                      (void *)&v_out_arb) )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    dsm_free_packet(&response);
  }

  if( FALSE == qmi_svc_put_param_tlv(&response,
                                     QMI_TYPE_REQUIRED_PARAMETERS,
                                     WDSI_PRM_TYPE_PS_IFACE_NAME_TYPE_LEN,
                                     (void *)&v_out_reqd))
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    dsm_free_packet(&response);
  }

send_result:

  if(sni_params != NULL)
  {
    PS_SYSTEM_HEAP_MEM_FREE(sni_params);
  }
  if(acl_policy_info != NULL)
  {
    PS_SYSTEM_HEAP_MEM_FREE(acl_policy_info);
  }

  result = (errval == QMI_ERR_NONE_V01? QMI_RESULT_SUCCESS_V01
                                   : QMI_RESULT_FAILURE_V01);

  retval = qmi_svc_put_result_tlv( &response, result, errval );
  CHECK_RETVAL();

  return response;
} /* qmi_wdsi_route_look_up() */

/*===========================================================================
  FUNCTION QMI_WDSI_STOP_NETWORK_INTERFACE()

  DESCRIPTION
    Release the WWAN packet data connection (unless other control points are
    using it)

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type *  qmi_wdsi_stop_network_interface
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *              response;
  qmi_wdsi_state_type *        wds_sp;
  qmi_wdsi_client_state_type * wds_client_sp;
  boolean                      pending_resp;

  qmi_error_type_v01 errval;
  boolean            disable_autoconnect;
  wds_stop_network_interface_req_msg_v01 req_msg;
  wds_stop_network_interface_resp_msg_v01 resp_msg;
  ps_iface_type                          * um_iface_ptr = NULL;
  sint15                                   ps_err_no = 0;
  ps_iface_ioctl_pdn_teardown_config_type  pdn_teardown_config;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&req_msg,0,sizeof(wds_stop_network_interface_req_msg_v01));
  memset(&resp_msg,0,sizeof(wds_stop_network_interface_resp_msg_v01));

  wds_client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  LOG_MSG_INFO1_1 ("Client %d end rmnet call", wds_client_sp->common.clid);

  wds_sp = (qmi_wdsi_state_type *) sp;
  response = NULL;
  errval   = QMI_ERR_NONE_V01;
  disable_autoconnect = FALSE;

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_STOP_NETWORK_INTERFACE_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(wds_stop_network_interface_req_msg_v01));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  if(req_msg.pkt_data_handle == 0)
  {
    errval = QMI_ERR_INVALID_HANDLE_V01;
    goto send_result;
  }
  /* Validate that request is not sent on reverse IP transport instance */
  if( wds_sp->binding.is_reversed ||
      wds_sp->binding.rmnet_inst >= RMNET_INSTANCE_MAX )
  {
    errval = QMI_ERR_INVALID_OPERATION_V01;
    LOG_MSG_ERROR_1("SNI request sent on non-binding instance %d "
            , wdsi_get_instance_from_wds_sp(sp));
      goto send_result;
  }
  if(req_msg.disable_autoconnect_valid)
  {
    disable_autoconnect =  req_msg.disable_autoconnect;
  }
    
  if(req_msg.local_abort_valid && wds_client_sp->net_bound)
  {
    um_iface_ptr = wds_sp->um_iface_ptr;
    if(!PS_IFACE_IS_VALID(wds_sp->um_iface_ptr))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }

    memset(&pdn_teardown_config, 0, 
           sizeof(ps_iface_ioctl_pdn_teardown_config_type));
    pdn_teardown_config.local_abort = req_msg.local_abort;
  
    if (ps_iface_ioctl(um_iface_ptr, PS_IFACE_IOCTL_SET_PDN_TEARDOWN_CONFIG,
                       &pdn_teardown_config, &ps_err_no) != 0)
    {
      LOG_MSG_ERROR_1("Couldn't set pdn teardown config, err: %d",
                      ps_err_no);
      switch (ps_err_no)
      {
        case DS_EFAULT:
          errval = QMI_ERR_INVALID_ARG_V01;
          break;

        case DS_EOPNOTSUPP:
          errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
          break;

        case DS_EINVAL:
          errval = QMI_ERR_INVALID_OPERATION_V01;
          break;

        default:
          errval = QMI_ERR_INTERNAL_V01;
          break;
      }
    }    
  }  

  pending_resp = FALSE;
  if (errval == QMI_ERR_NONE_V01)
  {
    if((void*)req_msg.pkt_data_handle == wds_client_sp)
    {
      /*---------------------------------------------------------------------
        Stop the network interface for this client
      ---------------------------------------------------------------------*/
      errval = qmi_wdsi_stop_net_iface_client(wds_client_sp,
                                              WDSI_FORCE_REASON_DEFAULT, &pending_resp);
    }
    else if( (disable_autoconnect) &&
             ((void*)req_msg.pkt_data_handle == WDS_GLOBAL_PKT_DATA_HANDLE))
    {
      if (rmnet_meta_sm_is_auto_connect_enabled(wds_sp->binding.rmnet_inst) ||
          wds_client_sp->net_bound == TRUE)
      {
        if(FALSE == rmnet_meta_sm_enable_auto_connect(wds_sp->binding.rmnet_inst,
                                        FALSE))
        {
          LOG_MSG_ERROR_0( "Could not disable autoconnect" );
        }

        /*---------------------------------------------------------------------
          Stop the network interface for this client
        ---------------------------------------------------------------------*/
        if(wds_sp->stop_ni_cmd_buf_p == NULL)
        {
        errval = qmi_wdsi_stop_net_iface_client(wds_client_sp,
                                                  WDSI_FORCE_REASON_AUTOCONNECT, &pending_resp);
        }
        else
        {
          LOG_MSG_INFO1_0("Previous response pending: Cannot call qmi_wdsi_stop_net_iface_client");
          errval = QMI_ERR_NO_EFFECT_V01;
        }
      }
      else
      {
        LOG_MSG_INFO1_0("no effect: autoconnect already disabled & client not bound");
        errval = QMI_ERR_NO_EFFECT_V01;
      }
    }
    else
    {
      errval = QMI_ERR_INVALID_HANDLE_V01;
      LOG_MSG_INFO2_1 ("Invalid packet data handle in stop request (%d)",
                       req_msg.pkt_data_handle);
      goto send_result;
    }

    if(pending_resp == TRUE)
    {
       ASSERT( (errval == QMI_ERR_NONE_V01) && (wds_sp->stop_ni_cmd_buf_p == NULL));
      /*---------------------------------------------------------------------
        A successful command to stop the UM iface is posted to RMNET.
        Queue the command buffer in the pending stop network interface
        queue. The deferred response would be sent when iface down event
        is received.
      ---------------------------------------------------------------------*/
      wds_sp->stop_ni_cmd_buf_p = (qmi_cmd_buf_type *)cmd_buf_p;
      return QMI_SVC_RESPONSE_PENDING;
    }
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_STOP_NETWORK_INTERFACE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_stop_network_interface() */



/*===========================================================================
  FUNCTION QMI_WDSI_GET_PKT_SRVC_STATUS()

  DESCRIPTION
    Give the current packet data connection status

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_pkt_srvc_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *  wds_sp;
  qmi_wdsi_client_state_type * client_sp;
  dsm_item_type *        response;
  qmi_error_type_v01 errval;
  wds_get_pkt_srvc_status_resp_msg_v01 resp_msg;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  /*-------------------------------------------------------------------------
    Build the response from back to front
  -------------------------------------------------------------------------*/
  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  resp_msg.connection_status = (wds_connection_status_enum_v01)wds_sp->pkt_svc_state;

 /*if ( (call is connceted || call is coming up) && client subs doesnt match the existing call) --> send ERROR)
     wds_sp->binding.subscription_id is set at start of the call and reset when call ended/fails*/
  if ( ((wds_sp->pkt_svc_state == QMI_WDS_CONN_CONNECTED) ||
        (wds_sp->binding.subscription_id != QMI_WDSI_SUBS_DEFAULT)) &&
       (FALSE == qmi_wdsi_verify_client_subs(client_sp,
                                             wds_sp->binding.subscription_id,
                                             TRUE)) )
  {
    LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

/* This is a workaround to return error in below case 
   If call is not connected but call bringup is in progress, send error*/
  if( (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED) &&
      (wds_sp->binding.subscription_id != QMI_WDSI_SUBS_DEFAULT) )
  {
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_PKT_SRVC_STATUS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_pkt_srvc_status() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_DUN_CALL_INFO()

  DESCRIPTION
    Return the current modem connection status

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_dun_call_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  qmi_error_type_v01 errval;

  qmi_wdsi_client_state_type *  wds_client_sp;
  wds_get_dun_call_info_req_msg_v01 req_msg;
  wds_get_dun_call_info_resp_msg_v01 resp_msg;

  time_type          curr_time, call_duration;
  ps_iface_type *    ps_iface_ptr;
  ps_phys_link_type *phys_link_ptr;
  qmi_wds_bearer_tech_e_type data_bearer_tech;
  phys_link_state_type phys_link_state;
  qmi_wds_dormancy_status_e_type dormancy_status;
  time_type          active_time;
  time_type          invalid_time;
  qmi_wdsi_data_byte_count_type      data_count;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;

  wds_client_sp = (qmi_wdsi_client_state_type *) cl_sp;
  dormancy_status = QMI_WDS_TRAFFIC_CH_MAX;

  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GET_DUN_CALL_INFO_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(wds_get_dun_call_info_req_msg_v01));

  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  if(req_msg.mask == 0)
  {
    errval = QMI_ERR_MISSING_ARG_V01;
    goto send_result;
  }

  if ( qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED &&
       (FALSE == qmi_wdsi_verify_client_subs(wds_client_sp,
                                             qmi_wdsi_global.dun_subs_id,
                                             TRUE)) )
  {
    LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",wds_client_sp->subscription_id,
                     qmi_wdsi_global.dun_subs_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }
   /*-------------------------------------------------------------------------
    Determine dormancy status (used in both dormancy status & active
    duration requests)
  -------------------------------------------------------------------------*/
  if (qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED &&
      (req_msg.mask & QMI_WDS_MASK_DUN_DORMANCY_STATUS_V01 ||
       req_msg.mask & QMI_WDS_MASK_DUN_CAL_ACTIVE_DURATION_V01))
  {
    ps_iface_ptr = qmi_wdsi_global.modem_dun_um_iface_ptr;
    if(PS_IFACE_IS_VALID(ps_iface_ptr) == FALSE)
    {
      LOG_MSG_ERROR_1("Recd invalid iface ptr: 0x%x", (uint32)ps_iface_ptr);
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
    else
    {
      phys_link_ptr = PS_IFACE_GET_PHYS_LINK(ps_iface_ptr);
      if(PS_PHYS_LINK_IS_VALID(phys_link_ptr) == FALSE)
      {
        LOG_MSG_ERROR_1("Recd invalid phys link ptr: 0x%x",
                        (uint32)phys_link_ptr);
        errval = QMI_ERR_INTERNAL_V01;
        goto send_result;
      }
      else
      {
        phys_link_state = PS_PHYS_LINK_GET_STATE( phys_link_ptr );
      }
    }

    switch (phys_link_state)
    {
      case PHYS_LINK_UP:
      dormancy_status = QMI_WDS_TRAFFIC_CH_ACTIVE;
      break;

      case PHYS_LINK_DOWN:
      dormancy_status = QMI_WDS_TRAFFIC_CH_DORMANT;
      break;

      case PHYS_LINK_COMING_UP:
      case PHYS_LINK_GOING_DOWN:
      case PHYS_LINK_RESUMING:
      case PHYS_LINK_GOING_NULL:
      case PHYS_LINK_NULL:
      default:
        if ((PHYS_LINK_COMING_UP == phys_link_state) ||
            (PHYS_LINK_GOING_DOWN == phys_link_state) ||
            (PHYS_LINK_RESUMING == phys_link_state) ||
            (PHYS_LINK_GOING_NULL == phys_link_state) ||
            (PHYS_LINK_NULL == phys_link_state))
        {
          /* This isn't an error condition if we only want the active
           * duration */
          if (req_msg.mask & QMI_WDS_MASK_DUN_DORMANCY_STATUS_V01)
          {
            errval = QMI_ERR_INFO_UNAVAILABLE_V01;
            goto send_result;
          }
        }
        LOG_MSG_INFO2_1("PhysLink status=%d. Neither active nor dormant",
                        phys_link_state );
        dormancy_status = QMI_WDS_TRAFFIC_CH_UNKNOWN;
        break;
    }
  }

  if (req_msg.mask & QMI_WDS_MASK_DUN_CAL_ACTIVE_DURATION_V01)
  {
    if (qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED)
    {
      if (QMI_WDS_TRAFFIC_CH_ACTIVE == dormancy_status)
      {
        /* We are currently active, so include the current active session in the duration */
        time_get_uptime_ms(curr_time);
        qw_sub(active_time, curr_time,
               qmi_wdsi_global.modem_dun_last_active_start_time);
        qw_add(active_time, active_time,
               qmi_wdsi_global.modem_dun_total_active_time);
      }
      else
      {
        /* Currently dormant (or neither active nor dormant) so just use the
           total_active_time value */
        qw_equ(active_time, qmi_wdsi_global.modem_dun_total_active_time);
      }
      resp_msg.modem_call_duration_active_valid = TRUE;
      resp_msg.modem_call_duration_active = (uint64)active_time;
      memscpy(&resp_msg.modem_call_duration_active,sizeof(resp_msg.modem_call_duration_active),
                &active_time,sizeof(active_time));
    }
    else
    {
      qw_set(invalid_time,
             QMI_WDSI_CALL_DURATION_INVALID_DW,
             QMI_WDSI_CALL_DURATION_INVALID_DW);
      if (QMI_WDSI_QW_CMP_EQUAL != qw_cmp(qmi_wdsi_global.modem_dun_last_call_active_duration,
                                          invalid_time))
      {
        resp_msg.modem_call_duration_active_valid = TRUE;
        memscpy(&resp_msg.modem_call_duration_active,sizeof(resp_msg.modem_call_duration_active),
          &qmi_wdsi_global.modem_dun_last_call_active_duration,sizeof(qmi_wdsi_global.modem_dun_last_call_active_duration));
      }
      else
      {
        /* Send 0 if the last call was made with RMNET */
        qw_set(invalid_time, 0, 0);
        resp_msg.modem_call_duration_active_valid = TRUE;
        memscpy(&resp_msg.modem_call_duration_active,sizeof(resp_msg.modem_call_duration_active),
                &invalid_time,sizeof(invalid_time));
      }
    }
  }

  /*-------------------------------------------------------------------------
    Byte statistics - only returned when last call was DUN or currently
    in a DUN call
  -------------------------------------------------------------------------*/
  qw_set(invalid_time,
         QMI_WDSI_CALL_DURATION_INVALID_DW,
         QMI_WDSI_CALL_DURATION_INVALID_DW);
  if(req_msg.mask & QMI_WDS_MASK_DUN_TX_RX_BYTES_OK_V01 &&
     QMI_WDSI_QW_CMP_EQUAL != qw_cmp(qmi_wdsi_global.modem_dun_call_connect_time,
                                     invalid_time))
  {
    /* If call is up, gets current session info, otherwise gets last info */
    if (!qmi_wdsi_get_dun_data_count(&data_count))
    {
      LOG_MSG_ERROR_0("Couldn't get byte stats for DUN call info query");
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
    if (qmi_wdsi_global.modem_dun_um_iface_ptr != NULL &&
        qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED)
    {
      resp_msg.rx_ok_bytes_count_valid = TRUE;
      resp_msg.rx_ok_bytes_count = data_count.rxed_bytes;
      resp_msg.tx_ok_bytes_count_valid = TRUE;
      resp_msg.tx_ok_bytes_count = data_count.rxed_bytes;
    }
    else
    {
      resp_msg.last_call_rx_ok_bytes_count_valid = TRUE;
      resp_msg.last_call_rx_ok_bytes_count = data_count.rxed_bytes;
      resp_msg.last_call_tx_ok_bytes_count_valid = TRUE;
      resp_msg.last_call_tx_ok_bytes_count = data_count.rxed_bytes;
    }
  }

  if(req_msg.mask & QMI_WDS_MASK_DUN_CHANNEL_RATE_V01)
  {
    /*-------------------------------------------------------------------------
      Get the instantaneous (current) channel rate
    -------------------------------------------------------------------------*/
    qmi_if_get_current_channel_rate(QMI_WDSI_DUN_UM_IFACE(qmi_wdsi_global),
                                    &resp_msg.channel_rate.current_channel_tx_rate,
                                    &resp_msg.channel_rate.current_channel_rx_rate );

    /*-------------------------------------------------------------------------
      Get the maximum channel rate for the serving system
    -------------------------------------------------------------------------*/
    qmi_if_get_max_channel_rate(QMI_WDSI_DUN_UM_IFACE(qmi_wdsi_global),
                                &resp_msg.channel_rate.max_channel_tx_rate,
                                &resp_msg.channel_rate.max_channel_rx_rate);

    resp_msg.channel_rate_valid = TRUE;
    /* Check these values against cache */
    if (qmi_wdsi_global.dun_rx_rate != resp_msg.channel_rate.max_channel_rx_rate ||
        qmi_wdsi_global.dun_tx_rate != resp_msg.channel_rate.max_channel_tx_rate)
    {
      LOG_MSG_ERROR_2("ioctl response in get modem status (rx %d tx %d) doesn't match cache, sending IND",
                resp_msg.channel_rate.max_channel_rx_rate, resp_msg.channel_rate.max_channel_tx_rate);
      qmi_wdsi_generate_dun_channel_rate_ind(QMI_IF_CH_RATE_TRIGGER_DATA_BEARER_CHANGE,
                                             wds_client_sp->subscription_id);
    }
  }

  if(req_msg.mask & QMI_WDS_MASK_DUN_DATA_BEARER_V01)
  {
    if( qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED )
    {
      data_bearer_tech = qmi_wdsi_global.modem_dun_last_data_bearer;

      if(data_bearer_tech == QMI_WDS_BEARER_TECH_UNKNOWN)
      {
        LOG_MSG_ERROR_1 ("Invalid bearer tech(=%d)!", data_bearer_tech);
        errval = QMI_ERR_INTERNAL_V01;
        goto send_result;
      }
      else if (data_bearer_tech == QMI_WDS_BEARER_TECH_NULL)
      {
        LOG_MSG_INFO1_0("NULL bearer from lower layer, not adding data bearer TLV");
      }
      else
      {
        resp_msg.data_bearer_tech_valid = TRUE;
        resp_msg.data_bearer_tech = (wds_data_bearer_tech_enum_v01)data_bearer_tech;
      }
    }
    /* Last call data bearer technology - returned only when not in a call and
     * when the last call was made with DUN */
    else if(qmi_wdsi_global.dun_state == QMI_WDS_CONN_DISCONNECTED)
    {
      if (qmi_wdsi_global.modem_dun_last_data_bearer !=
                                                  QMI_WDS_BEARER_TECH_UNKNOWN &&
          qmi_wdsi_global.modem_dun_last_data_bearer !=
                                                  QMI_WDS_BEARER_TECH_NULL)
      {
        resp_msg.last_call_data_bearer_tech_valid = TRUE;
        resp_msg.last_call_data_bearer_tech = (wds_data_bearer_tech_enum_v01)
                       qmi_wdsi_global.modem_dun_last_data_bearer;
      }
      else
      {
        LOG_MSG_INFO2_0 ("Last DUN data bearer unknown");
      }
    }
    else
    {
      LOG_MSG_INFO2_0 ("DUN call state invalid");
    }
  }

  if (req_msg.mask & QMI_WDS_MASK_DUN_DORMANCY_STATUS_V01)
  {
    if( qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED &&
        dormancy_status != QMI_WDS_TRAFFIC_CH_UNKNOWN )
    {
      resp_msg.dormancy_status_valid = TRUE;
      resp_msg.dormancy_status = (wds_dormancy_status_enum_v01)dormancy_status;
    }
    else
    {
      LOG_MSG_INFO1_0("Call not up. Cannot report dormancy status");
    }
  }

  if(req_msg.mask & QMI_WDS_MASK_DUN_LAST_CALL_END_REASON_V01)
  {
    resp_msg.call_end_reason_valid = TRUE;
    resp_msg.call_end_reason = (wds_call_end_reason_enum_v01)
                     qmi_wdsi_global.modem_dun_last_call_end_reason;;
  }

  if(req_msg.mask & QMI_WDS_MASK_DUN_CONNECTION_STATUS_V01)
  {
    /*-------------------------------------------------------------------------
      If call up, return current elapsed time; else return last call duration
    -------------------------------------------------------------------------*/
    if( qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED )
    {
      time_get_uptime_ms( curr_time );
      qw_sub( call_duration,
              curr_time,
              qmi_wdsi_global.modem_dun_call_connect_time );
    }
    else
    {
      qw_sub( call_duration,
              qmi_wdsi_global.modem_dun_call_end_time,
              qmi_wdsi_global.modem_dun_call_connect_time );
    }
    memscpy(&resp_msg.connection_status.modem_call_duration,sizeof(resp_msg.connection_status.modem_call_duration),
            &call_duration,sizeof(call_duration));
    resp_msg.connection_status.modem_connection_status = (wds_connection_status_enum_v01)
                            qmi_wdsi_global.dun_state;
    resp_msg.connection_status_valid = TRUE;
  }

  if (req_msg.report_connection_status_valid)
  {
    if(req_msg.report_connection_status)
    {
      wds_client_sp->report_status.report_dun_conn_status = TRUE;
    }
    else
    {
      wds_client_sp->report_status.report_dun_conn_status = FALSE;
    }
  }

  if (req_msg.report_stats_valid)
  {
    /*---------------------------------------------------------------------
      Do a memcpy for stat_mask as the structure is PACKED
    ---------------------------------------------------------------------*/
    qmi_wdsi_dun_set_pkt_stats_reports(wds_client_sp,
                                       req_msg.report_stats.stats_peroid,
                                       req_msg.report_stats.stats_mask);
  }

  if (req_msg.report_data_bearer_tech_valid)
  {
    if(req_msg.report_data_bearer_tech)
    {
      wds_client_sp->modem_rpt_status.data_bearer = TRUE;
    }
    else
    {
      wds_client_sp->modem_rpt_status.data_bearer = FALSE;
    }
  }

  if (req_msg.report_dormancy_status_valid)
  {
    if(req_msg.report_dormancy_status)
    {
      wds_client_sp->modem_rpt_status.dorm_status = TRUE;
    }
    else
    {
      wds_client_sp->modem_rpt_status.dorm_status = FALSE;
    }
  }

  if (req_msg.report_channel_rate_valid)
  {
    if(req_msg.report_channel_rate)
    {
      wds_client_sp->modem_rpt_status.ch_rate = TRUE;
    }
    else
    {
      wds_client_sp->modem_rpt_status.ch_rate = FALSE;
    }
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_DUN_CALL_INFO_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_dun_call_info() */


/*===========================================================================
  FUNCTION QMI_WDSI_GET_CURRENT_CHANNEL_RATE()

  DESCRIPTION
    Give the current bitrate of the WWAN link

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type *  qmi_wdsi_get_current_channel_rate
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *  wds_sp;
  dsm_item_type *     response;
  wds_get_current_channel_rate_resp_msg_v01 resp_msg;
  qmi_error_type_v01   errval;
  qmi_wdsi_client_state_type * client_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  /*-------------------------------------------------------------------------
    Build the response from back to front
  -------------------------------------------------------------------------*/
  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  if (NULL != wds_sp->um_iface_ptr) 
  {
    // If call is up on a different subs reject the request.
    if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                     TRUE))
    {
      LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                      " Client subs %d Call subs %d",client_sp->subscription_id,
                       wds_sp->binding.subscription_id );
      errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
      goto send_result;
    }
  }

   /*-------------------------------------------------------------------------
    Get the instantaneous (current) channel rate
  -------------------------------------------------------------------------*/
  qmi_if_get_current_channel_rate(wds_sp->um_iface_ptr,
                                  &resp_msg.rates.current_channel_tx_rate,
                                  &resp_msg.rates.current_channel_tx_rate);

  /*-------------------------------------------------------------------------
    Get the maximum channel rate for the serving system
  -------------------------------------------------------------------------*/
  qmi_if_get_max_channel_rate(wds_sp->um_iface_ptr,
                              &resp_msg.rates.max_channel_tx_rate,
                              &resp_msg.rates.max_channel_rx_rate);

  if ((wds_sp->current_rx_rate != resp_msg.rates.max_channel_rx_rate ||
       wds_sp->current_tx_rate != resp_msg.rates.max_channel_tx_rate))
  {
    LOG_MSG_ERROR_2("ioctl response (rx %d tx %d) in get cur channel rate doesn't match cache, sending IND",
                    resp_msg.rates.max_channel_rx_rate, resp_msg.rates.max_channel_tx_rate);
    qmi_wds_generate_channel_rate_ind(QMI_IF_CH_RATE_TRIGGER_DATA_BEARER_CHANGE,
                                      QMI_AF_INET == wds_sp->cur_ip_call_type,
                                      wds_sp->binding.subscription_id);
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_CURRENT_CHANNEL_RATE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_current_channel_rate() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_DORMANCY_STATUS()

  DESCRIPTION
    Give the current traffic channel status

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_dormancy_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *  wds_sp;
  qmi_wdsi_client_state_type * wds_client_sp;
  dsm_item_type *        response;
  qmi_error_type_v01 errval;
  wds_get_dormancy_status_resp_msg_v01 resp_msg;
  ps_iface_type *    ps_iface_ptr = NULL;
  ps_phys_link_type * phys_link_ptr = NULL;
  phys_link_state_type phys_link_state;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    Build the response from back to front
  -------------------------------------------------------------------------*/
  response = NULL;
  errval = QMI_ERR_NONE_V01;

  wds_sp = (qmi_wdsi_state_type *) sp;
  wds_client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  memset(&resp_msg,0,sizeof(resp_msg));
  if ( wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED )
  {
    LOG_MSG_INFO2_0( "Call not up. Cannot report dormancy status" );
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(wds_client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",wds_client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }  

  ps_iface_ptr = rmnet_meta_sm_get_um_iface(wds_sp->binding.rmnet_inst);
  if(PS_IFACE_IS_VALID(ps_iface_ptr) == FALSE)
  {
    LOG_MSG_ERROR_1("Recd invalid iface ptr: 0x%x", (uint32)ps_iface_ptr);
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  phys_link_ptr = PS_IFACE_GET_PHYS_LINK(ps_iface_ptr);
  if(PS_PHYS_LINK_IS_VALID(phys_link_ptr) == FALSE)
  {
    LOG_MSG_ERROR_1("Recd invalid phys link ptr: 0x%x", (uint32)phys_link_ptr);
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }
  /* Iface and phys link are Valid */
  phys_link_state = PS_PHYS_LINK_GET_STATE( phys_link_ptr );

  switch (phys_link_state)
  {
    case PHYS_LINK_UP:
      resp_msg.dormancy_status = (wds_dormancy_status_enum_v01)QMI_WDS_TRAFFIC_CH_ACTIVE;
      break;

    case PHYS_LINK_DOWN:
      resp_msg.dormancy_status = (wds_dormancy_status_enum_v01)QMI_WDS_TRAFFIC_CH_DORMANT;
      break;

    case PHYS_LINK_COMING_UP:
    case PHYS_LINK_GOING_DOWN:
    case PHYS_LINK_RESUMING:
    case PHYS_LINK_GOING_NULL:
    case PHYS_LINK_NULL:
      LOG_MSG_INFO2_1("PhysLink status=%d. Neither active nor dormant",
                      phys_link_state );
      errval = QMI_ERR_INFO_UNAVAILABLE_V01;
      goto send_result;

    default:
      LOG_MSG_INFO2_1("PhysLink status=%d. Neither active nor dormant",
                      phys_link_state );
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    /* Cache this value into last reported dormancy status */
    wds_client_sp->report_status.last_dorm_rpt = resp_msg.dormancy_status;
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_DORMANCY_STATUS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_dormancy_status */


/*===========================================================================
  FUNCTION QMI_WDSI_GET_PKT_STATISTICS()

  DESCRIPTION
    Get the packet statistics

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_pkt_statistics
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *  wds_sp;
  dsm_item_type *        response;
  ps_iface_type *        ps_iface_ptr;
  ps_iface_type *        stat_iface_ptr;
  uint32                    num_discard_pkts = WDSI_STAT_VALUE_UNAVAILABLE;
  uint32                    num_out_of_mem_pkts = WDSI_STAT_VALUE_UNAVAILABLE;
  qmi_error_type_v01        errval;
  qmi_wdsi_stats_type       wds_stats = {0};
  uint64                 last_call_tx_bytes;
  uint64                 last_call_rx_bytes;
  qmi_wdsi_client_state_type         * client_sp;
  wds_get_pkt_statistics_req_msg_v01 req_msg;
  wds_get_pkt_statistics_resp_msg_v01 resp_msg;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  response          = NULL;
  errval            = QMI_ERR_NONE_V01;
  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GET_PKT_STATISTICS_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));

  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  /* Validate that request is not sent on reverse IP transport instance */
  if( wds_sp->binding.is_reversed ||
      wds_sp->binding.rmnet_inst >= RMNET_INSTANCE_MAX )
  {
    errval = QMI_ERR_INVALID_OPERATION_V01;
    LOG_MSG_ERROR_1("Request sent on non-binding instance %d "
            , wdsi_get_instance_from_wds_sp(sp));
    goto send_result;
  }

  if(req_msg.stats_mask == 0)
  {
    errval = QMI_ERR_MISSING_ARG_V01;
    goto send_result;
  }

  LOG_MSG_INFO2_1 ("Got statistics require for mask %x",
                   req_msg.stats_mask);

  if (!rmnet_meta_sm_in_call(wds_sp->binding.rmnet_inst))
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    rmnet_meta_sm_get_prev_byte_stats(wds_sp->binding.rmnet_inst,
                                      &last_call_rx_bytes,
                                      &last_call_tx_bytes);

    if(req_msg.stats_mask & WDSI_STAT_MASK_TX_OK_BYTES)
    {
      resp_msg.last_call_tx_ok_bytes_count_valid = TRUE;
      resp_msg.last_call_tx_ok_bytes_count = last_call_rx_bytes;
    }
    if(req_msg.stats_mask & WDSI_STAT_MASK_RX_OK_BYTES)
    {
      resp_msg.last_call_rx_ok_bytes_count_valid = TRUE;
      resp_msg.last_call_rx_ok_bytes_count = last_call_tx_bytes;
    }
    goto send_result;
  }

  ps_iface_ptr = rmnet_meta_sm_iface(wds_sp->binding.rmnet_inst);
  if(PS_IFACE_IS_VALID(ps_iface_ptr) == FALSE)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
    LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  /* we query the um iface, hence tx/rx perspective is swapped*/
  stat_iface_ptr = qmi_wdsi_get_um_stat_iface(ps_iface_ptr);
  if((E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_PKTS_RX, stat_iface_ptr, &wds_stats.tx_pkts, 4))
     || (E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_PKTS_TX, stat_iface_ptr, &wds_stats.rx_pkts, 4))
     || (E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_BYTES_RX, stat_iface_ptr, &wds_stats.tx_bytes, 8))
     || (E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_BYTES_TX, stat_iface_ptr, &wds_stats.rx_bytes, 8))
     || (E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_PKTS_DROPPED_RX, stat_iface_ptr, &wds_stats.tx_pkts_dropped, 4))
     || (E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_PKTS_DROPPED_TX, stat_iface_ptr, &wds_stats.rx_pkts_dropped, 4))
     )
  {
    errval = QMI_ERR_INTERNAL_V01;
    LOG_MSG_ERROR_1("Unable to get stats for ps_iface_ptr 0x%x!",
                    ps_iface_ptr);
    goto send_result;
  }
  /*-------------------------------------------------------------------------
    Build the response from back to front
    Note the QMI message is communicated from the host's perspective, i.e.
    tx packet count is the number of packets rx'ed by the Rm interface.
    rx packet count is the number of packets tx'ed by the Rm interface.
  -------------------------------------------------------------------------*/
  if(req_msg.stats_mask  & WDSI_STAT_MASK_TX_GOOD_NW)
  {
    resp_msg.tx_ok_count_valid = TRUE;
    resp_msg.tx_ok_count = wds_stats.rx_pkts;
  }

  if(req_msg.stats_mask  & WDSI_STAT_MASK_RX_GOOD_NW)
  {
    resp_msg.rx_ok_count_valid = TRUE;
    resp_msg.rx_ok_count = wds_stats.tx_pkts;
  }

  if(req_msg.stats_mask  & WDSI_STAT_MASK_TX_DISCARD_NW)
  {
    resp_msg.tx_err_count_valid = TRUE;
    resp_msg.tx_err_count = num_discard_pkts;
  }

  if(req_msg.stats_mask  & WDSI_STAT_MASK_RX_DISCARD_NW)
  {
    resp_msg.rx_err_count_valid = TRUE;
    resp_msg.rx_err_count = num_discard_pkts;
  }

  if(req_msg.stats_mask  & WDSI_STAT_MASK_TX_OUT_OF_MEM_NW)
  {
    resp_msg.tx_ofl_count_valid = TRUE;
    resp_msg.tx_ofl_count = num_out_of_mem_pkts;
  }

  if(req_msg.stats_mask  & WDSI_STAT_MASK_RX_OUT_OF_MEM_NW)
  {
    resp_msg.rx_ofl_count_valid = TRUE;
    resp_msg.rx_ofl_count = num_out_of_mem_pkts;
  }

  if(req_msg.stats_mask  & WDSI_STAT_MASK_TX_OK_BYTES)
    {
    resp_msg.tx_ok_bytes_count_valid = TRUE;
    resp_msg.tx_ok_bytes_count = wds_stats.rx_bytes;
  }

  if(req_msg.stats_mask  & WDSI_STAT_MASK_RX_OK_BYTES)
    {
    resp_msg.rx_ok_bytes_count_valid = TRUE;
    resp_msg.rx_ok_bytes_count = wds_stats.tx_bytes;
  }

  if(req_msg.stats_mask  & WDSI_STAT_MASK_TX_DROPPED)
  {
    resp_msg.tx_dropped_count_valid = TRUE;
    resp_msg.tx_dropped_count = wds_stats.rx_pkts_dropped;
  }

  if(req_msg.stats_mask  & WDSI_STAT_MASK_RX_DROPPED)
  {
    resp_msg.rx_dropped_count_valid = TRUE;
    resp_msg.rx_dropped_count = wds_stats.tx_pkts_dropped;
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_PKT_STATISTICS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_pkt_statistics() */


/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_DEALY_DORMANCY_STATUS_IND()

DESCRIPTION
    Called when received IFACE_FAST_DORMANCY_STATUS_EV
    Used to indicate delay dormancy status.
    Causes wds_event_report_ind to be sent

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void qmi_wdsi_generate_delay_dormancy_status_ind
(
  void *                               sp,
  wds_delay_dormancy_result_type_v01 * delay_dorm_result
)
{
  qmi_wdsi_client_state_type *  cl_sp;
  qmi_wdsi_state_type *         wds_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT (sp && delay_dorm_result);
  wds_sp = (qmi_wdsi_state_type *) sp;

  LOG_MSG_INFO2_2( "Recvd delay dormancy event status (=%d) & fail_reason (=%d)", 
  	            delay_dorm_result->status, 
                    delay_dorm_result->dormancy_failure_reason);

  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
    if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
    {
      if ((wds_sp->pkt_svc_state == QMI_WDS_CONN_CONNECTED) &&
          (cl_sp->report_status.report_delay_dormancy_result) &&
          qmi_wdsi_verify_client_subs(cl_sp, wds_sp->binding.subscription_id, TRUE))
      {
        qmi_wdsi_event_report_ind(wds_sp,
                                  cl_sp->common.clid,
                                  WDSI_REPORT_STATUS_DELAY_DORMANCY,
                                  0,
                                  0,
                                  NULL,
                                  QMI_WDS_BEARER_TECH_UNKNOWN,
                                  0,
                                  QMI_WDS_TRAFFIC_CH_UNKNOWN,
                                  NULL,
                                  0,
                                  WDSI_CALL_UKNOWN,
                                  WDSI_DATA_CALL_NONE,                                  
                                  0,
                                  NULL,
                                  NULL,
                                  NULL,
                                  delay_dorm_result);
      }
    } /* if (wds_sp == ...) */
    cl_sp = cl_sp->next;
  } /* while */
} /* qmi_wdsi_generate_delay_dormancy_status_ind */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_DORMANCY_STATUS_IND()

DESCRIPTION
    Called when phys link events (up/down) occur.
    Used to indicate dormancy status.
    Causes wds_event_report_ind to be sent

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void qmi_wdsi_generate_dormancy_status_ind
(
  void *                         sp,
  qmi_wds_dormancy_status_e_type dormancy_status
)
{
  qmi_wdsi_client_state_type *  cl_sp;
  qmi_wdsi_state_type *         wds_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT (sp);
  wds_sp = (qmi_wdsi_state_type *) sp;

  LOG_MSG_INFO2_1( "Recvd dormancy status(=%d)", dormancy_status );

  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
    if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
    {
      /* reset the abortable flag if client is of same instance*/
      if(cl_sp->dormancy_abortable == TRUE)
      {
        cl_sp->dormancy_abortable = FALSE;
        LOG_MSG_INFO1_1("Domancy flag reset for client %0x",cl_sp);
      }
      if ((cl_sp->report_status.report_dormancy_status) &&
          (wds_sp->pkt_svc_state == QMI_WDS_CONN_CONNECTED) &&
          qmi_wdsi_verify_client_subs(cl_sp, wds_sp->binding.subscription_id, TRUE))
      {
        qmi_wdsi_event_report_ind(wds_sp,
                                  cl_sp->common.clid,
                                  WDSI_REPORT_STATUS_EV_DORM_STATUS,
                                  0,
                                  0,
                                  NULL,
                                  QMI_WDS_BEARER_TECH_UNKNOWN,
                                  0,
                                  dormancy_status,
                                  NULL,
                                  0,
                                  WDSI_CALL_UKNOWN,
                                  WDSI_DATA_CALL_NONE,                                  
                                  0,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);
        /* Cache this value into last reported dormancy status */
        cl_sp->report_status.last_dorm_rpt = dormancy_status;
      }
    } /* if (wds_sp == ...) */
    cl_sp = cl_sp->next;
  } /* while */
} /* qmi_wdsi_generate_dormancy_status_ind */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_DUN_DORMANCY_STATUS_IND()

DESCRIPTION
    Called when phys link events (up/down) occur.
    Used to indicate dormancy status.
    Causes dun_call_infoind to be sent

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void qmi_wdsi_generate_dun_dormancy_status_ind
(
  qmi_wds_dormancy_status_e_type dormancy_status
)
{
  qmi_wdsi_client_state_type *  cl_sp;
  qmi_wdsi_state_type *         wds_sp;
  uint8                         state;
  uint8                         inst;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  LOG_MSG_INFO2_1( "Sending DUN dormancy status IND (=%d)", dormancy_status );

  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }

      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if (cl_sp->modem_rpt_status.dorm_status &&
            qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED &&
            cl_sp->modem_rpt_status.last_dorm_rpt != dormancy_status &&
            qmi_wdsi_verify_client_subs(cl_sp, qmi_wdsi_global.dun_subs_id, TRUE))
        {
          qmi_wds_dun_call_info_ind(wds_sp,
                                    cl_sp->common.clid,
                                    (uint32)
                                        WDSI_REPORT_MODEM_STATUS_EV_DORM_STATUS,
                                    dormancy_status,
                                    QMI_WDS_BEARER_TECH_UNKNOWN,
                                    0,
                                    0,
                                    (qmi_wds_conn_status_e_type) 0);
          cl_sp->modem_rpt_status.last_dorm_rpt = dormancy_status;
        }
        cl_sp = cl_sp->next;
      } /* for each client */
    } /* for each instance */
  } /* for each state */
} /* qmi_wdsi_generate_dun_dormancy_status_ind */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_CURR_DATA_BEARER_TECH_IND()

DESCRIPTION
    Called when data bearer tech change iface event occurs.
    Used to indicate data bearer technology.
    Causes wds_event_report_ind to be sent

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_curr_data_bearer_tech_ind
(
  qmi_wdsi_state_type *                 wds_sp,
#ifdef FEATURE_DATA_WLAN_MAPCON
  ds_sys_system_status_info_type        data_bearer_tech_ex
#else
  qmi_wdsi_curr_data_bearer_tech_type * data_bearer_tech
#endif /* FEATURE_DATA_WLAN_MAPCON */
)
{
  qmi_wdsi_client_state_type *  cl_sp;
#ifdef FEATURE_DATA_WLAN_MAPCON
  qmi_wdsi_curr_data_bearer_tech_type data_bearer_tech;
  wds_event_report_ind_msg_v01  *indication = NULL;
#endif /* FEATURE_DATA_WLAN_MAPCON */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT (wds_sp);
#ifndef FEATURE_DATA_WLAN_MAPCON
  ASSERT (data_bearer_tech);
#endif /* ifndef FEATURE_DATA_WLAN_MAPCON*/

  if (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED)
  {
    LOG_MSG_INFO2_0("Skipping curr data bearer ind, RMNET call down");
    return;
  }

#ifdef FEATURE_DATA_WLAN_MAPCON
  PS_SYSTEM_HEAP_MEM_ALLOC(indication,
                           sizeof(wds_event_report_ind_msg_v01),
                           wds_event_report_ind_msg_v01*);
  if(indication == NULL)
  {
    return;
  }
  memset(indication,0,sizeof(wds_event_report_ind_msg_v01));
  LOG_MSG_INFO2_3( "Recvd data bearer technology technology=%d,rat_value=%d,so_mask=0x%llx",
                   data_bearer_tech_ex.technology,
                   data_bearer_tech_ex.rat_value,
                   data_bearer_tech_ex.so_mask);
  indication->bearer_tech_ex_valid = TRUE;
  indication->bearer_tech_ex.technology = (wds_bearer_tech_network_enum_v01)
                                          data_bearer_tech_ex.technology;
  indication->bearer_tech_ex.rat_value = (wds_bearer_tech_rat_ex_enum_v01)
                                          data_bearer_tech_ex.rat_value;
  indication->bearer_tech_ex.so_mask = data_bearer_tech_ex.so_mask;
  wdsi_get_current_data_bearer_tech(data_bearer_tech_ex, &data_bearer_tech); //What if it is S2B?
#else
  LOG_MSG_INFO2_3( "Recvd data bearer technology curr_nw=%d,rat_mask=%d,so_mask=%d",
                   data_bearer_tech->current_nw,
                   data_bearer_tech->rat_mask,
                   data_bearer_tech->so_mask);
#endif /* FEATURE_DATA_WLAN_MAPCON */

  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
    if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
    {
#ifdef FEATURE_DATA_WLAN_MAPCON
      if ((cl_sp->report_status.report_curr_data_bearer) && 
          (data_bearer_tech_ex.so_mask != DS_SYS_SO_EX_3GPP_S2B) &&
           qmi_wdsi_verify_client_subs(cl_sp, wds_sp->binding.subscription_id, TRUE))
#else
      if (cl_sp->report_status.report_curr_data_bearer &&
          qmi_wdsi_verify_client_subs(cl_sp, wds_sp->binding.subscription_id, TRUE))
#endif /* FEATURE_DATA_WLAN_MAPCON */
      {

        qmi_wdsi_event_report_ind(wds_sp,
                                  cl_sp->common.clid,
                                  WDSI_REPORT_STATUS_EV_CURR_DATA_BEARER,
                                  0,
                                  0,
                                  NULL,
                                  QMI_WDS_BEARER_TECH_UNKNOWN,
                                  0,
                                  QMI_WDS_TRAFFIC_CH_UNKNOWN,
#ifdef FEATURE_DATA_WLAN_MAPCON
                                  &data_bearer_tech,
#else
                                  data_bearer_tech,
#endif /* FEATURE_DATA_WLAN_MAPCON */
                                  0,
                                  WDSI_CALL_UKNOWN,
                                  WDSI_DATA_CALL_NONE,                                  
                                  0,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);
      }
#ifdef FEATURE_DATA_WLAN_MAPCON
      if (cl_sp->report_status.report_data_bearer_ex &&
          qmi_wdsi_verify_client_subs(cl_sp, wds_sp->binding.subscription_id, TRUE)) 
      {
        qmi_wdsi_send_ind(wds_sp, cl_sp, QMI_WDS_EVENT_REPORT_IND_V01,
                    sizeof(wds_event_report_ind_msg_v01), indication,TRUE);
      }
#endif /* FEATURE_DATA_WLAN_MAPCON */
    }
    cl_sp = cl_sp->next;
  } /* while */
#ifdef FEATURE_DATA_WLAN_MAPCON
  PS_SYSTEM_HEAP_MEM_FREE(indication);
#endif /* FEATURE_DATA_WLAN_MAPCON */
} /* qmi_wdsi_generate_curr_data_bearer_tech_ind */


#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_EVDO_PMP_CHANGE_IND()

DESCRIPTION
    Called when EVDO session change occurs

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_evdo_pmp_change_ind
(
  qmi_wdsi_evdo_page_monitor_period epmp,
  uint32                            subs_id
)
{
  qmi_wdsi_client_state_type *  cl_sp;
  qmi_wdsi_state_type *         wds_sp;
  uint8                         state;
  uint8                         inst;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  LOG_MSG_INFO1_0("Recvd EVDO page monitor period change ind");

  if (epmp.evdo_page_monitor_period == WDSI_EVDO_SLOT_CYCLE_INVALID)
  {
    LOG_MSG_INFO1_2("Got %d SCI, changing to %d",
                    WDSI_EVDO_SLOT_CYCLE_INVALID,
                    WDSI_EVDO_SLOT_CYCLE_5120_MSECS);
    epmp.evdo_page_monitor_period = WDSI_EVDO_SLOT_CYCLE_5120_MSECS;
  }

  /* Send indications to clients registered for the event */
  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }

      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if ((wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp)) &&
            (cl_sp->report_status.report_evdo_page_monitor_period_change) &&
             qmi_wdsi_verify_client_subs(cl_sp, subs_id, FALSE)) 
        {
          qmi_wdsi_event_report_ind(wds_sp,
                                cl_sp->common.clid,
                                WDSI_REPORT_STATUS_EVDO_PAGE_MONITOR_PERIOD_CHANGE,
                                0,
                                0,
                                NULL,
                                QMI_WDS_BEARER_TECH_UNKNOWN,
                                0,
                                QMI_WDS_TRAFFIC_CH_UNKNOWN,
                                NULL,
                                0,
                                WDSI_CALL_UKNOWN,
                                WDSI_DATA_CALL_NONE,
                                0,
                                (qmi_wdsi_evdo_page_monitor_period*)&epmp,
                                NULL,
                                NULL,
                                NULL);
        }
        /* Generate internal event as well if required */
        if ((wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp)) &&
            (cl_sp->internal_iface_ev_reg_mask & 
            (0x00000001 << (WDSI_INT_IF_EV_HDR_SM_SESS_CHANGE-1))) &&
            (wds_sp->pkt_svc_state == QMI_WDS_CONN_CONNECTED))
        {
          ps_iface_event_info_u_type event_info;
          memset(&event_info, 0, sizeof(ps_iface_event_info_u_type));
          event_info.slotted_mode_info.sm_current_sci = 
            (uint8)epmp.evdo_page_monitor_period;
          qmi_wdsi_internal_iface_ev_ind( wds_sp,
                                          cl_sp,
                                          WDSI_INT_IF_EV_HDR_SM_SESS_CHANGE,
                                          event_info);
        }
        cl_sp = cl_sp->next;
      } /* for each client */
    } /* for each instance */
  } /* for each state */
} /* qmi_wdsi_generate_evdo_pmp_change_ind */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_EVDO_PMP_RESULT_IND()

DESCRIPTION
    Called when set EVDO Page Monitor Period processing is completed by MH.
    Causes wds_evdo_page_monitor_period_result_ind to be sent

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_evdo_pmp_result_ind
(
  int16 evt, 
  ps_hdr_slotted_mode_failure_code_enum_type failure_code
)
{
  qmi_wdsi_client_state_type     *  cl_sp = NULL;
  evdo_pmp_pend_q_type           *  evdo_pmp_q_node = NULL;
  qmi_wdsi_state_type            * wds_sp = NULL;
  qmi_wdsi_evdo_pmp_result_e_type status;
  wds_evdo_page_monitor_period_result_ind_msg_v01 indication;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  LOG_MSG_INFO2_1( "Recvd set EVDO page monitor period result event (%d)",
                   evt );
  memset(&indication,0,sizeof(wds_evdo_page_monitor_period_result_ind_msg_v01));
  evdo_pmp_q_node = q_get(&qmi_wdsi_global.evdo_pmp_pend_q);
  if ( NULL != evdo_pmp_q_node )
  {
    cl_sp = evdo_pmp_q_node->cl_sp;
    PS_SYSTEM_HEAP_MEM_FREE(evdo_pmp_q_node);
    if ( NULL ==  cl_sp )
    {
      LOG_MSG_ERROR_0( "No client state found in EVDO pmp queue");
      return;
    }

  }
  else
  {
    LOG_MSG_ERROR_0( "EVDO pmp pend queue is empty");
    return;
  }

  if(0 == evt)
  {
    status = QMI_WDSI_EVDO_PMP_SUCCESS;
  }
  else if (-1 == evt)
  {
    switch(failure_code)
    {
      case PS_HDR_SLOTTED_MODE_REQUEST_REJECTED:
        status = QMI_WDSI_EVDO_PMP_REQUEST_REJECTED;
        break;

      case PS_HDR_SLOTTED_MODE_REQUEST_FAILED_TX:
        status = QMI_WDSI_EVDO_PMP_REQUEST_FAILED_TX;
        break;

      case PS_HDR_SLOTTED_MODE_NOT_SUPPORTED:
        status = QMI_WDSI_EVDO_PMP_NOT_SUPPORTED;
        break;

      case PS_HDR_SLOTTED_MODE_NO_NET:
        status = QMI_WDSI_EVDO_PMP_NO_NET;
        break;

      default:
        LOG_MSG_ERROR_1( "Invalid slotted mode failure reason code received, fail_reason:%d,",
                         failure_code );
        return;
    }

  }
  else
  {
    LOG_MSG_ERROR_1( "Invalid MH callback parameter received, evt:%d", evt );
    return;
  }
  indication.status = (wds_evdo_page_monitor_period_result_enum_v01)status;
  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);
  (void)qmi_wdsi_send_ind( wds_sp,
                          cl_sp,
                          QMI_WDS_EVDO_PAGE_MONITOR_PERIOD_RESULT_IND_V01,
                          sizeof(wds_evdo_page_monitor_period_result_ind_msg_v01),
                          &indication ,TRUE);

} /* qmi_wdsi_generate_evdo_pmp_result_ind */


/*===========================================================================
  FUNCTION QMI_WDS_CALL_THR_HDLR()

  DESCRIPTION
    Call throttle handler function registered with mode handler.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_wds_call_thr_hdlr
(
  void    *call_throttle_info,
  int16    ps_errno
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_CALL_THROTTLE_CB);
  if( cmd_ptr == NULL)
  {
    return;
  }

  cmd_ptr->data.call_throttle_info.throttled_delay.cdma_remaining_thr_time = 0;
  cmd_ptr->data.call_throttle_info.throttled_delay.hdr_remaining_thr_time = 0;

  cmd_ptr->cmd_id = QMI_CMD_PROCESS_CALL_THROTTLE_CB;
  cmd_ptr->data.call_throttle_info.ps_errno = ps_errno;
  if( NULL != call_throttle_info )
  {
    memscpy(&cmd_ptr->data.call_throttle_info.throttled_delay, 
            sizeof(ds707_call_throttle_info),
            call_throttle_info, 
            sizeof(ds707_call_throttle_info));
  }
  else
  {
    LOG_MSG_ERROR_0("Invalid throttle info received; Setting ps_errno to internal");
    cmd_ptr->data.call_throttle_info.ps_errno = DS_EINTR;
  }

  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);

}/* qmi_wds_call_thr_hdlr */

/*===========================================================================
  FUNCTION QMI_WDSI_CALL_THROTTLE_INFO_REQUEST_COMPLETE()

  DESCRIPTION
    Completes the pending call throttle info request

  PARAMETERS
    call_throttle_info    : Call throttle information
    ps_errno              : PS error from mode handler

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_call_throttle_info_request_complete
(
  ds707_call_throttle_info             call_throttle_info,
  int16                                ps_errno
)
{
  dsm_item_type                  *    response  = NULL;
  qmi_cmd_buf_type               *    cmd_buf_p = NULL;
  qmi_wdsi_client_state_type     *    cl_sp     = NULL;
  qmi_error_type_v01                  errval;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  cmd_buf_p = q_get(&qmi_wdsi_global.call_thr_pend_q);
  if (NULL == cmd_buf_p)
  {
    LOG_MSG_ERROR_0("Call Throttle pend queue is empty");
    return;
  }

  cl_sp = (qmi_wdsi_client_state_type *)cmd_buf_p->x_p->cl_sp;
  if ( NULL ==  cl_sp )
  {
    LOG_MSG_ERROR_0( "No client state found in call throttle queue");
    return;
  }

  errval = qmi_wdsi_map_mh_failure_reason(ps_errno);

  response = qmi_wdsi_gen_call_throttle_info_response(call_throttle_info, errval);
  if(response)
  {
    if (FALSE == qmi_wdsi_send_response(cmd_buf_p, response))
    {
      LOG_MSG_ERROR_1 ("Unable to send call throttle response for cmd %d",
                       cmd_buf_p->cmd_type);
      dsm_free_packet( &response );
      return;
    }

  }
  else
  {
    LOG_MSG_ERROR_0 ("Couldn't generate call throttle info response!");
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
  }

}/* qmi_wdsi_call_throttle_info_request_complete */

/*===========================================================================
  FUNCTION QMI_WDSI_GEN_CALL_THROTTLE_INFO_RESPONSE()

  DESCRIPTION
    Generates a call throttle info response

  PARAMETERS
    call_throttle_info    : Call throttle information to be returned
    errval                : QMI error

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_gen_call_throttle_info_response
(
  ds707_call_throttle_info             call_throttle_info,
  qmi_error_type_v01                   errval
)
{
  dsm_item_type                  *    response  = NULL;
  wds_get_call_throttle_info_resp_msg_v01 resp_msg;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&resp_msg,0,sizeof(resp_msg));
  if( errval == QMI_ERR_NONE_V01)
  {
    resp_msg.call_throttled.cdma_call_throttled_delay = call_throttle_info.cdma_remaining_thr_time;
    resp_msg.call_throttled.hdr_call_throttled_delay = call_throttle_info.hdr_remaining_thr_time;
  } /* if( errval == QMI_ERR_NONE_V01 ) */

  /*-------------------------------------------------------------------------
    Generate result TLV
  -------------------------------------------------------------------------*/
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_CALL_THROTTLE_INFO_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
}/* qmi_wdsi_gen_call_throttle_info_response */
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_INTERNAL_IFACE_EV_IND()

DESCRIPTION
    Called when internal iface events occur.
    Used to indicate information associated with the events
    Causes wds_internal_iface_ev_ind to be sent

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void qmi_wdsi_generate_internal_iface_ev_ind
(
  qmi_wdsi_state_type *      wds_sp,
  qmi_wdsi_int_if_ev_e_type  event,
  ps_iface_event_info_u_type event_info
)
{
  qmi_wdsi_client_state_type *  cl_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT (wds_sp && (event > WDSI_INT_IF_EV_NONE) && (event < WDSI_INT_IF_EV_MAX));

  LOG_MSG_INFO2_1( "Recvd internal iface event (%d)", event );

  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
    if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
    {
      if (cl_sp->internal_iface_ev_reg_mask & (0x00000001 << (event-1)) &&
          qmi_wdsi_verify_client_subs(cl_sp, 
                                      wds_sp->binding.subscription_id, TRUE))
      {
        qmi_wdsi_internal_iface_ev_ind( wds_sp,
                                        cl_sp,
                                        event,
                                        event_info);
      }
    }
    cl_sp = cl_sp->next;
  }
} /* qmi_wdsi_generate_internal_iface_ev_ind */


/*===========================================================================
  FUNCTION WDSI_UPDATE_TRAFFIC_CHANNEL_STATE 

  DESCRIPTION
    Handle request to go either dormant or active

  PARAMETERS
    sp        : service provided state pointer
    cl_sp     : client state pointer
    timer_val_ptr : pointer to timer value for go dormancy
    ioctl_name : Either Dormant or Active state

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * wdsi_update_traffic_channel_state 
(
  void *            sp,
  void *            cl_sp,
  void *            delay_timer_ptr,
  ps_phys_link_ioctl_type ioctl_name
)
{
  qmi_wdsi_state_type *  wds_sp;
  ps_phys_link_type * phys_link_ptr = NULL;
  int16             ps_errno;
  boolean            retval;
  uint32*            timer_ptr;
  dsm_item_type *    response;
  qmi_error_type_v01 errval;
  qmi_result_type_v01  result;
  qmi_wdsi_client_state_type * client_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response          = NULL;
  errval            = QMI_ERR_NONE_V01;
  wds_sp   = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  timer_ptr = (uint32*)delay_timer_ptr;

  if ( wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED )
  {
    LOG_MSG_INFO2_0( "Call not up. Cannot change traffic channel state" );
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    LOG_MSG_INFO1_2 ("Client %d forces TC for PHYS LINK IOCTL %d",
                     ((qmi_wdsi_client_state_type*)cl_sp)->common.clid,
                     ioctl_name);
    ASSERT(wds_sp->um_iface_ptr);

    phys_link_ptr = PS_IFACE_GET_PHYS_LINK(wds_sp->um_iface_ptr);
    if(PS_PHYS_LINK_IS_VALID(phys_link_ptr) == FALSE)
    {
      LOG_MSG_ERROR_0( "PHYSLINK invalid!" );
      errval = QMI_ERR_INTERNAL_V01;
    }
    else
    {
      /*-------------------------------------------------------------------
          Issue an ioctl to the MIP interface to go dormant
      -------------------------------------------------------------------*/
      if(ps_phys_link_ioctl(phys_link_ptr,
                            ioctl_name,
                            delay_timer_ptr,
                            &ps_errno) < 0)
      {
        LOG_MSG_ERROR_2("Force active/dorm for PHYS LINK IOCTL %d failed with, err=%d",
                        ioctl_name, ps_errno);
        switch (ps_errno)
        {
          case DS_EOPNOTSUPP:
            errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
            break;

          case DS_NOMEMORY:
            errval = QMI_ERR_NO_MEMORY_V01;
            break;

          case DS_EINVAL:
            errval = QMI_ERR_INVALID_OPERATION_V01;
            break;  
			
          default:
            errval = QMI_ERR_INTERNAL_V01;
            break;
        } /*  switch (ps_errno) */
      }
      else
      {
        if(ioctl_name == PS_PHYS_LINK_IOCTL_GO_DORMANT)
        {
          if(timer_ptr != NULL && (*timer_ptr) != 0)
          {
            ((qmi_wdsi_client_state_type*)cl_sp)->dormancy_abortable = TRUE;
             LOG_MSG_INFO1_2("Dormancy flag set for client (%0x) delay timer value (%d) ",
                              (qmi_wdsi_client_state_type*)cl_sp,*timer_ptr);
          }
        }
        else if(ioctl_name == PS_PHYS_LINK_IOCTL_ABORT_GO_DORMANT)
        {
          ((qmi_wdsi_client_state_type*)cl_sp)->dormancy_abortable = FALSE;
        }
      }
    }
  }

send_result:

  result = (errval == QMI_ERR_NONE_V01? QMI_RESULT_SUCCESS_V01
                                   : QMI_RESULT_FAILURE_V01);

  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;
} /* wdsi_update_traffic_channel_state */

/*===========================================================================
  FUNCTION QMI_WDSI_GO_DORMANT()

  DESCRIPTION
    Handles request to go dormant immediatly if timer value is not specified.
    when timer value is specified invokes fast dormancy after prescribed timer value.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_go_dormant
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response =  NULL;
  qmi_error_type_v01 errval = QMI_ERR_NONE_V01;
  wds_go_dormant_req_msg_v01 req_msg;
  wds_go_dormant_resp_msg_v01 resp_msg;

  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GO_DORMANT_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval == QMI_ERR_NONE_V01)
  {
    if(req_msg.delay_timer_valid)
    {
      LOG_MSG_INFO1_1("recieved delay timer value : (%d)",req_msg.delay_timer);
    }
    return wdsi_update_traffic_channel_state(sp, cl_sp, 
                 &(req_msg.delay_timer), PS_PHYS_LINK_IOCTL_GO_DORMANT);
  }
  else
  {
    QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GO_DORMANT_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
    return response;
  }
} /* qmi_wdsi_go_dormant() */

/*===========================================================================
  FUNCTION QMI_WDSI_GO_ACTIVE()

  DESCRIPTION
    Handle request to go active

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_go_active
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  return wdsi_update_traffic_channel_state(sp, cl_sp, NULL, PS_PHYS_LINK_IOCTL_GO_ACTIVE);
} /* qmi_wdsi_go_active() */

/*===========================================================================
  FUNCTION QMI_WDSI_ABORT_GO_DORMANT()

  DESCRIPTION
    Handles request to abort the dormancy if the same client already issued
    go dormant request with timer values and the timer is still running 

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_abort_go_dormant
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *  response =  NULL;
  wds_abort_go_dormant_resp_msg_v01 resp_msg;
  memset(&resp_msg,0,sizeof(resp_msg));
  if(((qmi_wdsi_client_state_type*)cl_sp)->dormancy_abortable == TRUE)
  {
    return wdsi_update_traffic_channel_state(sp, cl_sp, NULL, PS_PHYS_LINK_IOCTL_ABORT_GO_DORMANT);
  }
  else
  {
    LOG_MSG_ERROR_0("Dormancy is no more abortable either because its already into dormancy or no call");
    QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_ABORT_GO_DORMANT_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               QMI_ERR_INVALID_OPERATION_V01,
                               &response);
    return response;
  }
} /* qmi_wdsi_abort_go_dormant() */

/*===========================================================================
  FUNCTION QMI_WDSI_SET_EVENT_REPORT()

  DESCRIPTION
    Set the conditions for event reporting

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_event_report
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_set_event_report_req_msg_v01 req_msg;
  wds_set_event_report_resp_msg_v01 resp_msg;
  qmi_wdsi_state_type *         wds_sp;
  qmi_wdsi_client_state_type *  wds_client_sp;
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
  qmi_error_type_v01 errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  wds_sp = (qmi_wdsi_state_type *)sp;
  wds_client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_EVENT_REPORT_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                        sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
    {
      goto send_result;
    }

  /*-------------------------------------------------------------------------
    If ALL optional TLVs are absent return error or else carry on and
    process the request. (Needed since NO mandatory TLVs)
  -------------------------------------------------------------------------*/
  if(!(req_msg.report_channel_rate_valid || 
       req_msg.report_stats_valid || 
       req_msg.report_data_bearer_tech_valid ||
       req_msg.report_dormancy_status_valid || 
       req_msg.report_current_data_bearer_tech_valid ||
       req_msg.report_mip_status_valid || 
       req_msg.report_data_call_status_change_valid||
       req_msg.report_preferred_data_system_valid || 
       req_msg.report_data_system_status_valid||
       req_msg.report_evdo_page_monitor_period_change_valid ||
       req_msg.report_uplink_flow_control_valid || 
       req_msg.limited_data_system_status_valid||
       req_msg.report_additional_pdn_filters_removal_valid || 
       req_msg.report_data_bearer_tech_ex_valid ||
       req_msg.report_delay_dormancy_result ))
  {
    errval = QMI_ERR_MISSING_ARG_V01;
  }
  else
  {
    if (req_msg.report_channel_rate_valid)
    {
      if(req_msg.report_channel_rate)
      {
        wds_client_sp->report_status.report_ch_rate = TRUE;
      }
      else
      {
        wds_client_sp->report_status.report_ch_rate = FALSE;
      }
    }

    /* Ignore pkt statistics request on reverse IP transport instance */
    if (req_msg.report_stats_valid && !wds_sp->binding.is_reversed)
    {
      /*---------------------------------------------------------------------
        Do a memcpy for stat_mask as the structure is PACKED
      ---------------------------------------------------------------------*/
      qmi_wdsi_set_pkt_stats_reports(wds_client_sp,
                                     req_msg.report_stats.stats_period,
                                     req_msg.report_stats.stats_mask);
    }

    if (req_msg.report_data_bearer_tech_valid)
    {
      if( req_msg.report_data_bearer_tech)
      {
        wds_client_sp->report_status.report_data_bearer = TRUE;
      }
      else
      {
        wds_client_sp->report_status.report_data_bearer = FALSE;
      }
    }

    if (req_msg.report_dormancy_status_valid)
    {
      if( req_msg.report_dormancy_status )
      {
        wds_client_sp->report_status.report_dormancy_status = TRUE;
      }
      else
      {
        wds_client_sp->report_status.report_dormancy_status = FALSE;
      }
    }

    if (req_msg.report_current_data_bearer_tech_valid)
    {
      if( req_msg.report_current_data_bearer_tech )
      {
        wds_client_sp->report_status.report_curr_data_bearer = TRUE;
      }
      else
      {
        wds_client_sp->report_status.report_curr_data_bearer = FALSE;
      }
    }

    if (req_msg.report_mip_status_valid)
    {
      if( req_msg.report_mip_status )
      {
        wds_client_sp->report_status.report_mip_status = TRUE;
      }
      else
      {
        wds_client_sp->report_status.report_mip_status = FALSE;
      }
    }

    if (req_msg.report_data_call_status_change_valid)
    {
      if( req_msg.report_data_call_status_change )
      {
        wds_client_sp->report_status.report_data_call_status_change = TRUE;
      }
      else
      {
        wds_client_sp->report_status.report_data_call_status_change = FALSE;
      }
    }

    if (req_msg.report_preferred_data_system_valid)
    {
      if( req_msg.report_preferred_data_system )
      {
        wds_client_sp->report_status.report_preferred_data_system = TRUE;
      }
      else
      {
        wds_client_sp->report_status.report_preferred_data_system = FALSE;
      }
    }

    if (req_msg.report_data_system_status_valid)
    {
      if( req_msg.report_data_system_status )
      {
        wds_client_sp->report_status.report_data_system_status = TRUE;
      }
      else
      {
        wds_client_sp->report_status.report_data_system_status = FALSE;
      }
    }

    if (req_msg.report_evdo_page_monitor_period_change_valid)
    {
      wds_client_sp->report_status.report_evdo_page_monitor_period_change =
        req_msg.report_evdo_page_monitor_period_change;
    }

    if (req_msg.report_uplink_flow_control_valid)
    {
      wds_client_sp->report_status.report_uplink_flow_ctrl =
               req_msg.report_uplink_flow_control? TRUE : FALSE;
    }

    if (req_msg.limited_data_system_status_valid)
    {
      if( req_msg.limited_data_system_status )
      {
        wds_client_sp->report_status.report_limited_data_system_status = TRUE;
        cmd_ptr = (qmi_wdsi_cmd_buf_type *)
                   qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_DATA_SYSTEM_STATUS_CHANGE_EVT);

        if( cmd_ptr == NULL)
        {
          errval = QMI_ERR_NO_MEMORY_V01;
          goto send_result;
        }

        memscpy(&cmd_ptr->data.data_system_status,
                sizeof(qmi_wdsi_curr_data_system_status_type),
               &qmi_wdsi_global.last_data_system_status,
               sizeof(qmi_wdsi_curr_data_system_status_type));
        
        /* Send indication to control point when it registers only for limited data
           system status.(and not both data system status and limited data system 
           status)
        */
        cmd_ptr->cmd_id = QMI_CMD_WDS_DATA_SYSTEM_STATUS_CHANGE_EVT;
        dcc_send_cmd_ex (DCC_QMI_CMD, cmd_ptr);
      }
      else
      {
        wds_client_sp->report_status.report_limited_data_system_status = FALSE;
      }
    }

    if (req_msg.report_additional_pdn_filters_removal_valid)
    {
      if (req_msg.report_additional_pdn_filters_removal)
      {
        wds_client_sp->report_status.report_additional_pdn_fltrs_removal = TRUE;
      }
      else
      {
        wds_client_sp->report_status.report_additional_pdn_fltrs_removal = FALSE;
      }
    }

    if (req_msg.report_data_bearer_tech_ex_valid )
    {
      if( req_msg.report_data_bearer_tech_ex )
      {
        wds_client_sp->report_status.report_data_bearer_ex = TRUE;
      }
      else
      {
        wds_client_sp->report_status.report_data_bearer_ex = FALSE;
      }
    }

    if (req_msg.report_delay_dormancy_result_valid)
    {
      if( req_msg.report_delay_dormancy_result )
      {
        wds_client_sp->report_status.report_delay_dormancy_result = TRUE;
      }
      else
      {
        wds_client_sp->report_status.report_delay_dormancy_result = FALSE;
      }
    }
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_EVENT_REPORT_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_event_report() */

/*===========================================================================
  FUNCTION QMI_WDSI_EVENT_REPORT_IND()

  DESCRIPTION
    Is called when any of the conditions set in event_report_req becomes
    true.  Sends an indication to the client.

  PARAMETERS
    sp               : service provided state pointer (user data)
    clid             : clientID
    event_mask       : mask to indicate what caused the indication to be called
    tx_rate          : tx channel rate
    rx_rate          : rx channel rate
    stats            : pkt statistics
    dormancy_status: dormancy status
    curr_data_bearer_tech : data bearer technology (new format)
    data_call_status: call status
    preferred_network : preferred network
    evdo_page_monitor_period : EVDO page monitor period change
    data_system_status       : Current Data System Status

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_event_report_ind
(
  void *                                sp,
  uint8                                 clid,
  uint32                                event_mask,
  uint32                                tx_rate,
  uint32                                rx_rate,
  qmi_wdsi_stats_type *                 stats,
  qmi_wds_bearer_tech_e_type            data_bearer_tech,
  uint8                                 mip_status,
  qmi_wds_dormancy_status_e_type        dormancy_status,
  qmi_wdsi_curr_data_bearer_tech_type * curr_data_bearer_tech,
  uint32            preferred_system,
  qmi_wdsi_call_status                  call_status,
  qmi_wdsi_data_call_e_type             data_call_type,
  uint8                                 addr_family,
  qmi_wdsi_evdo_page_monitor_period   * evdo_page_monitor_period,
  qmi_wdsi_curr_data_system_status_type * data_system_status,
  qmi_wdsi_additional_pdn_filters_removed_type * fltrs_removed,
  wds_delay_dormancy_result_type_v01           * delay_dorm_result
)
{
  qmi_wdsi_client_state_type *  cl_sp;
  qmi_wdsi_state_type *         wds_sp;
  wds_event_report_ind_msg_v01* indication = NULL;
  uint8 length = 0;
  uint32  num_discard_pkts;
  uint32  num_out_of_mem_pkts;
  qmi_wdsi_data_call_type      v_out_data_call_type;
  uint32                       v_out_addr_family = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT(sp);
  wds_sp = (qmi_wdsi_state_type *) sp;
  cl_sp = qmi_wdsi_get_cl_sp_by_clid(wds_sp, clid);
  if (cl_sp == NULL)
  {
    ASSERT(0);
    return;
  }

  /*-------------------------------------------------------------------------
    Build indication from the back to the front
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC(indication,
  	 sizeof(wds_event_report_ind_msg_v01),wds_event_report_ind_msg_v01*);
  if(indication == NULL)
  {
    return;
  }
  memset(indication,0,sizeof(wds_event_report_ind_msg_v01));
  /*-------------------------------------------------------------------------
    Event causing indication is EVDO page monitor period change event
  -------------------------------------------------------------------------*/
  if (event_mask & WDSI_REPORT_STATUS_EVDO_PAGE_MONITOR_PERIOD_CHANGE)
  {
    if( NULL == evdo_page_monitor_period)
    {
      LOG_MSG_ERROR_0("evdo_page_monitor_period = NULL Skipping sending TLV in event_report_ind ");
    }
    else
    {
      LOG_MSG_INFO2_2 ("Indicate EVDO page monitor period changed: slot cycle=%d, force long sleep=%d",
                       evdo_page_monitor_period->evdo_page_monitor_period,
                       evdo_page_monitor_period->evdo_force_long_sleep);
      indication->evdo_page_monitor_period_change_valid = TRUE;
      indication->evdo_page_monitor_period_change.evdo_page_monitor_period_change =
                            evdo_page_monitor_period->evdo_page_monitor_period;
      indication->evdo_page_monitor_period_change.evdo_force_long_sleep =
                            evdo_page_monitor_period->evdo_force_long_sleep;
    }
  }

  /*-------------------------------------------------------------------------
    Event causing indication is Change in Channel Rate
  -------------------------------------------------------------------------*/
  if (event_mask & WDSI_REPORT_STATUS_EV_CH_RATE)
  {
    LOG_MSG_INFO3_2 ("Indicate channel rate changed FWD: %d, REV: %d",
                     rx_rate, tx_rate);
    indication->channel_rate.current_channel_rx_rate = rx_rate;
    indication->channel_rate.current_channel_tx_rate = rx_rate;
    indication->channel_rate_valid = TRUE;
  }

  if (event_mask & WDSI_REPORT_STATUS_EV_PKT_STATS)
  {
    ASSERT (stats);
    LOG_MSG_INFO2_1 ("ind_mask: 0x%x",cl_sp->report_status.ind_mask);

    LOG_MSG_INFO2_6 ("Indicate outgoing ok pkts: %d, incoming ok pkts:%d"
                     "RX ok bytes: %d,TX ok bytes: %d,"
                     "RX pkts dropped: %d, TX pkts dropped: %d",                       
                      stats->rx_pkts,
                      stats->tx_pkts,
                      stats->rx_bytes,
                      stats->tx_bytes,
                      stats->rx_pkts_dropped,
                      stats->tx_pkts_dropped);

    /*-----------------------------------------------------------------------
      Return packet statistics.  Note that the stats provided by the caller
      are from the Rm interface, hence from the opposite perspective as the
      client, hence we reverse the direction before formulating the message
    -----------------------------------------------------------------------*/
    if(cl_sp->report_status.ind_mask & WDSI_STAT_MASK_TX_GOOD_NW)
    {
      indication->tx_ok_count_valid = TRUE;
      indication->tx_ok_count = stats->rx_pkts;
      cl_sp->report_status.stats_last_rpt.rx_pkts = stats->rx_pkts;
    }

    if(cl_sp->report_status.ind_mask & WDSI_STAT_MASK_RX_GOOD_NW)
    {
      indication->rx_ok_count_valid = TRUE;
      indication->rx_ok_count = stats->tx_pkts;
      cl_sp->report_status.stats_last_rpt.tx_pkts = stats->tx_pkts;
    }

    /*-----------------------------------------------------------------------
      Return WDSI_STAT_VALUE_UNAVAILABLE for these as they are not supported:
      WDSI_PRM_TYPE_PKT_TX_ERROR, WDSI_PRM_TYPE_PKT_RX_ERROR,
      WDSI_PRM_TYPE_PKT_TX_OVERFLOW, WDSI_PRM_TYPE_PKT_RX_OVERFLOW
    -----------------------------------------------------------------------*/
    num_discard_pkts = WDSI_STAT_VALUE_UNAVAILABLE;
    num_out_of_mem_pkts = WDSI_STAT_VALUE_UNAVAILABLE;

    if(cl_sp->report_status.ind_mask & WDSI_STAT_MASK_TX_DISCARD_NW)
    {
      indication->tx_err_count_valid = TRUE;
      indication->tx_err_count = num_discard_pkts;
    }

    if(cl_sp->report_status.ind_mask & WDSI_STAT_MASK_RX_DISCARD_NW)
    {
      indication->rx_err_count_valid = TRUE;
      indication->rx_err_count = num_discard_pkts;
    }

    if(cl_sp->report_status.ind_mask & WDSI_STAT_MASK_TX_OUT_OF_MEM_NW)
    {
      indication->tx_ofl_count_valid = TRUE;
      indication->tx_ofl_count = num_out_of_mem_pkts;
    }

    if(cl_sp->report_status.ind_mask & WDSI_STAT_MASK_RX_OUT_OF_MEM_NW)
    {
      indication->rx_ofl_count_valid = TRUE;
      indication->rx_ofl_count = num_out_of_mem_pkts;
    }

    if(cl_sp->report_status.ind_mask & WDSI_STAT_MASK_TX_OK_BYTES)
    {
      indication->tx_ok_bytes_count_valid = TRUE;
      indication->tx_ok_bytes_count = stats->rx_bytes;
      cl_sp->report_status.stats_last_rpt.rx_bytes = stats->rx_bytes;
    }

    if(cl_sp->report_status.ind_mask & WDSI_STAT_MASK_RX_OK_BYTES)
    {
      indication->rx_ok_bytes_count_valid = TRUE;
      indication->rx_ok_bytes_count = stats->tx_bytes;
      cl_sp->report_status.stats_last_rpt.tx_bytes = stats->tx_bytes;
    }

    if(cl_sp->report_status.ind_mask & WDSI_STAT_MASK_TX_DROPPED)
    {
      indication->tx_dropped_count_valid = TRUE;
      indication->tx_dropped_count= stats->rx_pkts_dropped;
      cl_sp->report_status.stats_last_rpt.rx_pkts_dropped = stats->rx_pkts_dropped;
    }

    if(cl_sp->report_status.ind_mask & WDSI_STAT_MASK_RX_DROPPED)
    {
      indication->rx_dropped_count_valid = TRUE;
      indication->rx_dropped_count = stats->tx_pkts_dropped;
      cl_sp->report_status.stats_last_rpt.tx_pkts_dropped = stats->tx_pkts_dropped;
    }
  }

  /*-------------------------------------------------------------------------
    Event causing indication is Change in Data Bearer Technology
  -------------------------------------------------------------------------*/
  if (event_mask & WDSI_REPORT_STATUS_EV_DATA_BEARER)
  {
    LOG_MSG_INFO2_2 ("Indicate Data Bearer Technology (= %d) clid=%d",
                     data_bearer_tech, clid);
    indication->data_bearer_tech_valid = TRUE;
    indication->data_bearer_tech = (wds_data_bearer_tech_enum_v01)data_bearer_tech;
  }

  /*-------------------------------------------------------------------------
    Event causing indication is Change in Dormancy Status
  -------------------------------------------------------------------------*/
  if (event_mask & WDSI_REPORT_STATUS_EV_DORM_STATUS)
  {
    ASSERT ((dormancy_status > QMI_WDS_TRAFFIC_CH_MIN) && (dormancy_status < QMI_WDS_TRAFFIC_CH_MAX));

    LOG_MSG_INFO2_2 ("Indicate Dormancy Status (= %d) clid=%d",
                     dormancy_status, clid);
    indication->dormancy_status_valid = TRUE;
    indication->dormancy_status = (wds_dormancy_status_enum_v01)dormancy_status;
  }

  /*-------------------------------------------------------------------------
    Event causing indication is Change in MIP status
  -------------------------------------------------------------------------*/

  if (event_mask & WDSI_REPORT_STATUS_MIP_STATUS)
  {
    LOG_MSG_INFO2_1 ("Indicate MIPS Status (= 0x%02x)", mip_status);
    indication->mip_status_valid = TRUE;
    indication->mip_status = mip_status;
  }

  /*-------------------------------------------------------------------------
    Event causing indication is Change in Current Data Bearer Technology
  -------------------------------------------------------------------------*/
  if (event_mask & WDSI_REPORT_STATUS_EV_CURR_DATA_BEARER)
  {
    if( NULL == curr_data_bearer_tech)
    {
      LOG_MSG_ERROR_0("curr_data_bearer_tech = NULL");
      PS_SYSTEM_HEAP_MEM_FREE(indication);
      return;
    }
    LOG_MSG_INFO1_1 ("Indicate CurrentData Bearer Technology to clid=%d",
                     clid);
    LOG_MSG_INFO2_3 ("Data Bearer Tech curr_nw=%d, rat_mask=%d, so_mask=%d",
                     curr_data_bearer_tech->current_nw,
                     curr_data_bearer_tech->rat_mask,
                     curr_data_bearer_tech->so_mask);
    indication->current_bearer_tech_valid = TRUE;
    indication->current_bearer_tech.current_nw = (wds_current_nw_enum_v01)curr_data_bearer_tech->current_nw;
    indication->current_bearer_tech.rat_mask = curr_data_bearer_tech->rat_mask;
    indication->current_bearer_tech.so_mask = curr_data_bearer_tech->so_mask;
  }

  if (event_mask & WDSI_REPORT_STATUS_DATA_CALL_STATUS)
  {
    LOG_MSG_INFO2_1 ("Indicate call status change to clid=%d", clid);
    switch (data_call_type)
    {
      case WDSI_DATA_CALL_EMBEDDED:
      {
        v_out_data_call_type.call_type     = WDSI_CALL_TYPE_EMBEDDED;
        v_out_data_call_type.call_sub_type = WDSI_CALL_SUB_TYPE_NONE;
        break;
      }
        
      case WDSI_DATA_CALL_TETHERED_RMNET:
      {
        v_out_data_call_type.call_type     = WDSI_CALL_TYPE_TETHERED;
        v_out_data_call_type.call_sub_type = WDSI_CALL_SUB_TYPE_RMNET;
        break;
      }
    
      case WDSI_DATA_CALL_TETHERED_DUN:
      {
        v_out_data_call_type.call_type     = WDSI_CALL_TYPE_TETHERED;
        v_out_data_call_type.call_sub_type = WDSI_CALL_SUB_TYPE_DUN;
        break;
      }
    
      case WDSI_DATA_CALL_MODEM_EMBEDDED:
      {
        v_out_data_call_type.call_type     = WDSI_CALL_TYPE_MODEM_EMBEDDED;
        v_out_data_call_type.call_sub_type = WDSI_CALL_SUB_TYPE_NONE;
        break;
      }

      default:
      {
        LOG_MSG_ERROR_1("Recd invalid data call enum type: %d",
                        data_call_type);
        PS_SYSTEM_HEAP_MEM_FREE(indication);
        return;
      }
    }

    if ( (addr_family == QMI_AF_INET) || (addr_family == QMI_AF_INET6) )
    {
      v_out_addr_family = addr_family;
    }
    else
    {
      v_out_addr_family = QMI_AF_ANY;
    }
    indication->data_call_status_valid = TRUE;
    indication->data_call_status = (wds_data_call_status_change_enum_v01)call_status;
    indication->data_call_type_valid = TRUE;
    indication->data_call_type.data_call_type = v_out_data_call_type.call_type;
    indication->data_call_type.tethered_call_type = v_out_data_call_type.call_sub_type;
    indication->data_call_addr_family_valid = TRUE;
    indication->data_call_addr_family = v_out_addr_family;
  }
  
  if (event_mask & WDSI_REPORT_STATUS_DATA_SYSTEM_STATUS)
  {
    LOG_MSG_INFO2_1 ("Indicate data system status change to clid=%d", clid);
    indication->system_status_valid = TRUE;
    indication->system_status.preferred_network = data_system_status->preferred_network;
    indication->system_status.network_info_len = data_system_status->network_info_len;
	length = 0;
    while(length < data_system_status->network_info_len)
    {      
      indication->system_status.network_info[length].network =
                  data_system_status->network_info[length].network;
      indication->system_status.network_info[length].rat_mask =
                  data_system_status->network_info[length].rat_mask;
      indication->system_status.network_info[length].so_mask = 
                  data_system_status->network_info[length].so_mask;
      length++;
    }
  }

   if (event_mask & WDSI_REPORT_STATUS_PREFERRED_DATA_STATUS)
  {
    LOG_MSG_INFO1_1 ("Indicate preferred system to clid=%d", clid);
    indication->current_sys_valid = TRUE;
    indication->current_sys = preferred_system;
  }

  if (event_mask & WDSI_REPORT_STATUS_ADDITIONAL_PDN_FILTERS_REMOVAL)
  {
    LOG_MSG_INFO1_1 ("Indicate Removal of additional pdn fltrs to clid=%d",
                     clid);
    indication->removed_filter_handles_valid = TRUE;
    indication->removed_filter_handles_len = fltrs_removed->num_filters;
    memscpy(&indication->removed_filter_handles,sizeof(indication->removed_filter_handles),
             fltrs_removed->fltr_handles,((fltrs_removed->num_filters)*sizeof(uint32)));
  }
  
  if (event_mask & WDSI_REPORT_STATUS_DELAY_DORMANCY)
  {
    indication->delay_dormancy_result_valid = TRUE;
    indication->delay_dormancy_result.status = delay_dorm_result->status;
    indication->delay_dormancy_result.dormancy_failure_reason = 
                        delay_dorm_result->dormancy_failure_reason;
  }
  qmi_wdsi_send_ind(wds_sp, cl_sp, QMI_WDS_EVENT_REPORT_IND_V01,
          sizeof(wds_event_report_ind_msg_v01),indication,TRUE);
  PS_SYSTEM_HEAP_MEM_FREE(indication);
} /* qmi_wdsi_event_report_ind() */

/*===========================================================================
  FUNCTION QMI_WDSI_INTERNAL_IFACE_EV_REG()

  DESCRIPTION
    Register for internal IFACE Events

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_internal_iface_ev_reg
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *   response;
  wds_internal_iface_ev_register_req_msg_v01 req_msg;
  wds_internal_iface_ev_register_resp_msg_v01 resp_msg;
  qmi_wdsi_state_type *         wds_sp;
  qmi_wdsi_client_state_type *  wds_client_sp;
  qmi_error_type_v01 errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg)); 

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  wds_sp = (qmi_wdsi_state_type *) sp;
  wds_client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_INTERNAL_IFACE_EV_REGISTER_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  if ( req_msg.event_registration_mask == 0)
  {
    errval = QMI_ERR_MISSING_ARG_V01;
    goto send_result;
  }

  wds_client_sp->internal_iface_ev_reg_mask |= req_msg.event_registration_mask;
  if (FALSE == wds_sp->internal_iface_ev_reg)
  {
    /* First request from client to register for internal iface events */
    wds_sp->internal_iface_ev_reg = TRUE;
    if (wds_sp->pkt_svc_state == QMI_WDS_CONN_CONNECTED)
    {
      /* Call is up. Register for internal iface events */
      LOG_MSG_INFO2_0 ("Client requests internal iface event registration for the "
                       "first time after call is up");
      wdsi_reg_internal_um_iface_ev( wds_sp );
    }
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_INTERNAL_IFACE_EV_REGISTER_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_internal_iface_ev_reg() */

/*===========================================================================
  FUNCTION QMI_WDSI_INTERNAL_IFACE_EV_IND()

  DESCRIPTION
    Is called when any of the iface events registered for occur.
    Sends an indication to the client.

  PARAMETERS
    wds_sp                : service provided state pointer
    cl_sp                 : client state pointer
    event                 : event causing the indication
    event_info            : information to be sent out as part of the indication

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_internal_iface_ev_ind
(
  qmi_wdsi_state_type *          wds_sp,
  qmi_wdsi_client_state_type *   cl_sp,
  qmi_wdsi_int_if_ev_e_type      event,
  ps_iface_event_info_u_type     event_info
)
{
  wds_internal_iface_ev_ind_msg_v01 indication;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(wds_sp && cl_sp);

  memset(&indication,0,sizeof(wds_internal_iface_ev_ind_msg_v01));
  LOG_MSG_INFO2_1("qmi_wdsi_internal_iface_ev_ind - event=%d", event);
  switch (event)
  {
    case WDSI_INT_IF_EV_OUTAGE_NOTIFICATION:
    {
      /* Event causing indication is Outage */
      indication.outage_valid = TRUE;
      indication.outage.duration =
           event_info.outage_notification_info.duration;
      indication.outage.time_to_outage = 
                          event_info.outage_notification_info.time_to_outage;
      break;
    }

    case WDSI_INT_IF_EV_EXT_IPCONFIG:
    {
      /* Event causing indication is Extended IP Config */
      indication.extended_ip_config_status_valid = TRUE;
      indication.extended_ip_config_status = 
        (event_info.extended_ip_config_change_mask==0)?FALSE:TRUE;
      break;
    }

    case WDSI_INT_IF_EV_HDR_RATE_INERTIA_SUCCESS:
    case WDSI_INT_IF_EV_HDR_SM_SUCCESS:
    {
      /* Event causing indication is HDR Rev0 Rate Inertia Success
         or HDR Slotted Mode Success */
      break;
    }

    case WDSI_INT_IF_EV_HDR_RATE_INERTIA_FAILURE:
    {
      /* Event causing indication is HDR Rev0 Rate Inertia Failure */
      indication.hdr_rate_intertia_fail_valid = TRUE;
      indication.hdr_rate_intertia_fail = (wds_hdr_rev0_rate_inertia_failure_code_enum_v01)
                               event_info.hdr_rev0_rate_inertia_failure_code;
      break;
    }

    case WDSI_INT_IF_EV_HDR_SM_FAILURE:
    {
      /* Event causing indication is HDR Slotted Mode Failure */
      indication.hdr_sm_fail_valid = TRUE;
      indication.hdr_sm_fail = (wds_hdr_slotted_mode_failure_code_enum_v01)
                  event_info.slotted_mode_info.hdr_slotted_mode_failure_code;
      break;
    }

    case WDSI_INT_IF_EV_HDR_SM_SESS_CHANGE:
    {
      /* Event causing indication is HDR Slotted Mode Session Change */
      indication.slot_cycle_changed_valid = TRUE;
      indication.slot_cycle_changed = event_info.slotted_mode_info.sm_current_sci;
      break;
    }

    case WDSI_INT_IF_EV_RF_CONDITIONS:
    {
      /* Event causing indication is RF Conditions */
      if ((event_info.rf_conditions_change_info.bearer_tech.current_network >
           PS_IFACE_NETWORK_MIN) &&
          (event_info.rf_conditions_change_info.bearer_tech.current_network <
           PS_IFACE_NETWORK_MAX))
      {
        indication.rf_conditions_valid = TRUE;
        indication.rf_conditions.db_current_nw = 
          (wds_current_nw_enum_v01)event_info.rf_conditions_change_info.bearer_tech.current_network;
      }
      if (indication.rf_conditions.db_current_nw == PS_IFACE_NETWORK_CDMA)
      {
        indication.rf_conditions.db_rat_mask =
         event_info.rf_conditions_change_info.bearer_tech.data.cdma_type.rat_mask;
        /*-------------------------------------------------------------------------
          if rat_mask is PS_IFACE_CDMA_EVDO_REV0 or PS_IFACE_CDMA_NULL_BEARER ,
          then ignoring the so_mask from any garbage values.
        -------------------------------------------------------------------------*/
        if ( (indication.rf_conditions.db_rat_mask != PS_IFACE_CDMA_EVDO_REV0) && 
             (indication.rf_conditions.db_rat_mask != PS_IFACE_CDMA_NULL_BEARER) )
        {
          indication.rf_conditions.db_so_mask =
           event_info.rf_conditions_change_info.bearer_tech.data.cdma_type.so_mask;
        }
      }
      else if (indication.rf_conditions.db_current_nw == PS_IFACE_NETWORK_UMTS)
      {
        indication.rf_conditions.db_rat_mask =
         event_info.rf_conditions_change_info.bearer_tech.data.umts_type.rat_mask;
      }
      indication.rf_conditions.rf_cond =
           (wds_rf_conditions_enum_v01)event_info.rf_conditions_change_info.rf_conditions;
      break;
    }

    case WDSI_INT_IF_EV_DOS_ACK:
    {
      /* Event causing indication is DOS ACK Physlink Event */
      indication.dos_ack_info_valid = TRUE;
      indication.dos_ack_info.handle = 
                 (uint16)event_info.dos_ack_info.handle;
      indication.dos_ack_info.overflow = 
                                event_info.dos_ack_info.status_info.overflow;
      indication.dos_ack_info.dos_ack_status = (wds_dos_ack_status_enum_v01)
                  event_info.dos_ack_info.status_info.status;
      break;
    }
    default:
    {
      LOG_MSG_ERROR_1("Unexpected event (=%d)", event);
      return;
    }
  }
  indication.iface_event_name =(wds_iface_event_name_enum_v01)event;
  (void)qmi_wdsi_send_ind( wds_sp,
                          cl_sp,
                          QMI_WDS_INTERNAL_IFACE_EV_IND_V01,
                          sizeof(wds_internal_iface_ev_ind_msg_v01),
                          &indication ,TRUE);

} /* qmi_wdsi_internal_iface_ev_ind() */

/*===========================================================================
  FUNCTION QMI_WDSI_CREATE_PROFILE()

  DESCRIPTION
    Create a 3GPP or 3GPP2 profile

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_create_profile
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

 return qmi_wds_profile_create(sdu_in,
                               qmi_wdsi_resolve_client_subs(cl_sp));
} /* qmi_wdsi_create_profile() */



/*===========================================================================
  FUNCTION QMI_WDSI_MODIFY_PROFILE_SETTINGS()

  DESCRIPTION
    Modify a 3GPP or 3GPP2 profile

  PARAMETERS
    sp        : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : Client State Pointer.
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_modify_profile_settings
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_modify_profile_settings_req_msg_v01 *req_msg =  NULL;
  wds_modify_profile_settings_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
  dsm_item_type *    sdu_dup;
  int32              temp;
  uint32             sdu_len;
  uint32             subs_id;
  ds_profile_status_etype temp_profile_status;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  temp_profile_status = DS_PROFILE_REG_RESULT_SUCCESS;

  sdu_dup = NULL;
  sdu_len = dsm_length_packet(*sdu_in);
  memset(&resp_msg,0,sizeof(resp_msg));
  PS_SYSTEM_HEAP_MEM_ALLOC(req_msg,
                           sizeof(wds_modify_profile_settings_req_msg_v01),
                           wds_modify_profile_settings_req_msg_v01*);
  if(req_msg == NULL)
  {
    qmi_svc_put_result_tlv(&response, (qmi_result_e_type)QMI_RESULT_FAILURE_V01,
                           (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
    return response;
  }
  else
  {
    memset(req_msg,0,sizeof(wds_modify_profile_settings_req_msg_v01));
  }
  temp = PS_UTILS_DSM_DUP_PACKET( &sdu_dup, *sdu_in, 0, (uint16)sdu_len);
  if (0 == temp)
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    goto send_result;
  }
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_MODIFY_PROFILE_SETTINGS_REQ_V01,
                                       sdu_in,
                                       req_msg,
                                       sizeof(wds_modify_profile_settings_req_msg_v01));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  response = qmi_wds_profile_modify_settings(&sdu_dup,
                                          req_msg->profile.profile_type,
                                          req_msg->profile.profile_index,
                                          subs_id, 
                                          &errval,
                                          &temp_profile_status);
  PS_SYSTEM_HEAP_MEM_FREE(req_msg);
  return response;
send_result:
  dsm_free_packet(&sdu_dup);
  PS_SYSTEM_HEAP_MEM_FREE(req_msg);
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_MODIFY_PROFILE_SETTINGS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_modify_profile_settings() */

/*===========================================================================
  FUNCTION QMI_WDSI_DELETE_PROFILE()

  DESCRIPTION
    Delete the given 3GPP or 3GPP2 profile

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_delete_profile
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;

  qmi_error_type_v01  errval;
  uint32             subs_id;
  wds_delete_profile_req_msg_v01 req_msg;
  wds_delete_profile_resp_msg_v01 resp_msg;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&req_msg,0,sizeof(wds_delete_profile_req_msg_v01));
  memset(&resp_msg,0,sizeof(wds_delete_profile_resp_msg_v01));

  response = NULL;
  errval = QMI_ERR_NONE_V01;

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_DELETE_PROFILE_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  else
  {
    return qmi_wds_profile_delete(req_msg.profile.profile_type,
                                  req_msg.profile.profile_index, subs_id);
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_DELETE_PROFILE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_delete_profile() */



/*===========================================================================
  FUNCTION QMI_WDSI_GET_PROFILE_LIST()

  DESCRIPTION
    Get a list of all profiles

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_profile_list
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  wds_get_profile_list_req_msg_v01 req_msg;
  wds_get_profile_list_resp_msg_v01* resp_msg = NULL;
  dsm_item_type *               response;
  qmi_error_type_v01 errval;
  uint32             subs_id;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  memset(&req_msg,0,sizeof(req_msg));

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg,
                           sizeof(wds_get_profile_list_resp_msg_v01),
                           wds_get_profile_list_resp_msg_v01*);
  if(resp_msg == NULL)
  {
    qmi_svc_put_result_tlv(&response, (qmi_result_e_type)QMI_RESULT_FAILURE_V01, 
                           (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
    return response;
  }
  else
  {
    memset(resp_msg,0,sizeof(wds_get_profile_list_resp_msg_v01));
  }
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GET_PROFILE_LIST_REQ_V01,
                                       sdu_in,
                                      &req_msg,
                                      sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  LOG_MSG_INFO1_1("profile type valid %d",req_msg.profile_type_valid);
  /*No TLV chosen. Get the 3GPP profile list*/
  if(req_msg.profile_type_valid != TRUE)
  {
    req_msg.profile_type = WDS_PROFILE_TYPE_3GPP;
    req_msg.profile_type_valid = TRUE;
  }
  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  return qmi_wds_profile_get_list(req_msg.profile_type,
                                  subs_id);

send_result:

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_PROFILE_LIST_RESP_V01,
                               resp_msg,
                               sizeof(wds_get_profile_list_resp_msg_v01),
                               errval,
                               &response);
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  return response;
} /* qmi_wdsi_get_profile_list() */


/*===========================================================================
  FUNCTION QMI_WDSI_GET_PROFILE_SETTINGS()

  DESCRIPTION
    Retrive the settings of a 3GPP or 3GPP2 profile

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_profile_settings
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  qmi_error_type_v01 errval;
  uint32             subs_id;
  wds_get_profile_settings_req_msg_v01 req_msg;
  wds_get_profile_settings_resp_msg_v01 *resp_msg = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  
  PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg,
                           sizeof(wds_get_profile_settings_resp_msg_v01),
                           wds_get_profile_settings_resp_msg_v01*);
  if(resp_msg == NULL)
  {
    qmi_svc_put_result_tlv(&response, (qmi_result_e_type)QMI_RESULT_FAILURE_V01,
                          (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
    return response;
  }
  else
  {
    memset(resp_msg,0,sizeof(wds_get_profile_settings_resp_msg_v01));
  }
  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GET_PROFILE_SETTINGS_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  else
  {
    PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
    return qmi_wds_profile_get_settings(req_msg.profile.profile_type,
                                        req_msg.profile.profile_index,
                                        subs_id);
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_PROFILE_SETTINGS_RESP_V01,
                               resp_msg,
                               sizeof(wds_get_profile_settings_resp_msg_v01),
                               errval,
                               &response);
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  return response;
} /* qmi_wdsi_get_profile_settings() */


/*===========================================================================
  FUNCTION QMI_WDSI_GET_DEFAULT_PROFILE_SETTINGS()

  DESCRIPTION
    Retrive the default settings of a 3GPP or 3GPP2 profile

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_default_profile_settings
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_get_default_settings_req_msg_v01 req_msg;
  wds_get_default_settings_resp_msg_v01* resp_msg = NULL;
  qmi_error_type_v01 errval;
  uint32             subs_id = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&req_msg,0,sizeof(req_msg));
  
  response = NULL;
  errval = QMI_ERR_NONE_V01;
  PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg,
                           sizeof(wds_get_default_settings_resp_msg_v01),
                           wds_get_default_settings_resp_msg_v01*);
  if(resp_msg == NULL)
  {
    qmi_svc_put_result_tlv(&response, (qmi_result_e_type)QMI_RESULT_FAILURE_V01, 
                          (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
    return response;
  }
  else
  {
    memset(resp_msg,0,sizeof(wds_get_default_settings_resp_msg_v01));
  }
  
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GET_DEFAULT_SETTINGS_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  else
  {
    subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
    PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
    return qmi_wds_profile_get_default_settings(req_msg.profile_type,
                                                subs_id);
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_DEFAULT_SETTINGS_RESP_V01,
                               resp_msg,
                               sizeof(wds_get_default_settings_resp_msg_v01),
                               errval,
                               &response);
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  return response;
} /* qmi_wdsi_get_default_profile_settings() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_DEFAULT_PROFILE_NUM()

  DESCRIPTION
    Retrive the default profile number for a 3GPP or 3GPP2 profile

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_default_profile_num
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_get_default_profile_num_req_msg_v01 req_msg;
  wds_get_default_profile_num_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
  uint32             subs_id;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GET_DEFAULT_PROFILE_NUM_REQ_V01,
                                       sdu_in,
                                      &req_msg,
                                      sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  else
  {
    return qmi_wds_profile_get_default_profile_num(req_msg.profile.profile_type,
                                                   req_msg.profile.profile_family,
                                                   subs_id);
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_DEFAULT_PROFILE_NUM_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_default_profile_num() */


/*===========================================================================
  FUNCTION QMI_WDSI_SET_DEFAULT_PROFILE_NUM()

  DESCRIPTION
    Set the default profile number for a 3GPP or 3GPP2 profile

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_default_profile_num
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_set_default_profile_num_req_msg_v01 req_msg;
  wds_set_default_profile_num_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
  uint32             subs_id;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  response = NULL;
  errval = QMI_ERR_NONE_V01;

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_DEFAULT_PROFILE_NUM_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
      goto send_result;
  }
  else
  {
    return qmi_wds_profile_set_default_profile_num(req_msg.profile_identifier.profile_type,
                                                   req_msg.profile_identifier.profile_family,
                                                   req_msg.profile_identifier.profile_index,
                                                   subs_id);
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_DEFAULT_PROFILE_NUM_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;  
} /* qmi_wdsi_set_default_profile_num() */


/*===========================================================================
  FUNCTION QMI_WDSI_RESET_PROFILE_TO_DEFAULT()

  DESCRIPTION
    Resets the parameters of the specified profile to default values.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_reset_profile_to_default
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_reset_profile_to_default_req_msg_v01 req_msg;
  wds_reset_profile_to_default_resp_msg_v01 resp_msg;

  qmi_error_type_v01 errval;
  uint32             subs_id;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_RESET_PROFILE_TO_DEFAULT_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  else
  {
    return qmi_wds_profile_reset_profile_to_default(req_msg.profile_identifier.profile_type,
                                                    req_msg.profile_identifier.profile_index,
                                                    subs_id);
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_RESET_PROFILE_TO_DEFAULT_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_reset_profile_to_default() */


/*===========================================================================
  FUNCTION QMI_WDSI_RESET_PROFILE_PARAM_TO_INVALID()

  DESCRIPTION
    Resets the specified parameter of the specified profile to invalid.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_reset_profile_param_to_invalid
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_reset_profile_param_to_invalid_req_msg_v01 req_msg;
  wds_reset_profile_param_to_invalid_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
  uint32             subs_id;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));
  
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_RESET_PROFILE_PARAM_TO_INVALID_REQ_V01,
                                       sdu_in,
                                      &req_msg,
                                      sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  else
  {
    return qmi_wds_profile_reset_param_to_invalid( req_msg.profile_param.profile_type,
                                                   req_msg.profile_param.profile_index,
                                                   req_msg.profile_param.profile_param_id,
                                                   subs_id );
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_RESET_PROFILE_PARAM_TO_INVALID_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_reset_profile_param_to_invalid() */


/*===========================================================================
  FUNCTION QMI_WDSI_GET_RUNTIME_SETTINGS()

  DESCRIPTION
    Retrive the current runtime settings of a 3GPP or 3GPP2 call

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_runtime_settings
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *            wds_sp;
  dsm_item_type *                  response;
  wds_get_runtime_settings_req_msg_v01 req_msg;
  wds_get_runtime_settings_resp_msg_v01* resp_msg =  NULL;
  ps_iface_type *                  um_iface_ptr = NULL;
  qmi_error_type_v01 errval;
  uint32             req_settings;
  uint32  ipv4_addr;
  uint32  rm_ipv4_addr = 0;
  uint32  subnet_mask = 0;
#ifdef FEATURE_DATA_PS_IPV6
  ps_iface_type    *  rm_iface_ptr = NULL;
  struct ps_in6_addr  ipv6_addr = {{{0},}};
  struct ps_in6_addr  rm_ipv6_addr = {{{0},}};
  ip_addr_type        v6_pri_dns = {IP_ANY_ADDR, {0}};
  ip_addr_type        v6_sec_dns = {IP_ANY_ADDR, {0}};

  ip_addr_type        v6_pri_dns_man = {IP_ANY_ADDR, {0}};
  ip_addr_type        v6_sec_dns_man = {IP_ANY_ADDR, {0}};
  uint64                 * iid = NULL;
  sint15                   ps_errno_iid;
  uint32                   mtu = 0;
  ps_iface_addr_mgmt_handle_type handle;
  ps_iface_addr_mgmt_alloc_type  alloc_info;
  int16 ps_errno_addr_mgmt = 0;
  int   num_retry = 0;
#endif /* FEATURE_DATA_PS_IPV6 */
  ip_addr_type pri_dns = {IP_ANY_ADDR, {0}};
  ip_addr_type sec_dns = {IP_ANY_ADDR, {0}};
  uint16 fqdn_len;
  uint32 pcscf_cnt;
  int    i;
  ps_iface_addr_family_type ip_family;
  uint32 domain_name_cnt;
  uint16 domain_name_len;
  ps_iface_name_enum_type  tech_name;


#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
#ifdef FEATURE_DATA_WLAN_MAPCON
  ds_sys_system_status_info_type  bearer_tech_ex_type;
#else
  ps_iface_bearer_technology_type  bearer_tech_type;
#endif /* FEATURE_DATA_WLAN_MAPCON */
  int               return_val;
  int16             ps_errno;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)*/
  qmi_wdsi_client_state_type * client_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp =(qmi_wdsi_client_state_type *)cl_sp;

  response = NULL;
  errval = QMI_ERR_NONE_V01;

  memset(&req_msg,0,sizeof(req_msg));

  PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg,
                           sizeof(wds_get_runtime_settings_resp_msg_v01),
                           wds_get_runtime_settings_resp_msg_v01*);
  if(resp_msg == NULL)
  {
    qmi_svc_put_result_tlv(&response, (qmi_result_e_type)QMI_RESULT_FAILURE_V01, 
                            (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
    return response;
  }
  else
  {
    memset(resp_msg,0,sizeof(wds_get_runtime_settings_resp_msg_v01));
  }
  /* return all settings till bit12 by default */
  req_settings = QMI_WDS_MASK_RUNTIME_DEFAULT;

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GET_RUNTIME_SETTINGS_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  if(req_msg.requested_settings_valid)
  {
    req_settings = req_msg.requested_settings;
  }
  /*-------------------------------------------------------------------------
    Check whether the call is up or not
  -------------------------------------------------------------------------*/
  if(wds_sp->is_mcast_inst == TRUE || wds_sp->is_embms_inst == TRUE)
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
    goto send_result;
  }

  if (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED)
  {
    LOG_MSG_INFO2_0("Not in a call, so no runtime profile available");
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  um_iface_ptr = wds_sp->um_iface_ptr;
  if(PS_IFACE_IS_VALID(um_iface_ptr) == FALSE)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  ip_family = ps_iface_get_addr_family(um_iface_ptr);
  LOG_MSG_INFO2_2("requested mask=0x%X, IP family=%d",
                  req_settings, ip_family);
  
  /*---------------------------------------------------------------------------
    Setup the IPv4 address information.
  ---------------------------------------------------------------------------*/
  if(ps_iface_addr_family_is_v4(um_iface_ptr))
  {
    memset(&pri_dns, 0, sizeof(ip_addr_type));
    memset(&sec_dns, 0, sizeof(ip_addr_type));

    ps_iface_get_v4_dns_addrs(wds_sp->um_iface_ptr, &pri_dns, &sec_dns);

    /* Convert DNS addrs to little endian to send to host */
    pri_dns.addr.v4 = ps_ntohl(pri_dns.addr.v4);
    sec_dns.addr.v4 = ps_ntohl(sec_dns.addr.v4);

    rmnet_v4_sm_calc_rm_iface_addr(
      wds_sp->binding.rmnet_inst,
      &ipv4_addr,
      &rm_ipv4_addr,
      &subnet_mask);
    ipv4_addr = ps_ntohl(ipv4_addr);
    /* Convert to host order to send in QMI */
    rm_ipv4_addr = ps_ntohl(rm_ipv4_addr);
    subnet_mask = ps_ntohl(subnet_mask);

    if(0 == ipv4_addr || 0 == rm_ipv4_addr)
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }

  /*---------------------------------------------------------------------------
    Setup the IPv6 address information.
  ---------------------------------------------------------------------------*/
#ifdef FEATURE_DATA_PS_IPV6
  if(ps_iface_addr_family_is_v6(um_iface_ptr))
  {
    memset(&v6_pri_dns, 0, sizeof(ip_addr_type));
    memset(&v6_sec_dns, 0, sizeof(ip_addr_type));

    memset(&v6_pri_dns_man, 0, sizeof(ip_addr_type));
    memset(&v6_sec_dns_man, 0, sizeof(ip_addr_type));

    /*-----------------------------------------------------------------------
      Get Um Iface Address and send to host in network byte order.
    -----------------------------------------------------------------------*/
    ipv6_addr.ps_s6_addr64[0] = PS_IFACE_GET_IP_V6_PREFIX(um_iface_ptr);

    iid = &ipv6_addr.ps_s6_addr64[1];
    if (-1 == ps_iface_generate_ipv6_iid(um_iface_ptr, iid, &ps_errno_iid))
    {
      LOG_MSG_ERROR_0("Failed to generate a random IPv6 IID");
    }

    /*-----------------------------------------------------------------------
      Retrieve IPv6 DNS addresses and send to host in network byte order.
    -----------------------------------------------------------------------*/
    ps_iface_get_v6_dns_addrs(wds_sp->um_iface_ptr, &v6_pri_dns, &v6_sec_dns);

    /*-----------------------------------------------------------------------
      Query the 'manual' DNS addresses and over-ride auto-configured values if 
      set
    -----------------------------------------------------------------------*/
    rmnet_meta_sm_get_ipv6_manual_dns_addrs(wds_sp->binding.rmnet_inst,
                                            &v6_pri_dns_man,
                                            &v6_sec_dns_man);
    if (IPV6_ADDR == v6_pri_dns_man.type)
    {
      if ((0 == v6_pri_dns_man.addr.v6[0]) && (0 == v6_pri_dns_man.addr.v6[1]))
      {
        LOG_MSG_INFO2_0("Manual IPv6 primary DNS, Ignoring IPv6 primary DNS address");
      }
      else
      {
        LOG_MSG_INFO2_0("Using manual IPv6 primary DNS address");
        memscpy(&v6_pri_dns, sizeof(v6_pri_dns), &v6_pri_dns_man, sizeof(ip_addr_type));
      }
    }
    else
    {
      LOG_MSG_INFO2_0("Manual IPv6 primary DNS address not provisioned");
    }
    if (IPV6_ADDR == v6_sec_dns_man.type)
    {
      if ((0 == v6_sec_dns_man.addr.v6[0]) && (0 == v6_sec_dns_man.addr.v6[1]))
      {
        LOG_MSG_INFO2_0("Manual IPv6 secondary DNS, Ignoring manual IPv6 secondary DNS address");
      }
      else
      {
        LOG_MSG_INFO2_0("Using manual IPv6 secondary DNS address");
        memscpy(&v6_sec_dns, sizeof(v6_sec_dns), &v6_sec_dns_man, sizeof(ip_addr_type));
      }
    }
    else
    {
      LOG_MSG_INFO2_0("Manual IPv6 secondary DNS address not provisioned");
    }

    /*-----------------------------------------------------------------------
      Get Rm Iface Address (Gateway Address) and convert send to host in
      network byte order.
    -----------------------------------------------------------------------*/
    rm_iface_ptr = rmnet_meta_sm_iface(wds_sp->binding.rmnet_inst);

    rm_ipv6_addr.ps_s6_addr64[0] = PS_IFACE_GET_IP_V6_PREFIX(rm_iface_ptr);
    rm_ipv6_addr.ps_s6_addr64[1] = PS_IFACE_GET_IP_V6_IID(rm_iface_ptr);

    if((0 == ipv6_addr.ps_s6_addr64[0]) || (0 == rm_ipv6_addr.ps_s6_addr64[0]))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }
#endif /* FEATURE_DATA_PS_IPV6 */

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  return_val = ps_iface_ioctl(um_iface_ptr,
#ifdef FEATURE_DATA_WLAN_MAPCON
                              PS_IFACE_IOCTL_GET_BEARER_TECHNOLOGY_EX,
                              &bearer_tech_ex_type,
#else
                              PS_IFACE_IOCTL_GET_BEARER_TECHNOLOGY,
                              &bearer_tech_type,
#endif /* FEATURE_DATA_WLAN_MAPCON */
                              &ps_errno);
  if (return_val == -1)
  {
    LOG_MSG_INFO1_0("Failed to get data bearer info. Return rest of the available runtime settings");
  }

#ifdef FEATURE_DATA_WLAN_MAPCON
  if (bearer_tech_ex_type.technology == DS_SYS_NETWORK_3GPP)
#else
  if (bearer_tech_type.current_network == PS_IFACE_NETWORK_UMTS)
#endif /* FEATURE_DATA_WLAN_MAPCON */
  {
    errval = qmi_wds_umts_get_runtime_settings(req_settings,
                                               resp_msg,
                                               um_iface_ptr,
#ifdef FEATURE_DATA_WLAN_MAPCON
                                               bearer_tech_ex_type);
#else
                                               bearer_tech_type);
#endif /* FEATURE_DATA_WLAN_MAPCON */

  }
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)*/

  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    populate response with common runtime settings after tech specific
  -------------------------------------------------------------------------*/
  if(req_settings & QMI_WDS_MASK_TECH_NAME)
  {
    tech_name = (ps_iface_name_enum_type)
                    PS_IFACE_GET_NAME_FROM_ID(PS_IFACE_GET_ID(um_iface_ptr));
    resp_msg->technology_name_valid = TRUE;
    resp_msg->technology_name = (wds_technology_name_enum_v01)tech_name;
  }
  if(req_settings & QMI_WDS_MASK_OP_RES_PCO)
  {
    memset(&wds_temp, 0, sizeof(wds_temp));
    if(-1 == ps_iface_get_operator_reserved_pco(um_iface_ptr,
                                       &wds_temp.protocol_reserved_info))
    {
      LOG_MSG_INFO2_0 ("PCO information is unavailable !!!");
    }
    else
    {
      /*-----------------------------------------------------------------------
        Construct the PCO packet
      -----------------------------------------------------------------------*/
      /* Retrieve mcc field and copy into buffer*/
      resp_msg->operator_reserved_pco_valid = TRUE;
      resp_msg->operator_reserved_pco.mcc = wds_temp.protocol_reserved_info.mcc;
  
     /* Retrieve mnc field and copy into buffer*/
      resp_msg->operator_reserved_pco.mnc = wds_temp.protocol_reserved_info.mnc;
  
      /* Retrieve mnc_includes_pcs_digit field and copy into buffer*/
      resp_msg->operator_reserved_pco.mnc_includes_pcs_digit = 
               wds_temp.protocol_reserved_info.mnc_includes_pcs_digit;
  
      /* Retrieve app_specific_info_len field and copy into buffer*/
      resp_msg->operator_reserved_pco.app_specific_info_len = 
               wds_temp.protocol_reserved_info.app_specific_info_len;
  
      /* Retrieve app_specific_info field and copy into buffer*/
      memscpy(resp_msg->operator_reserved_pco.app_specific_info,
              sizeof(resp_msg->operator_reserved_pco.app_specific_info),
             (void *)&wds_temp.protocol_reserved_info.app_specific_info,
             wds_temp.protocol_reserved_info.app_specific_info_len);
  
      /* Retrieve container_id field and copy into buffer*/
      resp_msg->operator_reserved_pco.container_id = 
               wds_temp.protocol_reserved_info.container_id;
    }

  }

  if(req_settings & QMI_WDS_MASK_IP_FAMILY)
  {
    ip_family = ps_iface_get_addr_family(um_iface_ptr);
    if ((ip_family != IPV4_ADDR) && (ip_family != IPV6_ADDR))
    {
      LOG_MSG_ERROR_1("Invalid IP family (= &d)", ip_family);
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
    resp_msg->ip_family_valid = TRUE;
    resp_msg->ip_family = (wds_ip_family_enum_v01)ip_family;
  }

  if(req_settings & QMI_WDS_MASK_DOMAIN_NAME_LIST)
  {
    memset(&wds_temp, 0, sizeof(wds_temp));
    domain_name_cnt = QMI_WDS_MAX_DOMAIN_NAMES;
    ps_iface_get_domain_name_search_list( um_iface_ptr,
                                          wds_temp.domain_name_search_list,
                                          &domain_name_cnt );
    resp_msg->domain_name_list_valid = TRUE;
    resp_msg->domain_name_list.domain_name_list_len = domain_name_cnt;
    for(i = domain_name_cnt-1; i >= 0; i--)
    {
      /* Make sure strlen won't go beyond this page */
      wds_temp.domain_name_search_list[i].domain_name[sizeof(wds_temp.domain_name_search_list[i].domain_name)-1] = 0;
      domain_name_len = strlen(wds_temp.domain_name_search_list[i].domain_name);
      memscpy(resp_msg->domain_name_list.domain_name_list[i].domain_name,
              sizeof(resp_msg->domain_name_list.domain_name_list[i].domain_name),
              wds_temp.domain_name_search_list[i].domain_name,
              domain_name_len);
    }
  }

  if(req_settings & QMI_WDS_MASK_MTU)
  {
    mtu = PS_IFACE_GET_MTU(um_iface_ptr);
    resp_msg->mtu_valid = TRUE;
    resp_msg->mtu = mtu;
  }

  if(req_settings & QMI_WDS_MASK_PCSCF_ADDR)
  {
    memset(&wds_temp, 0, sizeof(wds_temp));
    pcscf_cnt = QMI_WDS_MAX_PCSCF_SERVERS;
    if(0 != ps_iface_get_sip_serv_addr_ex(um_iface_ptr,
                                          wds_temp.pcscf_addr,
                                          &pcscf_cnt))
    {
      errval= QMI_ERR_NO_MEMORY_V01;
      goto send_result;
    }
    
    if (PS_IFACE_IS_ADDR_FAMILY_V4(um_iface_ptr))
    {
      resp_msg->pcscf_ipv4_server_addr_list_valid = TRUE;
      resp_msg->pcscf_ipv4_server_addr_list.pcscf_ipv4_addr_list_len = pcscf_cnt;
    }
    else
    {
      resp_msg->pcscf_ipv6_server_addr_list_valid = TRUE;
      resp_msg->pcscf_ipv6_server_addr_list.pcscf_ipv6_addr_list_len = pcscf_cnt;
    }

    for(i = pcscf_cnt-1; i >= 0; i--)
    {
      switch (wds_temp.pcscf_addr[i].type)
      {
        case IPV4_ADDR:
          /* convert to host order to send in QMI */
          wds_temp.pcscf_addr[i].addr.v4 =
              ps_ntohl(wds_temp.pcscf_addr[i].addr.v4);
          resp_msg->pcscf_ipv4_server_addr_list.pcscf_ipv4_addr_list[i].pcscf_ipv4_address = 
              wds_temp.pcscf_addr[i].addr.v4;
          break;
        case IPV6_ADDR:
          /* IPv6 addresses are sent in network byte order */
          memscpy(resp_msg->pcscf_ipv6_server_addr_list.pcscf_ipv6_addr_list[i].pcscf_ipv6_addr,
                  sizeof(resp_msg->pcscf_ipv6_server_addr_list.pcscf_ipv6_addr_list[i].pcscf_ipv6_addr),
                  wds_temp.pcscf_addr[i].addr.v6,
                  sizeof(wds_temp.pcscf_addr[i].addr.v6));
          break;

        default:
          LOG_MSG_ERROR_1("Invalid IP addr type %d recd from PS iface",
                          wds_temp.pcscf_addr[i].type);
          errval = QMI_ERR_INTERNAL_V01;
          goto send_result;
      }
    }
  }

  if(req_settings & QMI_WDS_MASK_PCSCF_NAME)
  {
    memset(&wds_temp, 0, sizeof(wds_temp));
    pcscf_cnt = QMI_WDS_MAX_PCSCF_SERVERS;
    ps_iface_get_sip_domain_names(um_iface_ptr,
                                  wds_temp.pcscf_fqdn,
                                  &pcscf_cnt);
    resp_msg->fqdn_valid = TRUE;
    resp_msg->fqdn.fqdn_list_len = pcscf_cnt;
    for(i = pcscf_cnt-1; i >= 0; i--)
    {
        /* Make sure strlen won't go beyond this page */
      wds_temp.pcscf_fqdn[i].domain_name[sizeof(wds_temp.pcscf_fqdn[i].domain_name)-1] = 0;
      fqdn_len = strlen(wds_temp.pcscf_fqdn[i].domain_name);
      memscpy(resp_msg->fqdn.fqdn_list[i].fqdn,sizeof(resp_msg->fqdn.fqdn_list[i].fqdn),
              wds_temp.pcscf_fqdn[i].domain_name,fqdn_len);
    }
  }
  if(ps_iface_addr_family_is_v4(um_iface_ptr))
  {
    if(req_settings & QMI_WDS_MASK_GATEWAY)
    {
      if(0 != subnet_mask)
      {
        resp_msg->ipv4_subnet_mask_valid = TRUE;
        resp_msg->ipv4_subnet_mask = subnet_mask;
      }
      if(0 != rm_ipv4_addr)
      {
        resp_msg->ipv4_gateway_addr_valid =  TRUE;
        resp_msg->ipv4_gateway_addr = rm_ipv4_addr;
      }
    }

    if(req_settings & QMI_WDS_MASK_DNS_ADDR)
    {
      if(0 != sec_dns.addr.v4)
      {
        resp_msg->secondary_DNS_IPv4_address_preference_valid = TRUE;
        resp_msg->secondary_DNS_IPv4_address_preference = sec_dns.addr.v4;
      }
      if(0 != pri_dns.addr.v4)
      {
        resp_msg->primary_DNS_IPv4_address_preference_valid = TRUE;
        resp_msg->primary_DNS_IPv4_address_preference = pri_dns.addr.v4;
      }
    }

    if(req_settings & QMI_WDS_MASK_IP_ADDR)
    {
      resp_msg->ipv4_address_preference_valid = TRUE;
      resp_msg->ipv4_address_preference = ipv4_addr;
      /* clear guard timer as IP address querried in QMI */
      rmnet_v4_sm_clear_guard_timer(wds_sp->binding.rmnet_inst);
    }
  }

#ifdef FEATURE_DATA_PS_IPV6
  if(ps_iface_addr_family_is_v6(um_iface_ptr))
  {
    if(req_settings & QMI_WDS_MASK_IP_ADDR)
    {
      /* Add the address to UM database
         If there is a conflict re-generate IID up to 3 times
      */
      num_retry = 0;
      while (TRUE)
      {
        handle = ps_iface_addr_mgmt_get_handle_from_ip(rm_iface_ptr, &ipv6_addr);
        if (-1 == handle)
        {
          /* No match found, add to database */
          memset(&alloc_info, 0, sizeof(alloc_info));
          alloc_info.ip_addr.type    = IPV6_ADDR;
          alloc_info.ip_addr.addr.v6 = ipv6_addr;
          alloc_info.addr_type       = IPV6_ADDR_TYPE_EXTERNAL;
          if (-1 == ps_iface_addr_mgmt_alloc_unique_addr(rm_iface_ptr, 
                                                         &handle,
                                                         &alloc_info,
                                                         &ps_errno_addr_mgmt))
          {
            LOG_MSG_ERROR_1("Failed to add IPv6 addr to UM database. errno [%d]",
                                    ps_errno_addr_mgmt);
            /*Clean tlvs added till now.Send failure*/
            errval = QMI_ERR_INTERNAL_V01;
            goto send_result;
          }
          else
          {
            LOG_MSG_INFO2_0("Added IPv6 addr to UM database");
          }

          break;
        }
        else
        {
          IPV6_ADDR_MSG(ipv6_addr.ps_s6_addr64);
          /* Generate another address since there is a conflict */
          if (num_retry < 3)
          {
            LOG_MSG_INFO1_0("IPv6 addr already in database, re-generate IID");
            if (-1 == ps_iface_generate_ipv6_iid(um_iface_ptr, iid, &ps_errno_iid))
            {
              LOG_MSG_ERROR_0("Failed to generate a random IPv6 IID");
              errval = QMI_ERR_INTERNAL_V01;
              goto send_result;
            }
            num_retry++;
          }
          else
          {
            LOG_MSG_ERROR_1("Max retry [%d], give up writing to UM DB.",
                            num_retry);
            errval = QMI_ERR_INTERNAL_V01;
            goto send_result;
          }
        }
      } /* while */
      resp_msg->ipv6_addr_valid =  TRUE;
      resp_msg->ipv6_addr.ipv6_prefix_length = WDSI_IPV6_DEFAULT_PREFIX_LEN;
      memscpy(resp_msg->ipv6_addr.ipv6_addr,sizeof(resp_msg->ipv6_addr.ipv6_addr),
              ipv6_addr.ps_s6_addr64,sizeof(ipv6_addr.ps_s6_addr64));
        /* clear guard timer as IP address queried in QMI */
      rmnet_v6_sm_clear_guard_timer(wds_sp->binding.rmnet_inst);

    }

    if(req_settings & QMI_WDS_MASK_GATEWAY)
    {
      if(0 != rm_ipv6_addr.ps_s6_addr64[0])
      {
        resp_msg->ipv6_gateway_addr_valid = TRUE;
        resp_msg->ipv6_gateway_addr.ipv6_prefix_length = WDSI_IPV6_DEFAULT_PREFIX_LEN;
        memscpy(resp_msg->ipv6_gateway_addr.ipv6_addr,sizeof(resp_msg->ipv6_gateway_addr.ipv6_addr),
                rm_ipv6_addr.ps_s6_addr64,sizeof(rm_ipv6_addr.ps_s6_addr64));
      }
    }

    if(req_settings & QMI_WDS_MASK_DNS_ADDR)
    {
      if(0 != v6_pri_dns.addr.v6[0])
      {
        resp_msg->primary_dns_IPv6_address_valid = TRUE;
        memscpy(resp_msg->primary_dns_IPv6_address,sizeof(resp_msg->primary_dns_IPv6_address),
                v6_pri_dns.addr.v6,sizeof(v6_pri_dns.addr.v6));
      }
      else
      {
        LOG_MSG_INFO2_0("v6_pri_dns.addr.v6[0]=0, omitting TLV");
      }
      if(0 != v6_sec_dns.addr.v6[0])
      {
        resp_msg->secondary_dns_IPv6_address_valid = TRUE;
        memscpy(resp_msg->secondary_dns_IPv6_address,sizeof(resp_msg->secondary_dns_IPv6_address),
                v6_sec_dns.addr.v6,sizeof(v6_sec_dns.addr.v6));
      }
      else
      {
        LOG_MSG_INFO2_0("v6_sec_dns.addr.v6[0]=0, omitting TLV");
      }
    }
  }
#endif /* FEATURE_DATA_PS_IPV6 */

  send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_RUNTIME_SETTINGS_RESP_V01,
                               resp_msg,
                               sizeof(wds_get_runtime_settings_resp_msg_v01),
                               errval,
                               &response);
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  return response;
} /* qmi_wdsi_get_runtime_settings() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_INTERNAL_RUNTIME_SETTINGS()

  DESCRIPTION
    Retrive the current internal runtime settings of a 3GPP or 3GPP2 call

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_internal_runtime_settings
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *            wds_sp;
  dsm_item_type *                  response;
  wds_get_internal_runtime_settings_req_msg_v01 req_msg;
  wds_get_internal_runtime_settings_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
  int                return_val;
  int16             ps_errno;
  uint32             v_in_req_settings;
  dss_session_timer_type  session_timer_1x;
  dss_iface_ioctl_707_sdb_support_query_type sdb_support;
  unsigned int                     dorm_timer_1x = 0;
  boolean                          hdr_1x_handdown_opt = FALSE;
  int                              hat_timer = 0;
  ps_iface_rf_conditions_info_type rf_conds;
  ps_iface_ioctl_enable_hdr_slotted_mode hdr_sm;
  qmi_wdsi_client_state_type * client_sp;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
#define FILL_GET_OP_FAIL_TLV(BIT, ERROR) \
  resp_msg.operation_failure[resp_msg.operation_failure_len].bit_number = BIT; \
  resp_msg.operation_failure[resp_msg.operation_failure_len].error_value = ERROR; \
  resp_msg.operation_failure_len++;

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  /* Return all settings by default */
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  v_in_req_settings = WDSI_REQ_OPER_ALL_BITS;

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GET_INTERNAL_RUNTIME_SETTINGS_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  else
  {
    if(req_msg.requested_internal_settings_valid)
    {
      v_in_req_settings = req_msg.requested_internal_settings;
    }
  }
  /*-------------------------------------------------------------------------
    Check whether the call is up or not
  -------------------------------------------------------------------------*/
  if(wds_sp->is_mcast_inst == TRUE || wds_sp->is_embms_inst == TRUE)
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
    goto send_result;
  }

  if (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED)
  {
    LOG_MSG_INFO2_0("Not in a call, so no runtime profile available");
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  ASSERT (wds_sp->um_iface_ptr);

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
    LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    populate response with internal runtime settings
  -------------------------------------------------------------------------*/
  if(v_in_req_settings & (1 << QMI_WDSI_REQ_OPER_BIT6_SDB_SUPPORT))
  {
    if (FALSE == req_msg.flags_valid)
    {
      FILL_GET_OP_FAIL_TLV(QMI_WDSI_REQ_OPER_BIT6_SDB_SUPPORT,
                           DS_EINVAL);
    }
    else
    {
      sdb_support.flags = req_msg.flags;
      return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                  PS_IFACE_IOCTL_707_SDB_SUPPORT_QUERY,
                                  &sdb_support,
                                  &ps_errno);
      if (return_val == -1)
      {
        FILL_GET_OP_FAIL_TLV(QMI_WDSI_REQ_OPER_BIT6_SDB_SUPPORT, ps_errno);
      }
      else
      {
        resp_msg.sdb_support_valid = TRUE;
        resp_msg.sdb_support = sdb_support.can_do_sdb;
      }
    }
  }

  if(v_in_req_settings & (1 << QMI_WDSI_REQ_OPER_BIT5_HDR_EIDLE_SM_OPT))
  {
    memset(&hdr_sm, 0, sizeof(hdr_sm));
    hdr_sm.enable = 1;
    hdr_sm.get_slotted_mode = 1;
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_707_ENABLE_HDR_SLOTTED_MODE,
                                &hdr_sm,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_GET_OP_FAIL_TLV(QMI_WDSI_REQ_OPER_BIT5_HDR_EIDLE_SM_OPT, ps_errno);
    }
    else
    {
      resp_msg.slotted_mode_option_valid = TRUE;
      resp_msg.slotted_mode_option = hdr_sm.slotted_mode_option;
    }
  }

  if(v_in_req_settings & (1 << QMI_WDSI_REQ_OPER_BIT4_HYSTERISIS_ACTIVATION_TIMER))
  {
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_707_GET_HYSTERESIS_ACT_TIMER,
                                &hat_timer,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_GET_OP_FAIL_TLV(QMI_WDSI_REQ_OPER_BIT4_HYSTERISIS_ACTIVATION_TIMER,
                           ps_errno);
    }
    else
    {
      resp_msg.hysterisis_act_timer_valid =  TRUE;
      resp_msg.hysterisis_act_timer = hat_timer;
    }
  }

  if(v_in_req_settings & (1 << QMI_WDSI_REQ_OPER_BIT3_HDR_1X_HANDDOWN_OPT))
  {
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_707_GET_HDR_1X_HANDDOWN_OPTION,
                                &hdr_1x_handdown_opt,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_GET_OP_FAIL_TLV(QMI_WDSI_REQ_OPER_BIT3_HDR_1X_HANDDOWN_OPT,
                         ps_errno);
    }
    else
    {
      resp_msg.hdr_1x_handdown_option_valid = TRUE;
      resp_msg.hdr_1x_handdown_option = hdr_1x_handdown_opt;
      }
    }
  if(v_in_req_settings & (1 << QMI_WDSI_REQ_OPER_BIT2_1X_SESSION_TIMER))
  {
    if (FALSE == req_msg.timer_select_valid)
    {
      FILL_GET_OP_FAIL_TLV(QMI_WDSI_REQ_OPER_BIT2_1X_SESSION_TIMER,
                           DS_EINVAL);
    }
    else
    {
      session_timer_1x.timer_select = req_msg.timer_select;
      return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                  PS_IFACE_IOCTL_GET_SESSION_TIMER,
                                  &session_timer_1x,
                                  &ps_errno);
      if (return_val == -1)
      {
        FILL_GET_OP_FAIL_TLV(QMI_WDSI_REQ_OPER_BIT2_1X_SESSION_TIMER, ps_errno);
      }
      else
      {
        resp_msg.session_timer_value_valid = TRUE;
        resp_msg.session_timer_value = session_timer_1x.timer_val;
      }
    }
  }

  if(v_in_req_settings & (1 << QMI_WDSI_REQ_OPER_BIT1_1X_DORM_TIMER))
  {
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_707_GET_DORM_TIMER,
                                &dorm_timer_1x,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_GET_OP_FAIL_TLV(QMI_WDSI_REQ_OPER_BIT1_1X_DORM_TIMER, ps_errno);
    }
    else
    {
      resp_msg.dorm_timer_valid = TRUE;
      resp_msg.dorm_timer = dorm_timer_1x;
    }
  }

  if(v_in_req_settings & (1 << QMI_WDSI_REQ_OPER_BIT0_RF_CONDITIONS))
  {
    memset(&rf_conds, 0, sizeof(rf_conds));
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_GET_RF_CONDITIONS,
                                &rf_conds,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_GET_OP_FAIL_TLV(QMI_WDSI_REQ_OPER_BIT0_RF_CONDITIONS, ps_errno);
    }
    else
    {
      resp_msg.rf_conditions_valid = TRUE;
      if ((rf_conds.bearer_tech.current_network > PS_IFACE_NETWORK_MIN) &&
          (rf_conds.bearer_tech.current_network < PS_IFACE_NETWORK_MAX))
      {
        resp_msg.rf_conditions.db_current_nw = (wds_current_nw_enum_v01)
                                                rf_conds.bearer_tech.current_network;
      }
      if (resp_msg.rf_conditions.db_current_nw == PS_IFACE_NETWORK_CDMA)
      {
        resp_msg.rf_conditions.db_rat_mask =
                                rf_conds.bearer_tech.data.cdma_type.rat_mask;
        /*-------------------------------------------------------------------------
          if rat_mask is PS_IFACE_CDMA_EVDO_REV0 or PS_IFACE_CDMA_NULL_BEARER ,
          then ignoring the so_mask from any garbage values.
        -------------------------------------------------------------------------*/
        if ( (resp_msg.rf_conditions.db_rat_mask != PS_IFACE_CDMA_EVDO_REV0) && 
             (resp_msg.rf_conditions.db_rat_mask != PS_IFACE_CDMA_NULL_BEARER) )
        {
          resp_msg.rf_conditions.db_so_mask  =
                                 rf_conds.bearer_tech.data.cdma_type.so_mask;
        }
      }
      else if (resp_msg.rf_conditions.db_current_nw == PS_IFACE_NETWORK_UMTS)
      {
        resp_msg.rf_conditions.db_rat_mask  =
                                rf_conds.bearer_tech.data.umts_type.rat_mask;
      }
      resp_msg.rf_conditions.rf_cond = (wds_rf_conditions_enum_v01)rf_conds.rf_conditions;
    }
  }

  if (resp_msg.operation_failure_len > 0)
  {
    errval = QMI_ERR_OP_PARTIAL_FAILURE_V01;
    ASSERT (resp_msg.operation_failure_len <=
            QMI_WDS_MAX_RUNTIME_SETTINGS_FAILURES_V01);
    resp_msg.operation_failure_valid = TRUE;
  }

  send_result:
    QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_INTERNAL_RUNTIME_SETTINGS_RESP_V01,
                                 &resp_msg,
                                 sizeof(resp_msg),
                                 errval,
                                 &response);
    return response;
} /* qmi_wdsi_get_internal_runtime_settings() */

/*===========================================================================
  FUNCTION QMI_WDSI_SET_INTERNAL_RUNTIME_SETTINGS()

  DESCRIPTION
    Set the internal runtime settings of a 3GPP or 3GPP2 call

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_internal_runtime_settings
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *            wds_sp;
  dsm_item_type *                  response;
  wds_set_internal_runtime_settings_req_msg_v01 req_msg;
  wds_set_internal_runtime_settings_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
  int                return_val;
  int16             ps_errno;
  dss_session_timer_type           session_timer_1x;
  ps_iface_ioctl_enable_hdr_slotted_mode hdr_sm;
  qmi_wdsi_client_state_type * client_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#define FILL_SET_OP_FAIL_TLV(TYPE, ERROR) \
  resp_msg.operation_failure[resp_msg.operation_failure_len].tlv_type = TYPE; \
  resp_msg.operation_failure[resp_msg.operation_failure_len].error_value = ERROR; \
  resp_msg.operation_failure_len++

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  response = NULL;
  errval = QMI_ERR_NONE_V01;

  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_INTERNAL_RUNTIME_SETTINGS_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
      goto send_result;
  }
  /*-------------------------------------------------------------------------
    If ALL optional TLVs are absent return error or else carry on and
    process the request. (Needed since NO mandatory TLVs)
  -------------------------------------------------------------------------*/
  if ( !(req_msg.dorm_timer_valid || req_msg.session_timer_valid ||
         req_msg.hdr_1x_handdown_option_valid || req_msg.hysterisis_act_timer_valid ||
         req_msg.enable_1x_holddown_valid || req_msg.enable_hdr_hpt_valid ||
         req_msg.enable_hdr_rev0_rate_inertia_valid || req_msg.slotted_mode_option_valid ) )
  {
    errval = QMI_ERR_MISSING_ARG_V01;
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    Check whether the call is up or not
  -------------------------------------------------------------------------*/
  if(wds_sp->is_mcast_inst == TRUE || wds_sp->is_embms_inst == TRUE)
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
    goto send_result;
  }

  if (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED)
  {
    LOG_MSG_INFO2_0("Not in a call, so cannot set internal runtime settings");
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  ASSERT (wds_sp->um_iface_ptr);

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
    LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    Perform requested operation.
    If operation fails, populate operation failure tlv
  -------------------------------------------------------------------------*/
  if ( req_msg.enable_1x_holddown_valid )
  {
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_707_ENABLE_HOLDDOWN,
                                &req_msg.enable_1x_holddown,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_SET_OP_FAIL_TLV(WDSI_PRM_TYPE_SET_HOLDDOWN, ps_errno);
    }
  }

  if ( req_msg.dorm_timer_valid)
  {
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_707_SET_DORM_TIMER,
                                &req_msg.dorm_timer,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_SET_OP_FAIL_TLV(WDSI_PRM_TYPE_SET_1X_DORM_TIMER, ps_errno);
    }
  }

  if ( req_msg.session_timer_valid )
  {
    session_timer_1x.timer_select = req_msg.session_timer.timer_select;
    session_timer_1x.timer_val = req_msg.session_timer.timer_val;
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_SET_SESSION_TIMER,
                                &session_timer_1x,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_SET_OP_FAIL_TLV(WDSI_PRM_TYPE_SET_1X_SESSION_TIMER, ps_errno);
    }
  }

  if ( req_msg.hdr_1x_handdown_option_valid )
  {
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_707_SET_HDR_1X_HANDDOWN_OPTION,
                                &req_msg.hdr_1x_handdown_option,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_SET_OP_FAIL_TLV(WDSI_PRM_TYPE_SET_HDR_1X_HANDDOWN_OPT, ps_errno);
    }
  }

  if ( req_msg.hysterisis_act_timer_valid )
  {
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_707_SET_HYSTERESIS_ACT_TIMER,
                                &req_msg.hysterisis_act_timer,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_SET_OP_FAIL_TLV(WDSI_PRM_TYPE_SET_HYSTERISIS_ACTIVATION_TIMER, ps_errno);
    }
  }

  if ( req_msg.slotted_mode_option_valid  )
  {
    hdr_sm.enable = 1;
    hdr_sm.get_slotted_mode = 0;
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_707_ENABLE_HDR_SLOTTED_MODE,
                                &hdr_sm,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_SET_OP_FAIL_TLV(WDSI_PRM_TYPE_SET_HDR_SLOT_CYCLE_INDEX, ps_errno);
    }
  }

  if ( req_msg.enable_hdr_hpt_valid )
  {
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_707_ENABLE_HDR_HPT_MODE,
                                &req_msg.enable_hdr_hpt,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_SET_OP_FAIL_TLV(WDSI_PRM_TYPE_SET_HDR_HPT, ps_errno);
    }
  }

  if ( req_msg.enable_hdr_rev0_rate_inertia_valid)
  {
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_707_ENABLE_HDR_REV0_RATE_INERTIA,
                                &req_msg.enable_hdr_rev0_rate_inertia,
                                &ps_errno);
    if (return_val == -1)
    {
      FILL_SET_OP_FAIL_TLV(WDSI_PRM_TYPE_SET_HDR_REV0_RATE_INERTIA, ps_errno);
    }
  }

  if (resp_msg.operation_failure_len > 0)
  {
    errval = QMI_ERR_OP_PARTIAL_FAILURE_V01;
    ASSERT (resp_msg.operation_failure_len <=
            QMI_WDS_MAX_RUNTIME_SETTINGS_FAILURES_V01);
    resp_msg.operation_failure_valid = TRUE;
  }

  send_result:
    QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_INTERNAL_RUNTIME_SETTINGS_RESP_V01,
                                 &resp_msg,
                                 sizeof(resp_msg),
                                 errval,
                                 &response);
    return response;
} /* qmi_wdsi_set_internal_runtime_settings() */

#if (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && (defined(FEATURE_DS_MOBILE_IP))
#if defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE)
#ifdef FEATURE_MMGSDI_SESSION_LIB

/*===========================================================================
  FUNCTION QMI_WDSI_CHECK_UIM_ACCESS_STATUS()

  DESCRIPTION
   If RUIM/CSIM card being used, checks whether the UIM can be read from by
   checking for UIM state and PIN1 status

  PARAMETERS
    None

  RETURN VALUE
    QMI_ERR_NONE_V01: UIM present and unlocked
    QMI_ERR_SIM_NOT_INITIALIZED_V01: If the UIM is not initialized yet
    QMI_ERR_PIN_BLOCKED_V01: If PIN1 is blocked
    QMI_ERR_PIN_PERM_BLOCKED_V01: If PIN1 is permanently blocked

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_type_v01 qmi_wdsi_check_uim_access_status
(
  void
)
{
  qmi_error_type_v01   errval = QMI_ERR_NONE_V01;

  if (NV_RTRE_CONTROL_USE_RUIM == nv_rtre_control()) 
  {  

    /* sending as primary subs as it is the default subs. need to change this when WDS service is 
       made subscription specific
    */
    if ((errval = (qmi_error_type_v01)qmi_dms_get_uim_access_status_ext(MMGSDI_1X_PROV_PRI_SESSION)) != QMI_ERR_NONE_V01)
    {
      LOG_MSG_INFO1_1("RUIM not initialized (%d)", errval);
    }
    else
    {
      /*
      qmi_pin_status_enum_type pin1_status = QMI_PIN_STATUS_MIN;
      pin1_status = qmi_dms_get_pin1_status();
      LOG_MSG_INFO1_1("PIN1 status is (%d)", pin1_status);
      switch (pin1_status)
      {
      case QMI_PIN_BLOCKED:
        errval = QMI_ERR_PIN_BLOCKED_V01;
        break;
      case QMI_PIN_PERM_BLOCKED:
        errval = QMI_ERR_PIN_PERM_BLOCKED_V01;
        break;
      case QMI_PIN_ENABLED_NOT_VERIFIED:
        errval = QMI_ERR_SIM_NOT_INITIALIZED_V01;
        break;
      default:
        break;
      }
      */
    }
  }
  return errval;
} /* qmi_wdsi_check_uim_access_status */
#endif /* FEATURE_MMGSDI_SESSION_LIB */
#endif /* defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */
#endif /* (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && (defined(FEATURE_DS_MOBILE_IP))*/
/*===========================================================================
  FUNCTION QMI_WDSI_SET_MIP_MODE()

  DESCRIPTION
   Sets the MIP mode

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_mip_mode
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_set_mip_mode_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;

#if (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && (defined(FEATURE_DS_MOBILE_IP))
  nv_stat_enum_type  status;
  nv_item_type      *dcc_nv_item_ptr;
  uint8              temp_mip_val = 0;
  wds_set_mip_mode_req_msg_v01 req_msg;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */


/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response          = NULL;
  errval            = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
#if (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && (defined(FEATURE_DS_MOBILE_IP))
  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC(dcc_nv_item_ptr, sizeof(nv_item_type),
                            nv_item_type*);
  if( dcc_nv_item_ptr == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    goto send_result;
  }
  memset(&req_msg,0,sizeof(req_msg));
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_MIP_MODE_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

#if defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE)
#ifdef FEATURE_MMGSDI_SESSION_LIB
  /*-------------------------------------------------------------------------
    If RUIM/CSIM is being used, MIP mode cannot be set unless the UIM is
    unlocked. Check the UIM state and return QMI_ERR_SIM_NOT_INITIALIZED_V01 if 
    the state is not initialized. Also check PIN1 status
  -------------------------------------------------------------------------*/
  if ((errval = qmi_wdsi_check_uim_access_status()) != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
#endif /* FEATURE_MMGSDI_SESSION_LIB */
#endif /* defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */

  (void) dsmip_get_1x_profile_val_num(DS_QCMIP_VAL,(void *)&temp_mip_val,0);
  if ( (uint8)req_msg.mip_mode == (byte)temp_mip_val )
  {
    errval = QMI_ERR_NO_EFFECT_V01;
    goto send_result;
  }

  if ( WDSI_MIP_SETTING_MODE_MAX < req_msg.mip_mode)
  {
    LOG_MSG_INFO2_1 ("Invalid MIP Mode received (%d)", req_msg.mip_mode);
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  LOG_MSG_INFO2_1 ("Got Set MIP Mode Req , mip_mode to be set as  %d",
                   req_msg.mip_mode);

  /* Update MIP settings */
  ds_qcmip_set_val(req_msg.mip_mode);


  /*-----------------------------------------------------------------------
      Modify AT$QCMDR and AT+CRM values to reflect QCMIP setting
  -----------------------------------------------------------------------*/
  ds707_pkt_mgr_qcmip_set_mdr_val();
  ds707_pkt_mgr_qcmip_set_crm_val();

  /*-----------------------------------------------------------------------
    Recalculate 1x service option table
  -----------------------------------------------------------------------*/
  ds707_so_pkt_recal();

  /*-----------------------------------------------------------------------
    Write QCMIP value into NV
  -----------------------------------------------------------------------*/
  dcc_nv_item_ptr->ds_qcmip = req_msg.mip_mode;

  status = dcc_put_nv_item( NV_DS_QCMIP_I, dcc_nv_item_ptr );

  if (status != NV_DONE_S)
  {
    errval =  QMI_ERR_INTERNAL_V01;
  }

send_result:
  /*-------------------------------------------------------------------------
    Free the temporary memory allocated for NV item.
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);

#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;

#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)  
          && defined(FEATURE_DS_MOBILE_IP)*/
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_MIP_MODE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_mip_mode() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_MIP_MODE()

  DESCRIPTION
    Retrive the current MIP mode

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_mip_mode
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_get_mip_mode_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
#if (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && (defined(FEATURE_DS_MOBILE_IP))
#if defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE)
#ifdef FEATURE_MMGSDI_SESSION_LIB
  /*-------------------------------------------------------------------------
    If RUIM/CSIM is being used, MIP mode cannot be read unless the UIM is
    unlocked. Check the UIM state and return QMI_ERR_SIM_NOT_INITIALIZED_V01 if 
    the state is not initialized. Also check PIN1 status
    -------------------------------------------------------------------------*/
  if ((errval = qmi_wdsi_check_uim_access_status()) != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
#endif /* FEATURE_MMGSDI_SESSION_LIB */
#endif /* defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */

  /* Get MIP Mode */

  (void) dsmip_get_1x_profile_val_num(DS_QCMIP_VAL,(void *)&resp_msg.mip_mode,0);

#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */


#if (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && (defined(FEATURE_DS_MOBILE_IP))
#if defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE)
#ifdef FEATURE_MMGSDI_SESSION_LIB
send_result:

#endif /* FEATURE_MMGSDI_SESSION_LIB */
#endif /* defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_MIP_MODE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_mip_mode() */


#ifdef FEATURE_DATA_QMI_MCAST
/*This function will removed as part of MCAST feature removal.so not converting it*/
/*===========================================================================
  FUNCTION QMI_WDSI_MCAST_STATUS_IND()

  DESCRIPTION
    Sends an indication to the client to report mcast status.

  PARAMETERS
    sp          : service provided state pointer
    cl_sp       : client provided state pointer
    cmd
    mcast_handle
    mcast_status
    info_code

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_mcast_status_ind
(
  qmi_wdsi_state_type  *              wds_sp,
  qmi_wdsi_client_state_type *        cl_sp,
  qmi_wdsi_cmd_val_e_type             cmd,
  uint32                              mcast_handle,
  uint8                               mcast_status,
  ps_iface_mcast_info_code_enum_type  info_code
)
{
  dsm_item_type *               ind;
  struct
  {
    uint32 mcast_handle;
    uint8  mcast_status;
  } v_out_reqd;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    Build indication from the back to the front
  -------------------------------------------------------------------------*/
  ind = NULL;
  LOG_MSG_INFO2_2 ("Sending mcast_status (%d) ind for handle %d",
                   mcast_status, mcast_handle);

  v_out_reqd.mcast_handle = mcast_handle;
  v_out_reqd.mcast_status = mcast_status;

  if(info_code != PS_IFACE_MCAST_IC_NOT_SPECIFIED)
  {
    if(FALSE == qmi_svc_put_param_tlv(&ind,
                                      WDSI_PRM_TYPE_MCAST_REASON_CODE,
                                      sizeof(uint8),
                                      &info_code))
    {
      dsm_free_packet(&ind);
    }
  }

  if(FALSE == qmi_svc_put_param_tlv(&ind,
                                    QMI_TYPE_REQUIRED_PARAMETERS,
                                    5, //sizeof(v_out_reqd),
                                    &v_out_reqd))
  {
    dsm_free_packet(&ind);
    return;
  }
  /*ind size will be zero incase of no encoding needed*/
  (void)qmi_wdsi_send_ind( wds_sp, cl_sp, cmd, 0, ind ,FALSE);
} /* qmi_wdsi_mcast_status_ind() */
#endif /* FEATURE_DATA_QMI_MCAST */

/*===========================================================================
  FUNCTION WDSI_GET_CURR_DATA_BEARER_TECH()

  DESCRIPTION
    Return the current data bearer technology based on the
    ps_iface_bearer_technology_type.

  PARAMETERS
    bearer_tech_info - Bearer tech info obtained from event info or ioctl

  RETURN VALUE
    qmi_wdsi_curr_data_bearer_tech_type

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_wdsi_curr_data_bearer_tech_type wdsi_get_curr_data_bearer_tech
(
  ps_iface_bearer_technology_type bearer_tech_info
)
{
  qmi_wdsi_curr_data_bearer_tech_type curr_data_bearer_tech;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset((void *)&curr_data_bearer_tech, 0, sizeof(curr_data_bearer_tech));
  if ((bearer_tech_info.current_network > PS_IFACE_NETWORK_MIN) &&
      (bearer_tech_info.current_network < PS_IFACE_NETWORK_MAX))
  {
    LOG_MSG_INFO2_1("current network %d", bearer_tech_info.current_network);
    curr_data_bearer_tech.current_nw = bearer_tech_info.current_network;
  }
  else
  {
    LOG_MSG_INFO1_1("invalid current network %d",
                    bearer_tech_info.current_network);
  }
  if (curr_data_bearer_tech.current_nw == PS_IFACE_NETWORK_CDMA)
  {
    curr_data_bearer_tech.rat_mask =
                                    bearer_tech_info.data.cdma_type.rat_mask;
    /*-------------------------------------------------------------------------
      if rat_mask is PS_IFACE_CDMA_EVDO_REV0 or PS_IFACE_CDMA_NULL_BEARER ,
      then ignoring the so_mask from any garbage values.
    -------------------------------------------------------------------------*/
    if ( (curr_data_bearer_tech.rat_mask != PS_IFACE_CDMA_EVDO_REV0) && 
         (curr_data_bearer_tech.rat_mask != PS_IFACE_CDMA_NULL_BEARER) )
    {
      curr_data_bearer_tech.so_mask =
                                     bearer_tech_info.data.cdma_type.so_mask;
    }
  }
  else if (curr_data_bearer_tech.current_nw == PS_IFACE_NETWORK_UMTS)
  {
    curr_data_bearer_tech.rat_mask =
                                    bearer_tech_info.data.umts_type.rat_mask;
  }
  LOG_MSG_INFO2_3("current bearer tech nw%d rat %d, so%d",
                  curr_data_bearer_tech.current_nw,
                  curr_data_bearer_tech.rat_mask,
                  curr_data_bearer_tech.so_mask );
  return curr_data_bearer_tech;
} /* wdsi_get_curr_data_bearer_tech() */


/*===========================================================================
  FUNCTION WDSI_GET_DATA_BEARER_TECH()

  DESCRIPTION
    Return the data bearer technology based on the
    qmi_wdsi_curr_data_bearer_tech_type.

  PARAMETERS
    bearer_tech_info - Bearer tech info obtained from event info or ioctl

  RETURN VALUE
    wds_data_bearer_technology

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_wds_bearer_tech_e_type wdsi_get_data_bearer_tech
(
  qmi_wdsi_curr_data_bearer_tech_type bearer_tech_info
)
{
  qmi_wds_bearer_tech_e_type data_bearer_technology;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch (bearer_tech_info.current_nw)
  {
    case PS_IFACE_NETWORK_CDMA:
    {
      switch ( bearer_tech_info.rat_mask )
      {
        case PS_IFACE_CDMA_1X:
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_CDMA20001x;
          break;
        }
        case PS_IFACE_CDMA_EVDO_REVA:
        {
          if ( bearer_tech_info.so_mask & PS_IFACE_CDMA_EVDO_EMPA_EHRPD) 
          {
            data_bearer_technology = QMI_WDS_BEARER_TECH_CDMA_EVDO_EHRPD;
          }
          else
          {
            data_bearer_technology = QMI_WDS_BEARER_TECH_CDMA_EVDO_REVA;
          }
          break;
        }
        case PS_IFACE_CDMA_EVDO_REV0:
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_CDMA_EVDO_REV0;
          break;
        }
        case PS_IFACE_CDMA_NULL_BEARER:
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_NULL;
          break;
        }
        default:
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_UNKNOWN;
          break;
        }
      }; /* switch (bearer_tech_info.data.cdma_type.rat_mask) */
      break;
    }

    case PS_IFACE_NETWORK_UMTS:
    {
      switch ( bearer_tech_info.rat_mask )
      {
        case PS_IFACE_UMTS_GPRS:
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_GPRS;
          break;
        }
        case PS_IFACE_UMTS_EDGE:
        {
          if (!qmi_if_edge_supported())
          {
            /* EDGE is disabled by runtime config, so return GPRS */
            data_bearer_technology = QMI_WDS_BEARER_TECH_GPRS;
          }
          else
          {
            data_bearer_technology = QMI_WDS_BEARER_TECH_EDGE;
          }
          break;
        }
        case PS_IFACE_UMTS_WCDMA:
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_UMTS;
          break;
        }
        case (PS_IFACE_UMTS_HSDPA | PS_IFACE_UMTS_WCDMA):
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_HSDPA_WCDMA;
          break;
        }
        case (PS_IFACE_UMTS_WCDMA | PS_IFACE_UMTS_HSUPA):
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_WCDMA_HSUPA;
          break;
        }
        case (PS_IFACE_UMTS_HSDPA | PS_IFACE_UMTS_HSUPA):
        case (PS_IFACE_UMTS_HSDPA | PS_IFACE_UMTS_HSUPA | PS_IFACE_UMTS_WCDMA):
        case (PS_IFACE_UMTS_HSDPA | PS_IFACE_UMTS_HSUPA | PS_IFACE_3GPP_TDSCDMA):
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_HSDPA_HSUPA;
          break;
        }
        case (PS_IFACE_3GPP_HSDPAPLUS | PS_IFACE_UMTS_WCDMA):
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_HSDPAPLUS_WCDMA;
          break;
        }
        case (PS_IFACE_3GPP_HSDPAPLUS | PS_IFACE_UMTS_HSUPA):
        case (PS_IFACE_3GPP_HSDPAPLUS | PS_IFACE_UMTS_HSUPA |PS_IFACE_UMTS_WCDMA):
        case (PS_IFACE_3GPP_HSDPAPLUS | PS_IFACE_UMTS_HSUPA |PS_IFACE_3GPP_TDSCDMA):
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_HSDPAPLUS_HSUPA;
          break;
        }
        case (PS_IFACE_3GPP_HSDPAPLUS | PS_IFACE_3GPP_64_QAM | PS_IFACE_UMTS_WCDMA):
        case (PS_IFACE_3GPP_HSDPAPLUS | PS_IFACE_3GPP_64_QAM | PS_IFACE_3GPP_TDSCDMA):
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_HSDPAPLUS_64QAM;
          break;
        }
        case (PS_IFACE_3GPP_HSDPAPLUS | PS_IFACE_3GPP_64_QAM | PS_IFACE_UMTS_HSUPA):
        case (PS_IFACE_3GPP_HSDPAPLUS | PS_IFACE_3GPP_64_QAM | PS_IFACE_UMTS_HSUPA | 
                                        PS_IFACE_UMTS_WCDMA):
        case (PS_IFACE_3GPP_HSDPAPLUS | PS_IFACE_3GPP_64_QAM | 
                                        PS_IFACE_UMTS_HSUPA | PS_IFACE_3GPP_TDSCDMA):
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_HSDPAPLUS_64QAM_HSUPA;
          break;
        }
        case (PS_IFACE_3GPP_DC_HSDPAPLUS | PS_IFACE_UMTS_WCDMA):
        case (PS_IFACE_3GPP_DC_HSDPAPLUS | PS_IFACE_3GPP_TDSCDMA):
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_DCHSDPAPLUS_WCDMA;
          break;
        }
        case (PS_IFACE_3GPP_DC_HSDPAPLUS | PS_IFACE_UMTS_HSUPA):
        case (PS_IFACE_3GPP_DC_HSDPAPLUS | PS_IFACE_UMTS_HSUPA | PS_IFACE_UMTS_WCDMA):
        case (PS_IFACE_3GPP_DC_HSDPAPLUS | PS_IFACE_UMTS_HSUPA | PS_IFACE_3GPP_TDSCDMA):
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_DCHSDPAPLUS_HSUPA;
          break;
        }
        case PS_IFACE_3GPP_LTE:
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_LTE;
          break;
        }
        case PS_IFACE_3GPP_TDSCDMA:
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_TDSCDMA;
          break;
        }
        case (PS_IFACE_3GPP_TDSCDMA | PS_IFACE_UMTS_HSDPA):
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_TDSCDMA_HSDPA;
          break;
        }
        case (PS_IFACE_3GPP_TDSCDMA | PS_IFACE_UMTS_HSUPA):
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_TDSCDMA_HSUPA;
          break;
        }
        case PS_IFACE_3GPP_NULL_BEARER:
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_NULL;
          break;
        }
        default:
        {
          data_bearer_technology = QMI_WDS_BEARER_TECH_UNKNOWN;
          LOG_MSG_INFO1_1 ("Invalid rat mask (=0x%x)!",
                           bearer_tech_info.rat_mask);
          break;
        }
      }; /* switch (bearer_tech_info.data.cdma_type.rat_mask) */
      break;
    }

    default:
    {
      data_bearer_technology = QMI_WDS_BEARER_TECH_UNKNOWN;
      LOG_MSG_ERROR_1 ("Invalid current network (=%d)!",
                       bearer_tech_info.current_nw);
      break;
    }
  }; /* switch (bearer_tech_info) */

  return data_bearer_technology;

} /* wdsi_get_data_bearer_tech() */

#ifndef FEATURE_DATA_WLAN_MAPCON
/*===========================================================================
  FUNCTION WDSI_DATA_BEARER_TECH_IS_VALID()

  DESCRIPTION
    Return the data bearer technology based on the
    qmi_wdsi_curr_data_bearer_tech_type.

  PARAMETERS
    bearer_tech_info - Bearer tech info obtained from event info or ioctl

  RETURN VALUE
    wds_data_bearer_technology

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean wdsi_data_bearer_tech_is_valid
(
  qmi_wdsi_curr_data_bearer_tech_type bearer_tech_info
)
{
  boolean  is_valid = TRUE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch (bearer_tech_info.current_nw)
  {
    case PS_IFACE_NETWORK_CDMA:
    {
      switch ( bearer_tech_info.rat_mask )
      {
        case PS_IFACE_CDMA_NULL_BEARER:
        {
          is_valid = FALSE;
          break;
        }

        default:
        break;
      };
    }

    case PS_IFACE_NETWORK_UMTS:
    {
      switch ( bearer_tech_info.rat_mask )
      {
        case PS_IFACE_3GPP_NULL_BEARER:
        {
          is_valid = FALSE;
          break;
        }

        default:
        break;
      };
      break;
    }

    default:
    {
      is_valid = FALSE;
      break;
    }
  }; /* switch (bearer_tech_info) */

  return is_valid;

} /* wdsi_get_data_bearer_tech_is_valid() */
#endif /* FEATURE_DATA_WLAN_MAPCON */

#ifdef FEATURE_DATA_WLAN_MAPCON
/*===========================================================================
  FUNCTION WDSI_GET_CURRENT_DATA_BEARER_TECH()

  DESCRIPTION
    This function converts the data bearer technology information which is in
    ds_sys_system_status_info_type format to qmi_wdsi_curr_data_bearer_tech_type
    format.

  PARAMETERS
    bearer_tech_ex_info - Bearer tech info obtained from event info or ioctl

  RETURN VALUE
    data_bearer_technology

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_get_current_data_bearer_tech
(
  ds_sys_system_status_info_type bearer_tech_ex_info,
  qmi_wdsi_curr_data_bearer_tech_type * data_bearer_technology
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(data_bearer_technology, 0, sizeof(qmi_wdsi_curr_data_bearer_tech_type));
  switch (bearer_tech_ex_info.technology)
  {
    case DS_SYS_NETWORK_3GPP:
    {
      data_bearer_technology->current_nw = PS_IFACE_NETWORK_UMTS;

      switch ( bearer_tech_ex_info.rat_value )
      {
        case DS_SYS_RAT_EX_NULL_BEARER:
        {
          data_bearer_technology->rat_mask |= PS_IFACE_3GPP_NULL_BEARER;
          break;
        }
        case DS_SYS_RAT_EX_3GPP_WCDMA:
        case DS_SYS_RAT_EX_3GPP_TDSCDMA:
        {
          data_bearer_technology->rat_mask = 
            (bearer_tech_ex_info.rat_value == DS_SYS_RAT_EX_3GPP_WCDMA) ? 
            PS_IFACE_3GPP_WCDMA : PS_IFACE_3GPP_TDSCDMA;
          if (bearer_tech_ex_info.so_mask & DS_SYS_SO_EX_3GPP_HSDPA)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_3GPP_HSDPA;
          }
          if (bearer_tech_ex_info.so_mask & DS_SYS_SO_EX_3GPP_HSUPA)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_3GPP_HSUPA;
          }
          if (bearer_tech_ex_info.so_mask & DS_SYS_SO_EX_3GPP_HSDPAPLUS)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_3GPP_HSDPAPLUS;
          }
          if (bearer_tech_ex_info.so_mask & DS_SYS_SO_EX_3GPP_DC_HSDPAPLUS)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_3GPP_DC_HSDPAPLUS;
          }
          if (bearer_tech_ex_info.so_mask & DS_SYS_SO_EX_3GPP_64_QAM)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_3GPP_64_QAM;
          }
          break;
        }
        case DS_SYS_RAT_EX_3GPP_GERAN:
        {
          if (bearer_tech_ex_info.so_mask & DS_SYS_SO_EX_3GPP_GPRS)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_3GPP_GPRS;
          }
          else if (bearer_tech_ex_info.so_mask & DS_SYS_SO_EX_3GPP_EDGE)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_3GPP_EDGE;
          }
          else
          {
            data_bearer_technology->rat_mask |= PS_IFACE_3GPP_NULL_BEARER;
          }
          break;
        }
        case DS_SYS_RAT_EX_3GPP_LTE:
        {
          data_bearer_technology->rat_mask |= PS_IFACE_3GPP_LTE;
          break;
        }
        case DS_SYS_RAT_EX_3GPP_WLAN: //Not handled
        default:
        {
          data_bearer_technology->current_nw = PS_IFACE_NETWORK_MIN;
          break;
        }
      }; /* switch (bearer_tech_info_ex.rat_value) */
      break;
    } /* case DS_SYS_NETWORK_3GPP */

    case DS_SYS_NETWORK_3GPP2:
    {
      data_bearer_technology->current_nw = PS_IFACE_NETWORK_CDMA;
      switch ( bearer_tech_ex_info.rat_value )
      {
        case DS_SYS_RAT_EX_NULL_BEARER:
        {
          data_bearer_technology->rat_mask |= PS_IFACE_CDMA_NULL_BEARER;
          break;
        }

        case DS_SYS_RAT_EX_3GPP2_1X:
        {
          data_bearer_technology->rat_mask |= PS_IFACE_CDMA_1X;
          if (bearer_tech_ex_info.so_mask == DS_SYS_SO_EX_3GPP2_1X_IS95)
          {
            data_bearer_technology->so_mask = PS_IFACE_CDMA_1X_IS95;
          }
          else if (bearer_tech_ex_info.so_mask == DS_SYS_SO_EX_3GPP2_1X_IS2000_REL_A)
          {
            data_bearer_technology->so_mask = PS_IFACE_CDMA_1X_IS2000_REL_A;
          }
          else if(bearer_tech_ex_info.so_mask == DS_SYS_SO_EX_3GPP2_1X_IS2000)
          {
            data_bearer_technology->so_mask = PS_IFACE_CDMA_1X_IS2000;
          }
          break;
        }

        case DS_SYS_RAT_EX_3GPP2_HRPD:
        case DS_SYS_RAT_EX_3GPP2_EHRPD:
        {
          if (bearer_tech_ex_info.so_mask == DS_SYS_SO_EX_3GPP2_HDR_REV0_DPA)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_CDMA_EVDO_REV0;
            data_bearer_technology->so_mask = PS_IFACE_CDMA_EVDO_DPA;
          }
          else if( bearer_tech_ex_info.so_mask == DS_SYS_SO_EX_3GPP2_HDR_REVA_DPA ) 
          {
            data_bearer_technology->rat_mask |= PS_IFACE_CDMA_EVDO_REVA;
            data_bearer_technology->so_mask = PS_IFACE_CDMA_EVDO_DPA;
          }
          else if(bearer_tech_ex_info.so_mask == DS_SYS_SO_EX_3GPP2_HDR_REVB_DPA)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_CDMA_EVDO_REVB;
            data_bearer_technology->so_mask = PS_IFACE_CDMA_EVDO_DPA;
          }
          else if(bearer_tech_ex_info.so_mask == DS_SYS_SO_EX_3GPP2_HDR_REVA_MPA)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_CDMA_EVDO_REVA;
            data_bearer_technology->so_mask = PS_IFACE_CDMA_EVDO_MFPA;
          }
          else if(bearer_tech_ex_info.so_mask == DS_SYS_SO_EX_3GPP2_HDR_REVB_MPA)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_CDMA_EVDO_REVB;
            data_bearer_technology->so_mask = PS_IFACE_CDMA_EVDO_MFPA;
          }
          else if(bearer_tech_ex_info.so_mask == DS_SYS_SO_EX_3GPP2_HDR_REVA_EMPA)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_CDMA_EVDO_REVA;
            if(bearer_tech_ex_info.rat_value == DS_SYS_RAT_EX_3GPP2_EHRPD)
            {
              data_bearer_technology->so_mask = PS_IFACE_CDMA_EVDO_EMPA_EHRPD;
            }
            else
            {
              data_bearer_technology->so_mask = PS_IFACE_CDMA_EVDO_EMPA;
            }
          }
          else if(bearer_tech_ex_info.so_mask == DS_SYS_SO_EX_3GPP2_HDR_REVB_EMPA)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_CDMA_EVDO_REVB;
            if(bearer_tech_ex_info.rat_value == DS_SYS_RAT_EX_3GPP2_EHRPD)
            {
              data_bearer_technology->so_mask = PS_IFACE_CDMA_EVDO_EMPA_EHRPD;
            }
            else
            {
              data_bearer_technology->so_mask = PS_IFACE_CDMA_EVDO_EMPA;
            }
          }
          else if(bearer_tech_ex_info.so_mask == DS_SYS_SO_EX_3GPP2_HDR_REVB_MMPA)
          {
            data_bearer_technology->rat_mask |= PS_IFACE_CDMA_EVDO_REVB;
            if(bearer_tech_ex_info.rat_value == DS_SYS_RAT_EX_3GPP2_EHRPD)
            {
              data_bearer_technology->so_mask = PS_IFACE_CDMA_EVDO_MMPA_EHRPD;
            }
            else
            {
              data_bearer_technology->so_mask = PS_IFACE_CDMA_EVDO_MMPA;
            }
          }
          break;
        }

        default:
        {
          data_bearer_technology->rat_mask |= PS_IFACE_CDMA_NULL_BEARER;
          break;
        }
      }; /* switch (bearer_tech_info_ex.rat_value) */
      break;
    } /* case DS_SYS_NETWORK_3GPP2 */
    default:
    {
      data_bearer_technology->current_nw = PS_IFACE_NETWORK_MIN;
      LOG_MSG_ERROR_1 ("Invalid current technology (=%d)!",
                       bearer_tech_ex_info.technology);
      break;
    }
  }; /* switch (bearer_tech_info) */

} /* wdsi_get_current_data_bearer_tech() */
#endif /* FEATURE_DATA_WLAN_MAPCON */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_DATA_BEARER_TECHNOLOGY()

  DESCRIPTION
    Retrive the current data bearer technology

  PARAMETERS
    sp        : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_data_bearer_technology(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *         wds_sp;
  qmi_wdsi_client_state_type *  client_sp;
  dsm_item_type *               response;
  wds_get_data_bearer_technology_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
#ifdef FEATURE_DATA_WLAN_MAPCON
  qmi_wdsi_curr_data_bearer_tech_type curr_data_bearer_tech;
#endif /* FEATURE_DATA_WLAN_MAPCON */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    Build the response from back to front
  -------------------------------------------------------------------------*/
  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg, 0, sizeof(resp_msg));

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  if ( wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED )
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;

#ifdef FEATURE_DATA_WLAN_MAPCON
    if (wds_sp->is_last_data_bearer_cache_set)
    {
      wdsi_get_current_data_bearer_tech(wds_sp->last_data_bearer_cache, &curr_data_bearer_tech);
      resp_msg.data_bearer_tech = (wds_data_bearer_tech_enum_v01)
                         wdsi_get_data_bearer_tech(curr_data_bearer_tech);
      if ((resp_msg.data_bearer_tech != QMI_WDS_BEARER_TECH_UNKNOWN) &&
          (resp_msg.data_bearer_tech != QMI_WDS_BEARER_TECH_NULL))
      {
        resp_msg.last_call_data_bearer_tech_valid = TRUE;
        resp_msg.last_call_data_bearer_tech = resp_msg.data_bearer_tech;
      }
      else
      {
        LOG_MSG_INFO2_0("Cached data bearer not set, do not include opt TLV");
      }
    }
#else
    resp_msg.data_bearer_tech = wdsi_get_data_bearer_tech(wds_sp->last_data_bearer_cache);
    if ((resp_msg.data_bearer_tech != QMI_WDS_BEARER_TECH_UNKNOWN) &&
        (resp_msg.data_bearer_tech != QMI_WDS_BEARER_TECH_NULL))
    {
      resp_msg.last_call_data_bearer_tech_valid = TRUE;
      resp_msg.last_call_data_bearer_tech = resp_msg.data_bearer_tech;
    }
    else
    {
      LOG_MSG_INFO2_0("Cached data bearer not set, do not include opt TLV");
    }
#endif /* FEATURE_DATA_WLAN_MAPCON */
   /*As call is not there we should not send valid value*/
    resp_msg.data_bearer_tech = 0;
    goto send_result;
  }

  // If call is up on a different subs reject the request.
  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
    LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

#ifdef FEATURE_DATA_WLAN_MAPCON
  wdsi_get_current_data_bearer_tech(wds_sp->curr_data_bearer_cache, &curr_data_bearer_tech);
  resp_msg.data_bearer_tech = (wds_data_bearer_tech_enum_v01)
  	                           wdsi_get_data_bearer_tech(curr_data_bearer_tech);
#else
  resp_msg.data_bearer_tech = (wds_data_bearer_tech_enum_v01)
                               wdsi_get_data_bearer_tech(wds_sp->curr_data_bearer_cache);
#endif /* FEATURE_DATA_WLAN_MAPCON */

  if  (resp_msg.data_bearer_tech == QMI_WDS_BEARER_TECH_UNKNOWN)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }
  else if (resp_msg.data_bearer_tech == QMI_WDS_BEARER_TECH_NULL)
  {
    errval = QMI_ERR_INFO_UNAVAILABLE_V01;
    goto send_result;
  }

send_result:
  if(errval != QMI_ERR_NONE_V01)
  {
    LOG_MSG_ERROR_2("qmi_wdsi_get_data_bearer_technology: errval: %d, bearer tech(=%d)!",
                     errval, resp_msg.data_bearer_tech);
  }
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_DATA_BEARER_TECHNOLOGY_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
}  /* qmi_wdsi_get_data_bearer_technology() */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_DATA_BEARER_TECH_IND()

DESCRIPTION
    Called when data bearer tech change iface event occurs.
    Used to indicate data bearer technology.
    Causes wds_event_report_ind to be sent

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void qmi_wdsi_generate_data_bearer_tech_ind
(
  qmi_wdsi_state_type *       wds_sp,
  qmi_wds_bearer_tech_e_type  data_bearer_tech
)
{
  qmi_wdsi_client_state_type *  cl_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (wds_sp);

  if (QMI_WDS_BEARER_TECH_UNKNOWN == data_bearer_tech ||
      QMI_WDS_BEARER_TECH_NULL == data_bearer_tech)
  {
    LOG_MSG_INFO1_1("Data bearer tech %d is not valid or NULL, not sending IND",
                    data_bearer_tech);
  }
  else
  {
    LOG_MSG_INFO1_1("Recvd new data bearer technology %d", data_bearer_tech);

    /* Send indications to clients registered for the event */
    cl_sp = wds_sp->client_list;
    while (cl_sp != NULL)
    {
      if(wds_sp->pkt_svc_state == QMI_WDS_CONN_CONNECTED &&
         cl_sp->report_status.report_data_bearer &&
         qmi_wdsi_verify_client_subs(cl_sp, wds_sp->binding.subscription_id, TRUE))
      {
          qmi_wdsi_event_report_ind(wds_sp,
                                    cl_sp->common.clid,
                                    WDSI_REPORT_STATUS_EV_DATA_BEARER,
                                    0,
                                    0,
                                    NULL,
                                    data_bearer_tech,
                                    0,
                                    (qmi_wds_dormancy_status_e_type) 0,
                                    NULL,
                                    0,
                                    WDSI_CALL_UKNOWN,
                                    WDSI_DATA_CALL_NONE,                                       
                                    0,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
      }
      cl_sp = cl_sp->next;
    } /* while */
  } /*else [if(data_bearer_tech is valid)]*/
} /* qmi_wdsi_generate_data_bearer_tech_ind */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_UPLINK_FLOW_CTRL_IND()

DESCRIPTION
    Called when uplink flow control status change event occurs.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_flow_ctrl_ind
(
  qmi_wdsi_state_type *       wds_sp,
  boolean                     uplink_flow_ctrl,
  uint16                      fc_seq_num
)
{
  qmi_wdsi_client_state_type *  cl_sp;
  wds_event_report_ind_msg_v01*  indication;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (wds_sp == NULL)
  {
    DATA_ERR_FATAL("NULL wds_sp");
    return;
  }
  PS_SYSTEM_HEAP_MEM_ALLOC(indication,
                           sizeof(wds_event_report_ind_msg_v01),
                           wds_event_report_ind_msg_v01*);
  if(indication == NULL)
  {
    return;
  }

  /* Send indications to clients registered for the event */
  cl_sp = wds_sp->client_list;

  memset(indication,0,sizeof(wds_event_report_ind_msg_v01));
  indication->uplink_fc_seq_num_valid = TRUE;
  indication->uplink_fc_seq_num = fc_seq_num;
  indication->uplink_flow_control_valid = TRUE;
  indication->uplink_flow_control = uplink_flow_ctrl;
  
  while (cl_sp != NULL)
  {
    if ( (cl_sp->report_status.report_uplink_flow_ctrl) &&
         (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp)) )
    {
      if (qmi_wdsi_verify_client_subs(cl_sp, wds_sp->binding.subscription_id, TRUE))
      {
        (void)qmi_wdsi_send_ind (
              wds_sp, cl_sp, QMI_WDS_EVENT_REPORT_IND_V01,
              sizeof(wds_event_report_ind_msg_v01),indication,TRUE);
      }
    }
    cl_sp = cl_sp->next;
  } /* while */
  PS_SYSTEM_HEAP_MEM_FREE(indication);
} /* qmi_wdsi_generate_flow_ctrl_ind() */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_DUN_DATA_BEARER_TECH_IND()

DESCRIPTION
    Called when data bearer tech change iface event occurs.
    Used to indicate data bearer technology.
    Causes dun_call_info IND to be sent

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void qmi_wdsi_generate_dun_data_bearer_tech_ind
(
  qmi_wds_bearer_tech_e_type  data_bearer_tech
)
{
  qmi_wdsi_client_state_type *  cl_sp;
  qmi_wdsi_state_type *         wds_sp;
  uint8                         state;
  uint8                         inst;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (QMI_WDS_BEARER_TECH_UNKNOWN == data_bearer_tech ||
      QMI_WDS_BEARER_TECH_NULL == data_bearer_tech)
  {
    LOG_MSG_INFO1_1("Data bearer tech %d is not valid or NULL, not sending IND",
                    data_bearer_tech);
  }
  else
  {
    LOG_MSG_INFO1_1("Recvd new DUN data bearer technology %d",
                    data_bearer_tech);

    /* Send indications to clients registered for the event */
    for( state = 0; state < WDSI_MAX_STATE; state++ )
    {
      for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
      {
        wds_sp = qmi_wds_state[state][inst];
        if (wds_sp == NULL)
        {
          continue;
        }

        cl_sp = wds_sp->client_list;
        while (cl_sp != NULL)
        {
          if (cl_sp->modem_rpt_status.data_bearer && 
              cl_sp->modem_rpt_status.last_data_bearer != data_bearer_tech &&
              qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED &&
              qmi_wdsi_verify_client_subs(cl_sp, qmi_wdsi_global.dun_subs_id, TRUE))
          {
            qmi_wds_dun_call_info_ind(wds_sp,
                                     cl_sp->common.clid,
                                     (uint32)
                                      WDSI_REPORT_MODEM_STATUS_EV_DATA_BEARER,
                                     QMI_WDS_TRAFFIC_CH_UNKNOWN,
                                     data_bearer_tech,
                                     0,
                                     0,
                                     (qmi_wds_conn_status_e_type) 0);
            cl_sp->modem_rpt_status.last_data_bearer = data_bearer_tech;
          }
          cl_sp = cl_sp->next;
        } /* for each client */
      } /* for each instance */
    } /* for each state */
  } /*else [if(data_bearer_tech is valid)]*/
} /* qmi_wdsi_generate_dun_data_bearer_tech_ind */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_AUTOCONNECT_SETTING()

  DESCRIPTION
    Give the current autoconnect setting

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_autoconnect_setting
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *  wds_sp;
  dsm_item_type *        response;
  wds_get_autoconnect_setting_req_msg_v01 req_msg;
  wds_get_autoconnect_setting_resp_msg_v01 resp_msg;

  qmi_error_type_v01 errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;

  /*-------------------------------------------------------------------------
    Build the response from back to front
  -------------------------------------------------------------------------*/
  response = NULL;
  errval = QMI_ERR_NONE_V01;

  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  /* Check that request is sent on a valid port */
  if( wds_sp->binding.is_reversed ||
      wds_sp->binding.rmnet_inst >= RMNET_INSTANCE_MAX )
  {
    errval = QMI_ERR_INVALID_OPERATION_V01;
    LOG_MSG_ERROR_1("Request sent on non-binding instance %d "
            , wdsi_get_instance_from_wds_sp(sp));
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    Get roam setting- optional tlv.
  -------------------------------------------------------------------------*/
  resp_msg.autoconnect_roam_setting =
                              (uint8)rmnet_meta_sm_get_autoconnect_roam_setting(
                                              wds_sp->binding.rmnet_inst);

  if (resp_msg.autoconnect_roam_setting < QMI_WDS_AUTOCONNECT_ROAM_SETTING_MAX)
    {
    resp_msg.autoconnect_roam_setting_valid = TRUE;
  }

  /*-------------------------------------------------------------------------
    Get autoconnect setting.
  -------------------------------------------------------------------------*/
  resp_msg.autoconnect_setting = (uint8)rmnet_meta_sm_get_autoconnect_setting(
                                              wds_sp->binding.rmnet_inst);
send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_AUTOCONNECT_SETTING_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_autoconnect_setting() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_ACTIVE_MIP_PROFILE()

  DESCRIPTION
    Queries the active MIP profile

  PARAMETERS
    sp        : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_active_mip_profile
(
  void *              sp,
  void *              cmd_buf_p,
  void *              cl_sp,
  dsm_item_type **    sdu_in
)
{
  dsm_item_type *               response;
  wds_get_active_mip_profile_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  nv_item_type      *dcc_nv_item_ptr;
#endif  /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
            defined(FEATURE_DS_MOBILE_IP)) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));

#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC(dcc_nv_item_ptr, sizeof(nv_item_type),
                            nv_item_type*);
  if( dcc_nv_item_ptr == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    goto send_result;
  }
#if defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE)
#ifdef FEATURE_MMGSDI_SESSION_LIB
  /*-------------------------------------------------------------------------
    If RUIM/CSIM is being used, the active MIP profile cannot be read unless
    the UIM is unlocked. Check the UIM state and return
    QMI_ERR_SIM_NOT_INITIALIZED_V01 if the state is not initialized. Also check
    PIN1 status
    -------------------------------------------------------------------------*/
  if ((errval = qmi_wdsi_check_uim_access_status()) != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
#endif /* FEATURE_MMGSDI_SESSION_LIB */
#endif /* defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */

  /*-------------------------------------------------------------------------
    Get current MIP profile settings
  -------------------------------------------------------------------------*/
  /* read the active MIP profile index and verify it is within the valid range*/
  if (NV_DONE_S == dcc_get_nv_item(NV_DS_MIP_ACTIVE_PROF_I, dcc_nv_item_ptr))
  {
    resp_msg.profile_index = dcc_nv_item_ptr->ds_mip_active_prof;
  }
  else
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }
  if (WDSI_MIP_PROF_INDEX_MAX <= resp_msg.profile_index)
  {
    LOG_MSG_INFO1_1("MIP profile index %d invalid", resp_msg.profile_index);
    errval = QMI_ERR_INVALID_INDEX_V01;
    goto send_result;
  }

send_result:
  /*-------------------------------------------------------------------------
    Free the temporary memory allocated for NV item.
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);

#else /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
          defined(FEATURE_DS_MOBILE_IP)) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif  /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
            defined(FEATURE_DS_MOBILE_IP)) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_ACTIVE_MIP_PROFILE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_active_mip_profile() */


/*===========================================================================
  FUNCTION QMI_WDSI_SET_ACTIVE_MIP_PROFILE()

  DESCRIPTION
   Sets the active MIP profile

  PARAMETERS
    sp        : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_active_mip_profile
(
  void *              sp,
  void *              cmd_buf_p,
  void *              cl_sp,
  dsm_item_type **    sdu_in
)
{
  dsm_item_type *               response;
  wds_set_active_mip_profile_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  wds_set_active_mip_profile_req_msg_v01 req_msg;
  qmi_if_spc_result_e_type   check_spc_result;
  nv_item_type      *dcc_nv_item_ptr;

 #endif  /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
            defined(FEATURE_DS_MOBILE_IP)) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response      = NULL;
  errval        = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  memset(&req_msg,0,sizeof(req_msg));
  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC(dcc_nv_item_ptr, sizeof(nv_item_type),
                            nv_item_type*);
  if( dcc_nv_item_ptr == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    goto send_result;
  }
#if defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE)
#ifdef FEATURE_MMGSDI_SESSION_LIB
  /*-------------------------------------------------------------------------
    If RUIM/CSIM is being used, the active MIP profile cannot be set unless the
    UIM is unlocked. Check the UIM state and return QMI_ERR_SIM_NOT_INITIALIZED_V01
    if the state is not initialized. Also check PIN1 status
    -------------------------------------------------------------------------*/
  if ((errval = qmi_wdsi_check_uim_access_status()) != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
#endif /* FEATURE_MMGSDI_SESSION_LIB */
#endif /* defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_ACTIVE_MIP_PROFILE_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  /*-----------------------------------------------------------------------
    Check the supplied SPC is valid
  -----------------------------------------------------------------------*/
  check_spc_result = qmi_if_check_spc((uint8 *)req_msg.profile_identifier.spc, FALSE);

  if(check_spc_result == QMI_SPC_FAIL)
  {
    errval = QMI_ERR_AUTHENTICATION_FAILED_V01;
    goto send_result;
  }

  if(check_spc_result == QMI_SPC_LOCKED)
  {
    errval = QMI_ERR_AUTHENTICATION_LOCK_V01;
    goto send_result;
  }

  if(check_spc_result == QMI_SPC_ERR_INTERNAL)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  /*-----------------------------------------------------------------------
    Update the active MIP profile NV item
  -----------------------------------------------------------------------*/
  /* check that the new profile index is within range*/
  if (WDSI_MIP_PROF_INDEX_MAX <= req_msg.profile_identifier.profile_index)
  {
    errval = QMI_ERR_INVALID_INDEX_V01;
    goto send_result;
  }
  /* check that the new profile index has a profile written
     (NV_DS_MIP_GEN_USER_PROFILE_I) */
  dcc_nv_item_ptr->ds_mip_gen_user_prof.index = req_msg.profile_identifier.profile_index;
  if (NV_DONE_S != dcc_get_nv_item(NV_DS_MIP_GEN_USER_PROF_I, dcc_nv_item_ptr))
  {
    errval = QMI_ERR_NOT_PROVISIONED_V01;
    goto send_result;
  }

  /* set the active profile */
  memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
  dcc_nv_item_ptr->ds_mip_active_prof = req_msg.profile_identifier.profile_index;
  if (NV_DONE_S != dcc_put_nv_item(NV_DS_MIP_ACTIVE_PROF_I, dcc_nv_item_ptr))
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

send_result:
  /*-------------------------------------------------------------------------
    Free the temporary memory allocated for NV item.
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);

  if(errval != QMI_ERR_NONE_V01)
  {
    LOG_MSG_INFO1_2("qmi_wdsi_set_active_mip_profile: errval:%d, MIP profile index %d",
                     errval, req_msg.profile_identifier.profile_index);
  }

#else /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
          defined(FEATURE_DS_MOBILE_IP)) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif  /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
            defined(FEATURE_DS_MOBILE_IP)) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_ACTIVE_MIP_PROFILE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_active_mip_profile() */


/*===========================================================================
  FUNCTION QMI_WDSI_GET_MIP_PROFILE()

  DESCRIPTION
    Retrive parameters for a specified MIP profile

  PARAMETERS
    sp        : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_mip_profile
(
  void *              sp,
  void *              cmd_buf_p,
  void *              cl_sp,
  dsm_item_type **    sdu_in
)
{
  dsm_item_type *               response;
  qmi_error_type_v01 errval;
  wds_read_mip_profile_req_msg_v01 req_msg;
  wds_read_mip_profile_resp_msg_v01 resp_msg;
#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  uint8  mn_ha_key_state = QMI_WDS_MIP_KEY_UNSET;
  uint8  mn_aaa_key_state = QMI_WDS_MIP_KEY_UNSET;
  nv_stat_enum_type nv_status;
  nv_item_type      *dcc_nv_item_ptr;
#endif  /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
            defined(FEATURE_DS_MOBILE_IP)) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response      = NULL;
  errval        = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));
  
#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))

  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC(dcc_nv_item_ptr, sizeof(nv_item_type),
                            nv_item_type*);
  if( dcc_nv_item_ptr == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    goto send_result;
  }

#if defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE)
#ifdef FEATURE_MMGSDI_SESSION_LIB
  /*-------------------------------------------------------------------------
    If RUIM/CSIM is being used, the MIP profile cannot be read unless the UIM 
    is unlocked. Check the UIM state and return QMI_ERR_SIM_NOT_INITIALIZED_V01 if 
    the state is not initialized. Also check PIN1 status
    -------------------------------------------------------------------------*/
  if ((errval = qmi_wdsi_check_uim_access_status()) != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
#endif /* FEATURE_MMGSDI_SESSION_LIB */
#endif /* defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_READ_MIP_PROFILE_REQ_V01,
                                       sdu_in,
                                      &req_msg,
                                      sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    Get current MIP profile settings
  -------------------------------------------------------------------------*/
  /* check that the give MIP profile index is within index range */
  if (WDSI_MIP_PROF_INDEX_MAX <= req_msg.profile_index)
  {
    LOG_MSG_INFO1_1("MIP profile index %d invalid", req_msg.profile_index);
    errval = QMI_ERR_INVALID_INDEX_V01;
    goto send_result;
  }

  /* read enabled NV item for MIP profile index */
  if (NV_DONE_S != dcc_get_nv_item(NV_DS_MIP_ENABLE_PROF_I, dcc_nv_item_ptr))
  {
    resp_msg.profile_state = FALSE;
  }
  else
  {
    resp_msg.profile_state = dcc_nv_item_ptr->ds_mip_enable_prof[req_msg.profile_index];
  }
  resp_msg.profile_state_valid = TRUE;

  /* read the specified MIP profile from NV */
  dcc_nv_item_ptr->ds_mip_gen_user_prof.index = req_msg.profile_index;
  if (NV_DONE_S != dcc_get_nv_item(NV_DS_MIP_GEN_USER_PROF_I, dcc_nv_item_ptr))
  {
    errval = QMI_ERR_NOT_PROVISIONED_V01;
    dsm_free_packet(&response);
    goto send_result;
  }
  else
  {
    /* copy the MIP profile from the NV item */
    resp_msg.home_address_valid = TRUE;
    resp_msg.home_address = (uint32) dcc_nv_item_ptr->ds_mip_gen_user_prof.home_addr;
    resp_msg.home_agent_priv_valid = TRUE;
    resp_msg.home_agent_priv = (uint32) dcc_nv_item_ptr->ds_mip_gen_user_prof.primary_ha_addr;
    resp_msg.home_agent_sec_valid = TRUE;
    resp_msg.home_agent_sec = (uint32) dcc_nv_item_ptr->ds_mip_gen_user_prof.secondary_ha_addr;
    resp_msg.rev_tun_pref_valid =  TRUE;
    resp_msg.rev_tun_pref = (uint8)  dcc_nv_item_ptr->ds_mip_gen_user_prof.rev_tun_pref;

    /* copy the MIP profile NAI from the NV item if it has a value */
    if (0 < dcc_nv_item_ptr->ds_mip_gen_user_prof.nai_length)
    {
      dcc_nv_item_ptr->ds_mip_gen_user_prof.nai_length = 
        MIN(dcc_nv_item_ptr->ds_mip_gen_user_prof.nai_length, 
            sizeof(resp_msg.nai));
      resp_msg.nai_valid = TRUE;
      memscpy((void *)resp_msg.nai,
              sizeof(resp_msg.nai),
             (void *)dcc_nv_item_ptr->ds_mip_gen_user_prof.nai,
             dcc_nv_item_ptr->ds_mip_gen_user_prof.nai_length);
    }
    else
    {
      LOG_MSG_INFO2_0("MIP profile NAI not set, omitting TLV");
    }

    /* copy the MIP profile HA SPI from the NV item if set */
    if (dcc_nv_item_ptr->ds_mip_gen_user_prof.mn_ha_spi_set)
    {
      resp_msg.mn_ha_spi_valid = TRUE;
      resp_msg.mn_ha_spi = (uint32) dcc_nv_item_ptr->ds_mip_gen_user_prof.mn_ha_spi;
    }
    else
    {
      LOG_MSG_INFO2_0("MIP profile HA SPI not set, omitting TLV");
    }

    /* copy the MIP profile AAA SPI from the NV item if set */
    if (dcc_nv_item_ptr->ds_mip_gen_user_prof.mn_aaa_spi_set)
    {
      resp_msg.mn_aaa_spi_valid = TRUE;
      resp_msg.mn_aaa_spi = (uint32) dcc_nv_item_ptr->ds_mip_gen_user_prof.mn_aaa_spi;
    }
    else
    {
      LOG_MSG_INFO2_0("MIP profile AAA SPI not set, omitting TLV");
    }
  }

  /* read the specified MIP Shared Secret User profile from NV */
  dcc_nv_item_ptr->ds_mip_ss_user_prof.index = req_msg.profile_index;
  nv_status = dcc_get_nv_item(NV_DS_MIP_SS_USER_PROF_I, dcc_nv_item_ptr);
  if ( NV_DONE_S == nv_status )
  {
    /* only get 'default' keys if the current keys are set and non-zero len */
    if (( dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_ha_shared_secret_length  > 0 ) ||
        ( dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_aaa_shared_secret_length > 0 ))

    {
      nv_item_type      *dcc_nv_item_ptr2;

      /*-------------------------------------------------------------------------
        Allocate temporary memory for the NV item
      -------------------------------------------------------------------------*/
      PS_SYSTEM_HEAP_MEM_ALLOC(dcc_nv_item_ptr2, sizeof(nv_item_type),
                            nv_item_type*);
      if( dcc_nv_item_ptr2 == NULL )
      {
        errval = QMI_ERR_NO_MEMORY_V01;
        goto send_result;
      }

      memset(dcc_nv_item_ptr2, 0, sizeof(nv_item_type));

      dcc_nv_item_ptr2->ds_mip_ss_user_prof.index = req_msg.profile_index;

      nv_status = NV_NOTACTIVE_S;
      if ( dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_ha_shared_secret_length > 0 )
      {
        /* The state of the key is 2 ( Set to non-default value). */
        mn_ha_key_state = QMI_WDS_MIP_KEY_NOTDEFAULT;

        if ( nv_status == NV_DONE_S )
        {
          /* Check to see if the MIP HA key is the same as the default. */
          /* If the length is the same as the default ... */
          if ( ( dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_ha_shared_secret_length ==
                 dcc_nv_item_ptr2->ds_mip_ss_user_prof.mn_ha_shared_secret_length ) &&
               ( memcmp(dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_ha_shared_secret,
                        dcc_nv_item_ptr2->ds_mip_ss_user_prof.mn_ha_shared_secret,
                        dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_ha_shared_secret_length
                        ) == 0
               )
             )
          {
            /* The state of the key is 1 ( Set to default). */
            mn_ha_key_state = QMI_WDS_MIP_KEY_DEFAULT;
          }
        }
      }

      if ( dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_aaa_shared_secret_length > 0 )
      {
        /* The state of the key is 2 ( Set to non-default value). */
        mn_aaa_key_state = QMI_WDS_MIP_KEY_NOTDEFAULT;

        if ( nv_status == NV_DONE_S )
        {
          /* Check to see if the MIP AAA key is the same as the default. */
          /* If the length is the same as the default ... */
          if ( ( dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_aaa_shared_secret_length ==
                 dcc_nv_item_ptr2->ds_mip_ss_user_prof.mn_aaa_shared_secret_length ) &&
               ( memcmp(dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_aaa_shared_secret,
                        dcc_nv_item_ptr2->ds_mip_ss_user_prof.mn_aaa_shared_secret,
                        dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_aaa_shared_secret_length
                        ) == 0
               )
             )
          {
            /* The state of the key is 1 ( Set to default). */
            mn_aaa_key_state = QMI_WDS_MIP_KEY_DEFAULT;
          }
        }
      }

      /*-------------------------------------------------------------------------
        Free the temporary memory allocated for NV item.
      -------------------------------------------------------------------------*/
      PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr2);
    }
    else
    {
      LOG_MSG_INFO1_1("MIP keys for profile index %d zero len",
                      req_msg.profile_index);
    }
  }
  else if ( nv_status != NV_NOTACTIVE_S )
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }
  resp_msg.mn_ha_key_state_valid = TRUE;
  resp_msg.mn_ha_key_state = mn_ha_key_state;
  resp_msg.mn_aaa_key_state_valid = TRUE;
  resp_msg.mn_aaa_key_state = mn_aaa_key_state;

send_result:
  /*-------------------------------------------------------------------------
    Free the temporary memory allocated for NV item.
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);

  if(errval != QMI_ERR_NONE_V01)
  {
    LOG_MSG_INFO1_2("qmi_wdsi_get_mip_profile: errval:%d MIP profile index %d",
                     errval, req_msg.profile_index);
  }

#else /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
          defined(FEATURE_DS_MOBILE_IP)) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif  /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
            defined(FEATURE_DS_MOBILE_IP)) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_READ_MIP_PROFILE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_mip_profile() */


/*===========================================================================
  FUNCTION QMI_WDSI_SET_MIP_PROFILE()

  DESCRIPTION
    Sets parameters for a specified MIP profile

  PARAMETERS
    sp        : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_mip_profile
(
  void *              sp,
  void *              cmd_buf_p,
  void *              cl_sp,
  dsm_item_type **    sdu_in
)
{
  dsm_item_type *               response;
  wds_modify_mip_profile_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;

#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  qmi_if_spc_result_e_type   check_spc_result;
  wds_modify_mip_profile_req_msg_v01 req_msg;
  nv_item_type      *dcc_nv_item_ptr;
#endif  /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
            defined(FEATURE_DS_MOBILE_IP)) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response           = NULL;
  errval             = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));

#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC(dcc_nv_item_ptr, sizeof(nv_item_type),
                            nv_item_type*);
  if( dcc_nv_item_ptr == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    goto send_result;
  }

#if defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE)
  /*-------------------------------------------------------------------------
    Changes are not allowed on RUIM/CSIM,returning QMI_ERR_OP_DEVICE_UNSUPPORTED_V01
  -------------------------------------------------------------------------*/
  if (NV_RTRE_CONTROL_USE_RUIM == nv_rtre_control())
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
    LOG_MSG_INFO1_1("Changes are not allowed on RUIM or CSIM (%d)", errval);
    goto send_result;
  }
#endif /* defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */
  memset(&req_msg,0,sizeof(req_msg));
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_MODIFY_MIP_PROFILE_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  /*-----------------------------------------------------------------------
    Check the supplied SPC is valid
  -----------------------------------------------------------------------*/
  check_spc_result = qmi_if_check_spc((uint8 *)req_msg.profile_identifier.spc, FALSE);

  if(check_spc_result == QMI_SPC_FAIL)
  {
    errval = QMI_ERR_AUTHENTICATION_FAILED_V01;
    goto send_result;
  }

  if(check_spc_result == QMI_SPC_LOCKED)
  {
    errval = QMI_ERR_AUTHENTICATION_LOCK_V01;
    goto send_result;
  }

  if(check_spc_result == QMI_SPC_ERR_INTERNAL)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  /*-----------------------------------------------------------------------
    Perform validity checks on input parameters
  -----------------------------------------------------------------------*/
  /* check that the new profile index is within range*/
  if (WDSI_MIP_PROF_INDEX_MAX <= req_msg.profile_identifier.profile_index)
  {
    LOG_MSG_INFO1_1("MIP profile index %d invalid", req_msg.profile_identifier.profile_index);
    errval = QMI_ERR_INVALID_INDEX_V01;
    goto send_result;
  }
  if (req_msg.profile_state_valid)
  {
    if ((FALSE != req_msg.profile_state) && (TRUE != req_msg.profile_state))
    {
      LOG_MSG_INFO1_1("MIP profile state %d invalid", req_msg.profile_state);
      errval = QMI_ERR_INVALID_ARG_V01;
      goto send_result;
    }
  }
  if (req_msg.rev_tun_pref_valid)
  {
    if ((FALSE != req_msg.rev_tun_pref) && (TRUE != req_msg.rev_tun_pref))
    {
      LOG_MSG_INFO1_1("MIP profile rev tunnel pref %d invalid", req_msg.rev_tun_pref);
      errval = QMI_ERR_INVALID_ARG_V01;
      goto send_result;
    }
  }

  /*-----------------------------------------------------------------------
    Update the MIP profile NV items
  -----------------------------------------------------------------------*/
  if (req_msg.profile_state_valid)
  {
    /* read enabled NV item for MIP profile index */
    if (NV_DONE_S != dcc_get_nv_item(NV_DS_MIP_ENABLE_PROF_I, dcc_nv_item_ptr))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
    /* if the state is different that the current, update the NV item */
    if (req_msg.profile_state != 
         dcc_nv_item_ptr->ds_mip_enable_prof[req_msg.profile_identifier.profile_index])
    {
      /* update enabled NV item for given MIP profile index */
      dcc_nv_item_ptr->ds_mip_enable_prof[req_msg.profile_identifier.profile_index] = req_msg.profile_state;
      /* write enabled NV item for MIP profile index */
      if (NV_DONE_S != dcc_put_nv_item(NV_DS_MIP_ENABLE_PROF_I, dcc_nv_item_ptr))
      {
        errval = QMI_ERR_INTERNAL_V01;
        goto send_result;
      }
    }
  }

  if ((req_msg.home_address_valid) ||
      (req_msg.home_agent_priv_valid)    ||
      (req_msg.home_agent_sec_valid)    ||
      (req_msg.rev_tun_pref_valid)   ||
      (req_msg.nai_valid)       ||
      (req_msg.mn_ha_spi_valid)    ||
      (req_msg.mn_aaa_spi_valid))
  {
    dcc_nv_item_ptr->ds_mip_gen_user_prof.index = req_msg.profile_identifier.profile_index;
    if (NV_DONE_S != dcc_get_nv_item(NV_DS_MIP_GEN_USER_PROF_I, dcc_nv_item_ptr))
    {
      LOG_MSG_INFO2_0("Using default HA/AAA SPI for new MIP profile");
      dcc_nv_item_ptr->ds_mip_gen_user_prof.mn_ha_spi_set     = TRUE;
      dcc_nv_item_ptr->ds_mip_gen_user_prof.mn_ha_spi         = MIP_MD5_SPI;
      dcc_nv_item_ptr->ds_mip_gen_user_prof.mn_aaa_spi_set    = TRUE;
      dcc_nv_item_ptr->ds_mip_gen_user_prof.mn_aaa_spi        = MIP_CHAP_SPI;
    }

    /* update any MIP profile items provided to NV item */
    if (req_msg.home_address_valid)
    {
      dcc_nv_item_ptr->ds_mip_gen_user_prof.home_addr         = req_msg.home_address;
    }
    if (req_msg.home_agent_priv_valid)
    {
      dcc_nv_item_ptr->ds_mip_gen_user_prof.primary_ha_addr   = req_msg.home_agent_priv;
    }
    if (req_msg.home_agent_sec_valid)
    {
      dcc_nv_item_ptr->ds_mip_gen_user_prof.secondary_ha_addr = req_msg.home_agent_sec;
    }
    if (req_msg.rev_tun_pref_valid)
    {
      dcc_nv_item_ptr->ds_mip_gen_user_prof.rev_tun_pref      = req_msg.rev_tun_pref;
    }
    if (req_msg.nai_valid)
    {
      dcc_nv_item_ptr->ds_mip_gen_user_prof.nai_length        = (byte)strlen(req_msg.nai);
      memscpy((void *) dcc_nv_item_ptr->ds_mip_gen_user_prof.nai,
               sizeof(dcc_nv_item_ptr->ds_mip_gen_user_prof.nai),
             (void *) req_msg.nai,
             strlen(req_msg.nai));
    }
    if (req_msg.mn_ha_spi_valid)
    {
      dcc_nv_item_ptr->ds_mip_gen_user_prof.mn_ha_spi_set     = TRUE;
      dcc_nv_item_ptr->ds_mip_gen_user_prof.mn_ha_spi         = req_msg.mn_ha_spi;
    }
    if (req_msg.mn_aaa_spi_valid)
    {
      dcc_nv_item_ptr->ds_mip_gen_user_prof.mn_aaa_spi_set     = TRUE;
      dcc_nv_item_ptr->ds_mip_gen_user_prof.mn_aaa_spi         = req_msg.mn_aaa_spi;
    }

    /* update the MIP profile NV item */
    if (NV_DONE_S != dcc_put_nv_item(NV_DS_MIP_GEN_USER_PROF_I, dcc_nv_item_ptr))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }

  /*-----------------------------------------------------------------------
    Update the MIP shared secret user profile
  -----------------------------------------------------------------------*/
  if ((req_msg.mn_ha_key_valid) || (req_msg.mn_aaa_key_valid))
  {
    dcc_nv_item_ptr->ds_mip_ss_user_prof.index = req_msg.profile_identifier.profile_index;
    (void)dcc_get_nv_item(NV_DS_MIP_SS_USER_PROF_I, dcc_nv_item_ptr);
    

    if(req_msg.mn_ha_key_valid)
    {
      dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_ha_shared_secret_length = (byte)strlen(req_msg.mn_ha_key);
      memscpy ((void *) dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_ha_shared_secret,
                sizeof(dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_ha_shared_secret),
              (void *) req_msg.mn_ha_key,
              strlen(req_msg.mn_ha_key));
    }
    if(req_msg.mn_aaa_key_valid)
    {
      dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_aaa_shared_secret_length = (byte)strlen(req_msg.mn_aaa_key);
      memscpy ((void *) dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_aaa_shared_secret,
                sizeof(dcc_nv_item_ptr->ds_mip_ss_user_prof.mn_aaa_shared_secret),
              (void *) req_msg.mn_aaa_key,
              strlen(req_msg.mn_aaa_key));
    }

    if (NV_DONE_S != dcc_put_nv_item (NV_DS_MIP_SS_USER_PROF_I, dcc_nv_item_ptr))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  } /* (req_msg.mn_ha_key_valid) || (req_msg.mn_aaa_key_valid) */

send_result:
  /*-------------------------------------------------------------------------
    Free the temporary memory allocated for NV item.
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);

#else /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
          defined(FEATURE_DS_MOBILE_IP)) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif  /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
            defined(FEATURE_DS_MOBILE_IP)) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_MODIFY_MIP_PROFILE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_mip_profile() */



/*===========================================================================
  FUNCTION QMI_WDSI_GET_MIP_SETTINGS()

  DESCRIPTION
    Retrive MIP settings

  PARAMETERS
    sp        : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_mip_settings
(
  void *              sp,
  void *              cmd_buf_p,
  void *              cl_sp,
  dsm_item_type **    sdu_in
)
{
  dsm_item_type *               response;
  wds_get_mip_settings_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;

#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  nv_stat_enum_type  nv_status;
  nv_item_type      *dcc_nv_item_ptr;
#endif  /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
            defined(FEATURE_DS_MOBILE_IP)) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response      = NULL;
  errval        = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC(dcc_nv_item_ptr, sizeof(nv_item_type),
                            nv_item_type*);
  if( dcc_nv_item_ptr == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    goto send_result;
  }
#if defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE)
#ifdef FEATURE_MMGSDI_SESSION_LIB
  /*-------------------------------------------------------------------------
    If RUIM/CSIM is being used, the MIP Settings cannot be read unless the UIM
    is unlocked. Check the UIM state and return QMI_ERR_SIM_NOT_INITIALIZED_V01 if 
    the state is not initialized. Also check PIN1 status
    -------------------------------------------------------------------------*/
  if ((errval = qmi_wdsi_check_uim_access_status()) != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
#endif /* FEATURE_MMGSDI_SESSION_LIB */
#endif /* defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */

  /*-------------------------------------------------------------------------
    Get current MIP profile settings
  -------------------------------------------------------------------------*/
  /* read NV item for MIP mode */
  nv_status = dcc_get_nv_item(NV_DS_QCMIP_I, dcc_nv_item_ptr);
  if (NV_DONE_S != nv_status)
  {
    if (NV_NOTACTIVE_S != nv_status)
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }
  else
  {
    resp_msg.mip_mode_valid = TRUE;
    resp_msg.mip_mode = (uint8) dcc_nv_item_ptr->ds_qcmip;
  }

  /* read NV item for MIP retry count */
  nv_status = dcc_get_nv_item(NV_DS_MIP_RETRIES_I, dcc_nv_item_ptr);
  if (NV_DONE_S != nv_status)
  {
    if (NV_NOTACTIVE_S != nv_status)
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }
  else
  {
    resp_msg.mip_reg_retry_count_valid = TRUE;
    resp_msg.mip_reg_retry_count = (uint8) dcc_nv_item_ptr->ds_mip_retries;
  }

  /* read NV item for MIP retry interval */
  nv_status = dcc_get_nv_item(NV_DS_MIP_RETRY_INT_I, dcc_nv_item_ptr);
  if (NV_DONE_S != nv_status)
  {
    if (NV_NOTACTIVE_S != nv_status)
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }
  else
  {
    resp_msg.mip_reg_retry_interval_valid = TRUE;
    resp_msg.mip_reg_retry_interval = (uint8) dcc_nv_item_ptr->ds_mip_retry_int;
  }

  /* read NV item for MIP re-register period */
  nv_status = dcc_get_nv_item(NV_DS_MIP_PRE_RE_RRQ_TIME_I, dcc_nv_item_ptr);
  if (NV_DONE_S != nv_status)
  {
    if (NV_NOTACTIVE_S != nv_status)
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }
  else
  {
    resp_msg.mip_re_reg_peroid_valid = TRUE;
    resp_msg.mip_re_reg_peroid = (uint8) dcc_nv_item_ptr->ds_mip_pre_re_rrq_time;
  }

  /* read NV item for MIP re-register if traffic */
  nv_status = dcc_get_nv_item(NV_DS_MIP_RRQ_IF_TFRK_I, dcc_nv_item_ptr);
  if (NV_DONE_S != nv_status)
  {
    if (NV_NOTACTIVE_S != nv_status)
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }
  else
  {
    resp_msg.mip_re_reg_if_traf_valid = TRUE;
    resp_msg.mip_re_reg_if_traf = (uint8) dcc_nv_item_ptr->ds_mip_rrq_if_tfrk;
  }

  /* read NV item for MIP QC dormant handdown */
  nv_status = dcc_get_nv_item(NV_DS_MIP_QC_HANDDOWN_TO_1X_OPT_I, dcc_nv_item_ptr);
  if (NV_DONE_S != nv_status)
  {
    if (NV_NOTACTIVE_S != nv_status)
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }
  else
  {
    resp_msg.mip_qc_handoff_valid = TRUE;
    resp_msg.mip_qc_handoff = (uint8) dcc_nv_item_ptr->ds_mip_qc_handdown_to_1x_opt;
  }

  /* read NV item for MIP RFC2002BIS MN-HA authentication */
  nv_status = dcc_get_nv_item(NV_DS_MIP_2002BIS_MN_HA_AUTH_I, dcc_nv_item_ptr);
  if (NV_DONE_S != nv_status)
  {
    if (NV_NOTACTIVE_S != nv_status)
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }
  else
  {
    resp_msg.mip_rfc2002bis_valid = TRUE;
    resp_msg.mip_rfc2002bis = (uint8) dcc_nv_item_ptr->ds_mip_2002bis_mn_ha_auth;
  }

send_result:
  /*-------------------------------------------------------------------------
    Free the temporary memory allocated for NV item.
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);

#else /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
          defined(FEATURE_DS_MOBILE_IP)) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif  /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&
            defined(FEATURE_DS_MOBILE_IP)) */

 QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_MIP_SETTINGS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
 return response;
} /* qmi_wdsi_get_mip_settings() */


/*===========================================================================
  FUNCTION QMI_WDSI_SET_MIP_SETTINGS()

  DESCRIPTION
   Sets MIP settings

  PARAMETERS
    sp        : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_mip_settings
(
  void *              sp,
  void *              cmd_buf_p,
  void *              cl_sp,
  dsm_item_type **    sdu_in
)
{
  dsm_item_type *               response;
  qmi_error_type_v01 errval;
  uint8              invalid_param;
  wds_set_mip_settings_resp_msg_v01 resp_msg;
#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  qmi_if_spc_result_e_type   check_spc_result;
  nv_item_type      *dcc_nv_item_ptr;
  wds_set_mip_settings_req_msg_v01 req_msg;
#endif  /* (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
            defined(FEATURE_DS_MOBILE_IP) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response               = NULL;
  errval                 = QMI_ERR_NONE_V01;
  invalid_param          = 0;
  memset(&resp_msg,0,sizeof(resp_msg));

#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC(dcc_nv_item_ptr, sizeof(nv_item_type),
                            nv_item_type*);
  if( dcc_nv_item_ptr == NULL )
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    goto send_result;
  }

#if defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE)
  /*-------------------------------------------------------------------------
    Changes are not allowed on RUIM/CSIM, returning QMI_ERR_OP_DEVICE_UNSUPPORTED_V01
  -------------------------------------------------------------------------*/
  if (NV_RTRE_CONTROL_USE_RUIM == nv_rtre_control())
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
    LOG_MSG_INFO1_1("Changes are not allowed on RUIM or CSIM (%d)", errval);
    goto send_result;
  }
#endif /* defined(FEATURE_RUIM) && defined(FEATURE_UIM_RUN_TIME_ENABLE) */
  memset(&req_msg,0,sizeof(req_msg));
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_MIP_SETTINGS_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  /*-----------------------------------------------------------------------
    Check the supplied SPC is valid
  -----------------------------------------------------------------------*/
  check_spc_result = qmi_if_check_spc((uint8 *)req_msg.spc, FALSE);

  if(check_spc_result == QMI_SPC_FAIL)
  {
    errval = QMI_ERR_AUTHENTICATION_FAILED_V01;
    goto send_result;
  }

  if(check_spc_result == QMI_SPC_LOCKED)
  {
    errval = QMI_ERR_AUTHENTICATION_LOCK_V01;
    goto send_result;
  }

  if(check_spc_result == QMI_SPC_ERR_INTERNAL)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  /*-----------------------------------------------------------------------
    Validate all input parameters
  -----------------------------------------------------------------------*/
  /* check that the new MIP mode is withing range */
  if (req_msg.mip_mode_valid)
  {
    if (WDSI_MIP_SETTING_MODE_MAX < req_msg.mip_mode)
    {
      invalid_param = WDSI_PRM_TYPE_MIP_SETTING_MODE;
      errval = QMI_ERR_INVALID_ARG_V01;
      goto send_result;
    }
  }
  /* check that the new initial registration interval modifier is within range*/
  if (req_msg.mip_reg_retry_interval_valid)
  {
    if (WDSI_MIP_SETTING_RETRY_INT_MAX < req_msg.mip_reg_retry_interval)
    {
      invalid_param = WDSI_PRM_TYPE_MIP_SETTING_RETRY_INT;
      errval = QMI_ERR_INVALID_ARG_V01;
      goto send_result;
    }
  }
  /* check that the new re-reg if traffic value is TRUE or FALSE */
  if (req_msg.mip_re_reg_peroid_valid)
  {
    if ((FALSE != req_msg.mip_re_reg_if_traf) && (TRUE != req_msg.mip_re_reg_if_traf))
    {
      invalid_param =  WDSI_PRM_TYPE_MIP_SETTING_RE_REG_IF_TRAF;
      errval = QMI_ERR_INVALID_ARG_V01;
      goto send_result;
    }
  }
  /* check that the new QC dormant handoff value is TRUE or FALSE */
  if (req_msg.mip_qc_handoff_valid)
  {
    if ((FALSE != req_msg.mip_qc_handoff) && (TRUE != req_msg.mip_qc_handoff))
    {
      invalid_param = WDSI_PRM_TYPE_MIP_SETTING_QC_DORM_HANDOFF;
      errval = QMI_ERR_INVALID_ARG_V01;
      goto send_result;
    }
  }
  /* check that the RFC2002BIS MN-HA auth value is TRUE or FALSE */
  if (req_msg.mip_rfc2002bis_valid)
  {
    if ((FALSE != req_msg.mip_rfc2002bis_valid) && (TRUE != req_msg.mip_rfc2002bis_valid))
    {
      invalid_param = WDSI_PRM_TYPE_MIP_SETTING_RFC2002BIS_MN_HA;
      errval = QMI_ERR_INVALID_ARG_V01;
      goto send_result;
    }
  }

  /*-----------------------------------------------------------------------
    Update the MIP setting NV items for any TLVs specified
  -----------------------------------------------------------------------*/
  /* write MIP mode */
  if (req_msg.mip_mode_valid)
  {
    memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
    dcc_nv_item_ptr->ds_qcmip = req_msg.mip_mode;
    if (NV_DONE_S != dcc_put_nv_item(NV_DS_QCMIP_I, dcc_nv_item_ptr))
    {
      errval =  QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }

  /* write MIP retry count */
  if (req_msg.mip_reg_retry_count_valid)
  {
    memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
    dcc_nv_item_ptr->ds_mip_retries = req_msg.mip_reg_retry_count;
    if (NV_DONE_S != dcc_put_nv_item(NV_DS_MIP_RETRIES_I, dcc_nv_item_ptr))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }

  /* write MIP retry interval */
  if (req_msg.mip_reg_retry_interval_valid)
  {
    memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
    dcc_nv_item_ptr->ds_mip_retry_int = req_msg.mip_reg_retry_interval;
    if (NV_DONE_S != dcc_put_nv_item(NV_DS_MIP_RETRY_INT_I, dcc_nv_item_ptr))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }

  /* write MIP re-register period */
  if (req_msg.mip_re_reg_peroid_valid)
  {
    memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
    dcc_nv_item_ptr->ds_mip_pre_re_rrq_time = req_msg.mip_re_reg_peroid;
    if (NV_DONE_S != dcc_put_nv_item(NV_DS_MIP_PRE_RE_RRQ_TIME_I, dcc_nv_item_ptr))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }

  /* write MIP re-register if traffic */
  if (req_msg.mip_re_reg_if_traf_valid)
  {
    memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
    dcc_nv_item_ptr->ds_mip_rrq_if_tfrk = req_msg.mip_re_reg_if_traf;
    if (NV_DONE_S != dcc_put_nv_item(NV_DS_MIP_RRQ_IF_TFRK_I, dcc_nv_item_ptr))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }

  /* write MIP QC dormant handoff to 1x */
  if (req_msg.mip_qc_handoff_valid)
  {
    memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
    dcc_nv_item_ptr->ds_mip_qc_handdown_to_1x_opt = req_msg.mip_qc_handoff;
    if (NV_DONE_S != dcc_put_nv_item(NV_DS_MIP_QC_HANDDOWN_TO_1X_OPT_I, dcc_nv_item_ptr))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }

  /* write MIP RFC2002BIS MN-HA Auth */
  if (req_msg.mip_rfc2002bis_valid)
  {
    memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
    dcc_nv_item_ptr->ds_mip_2002bis_mn_ha_auth = req_msg.mip_rfc2002bis;
    if (NV_DONE_S != dcc_put_nv_item(NV_DS_MIP_2002BIS_MN_HA_AUTH_I, dcc_nv_item_ptr))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }

send_result:
  /*-------------------------------------------------------------------------
    Free the temporary memory allocated for NV item.
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);

  if (errval == QMI_ERR_INVALID_ARG_V01)
  {
     LOG_MSG_INFO1_6("Invalid TLV:0x%x, MIP setting mode %d, MIP setting retry interval %d, MIP profile re-reg if trfk %d,"
                     "MIP profile QC dormt hndoff %d, MIP profile RFC2002BIS %d",
                     invalid_param, req_msg.mip_mode,req_msg.mip_reg_retry_interval, 
                     req_msg.mip_re_reg_if_traf, req_msg.mip_qc_handoff, req_msg.mip_rfc2002bis);
  }

#else /* (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&  \
          defined(FEATURE_DS_MOBILE_IP) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* (defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&  \
           defined(FEATURE_DS_MOBILE_IP) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_MIP_SETTINGS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_mip_settings() */


/*===========================================================================
  FUNCTION QMI_WDSI_GET_LAST_MIP_STATUS()

  DESCRIPTION
    Retrive the most recent MIP RRQ status

  PARAMETERS
    sp        : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_last_mip_status
(
  void *              sp,
  void *              cmd_buf_p,
  void *              cl_sp,
  dsm_item_type **    sdu_in
)
{
  dsm_item_type *     response;
  qmi_error_type_v01  errval;
  wds_get_last_mip_status_resp_msg_v01 resp_msg;
#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  qmi_wdsi_state_type *wds_sp;
  qmi_nv_status_e_type qmi_nv_status;
#endif  /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&  \
            defined(FEATURE_DS_MOBILE_IP) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response      = NULL;
  errval        = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
  /* check that not currently in a call */
  wds_sp = (qmi_wdsi_state_type *) sp;
  if (QMI_WDS_CONN_DISCONNECTED != wds_sp->pkt_svc_state ||
      QMI_WDS_CONN_DISCONNECTED != qmi_wdsi_global.dun_state)
  {
    errval = QMI_ERR_DEVICE_IN_USE_V01;
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    Get last MIP RRQ code
  -------------------------------------------------------------------------*/
  qmi_nv_status = qmi_nv_read(QMI_NV_ITEM_LAST_RMNET_MIP_ERR_CODE,
                              0,
                              0,
                              &resp_msg.mip_error,
                              sizeof(resp_msg.mip_error));
  if (QMI_NV_STATUS_OK == qmi_nv_status)
  {
    errval = QMI_ERR_NONE_V01;
  }
  else if (QMI_NV_STATUS_NOT_ACTIVE == qmi_nv_status)
  {
    errval = QMI_ERR_NO_ENTRY_V01;
  }
  else
  {
    errval = QMI_ERR_INTERNAL_V01;
  }

send_result:
#else /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&  \
         defined(FEATURE_DS_MOBILE_IP) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif  /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) &&  \
         defined(FEATURE_DS_MOBILE_IP) */

  if(errval != QMI_ERR_NONE_V01)
  {
    LOG_MSG_INFO2_1("qmi_wdsi_get_last_mip_status: errval:%d",errval);
  }
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_LAST_MIP_STATUS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_last_mip_status() */

/*===========================================================================
FUNCTION  QMI_WDS_CALLHIST_SAVE_PHONE_NUM

DESCRIPTION
  Saves the phone number from CM into a local QMI variable for call history
  purposes.  The data in phone_num_buf should be in 8-bit ASCII format
  (not 4-bit DTMF) with a trailing null byte.  This function is called from
  qmi_if_process_cm_call_event() in the file ds_qmi_if.c

PARAMETERS
  phone_num_len - length of phone_num_buf (max we will accept is governed
                  by QMI_PBM_PHONENUM_MAX_LEN)
  phone_num_buf - buffer containing phone number

DEPENDENCIES
  None

RETURNS
  None

SIDE EFFECTS
  None

===========================================================================*/
void qmi_wds_callhist_save_phone_num
(
  uint8         phone_num_len,
  const uint8  *phone_num_buf
)
{
  time_type             curr_time;

  if (phone_num_len > sizeof(qmi_wdsi_global.callhist_data.phone_num))
  {
    phone_num_len = sizeof(qmi_wdsi_global.callhist_data.phone_num);
  }

  memset(qmi_wdsi_global.callhist_data.phone_num,
         0,
         sizeof(qmi_wdsi_global.callhist_data.phone_num));
  qmi_wdsi_global.callhist_data.phone_num_len = phone_num_len;
  if (phone_num_len > 0)
  {
    memscpy(qmi_wdsi_global.callhist_data.phone_num,
            sizeof(qmi_wdsi_global.callhist_data.phone_num),
           phone_num_buf,
           phone_num_len);
  }

  /* Fetch timestamp here so we have one even if the call fails */
  (void) time_get(curr_time);
  qw_equ(QW_CVT_N2Q(&qmi_wdsi_global.callhist_data.date), curr_time);
} /* qmi_wds_callhist_save_phone_num() */

/*===========================================================================
  FUNCTION QMI_WDSI_CALL_HISTORY_LIST()

  DESCRIPTION
    Returns the listing of call history entries.  If the optional parameter
    field_mask is not present, returns all fields except the record ID.

  PARAMETERS
    sp      : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_call_history_list
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  wds_call_history_list_resp_msg_v01* resp_msg = NULL;
  qmi_error_type_v01 errval;
  uint16             field_mask;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval   = QMI_ERR_NONE_V01;
  PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg,
                           sizeof(wds_call_history_list_resp_msg_v01),
                           wds_call_history_list_resp_msg_v01*);
  if(resp_msg == NULL)
  {
    qmi_svc_put_result_tlv(&response, (qmi_result_e_type)QMI_RESULT_FAILURE_V01,
                          (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
    return response;
  }
  else
  {
    memset(resp_msg,0,sizeof(wds_call_history_list_resp_msg_v01));
  }
  /*Currently we support only full history as there is no history type TLV in request*/
  field_mask = QMI_PBM_MASK_ALL;
  errval = qmi_pbm_get_var_len_list(resp_msg,
                                    QMI_PBM_LIST_MAX_LEN,
                                    field_mask);
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_CALL_HISTORY_LIST_RESP_V01,
                               resp_msg,
                               sizeof(wds_call_history_list_resp_msg_v01),
                               errval,
                               &response);
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  return response;
} /* qmi_wdsi_call_history_list() */


/*===========================================================================
  FUNCTION QMI_WDSI_CALL_HISTORY_READ()

  DESCRIPTION
    Returns the data of a specific call history entry, or errors with

  PARAMETERS
    sp      : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_call_history_read
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  wds_call_history_read_req_msg_v01 req_msg;
  wds_call_history_read_resp_msg_v01 resp_msg;
  qmi_pbm_callhist_s_type   callhist_data;
  qmi_error_type_v01 errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response          = NULL;
  errval            = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_CALL_HISTORY_READ_REQ_V01,
                                       sdu_in,
                                      &req_msg,
                                      sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  
  errval = qmi_pbm_get_record_by_id(req_msg.call_record_id, &callhist_data);
  if(errval == QMI_ERR_NONE_V01)
  {
    resp_msg.call_history_record.call_type = callhist_data.source;
    resp_msg.call_history_record.call_data_bearer = callhist_data.tech_type_e; 
    resp_msg.call_history_record.call_rx_ok_bytes = callhist_data.rx_bytes;
    resp_msg.call_history_record.call_tx_ok_bytes = callhist_data.tx_bytes;
    resp_msg.call_history_record.call_duration_total = callhist_data.call_duration;
    resp_msg.call_history_record.call_duration_active =  callhist_data.call_duration_active;
    resp_msg.call_history_record.call_ip_addr = callhist_data.ipv4_addr;
    resp_msg.call_history_record.call_timestamp = callhist_data.date;
    resp_msg.call_history_record.call_end_reason = callhist_data.call_err_e;
    if (callhist_data.phone_num_len > QMI_WDS_MAX_PHONE_NUMBER_LEN_V01)
    {
      callhist_data.phone_num_len = QMI_WDS_MAX_PHONE_NUMBER_LEN_V01;
    }
    memscpy((void*)resp_msg.call_history_record.call_phone_num, 
              sizeof(resp_msg.call_history_record.call_phone_num),
              (void *)(callhist_data.phone_num), 
              callhist_data.phone_num_len);

  }
send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_CALL_HISTORY_READ_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_call_history_read() */

/*===========================================================================
  FUNCTION QMI_WDSI_CALL_HISTORY_DELETE()

  DESCRIPTION
    Removes all stored call history entries, maintaining the current one
    if it is a partial entry (i.e. call is still in progress).

  PARAMETERS
    sp      : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_call_history_delete
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  wds_call_history_delete_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));
  errval = qmi_pbm_clear_history();

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_CALL_HISTORY_DELETE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_call_history_delete() */

/*===========================================================================
  FUNCTION QMI_WDSI_CALL_HISTORY_MAX_SIZE()

  DESCRIPTION
    Returns the maximum number of call history records we can store.

  PARAMETERS
    sp      : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in  : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_call_history_max_size
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  wds_call_history_max_size_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  resp_msg.max_size = QMI_PBM_MAX_PB_ENTRIES;

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_CALL_HISTORY_MAX_SIZE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_call_history_max_size() */

/*===========================================================================
FUNCTION  DS_QMI_PBM_ADD

DESCRIPTION
  Adds a new entry into PBM

PARAMETERS
  wds_sp - current wds state (before disconnect is completed) or NULL for DUN

DEPENDENCIES
  None

RETURNS
  None

SIDE EFFECTS
  None

===========================================================================*/
static void qmi_wdsi_pbm_add
(
  qmi_wdsi_state_type   *wds_sp
)
{
  ps_iface_type             *ps_iface_ptr;
  ps_iface_type *           stat_iface_ptr;

  qmi_wdsi_callhist_data_temp_s_type * call_hist_ptr;

  qmi_pbm_callhist_s_type   callhist_data;
  uint64                    rx_bytes;
  uint64                    tx_bytes;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  tx_bytes = rx_bytes = 0;
  call_hist_ptr = NULL;

  if (NULL == wds_sp)
  {
    LOG_MSG_INFO2_0("Writing DUN callhistory record");
    call_hist_ptr = &qmi_wdsi_global.callhist_data;
    call_hist_ptr->source = QMI_PBM_SOURCE_DUN;
  }
  else
  {
    LOG_MSG_INFO2_1("Writing RMNET (inst=%d) callhistory record",
                    wds_sp->binding.rmnet_inst);
    call_hist_ptr = &wds_sp->callhist_data;
    call_hist_ptr->source = QMI_PBM_SOURCE_RMNET;
  }

  /* Only add a record if the device has reached the connected state */
  if (call_hist_ptr->has_connected)
  {
    memset(&callhist_data, 0, sizeof(callhist_data));

    callhist_data.source       = call_hist_ptr->source;
    callhist_data.date         = call_hist_ptr->date;
    callhist_data.ipv4_addr    = call_hist_ptr->ipv4_addr;
    callhist_data.tech_type_e  = call_hist_ptr->tech_type_e;
    callhist_data.phone_num_len=MIN(call_hist_ptr->phone_num_len,
                                    QMI_PBM_PHONENUM_MAX_LEN);
    if (callhist_data.phone_num_len > 0)
    {
      memscpy(callhist_data.phone_num, 
              sizeof(callhist_data.phone_num), 
              call_hist_ptr->phone_num,
             callhist_data.phone_num_len);
    }

    /*-------------------------------------------------------------------------
      RMNet specific data sources
    -------------------------------------------------------------------------*/
    if (QMI_PBM_SOURCE_RMNET == call_hist_ptr->source)
    {
      qw_equ(QW_CVT_N2Q(&callhist_data.call_duration),
             wds_sp->last_call_duration);

      qw_equ(QW_CVT_N2Q(&callhist_data.call_duration_active),
             wds_sp->last_call_active_duration);

      callhist_data.call_err_e = wds_sp->call_end_reason;

      /*-----------------------------------------------------------------------
        Possible race condition here: the function that tears down the RMNet
        instance and stores the rx/tx bytes in the area for a previous call
        _might_ finish before we make it to this point (but usually not); this
        way we cover both possibilities.
        Note that the statistics returned from these functions are in the
        perspective of to/from TE2, not the network, so RX and TX are swapped
      -----------------------------------------------------------------------*/
      ps_iface_ptr = rmnet_meta_sm_iface(wds_sp->binding.rmnet_inst);
      if(PS_IFACE_IS_VALID(ps_iface_ptr) == FALSE)
      {
        return;
      }

      /* we query the um iface, hence tx/rx perspective is swapped*/
      stat_iface_ptr = qmi_wdsi_get_um_stat_iface(ps_iface_ptr);

      if((stat_iface_ptr == ps_iface_ptr) ||   // call is down, stats may have been reset
         (E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_BYTES_RX, stat_iface_ptr,
                                         &rx_bytes, 8)) ||
         (E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_BYTES_TX, stat_iface_ptr,
                                         &tx_bytes, 8)))
      {
        rmnet_meta_sm_get_prev_byte_stats(wds_sp->binding.rmnet_inst,
                                          &tx_bytes,
                                          &rx_bytes);
        LOG_MSG_INFO1_0("Notice: PBM byte stats are coming from previous call information");
      }
    }
    /*-------------------------------------------------------------------------
      Dial-up networking (DUN) specific data sources
    -------------------------------------------------------------------------*/
    else if (QMI_PBM_SOURCE_DUN == call_hist_ptr->source)
    {
      qw_sub(QW_CVT_N2Q(&callhist_data.call_duration),
             qmi_wdsi_global.modem_dun_call_end_time,
             qmi_wdsi_global.modem_dun_call_connect_time);

       qw_equ(QW_CVT_N2Q(&callhist_data.call_duration_active),
              qmi_wdsi_global.modem_dun_total_active_time);

      callhist_data.call_err_e = qmi_wdsi_global.modem_dun_last_call_end_reason;

      tx_bytes = qmi_wdsi_global.modem_dun_last_call_data_count.txed_bytes;
      rx_bytes = qmi_wdsi_global.modem_dun_last_call_data_count.rxed_bytes;
    }

    LOG_MSG_INFO2_3("PBM add bytes stat tx %d rx %d, data bearer %d",
                    tx_bytes, rx_bytes, call_hist_ptr->tech_type_e);

    callhist_data.tx_bytes = tx_bytes;
    callhist_data.rx_bytes = rx_bytes;

    if (QMI_ERR_NONE_V01!= qmi_pbm_add_record(&callhist_data, NULL))
    {
      LOG_MSG_INFO1_0("could not add PBM record");
    }
  }
  else
  {
    LOG_MSG_INFO2_0("Not adding new call history entry, call was not connected");
  }

  memset(call_hist_ptr, 0, sizeof(qmi_wdsi_callhist_data_temp_s_type));
} /* qmi_wdsi_pbm_add() */


/*===========================================================================
  FUNCTION QMI_WDSI_FMC_SET_TUNNEL_PARAMS()

  DESCRIPTION
    Sets the FMC Tunnel parameters

  PARAMETERS
    sp        : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_fmc_set_tunnel_params
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_fmc_set_tunnel_params_resp_msg_v01 resp_msg;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response     = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_FMC_SET_TUNNEL_PARAMS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               QMI_ERR_OP_DEVICE_UNSUPPORTED_V01,
                               &response);
  return response;
} /* qmi_wdsi_fmc_set_tunnel_params() */

/*===========================================================================
  FUNCTION QMI_WDSI_FMC_CLEAR_TUNNEL_PARAMS()

  DESCRIPTION
    Clears the FMC Tunnel parameters

  PARAMETERS
    sp        : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_fmc_clear_tunnel_params
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  wds_fmc_clear_tunnel_params_resp_msg_v01 resp_msg;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;  
  memset(&resp_msg,0,sizeof(resp_msg));  
 
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_FMC_CLEAR_TUNNEL_PARAMS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               QMI_ERR_OP_DEVICE_UNSUPPORTED_V01,
                               &response);
  return response;
} /* qmi_wdsi_fmc_clear_tunnel_params() */

/*===========================================================================
  FUNCTION QMI_WDSI_FMC_GET_TUNNEL_PARAMS()

  DESCRIPTION
    Gets the FMC Tunnel parameters

  PARAMETERS
    sp        : service provided state pointer (user data)
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_fmc_get_tunnel_params
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  wds_fmc_get_tunnel_params_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  /*-------------------------------------------------------------------------
    ps_iface_ioctl doesn't support get tunnel params
  -------------------------------------------------------------------------*/
  LOG_MSG_INFO1_0("Get Tunnel Parameters not supported!");

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_FMC_GET_TUNNEL_PARAMS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_fmc_get_tunnel_params() */

/*===========================================================================
  FUNCTION QMI_WDSI_SET_AUTOCONNECT_SETTING()

  DESCRIPTION
    Set new autoconnect and autoconnect_roaming setting and start/stop the
    data call based one new settings.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_autoconnect_setting
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_set_autoconnect_settings_req_msg_v01 req_msg;
  wds_set_autoconnect_settings_resp_msg_v01 resp_msg;
  qmi_wdsi_state_type *         wds_sp;
  qmi_error_type_v01 errval;
  //qmi_ip_family_e_type ip_type;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  LOG_MSG_INFO2_0("AUTOCONNECT starts here");


  wds_sp = (qmi_wdsi_state_type *) sp;

  response      = NULL;
  errval        = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  /* Validate that request is not sent on reverse IP transport instance */
  if( wds_sp->binding.is_reversed ||
      wds_sp->binding.rmnet_inst >= RMNET_INSTANCE_MAX )
  {
    errval = QMI_ERR_INVALID_OPERATION_V01;
    LOG_MSG_ERROR_1("Request sent on non-binding instance %d "
            , wdsi_get_instance_from_wds_sp(sp));
    goto send_result;
  }
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_AUTOCONNECT_SETTINGS_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  /*-----------------------------------------------------------------------
    Validate the autoconnect and roaming settings.
  -----------------------------------------------------------------------*/
  /* Validate the autoconnect setting */
  if(QMI_WDS_AUTOCONNECT_MAX <= req_msg.autoconnect_setting)
  {
    LOG_MSG_ERROR_1("Autoconnect setting %d invalid",
                    req_msg.autoconnect_setting);
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  /*-----------------------------------------------------------------------
    To enable or pause autoconnect when disallowed by the device
    provisioning then return QMI_ERR_ACCESS_DENIED_V01 error.
  -----------------------------------------------------------------------*/
  if ((req_msg.autoconnect_setting > QMI_WDS_AUTOCONNECT_DISABLED) &&
      (!qmi_svc_ext_allow_auto_connect()))
  {
    LOG_MSG_ERROR_0("To set autoconnect is disallowed.");
    errval = QMI_ERR_ACCESS_DENIED_V01;
    goto send_result;
  }

  /* check optional tlv */
  if ( req_msg.autoconnect_roam_setting_valid ) 
  {
    /* Validate the roam setting */
    if (QMI_WDS_AUTOCONNECT_ROAM_SETTING_HOME_ONLY < req_msg.autoconnect_roam_setting )
    {
      LOG_MSG_ERROR_1("Autoconnect roam setting %d invalid",
                      req_msg.autoconnect_roam_setting );
      errval = QMI_ERR_MALFORMED_MSG_V01;
      goto send_result;
    }

    /* Requests to set the same values that are already active
      then return QMI_ERR_NO_EFFECT_V01 */
    if(req_msg.autoconnect_roam_setting  == (uint8)rmnet_meta_sm_get_autoconnect_roam_setting(
                                            wds_sp->binding.rmnet_inst))
    {
      errval = QMI_ERR_NO_EFFECT_V01;
    }
  }
  else
  {
    req_msg.autoconnect_roam_setting  = (uint8)rmnet_meta_sm_get_autoconnect_roam_setting(
                                            wds_sp->binding.rmnet_inst);
  }

  /*-----------------------------------------------------------------------
    Requests to set the same values that are already active
    then return QMI_ERR_NO_EFFECT_V01
  -----------------------------------------------------------------------*/
  if(req_msg.autoconnect_setting ==
         (uint8)rmnet_meta_sm_get_autoconnect_setting(wds_sp->binding.rmnet_inst))
  {
    if((QMI_ERR_NO_EFFECT_V01== errval) || (!req_msg.autoconnect_roam_setting_valid))
    {
      LOG_MSG_ERROR_0("Requests to set the autoconnect values that are already active");
      errval = QMI_ERR_NO_EFFECT_V01;
      goto send_result;
    }
  }

  /*-----------------------------------------------------------------------
    Set new autoconnect and roam settings.
  -----------------------------------------------------------------------*/
  errval = QMI_ERR_NONE_V01;
  if (FALSE == rmnet_meta_sm_set_autoconnect_setting(
                wds_sp->binding.rmnet_inst,
                (rmnet_meta_sm_autoconnect_setting_e_type)req_msg.autoconnect_setting,
                (rmnet_meta_sm_autoconnect_roam_setting_e_type)req_msg.autoconnect_roam_setting))
  {
    LOG_MSG_ERROR_0("Could not set autoconnect settings");
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  /*-----------------------------------------------------------------------
    Start or stop the data call based on new autoconnect and roam settings.
  -----------------------------------------------------------------------*/
  if (QMI_WDS_AUTOCONNECT_DISABLED == req_msg.autoconnect_setting ||
      QMI_WDS_AUTOCONNECT_PAUSED   == req_msg.autoconnect_setting )
  {
    /*-----------------------------------------------------------------------
      If no other client has the net interface started &&
      Autoconnect is disabled  release it
    -----------------------------------------------------------------------*/
    if ((!qmi_wdsi_net_if_bound( wds_sp )) &&
        (rmnet_meta_sm_is_auto_connect_enabled(
                                 wds_sp->binding.rmnet_inst) == FALSE))
    {
      if (rmnet_meta_sm_in_call(wds_sp->binding.rmnet_inst))
      {
        LOG_MSG_INFO2_0("Last client releases RmNet call");

        /*---------------------------------------------------------------------
          Post event to WWAN RMSM to end call.
        ---------------------------------------------------------------------*/
        rmnet_meta_sm_post_event(wds_sp->binding.rmnet_inst,
                                 RMNET_META_SM_RM_LINK_DOWN_EV);
      }
      else
      {
        LOG_MSG_INFO2_0("Rm iface already down");
      }
    }
    else
    {
      LOG_MSG_INFO2_0("Network interface left up for other clients");
    }
  }
  else if (QMI_WDS_AUTOCONNECT_ENABLED == req_msg.autoconnect_setting)
  {
    /*-----------------------------------------------------------------------
      If no other client has the net interface started &&
      Autoconnect is enabled then bring up the call
    -----------------------------------------------------------------------*/
    if ((!qmi_wdsi_net_if_bound( wds_sp )) &&
        (rmnet_meta_sm_is_auto_connect_enabled(
                                 wds_sp->binding.rmnet_inst) == TRUE))
    {
      if (!rmnet_meta_sm_in_call(wds_sp->binding.rmnet_inst))
      {
        /*---------------------------------------------------------------------
          Post event to WWAN RMSM to start call.
        ---------------------------------------------------------------------*/
        LOG_MSG_INFO1_0 ("Start rmnet call");
        rmnet_meta_sm_post_event(wds_sp->binding.rmnet_inst,
                                 RMNET_META_SM_RM_DEV_START_PKT_EV);
      }
      else
      {
        LOG_MSG_INFO2_0("Rm iface already started");
      }
    }
    else
    {
      LOG_MSG_INFO2_0("Network interface already up for other clients");
    }
  }
send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_AUTOCONNECT_SETTINGS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_autoconnect_setting() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_DNS_SETTING()

  DESCRIPTION
    Returns the current IPv4 and IPv6 DNS settings (primary and secondary).

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_dns_setting
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type * wds_sp;
  dsm_item_type *       response;
  wds_get_dns_settings_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;

  ip_addr_type       ipv4_pri_dns = {IP_ANY_ADDR, {0,}};
  ip_addr_type       ipv4_sec_dns = {IP_ANY_ADDR, {0,}};

  ip_addr_type       ipv6_pri_dns = {IP_ANY_ADDR, {0,}};
  ip_addr_type       ipv6_sec_dns = {IP_ANY_ADDR, {0,}};

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  /* Validate that request is not sent on reverse IP transport instance */
  if( wds_sp->binding.is_reversed ||
      wds_sp->binding.rmnet_inst >= RMNET_INSTANCE_MAX )
  {
    errval = QMI_ERR_INVALID_OPERATION_V01;
    LOG_MSG_ERROR_1("Request sent on non-binding instance %d "
            , wdsi_get_instance_from_wds_sp(sp));
    goto send_result;
  }

  /* Get current IPv4 DNS setting from RMNET */
  rmnet_meta_sm_get_ipv4_manual_dns_addrs(wds_sp->binding.rmnet_inst,
                                          &ipv4_pri_dns,
                                          &ipv4_sec_dns);

#ifdef FEATURE_DATA_PS_IPV6
  /* Get current IPv6 DNS setting from RMNET if supported */
  rmnet_meta_sm_get_ipv6_manual_dns_addrs(wds_sp->binding.rmnet_inst,
                                          &ipv6_pri_dns,
                                          &ipv6_sec_dns);
#endif /* FEATURE_DATA_PS_IPV6 */

  /* check that either value is set */
  /* if IPv6 is not enabled those addresses will still be empty and will not be
     returned */
  if ((IPV4_ADDR != ipv4_pri_dns.type) && (IPV4_ADDR != ipv4_sec_dns.type) &&
      (IPV6_ADDR != ipv6_pri_dns.type) && (IPV6_ADDR != ipv6_sec_dns.type))
  {
    LOG_MSG_ERROR_0("Manual DNS settings (pri/sec) inactive");
    errval = QMI_ERR_NOT_PROVISIONED_V01;
    goto send_result;
  }

  /* provide secondary IPv6 DNS address setting */
  if (IPV6_ADDR == ipv6_sec_dns.type)
  {
    resp_msg.secondary_dns_ipv6_address_valid = TRUE;
    memscpy(resp_msg.secondary_dns_ipv6_address,sizeof(resp_msg.secondary_dns_ipv6_address),
            ipv6_sec_dns.addr.v6,sizeof(ipv6_sec_dns.addr.v6));
  }

  /* provide primary IPv6 DNS address setting */
  if (IPV6_ADDR == ipv6_pri_dns.type)
  {
    resp_msg.primary_dns_ipv6_address_valid = TRUE;
    memscpy(resp_msg.primary_dns_ipv6_address,sizeof(resp_msg.primary_dns_ipv6_address),
            ipv6_pri_dns.addr.v6,sizeof(ipv6_pri_dns.addr.v6));
  }

  /* provide secondary IPv4 DNS address setting */
  if (IPV4_ADDR == ipv4_sec_dns.type)
  {
    resp_msg.secondary_dns_ipv4_address_valid = TRUE;
    resp_msg.secondary_dns_ipv4_address = ipv4_sec_dns.addr.v4;
  }

  /* provide primary IPv4 DNS address setting */
  if (IPV4_ADDR == ipv4_pri_dns.type)
  {
    resp_msg.primary_dns_ipv4_address_valid = TRUE;
    resp_msg.primary_dns_ipv4_address = ipv4_pri_dns.addr.v4;
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_DNS_SETTINGS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_dns_setting() */


/*===========================================================================
  FUNCTION QMI_WDSI_SET_DNS_SETTING()

  DESCRIPTION
   Sets the current IPv4 and IPv6 DNS settings (primary and secondary).

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_dns_setting
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type * wds_sp;
  qmi_wdsi_client_state_type *  wds_cl_sp;
  dsm_item_type *       response;
  wds_set_dns_settings_req_msg_v01 req_msg;
  wds_set_dns_settings_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;

  ip_addr_type       ipv4_pri_dns = {IPV4_ADDR, {0,}};
  ip_addr_type       ipv4_sec_dns = {IPV4_ADDR, {0,}};
  
  ip_addr_type       ipv6_pri_dns = {IPV6_ADDR, {0,}};
  ip_addr_type       ipv6_sec_dns = {IPV6_ADDR, {0,}};

  ip_addr_type       *ipv4_pri_dns_ptr;
  ip_addr_type       *ipv4_sec_dns_ptr;
  ip_addr_type       *ipv6_pri_dns_ptr;
  ip_addr_type       *ipv6_sec_dns_ptr;

  rmnet_instance_e_type rmnet_instance2;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  wds_cl_sp = (qmi_wdsi_client_state_type *) cl_sp;

  response          = NULL;
  errval            = QMI_ERR_NONE_V01;

  ipv4_pri_dns_ptr = NULL;
  ipv4_sec_dns_ptr = NULL;
  ipv6_pri_dns_ptr = NULL;
  ipv6_sec_dns_ptr = NULL;

  rmnet_instance2 = RMNET_INSTANCE_MIN;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  /* Validate that request is not sent on reverse IP transport instance */
  if( wds_sp->binding.is_reversed ||
      wds_sp->binding.rmnet_inst >= RMNET_INSTANCE_MAX )
  {
    errval = QMI_ERR_INVALID_OPERATION_V01;
    LOG_MSG_ERROR_1("Request sent on non-binding instance %d "
            , wdsi_get_instance_from_wds_sp(sp));
    goto send_result;
  }
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_DNS_SETTINGS_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
    {
      goto send_result;
    }
  if (( !req_msg.primary_dns_ipv4_address_valid ) && ( !req_msg.secondary_dns_ipv4_address_valid ) && 
      ( !req_msg.primary_dns_ipv6_address_valid ) && ( !req_msg.secondary_dns_ipv6_address_valid))
  {
    LOG_MSG_ERROR_0("No optional TLV's specified");
    errval = QMI_ERR_MISSING_ARG_V01;
    goto send_result;
  }

  /* Get current IPv4 DNS setting from RMNET */
  rmnet_meta_sm_get_ipv4_manual_dns_addrs(wds_sp->binding.rmnet_inst,
                                          &ipv4_pri_dns,
                                          &ipv4_sec_dns);

  /* for each TLV value specified, check that the address is either not
     currently set (type != IPV4) or that if it is valid that it is different
     that the requested value */
  if ((req_msg.primary_dns_ipv4_address_valid ) && ((IPV4_ADDR != ipv4_pri_dns.type) ||
              (req_msg.primary_dns_ipv4_address != ipv4_pri_dns.addr.v4)))
  {
    /* update IP struct with new IPv4 address */
    ipv4_pri_dns.type    = IPV4_ADDR;
    ipv4_pri_dns.addr.v4 = req_msg.primary_dns_ipv4_address;
    /* set the pointer to this struct addr so that it will be updated */
    ipv4_pri_dns_ptr     = &ipv4_pri_dns;
  }
  if ((req_msg.secondary_dns_ipv4_address_valid) && ((IPV4_ADDR != ipv4_sec_dns.type) ||
              (req_msg.secondary_dns_ipv4_address != ipv4_sec_dns.addr.v4)))
  {
    /* update IP struct with new IPv4 address */
    ipv4_sec_dns.type    = IPV4_ADDR;
    ipv4_sec_dns.addr.v4 = req_msg.secondary_dns_ipv4_address;
    /* set the pointer to this struct addr so that it will be updated */
    ipv4_sec_dns_ptr = &ipv4_sec_dns;
  }

  /* Get current IPv6 DNS setting from RMNET */
  rmnet_meta_sm_get_ipv6_manual_dns_addrs(wds_sp->binding.rmnet_inst,
                                          &ipv6_pri_dns,
                                          &ipv6_sec_dns);

  /* for each TLV value specified, check that the address is either not
     currently set (type != IPV6) or that if it is valid that it is different
     that the requested value */
  if ((req_msg.primary_dns_ipv6_address_valid ) && ((IPV6_ADDR != ipv6_pri_dns.type) ||
      (memcmp(req_msg.primary_dns_ipv6_address,ipv6_pri_dns.addr.v6,sizeof(ipv6_pri_dns.addr.v6)))))
  {
    /* update IP struct with new IPv6 address */
    ipv6_pri_dns.type       = IPV6_ADDR;
    memscpy(ipv6_pri_dns.addr.v6,sizeof(ipv6_pri_dns.addr.v6),
           req_msg.primary_dns_ipv6_address,sizeof(req_msg.primary_dns_ipv6_address));
    /* set the pointer to this struct addr so that it will be updated */
    ipv6_pri_dns_ptr        = &ipv6_pri_dns;
  }
  if ((req_msg.secondary_dns_ipv6_address_valid) && ((IPV6_ADDR != ipv6_sec_dns.type) ||
      (memcmp(req_msg.secondary_dns_ipv6_address,ipv6_sec_dns.addr.v6,sizeof(ipv6_sec_dns.addr.v6)))))
  {
    /* update IP struct with new IPv6 address */
    ipv6_sec_dns.type       = IPV6_ADDR;
    memscpy(ipv6_sec_dns.addr.v6,sizeof(ipv6_sec_dns.addr.v6),
           req_msg.secondary_dns_ipv6_address,sizeof(req_msg.secondary_dns_ipv6_address));

    /* set the pointer to this struct addr so that it will be updated */
    ipv6_sec_dns_ptr        = &ipv6_sec_dns;
  }

  /* check that at least one DNS values must change, else return NO_EFFECT */
  if ((NULL == ipv4_pri_dns_ptr) && (NULL == ipv4_sec_dns_ptr) && 
      (NULL == ipv6_pri_dns_ptr) && (NULL == ipv6_sec_dns_ptr))
  {
    errval = QMI_ERR_NO_EFFECT_V01;
    goto send_result;
  }

  /* need to set IPv6 addresses on both instances (IPv4+6 and IPv6-only) to keep
     them in sync */
  rmnet_instance2 = wds_sp->binding.rmnet_inst;
  if (wds_cl_sp->current_wds_state == WDSI_IPV4_STATE)
  {
    /* currently on IPv4+6 instance, 2nd instance is IPv6-only */
    rmnet_instance2++;
  }
  else
  {
    /* currently on IPv6-only instance, 2nd instance is IPv4+6 */
    rmnet_instance2--;
  }

  /* update the new IPv4 DNS values */
  if ((NULL != ipv4_pri_dns_ptr) || (NULL != ipv4_sec_dns_ptr))
  {
    LOG_MSG_INFO2_2("Setting IPv4: pri=%p sec=%p",
                    ipv4_pri_dns_ptr, ipv4_sec_dns_ptr);
    
    if (-1 == rmnet_meta_sm_set_ipv4_manual_dns_addrs(
                                               wds_sp->binding.rmnet_inst,
                                               ipv4_pri_dns_ptr,
                                               ipv4_sec_dns_ptr))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
    if (-1 == rmnet_meta_sm_set_ipv4_manual_dns_addrs(
                                               rmnet_instance2,
                                               ipv4_pri_dns_ptr,
                                               ipv4_sec_dns_ptr))
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }

  /* update the new IPv6 DNS values */
  if ((NULL != ipv6_pri_dns_ptr) || (NULL != ipv6_sec_dns_ptr))
  {
    LOG_MSG_INFO2_2("Setting IPv6: pri=%p sec=%p",
                    ipv6_pri_dns_ptr, ipv6_sec_dns_ptr);
    
    if (-1 == rmnet_meta_sm_set_ipv6_manual_dns_addrs(
                                               wds_sp->binding.rmnet_inst,
                                               ipv6_pri_dns_ptr,
                                               ipv6_sec_dns_ptr))
    {
      LOG_MSG_ERROR_2("Manual IPv6 DNS settings (pri/sec) not set (ep_id=%d) (mux_id=%d)",
                    wds_sp->binding.ep_id,wds_sp->binding.mux_id);
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
    if (-1 == rmnet_meta_sm_set_ipv6_manual_dns_addrs(
                                               rmnet_instance2,
                                               ipv6_pri_dns_ptr,
                                               ipv6_sec_dns_ptr))
    {
      LOG_MSG_ERROR_1("Manual IPv6 DNS settings (pri/sec) not set (ep_id=%d)",
                    wds_sp->binding.ep_id);
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }

send_result:
  if(errval != QMI_ERR_NONE_V01)
  {
    LOG_MSG_ERROR_1("qmi_wdsi_set_dns_setting: errval:%d",errval);
  }
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_DNS_SETTINGS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_dns_setting() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_CALL_DURATION()

  DESCRIPTION
    Retrive the current call duration (in milliseconds)

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_call_duration
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *         wds_sp;
  dsm_item_type *               response;
  wds_get_call_duration_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;

  time_type   call_duration;
  time_type   curr_time;
  time_type   invalid_time;
  ps_iface_type        *ps_iface_ptr;
  ps_phys_link_type    *phys_link_ptr;
  boolean              iface_valid, physlink_valid;
  qmi_wdsi_client_state_type *   client_sp;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  iface_valid = FALSE;
  physlink_valid = FALSE;
  memset(&resp_msg,0,sizeof(resp_msg));
  /*-------------------------------------------------------------------------
    Check whether the call is up or not
  -------------------------------------------------------------------------*/
  if ( wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED )
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;

    qw_set(invalid_time,
           QMI_WDSI_CALL_DURATION_INVALID_DW,
           QMI_WDSI_CALL_DURATION_INVALID_DW);
    if (QMI_WDSI_QW_CMP_EQUAL != qw_cmp(wds_sp->last_call_active_duration,
                                        invalid_time))
    {
      resp_msg.last_call_active_duration_valid = TRUE;
      memscpy(&resp_msg.last_call_active_duration,sizeof(resp_msg.last_call_active_duration),
                &wds_sp->last_call_active_duration,sizeof(wds_sp->last_call_active_duration));
    }

    /* Don't return last call duration if the value is invalid */
    if (QMI_WDSI_QW_CMP_EQUAL != qw_cmp(wds_sp->last_call_duration,
                                        invalid_time))
    {
      resp_msg.last_call_duration_valid = TRUE;
      memscpy(&resp_msg.last_call_duration,sizeof(resp_msg.last_call_duration),
                &wds_sp->last_call_duration,sizeof(wds_sp->last_call_duration));
    }
  }
  else
  {
    time_get_uptime_ms( curr_time );

    ps_iface_ptr = rmnet_meta_sm_get_um_iface(wds_sp->binding.rmnet_inst);
    phys_link_ptr = PS_IFACE_GET_PHYS_LINK(ps_iface_ptr);

    iface_valid = PS_IFACE_IS_VALID(ps_iface_ptr);
    physlink_valid = PS_PHYS_LINK_IS_VALID(phys_link_ptr);

    if( !(iface_valid && physlink_valid) )
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }

    if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                     TRUE))
    {
     LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                      " Client subs %d Call subs %d", client_sp->subscription_id,
                       wds_sp->binding.subscription_id );
      errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
      goto send_result;
    }  

    if (PHYS_LINK_UP == PS_PHYS_LINK_GET_STATE(phys_link_ptr))
    {
      /* We are active, so add the current active session's time to the total */
      qw_sub(call_duration, curr_time, wds_sp->last_active_start_time);
      qw_add(call_duration, call_duration, wds_sp->total_active_time);
    }
    else
    {
      /* We are dormant (or neither active nor dormant) so just use total_active_time */
      qw_equ(call_duration, wds_sp->total_active_time);
    }
    resp_msg.call_active_duration_valid = TRUE;
    memscpy(&resp_msg.call_active_duration,sizeof( resp_msg.call_active_duration),
                &call_duration,sizeof(call_duration));

    qw_sub(call_duration, curr_time, wds_sp->call_connect_time);
    memscpy(&resp_msg.call_duration,sizeof(resp_msg.call_duration),
                &call_duration,sizeof(call_duration));
  }

send_result:
  if(errval !=  QMI_ERR_NONE_V01)
  {
    LOG_MSG_INFO1_3("qmi_wdsi_get_call_duration: errval: %d, iface_valid: %d, physlink_valid: %d", 
                   errval, iface_valid, physlink_valid);
  }
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_CALL_DURATION_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_call_duration() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_CURRRENT_DATA_BEARER_TECHNOLOGY()

  DESCRIPTION
    Retrive the current data bearer technology

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_current_data_bearer_technology
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *               wds_sp;
  dsm_item_type *                     response;
  wds_get_current_data_bearer_technology_resp_msg_v01 resp_msg;
  qmi_wdsi_curr_data_bearer_tech_type v_out_data_bearer_tech;
  qmi_error_type_v01 errval;
  qmi_wdsi_client_state_type * client_sp;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  memset((void *)&v_out_data_bearer_tech, 0, sizeof(v_out_data_bearer_tech));
  memset(&resp_msg,0,sizeof(resp_msg));
  /*-------------------------------------------------------------------------
    Build the response from back to front
  -------------------------------------------------------------------------*/
  response = NULL;
  errval = QMI_ERR_NONE_V01;

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  if ( wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED )
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
#ifdef FEATURE_DATA_WLAN_MAPCON
    if (!wds_sp->is_last_data_bearer_cache_set)
    {
      LOG_MSG_INFO2_0("Cached data bearer not set, do not include opt TLV");
    }
    else
    {
      wdsi_get_current_data_bearer_tech(wds_sp->last_data_bearer_cache, &v_out_data_bearer_tech);
      resp_msg.last_bearer_tech_valid = TRUE;
      LOG_MSG_INFO2_0("Cached data bearer set, include opt TLV");
    }
#else
    v_out_data_bearer_tech = wds_sp->last_data_bearer_cache;
    if (TRUE == wdsi_data_bearer_tech_is_valid(v_out_data_bearer_tech))
    {
      resp_msg.last_bearer_tech_valid = TRUE;
      LOG_MSG_INFO2_0("Cached data bearer set, include opt TLV");
    }
    else
    {
      LOG_MSG_INFO2_1("Cached data bearer: %d is invlaid, do not include opt TLV",v_out_data_bearer_tech);
    }
#endif /* FEATURE_DATA_WLAN_MAPCON */
    if(resp_msg.last_bearer_tech_valid == TRUE)
    {
      resp_msg.last_bearer_tech.current_nw = (wds_current_nw_enum_v01)v_out_data_bearer_tech.current_nw;
      resp_msg.last_bearer_tech.rat_mask = v_out_data_bearer_tech.rat_mask;
      resp_msg.last_bearer_tech.so_mask = v_out_data_bearer_tech.so_mask;
    }
    goto send_result;
  }

  // If call is up on a different subs reject the request.
  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
    LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  /*get the cached current data bearer data*/
#ifdef FEATURE_DATA_WLAN_MAPCON
  wdsi_get_current_data_bearer_tech(wds_sp->curr_data_bearer_cache, &v_out_data_bearer_tech);
#else
  v_out_data_bearer_tech = wds_sp->curr_data_bearer_cache;
#endif /* FEATURE_DATA_WLAN_MAPCON */
  resp_msg.current_bearer_tech.current_nw = (wds_current_nw_enum_v01)
                               v_out_data_bearer_tech.current_nw;
  resp_msg.current_bearer_tech.rat_mask = v_out_data_bearer_tech.rat_mask;
  resp_msg.current_bearer_tech.so_mask = v_out_data_bearer_tech.so_mask;

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_CURRENT_DATA_BEARER_TECHNOLOGY_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_current_data_bearer_technology() */

#ifdef FEATURE_DATA_WLAN_MAPCON
/*===========================================================================
  FUNCTION QMI_WDSI_GET_DATA_BEARER_TECHNOLOGY_EX()

  DESCRIPTION
    Retrive the current data bearer technology in new format

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_data_bearer_technology_ex
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *               wds_sp;
  dsm_item_type *                     response;
  wds_get_data_bearer_technology_ex_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
  qmi_wdsi_client_state_type *        client_sp;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  memset(&resp_msg,0,sizeof(resp_msg));
  response = NULL;
  errval = QMI_ERR_NONE_V01;

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  if ( wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED )
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    if (wds_sp->is_last_data_bearer_cache_set) 
    {
      resp_msg.last_bearer_tech_valid = TRUE;
      resp_msg.last_bearer_tech.technology = (wds_bearer_tech_network_enum_v01)
                     wds_sp->last_data_bearer_cache.technology;
      resp_msg.last_bearer_tech.rat_value = (wds_bearer_tech_rat_ex_enum_v01)
                     wds_sp->last_data_bearer_cache.rat_value;
      resp_msg.last_bearer_tech.so_mask = wds_sp->last_data_bearer_cache.so_mask;
    }
    goto send_result;
  }

  // If call is up on a different subs reject the request.
  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
    LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  /*get the cached current data bearer data*/
  resp_msg.bearer_tech_valid = TRUE;
  resp_msg.bearer_tech.technology = (wds_bearer_tech_network_enum_v01)
                    wds_sp->curr_data_bearer_cache.technology;
  resp_msg.bearer_tech.rat_value = (wds_bearer_tech_rat_ex_enum_v01)
                    wds_sp->curr_data_bearer_cache.rat_value;
  resp_msg.bearer_tech.so_mask = wds_sp->curr_data_bearer_cache.so_mask;

send_result:

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_DATA_BEARER_TECHNOLOGY_EX_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_data_bearer_technology_ex() */
#endif /* FEATURE_DATA_WLAN_MAPCON */

/*===========================================================================
  FUNCTION QMI_WDSI_EMBMS_TMGI_ACTIVATE()

  DESCRIPTION
    Activate eMBMS TMGI.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_embms_tmgi_activate
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type * wds_sp;
  dsm_item_type *       response;
  wds_embms_tmgi_activate_req_msg_v01 req_msg;
  wds_embms_tmgi_activate_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;

  int                   return_val = 0;
  int16                 ps_errno = DS_ENOERR;

  ps_iface_earfcn_type      ps_earfcn_list[WDSI_MAX_TMGI_EARFCN];
  int                       i;

  ps_iface_embms_tmgi_act_req_type  ps_tmgi_act;
#ifdef FEATURE_DATA_EMBMS
  ps_iface_embms_sai_type   ps_sai_list[WDSI_MAX_SAI];
#endif /* FEATURE_DATA_EMBMS */
  qmi_wdsi_client_state_type * client_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  response = NULL;
  errval = QMI_ERR_NONE_V01;

  memset(&ps_tmgi_act, 0, sizeof(ps_tmgi_act));
  memset(ps_earfcn_list, 0, sizeof(ps_earfcn_list));
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_EMBMS_TMGI_ACTIVATE_REQ_V01,
                                       sdu_in,
                                      &req_msg,
                                      sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  if (req_msg.earfcn_list_valid && req_msg.earfcn_list_ex_valid)
  {
    //Either 16 bit or 32 bit frequency values can be
    //specified, but not both
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  // Check if the eMBMS call is up
  if ( (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED) ||
       (wds_sp->is_embms_inst != TRUE) )
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d", client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  if (req_msg.earfcn_list_len > WDSI_MAX_TMGI_EARFCN || 
      req_msg.earfcn_list_ex_len > WDSI_MAX_TMGI_EARFCN)
  {
    errval = QMI_ERR_MALFORMED_MSG_V01;
    goto send_result;
  }

#ifdef FEATURE_DATA_EMBMS
  if (req_msg.sai_list_len > WDSI_MAX_SAI)
  {
    errval = QMI_ERR_MALFORMED_MSG_V01;
    goto send_result;
  }
#endif /* FEATURE_DATA_EMBMS */

  // Call ioctl to activate TMGI. Use cl_sp as client_id.
  ps_tmgi_act.client_id = cl_sp;

  memscpy(ps_tmgi_act.tmgi_session_info.tmgi,
          sizeof(ps_tmgi_act.tmgi_session_info.tmgi),
          req_msg.tmgi.tmgi, 
          sizeof(req_msg.tmgi.tmgi));
  ps_tmgi_act.tmgi_session_info.session_id_present =
                        req_msg.tmgi.session_id_valid ? TRUE : FALSE;
  ps_tmgi_act.tmgi_session_info.session_id = req_msg.tmgi.session_id;
  if(req_msg.tranx_id_valid)
  {
    ps_tmgi_act.debug_trace_id = req_msg.tranx_id;
  }
  else
  {
    ps_tmgi_act.debug_trace_id = -1;
  }

  if(req_msg.preempt_priority_valid)
  {
    ps_tmgi_act.preempt_priority = req_msg.preempt_priority;
  }

  if (req_msg.earfcn_list_valid)
  {
    ps_tmgi_act.num_earfcn_to_search = req_msg.earfcn_list_len;
    for (i = 0; i < req_msg.earfcn_list_len; i++)
    {
      ps_earfcn_list[i] = (uint32)req_msg.earfcn_list[i].earfcn;
    }
  } 

  if (req_msg.earfcn_list_ex_valid)
  {
    ps_tmgi_act.num_earfcn_to_search = req_msg.earfcn_list_ex_len;
    for (i = 0; i < req_msg.earfcn_list_ex_len; i++)
    {
      ps_earfcn_list[i] = req_msg.earfcn_list_ex[i];
    }
  }
  ps_tmgi_act.earfcn_list = ps_earfcn_list;

#ifdef FEATURE_DATA_EMBMS
  if(req_msg.sai_list_valid)
  {
    ps_tmgi_act.num_sai_to_search = req_msg.sai_list_len;
    for (i = 0; i < req_msg.sai_list_len; i++)
    {
      ps_sai_list[i] = (uint16)req_msg.sai_list[i];
    }
    ps_tmgi_act.sai_list = ps_sai_list;
  }
#endif /* FEATURE_DATA_EMBMS */

  return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                              PS_IFACE_IOCTL_EMBMS_ACTIVATE_TMGI,
                              &ps_tmgi_act,
                              &ps_errno);

  // If failed, send extended error code TLV
  if (return_val != 0)
  {
    errval = QMI_ERR_EXTENDED_INTERNAL_V01;
    resp_msg.extended_error_code_valid = TRUE;
    resp_msg.extended_error_code = ps_errno;
  }

send_result:
#ifdef FEATURE_DATA_EMBMS
  if(errval != QMI_ERR_NONE_V01)
  {
    LOG_MSG_INFO2_3("qmi_wdsi_embms_tmgi_activate: errval: %d, SAI: %d, earfcn_list.num_earfcn: %d", 
                    errval, req_msg.sai_list_len, req_msg.earfcn_list_len);
  }
#endif
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_EMBMS_TMGI_ACTIVATE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_embms_tmgi_activate() */

/*===========================================================================
  FUNCTION QMI_WDSI_EMBMS_TMGI_DEACTIVATE()

  DESCRIPTION
    Deactivate eMBMS TMGI.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_embms_tmgi_deactivate
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type * wds_sp;
  dsm_item_type *       response;
  wds_embms_tmgi_deactivate_req_msg_v01 req_msg;
  wds_embms_tmgi_deactivate_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;

  int                   return_val = 0;
  int16                 ps_errno = DS_ENOERR;
  ps_iface_embms_tmgi_deact_req_type  ps_tmgi_deact;
  qmi_wdsi_client_state_type * client_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  response = NULL;
  errval = QMI_ERR_NONE_V01;

  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_EMBMS_TMGI_DEACTIVATE_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  // Check if the eMBMS call is up
  if ( (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED) ||
       (wds_sp->is_embms_inst != TRUE) )
  {
    LOG_MSG_INFO2_0("eMBMS Call not up. Cannot deactivate TMGI" );
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d", client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  // Call ioctl to deactivate TMGI. Use cl_sp as client_id
  ps_tmgi_deact.client_id = cl_sp;

  memscpy(ps_tmgi_deact.tmgi_session_info.tmgi,
      sizeof(ps_tmgi_deact.tmgi_session_info.tmgi),
      req_msg.tmgi.tmgi, 
      sizeof(req_msg.tmgi.tmgi));

  ps_tmgi_deact.tmgi_session_info.session_id_present =
                       req_msg.tmgi.session_id_valid ? TRUE : FALSE;
  ps_tmgi_deact.tmgi_session_info.session_id = req_msg.tmgi.session_id;

  if(req_msg.tranx_id_valid)
  {
    ps_tmgi_deact.debug_trace_id = req_msg.tranx_id;
  }
  else
  {
    ps_tmgi_deact.debug_trace_id =  -1;
  }

  return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                              PS_IFACE_IOCTL_EMBMS_DEACTIVATE_TMGI,
                              &ps_tmgi_deact,
                              &ps_errno);

  // If failed, send extended error code TLV
  if (return_val != 0)
  {
    errval = QMI_ERR_EXTENDED_INTERNAL_V01;
    resp_msg.extended_error_code_valid = TRUE;
    resp_msg.extended_error_code = ps_errno;
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_EMBMS_TMGI_DEACTIVATE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_embms_tmgi_deactivate() */

/*===========================================================================
  FUNCTION QMI_WDSI_EMBMS_TMGI_ACT_DEACT()

  DESCRIPTION
    Activate and deactivate eMBMS TMGIs.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type* qmi_wdsi_embms_tmgi_act_deact
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type * wds_sp;
  dsm_item_type *       response;
  wds_embms_tmgi_act_deact_req_msg_v01 req_msg;
  wds_embms_tmgi_act_deact_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;

  int                   return_val = 0;
  int16                 ps_errno = DS_ENOERR;
  ps_iface_earfcn_type      ps_earfcn_list[WDSI_MAX_TMGI_EARFCN];
  int                       i;
  ps_iface_embms_tmgi_act_deact_req_type  ps_tmgi_act_deact;
#ifdef FEATURE_DATA_EMBMS
  ps_iface_embms_sai_type   ps_sai_list[WDSI_MAX_SAI];
#endif /* FEATURE_DATA_EMBMS */
  qmi_wdsi_client_state_type * client_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  response = NULL;
  errval = QMI_ERR_NONE_V01;

  memset(&ps_tmgi_act_deact, 0, sizeof(ps_tmgi_act_deact));
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_EMBMS_TMGI_ACT_DEACT_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  if (req_msg.earfcn_list_valid && req_msg.earfcn_list_ex_valid )
  {
    //Either 16 bit or 32 bit frequency values can be
    //specified, but not both
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  // Check if the eMBMS call is up
  if ( (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED) ||
       (wds_sp->is_embms_inst != TRUE) )
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d", client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  if (req_msg.earfcn_list_len > WDSI_MAX_TMGI_EARFCN || 
      req_msg.earfcn_list_ex_len > WDSI_MAX_TMGI_EARFCN)
  {
    errval = QMI_ERR_MALFORMED_MSG_V01;
    goto send_result;
  }

#ifdef FEATURE_DATA_EMBMS
  if (req_msg.sai_list_len > WDSI_MAX_SAI)
  {
    errval = QMI_ERR_MALFORMED_MSG_V01;
    goto send_result;
  }
#endif /* FEATURE_DATA_EMBMS */

  // Call ioctl to act_deact TMGI. Use cl_sp as client_id.
  ps_tmgi_act_deact.client_id = cl_sp;

  memscpy(ps_tmgi_act_deact.act_tmgi_session_info.tmgi,
          sizeof(ps_tmgi_act_deact.act_tmgi_session_info.tmgi),
          req_msg.act_tmgi.tmgi, 
          sizeof(req_msg.act_tmgi.tmgi));
  ps_tmgi_act_deact.act_tmgi_session_info.session_id_present =
                        req_msg.act_tmgi.session_id_valid ? TRUE : FALSE;
  ps_tmgi_act_deact.act_tmgi_session_info.session_id = req_msg.act_tmgi.session_id;

  memscpy(ps_tmgi_act_deact.deact_tmgi_session_info.tmgi,
          sizeof(ps_tmgi_act_deact.deact_tmgi_session_info.tmgi),
          req_msg.deact_tmgi.tmgi, 
          sizeof(req_msg.deact_tmgi.tmgi));
  ps_tmgi_act_deact.deact_tmgi_session_info.session_id_present =
                        req_msg.deact_tmgi.session_id_valid ? TRUE : FALSE;
  ps_tmgi_act_deact.deact_tmgi_session_info.session_id = req_msg.deact_tmgi.session_id;

  if(req_msg.tranx_id_valid)
  {
    ps_tmgi_act_deact.debug_trace_id = req_msg.tranx_id;
  }
  else
  {
    ps_tmgi_act_deact.debug_trace_id =  -1;
  }
  if(req_msg.preempt_priority_valid)
  {
    ps_tmgi_act_deact.preempt_priority = (uint8)req_msg.preempt_priority;
  }
  if (req_msg.earfcn_list_valid)
  {
    ps_tmgi_act_deact.num_earfcn_to_search = req_msg.earfcn_list_len;
    for (i = 0; i < req_msg.earfcn_list_len; i++)
    {
      ps_earfcn_list[i] = (uint32)req_msg.earfcn_list[i].earfcn;
    }      
  }

  if (req_msg.earfcn_list_ex_valid)
  {
    ps_tmgi_act_deact.num_earfcn_to_search = req_msg.earfcn_list_ex_len;
    for (i = 0; i < req_msg.earfcn_list_ex_len; i++)
    {
      ps_earfcn_list[i] = req_msg.earfcn_list_ex[i];
    }
  }
  ps_tmgi_act_deact.earfcn_list = ps_earfcn_list;

#ifdef FEATURE_DATA_EMBMS
  ps_tmgi_act_deact.num_sai_to_search = req_msg.sai_list_len;
  for (i = 0; i < req_msg.sai_list_len; i++)
  {
    ps_sai_list[i] = (uint16)req_msg.sai_list[i];
  }
  ps_tmgi_act_deact.sai_list = ps_sai_list;
#endif /* FEATURE_DATA_EMBMS */

  return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                              PS_IFACE_IOCTL_EMBMS_ACT_DEACT_TMGI,
                              &ps_tmgi_act_deact,
                              &ps_errno);

  // If failed, send extended error code TLV
  if (return_val != 0)
  {
    errval = QMI_ERR_EXTENDED_INTERNAL_V01;
    resp_msg.extended_error_code_valid = TRUE;
    resp_msg.extended_error_code = ps_errno;
  }

send_result:
#ifdef FEATURE_DATA_EMBMS
if (errval != QMI_ERR_NONE_V01)
{
  LOG_MSG_INFO2_3("qmi_wdsi_embms_tmgi_act_deact: errval:%d, EARFCN num: %d, sai_num: %d",
                   errval, req_msg.earfcn_list_len,req_msg.sai_list_len);

}
#endif
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_EMBMS_TMGI_ACT_DEACT_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_embms_tmgi_act_deact() */

/*===========================================================================
  FUNCTION QMI_WDSI_EMBMS_TMGI_LIST_QUERY()

  DESCRIPTION
    Query eMBMS TMGI list.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_embms_tmgi_list_query
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type * wds_sp;
  qmi_wdsi_client_state_type *client_sp;
  dsm_item_type *       response;
  wds_embms_tmgi_list_query_req_msg_v01 req_msg;
  wds_embms_tmgi_list_query_resp_msg_v01* resp_msg =  NULL;
  qmi_error_type_v01    errval;

  int                   return_val = 0;
  int16                 ps_errno = DS_ENOERR;
  uint8                 tmgi_list_type = 0;
  ps_iface_embms_tmgi_related_query_type ps_get_tmgi;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *) cl_sp;
  response = NULL;
  errval = QMI_ERR_NONE_V01;

  memset(&ps_get_tmgi, 0, sizeof(ps_get_tmgi));

  memset(&req_msg,0,sizeof(req_msg));
  PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg,
                           sizeof(wds_embms_tmgi_list_query_resp_msg_v01),
                           wds_embms_tmgi_list_query_resp_msg_v01*);
  if(resp_msg == NULL)
  {
    qmi_svc_put_result_tlv(&response, (qmi_result_e_type)QMI_RESULT_FAILURE_V01,
                           (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
    return response;
  }
  else
  {
    memset(resp_msg,0,sizeof(wds_embms_tmgi_list_query_resp_msg_v01));
  }

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_EMBMS_TMGI_LIST_QUERY_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  tmgi_list_type = req_msg.list_type;
  // Check TMGI list type
  if ( (tmgi_list_type != WDSI_TMGI_LIST_TYPE_ACTIVE) &&
       (tmgi_list_type != WDSI_TMGI_LIST_TYPE_AVAILABLE) &&
       (tmgi_list_type != WDSI_TMGI_LIST_TYPE_OOS_WARNING) )
  {
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }  

  // Check if eMBMS call is up
  if ( (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED) ||
       (wds_sp->is_embms_inst != TRUE) )
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d", client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  // Check if there are pending query requests
  if ( ((tmgi_list_type == WDSI_TMGI_LIST_TYPE_ACTIVE) &&
                          (client_sp->tmgi_active_list_cmd_buf_p != NULL)) ||
       ((tmgi_list_type == WDSI_TMGI_LIST_TYPE_AVAILABLE) &&
                          (client_sp->tmgi_avail_list_cmd_buf_p != NULL)) )
  {
    errval = QMI_ERR_NO_EFFECT_V01;
    goto send_result;
  }

  // Call ioctl to query TMGI list. Use cl_sp as client_id
  ps_get_tmgi.client_id = cl_sp;
  if(req_msg.tranx_id_valid)
  {
    ps_get_tmgi.debug_trace_id = req_msg.tranx_id;
  }
  else
  {
    ps_get_tmgi.debug_trace_id = -1;
  }

  if (tmgi_list_type == WDSI_TMGI_LIST_TYPE_ACTIVE)
  {
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_EMBMS_GET_ACTIVE_TMGI_LIST,
                                &ps_get_tmgi,
                                &ps_errno);
  }
  else if (tmgi_list_type == WDSI_TMGI_LIST_TYPE_AVAILABLE)
  {
    return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                                PS_IFACE_IOCTL_EMBMS_GET_AVAIL_TMGI_LIST,
                                &ps_get_tmgi,
                                &ps_errno);
  }
  else
  {
    errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
    goto send_result;
  }

  // If success, put the request in the pending queue.
  // We will send response upon TMGI list event.
  if (return_val == 0)
  {
    if (tmgi_list_type == WDSI_TMGI_LIST_TYPE_ACTIVE)
    {
      client_sp->tmgi_active_list_cmd_buf_p = cmd_buf_p;
    }
    else if (tmgi_list_type == WDSI_TMGI_LIST_TYPE_AVAILABLE)
    {
      client_sp->tmgi_avail_list_cmd_buf_p = cmd_buf_p;
    }
    PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
    return QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

send_result:
  if(errval != QMI_ERR_NONE_V01)
  {
    LOG_MSG_INFO2_3("qmi_wdsi_embms_tmgi_list_query: errval: %d, list type %d, ps_errno: %d", 
                     errval,tmgi_list_type,ps_errno);
  }

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_EMBMS_TMGI_LIST_QUERY_RESP_V01,
                               resp_msg,
                               sizeof(wds_embms_tmgi_list_query_resp_msg_v01),
                               errval,
                               &response);
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  return response;
} /* qmi_wdsi_embms_tmgi_list_query() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_PREFERRED_DATA_SYSTEM()

  DESCRIPTION
    Retrive the current preferred data system

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_preferred_data_system
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  wds_get_preferred_data_system_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;
  qmi_result_type_v01  result;
  ps_sys_system_status_type     conf_status_type;
  int16                         ps_errno = 0;
  uint32             pref_data_sys;
  uint32                        subs_id;
  qmi_wdsi_client_state_type *  client_sp;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  client_sp  = (qmi_wdsi_client_state_type *)cl_sp;
  subs_id    =  qmi_wdsi_resolve_client_subs(client_sp);
  /*-------------------------------------------------------------------------
    Retrieve data system status by calling into PS Sys Layer
  -------------------------------------------------------------------------*/
  result = ps_sys_conf_get_ex( PS_SYS_TECH_ALL,
                            PS_SYS_CONF_SYSTEM_STATUS,
                               (ps_sys_subscription_enum_type)subs_id,
                            (void *)&conf_status_type,
                            &ps_errno);
  if(result < 0)
  {
    LOG_MSG_ERROR_1("ps_sys_conf_get operation returned : (%d)", ps_errno);
    switch (ps_errno)
    {                                   
      case DS_NOMEMORY:
        errval = QMI_ERR_NO_MEMORY_V01;
        break;

      default:
        errval = QMI_ERR_INTERNAL_V01;
        break;
    } /*  switch (ps_errno) */
  }

  if (errval == QMI_ERR_NONE_V01)
  {
    uint32 rat_mask = (conf_status_type.preferred_network == PS_SYS_NETWORK_3GPP) ?
                          conf_status_type.network_info[PS_SYS_NETWORK_3GPP].rat_mask :
                          conf_status_type.network_info[PS_SYS_NETWORK_3GPP2].rat_mask;
    pref_data_sys = wdsi_xlate_data_system_status_to_pref_data_sys(
      (uint8)conf_status_type.preferred_network, rat_mask);
    resp_msg.current_sys_valid = TRUE;
    resp_msg.current_sys = pref_data_sys;
  }

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_PREFERRED_DATA_SYSTEM_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_preferred_data_system() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_LAST_DATA_CALL_STATUS()

  DESCRIPTION
    Retrive the last reported data call status

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_last_data_call_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *    response;
  wds_get_last_data_call_status_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  resp_msg.data_call_status_valid  = TRUE;
  resp_msg.data_call_status = (wds_data_call_status_change_enum_v01)
                              qmi_wdsi_global.last_data_call_status;
  resp_msg.data_call_addr_family_valid = TRUE;
  if ( (qmi_wdsi_global.last_data_call_addr_family == QMI_AF_INET) ||
       (qmi_wdsi_global.last_data_call_addr_family == QMI_AF_INET6) )
  {
    resp_msg.data_call_addr_family = (wds_data_call_addr_family_enum_v01)
                                    qmi_wdsi_global.last_data_call_addr_family;
  }
  else
  {
    resp_msg.data_call_addr_family = (wds_data_call_addr_family_enum_v01)QMI_AF_ANY;
  }
  switch (qmi_wdsi_global.last_data_call_type)
  {
    case WDSI_DATA_CALL_NONE:
    {
      resp_msg.data_call_type_valid = TRUE;
      resp_msg.data_call_type.data_call_type = WDSI_CALL_TYPE_NONE;
      resp_msg.data_call_type.tethered_call_type = WDSI_CALL_SUB_TYPE_NONE;
      break;
    }

    case WDSI_DATA_CALL_EMBEDDED:
    {
      resp_msg.data_call_type_valid = TRUE;
      resp_msg.data_call_type.data_call_type = WDSI_CALL_TYPE_EMBEDDED;
      resp_msg.data_call_type.tethered_call_type = WDSI_CALL_SUB_TYPE_NONE;
      break;
    }
          
    case WDSI_DATA_CALL_TETHERED_RMNET:
    {
      resp_msg.data_call_type_valid = TRUE;
      resp_msg.data_call_type.data_call_type = WDSI_CALL_TYPE_TETHERED;
      resp_msg.data_call_type.tethered_call_type = WDSI_CALL_SUB_TYPE_RMNET;
      break;
    }
    
    case WDSI_DATA_CALL_TETHERED_DUN:
    {
      resp_msg.data_call_type_valid = TRUE;
      resp_msg.data_call_type.data_call_type = WDSI_CALL_TYPE_TETHERED;
      resp_msg.data_call_type.tethered_call_type = WDSI_CALL_SUB_TYPE_DUN;
      break;
    }
    
    case WDSI_DATA_CALL_MODEM_EMBEDDED:
    {
      resp_msg.data_call_type_valid = TRUE;
      resp_msg.data_call_type.data_call_type  = WDSI_CALL_TYPE_MODEM_EMBEDDED;
      resp_msg.data_call_type.tethered_call_type = WDSI_CALL_SUB_TYPE_NONE;
      break;
    }
    
    default:
    {
      LOG_MSG_ERROR_1("Invalid data call enum type: %d",
                      qmi_wdsi_global.last_data_call_type);
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_LAST_DATA_CALL_STATUS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_last_data_call_status() */

/*===========================================================================
  FUNCTION QMI_WDSI_REFRESH_DHCP_CONFIG_INFO()

  DESCRIPTION
    Give the current traffic channel status

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_refresh_dhcp_config_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *  wds_sp;
  dsm_item_type *        response;
  wds_refresh_dhcp_config_info_resp_msg_v01 resp_msg;
  qmi_error_type_v01 errval;

  void *             dhcp_client_handle = NULL;
  uint32             ipv4_addr;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    Build the response from back to front
  -------------------------------------------------------------------------*/
  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  wds_sp = (qmi_wdsi_state_type *) sp;

  if ( wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED )
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  ASSERT ( wds_sp->um_iface_ptr );

  dhcp_client_handle = 
          ps_iface_get_dhcp_stateless_client_handle(wds_sp->um_iface_ptr);
  if (NULL == dhcp_client_handle)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  if (TRUE == ps_iface_addr_family_is_v4(wds_sp->um_iface_ptr))
  {
    /* Get already configured ip_addr */
    ipv4_addr = PS_IFACE_IP_V4_ADDR(wds_sp->um_iface_ptr);

    /* Trigger non-address config refresh */
    dhcp_client_inform(dhcp_client_handle, ipv4_addr);
  }
#ifdef FEATURE_DATA_PS_IPV6
  else if (TRUE == ps_iface_addr_family_is_v6(wds_sp->um_iface_ptr))
  {
    dhcp6_client_inform(dhcp_client_handle);
  }
#endif /* FEATURE_DATA_PS_IPV6 */
  else
  {
    LOG_MSG_INFO1_0("iface addr family does not match dhcp clients");
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

send_result:
  if(errval != QMI_ERR_NONE_V01)
  {
    LOG_MSG_INFO1_2("qmi_wdsi_refresh_dhcp_config_info: errval:%d, dhcp_handle: %x",
                     errval, ((dhcp_client_handle != NULL)?dhcp_client_handle:0));
  }

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_REFRESH_DHCP_CONFIG_INFO_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_refresh_dhcp_config_info */

/*===========================================================================
  FUNCTION QMI_WDSI_MT_REQUEST_IND()

  DESCRIPTION
    Is called when any of the iface events registered for occur.
    Sends an indication to the client.

  PARAMETERS
    wds_sp                : service provided state pointer
    index                 : index to the global mt handle list array

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_mt_request_ind
(
  qmi_wdsi_state_type *   wds_sp,
  uint8                   index
)
{
  dsm_item_type *               ind;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(wds_sp);

  /*-------------------------------------------------------------------------
    Build indication from the back to the front
  -------------------------------------------------------------------------*/
  ind = NULL;

  LOG_MSG_INFO2_2 ("MT Request iface event indication with handle(%d) for client(%d)",
                   wds_mt_handle_list[index].handle,
                   wds_mt_handle_list[index].cl_sp->common.clid);

  if(FALSE == qmi_svc_put_param_tlv(&ind,
                                    QMI_TYPE_REQUIRED_PARAMETERS,
                                    sizeof(ps_iface_mt_handle_type),
                                    &wds_mt_handle_list[index].handle))
  {
    HANDLE_IND_FAILURE();
  }

  (void)qmi_wdsi_send_ind( wds_sp,
                          wds_mt_handle_list[index].cl_sp,
                          WDSI_CMD_VAL_MT_REG_CB,
                          0,
                          ind,
                          FALSE );

} /* qmi_wdsi_mt_request_ind() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_PRE_DORMANCY_CDMA_SETTINGS()

  DESCRIPTION
    Returns the packet data session information before dormancy.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_pre_dormancy_cdma_settings
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_get_pre_dormancy_cdma_settings_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  int                   return_val;
  int16                 ps_errno = DS_ENOERR;
  ps_sys_ioctl_3gpp2_pre_dormancy_sys_info_type    dorm_info;
  uint32         subs_id;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  errval = QMI_ERR_NONE_V01;
  memset(&dorm_info, 0, sizeof(dorm_info));

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);

  return_val = ps_sys_ioctl_ex(PS_SYS_TECH_3GPP2,
                               PS_SYS_IOCTL_3GPP2_PRE_DORMANCY_SYS_INFO,
                               (ps_sys_subscription_enum_type)subs_id,
                               &dorm_info,
                               &ps_errno);


  if ( -1 == return_val )
  {
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
  }
  else
  {
    resp_msg.pre_dormancy_settings.service_option = dorm_info.service_option;
    resp_msg.pre_dormancy_settings.data_sess_nw = (wds_data_sess_nw_enum_v01)
                dorm_info.data_session_network;
  }
#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_PRE_DORMANCY_CDMA_SETTINGS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_pre_dormancy_cdma_settings() */

/*===========================================================================
  FUNCTION QMI_WDSI_SET_CAM_TIMER()

  DESCRIPTION
    Sets the Chatty App Manager timer value.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_set_cam_timer
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_set_cam_timer_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  int                   return_val;
  int16                 ps_errno = DS_ENOERR;
  wds_set_cam_timer_req_msg_v01 req_msg;
  uint32                subs_id;
  ps_sys_ioctl_3gpp2_cam_timer_type  ps_cam_timer;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  errval = QMI_ERR_NONE_V01;
  memset(&ps_cam_timer, 0, sizeof(ps_cam_timer));
  memset(&req_msg,0,sizeof(req_msg));
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_CAM_TIMER_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  ps_cam_timer = req_msg.cam_timer;

  return_val = ps_sys_ioctl_ex(PS_SYS_TECH_3GPP2,
                               PS_SYS_IOCTL_3GPP2_SET_CAM_TIMER,
                               (ps_sys_subscription_enum_type)subs_id,
                               &ps_cam_timer,
                               &ps_errno);

  if (-1 == return_val )
  {
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
  }
#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  goto send_result;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_CAM_TIMER_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_cam_timer() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_CAM_TIMER()

  DESCRIPTION
    Returns the the Chatty App Manager timer value.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_cam_timer
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_get_cam_timer_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  int                   return_val;
  int16                 ps_errno = DS_ENOERR;
  ps_sys_ioctl_3gpp2_cam_timer_type  ps_cam_timer = 0;
  uint32                 subs_id;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  errval = QMI_ERR_NONE_V01;

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);

  return_val = ps_sys_ioctl_ex(PS_SYS_TECH_3GPP2,
                               PS_SYS_IOCTL_3GPP2_GET_CAM_TIMER,
                               (ps_sys_subscription_enum_type)subs_id,
                               &ps_cam_timer,
                               &ps_errno);

  resp_msg.cam_timer = ps_cam_timer;

  if ( -1 == return_val )
  {
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
  }
#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_CAM_TIMER_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_cam_timer() */

/*===========================================================================
  FUNCTION QMI_WDSI_SET_SCRM()

  DESCRIPTION
    Disable/Enable the Supplemental Channel Request Message

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_set_scrm
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_set_scrm_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  int                   return_val;
  int16                 ps_errno = DS_ENOERR;
  uint32                subs_id = 0;
  ps_sys_ioctl_3gpp2_scrm_type ps_enable_scrm;
  wds_set_scrm_req_msg_v01 req_msg;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  errval = QMI_ERR_NONE_V01;
  memset(&ps_enable_scrm, 0, sizeof(ps_enable_scrm));
  memset(&req_msg,0,sizeof(req_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_SCRM_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  if ( (req_msg.scrm != 0) && (req_msg.scrm != 1) )
  {
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }
  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  ps_enable_scrm = req_msg.scrm;

  return_val = ps_sys_ioctl_ex(PS_SYS_TECH_3GPP2,
                               PS_SYS_IOCTL_3GPP2_SET_SCRM,
                               (ps_sys_subscription_enum_type)subs_id,
                               &ps_enable_scrm,
                               &ps_errno);

  if (-1 == return_val )
  {
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
  }
#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  goto send_result;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_SCRM_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_scrm() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_SCRM()

  DESCRIPTION
    Returns if SCRM support is enabled or disabled.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_scrm
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_get_scrm_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  int                   return_val;
  int16                 ps_errno = DS_ENOERR;
  uint32                subs_id;
  ps_sys_ioctl_3gpp2_scrm_type ps_enable_scrm;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  errval = QMI_ERR_NONE_V01;

  memset(&ps_enable_scrm, 0, sizeof(ps_enable_scrm));
  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);

  return_val = ps_sys_ioctl_ex(PS_SYS_TECH_3GPP2,
                               PS_SYS_IOCTL_3GPP2_GET_SCRM,
                               (ps_sys_subscription_enum_type)subs_id,
                               &ps_enable_scrm,
                               &ps_errno);

  if ( -1 == return_val )
  {
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
  }
  else
  {
    resp_msg.scrm = ps_enable_scrm ? 1 : 0;
  }
#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_SCRM_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_scrm() */

/*===========================================================================
  FUNCTION QMI_WDSI_SET_RDUD()

  DESCRIPTION
    Disable/Enable Reduced Dormancy followed by Unsolicited Data.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_set_rdud
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_set_rdud_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  int                   return_val;
  int16                 ps_errno = DS_ENOERR;
  uint32                subs_id;
  ds_sys_ioctl_3gpp2_rdud_type  ps_rdud;
  wds_set_rdud_req_msg_v01 req_msg;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  errval = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_RDUD_REQ_V01,
                                       sdu_in,
                                      &req_msg,
                                      sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  if ( (req_msg.rdud != 0) && (req_msg.rdud != 1) )
  {
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  ps_rdud = req_msg.rdud;

  return_val = ps_sys_ioctl_ex(PS_SYS_TECH_3GPP2,
                               PS_SYS_IOCTL_3GPP2_SET_RDUD,
                               (ps_sys_subscription_enum_type)subs_id,
                               &ps_rdud,
                               &ps_errno);

  if (-1 == return_val )
  {
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
  }
#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  goto send_result;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_RDUD_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_rdud() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_RDUD()

  DESCRIPTION
    Returns whether Reduced Dormancy followed by Unsolicited Data is 
    enabled or disabled.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_rdud
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_get_rdud_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  int                   return_val;
  int16                ps_errno = DS_ENOERR;
  ps_sys_ioctl_3gpp2_rdud_type  ps_rdud = 0;
  uint32 subs_id;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  errval = QMI_ERR_NONE_V01;

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  return_val = ps_sys_ioctl_ex(PS_SYS_TECH_3GPP2,
                               PS_SYS_IOCTL_3GPP2_GET_RDUD,
                               (ps_sys_subscription_enum_type)subs_id,
                               &ps_rdud,
                               &ps_errno);

  if ( -1 == return_val )
  {
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
  }
  else
  {
    resp_msg.rdud = ps_rdud;
  }
#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_RDUD_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_rdud() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_SIP_MIP_CALL_TYPE()

  DESCRIPTION
    Returns the type of data call that is up, SIP, MIP or none

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_sip_mip_call_type
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type * wds_sp;
  dsm_item_type *       response;
  wds_get_sip_mip_call_type_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;
  int                   return_val;
  sint15                ps_errno;

  ps_iface_ioctl_sip_mip_data_call_enum_type   sip_mip_call_type = 
                                                 PS_IFACE_IOCTL_DATA_CALL_TYPE_NONE;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));

  /*-------------------------------------------------------------------------
    Check whether the call is up or not
  -------------------------------------------------------------------------*/
  if (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED)
  {
    LOG_MSG_INFO2_0("Not in a call, cannot get SIP/MIP call type");
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  ASSERT (wds_sp->um_iface_ptr);

  return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                              PS_IFACE_IOCTL_707_GET_SIP_MIP_DATA_CALL_TYPE,
                              &sip_mip_call_type,
                              &ps_errno);
  if ( -1 == return_val )
  {
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
  }
  else
  {
    resp_msg.call_type = (wds_sip_mip_call_type_enum_v01)sip_mip_call_type;
  }

  send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_SIP_MIP_CALL_TYPE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_sip_mip_status() */

/*===========================================================================
  FUNCTION QMI_WDSI_SET_EVDO_PAGE_MONITOR_PERIOD()

  DESCRIPTION
    Sets the EVDO slot cycle index.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_set_evdo_page_monitor_period
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response = NULL;
  wds_set_evdo_page_monitor_period_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval = QMI_ERR_NONE_V01;

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  int                   return_val;
  int16                 ps_errno;
  evdo_pmp_pend_q_type                          *evdo_pmp_q_node  = NULL;
  ps_sys_ioctl_3gpp2_set_page_monitor_type      ps_set_period;
  uint32       subs_id =0;
  wds_set_evdo_page_monitor_period_req_msg_v01 req_msg;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&resp_msg,0,sizeof(resp_msg));

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)

  memset(&req_msg,0,sizeof(req_msg));
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_EVDO_PAGE_MONITOR_PERIOD_REQ_V01,
                                       sdu_in,
                                      &req_msg,
                                      sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    Check whether the SCI value is in acceptable range
  -------------------------------------------------------------------------*/
  if (!((req_msg.evdo_page_monitor_period == WDSI_EVDO_SLOT_CYCLE_DEFAULT) || 
       ((req_msg.evdo_page_monitor_period > WDSI_EVDO_SLOT_CYCLE_106_MSECS) && 
        (req_msg.evdo_page_monitor_period < WDSI_EVDO_SLOT_CYCLE_2560_MSECS))))
  {
    LOG_MSG_INFO2_1("Invalid SCI value %d", req_msg.evdo_page_monitor_period);
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    Queue client state pointer to the pending queue of EVDO page monitor period
    change events.
    Done before calling the MH function to avoid possible race conditions where
    the event may be received before the MH call completes.
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC_ASSERT(evdo_pmp_q_node, 
                                  sizeof(evdo_pmp_pend_q_type),
                                  evdo_pmp_pend_q_type*);

  if( NULL == evdo_pmp_q_node)
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    goto send_result;
  }

  evdo_pmp_q_node->cl_sp = cl_sp;
  q_link(evdo_pmp_q_node, &(evdo_pmp_q_node->link));
  q_put( &qmi_wdsi_global.evdo_pmp_pend_q, &(evdo_pmp_q_node->link));

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  ps_set_period.page_monitor_period =
    wdsi_xlate_app_scm_to_hdr_enum(req_msg.evdo_page_monitor_period);
  ps_set_period.ps_sys_ioctl_set_evdo_pmp_cb = qmi_wdsi_set_evdo_pmp_cb;

  return_val = ps_sys_ioctl_ex(PS_SYS_TECH_3GPP2,
                               PS_SYS_IOCTL_3GPP2_SET_PAGE_MONITOR_PERIOD,
                               (ps_sys_subscription_enum_type)subs_id,
                               &ps_set_period,
                              &ps_errno);

  if (-1 == return_val )
  {
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
    (void) q_delete(
           &qmi_wdsi_global.evdo_pmp_pend_q,
           &evdo_pmp_q_node->link);
    PS_SYSTEM_HEAP_MEM_FREE(evdo_pmp_q_node);
  }
  send_result:
#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_EVDO_PAGE_MONITOR_PERIOD_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_evdo_page_monitor_period() */
/*===========================================================================
  FUNCTION QMI_WDSI_SET_EVDO_FORCE_LONG_SLEEP()

  DESCRIPTION
    Enables or disables EVDO long sleep.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/

static dsm_item_type*  qmi_wdsi_set_evdo_force_long_sleep
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_set_evdo_force_long_sleep_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  int                   return_val;
  int16                ps_errno = DS_ENOERR;
  uint32                subs_id = 0;
  ps_sys_ioctl_3gpp2_force_long_sleep_type   ps_force_long_sleep = 0;
  wds_set_evdo_force_long_sleep_req_msg_v01 req_msg;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  errval = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_EVDO_FORCE_LONG_SLEEP_REQ_V01,
                                       sdu_in,
                                      &req_msg,
                                      sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  if ((req_msg.force_evdo_long_sleep != TRUE) &&
      (req_msg.force_evdo_long_sleep != FALSE))
  {
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  ps_force_long_sleep = req_msg.force_evdo_long_sleep ;

  return_val = ps_sys_ioctl_ex(PS_SYS_TECH_3GPP2,
                               PS_SYS_IOCTL_3GPP2_SET_FORCE_LONG_SLEEP,
                               (ps_sys_subscription_enum_type)subs_id,
                               &ps_force_long_sleep,
                                                       &ps_errno);

  if (-1 == return_val )
  {
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
  }
#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  goto send_result;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_EVDO_FORCE_LONG_SLEEP_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_evdo_force_long_sleep() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_EVDO_PAGE_MONITOR_PERIOD()

  DESCRIPTION
    Returns the the EVDO Page Monitor Period.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_evdo_page_monitor_period
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_get_evdo_page_monitor_period_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  int                   return_val;
  int16                 ps_errno = DS_ENOERR;
  ps_sys_3gpp2_page_monitor_period_info_type      epmp= {0};
  uint32         subs_id =0;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  errval = QMI_ERR_NONE_V01;

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  return_val = ps_sys_ioctl_ex(PS_SYS_TECH_3GPP2,
                               PS_SYS_IOCTL_3GPP2_GET_PAGE_MONITOR_PERIOD,
                               (ps_sys_subscription_enum_type)subs_id,
                               &epmp,
                               &ps_errno);

  if ( -1 == return_val )
  {
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
  }
  else
  {
    resp_msg.evdo_page_monitor_period.evdo_page_monitor_period_change = 
                                       epmp.slotted_mode_option;
    resp_msg.evdo_page_monitor_period.evdo_force_long_sleep = epmp.long_sleep_enabled;
    if (WDSI_EVDO_SLOT_CYCLE_INVALID == 
           resp_msg.evdo_page_monitor_period.evdo_page_monitor_period_change)
    {
      LOG_MSG_INFO1_0("Mapping slotted mode option meant for rev0 from 0xFE to 0x09");
      resp_msg.evdo_page_monitor_period.evdo_page_monitor_period_change = 
                         (wds_evdo_slot_cycle_enum_v01)WDSI_EVDO_SLOT_CYCLE_5120_MSECS;
    }
  }
#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_EVDO_PAGE_MONITOR_PERIOD_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_evdo_page_monitor_period() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_CALL_THROTTLE_INFO()

  DESCRIPTION
    Returns the remaining call throttled delay of HDR and 1x systems in secs.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_call_throttle_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_get_call_throttle_info_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  int                   return_val;
  int16                 ps_errno = DS_ENOERR;
  ps_sys_ioctl_3gpp2_call_thr_info_hdlr_cb_type ps_call_thr;
  uint32                subs_id;
#else
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  errval = QMI_ERR_NONE_V01;

  /*-------------------------------------------------------------------------
    Queue command buffer in the "pending call throttle info requests" queue.
    Defer response until we receive the call throttle event from MH.
  -------------------------------------------------------------------------*/
  q_put( &qmi_wdsi_global.call_thr_pend_q, &(((qmi_cmd_buf_type *)cmd_buf_p)->link) );

  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  ps_call_thr.call_thro_info_f_ptr = qmi_wds_call_thr_hdlr;

  return_val = ps_sys_ioctl_ex(PS_SYS_TECH_3GPP2,
                               PS_SYS_IOCTL_3GPP2_GET_CALL_THROTTLE_INFO,
                               (ps_sys_subscription_enum_type)subs_id,
                               &ps_call_thr,
                               &ps_errno);

  if (-1 == return_val )
  {
    ds707_call_throttle_info             temp_call_throttle_info = {0};
    
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
    (void) q_delete(
           &qmi_wdsi_global.call_thr_pend_q,
           &(((qmi_cmd_buf_type *)cmd_buf_p)->link));

    return qmi_wdsi_gen_call_throttle_info_response(
                                   temp_call_throttle_info,
                                   errval
                                    );
  }

  return QMI_SVC_RESPONSE_PENDING;
#else /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

  /*-------------------------------------------------------------------------
    Generate result TLV
  -------------------------------------------------------------------------*/
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_CALL_THROTTLE_INFO_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
}
/*===========================================================================
  FUNCTION QMI_WDSI_GET_NSAPI()

  DESCRIPTION
    Returns the NSAPI for a specified APN.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_nsapi
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  qmi_error_type_v01    errval;
  wds_get_nsapi_resp_msg_v01 resp_msg;
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  int                   return_val;
  sint15                ps_errno;
  wds_get_nsapi_req_msg_v01 req_msg;
  ps_sys_ioctl_3gpp_nsapi_type     ps_nsapi;
  qmi_wdsi_client_state_type     * client_sp;
  uint32                           subs_id; 
  uint8                            nsapi_ind = 0;                         
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  memset(&resp_msg,0,sizeof(resp_msg));
#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  errval = QMI_ERR_NONE_V01;
  memset(&ps_nsapi, 0, sizeof(ps_sys_ioctl_3gpp_nsapi_type));
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  subs_id = qmi_wdsi_resolve_client_subs(client_sp);
  memset(&req_msg,0,sizeof(req_msg));
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GET_NSAPI_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }


  memscpy(ps_nsapi.apn, sizeof(ps_nsapi.apn), 
          req_msg.apn, sizeof(req_msg.apn));
  
  /*-------------------------------------------------------------------------
    Call the ioctl and check result
  -------------------------------------------------------------------------*/
  return_val = ps_sys_ioctl_ex ( PS_SYS_TECH_3GPP,
                                 PS_SYS_IOCTL_3GPP_NSAPI,
                                (ps_sys_subscription_enum_type)subs_id,
                                 &ps_nsapi,
                                 &ps_errno );
  if (-1 == return_val )
  {
    errval = qmi_wdsi_map_mh_failure_reason(ps_errno);
  }
  else
  {
    resp_msg.nsapi_len = ps_nsapi.num_nsapi;
    for (nsapi_ind = 0; nsapi_ind < PS_SYS_MAX_BEARER; nsapi_ind++)
    {
      resp_msg.nsapi[nsapi_ind] = ps_nsapi.nsapi[nsapi_ind];
    }
  }
#else /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */

  send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_NAAPI_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_nsapi() */

/*===========================================================================
  FUNCTION QMI_WDSI_SET_DUN_CTRL_PREF()

  DESCRIPTION
    Sets the control point's DUN call control preference.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_set_dun_ctrl_pref
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_set_dun_ctrl_pref_resp_msg_v01 resp_msg;
  qmi_error_type_v01    errval;
#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  wds_set_dun_ctrl_pref_req_msg_v01 req_msg;
#endif /* defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval   = QMI_ERR_NONE_V01;

  memset(&resp_msg,0,sizeof(resp_msg)); 
#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  memset(&req_msg,0,sizeof(req_msg));
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_DUN_CTRL_PREF_REQ_V01,
                              sdu_in,
                              &req_msg,
                              sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  if (WDS_DUN_CTRL_PREF_DISABLE_V01 != req_msg.dun_control_preference &&
      WDS_DUN_CTRL_PREF_ENABLE_V01 != req_msg.dun_control_preference)
  /* Check for the mandatory DUN control preference TLV. */
  {
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }
  else
  {
    if ( (TRUE == qmi_wdsi_global.dun_ctrl_info.is_active) &&
         ((qmi_wdsi_client_state_type *)cl_sp != qmi_wdsi_global.dun_ctrl_info.ctrl_cl_sp) )
    /* If DUN control is already enabled, check if this is the controlling
     * control point. */
    {
      LOG_MSG_ERROR_0("Ignoring DUN control request from stray control point");
      errval = QMI_ERR_NO_EFFECT_V01;
      goto send_result;
    }

    if (TRUE == req_msg.dun_control_preference)
    {
      /* Create/update the DUN control preference. */
      qmi_wdsi_global.dun_ctrl_info.ctrl_cl_sp = (qmi_wdsi_client_state_type *)cl_sp;
      qmi_wdsi_global.dun_ctrl_info.enable_dun_control = 
                                    req_msg.dun_control_preference;

      if (req_msg.dun_allow_preference_valid)
      {
        qmi_wdsi_global.dun_ctrl_info.allow_dun_call = 
                                      req_msg.dun_allow_preference;
      }
      else
      {
        qmi_wdsi_global.dun_ctrl_info.allow_dun_call = TRUE;
      }
      LOG_MSG_INFO2_1("DUN control set with allow_call=%d",
                      qmi_wdsi_global.dun_ctrl_info.allow_dun_call);
      qmi_wdsi_global.dun_ctrl_info.is_active        = TRUE;
    }
    else
    {
      /* Wipe-out the DUN control preferences. */
      if (cl_sp == qmi_wdsi_global.dun_ctrl_info.ctrl_cl_sp)
      {
        LOG_MSG_INFO2_0("DUN control relinquished!");
        qmi_wdsi_init_dun_ctrl_pref_to_default();
      }
    }
  }

send_result:
#else
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_DUN_CTRL_PREF_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
}/* qmi_wdsi_set_dun_ctrl_pref() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_DUN_CTRL_PREF()

  DESCRIPTION
    Queries the control point's DUN call control preference.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_dun_ctrl_pref
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  qmi_error_type_v01      errval;

  wds_get_dun_ctrl_info_resp_msg_v01 resp_msg;
#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  boolean               controlling_client;
  uint8                 event_report_mask;
#endif /* defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/



  response           = NULL;
  errval             = QMI_ERR_NONE_V01;

  memset(&resp_msg,0,sizeof(resp_msg));
#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  controlling_client = FALSE;
  event_report_mask  = 0;

  if (TRUE == qmi_wdsi_global.dun_ctrl_info.is_active)
  {
    /* If DUN control is set, populate the optional TLVs. */
    if ((qmi_wdsi_client_state_type *)cl_sp == qmi_wdsi_global.dun_ctrl_info.ctrl_cl_sp)
    {
      controlling_client = TRUE;
    }
    else
    {
      controlling_client = FALSE;
    }

    /* Start populating the event report mask */
    if (qmi_wdsi_global.dun_ctrl_info.ctrl_cl_sp != NULL)
    {
      if ((qmi_wdsi_global.dun_ctrl_info.ctrl_cl_sp)->report_status.\
                                                 report_dun_call_processed)
      {
        event_report_mask |= QMI_WDS_CTRL_EVENT_REPORT_DUN_CALL_COMPLETE_V01;
      }
      if (qmi_wdsi_global.dun_ctrl_info.report_status.report_entitlement_event)
      {
        event_report_mask |= QMI_WDS_CTRL_EVENT_REPORT_DUN_ENTITLEMENT_V01;
      }
      if (qmi_wdsi_global.dun_ctrl_info.report_status.report_silent_redial_event)
      {
        event_report_mask |= QMI_WDS_CTRL_EVENT_REPORT_DUN_SILENT_REDIAL_V01;
      }
      resp_msg.event_report_mask_valid = TRUE;
      resp_msg.event_report_mask = event_report_mask;
    }
    resp_msg.current_control_point_valid = TRUE;
    resp_msg.current_control_point = controlling_client;
    resp_msg.allow_preference_valid = TRUE;
    resp_msg.allow_preference = qmi_wdsi_global.dun_ctrl_info.allow_dun_call;

    LOG_MSG_INFO2_2("DUN ctrl pref: allow_call=%d, current_client=%d",
                    qmi_wdsi_global.dun_ctrl_info.allow_dun_call,
                    controlling_client);
  }

  /* Populate the mandatory TLV. */
  resp_msg.dun_control_status = qmi_wdsi_global.dun_ctrl_info.is_active;
#else
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_DUN_CTRL_INFO_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
}/* qmi_wdsi_get_dun_ctrl_pref() */

/*===========================================================================
  FUNCTION QMI_WDSI_SET_DUN_CTRL_EVENT_REPORT()

  DESCRIPTION
    Sets the control point's preference to receive call notifications,
    entitlement and silent redial requests for DUN calls.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_set_dun_ctrl_event_report
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  qmi_error_type_v01      errval;

  wds_set_dun_ctrl_event_report_resp_msg_v01 resp_msg;
#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  qmi_wdsi_client_state_type *wds_cl_sp;
  wds_set_dun_ctrl_event_report_req_msg_v01 req_msg;
#endif /* defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response  = NULL;
  errval    = QMI_ERR_NONE_V01;

  memset(&resp_msg,0,sizeof(resp_msg));
#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  wds_cl_sp = (qmi_wdsi_client_state_type *)cl_sp;

  memset(&req_msg,0,sizeof(req_msg));
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_DUN_CTRL_EVENT_REPORT_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  if ((wds_cl_sp != qmi_wdsi_global.dun_ctrl_info.ctrl_cl_sp) 
       && ((TRUE == req_msg.notify_entitlement_valid) ||
           (TRUE == req_msg.notify_silent_redial_valid)))
  {
    LOG_MSG_INFO1_0("Ignoring entitlement request from stray control point");
    errval = QMI_ERR_NO_EFFECT_V01;
    goto send_result;
  }

  if (wds_cl_sp == qmi_wdsi_global.dun_ctrl_info.ctrl_cl_sp)
  {
    if (TRUE == req_msg.notify_entitlement_valid)
    {
      qmi_wdsi_global.dun_ctrl_info.report_status.report_entitlement_event = 
                                           req_msg.notify_entitlement;
      resp_msg.accepted_event_report_mask |= QMI_WDS_CTRL_EVENT_REPORT_DUN_ENTITLEMENT_V01;
    }
    if (TRUE == req_msg.notify_silent_redial_valid)
    {
      if (TRUE == qmi_wdsi_global.dun_ctrl_info.report_status.report_entitlement_event)
      {
        qmi_wdsi_global.dun_ctrl_info.report_status.report_silent_redial_event = 
                                           req_msg.notify_silent_redial;
        resp_msg.accepted_event_report_mask |= 
                                QMI_WDS_CTRL_EVENT_REPORT_DUN_SILENT_REDIAL_V01;
      }
      else
      {
        LOG_MSG_INFO1_0("Silent redial cannot be enabled without entitlement");
        errval = QMI_ERR_NO_EFFECT_V01;
        goto send_result;
      }
    }
  }

  wds_cl_sp->report_status.report_dun_call_processed = req_msg.notify_dun_call;
  resp_msg.accepted_event_report_mask |= QMI_WDS_CTRL_EVENT_REPORT_DUN_CALL_COMPLETE_V01;

send_result:
#else
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
#endif /* defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_DUN_CTRL_EVENT_REPORT_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
}/* qmi_wdsi_set_dun_ctrl_event_report() */

/*===========================================================================
  FUNCTION QMI_WDSI_CONTROL_PENDING_DUN_CALL()

  DESCRIPTION
    Directs the mode handler to (dis)allow a pending DUN call request.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_control_pending_dun_call
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_control_pending_dun_call_req_msg_v01 req_msg;
  wds_control_pending_dun_call_resp_msg_v01 resp_msg;
  qmi_error_type_v01      errval;
  qmi_wdsi_cmd_buf_type *cmd_ptr;
  int16                  rval =0, pserr = 0;
  ps_sys_ioctl_dun_ctrl_response_type  dun_sr_response;
  uint32                subs_id = 0;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval   = QMI_ERR_NONE_V01;
  cmd_ptr  = NULL;
  subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_CONTROL_PENDING_DUN_CALL_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  if ((FALSE == qmi_wdsi_global.dun_ctrl_info.is_active) ||
           (FALSE == qmi_wdsi_global.dun_ctrl_info.call_info.is_valid) ||
           (cl_sp != qmi_wdsi_global.dun_ctrl_info.ctrl_cl_sp))
  {
    errval = QMI_ERR_NO_EFFECT_V01;
    goto send_result;
  }
  else if (req_msg.dun_call_id != qmi_wdsi_global.dun_ctrl_info.pending_call_id)
  {
    errval = QMI_ERR_INVALID_ID_V01;
    goto send_result;
  }
  else
  {
    /* If this is a valid request, send the appropriate response to RMSM. */
    if (WDSI_DUN_CTRL_EVENT_ENTITLEMENT == 
                 qmi_wdsi_global.dun_ctrl_info.call_info.event_type || 
        WDSI_DUN_CTRL_EVENT_SILENT_REDIAL == 
                 qmi_wdsi_global.dun_ctrl_info.call_info.event_type)
    {
      dun_sr_response.cb_data = qmi_wdsi_global.dun_ctrl_info.call_info.cb_data;
      dun_sr_response.allow_call = req_msg.dun_call_action;	  
      rval = ps_sys_ioctl_ex(qmi_wdsi_global.dun_ctrl_info.call_info.tech_type,
                            PS_SYS_IOCTL_DUN_CTRL_RESPONSE,
                             subs_id,(void*)&dun_sr_response,&pserr);
      if(rval != 0)
      {
        LOG_MSG_INFO1_2("DUN ENTITLEMENT RESPONSE NOT SENT %d ps_err %d",
                        rval, pserr);
      }
    }

    /* Post a command to QMI to send out an indication to other clients. */
    cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_DUN_RMSM_EVENT);
    if( cmd_ptr != NULL)
    {
      cmd_ptr->cmd_id                        = QMI_CMD_PROCESS_DUN_RMSM_EVENT;
      cmd_ptr->data.dun_ctrl_event_info.event_type  =
                                           WDSI_DUN_CTRL_EVENT_CALL_PROCESSED;
      cmd_ptr->data.dun_ctrl_event_info.call_allowed = req_msg.dun_call_action;
      cmd_ptr->subscription_id = subs_id;

      dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
    }

    /* Clean up the cache. */
    qmi_wdsi_global.dun_ctrl_info.call_info.is_valid = FALSE;
    qmi_wdsi_dun_ctrl_call_cleanup(subs_id);
  }

send_result:

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_CONTROL_PENDING_DUN_CALL_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
}/* qmi_wdsi_control_pending_dun_call() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_CURRENT_DATA_SYSTEM_STATUS()

  DESCRIPTION
    Retrieve current data system status

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_current_data_system_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_get_current_data_system_status_resp_msg_v01 resp_msg;
  qmi_error_type_v01              errval;
  qmi_result_type_v01             result;
  ps_sys_system_status_type     conf_status_type;
  int16                         ps_errno = 0;
  int                           cnt_network;
  uint32                        subs_id;
  qmi_wdsi_client_state_type *  client_sp;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  subs_id = qmi_wdsi_resolve_client_subs(client_sp);
  memset(&resp_msg,0,sizeof(resp_msg));
  /*-------------------------------------------------------------------------
    Retrieve data system status by calling into PS Sys Layer
  -------------------------------------------------------------------------*/
  result = ps_sys_conf_get_ex( PS_SYS_TECH_ALL,
                            PS_SYS_CONF_SYSTEM_STATUS,
                               (ps_sys_subscription_enum_type)subs_id,
                            (void *)&conf_status_type,
                            &ps_errno);
  if(result < 0)
  {
    LOG_MSG_ERROR_1("ps_sys_conf_get operation returned : (%d)", ps_errno);
    switch (ps_errno)
    {                                   
      case DS_NOMEMORY:
        errval = QMI_ERR_NO_MEMORY_V01;
        break;

      default:
        errval = QMI_ERR_INTERNAL_V01;
        break;
    } /*  switch (ps_errno) */
  }

  if(errval == QMI_ERR_NONE_V01)
  {
    resp_msg.system_status_valid = TRUE;
    resp_msg.system_status.preferred_network = 
    (uint8)conf_status_type.preferred_network;
  /* MH layer is going to fill up rat mask and so mask for all
     technologies. In case if one of them is not present, it would be
     rat mask and so mask would set to zero.We are filtering out WLAN
     as technology for non epdg PLs.*/
    resp_msg.system_status.network_info_len = (uint8)WDSI_SYS_NETWORK_MAX;
  /* PS API gaurantees that order of technologies returned is fixed
     and hence qmi can rely on loop index for network type in tlv
     field. Ex 0 = 3gpp, 1 = 3gpp2 WLAN is currently filtered out for 
     non epdg PLs*/
    for (cnt_network=0; cnt_network < 
                      resp_msg.system_status.network_info_len; cnt_network++)
    {
      resp_msg.system_status.network_info[cnt_network].network = 
                                 (uint8)cnt_network;
      resp_msg.system_status.network_info[cnt_network].rat_mask =
                                  conf_status_type.network_info[cnt_network].rat_mask;
      resp_msg.system_status.network_info[cnt_network].so_mask =
                                  conf_status_type.network_info[cnt_network].so_mask;
    }
  }

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_CURRENT_SYSTEM_STATUS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_current_data_system_status() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_FLOW_CONTROL_STATUS()

  DESCRIPTION
    Returns the current data call flow control status

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_flow_control_status
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type * wds_sp;
  dsm_item_type *       response;
  wds_get_flow_control_status_resp_msg_v01 resp_msg;
  qmi_error_type_v01      errval;
  qmi_wdsi_client_state_type * client_sp;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  /* Validate that request is not sent on reverse IP transport instance */
  if( wds_sp->binding.is_reversed ||
      wds_sp->binding.rmnet_inst >= RMNET_INSTANCE_MAX )
  {
    errval = QMI_ERR_INVALID_OPERATION_V01;
    LOG_MSG_ERROR_1("Request sent on non-binding instance %d "
            , wdsi_get_instance_from_wds_sp(sp));
    goto send_result;
  }

  // Check if call is up
  if (!rmnet_meta_sm_in_call(wds_sp->binding.rmnet_inst))
  {
    LOG_MSG_INFO2_0("Call not up." );
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d", client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }
  // Return cached value (1 if unknown)
  resp_msg.uplink_flow_control_valid = TRUE;
  resp_msg.uplink_flow_control = wds_sp->uplink_flow_ctrl;
send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_FLOW_CONTROL_STATUS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_flow_control_status() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_PDN_THROTTLE_INFO()

  DESCRIPTION
    Retrieves pdn throttle information

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_pdn_throttle_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *                     response;
  qmi_error_type_v01                    errval;
  ps_sys_ioctl_pdn_throttle_info_type *pdn_throttle_info;
  ps_sys_tech_enum_type               tech_type;
  int16                               ps_errno = 0;
  int                                 cnt_apn;
  uint32                              subs_id;
  qmi_wdsi_client_state_type *        client_sp;        
  wds_get_pdn_throttle_info_req_msg_v01 req_msg;
  wds_get_pdn_throttle_info_resp_msg_v01* resp_msg = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  client_sp = (qmi_wdsi_client_state_type *) cl_sp;

  PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg,
                           sizeof(wds_get_pdn_throttle_info_resp_msg_v01),
                           wds_get_pdn_throttle_info_resp_msg_v01*);
  if(resp_msg == NULL)
  {
    qmi_svc_put_result_tlv(&response,(qmi_result_e_type) QMI_RESULT_FAILURE_V01, 
                          (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
    return response;
  }
  else
  {
    memset(resp_msg,0,sizeof(wds_get_pdn_throttle_info_resp_msg_v01));
  }
  
  PS_SYSTEM_HEAP_MEM_ALLOC(pdn_throttle_info,
                       sizeof(ps_sys_ioctl_pdn_throttle_info_type),
                       ps_sys_ioctl_pdn_throttle_info_type*); 

  if (NULL == pdn_throttle_info)
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    goto send_result;
  }
  memset(pdn_throttle_info, 0, sizeof(ps_sys_ioctl_pdn_throttle_info_type));
  memset(&req_msg,0,sizeof(req_msg));
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GET_PDN_THROTTLE_INFO_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  if ( !((req_msg.tech_type == PS_SYS_TECH_3GPP) || (req_msg.tech_type == PS_SYS_TECH_3GPP2)))
  {
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }
  else
  {
    tech_type = (ps_sys_tech_enum_type)req_msg.tech_type;
  }

  LOG_MSG_INFO2_1 ("Got tech type for pdn throttle  as  %d",
                   req_msg.tech_type);


  subs_id = qmi_wdsi_resolve_client_subs(client_sp);
  /*-------------------------------------------------------------------------
    Retrieve pdn throttle information by calling into PS Sys Layer
  -------------------------------------------------------------------------*/
  if(0 > ps_sys_ioctl_ex ( tech_type,
                          PS_SYS_IOCTL_PDN_THROTTLE_INFO,
                          (ps_sys_subscription_enum_type)subs_id,
                          (void *)pdn_throttle_info,
                         &ps_errno))
  {
    LOG_MSG_ERROR_2("ps_sys_ioctl %d operation returned : (%d)",
                    PS_SYS_IOCTL_PDN_THROTTLE_INFO, ps_errno);
    switch (ps_errno)
    {                                   
      case DS_NOMEMORY:
        errval = QMI_ERR_NO_MEMORY_V01;
        break;

      default:
        errval = QMI_ERR_INTERNAL_V01;
        break;
    } 
    goto send_result;
  }
  
  if(pdn_throttle_info->num_apn > PS_SYS_MAX_APNS)
  {
    LOG_MSG_ERROR_1("Incorrect number of valid apns : (%d)",
                    pdn_throttle_info->num_apn);
    ASSERT(0);
    pdn_throttle_info->num_apn = PS_SYS_MAX_APNS;
  }

  if(pdn_throttle_info->num_apn > 0)
  {
    resp_msg->throttle_info_len = MIN(pdn_throttle_info->num_apn,QMI_WDS_APNS_MAX_V01);
  }
  else
  {
    resp_msg->throttle_info_len = 0;
  }
  resp_msg->throttle_info_valid  = TRUE;

  /* Retrieve num of valid apns. It should be of 1 byte field */

  for (cnt_apn=0; cnt_apn < resp_msg->throttle_info_len; cnt_apn++)
  {
    resp_msg->throttle_info[cnt_apn].is_ipv4_throttled = 
       pdn_throttle_info->pdn_throttle_info[cnt_apn].is_ipv4_throttled;
    resp_msg->throttle_info[cnt_apn].is_ipv6_throttled = 
       pdn_throttle_info->pdn_throttle_info[cnt_apn].is_ipv6_throttled;
    resp_msg->throttle_info[cnt_apn].remaining_ipv4_throttled_time = 
       pdn_throttle_info->pdn_throttle_info[cnt_apn].remaining_ipv4_throttled_time;
    resp_msg->throttle_info[cnt_apn].remaining_ipv6_throttled_time = 
       pdn_throttle_info->pdn_throttle_info[cnt_apn].remaining_ipv6_throttled_time;
    if(pdn_throttle_info->pdn_throttle_info[cnt_apn].apn_string_len > PS_SYS_MAX_APN_LEN)
    {
      LOG_MSG_ERROR_1("String length (%d) for apn excedding allowed value 100",
                      pdn_throttle_info->pdn_throttle_info[cnt_apn].apn_string_len );
      ASSERT(0);
      pdn_throttle_info->pdn_throttle_info[cnt_apn].apn_string_len  = PS_SYS_MAX_APN_LEN;           
    }
    resp_msg->throttle_info[cnt_apn].apn_string_len = 
       pdn_throttle_info->pdn_throttle_info[cnt_apn].apn_string_len;
    /* Retrieve apn string. It is variable byte field */
    memscpy
    (
      resp_msg->throttle_info[cnt_apn].apn_string,
      sizeof(resp_msg->throttle_info[cnt_apn].apn_string),
      (void *)pdn_throttle_info->pdn_throttle_info[cnt_apn].apn_string,
      pdn_throttle_info->pdn_throttle_info[cnt_apn].apn_string_len
    );
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_PDN_THROTTLE_INFO_RESP_V01,
                               resp_msg,
                               sizeof(wds_get_pdn_throttle_info_resp_msg_v01),
                               errval,
                               &response);
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  if(pdn_throttle_info != NULL)
  {
    PS_SYSTEM_HEAP_MEM_FREE(pdn_throttle_info);
  }
  return response;
} /* qmi_wdsi_get_pdn_throttle_info() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_LTE_ATTACH_PARAMS()

  DESCRIPTION
    Retrieves LTE attach PDN params

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_lte_attach_params
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *        response;
  wds_get_lte_attach_params_resp_msg_v01 resp_msg;
  ps_sys_ioctl_3gpp_lte_attach_pdn_params_type lte_params;
  int16 ps_errno = DS_ENOERR;
  int16 return_val = DSS_SUCCESS;

  qmi_error_type_v01     errval;
  uint32               subs_id;
  qmi_wdsi_client_state_type * client_sp = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  subs_id   = qmi_wdsi_resolve_client_subs(client_sp);
  memset(&resp_msg,0,sizeof(resp_msg));
  /*-------------------------------------------------------------------------
    Call the ioctl and check result
  -------------------------------------------------------------------------*/
  memset(&lte_params, 0, sizeof(lte_params));
  return_val = ps_sys_ioctl_ex ( PS_SYS_TECH_3GPP,
                          PS_SYS_IOCTL_3GPP_LTE_ATTACH_PDN_PARAMS,
                                 (ps_sys_subscription_enum_type)subs_id,
                          &lte_params,
                          &ps_errno );

  if (return_val != DSS_SUCCESS)
  {
    LOG_MSG_ERROR_2("ps_sys_ioctl ret [%d] errno [%d]", return_val, ps_errno);
    switch (ps_errno)
    {
      case DS_EINVAL:
        errval = QMI_ERR_INFO_UNAVAILABLE_V01;
        break;
      case DS_NOMEMORY:
        errval = QMI_ERR_NO_MEMORY_V01;
        break;
      default:
        errval = QMI_ERR_INTERNAL_V01;
        break;
    }
    goto send_result;
  }

  if (lte_params.apn_string_len > PS_SYS_MAX_APN_LEN)
  {
    LOG_MSG_ERROR_1("Invalid APN string length %u", lte_params.apn_string_len);
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    Build the response TLV
  -------------------------------------------------------------------------*/
  resp_msg.ota_attach_performed_valid = TRUE;
  resp_msg.ota_attach_performed = lte_params.ota_attach_performed;
  resp_msg.ip_type_valid = TRUE;
  resp_msg.ip_type = (wds_ip_support_type_enum_v01)lte_params.ip_type;
  resp_msg.apn_string_valid = TRUE;
  memscpy(resp_msg.apn_string,sizeof(resp_msg.apn_string),
          lte_params.apn_string,lte_params.apn_string_len);
send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_LTE_ATTACH_PARAMS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_lte_attach_params() */

/*===========================================================================
FUNCTION QMI_WDSI_RESET_PKT_STATISTICS()

  DESCRIPTION
    Reset packet statistics

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_reset_pkt_statistics
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *  wds_sp;
  qmi_wdsi_client_state_type * client_sp;
  dsm_item_type *        response;
  wds_reset_pkt_statistics_resp_msg_v01 resp_msg;

  ps_iface_type *        ps_iface_ptr;
  ps_iface_type *        stat_iface_ptr;

  qmi_error_type_v01     errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp =(qmi_wdsi_client_state_type *)cl_sp;

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  /* Validate that request is not sent on reverse IP transport instance */
  if( wds_sp->binding.is_reversed ||
      wds_sp->binding.rmnet_inst >= RMNET_INSTANCE_MAX )
  {
    errval = QMI_ERR_INVALID_OPERATION_V01;
    LOG_MSG_ERROR_1("Request sent on non-binding instance %d "
            , wdsi_get_instance_from_wds_sp(sp));
    goto send_result;
  }

  // Check if call is up
  if (!rmnet_meta_sm_in_call(wds_sp->binding.rmnet_inst))
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  // Get rm iface
  ps_iface_ptr = rmnet_meta_sm_iface(wds_sp->binding.rmnet_inst);
  if (PS_IFACE_IS_VALID(ps_iface_ptr) == FALSE)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  // Get stats iface
  stat_iface_ptr = qmi_wdsi_get_um_stat_iface(ps_iface_ptr);
  if (PS_IFACE_IS_VALID(stat_iface_ptr) == FALSE)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  // Reset stats
  ps_stat_reset_iface_stats_by_iface_ptr(stat_iface_ptr);

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_RESET_PKT_STATISTICS_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_reset_pkt_statistics() */

/*===========================================================================
FUNCTION QMI_WDSI_BIND_DATA_PORT()

  DESCRIPTION
    Bind the WDS client to an SIO data port

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp_in  : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_bind_data_port
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp_in,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type    * response;
  wds_bind_data_port_resp_msg_v01 resp_msg;
  qmi_error_type_v01   errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_BIND_DATA_PORT_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_bind_data_port() */

/*===========================================================================
FUNCTION QMI_WDSI_BIND_MUX_DATA_PORT()

  DESCRIPTION
    Bind the WDS client to a data port

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp_in  : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_bind_mux_data_port
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp_in,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              * response;
  wds_bind_mux_data_port_req_msg_v01 req_msg;
  wds_bind_mux_data_port_resp_msg_v01 resp_msg;
  qmi_wdsi_state_type        * wds_sp;
  qmi_wdsi_client_state_type * cl_sp;
  uint32                       ep_id;
  uint8                        mux_id;
  boolean                      is_reversed;
  uint8                        bind_inst;
  uint32                       client_type = QMI_WDS_CLIENT_TYPE_NONE;

  qmi_error_type_v01   errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  cl_sp = (qmi_wdsi_client_state_type *)cl_sp_in;

  response = NULL;
  errval = QMI_ERR_NONE_V01;

  ep_id       = wds_sp->binding.ep_id;
  mux_id      = 0;
  is_reversed = FALSE;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_BIND_MUX_DATA_PORT_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
    {
      goto send_result;
    }
  if (req_msg.ep_id_valid)
  {
    // Converting to uint32
    if (QMI_EP_ID_VALID(req_msg.ep_id))
    {
      ep_id = QMI_EP_ID_TO_INTERNAL_EP_ID(req_msg.ep_id);
    }
    else
    {
      LOG_MSG_ERROR_2("Invalid ep_id 0x%x:0x%x",
                      req_msg.ep_id.ep_type, req_msg.ep_id.iface_id);
      errval = QMI_ERR_INVALID_ARG_V01;
      goto send_result;
    }
  }

  if (ep_id == 0)
  {
    LOG_MSG_INFO1_1("Invalid EP id 0x%x", ep_id);
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }
  if(req_msg.mux_id_valid)
  {
    mux_id = req_msg.mux_id;
  }
  if(req_msg.client_type_valid)
  {
    client_type = req_msg.client_type;
  }
  if(req_msg.reversed_valid)
  {
    is_reversed = req_msg.reversed;
  }
  // Find the binding inst from ep and mux id
  bind_inst = wdsi_get_inst_from_ep_and_mux_id(ep_id, mux_id);
  if (bind_inst >= WDS_INSTANCE_MAX)
  {
    // Find a free (unbound) WDS instance
    bind_inst = wdsi_get_unbound_inst(ep_id, mux_id, is_reversed);
    if (bind_inst >= WDS_INSTANCE_MAX)
    {
      LOG_MSG_ERROR_2("No available WDS inst to bind to EP 0x%x mux_id %d",
                           ep_id, mux_id);
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }
  else if (qmi_wds_state[WDSI_IPV4_STATE][bind_inst]->binding.is_reversed != is_reversed)
  {
    LOG_MSG_INFO1_0("is_reversed flag mismatch");
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  // If bind to the current binding inst, no action is needed
  if (cl_sp->wds_inst == bind_inst)
  {
    LOG_MSG_INFO1_2("Client %d already bound to inst %d",
                    cl_sp->common.clid, cl_sp->wds_inst);
    errval = QMI_ERR_NONE_V01;
    goto send_result;
  }

  // Bind the WDS instance
  if (!qmi_wdsi_inst_bind(bind_inst, ep_id, mux_id, is_reversed))
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  // Bind the client
  if (!qmi_wdsi_process_bind_data_port(cl_sp, bind_inst))
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

send_result:

  // Add to the rmnet tethered inst table
  if (errval == QMI_ERR_NONE_V01&& 
      client_type == QMI_WDS_CLIENT_TYPE_TETHERED &&
      !is_reversed)
  {
    rmnet_qcrmcall_inst_add(ep_id, mux_id);
  }

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_BIND_MUX_DATA_PORT_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_bind_mux_data_port() */

/*===========================================================================
  FUNCTION WDSI_GEN_START_NETWORK_INTERFACE_RESPONSE()

  DESCRIPTION
    Generates a start network interface response.

  PARAMETERS
    errval          - the result of the start network interface request
    pkt_data_handle - the pkt data handle to return, if errval == NONE
    call_end_reason - call end reason
    call_end_reason_verbose - call end reason
  RETURN VALUE
    pointer to dsm chain containing the SNI response.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type *  wdsi_gen_start_network_interface_response
(
  qmi_error_type_v01  errval,
  void *            pkt_data_handle,
  qmi_wds_call_end_reason_e_type call_end_reason,
  uint32            call_end_reason_verbose,
  uint32            net_down_ep_id,
  uint8             net_down_mux_id
)
{
  dsm_item_type *    response =  NULL;
  wds_start_network_interface_resp_msg_v01 resp_msg;
  memset(&resp_msg,0,sizeof(resp_msg));
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  response = NULL;

  if ( errval == QMI_ERR_CALL_FAILED_V01)
  {
    if ( (call_end_reason_verbose ==
               PS_NET_DOWN_REASON_INTERNAL_CALL_ALREADY_PRESENT) &&
         (net_down_ep_id > 0) )
    {
      resp_msg.ep_id_valid = TRUE;
      resp_msg.ep_id.ep_type = (net_down_ep_id & 0xFF000000) >> 24;
      resp_msg.ep_id.iface_id = (net_down_ep_id & 0x00FFFFFF);
      resp_msg.mux_id_valid = TRUE;
      resp_msg.mux_id = net_down_mux_id;
    }
    resp_msg.verbose_call_end_reason_valid = TRUE;
    resp_msg.verbose_call_end_reason.call_end_reason_type = 
                                (call_end_reason_verbose >> 16);
    resp_msg.verbose_call_end_reason.call_end_reason = 
                                (0x0000FFFF&call_end_reason_verbose);
    resp_msg.call_end_reason_valid = TRUE;
    resp_msg.call_end_reason = (wds_call_end_reason_enum_v01)call_end_reason;
  }
  if(errval == QMI_ERR_NONE_V01)
  {
    resp_msg.pkt_data_handle = (uint32)pkt_data_handle;
  }
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_START_NETWORK_INTERFACE_RESP_V01,
                           &resp_msg,
                           sizeof(resp_msg),
                           errval,
                           &response);
  return response;
} /* wdsi_gen_start_network_interface_response() */


/*===========================================================================
  FUNCTION WDSI_START_NET_ATTEMPT_COMPLETE()

  DESCRIPTION
    Completes all pending start network interface requests with the provided
    error value and pkt_data_handle.

  PARAMETERS
    wds_sp  - WDS instance state pointer
    errval  - the result of the start network interface request

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_start_net_attempt_complete
(
  qmi_wdsi_state_type *  wds_sp,
  qmi_error_type_v01       errval
)
{
  dsm_item_type *     response_ptr;
  qmi_cmd_buf_type *  cmd_buf_p;
  qmi_wdsi_client_state_type *  cl_sp;
  uint32              net_down_ep_id = 0;
  uint8               net_down_mux_id = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  LOG_MSG_INFO2_1 ("RmNet call attempt result (%d), complete pending requests",
                   errval);

  /*-------------------------------------------------------------------------
    Complete pending start_network_interface transaction

    wds state pointer was saved in the user data field
    pending commands are queued in sni_pend_q
  -------------------------------------------------------------------------*/
  while( (cmd_buf_p = q_get(&wds_sp->sni_pend_q)) != NULL )
  {
      cl_sp = (qmi_wdsi_client_state_type *)cmd_buf_p->x_p->cl_sp;

    /*-----------------------------------------------------------------------
      If rmnet activation failed, unbind the client and generate SNI response
    -----------------------------------------------------------------------*/
    if (errval != QMI_ERR_NONE_V01)
    {
      cl_sp->net_bound = FALSE;
    }

    /*-----------------------------------------------------------------------
      Build the response from back to front
    -----------------------------------------------------------------------*/
    if ( errval == QMI_ERR_CALL_FAILED_V01)
    {
      if (wds_sp->call_end_reason_verbose == 
                   PS_NET_DOWN_REASON_INTERNAL_CALL_ALREADY_PRESENT)
      {
        (void)rmnet_get_net_down_ep_and_mux_id(
                          wds_sp->binding.rmnet_inst,
                          &net_down_ep_id,
                          &net_down_mux_id);
      }
      response_ptr =
        wdsi_gen_start_network_interface_response(
                                                   errval,
                                                   cmd_buf_p->x_p->cl_sp,
                                                   wds_sp->call_end_reason,
                                                   wds_sp->call_end_reason_verbose,
                                                   net_down_ep_id,
                                                   net_down_mux_id
                                                 );
    }
    else
    {
      response_ptr =
        wdsi_gen_start_network_interface_response(
                                                  errval,
                                                  cmd_buf_p->x_p->cl_sp,
                                                  QMI_WDS_CALL_END_REASON_MIN,
                                                  0, 0, 0
                                                 );
    }

    if (response_ptr == NULL)
    {
      LOG_MSG_ERROR_0 ("Couldn't generate SNI response!");
      ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
      continue;
    }

    if ( FALSE == qmi_wdsi_send_response(
                   cmd_buf_p,
                   response_ptr) )
    {
      LOG_MSG_ERROR_0("Unable to send start network interface response!");
      dsm_free_packet( &response_ptr );
      ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
      return;
    }
  } /* end while (pending SNI transactions) */
} /* wdsi_start_net_attempt_complete() */


/*===========================================================================
  FUNCTION WDSI_STOP_NET_ATTEMPT_COMPLETE()

  DESCRIPTION
    Completes all pending stop network interface requests with the provided
    pkt_data_handle.

  PARAMETERS
    wds_sp  - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_stop_net_attempt_complete
(
  qmi_wdsi_state_type *  wds_sp
)
{
  dsm_item_type *     response_ptr = NULL;
  qmi_cmd_buf_type *  cmd_buf_p = NULL;
  wds_stop_network_interface_resp_msg_v01 resp_msg;
  boolean retval = FALSE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response_ptr = NULL;
  cmd_buf_p = wds_sp->stop_ni_cmd_buf_p;

  if (cmd_buf_p == NULL)
  {
    LOG_MSG_INFO2_0("No pending Stop Network response");
    return;
  }
  LOG_MSG_INFO1_1("Processing pending Stop Network response cmd_buf_p %0x",cmd_buf_p);
  memset(&resp_msg,0,sizeof(wds_stop_network_interface_resp_msg_v01));
  /*-------------------------------------------------------------------------
    Complete pending stop_network_interface transaction
    Pending command is stored in wds_sp as stop_ni_cmd_buf_p
  -------------------------------------------------------------------------*/
  wds_sp->stop_ni_cmd_buf_p = NULL;
  
  /*-------------------------------------------------------------------------
    Generate result TLV and message header
  -------------------------------------------------------------------------*/
  retval = QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_STOP_NETWORK_INTERFACE_RESP_V01,
                                        &resp_msg,
                                        sizeof(resp_msg),
                                        QMI_ERR_NONE_V01,
                                        &response_ptr);   
  if(retval != TRUE)
  {
    dsm_free_packet(&response_ptr);
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }
  if (response_ptr)
  {
    if (FALSE == qmi_wdsi_send_response(cmd_buf_p, response_ptr))
    {
      LOG_MSG_INFO2_1 ("Unable to send Stop Network Interface response for cmd %d",
                       cmd_buf_p->cmd_type);
      dsm_free_packet( &response_ptr );
      ds_qmi_fw_free_cmd_buf(&cmd_buf_p);
      return;
    }
  }
  else
  {
    LOG_MSG_ERROR_0 ("Couldn't generate Stop Network Interface response!");
    ds_qmi_fw_free_cmd_buf( &cmd_buf_p );
    return;
  }
} /* wdsi_stop_net_attempt_complete() */

#ifdef FEATURE_DATA_QMI_MCAST
/*===========================================================================
  FUNCTION WDSI_REG_IFACE_MCAST_EVENT()

  DESCRIPTION
    Function to register mcast events on UM iface

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_reg_iface_mcast_event
(
  qmi_wdsi_state_type *  wds_sp
)
{
  ps_iface_event_enum_type      err_ev = IFACE_EVENT_MAX;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  do
  {
    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                     IFACE_MCAST_REGISTER_SUCCESS_EV,
                                     wds_sp->um_iface_mcast_reg_success_buf_ptr))
    {
        err_ev = IFACE_MCAST_REGISTER_SUCCESS_EV;
        break;
    }
  
    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                     IFACE_MCAST_REGISTER_FAILURE_EV,
                                     wds_sp->um_iface_mcast_reg_failure_buf_ptr))
    {
        err_ev = IFACE_MCAST_REGISTER_FAILURE_EV;
        break;
    }
  
    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                     IFACE_MCAST_DEREGISTERED_EV,
                                     wds_sp->um_iface_mcast_dereg_buf_ptr))
    {
        err_ev = IFACE_MCAST_DEREGISTERED_EV;
        break;
    }
  
    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                     IFACE_MBMS_CONTEXT_ACT_SUCCESS_EV,
                                     wds_sp->um_iface_mbms_cont_act_success_buf_ptr))
    {
        err_ev = IFACE_MBMS_CONTEXT_ACT_SUCCESS_EV;
        break;
    }

    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                     IFACE_MBMS_CONTEXT_ACT_FAILURE_EV,
                                     wds_sp->um_iface_mbms_cont_act_failure_buf_ptr))
    {
        err_ev = IFACE_MBMS_CONTEXT_ACT_FAILURE_EV;
        break;
    }
  
    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                     IFACE_MBMS_CONTEXT_DEACT_SUCCESS_EV,
                                     wds_sp->um_iface_mbms_cont_deact_success_buf_ptr))
    {
        err_ev = IFACE_MBMS_CONTEXT_DEACT_SUCCESS_EV;
        break;
    }
  
    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                     IFACE_MBMS_CONTEXT_DEACT_FAILURE_EV,
                                     wds_sp->um_iface_mbms_cont_deact_failure_buf_ptr))
    {
        err_ev = IFACE_MBMS_CONTEXT_DEACT_FAILURE_EV;
        break;
    }
  
    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                     IFACE_MCAST_STATUS_EV,
                                     wds_sp->um_iface_mcast_status_ex_buf_ptr))
    {
        err_ev = IFACE_MCAST_STATUS_EV;
        break;
    }
  }while(0);

  if(err_ev != IFACE_EVENT_MAX)
  {
    LOG_MSG_ERROR_1("Couldn't register for Iface event: %d",err_ev);
    ASSERT(0);
    return;
  }

  wds_sp->reg_mcast_iface_ev = TRUE;
}


/*===========================================================================
  FUNCTION WDSI_DEREG_IFACE_MCAST_EVENT()

  DESCRIPTION
    Function to de-register mcast events on UM iface

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_dereg_iface_mcast_event
(
  qmi_wdsi_state_type *  wds_sp
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_MCAST_REGISTER_SUCCESS_EV,
                             wds_sp->um_iface_mcast_reg_success_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                           IFACE_MCAST_REGISTER_FAILURE_EV,
                           wds_sp->um_iface_mcast_reg_failure_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                           IFACE_MCAST_DEREGISTERED_EV,
                           wds_sp->um_iface_mcast_dereg_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_MBMS_CONTEXT_ACT_SUCCESS_EV,
                             wds_sp->um_iface_mbms_cont_act_success_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_MBMS_CONTEXT_ACT_FAILURE_EV,
                             wds_sp->um_iface_mbms_cont_act_failure_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_MBMS_CONTEXT_DEACT_SUCCESS_EV,
                             wds_sp->um_iface_mbms_cont_deact_success_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_MBMS_CONTEXT_DEACT_FAILURE_EV,
                             wds_sp->um_iface_mbms_cont_deact_failure_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_MCAST_STATUS_EV,
                             wds_sp->um_iface_mcast_status_ex_buf_ptr);


  wds_sp->reg_mcast_iface_ev = FALSE;
}
#endif /* FEATURE_DATA_QMI_MCAST */

/*===========================================================================
  FUNCTION WDSI_REG_RMNET_IFACE_EV()

  DESCRIPTION
    Function to register for Rmnet Iface events

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_reg_rmnet_iface_ev
(
  qmi_wdsi_state_type *  wds_sp
)
{
    ps_iface_event_enum_type err_ev = IFACE_EVENT_MAX;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(wds_sp);
  do
  {
    if(0 != ps_iface_event_cback_reg(wds_sp->rmnet_iface_ptr,
                                     IFACE_CONFIGURING_EV,
                                     wds_sp->net_iface_configuring_buf_ptr))
    {
        err_ev = IFACE_CONFIGURING_EV;
        break;
    }
  
    if(0 != ps_iface_event_cback_reg(wds_sp->rmnet_iface_ptr,
                                     IFACE_DOWN_EV,
                                     wds_sp->net_iface_down_buf_ptr))
    {
        err_ev = IFACE_DOWN_EV;
        break;
    }
  
    if(0 != ps_iface_event_cback_reg(wds_sp->rmnet_iface_ptr,
                                     IFACE_AUTHENTICATING_EV,
                                     wds_sp->net_iface_authenticating_buf_ptr))
    {
      err_ev = IFACE_AUTHENTICATING_EV;
      break;
    }
  
  }while(0);

  if(err_ev != IFACE_EVENT_MAX)
  {
    DATA_ERR_FATAL("Couldn't subscribe for rmnet iface event");
    return;
  }
  wds_sp->reg_rmnet_iface_ev = TRUE;
} /* wdsi_reg_rmnet_iface_ev() */

/*===========================================================================
  FUNCTION WDSI_DEREG_RMNET_IFACE_EV()

  DESCRIPTION
    Function to deregister from Rmnet Iface events

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_dereg_rmnet_iface_ev
(
  qmi_wdsi_state_type      * wds_sp
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (wds_sp);
  if ( wds_sp->rmnet_iface_ptr != NULL )
  {
    ps_iface_event_cback_dereg(wds_sp->rmnet_iface_ptr,
                               IFACE_CONFIGURING_EV,
                               wds_sp->net_iface_configuring_buf_ptr);

    ps_iface_event_cback_dereg(wds_sp->rmnet_iface_ptr,
                               IFACE_DOWN_EV,
                               wds_sp->net_iface_down_buf_ptr);

    ps_iface_event_cback_dereg(wds_sp->rmnet_iface_ptr,
                               IFACE_AUTHENTICATING_EV,
                               wds_sp->net_iface_authenticating_buf_ptr);


    wds_sp->reg_rmnet_iface_ev = FALSE;
  }
  else
  {
     LOG_MSG_ERROR_0 ("UmIface ptr NULL before dereg'ing from iface ev!");
     return;
  }
 }  /* wdsi_dereg_rmnet_iface_ev */


/*===========================================================================
  FUNCTION WDSI_REG_INTERNAL_UM_IFACE_EV()

  DESCRIPTION
    Function to register for Internal Um Iface events

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_reg_internal_um_iface_ev
(
  qmi_wdsi_state_type      * wds_sp
)
{
  ps_iface_event_enum_type err_ev = IFACE_EVENT_MAX;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/*Register for ALL internal IFACE events irrespective of the requested mask*/
  do
  {
    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                              IFACE_ENABLE_HDR_REV0_RATE_INERTIA_SUCCESS_EV,
                              wds_sp->um_iface_hdr_rate_inertia_succ_buf_ptr) )
    {
      err_ev = IFACE_ENABLE_HDR_REV0_RATE_INERTIA_SUCCESS_EV;
      break;
    }
  
    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                              IFACE_ENABLE_HDR_REV0_RATE_INERTIA_FAILURE_EV,
                              wds_sp->um_iface_hdr_rate_inertia_fail_buf_ptr) )
    {
        err_ev = IFACE_ENABLE_HDR_REV0_RATE_INERTIA_FAILURE_EV;
        break;
    }

#ifdef FEATURE_EIDLE_SCI
    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                            IFACE_ENABLE_HDR_SET_EIDLE_SLOTTED_MODE_SUCCESS_EV,
                            wds_sp->um_iface_hdr_sm_succ_buf_ptr) )
    {
        err_ev = IFACE_ENABLE_HDR_SET_EIDLE_SLOTTED_MODE_SUCCESS_EV;
        break;
    }
  
    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                            IFACE_ENABLE_HDR_SET_EIDLE_SLOTTED_MODE_FAILURE_EV,
                            wds_sp->um_iface_hdr_sm_fail_buf_ptr) )
    {
        err_ev = IFACE_ENABLE_HDR_SET_EIDLE_SLOTTED_MODE_FAILURE_EV;
        break;
    }
  
    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                    IFACE_ENABLE_HDR_SET_EIDLE_SLOTTED_MODE_SESSION_CHANGED_EV,
                    wds_sp->um_iface_hdr_sm_sess_change_buf_ptr) )
    {
        err_ev = IFACE_ENABLE_HDR_SET_EIDLE_SLOTTED_MODE_SESSION_CHANGED_EV;
        break;
    }
#endif /* FEATURE_EIDLE_SCI */

    if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_RF_CONDITIONS_CHANGED_EV,
                                   wds_sp->um_iface_rf_conditions_buf_ptr) )
    {
        err_ev = IFACE_RF_CONDITIONS_CHANGED_EV;
        break;
    }
  }while(0);

  if(err_ev != IFACE_EVENT_MAX)
  {
    LOG_MSG_ERROR_1("Couldn't register for internal UM iface event %d",err_ev);
    ASSERT(0);
    return;
  }
} /* wdsi_reg_internal_um_iface_ev() */
/*===========================================================================
  FUNCTION WDSI_REG_UM_IFACE_EV()

  DESCRIPTION
    Function to register for Um Iface events

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_reg_um_iface_ev
(
  qmi_wdsi_state_type      * wds_sp
)
{
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
 /* Register for IFACE_EXTENDED_IP_CONFIG_EX_EV */
  ASSERT (wds_sp);
  if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                    IFACE_EXTENDED_IP_CONFIG_EX_EV,
                                    wds_sp->um_iface_ext_ipconfig_ex_buf_ptr))
  {
    DATA_ERR_FATAL("Couldn't register for IFACE_EXTENDED_IP_CONFIG_EX_EV");
    return;
  }

  if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                    IFACE_APN_PARAM_CHANGED_EV,
                                    wds_sp->um_iface_apn_param_changed_buf_ptr))
  {
    DATA_ERR_FATAL("Couldn't register for IFACE_APN_PARAM_CHANGED_EV");
    return;
  }
    
  if(0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_FAST_DORMANCY_STATUS_EV,
                                   wds_sp->um_iface_fast_dormancy_status_buf_ptr) )
  {
    DATA_ERR_FATAL("Couldn't register for IFACE_FAST_DORMANCY_STATUS_EV");
    return;
  }

  wds_sp->reg_um_iface_ev = TRUE;
  LOG_MSG_INFO2_0("wdsi_reg_um_iface_ev():Um iface events registered ");
}

/*===========================================================================
  FUNCTION WDSI_DEREG_INTERNAL_UM_IFACE_EV()

  DESCRIPTION
    Function to deregister from Internal Um Iface events

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_dereg_internal_um_iface_ev
(
  qmi_wdsi_state_type      * wds_sp
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (wds_sp);
  if ( wds_sp->um_iface_ptr != NULL )
  {
    ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_ENABLE_HDR_REV0_RATE_INERTIA_SUCCESS_EV,
                             wds_sp->um_iface_hdr_rate_inertia_succ_buf_ptr);
    ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_ENABLE_HDR_REV0_RATE_INERTIA_FAILURE_EV,
                             wds_sp->um_iface_hdr_rate_inertia_fail_buf_ptr);
    ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                          IFACE_ENABLE_HDR_SET_EIDLE_SLOTTED_MODE_SUCCESS_EV,
                          wds_sp->um_iface_hdr_sm_succ_buf_ptr);
    ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                          IFACE_ENABLE_HDR_SET_EIDLE_SLOTTED_MODE_FAILURE_EV,
                          wds_sp->um_iface_hdr_sm_fail_buf_ptr);
    ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                  IFACE_ENABLE_HDR_SET_EIDLE_SLOTTED_MODE_SESSION_CHANGED_EV,
                  wds_sp->um_iface_hdr_sm_sess_change_buf_ptr);
    ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                               IFACE_RF_CONDITIONS_CHANGED_EV,
                               wds_sp->um_iface_rf_conditions_buf_ptr);
    
  }
  else
  {
     LOG_MSG_ERROR_0 ("UmIface ptr NULL before dereg'ing from iface ev!");
     return;
  }
 }  /* wdsi_dereg_internal_um_iface_ev */

/*===========================================================================
  FUNCTION WDSI_DEREG_UM_IFACE_EV()

  DESCRIPTION
    Function to deregister from Um Iface events

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_dereg_um_iface_ev
(
  qmi_wdsi_state_type      * wds_sp
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (wds_sp);
  if ( wds_sp->um_iface_ptr != NULL )
  {
    ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                               IFACE_EXTENDED_IP_CONFIG_EX_EV,
                               wds_sp->um_iface_ext_ipconfig_ex_buf_ptr);
  
     ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                               IFACE_APN_PARAM_CHANGED_EV,
                               wds_sp->um_iface_apn_param_changed_buf_ptr);

    ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                               IFACE_FAST_DORMANCY_STATUS_EV,
                               wds_sp->um_iface_fast_dormancy_status_buf_ptr);
  }
  else
  {
     LOG_MSG_ERROR_0 ("UmIface ptr NULL before dereg'ing extended ip config ev!");
     return;
  }
  wds_sp->reg_um_iface_ev = FALSE;
  return;
}

/*===========================================================================
  FUNCTION WDSI_DEREG_WLAN_IFACE_EV()

  DESCRIPTION
    Function to deregister from WLAN Iface events

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_dereg_wlan_iface_ev
(
  qmi_wdsi_state_type      * wds_sp
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (wds_sp);
  if ( wds_sp->wlan_iface_ptr != NULL )
  {
    ps_iface_event_cback_dereg(wds_sp->wlan_iface_ptr,
                               IFACE_REVERSE_IP_TRANSPORT_CONFIG_EV,
                               wds_sp->wlan_iface_rev_ip_transport_config_buf_ptr);
    ps_iface_event_cback_dereg(wds_sp->wlan_iface_ptr,
                               IFACE_DOWN_EV,
                               wds_sp->wlan_iface_down_buf_ptr);
    ps_iface_event_cback_dereg(wds_sp->wlan_iface_ptr,
                             IFACE_CONFIGURING_EV,
                             wds_sp->wlan_iface_configuring_buf_ptr);
  }
  else
  {
     LOG_MSG_ERROR_0 ("WLAN Iface ptr NULL before dereg'ing from iface ev!");
     return;
  }
}  /* wdsi_dereg_wlan_iface_ev */

/*===========================================================================
  FUNCTION QMI_WDSI_RESET_CLIENT()

  DESCRIPTION
    Resets the state for the given client

  PARAMETERS
    cl_sp :  client state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_reset_client
(
  void * cl_sp_in
)
{
  int i, inst;
  qmi_wdsi_client_state_type *  cl_sp;
  qmi_transaction_type *  x_p;
  qmi_wdsi_state_type *   wds_sp;
  boolean                 pending_resp;
  int16                   ps_errno = 0;
  qmi_cmd_buf_type * pending_cmd_buf = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT (cl_sp_in);

  cl_sp = (qmi_wdsi_client_state_type *)cl_sp_in;
  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);
  inst = wdsi_get_instance_from_wds_sp(wds_sp);

  if ( (wds_sp == NULL) || (inst >= WDS_INSTANCE_MAX) )
  {
    DATA_ERR_FATAL("Recd reset request with invalid client");
    return;
  }
  /*-------------------------------------------------------------------------
    Free resources for client
    Remove any pending commmands for this client from the pending q's
    Clear pending msg transactions and partially bundled responses
  -------------------------------------------------------------------------*/
  (void) q_linear_delete_new(
           &wds_sp->sni_pend_q,
           (q_compare_func_type) qmi_svc_cmd_buf_belongs_to_client,
           cl_sp,
           (q_action_func_type) NULL,
           NULL);
  /* Delete any pending transactions for this client */
  if(q_cnt(&qmi_wdsi_global.call_thr_pend_q) > 0)
  {
    do
    {
     /*No need of freeing cmd_bufs will be freed as apart of ds_qmi_fw_free_transaction*/
       pending_cmd_buf = 
            q_linear_delete_new( &qmi_wdsi_global.call_thr_pend_q,
           (q_compare_func_type) qmi_svc_cmd_buf_belongs_to_client,
           cl_sp,
           (q_action_func_type) NULL,
           NULL);
    }while(pending_cmd_buf != NULL);
  }

  if(wds_sp->stop_ni_cmd_buf_p != NULL &&
      qmi_svc_cmd_buf_belongs_to_client(wds_sp->stop_ni_cmd_buf_p,
                                        (qmi_common_client_state_type*)cl_sp))
  {
    ds_qmi_fw_free_cmd_buf(&wds_sp->stop_ni_cmd_buf_p);
    wds_sp->stop_ni_cmd_buf_p = NULL;
  }

  if (cl_sp->tmgi_active_list_cmd_buf_p != NULL)
  {
    ds_qmi_fw_free_cmd_buf(&cl_sp->tmgi_active_list_cmd_buf_p);
    cl_sp->tmgi_active_list_cmd_buf_p = NULL;
  }

  if (cl_sp->tmgi_avail_list_cmd_buf_p != NULL)
  {
    ds_qmi_fw_free_cmd_buf(&cl_sp->tmgi_avail_list_cmd_buf_p);
    cl_sp->tmgi_avail_list_cmd_buf_p = NULL;
  }

  /*-------------------------------------------------------------------------
    q_init() is used here as a way to clear the queue and not as a way to
    initialize the queue.
  -------------------------------------------------------------------------*/
  (void) q_init( &cl_sp->common.x_free_q );
  for( i = 0; i < MAX_PENDING_TRANSACTIONS; i++ )
  {
    x_p = &cl_sp->common.transactions[i];
    ds_qmi_fw_free_transaction(&x_p );
  }

  /*-------------------------------------------------------------------------
    stop network interface
  -------------------------------------------------------------------------*/
  (void)qmi_wdsi_stop_net_iface_client(cl_sp, WDSI_FORCE_REASON_DEFAULT, &pending_resp);

  /*-------------------------------------------------------------------------
    clear call status reporting
  -------------------------------------------------------------------------*/
  qmi_wdsi_set_pkt_stats_reports( cl_sp, 0, 0 );
  memset(&cl_sp->report_status, 0, sizeof(cl_sp->report_status));


  /*-------------------------------------------------------------------------
    Deallocate Profile Change Event List
  -------------------------------------------------------------------------*/
  if (cl_sp->config_evt_list.profile_change_evt_list != NULL)
  {
    PS_SYSTEM_HEAP_MEM_FREE(cl_sp->config_evt_list.profile_change_evt_list);
    cl_sp->config_evt_list.report_on_tech_mask = 0;
  }

  qmi_wdsi_dun_set_pkt_stats_reports(cl_sp, 0, 0);
  memset(&cl_sp->modem_rpt_status, 0, sizeof(cl_sp->modem_rpt_status));

#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
  if (cl_sp == qmi_wdsi_global.dun_ctrl_info.ctrl_cl_sp)
  {
    qmi_wdsi_init_dun_ctrl_pref_to_default();
  }
#endif /* defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA) */

  cl_sp->bound_ip_type = QMI_AF_ANY;
  cl_sp->subscription_id = QMI_WDSI_SUBS_DONT_CARE;

  if (cl_sp->downlink_report_interval !=  0)
  {
    qmi_wdsi_update_downlink_throughput_interval(cl_sp ,FALSE, &ps_errno);
  }

  qmi_wdsi_sync_clients(inst);
} /* qmi_wdsi_reset_client() */


/*===========================================================================
  FUNCTION QMI_WDSI_GET_QMI_WDS_SP_BY_CL_SP()

  DESCRIPTION
    to get the wireless service state ptr from the client state ptr

  PARAMETERS
    cl_sp : client state ptr

  RETURN VALUE
    wireless service state ptr

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_wdsi_state_type *  qmi_wdsi_get_wds_sp_by_cl_sp
(
  qmi_wdsi_client_state_type *  cl_sp
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( (cl_sp == NULL) ||
       (cl_sp->current_wds_state >= WDSI_MAX_STATE) ||
       (cl_sp->wds_inst >= WDS_INSTANCE_MAX) )
  {
    LOG_MSG_ERROR_1("Invalid cl_sp %p", cl_sp);
    return NULL;
  }

  return qmi_wds_state[cl_sp->current_wds_state][cl_sp->wds_inst];

} /* qmi_wdsi_get_wds_sp_by_cl_sp() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_CL_SP_BY_CL_ID()

  DESCRIPTION
    to get the wireless service client state ptr from the client id

  PARAMETERS
    wds_sp : wds state ptr (either v4 or v6 is ok)
    clid:    client id

  RETURN VALUE
    client state ptr

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_wdsi_client_state_type * qmi_wdsi_get_cl_sp_by_clid_debug
(
  qmi_wdsi_state_type * wds_sp,
  uint8                 clid,
  int                   line_num
)
{
  qmi_wdsi_client_state_type * cl_sp;
  int                          i;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (wds_sp == NULL)
  {
    // Search all WDS states
    for (i = 0; i < WDS_INSTANCE_MAX; i++)
    {
      wds_sp = qmi_wds_state[WDSI_IPV4_STATE][i];
      if (wds_sp == NULL)
      {
        continue;
      }

      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if (cl_sp->common.clid == clid)
        {
          return cl_sp;
        }
        cl_sp = cl_sp->next;
      }
    }
  }
  else
  {
    cl_sp = wds_sp->client_list;
    while (cl_sp != NULL)
    {
      if (cl_sp->common.clid == clid)
      {
        return cl_sp;
      }
      cl_sp = cl_sp->next;
    }
  }

  LOG_MSG_INFO1_2("clid %d does not exists, caller_line:%d",clid,line_num);

  return NULL;

} /* qmi_wdsi_get_cl_sp_by_clid() */


/*===========================================================================
  FUNCTION QMI_WDSI_NET_IF_STARTED()

  DESCRIPTION
    checks if the network interface is already started

  PARAMETERS
    wds_sp :  wireless data service state ptr

  RETURN VALUE
    TRUE  : started
    FALSE : not started

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_wdsi_net_if_bound
(
  qmi_wdsi_state_type *  wds_sp
)
{
  qmi_wdsi_client_state_type *  cl_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (wds_sp == NULL)
  {
    DATA_ERR_FATAL("NULL wds_sp");
    return FALSE;
  }

  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
    if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
    {
      if (cl_sp->net_bound)
      {
        return TRUE;
      }
    }
    cl_sp = cl_sp->next;
  }

  return FALSE;
} /* qmi_wdsi_net_if_bound() */



/*===========================================================================
  FUNCTION QMI_WDSI_STOP_NET_IFACE_CLIENT()

  DESCRIPTION
    Release the WWAN packet data connection (unless other control points are
    using it)

  PARAMETERS
    cl_sp : client specific wireless data service state ptr

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_type_v01 qmi_wdsi_stop_net_iface_client
(
  qmi_wdsi_client_state_type *  cl_sp,
  qmi_wdsi_force_type           force,
  boolean                    *  pending_resp
)
{
  qmi_wdsi_state_type *  wds_sp;
#ifdef FEATURE_DATA_QMI_MCAST
  ps_iface_ioctl_mcast_leave_type mcast_leave;
  int16 ps_errno;
  uint8  i;
#endif /* FEATURE_DATA_QMI_MCAST */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (cl_sp);

  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);
  *pending_resp = FALSE;

  if( NULL == wds_sp)
  {
    LOG_MSG_INFO2_0("Invalid value of wds state ptr");
    return QMI_ERR_INTERNAL_V01;
  }

  LOG_MSG_INFO2_1 ("Client %d stop network interface", cl_sp->common.clid);
#ifdef FEATURE_DATA_QMI_MCAST
  /*-------------------------------------------------------------------------
    release any mcast sessions owned by this client
  -------------------------------------------------------------------------*/
  for(i=0; i < WDSI_MAX_MCAST_SESSIONS; i++)
  {
    if(wds_mcast_info[i].cl_sp == cl_sp)
    {
      mcast_leave.handle = wds_mcast_info[i].handle;
      (void) ps_iface_ioctl(wds_sp->um_iface_ptr,
                            PS_IFACE_IOCTL_MCAST_LEAVE,
                            &mcast_leave,
                            &ps_errno);
      /*---------------------------------------------------------------------
        since client is stoping the call, we clear the mcast info stored for
        this client and do not send dereg event back
      ---------------------------------------------------------------------*/
      wds_sp->num_mcast_reqs--;
      memset(&wds_mcast_info[i], 0, sizeof(wds_mcast_info[i]));
    }
  }
#endif /* FEATURE_DATA_QMI_MCAST */

  if ((!cl_sp->net_bound) && (force == WDSI_FORCE_REASON_DEFAULT))
  {
    LOG_MSG_INFO2_1 ("NW interface never started or already stopped by clid %d!",
                     cl_sp->common.clid);
    return QMI_ERR_NO_EFFECT_V01;
  }
  else
  {
    /*-----------------------------------------------------------------------
      Release client's hold on net interface
    -----------------------------------------------------------------------*/
    cl_sp->net_bound = FALSE;

    /*-----------------------------------------------------------------------
      If no other client has the net interface started &&
      Autoconnect is disabled  release it
    -----------------------------------------------------------------------*/
    if ((!qmi_wdsi_net_if_bound( wds_sp )) &&
        (rmnet_meta_sm_is_auto_connect_enabled(
                                 wds_sp->binding.rmnet_inst) == FALSE))
    {
      if (rmnet_meta_sm_in_call(wds_sp->binding.rmnet_inst) || (force == WDSI_FORCE_REASON_ABORT))
      {
        LOG_MSG_INFO2_0("Last client releases RmNet call");

        /*---------------------------------------------------------------------
          Post event to WWAN RMSM to end call.
        ---------------------------------------------------------------------*/
        rmnet_meta_sm_post_event(wds_sp->binding.rmnet_inst,
                                 RMNET_META_SM_RM_LINK_DOWN_EV);
        *pending_resp = TRUE;
      }
      else
      {
        LOG_MSG_INFO2_0("Rm iface already down");
      }
      return QMI_ERR_NONE_V01;
    }
    else
    {
      LOG_MSG_INFO2_0("Network interface left up for other clients");
      return QMI_ERR_NONE_V01;
    }
  }
} /* qmi_wdsi_stop_net_iface_client() */



/*===========================================================================
  FUNCTION QMI_WDSI_SET_PKT_STATS_REPORTS()

  DESCRIPTION
    Set the conditions for packet statistics reporting

  PARAMETERS
    cl_sp : cleint specific wds state pointer (user data)
    stat_ind_period   : pkt statistics indication time interval
    stat_mask         : pkt statistics mask

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_set_pkt_stats_reports
(
  qmi_wdsi_client_state_type *  cl_sp,
  uint8                         stat_ind_period,
  uint32                        stat_mask
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*-------------------------------------------------------------------------
    Clear any outstanding pkt stats report timer, save the new settings
    and start the timer again (if applicable)
  -------------------------------------------------------------------------*/
  if (cl_sp->report_status.pkt_stats_period != 0)
  {
    (void) timer_clr( &cl_sp->pkt_stats_timer,
                      T_NONE );
  }

  cl_sp->report_status.pkt_stats_period = stat_ind_period;
  cl_sp->report_status.ind_mask         = stat_mask;

  if (cl_sp->report_status.pkt_stats_period != 0 &&
      cl_sp->report_status.ind_mask != WDSI_STAT_MASK_NONE)
  {
    timer_set( &cl_sp->pkt_stats_timer,
               cl_sp->report_status.pkt_stats_period,
               cl_sp->report_status.pkt_stats_period,
               T_SEC );
  }
  else
  {
    (void) timer_clr( &cl_sp->pkt_stats_timer,
                      T_NONE );
  }
} /* qmi_wdsi_set_pkt_stats_reports() */

/*===========================================================================
  FUNCTION QMI_WDSI_DUN_SET_PKT_STATS_REPORTS()

  DESCRIPTION
    Set the conditions for packet statistics reporting

  PARAMETERS
    cl_sp : cleint specific wds state pointer (user data)
    stat_ind_period   : pkt statistics indication time interval
    stat_mask         : pkt statistics mask

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_dun_set_pkt_stats_reports
(
  qmi_wdsi_client_state_type *  cl_sp,
  uint8                         stat_ind_period,
  uint32                        stat_mask
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*-------------------------------------------------------------------------
    Clear any outstanding pkt stats report timer, save the new settings
    and start the timer again (if applicable)
  -------------------------------------------------------------------------*/
  if (cl_sp->modem_rpt_status.pkt_stats_period != 0)
  {
    (void) timer_clr( &cl_sp->dun_stats_timer,
                      T_NONE );
  }

  cl_sp->modem_rpt_status.pkt_stats_period = stat_ind_period;
  cl_sp->modem_rpt_status.ind_mask         = stat_mask;

  if (cl_sp->modem_rpt_status.pkt_stats_period != 0 &&
      cl_sp->modem_rpt_status.ind_mask != WDSI_STAT_MASK_NONE)
  {
    timer_set(&cl_sp->dun_stats_timer,
              cl_sp->modem_rpt_status.pkt_stats_period,
              cl_sp->modem_rpt_status.pkt_stats_period,
              T_SEC );
  }
  else
  {
    (void) timer_clr(&cl_sp->dun_stats_timer,
                     T_NONE );
  }
} /* qmi_wdsi_dun_set_pkt_stats_reports() */

/*===========================================================================
  FUNCTION wdsi_data_system_status_change_cb()

  DESCRIPTION
    This the callback that we have registered with PS Sys layer for
    system status change event. 

  PARAMETERS
    tech_type      : technology for which system status has changed
    event_name     : Event name
    subs_id: Subscription identifier
    event_info_ptr : System status event info which includes fields like
                     preferred network, rat mask, so mask
    user_data_ptr  : Optional user data to be sent.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_data_system_status_change_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
  qmi_wdsi_curr_data_system_status_type * wds_system_status;
  ps_sys_system_status_type * system_status;
  int cnt_network;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(event_info_ptr);

  system_status = (ps_sys_system_status_type *)event_info_ptr;
 
  cmd_ptr = (qmi_wdsi_cmd_buf_type *)
              qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_DATA_SYSTEM_STATUS_CHANGE_EVT);

  if( cmd_ptr == NULL)
  {
    return;
  }

  wds_system_status = &cmd_ptr->data.data_system_status;

  /* Assign event info to local structure*/
  wds_system_status->preferred_network = 
    (uint8)system_status->preferred_network;

  /* MH layer is going to fill up rat mask and so mask for all
     technologies. In case if one of them is not present, it would be
     rat mask and so mask would set to zero.We are filtering out WLAN
     as technology for non epdg PLs.*/
  wds_system_status->network_info_len = (uint8)WDSI_SYS_NETWORK_MAX;

  /* PS API gaurantees that order of technologies returned is fixed
     and hence qmi can rely on loop index for network type in tlv
     field. Ex 0 = 3gpp, 1 = 3gpp2 WLAN is currently filtered out for 
     non epdg PLs*/
  for (cnt_network=0; cnt_network < wds_system_status->network_info_len; cnt_network++)
  {
    wds_system_status->network_info[cnt_network].network =
      (uint8)cnt_network;
    wds_system_status->network_info[cnt_network].rat_mask =
      system_status->network_info[cnt_network].rat_mask;
    wds_system_status->network_info[cnt_network].so_mask =
      system_status->network_info[cnt_network].so_mask;
  }

  cmd_ptr->cmd_id = QMI_CMD_WDS_DATA_SYSTEM_STATUS_CHANGE_EVT;
  cmd_ptr->subscription_id = subscription_id;

  dcc_send_cmd_ex (DCC_QMI_CMD, cmd_ptr);
} /* wdsi_data_system_status_change_cb() */


/*===========================================================================
  FUNCTION QMI_WDSI_PKT_STATS_TIMER_CB()

  DESCRIPTION
    Rex timer callback for packet statistics reporting.  It queues a command
    back to the WDS serving task to generate WDS_EVENT_REPORT_INDs to any
    registered client(s).

  PARAMETERS
    user_data  : points to the WDS client state structure of the client
                 who registered for pkt_stats reporting

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    Generates the WDS_START_NETWORK_INTERFACE response if the route_get
    failed.
===========================================================================*/
static void qmi_wdsi_pkt_stats_timer_cb
(
  timer_cb_data_type  user_data
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(user_data);

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_SEND_PKT_STATS);
  if( cmd_ptr == NULL)
  {
    return;
  }

  cmd_ptr->cmd_id                    = QMI_CMD_SEND_PKT_STATS;
  cmd_ptr->data.send_pkt_stats.clid  = (uint8) user_data;

  dcc_send_cmd_ex (DCC_QMI_CMD, cmd_ptr);
} /* qmi_wdsi_pkt_stats_timer_cb() */

/*===========================================================================
  FUNCTION QMI_WDSI_DUN_STATS_TIMER_CB()

  DESCRIPTION
    Rex timer callback for DUN packet statistics reporting.  It queues a
    command back to the WDS serving task to generate a DUN status
    indication to the registered client.

  PARAMETERS
    user_data  : points to the WDS client state structure of the client
                 who registered for pkt_stats reporting

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_dun_stats_timer_cb
(
  timer_cb_data_type  user_data
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_SEND_DUN_PKT_STATS);
  if( cmd_ptr == NULL)
  {
    return;
  }

  cmd_ptr->cmd_id                    = QMI_CMD_SEND_DUN_PKT_STATS;
  cmd_ptr->data.send_pkt_stats.clid  = (uint8) user_data;

  dcc_send_cmd_ex (DCC_QMI_CMD, cmd_ptr);

} /* qmi_wdsi_pkt_stats_timer_cb() */

/*===========================================================================
  FUNCTION WDS_RMNET_IFACE_BINDING_COMPLETE_CB()

  DESCRIPTION
    Callback when rmnet binding is complete

  PARAMETERS
    rmnet_iface_ptr: rmnet iface pointer
    ep_id:           Endpoint ID
    mux_id:          MUX id
    is_v6:           is V6 call
    subs_id:         Subscription identifier

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void wds_rmnet_iface_binding_complete_cb
(
  ps_iface_type *       rmnet_iface_ptr,
  uint32                ep_id,
  uint8                 mux_id,
  uint8                 is_v6,
  uint32                subs_id
)
{
  uint8                 wds_inst;
  qmi_wdsi_state_type * wds_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(rmnet_iface_ptr);

  wds_inst = wdsi_get_inst_from_ep_and_mux_id(ep_id, mux_id);
  if (wds_inst >= WDS_INSTANCE_MAX)
  {
    // This may happen in autoconnect case. RmNet is up but WDS has not
    // allocated any client so WDS inst is not bound.
    // Let's try to bind an WDS inst.
    wds_inst = wdsi_get_unbound_inst(ep_id, mux_id, FALSE);
    if (wds_inst >= WDS_INSTANCE_MAX)
    {
      LOG_MSG_ERROR_0("No avaialbe WDS inst");
      return;
    }

    if (!qmi_wdsi_inst_bind(wds_inst, ep_id, mux_id, FALSE))
    {
      return;
    }
  }

  if( 0 == is_v6)
    wds_sp = qmi_wds_state[WDSI_IPV4_STATE][wds_inst];
  else
    wds_sp = qmi_wds_state[WDSI_IPV6_STATE][wds_inst];

  wds_sp->rmnet_iface_ptr = rmnet_iface_ptr;
  wds_sp->binding.subscription_id = subs_id;

  /* Register for events on Rmnet iface */
  if(wds_sp->reg_rmnet_iface_ev == FALSE)
  {
    wdsi_reg_rmnet_iface_ev(wds_sp);
  }
  else
  {
    LOG_MSG_ERROR_0("WDS should have de-reg rmnet iface events at this point");
  }
} /* wds_rmnet_iface_binding_complete_cb */

/*===========================================================================
FUNCTION   WDS_RMNET_FLOW_CTRL_CB()

DESCRIPTION
  This callback function is called when flow control events occur on
  RmNet interface. An indication will be sent to registered clients. 

PARAMETERS
    rmnet_inst:         RMNET instance
    uplink_flow_ctrl:   Uplink flow ctrl status 

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
void wds_rmnet_flow_ctrl_cb
(
   uint32                          ep_id,
   uint8                           mux_id,
   uint8                           is_v6,
   boolean                         uplink_flow_ctrl
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)
                 qmi_wdsi_get_cmd_buf(QMI_CMD_SEND_FLOW_CTRL);
  if ( cmd_ptr == NULL)
  {
    return;
  }

  cmd_ptr->cmd_id                          = QMI_CMD_SEND_FLOW_CTRL;
  cmd_ptr->data.flow_ctrl.ep_id            = ep_id;
  cmd_ptr->data.flow_ctrl.mux_id           = mux_id;
  cmd_ptr->data.flow_ctrl.is_v6            = is_v6;
  cmd_ptr->data.flow_ctrl.uplink_flow_ctrl = uplink_flow_ctrl;

  dcc_send_cmd_ex (DCC_QMI_CMD, cmd_ptr);
} /* wds_rmnet_flow_ctrl_cb() */

/*===========================================================================
FUNCTION   QMI_WDSI_PROCESS_FLOW_CTRL_EVENT()

DESCRIPTION
  This callback function is called when flow control events occur on
  RmNet interface. An indication will be sent to registered clients. 

PARAMETERS
    ep_id:              End point ID
    mux_id:             mux ID
    is_v6:              is V6 call 
    uplink_flow_ctrl:   Uplink flow ctrl status 
    call_ending:        is call ending

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_process_flow_ctrl_event 
(
   uint32                          ep_id,
   uint8                           mux_id,
   uint8                           is_v6,
   boolean                         uplink_flow_ctrl,
   boolean                         call_ending
)
{
  qmi_wdsi_state_type * wds_sp;
  uint8                 wds_inst;
  ps_iface_addr_family_type   ip_family;
  ds_qmap_cmd_flow_ctrl_type  qmap_fc_cmd;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_inst = wdsi_get_inst_from_ep_and_mux_id(ep_id, mux_id); 
  if (wds_inst >= WDS_INSTANCE_MAX)
  {
    LOG_MSG_INFO2_2("Ignore fc as EP 0x%x mux_id %d is not bound",
                         ep_id, mux_id);
    return;
  }

  if (is_v6)
  {
    wds_sp = qmi_wds_state[WDSI_IPV6_STATE][wds_inst];
    ip_family = IPV6_ADDR;
  }
  else
  {
    wds_sp = qmi_wds_state[WDSI_IPV4_STATE][wds_inst];
    ip_family = IPV4_ADDR;
  }

  if (wds_sp == NULL)
  {
    ASSERT(0);
    return;
  }

  /*-------------------------------------------------------------------------
   * Generate QMAP and WDS flow control status while in a call. If the call
   * is endded, force to gereate a flow enable if the last status is diable
  -------------------------------------------------------------------------*/
  if ( (wds_sp->pkt_svc_state != QMI_WDS_CONN_DISCONNECTED && !call_ending) ||
       (call_ending && uplink_flow_ctrl != wds_sp->uplink_flow_ctrl) )
  {
    if (uplink_flow_ctrl)
    {
      qmi_wdsi_global.num_flow_disable++;
      wds_sp->uplink_fc_seq_num++;
      ds_qmap_build_flow_disable_cmd(
                   &qmap_fc_cmd,
                   (uint8)ip_family,
                   wds_sp->uplink_fc_seq_num,
                   0xFFFFFFFF);
    }
    else
    {
      qmi_wdsi_global.num_flow_enable++;
      ds_qmap_build_flow_enable_cmd(
                   &qmap_fc_cmd,
                   (uint8)ip_family,
                   wds_sp->uplink_fc_seq_num,
                   0xFFFFFFFF);
    }

    // Send QMAP command
    rmnet_send_qmap_cmd(
                 wds_sp->binding.rmnet_inst,
                 sizeof(qmap_fc_cmd),
                 &qmap_fc_cmd);

    // Send QMI command
    qmi_wdsi_generate_flow_ctrl_ind(
                  wds_sp,
                  (uint8)uplink_flow_ctrl,
                  wds_sp->uplink_fc_seq_num);

    wds_sp->uplink_flow_ctrl = uplink_flow_ctrl;
  }

} /* qmi_wdsi_process_flow_ctrl_event() */


/*===========================================================================
FUNCTION   WDSI_NET_IFACE_EV_CB()

DESCRIPTION
  This callback function is called when one of the registered ps_iface events
  occur on RmNet interface.  DOWN and CONFIGURING RmNet iface events are
  registered, and affect the outcome of pending Start Network Interface
  requests.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void wdsi_net_iface_ev_cb
(
  ps_iface_type             *this_iface_ptr,
  ps_iface_event_enum_type   event,
  ps_iface_event_info_u_type event_info,
  void                      *user_data_ptr
)
{
  qmi_wdsi_state_type *         wds_sp;
  qmi_wdsi_client_state_type *  cl_sp;
  time_type                     curr_time;
  boolean                       is_mip_error;
#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP) )
  qmi_nv_status_e_type          qmi_nv_status;
  uint8                         mip_status;
  uint8                         nv_mip_status;
  ps_iface_ioctl_data_call_enum_type call_type;
#endif   /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
          defined(FEATURE_DS_MOBILE_IP) ) */
#ifndef FEATURE_DATA_WLAN_MAPCON
  ps_iface_bearer_technology_type bearer_tech;
#endif /* FEATURE_DATA_WLAN_MAPCON */
  sint15                          ps_errno;
  boolean                         got_data_bearer = FALSE;
  qmi_wdsi_data_call_e_type       data_call_type= WDSI_DATA_CALL_NONE;
  boolean                         reconfig_reqd;
  uint8                           addr_family;
  qmi_wdsi_state_type *           wds_sp_v4 = NULL;
  qmi_wdsi_state_type *           wds_sp_v6 = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (user_data_ptr);
  wds_sp = (qmi_wdsi_state_type *) user_data_ptr;

  LOG_MSG_INFO2_2( "Recvd iface ev %d from 1x i/f 0x%x",
                   event, this_iface_ptr );

  /*-------------------------------------------------------------------------
    Act on Rm Iface events.
    - start network interface:  complete outstanding requests
    - media connect:  Generate connected on iface routable.
                      Generate disconnect on iface down.
  -------------------------------------------------------------------------*/
  switch( event )
  {
    case IFACE_CONFIGURING_EV:
    {
      /*---------------------------------------------------------------------
        Start Network Interface is successful
      ---------------------------------------------------------------------*/
      LOG_MSG_INFO1_0 ("Net interface is connected!");
      wdsi_start_net_attempt_complete( wds_sp, QMI_ERR_NONE_V01);
      /*---------------------------------------------------------------------
        Make sure datapath is all set up before sending Media Connect
      ---------------------------------------------------------------------*/
      if(wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED)
      {
        wds_sp->um_iface_ptr =
                rmnet_meta_sm_get_um_iface(wds_sp->binding.rmnet_inst);
        ASSERT (wds_sp->um_iface_ptr);

        /*-------------------------------------------------------------------
          Register for desired events with Um_Phys_link and Um Iface
        -------------------------------------------------------------------*/
        wdsi_reg_um_phys_link_ev( wds_sp );
      #ifdef FEATURE_DATA_QMI_MCAST
        if(wds_sp->is_mcast_inst == TRUE)
        {
          if(wds_sp->reg_mcast_iface_ev == FALSE)
          {
            /*---------------------------------------------------------------
            Register for mcast events with Um iface
            ---------------------------------------------------------------*/
            wdsi_reg_iface_mcast_event(wds_sp);
          }
        }
      #endif /* FEATURE_DATA_QMI_MCAST */

        /* Register eMBMS events */
        if (wds_sp->is_embms_inst == TRUE)
        {
          wdsi_reg_iface_embms_event(wds_sp);
        /*-------------------------------------------------------------------
          Some eMBMS events could have been missed before event registration
          due to race condition. Request MH explicitly to send the
          interested events
        -------------------------------------------------------------------*/
          wdsi_request_available_embms_events(wds_sp);
        }
        
        /* Register for Um iface events */
        if (wds_sp->reg_um_iface_ev == FALSE)
        {
            wdsi_reg_um_iface_ev( wds_sp);
        }
        /*-------------------------------------------------------------------
          If client already requested registering for internal iface events
          then register for internal iface events as well
        -------------------------------------------------------------------*/
        if (wds_sp->internal_iface_ev_reg == TRUE)
        {
          wdsi_reg_internal_um_iface_ev( wds_sp );
        }

#ifdef FEATURE_EPC_HANDOFF
        /* Register handoff events */
        if (wds_sp->handoff_iface_ev_reg == TRUE)
        {
          wdsi_reg_iface_handoff_event(wds_sp);
        }
#endif /* FEATURE_EPC_HANDOFF */

        qw_set(wds_sp->total_active_time, 0, 0);

        /* Store the current time in the wds state */
        time_get_uptime_ms( wds_sp->call_connect_time );

#ifdef FEATURE_DATA_WLAN_MAPCON
        if (ps_iface_ioctl(wds_sp->um_iface_ptr,
                           PS_IFACE_IOCTL_GET_BEARER_TECHNOLOGY_EX,
                           &wds_sp->curr_data_bearer_cache,
                           &ps_errno) == 0)
        {
          /*cache WDS state current data bearer tech*/
          got_data_bearer = TRUE;

          memscpy((void *) &(wds_sp->last_data_bearer_cache),
                  sizeof(ds_sys_system_status_info_type),
                 (void *) &(wds_sp->curr_data_bearer_cache),
                 sizeof(ds_sys_system_status_info_type));
          wds_sp->is_last_data_bearer_cache_set = TRUE;
        }
        else
        {
          LOG_MSG_ERROR_4("Couldn't initialize RmNet data bearer cache (still set to %d,%d,0x%llx): "
                          "IOCTL gave errno %d",
                          wds_sp->curr_data_bearer_cache.technology,
                          wds_sp->curr_data_bearer_cache.rat_value,
                          wds_sp->curr_data_bearer_cache.so_mask,
                          ps_errno);
        }
#else
        if (ps_iface_ioctl(wds_sp->um_iface_ptr,
                           PS_IFACE_IOCTL_GET_BEARER_TECHNOLOGY,
                           &bearer_tech,
                           &ps_errno) == 0)
        {
          /*cache WDS state current data bearer tech*/
          wds_sp->curr_data_bearer_cache = wdsi_get_curr_data_bearer_tech(bearer_tech);
          got_data_bearer = TRUE;

          /*for 'last' data bearer, do not cache NULL or unknown */
          if (TRUE == wdsi_data_bearer_tech_is_valid(wds_sp->curr_data_bearer_cache))
          {
            memscpy((void *) &(wds_sp->last_data_bearer_cache),
                    sizeof(qmi_wdsi_curr_data_bearer_tech_type),
                   (void *) &(wds_sp->curr_data_bearer_cache),
                   sizeof(qmi_wdsi_curr_data_bearer_tech_type));
          }
          else
          {
            LOG_MSG_INFO1_0("Ignoring null bearer ");
          }
        }
        else
        {
          LOG_MSG_ERROR_2("Couldn't initialize RmNet data bearer cache (still set to %d): "
                          "IOCTL gave errno %d",
                          wds_sp->curr_data_bearer_cache.current_nw, ps_errno);
        }
#endif /* FEATURE_DATA_WLAN_MAPCON */
 
        reconfig_reqd = FALSE; 
     
      }
      else
      {
        reconfig_reqd = TRUE; 
        LOG_MSG_INFO2_0 ("Reconfig required set to true"); 
      }

      /*---------------------------------------------------------------------
        Send Data Call Status indication
      ---------------------------------------------------------------------*/
      LOG_MSG_INFO2_0 ("Retrieving rment call type and sending call status ");
      addr_family = ps_iface_get_addr_family(wds_sp->um_iface_ptr);
      qmi_wdsi_get_rmnet_data_call_type(&data_call_type, 
                                        wds_sp->binding.rmnet_inst);
	  		 
      if (data_call_type != WDSI_DATA_CALL_NONE)
      {
        /* Data call status (UP) indication for RmNet calls is sent when the
         * Um iface comes up and configuring ind gets posted on RmNet Iface */
         qmi_wdsi_process_data_call_status_change(WDSI_CALL_ACTIVATED,
                                                  data_call_type,
                                                  addr_family,
                                                  wds_sp->binding.subscription_id);
      }            

      /*-------------------------------------------------------------------------        
        - If its a new call(i.e. previous state is disconnected) send
          media connect with reconfig_reqd = FALSE
        - if it is because of IP addr change(i.e. previous state is connected)
          send media connect with reconfig_reqd = TRUE (driver will translate
          this into disconnect followed by connect for NDIS)
      -------------------------------------------------------------------------*/
      wdsi_media_connected(wds_sp,reconfig_reqd); 
      if (got_data_bearer) 
      {
        LOG_MSG_INFO2_0("RmNet call up. Report current data bearer tech");
        qmi_wdsi_generate_curr_data_bearer_tech_ind( wds_sp, 
#ifdef FEATURE_DATA_WLAN_MAPCON
                                          wds_sp->curr_data_bearer_cache );
#else
                                         &(wds_sp->curr_data_bearer_cache) );
#endif /* FEATURE_DATA_WLAN_MAPCON */
      }

      /* We can now store technology type & IP address (converted to little endian order)  */
      wds_sp->callhist_data.ipv4_addr =
                                 PS_IFACE_IP_V4_ADDR(wds_sp->um_iface_ptr);
      wds_sp->callhist_data.ipv4_addr =
                                 ps_ntohl(wds_sp->callhist_data.ipv4_addr);
#ifdef FEATURE_DATA_WLAN_MAPCON
      if (DS_SYS_SO_EX_3GPP_S2B == wds_sp->curr_data_bearer_cache.so_mask)
      {
        wds_sp->callhist_data.tech_type_e = QMI_WDS_BEARER_TECH_IWLAN_S2B;
      }
      else
      {
        qmi_wdsi_curr_data_bearer_tech_type bearer_tech_info;
        wdsi_get_current_data_bearer_tech(wds_sp->curr_data_bearer_cache, &bearer_tech_info);
        wds_sp->callhist_data.tech_type_e = wdsi_get_data_bearer_tech(
                                            bearer_tech_info );
      }
#else
      wds_sp->callhist_data.tech_type_e = wdsi_get_data_bearer_tech(
                                 wds_sp->curr_data_bearer_cache );
#endif /* FEATURE_DATA_WLAN_MAPCON */

      /* Get a timestampe */
      (void) time_get(curr_time);
      qw_equ(QW_CVT_N2Q(&wds_sp->callhist_data.date), curr_time);

      LOG_MSG_INFO2_2("Call History got IFACE_CONFIGURING_EV: IP is 0x%08x and data bearer is %d",
                      wds_sp->callhist_data.ipv4_addr,
                      wds_sp->callhist_data.tech_type_e);
      wds_sp->callhist_data.has_connected = TRUE;

      if (qmi_wdsi_global.call_status_cb != NULL &&
          wds_sp->binding.is_reversed == FALSE)
      {
        qmi_wdsi_global.call_status_cb(wds_sp->binding.ep_id,
                                       wds_sp->binding.mux_id,
                                       QMI_AF_INET6 == wds_sp->cur_ip_call_type,
                                       TRUE);
      }
#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP))
      wds_sp->um_iface_ptr =
              rmnet_meta_sm_get_um_iface(wds_sp->binding.rmnet_inst);
      ASSERT (wds_sp->um_iface_ptr);
      if (ps_iface_ioctl(wds_sp->um_iface_ptr,
                         PS_IFACE_IOCTL_707_GET_DATA_CALL_TYPE,
                         &call_type,
                         &ps_errno) == 0)
      {
        if ( PS_IFACE_IOCTL_DATA_CALL_TYPE_MIP == call_type )
        {
          mip_status = 0;
          qmi_nv_status = qmi_nv_read(QMI_NV_ITEM_LAST_RMNET_MIP_ERR_CODE,
                                      0,
                                      0,
                                      &nv_mip_status,
                                      sizeof(nv_mip_status));

          if ( (QMI_NV_STATUS_OK == qmi_nv_status) && ( nv_mip_status == mip_status) )
          {
            LOG_MSG_INFO2_1("MIP status is the same (%d)", mip_status);
          }
          else
          {
            nv_mip_status = mip_status;
            qmi_nv_status = qmi_nv_write(QMI_NV_ITEM_LAST_RMNET_MIP_ERR_CODE,
                                         0,
                                         0,
                                         &nv_mip_status,
                                         sizeof(nv_mip_status));
            if( QMI_NV_STATUS_OK != qmi_nv_status )
            {
              LOG_MSG_ERROR_1("Unable to write NV for MIP status(%x)",
                              qmi_nv_status);
            }
          }

          cl_sp = wds_sp->client_list;
          while (cl_sp != NULL)
          {
            if (cl_sp->report_status.report_mip_status)
            {
              qmi_wdsi_event_report_ind(wds_sp,
                                      cl_sp->common.clid,
                                      WDSI_REPORT_STATUS_MIP_STATUS,
                                      0,
                                      0,
                                      NULL,
                                      QMI_WDS_BEARER_TECH_UNKNOWN,
                                      0,
                                      (qmi_wds_dormancy_status_e_type) 0,
                                      NULL,
                                      0,
                                      WDSI_CALL_UKNOWN,
                                      WDSI_DATA_CALL_NONE,
                                      0,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);
            }
            cl_sp = cl_sp->next;
          } /* while */
        } /*if ( call_type == PS_IFACE_IOCTL_DATA_CALL_TYPE_MIP )*/
      } /*PS_IFACE_IOCTL_707_GET_DATA_CALL_TYPE*/
      else
      {
        LOG_MSG_ERROR_1("Couldn't get call type info IOCTL gave errno %d",
                        ps_errno);
      }
#endif   /* ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
            defined(FEATURE_DS_MOBILE_IP)) */
      break;
    }

    case IFACE_COMING_UP_EV:
    {
      // route get succeeded - cache state
      break;
    }

    case IFACE_DOWN_EV:
    {
      /* Clear the previous call end reason */
      wds_sp->call_end_reason = QMI_WDS_CALL_END_REASON_MIN;
      LOG_MSG_INFO1_0 ("Net interface is disconnected!");

      wds_sp->call_end_reason = qmi_wdsi_map_wds_call_end_reason(
                                  event_info.iface_down_info.netdown_reason
                                );
      wds_sp->call_end_reason_verbose = (uint32) event_info.iface_down_info.netdown_reason;
      LOG_MSG_INFO2_1 ("Call end reason = %d", wds_sp->call_end_reason);

      is_mip_error = ( (event_info.iface_down_info.netdown_reason & 0xFFFF0000) 
                                  == QMI_WDS_MIP_ERR_CODE_MASK ) ? TRUE : FALSE;
      LOG_MSG_INFO2_3 ("Call end reason = %d : iface reason = 0x%08x : MIP_Error(%d)",
                       wds_sp->call_end_reason,
                       event_info.iface_down_info.netdown_reason,
                       is_mip_error);
      wdsi_start_net_attempt_complete( wds_sp, QMI_ERR_CALL_FAILED_V01);

#if ((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
     defined(FEATURE_DS_MOBILE_IP) )
      if (is_mip_error)
      {
        qmi_nv_status = qmi_nv_read(QMI_NV_ITEM_LAST_RMNET_MIP_ERR_CODE,
                                    0, 0, &nv_mip_status,
                                   sizeof(nv_mip_status));
        mip_status = event_info.iface_down_info.netdown_reason & 0xff;
        if ( (QMI_NV_STATUS_OK == qmi_nv_status) && ( nv_mip_status == mip_status) )
        {
          LOG_MSG_INFO2_1("MIP status is the same %d", mip_status);
        }
        else
        {
          nv_mip_status = mip_status;
          qmi_nv_status = qmi_nv_write(QMI_NV_ITEM_LAST_RMNET_MIP_ERR_CODE,
                                       0,
                                       0,
                                       &nv_mip_status, sizeof(nv_mip_status));
          if( QMI_NV_STATUS_OK != qmi_nv_status )
          {
            LOG_MSG_ERROR_1("Unable to write NV for MIP status(%x)",
                            qmi_nv_status);
          }
        }
      }
#endif /*(((defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)) && \
         defined(FEATURE_DS_MOBILE_IP) )*/

      /*---------------------------------------------------------------------
        Rmnet call is disconnected, so clear the net_bound for each client
        on this QMI instance so that the client can start another call when
        it wants
      ---------------------------------------------------------------------*/
      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
        {
          LOG_MSG_INFO2_2("Client %d unbound from net interface (wds_sp) %x",
                          cl_sp->common.clid, wds_sp);
          cl_sp->net_bound = FALSE;
          /* reset the abortable flag if client is of same instance*/
          if(cl_sp->dormancy_abortable == TRUE)
          {
            cl_sp->dormancy_abortable = FALSE;
            LOG_MSG_INFO1_1("Domancy flag reset for client %0x",cl_sp);
          }
          if (cl_sp->report_status.report_mip_status && is_mip_error &&
              qmi_wdsi_verify_client_subs(cl_sp, wds_sp->binding.subscription_id, TRUE))
          {
            qmi_wdsi_event_report_ind(wds_sp,
                                      cl_sp->common.clid,
                                      WDSI_REPORT_STATUS_MIP_STATUS,
                                      0,
                                      0,
                                      NULL,
                                      QMI_WDS_BEARER_TECH_UNKNOWN,
                                      (event_info.iface_down_info.netdown_reason & 0xff),
                                      (qmi_wds_dormancy_status_e_type) 0,
                                      NULL,
                                      0,
                                      WDSI_CALL_UKNOWN,
                                      WDSI_DATA_CALL_NONE, 
                                      0,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);

          }

          if (wds_sp->pkt_svc_state != QMI_WDS_CONN_DISCONNECTED)
          {
            /* Clear out last-send byte statistic IND's to ensure empty IND's are
               sent to this client the next time the call is connected.*/
            if (cl_sp->report_status.stats_last_rpt.rx_pkts  || 
                cl_sp->report_status.stats_last_rpt.tx_pkts  ||
                cl_sp->report_status.stats_last_rpt.rx_bytes ||
                cl_sp->report_status.stats_last_rpt.tx_bytes)
            {
              LOG_MSG_INFO2_1("Client %d RMNET byte stat's IND non-zero, clearing",
                              cl_sp->common.clid);
              cl_sp->report_status.stats_last_rpt.rx_pkts  = 0;
              cl_sp->report_status.stats_last_rpt.tx_pkts  = 0;
              cl_sp->report_status.stats_last_rpt.rx_bytes = 0;
              cl_sp->report_status.stats_last_rpt.tx_bytes = 0;
            }
          }
        }
        cl_sp = cl_sp->next;
      } /* while */

      /*---------------------------------------------------------------------
        Send the Stop Network Interface Success Response for any pending
        stop_network request and set the command buffer to NULL.
      ---------------------------------------------------------------------*/
      wdsi_stop_net_attempt_complete( wds_sp );

      /*---------------------------------------------------------------------
        Send Data Call Status indication
      ---------------------------------------------------------------------*/
      LOG_MSG_INFO2_0 ("Retrieving rment call type and sending call status ");
      addr_family = event_info.iface_down_info.addr_family;
      qmi_wdsi_get_rmnet_data_call_type(&data_call_type, 
                                        wds_sp->binding.rmnet_inst);
	  		 
      if (data_call_type != WDSI_DATA_CALL_NONE)
      {
        /* Data call status (DOWN) indication for RmNet calls is sent when the
         * um iface goes down and iface down ind gets posted on RmNet Iface */
         qmi_wdsi_process_data_call_status_change(WDSI_CALL_TERMINATED,
                                                  data_call_type,
                                                  addr_family,
                                                  wds_sp->binding.subscription_id);
      }            

      /*-------------------------------------------------------------------
       * Send QMAP flow enable if call is ending
      -------------------------------------------------------------------*/
      qmi_wdsi_process_flow_ctrl_event(
                 wds_sp->binding.ep_id,
                 wds_sp->binding.mux_id,
                 wds_sp->binding.rmnet_inst & 0x1,
                 FALSE,
                 TRUE);

      /*---------------------------------------------------------------------
        Send media disconnect to host
      ---------------------------------------------------------------------*/
      if(wds_sp->pkt_svc_state != QMI_WDS_CONN_DISCONNECTED)
      {        
        /*-------------------------------------------------------------------
          Deregister events with Um_Phys_link and clear/reset the UMiface
          pointer to NULL. Deregister Um Iface events.
        -------------------------------------------------------------------*/
        wdsi_dereg_um_phys_link_ev( wds_sp );
      #ifdef FEATURE_DATA_QMI_MCAST
        /*-------------------------------------------------------------------
          Dereg mcast iface events as call is torn down
        -------------------------------------------------------------------*/
        if(wds_sp->is_mcast_inst == TRUE)
        {
          if(wds_sp->reg_mcast_iface_ev == TRUE)
          {
            wdsi_dereg_iface_mcast_event(wds_sp);
          }
          wds_sp->is_mcast_inst = FALSE;
        }
      #endif /* FEATURE_DATA_QMI_MCAST */

        /* Deregister eMBMS events, clean TMGI pend queues */
        if (wds_sp->is_embms_inst == TRUE)
        {
          wdsi_dereg_iface_embms_event(wds_sp);
          wdsi_tmgi_clean_pend_req(wds_sp, QMI_ERR_OUT_OF_CALL_V01);
          wds_sp->is_embms_inst = FALSE;
        }

        /* Deregister for Um iface events*/
        if (wds_sp->reg_um_iface_ev == TRUE)
        {
          wdsi_dereg_um_iface_ev( wds_sp );
        }
        if (wds_sp->internal_iface_ev_reg == TRUE)
        {
          wdsi_dereg_internal_um_iface_ev( wds_sp );
        }
#ifdef FEATURE_EPC_HANDOFF
        /* Deregister handoff events */
        if (wds_sp->handoff_iface_ev_reg == TRUE)
        {
          wdsi_dereg_iface_handoff_event( wds_sp );
        }
#endif /* FEATURE_EPC_HANDOFF */

        /*-------------------------------------------------------------------
          Clear the um and rmnet iface_ptr stored in wds_sp as call is
          torn down
        -------------------------------------------------------------------*/
        wds_sp->um_iface_ptr = NULL;
        /* Compute call duration and store in last_call_duration */
        time_get_uptime_ms( curr_time );
        qw_sub( wds_sp->last_call_duration,
                curr_time,
                wds_sp->call_connect_time );

        QMI_INCREMENT_TOTAL_ACTIVE_TIME(curr_time);
        qw_equ(wds_sp->last_call_active_duration, 
               wds_sp->total_active_time);

       /* Invalidate DUN's last call timers */
        qw_set(qmi_wdsi_global.modem_dun_last_call_active_duration,
               QMI_WDSI_CALL_DURATION_INVALID_DW,
               QMI_WDSI_CALL_DURATION_INVALID_DW);
       /* Invalidate the DUN values since the last call was now made with RMNet */
        qw_set(qmi_wdsi_global.modem_dun_call_connect_time,
               QMI_WDSI_CALL_DURATION_INVALID_DW,
               QMI_WDSI_CALL_DURATION_INVALID_DW);
        qw_set(qmi_wdsi_global.modem_dun_call_end_time,
               QMI_WDSI_CALL_DURATION_INVALID_DW,
               QMI_WDSI_CALL_DURATION_INVALID_DW);
        qmi_wdsi_global.modem_dun_last_call_end_reason = 
                                                    QMI_WDS_CALL_END_REASON_MIN;
        qmi_wdsi_global.modem_dun_last_data_bearer = 
                                                    QMI_WDS_BEARER_TECH_UNKNOWN;

        wdsi_media_disconnected(wds_sp);
        qmi_wdsi_pbm_add(wds_sp);
      }

      /*-------------------------------------------------------------------------
        Reset wds/rmnet subs id to default 
      -------------------------------------------------------------------------*/
      wds_sp->binding.subscription_id = QMI_WDSI_SUBS_DEFAULT;
      rmnet_meta_sm_set_subs_id(wds_sp->binding.rmnet_inst,
                                QMI_WDSI_SUBS_DEFAULT);
      /*-------------------------------------------------------------------
        Need to do this outside the DISCONNECTED check since we reg for
        rmnet iface events and do the binding between wds - rmnet iface
        before media connect.
        So in case where Start Network Attempt fails, pkt_srvc_status will
        still be disconnected (since we were never connected), but we still
        need to do the below
      -------------------------------------------------------------------*/
      if(wds_sp->reg_rmnet_iface_ev == TRUE)
      {
        /* dereg the events */
        wdsi_dereg_rmnet_iface_ev(wds_sp);

        /* clear the wds - rmnet iface binding */
        wds_sp->rmnet_iface_ptr = NULL;
      }

      if (qmi_wdsi_global.call_status_cb != NULL &&
          wds_sp->binding.is_reversed == FALSE)
      {
        qmi_wdsi_global.call_status_cb(
              wds_sp->binding.ep_id,
              wds_sp->binding.mux_id,
              QMI_AF_INET6 == wds_sp->cur_ip_call_type,
              FALSE);
      }

      /* Unbind WDS state if all clients and calls are released */
      wds_sp_v4 = qmi_wds_state[WDSI_IPV4_STATE][wds_sp->constants.wds_inst];
      wds_sp_v6 = qmi_wds_state[WDSI_IPV6_STATE][wds_sp->constants.wds_inst];
      if ( (wds_sp->client_list == NULL) &&
           (wds_sp_v4 != NULL && wds_sp_v6 != NULL) &&
           (!rmnet_meta_sm_in_call(wds_sp_v4->binding.rmnet_inst)) &&
           (!rmnet_meta_sm_in_call(wds_sp_v6->binding.rmnet_inst)) )
      {
        qmi_wdsi_inst_unbind(wds_sp->constants.wds_inst);
      }

      break;
    }

    case IFACE_AUTHENTICATING_EV:
    {
      if(wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED)
      {
        LOG_MSG_INFO1_1( "Authentication in progress (%08x)", wds_sp );
        qmi_wds_pkt_srvc_status_ind( wds_sp,
                                     NULL,   // broadcast
                                     QMI_WDS_CONN_AUTHENTICATING,
                                     FALSE );
      }
      else
      {
        LOG_MSG_INFO2_1( "Event (%d) occured when call is in connected state",
                         event );
      }
      break;
    }

    default:
    {
      LOG_MSG_ERROR_1("Unregistered event %d recvd, ignoring", event);
      break;
    }
  } /* switch( event ) */
} /* wdsi_net_iface_ev_cb() */

/*===========================================================================
FUNCTION   WDSI_WLAN_IFACE_EV_CB()

DESCRIPTION
  This callback function is called when one of the registered ps_iface events
  occur on WLAN/EPDG interface.  REV_IP_TRANSPORT_CONFIG, DOWN and CONFIGURING iface events are
  registered.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void wdsi_wlan_iface_ev_cb
(
  ps_iface_type             *this_iface_ptr,
  ps_iface_event_enum_type   event,
  ps_iface_event_info_u_type event_info,
  void                      *user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type        *cmd_ptr = NULL;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  LOG_MSG_INFO2_2( "Recvd iface ev %d from WLAN/EPDG i/f 0x%x",
                   event, this_iface_ptr );

  switch( event )
  {

    case IFACE_CONFIGURING_EV:
    case IFACE_REVERSE_IP_TRANSPORT_CONFIG_EV:
    case IFACE_DOWN_EV:
    {
      cmd_ptr = qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_WLAN_IFACE_EVT);
      if( cmd_ptr == NULL)
      {
        return;
      }

      cmd_ptr->cmd_id = QMI_CMD_PROCESS_WLAN_IFACE_EVT;
      cmd_ptr->data.wlan_evt_info.event      = event;
      cmd_ptr->data.wlan_evt_info.iface_ptr  = this_iface_ptr;
      cmd_ptr->data.wlan_evt_info.event_info = event_info;
      cmd_ptr->data.wlan_evt_info.wds_sp = user_data_ptr;
      dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
      break;
    }

    default:
    {
      LOG_MSG_ERROR_1("Unregistered event %d recvd, ignoring", event);
      break;
    }
  } /* switch( event ) */
} /* wdsi_wlan_iface_ev_cb*/
/*===========================================================================
FUNCTION   WDSI_DUN_IFACE_EV_CB()

DESCRIPTION
  This callback function is called when one of the registered ps_iface events
  occur on external interface.  UP, DOWN and ROUTEABLE iface events are
  registered, and affect the DUN call info message and indication behaviour.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void wdsi_dun_iface_ev_cb
(
  ps_iface_type             *this_iface_ptr,
  ps_iface_event_enum_type   event,
  ps_iface_event_info_u_type event_info,
  void                      *user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type        *cmd_ptr = NULL;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  LOG_MSG_INFO2_2( "Recvd iface ev %d from i/f 0x%x", event, this_iface_ptr );

  switch( event )
  {
    case IFACE_UP_EV:
    case IFACE_ROUTEABLE_EV:
    case IFACE_DOWN_EV:
    case IFACE_ACTIVE_OUT_OF_USE_EV:
    case IFACE_ACTIVE_IN_USE_EV:
    {
      cmd_ptr = qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_DUN_CALL_INFO_EVT);
      if( cmd_ptr == NULL)
      {
        return;
      }

      cmd_ptr->cmd_id = QMI_CMD_PROCESS_DUN_CALL_INFO_EVT;
      cmd_ptr->data.dun_call_info.event      = event;
      cmd_ptr->data.dun_call_info.iface_ptr  = this_iface_ptr;
      cmd_ptr->data.dun_call_info.event_info = event_info;
      cmd_ptr->data.dun_call_info.iface_name = (ps_iface_name_enum_type)
                    PS_IFACE_GET_NAME_FROM_ID(PS_IFACE_GET_ID(this_iface_ptr));
      dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
      break;
    }

    default:
    {
      LOG_MSG_ERROR_1("Unregistered event %d recvd, ignoring", event);
      break;
    }
  } /* switch( event ) */
} /* wdsi_dun_iface_ev_cb() */

/*===========================================================================
FUNCTION   WDSI_UM_IFACE_EV_CB()

DESCRIPTION
  This callback function is called when one of the registered ps_flow/ps_iface
  events occur on Um interface. Flow events were registered on ALL flows.

PARAMETERS:
  iface_ptr     : ptr to flow/iface for which event occured
  event         : type of event
  event_info    : info for the event
  user_data_ptr : user data (qos_sp/wds_sp)

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void wdsi_um_iface_ev_cb
(
  ps_iface_type             *iface_ptr,
  ps_iface_event_enum_type   event,
  ps_iface_event_info_u_type event_info,
  void                      *user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type * cmd_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#ifdef FEATURE_DATA_WLAN_MAPCON
  if (event != IFACE_BEARER_TECH_EX_CHANGED_EV)
#else
  if (event != IFACE_BEARER_TECH_CHANGED_EV)
#endif /* FEATURE_DATA_WLAN_MAPCON */
  {
    ASSERT (user_data_ptr);
  }
  LOG_MSG_INFO2_2( "Recvd iface ev %d for UM iface_ptr 0x%x",
                   event, iface_ptr );

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_WDS_UM_IFACE_EVT);
  if( cmd_ptr == NULL)
  {
    return;
  }

  cmd_ptr->cmd_id = QMI_CMD_PROCESS_WDS_UM_IFACE_EVT;
  cmd_ptr->data.iface_info.iface_ptr = iface_ptr;
  cmd_ptr->data.iface_info.event = event;
  cmd_ptr->data.iface_info.event_info = event_info;
  cmd_ptr->data.iface_info.wds_sp = user_data_ptr;

  // For some eMBMS events, need to alloc memory and copy TMGI list
  // since the one in the event_info will be freed after callback.
  if ( (event == IFACE_EMBMS_TMGI_DEACTIVATED_EV) ||
       (event == IFACE_EMBMS_ACTIVE_TMGI_LIST_EV) ||
       (event == IFACE_EMBMS_AVAILABLE_TMGI_LIST_EV) ||
       (event == IFACE_EMBMS_WARNING_TMGI_LIST_EV) )
  {
    if ( wdsi_copy_tmgi_list_from_event(event, &event_info, cmd_ptr) != TRUE )
    {
        LOG_MSG_ERROR_0("Unable to copy TMGI list");
        qmi_wdsi_free_cmd_buf(cmd_ptr);
        return;
    }
  }

#ifdef FEATURE_DATA_EMBMS
  if (event == IFACE_EMBMS_AVAILABLE_SAI_LIST_EV)
  {
    if ( wdsi_copy_sai_list_from_event(event, &event_info, cmd_ptr) != TRUE )
    {
        LOG_MSG_ERROR_0("Unable to copy SAI list");
        qmi_wdsi_free_cmd_buf(cmd_ptr);
        return;
    }
  }
#endif /* FEATURE_DATA_EMBMS */
  if (event == IFACE_EMBMS_CONTENT_DESC_CONTROL_EV)
  {
     if (wdsi_copy_embms_content_desc_update(event, 
                                             &event_info, cmd_ptr) != TRUE) 
     {
        LOG_MSG_ERROR_0("Unable to copy content desc info");
        qmi_wdsi_free_cmd_buf(cmd_ptr);
        return;
     }
  }

  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
} /* wdsi_um_iface_ev_cb() */

/*===========================================================================
FUNCTION   QMI_WDSI_PROCESS_UM_IFACE_EVENT()

DESCRIPTION
  This callback function is called when one of the registered ps_flow events
  occurs. Flow events were registered on ALL flows

PARAMETERS:
  flow_ptr      : ptr to flow for which event occured
  event         : type of event
  event_info    : info for the event
  user_data_ptr : user data (qos_sp)

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_process_um_iface_event
(
  ps_iface_type               * iface_ptr,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  void                        * sp
)
{
  qmi_wdsi_state_type *           wds_sp = NULL;
  qmi_wdsi_curr_data_bearer_tech_type  data_bearer_tech;
#ifndef FEATURE_DATA_WLAN_MAPCON
  ps_iface_bearer_technology_type new_bearer_tech;
#endif /* FEATURE_DATA_WLAN_MAPCON */
  qmi_wds_bearer_tech_e_type      legacy_data_bearer_tech;
#ifdef FEATURE_DATA_QMI_MCAST
  qmi_wdsi_client_state_type *  cl_sp;
  qmi_wdsi_cmd_val_e_type     cmd = WDSI_CMD_VAL_WIDTH; // initialize to remove ARM compiler warning
  ps_iface_mcast_handle_type  mcast_handle;
  uint8                       mcast_status = 0;
#endif /* FEATURE_DATA_QMI_MCAST */
  uint8                       i = 0;
  uint8 state, inst;
  ps_phys_link_type *new_phys_link_ptr = NULL;
  wds_delay_dormancy_result_type_v01 delay_dormancy_result;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

#ifdef FEATURE_DATA_WLAN_MAPCON
  if (event != IFACE_BEARER_TECH_EX_CHANGED_EV)
#else
  if (event != IFACE_BEARER_TECH_CHANGED_EV)
#endif /* FEATURE_DATA_WLAN_MAPCON */
  {
    ASSERT(sp);
    wds_sp = (qmi_wdsi_state_type *) sp;
  }

  switch(event)
  {
#ifdef FEATURE_DATA_QMI_MCAST
    case IFACE_MCAST_REGISTER_SUCCESS_EV:
    case IFACE_MCAST_REGISTER_FAILURE_EV:
    case IFACE_MCAST_DEREGISTERED_EV:
    case IFACE_MBMS_CONTEXT_ACT_SUCCESS_EV:
    case IFACE_MBMS_CONTEXT_ACT_FAILURE_EV:
    case IFACE_MBMS_CONTEXT_DEACT_SUCCESS_EV:
    case IFACE_MBMS_CONTEXT_DEACT_FAILURE_EV:
    case IFACE_MCAST_STATUS_EV:
    {
      for(i=0; i < WDSI_MAX_MCAST_SESSIONS; i++)
      {
        if(wds_mcast_info[i].handle == event_info.mcast_info.handle)
        {
          break;
        }
      }
      if(i == WDSI_MAX_MCAST_SESSIONS)
      {
        LOG_MSG_INFO2_0("Received UM iface MCAST event for non-QMI WDS client,"
                        " ignoring");
        return;
      }
      break;
    }
#endif /* FEATURE_DATA_QMI_MCAST */

    case IFACE_EMBMS_TMGI_ACTIVATED_EV:
    case IFACE_EMBMS_TMGI_DEACTIVATED_EV:
    case IFACE_EMBMS_TMGI_ACTIVATE_DEACTIVATE_RESPONSE_EV:
    case IFACE_EMBMS_ACTIVE_TMGI_LIST_EV:
    case IFACE_EMBMS_AVAILABLE_TMGI_LIST_EV:
#ifdef FEATURE_DATA_EMBMS
    case IFACE_EMBMS_AVAILABLE_SAI_LIST_EV:
#endif /* FEATURE_DATA_EMBMS */
    case IFACE_EMBMS_WARNING_TMGI_LIST_EV:
    case IFACE_EMBMS_CONTENT_DESC_CONTROL_EV:
    {
      qmi_wdsi_generate_embms_ev_ind( wds_sp, event, event_info );
      return;
    }

    case IFACE_APN_PARAM_CHANGED_EV:
    {
      /* If RmNet call is up, send the APN Param Change IND */
      if ((wds_sp->pkt_svc_state == QMI_WDS_CONN_CONNECTED) &&
          (wds_sp->um_iface_ptr == iface_ptr))
     {
       qmi_wdsi_generate_apn_param_changed_ind(wds_sp, event, event_info);
       return;
     }
      break;
    }

#ifdef FEATURE_EPC_HANDOFF
    case IFACE_HANDOFF_INIT_EV:
    case IFACE_HANDOFF_STATUS_SUCCESS_EV:
    case IFACE_HANDOFF_STATUS_FAILURE_EV:
    {
      qmi_wdsi_generate_handoff_ev_ind( wds_sp, event, event_info );
      return;
    }
#endif /* FEATURE_EPC_HANDOFF */

#ifdef FEATURE_DATA_WLAN_MAPCON
    case IFACE_BEARER_TECH_EX_CHANGED_EV:
    {
      ds_sys_system_status_info_type bearer_tech_ex = event_info.bearer_tech_ex_changed_info;
     /*----------------------------------------------------------------
       Indicate the new current data bearer technology -- new format
     ----------------------------------------------------------------*/
      wdsi_get_current_data_bearer_tech(bearer_tech_ex, &data_bearer_tech);
#else
    case IFACE_BEARER_TECH_CHANGED_EV:
    {
     /*----------------------------------------------------------------
       Indicate the new current data bearer technology -- new format
     ----------------------------------------------------------------*/
      new_bearer_tech = event_info.bearer_tech_changed_info.new_bearer_tech;
      data_bearer_tech = wdsi_get_curr_data_bearer_tech(new_bearer_tech);
#endif /* FEATURE_DATA_WLAN_MAPCON */
      legacy_data_bearer_tech = wdsi_get_data_bearer_tech(data_bearer_tech);

      /* check if data bearer vent on the DUN iface */
      if (qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED &&
          qmi_wdsi_global.modem_dun_um_iface_ptr == iface_ptr)
      {
        /* see if data bearer has changed since last reported value */
        if (legacy_data_bearer_tech!=qmi_wdsi_global.modem_dun_last_data_bearer)
        {
          /* if new data bearer, cache it and send out IND's */
          qmi_wdsi_global.modem_dun_last_data_bearer = legacy_data_bearer_tech;

          LOG_MSG_INFO1_0("New DUN data bearer, sending out IND");
          qmi_wdsi_generate_dun_data_bearer_tech_ind(legacy_data_bearer_tech);
          qmi_wdsi_generate_dun_channel_rate_ind(
                                     QMI_IF_CH_RATE_TRIGGER_DATA_BEARER_CHANGE, qmi_wdsi_global.dun_subs_id);
        } /* if (data bearer changed) */
      } /* if (DUN call) */

      for( state = 0; state < WDSI_MAX_STATE; state++ )
      {
        for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
        {
          wds_sp = qmi_wds_state[state][inst];
          if (wds_sp == NULL || wds_sp->binding.is_reversed)
          {
            continue;
          }

          /* If RmNet call is up, send the data bearer tech IND */
#ifdef FEATURE_DATA_WLAN_MAPCON
          if ((wds_sp->pkt_svc_state == QMI_WDS_CONN_CONNECTED) && 
              (wds_sp->um_iface_ptr == iface_ptr))
          {
            if ( (bearer_tech_ex.technology == wds_sp->curr_data_bearer_cache.technology)&&
                 (bearer_tech_ex.rat_value == wds_sp->curr_data_bearer_cache.rat_value)&&
                 (bearer_tech_ex.so_mask == wds_sp->curr_data_bearer_cache.so_mask) )
            {
              LOG_MSG_INFO1_3("New data bearer matches cache technology=(%d) rat_value=(%d) so_mask=(0x%llx), not sending IND",
                              wds_sp->curr_data_bearer_cache.technology,
                              wds_sp->curr_data_bearer_cache.rat_value,
                              wds_sp->curr_data_bearer_cache.so_mask);
            }
            else
            {
              LOG_MSG_INFO2_3 ("Data Bearer Tech changed (technology=%d, ratmask=%d, somask=0x%llx",
                               bearer_tech_ex.technology,
                               bearer_tech_ex.rat_value,
                               bearer_tech_ex.so_mask);

              /* Only send legacy indication if current_nw or rat_mask have changed, as
               * so_mask does not affect the value of this type of data bearer indication. */
              /*if ( (data_bearer_tech.current_nw != wds_sp->curr_data_bearer_cache.current_nw) ||
                   (data_bearer_tech.rat_mask != wds_sp->curr_data_bearer_cache.rat_mask) )
              {*/
              if ((QMI_WDS_BEARER_TECH_UNKNOWN!= legacy_data_bearer_tech) &&
                  (QMI_WDS_BEARER_TECH_NULL!= legacy_data_bearer_tech))
              {
                  qmi_wdsi_generate_data_bearer_tech_ind(wds_sp,
                                                         legacy_data_bearer_tech);
              }
              /*}*/
              /* Cache this value into current data bearer technology */
              memscpy( (void *) &(wds_sp->curr_data_bearer_cache),
                       sizeof(ds_sys_system_status_info_type),
                      (void *) &bearer_tech_ex,
                      sizeof(ds_sys_system_status_info_type) );

              memscpy((void *) &(wds_sp->last_data_bearer_cache),
                      sizeof(ds_sys_system_status_info_type),
                     (void *) &(wds_sp->curr_data_bearer_cache),
                     sizeof(ds_sys_system_status_info_type));
              wds_sp->is_last_data_bearer_cache_set = TRUE;
              
              qmi_wdsi_generate_curr_data_bearer_tech_ind(wds_sp, bearer_tech_ex);
#else
          if (wds_sp->pkt_svc_state == QMI_WDS_CONN_CONNECTED)
          {
            if ( (data_bearer_tech.current_nw == wds_sp->curr_data_bearer_cache.current_nw)&&
                 (data_bearer_tech.rat_mask == wds_sp->curr_data_bearer_cache.rat_mask)&&
                 (data_bearer_tech.so_mask == wds_sp->curr_data_bearer_cache.so_mask) )
            {
              LOG_MSG_INFO1_3("New data bearer matches cache curr_nw=(%d) rat_mask=(%d) so_mask=(%d), not sending IND",
                              data_bearer_tech.current_nw,
                              data_bearer_tech.rat_mask,
                              data_bearer_tech.so_mask);
            }
            else
            {
              LOG_MSG_INFO2_3 ("Data Bearer Tech changed (curr_nw=%d, ratmask=%d, somask=%d",
                               data_bearer_tech.current_nw,
                               data_bearer_tech.rat_mask,
                               data_bearer_tech.so_mask);

              /* Only send legacy indication if current_nw or rat_mask have changed, as
               * so_mask does not affect the value of this type of data bearer indication. */
              if ( (data_bearer_tech.current_nw != wds_sp->curr_data_bearer_cache.current_nw) ||
                   (data_bearer_tech.rat_mask != wds_sp->curr_data_bearer_cache.rat_mask) )
              {
                qmi_wdsi_generate_data_bearer_tech_ind(wds_sp,
                                                       legacy_data_bearer_tech);
              }
              /* Cache this value into current data bearer technology */
              memscpy( (void *) &(wds_sp->curr_data_bearer_cache),
                       sizeof(qmi_wdsi_curr_data_bearer_tech_type),
                      (void *) &data_bearer_tech,
                      sizeof(qmi_wdsi_curr_data_bearer_tech_type) );

              /* for 'last' data bearer, do not cache NULL or unknown */
              if ((QMI_WDS_BEARER_TECH_UNKNOWN != legacy_data_bearer_tech) &&
                  (QMI_WDS_BEARER_TECH_NULL    != legacy_data_bearer_tech))
              {
                memscpy((void *) &(wds_sp->last_data_bearer_cache),
                        sizeof(qmi_wdsi_curr_data_bearer_tech_type),
                       (void *) &(wds_sp->curr_data_bearer_cache),
                       sizeof(qmi_wdsi_curr_data_bearer_tech_type));
              }
              else
              {
                LOG_MSG_INFO1_1("Ignoring null or unknown bearer (%d)",
                                legacy_data_bearer_tech);
              }
              
              qmi_wdsi_generate_curr_data_bearer_tech_ind(wds_sp, &data_bearer_tech);
#endif /* FEATURE_DATA_WLAN_MAPCON */
            }

            new_phys_link_ptr = PS_IFACE_GET_PHYS_LINK(wds_sp->um_iface_ptr);
            if( QMI_WDS_CONN_CONNECTED == wds_sp->pkt_svc_state &&
                NULL != wds_sp->um_iface_phys_link_ptr &&
                NULL != new_phys_link_ptr &&
                new_phys_link_ptr != wds_sp->um_iface_phys_link_ptr)
            {
              LOG_MSG_INFO2_2("Changing physlink! old physlink (0x%x), new physlink (0x%x)",
                              wds_sp->um_iface_phys_link_ptr,
                              new_phys_link_ptr);
              wdsi_dereg_um_phys_link_ev(wds_sp);
              wds_sp->um_iface_phys_link_ptr = new_phys_link_ptr;
              wdsi_reg_um_phys_link_ev(wds_sp);
            }
            /* Generate channel rate ind also since data bearer has changed
             (as CM serving system change doesn't come in some cases). if both
              happen to come, only one channel rate ind will be sent since we
              comapre last reported values */
            qmi_wds_generate_channel_rate_ind(QMI_IF_CH_RATE_TRIGGER_DATA_BEARER_CHANGE,
                                              QMI_AF_INET == wds_sp->cur_ip_call_type,
                                              wds_sp->binding.subscription_id);
          } /* endif call up */
        } /* for loop (inst) */
      } /* for loop (state) */
      return;
    }


    case IFACE_EXTENDED_IP_CONFIG_EX_EV:
    {
      LOG_MSG_INFO1_1("qmi_wdsi_process_um_iface_event(): "
                      "IFACE_EXTENDED_IP_CONFIG_EX_EV, change mask 0x%x",
                      event_info.extended_ip_config_change_mask );
      qmi_wdsi_generate_internal_iface_ev_ind( wds_sp,
                                               WDSI_INT_IF_EV_EXT_IPCONFIG,
                                               event_info );
      qmi_wdsi_generate_extended_ip_config_ev_ind
        ( wds_sp, event_info.extended_ip_config_change_mask );
      return;
    }
    case IFACE_ENABLE_HDR_REV0_RATE_INERTIA_SUCCESS_EV:
    {
      qmi_wdsi_generate_internal_iface_ev_ind( wds_sp,
                                               WDSI_INT_IF_EV_HDR_RATE_INERTIA_SUCCESS,
                                               event_info );
     //break;
      return;
    }
    case IFACE_ENABLE_HDR_REV0_RATE_INERTIA_FAILURE_EV:
    {
      qmi_wdsi_generate_internal_iface_ev_ind( wds_sp,
                                               WDSI_INT_IF_EV_HDR_RATE_INERTIA_FAILURE,
                                               event_info );
     //break;
      return;
    }

    case IFACE_ENABLE_HDR_SET_EIDLE_SLOTTED_MODE_SUCCESS_EV:
    {

      if ( TRUE == wds_sp->internal_iface_ev_reg )
      {
        qmi_wdsi_generate_internal_iface_ev_ind( wds_sp,
                                                 WDSI_INT_IF_EV_HDR_SM_SUCCESS,
                                                 event_info );
      }

     //break;
      return;
    }
    case IFACE_ENABLE_HDR_SET_EIDLE_SLOTTED_MODE_FAILURE_EV:
    {
      if ( TRUE == wds_sp->internal_iface_ev_reg )
      {
        qmi_wdsi_generate_internal_iface_ev_ind( wds_sp,
                                                 WDSI_INT_IF_EV_HDR_SM_FAILURE,
                                                 event_info );
      }

      //break;
      return;
    }
    case IFACE_ENABLE_HDR_SET_EIDLE_SLOTTED_MODE_SESSION_CHANGED_EV:
    {
      qmi_wdsi_generate_internal_iface_ev_ind( wds_sp,
                                               WDSI_INT_IF_EV_HDR_SM_SESS_CHANGE,
                                               event_info );
     //break;
      return;
    }
    case IFACE_RF_CONDITIONS_CHANGED_EV:
    {
      qmi_wdsi_generate_internal_iface_ev_ind( wds_sp,
                                               WDSI_INT_IF_EV_RF_CONDITIONS,
                                               event_info );
     //break;
      return;
    }

    case IFACE_MT_REQUEST_EV:
    {
      for (i=0; i<WDSI_MAX_MT_CBS; i++)
      {
        if (wds_mt_handle_list[i].handle == event_info.mt_handle)
        {
          break;
        }
      }

      if (i == WDSI_MAX_MT_CBS)
      {
        LOG_MSG_INFO2_0("Recvd MT request iface event for non-QMI WDS client,ignore");
        return;
      }

      qmi_wdsi_mt_request_ind( wds_sp, i );
      //break;
      return;
    }

    case IFACE_FAST_DORMANCY_STATUS_EV:
    {
      if( event_info.fast_dorm_status.dorm_status == PS_FAST_DORMANCY_STATUS_SUCCESS ||
          event_info.fast_dorm_status.dorm_status == PS_FAST_DORMANCY_STATUS_FAILURE )
      {
        delay_dormancy_result.status = (uint8)event_info.fast_dorm_status.dorm_status;
        delay_dormancy_result.dormancy_failure_reason = 
            (wds_dormancy_failure_reason_type_enum_v01)event_info.fast_dorm_status.failure_reason;
      }
      else
      {
        LOG_MSG_ERROR_1("Received invalid IFACE_FAST_DORMANCY_STATUS_EV status:%d.Ignore",
                      event_info.fast_dorm_status.dorm_status);
        return;
      }
      /*Send the delay dormancy status indication*/
      qmi_wdsi_generate_delay_dormancy_status_ind(wds_sp, &delay_dormancy_result);
      //break;
      return;
    }
    default:
      LOG_MSG_ERROR_0("Received unregistered UM iface event!!");
      break;
  }

#ifdef FEATURE_DATA_QMI_MCAST
  mcast_handle = wds_mcast_info[i].handle;
  cl_sp = wds_mcast_info[i].cl_sp;

  switch(event)
  {
    case IFACE_MCAST_REGISTER_SUCCESS_EV:
      mcast_status = WDSI_MCAST_REG_SUCCESS;
      cmd = WDSI_CMD_VAL_GET_MCAST_STATUS;
      break;

    case IFACE_MCAST_REGISTER_FAILURE_EV:
      mcast_status = WDSI_MCAST_REG_FAILURE;
      wds_sp->num_mcast_reqs--;
      memset(&wds_mcast_info[i], 0, sizeof(wds_mcast_info[i]));
      cmd = WDSI_CMD_VAL_GET_MCAST_STATUS;
      break;

    case IFACE_MCAST_DEREGISTERED_EV:
      mcast_status = WDSI_MCAST_DEREG;
      wds_sp->num_mcast_reqs--;
      memset(&wds_mcast_info[i], 0, sizeof(wds_mcast_info[i]));
      cmd = WDSI_CMD_VAL_GET_MCAST_STATUS;
      break;

    case IFACE_MBMS_CONTEXT_ACT_SUCCESS_EV:
      mcast_status = WDSI_MBMS_MCAST_CONT_ACT_SUCCESS;
      cmd = WDSI_CMD_VAL_GET_MBMS_MCAST_CONTEXT_STATUS;
      break;

    case IFACE_MBMS_CONTEXT_ACT_FAILURE_EV:
      mcast_status = WDSI_MBMS_MCAST_CONT_ACT_FAILURE;
      wds_sp->num_mcast_reqs--;
      memset(&wds_mcast_info[i], 0, sizeof(wds_mcast_info[i]));
      cmd = WDSI_CMD_VAL_GET_MBMS_MCAST_CONTEXT_STATUS;
      break;

    case IFACE_MBMS_CONTEXT_DEACT_SUCCESS_EV:
      mcast_status = WDSI_MBMS_MCAST_CONT_DEACT_SUCCESS;
      wds_sp->num_mcast_reqs--;
      memset(&wds_mcast_info[i], 0, sizeof(wds_mcast_info[i]));
      cmd = WDSI_CMD_VAL_GET_MBMS_MCAST_CONTEXT_STATUS;
      break;

    case IFACE_MBMS_CONTEXT_DEACT_FAILURE_EV:
      mcast_status = WDSI_MBMS_MCAST_CONT_DEACT_FAILURE;
      LOG_MSG_ERROR_0("mbms context deact failure!!");
      cmd = WDSI_CMD_VAL_GET_MBMS_MCAST_CONTEXT_STATUS;
      break;

    case IFACE_MCAST_STATUS_EV:
      mcast_status = WDSI_MCAST_STATUS_EX;
      cmd = WDSI_CMD_VAL_GET_MCAST_STATUS;
      break;

    default:
      LOG_MSG_ERROR_0("Received unregistered UM iface event!!");
      break;
  }

  qmi_wdsi_mcast_status_ind(wds_sp,
                            cl_sp,
                            cmd,
                            mcast_handle,
                            mcast_status,
                            event_info.mcast_info.info_code);
#endif /* FEATURE_DATA_QMI_MCAST */
} /* qmi_wdsi_process_um_iface_event() */

/*===========================================================================
  FUNCTION WDSI_REG_UM_PHYS_LINK_EV()

  DESCRIPTION
    Function to register phys link events on UM iface

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_reg_um_phys_link_ev
(
  qmi_wdsi_state_type      * wds_sp
)
{
  ps_iface_type        *iface_ptr = NULL;
  ps_iface_state_enum_type iface_state = IFACE_STATE_INVALID;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   /*---------------------------------------------------------------------
     Cache the um iface phys link
     - to be able to access phys link ptr even it is unbound from um iface
       when iface is torn down in the case of the phys link dynamic binding
   ----------------------------------------------------------------------*/
   wds_sp->um_iface_phys_link_ptr =
                                 PS_IFACE_GET_PHYS_LINK(wds_sp->um_iface_ptr);

   if (wds_sp->um_iface_phys_link_ptr == NULL)
   {
     /* Check for physical iface state because some cases logical /epc iface
        gets updated in DCC task and may not be up-to-date */
     iface_ptr = PS_IFACE_GET_BASE_IFACE(wds_sp->um_iface_ptr);
     if ( PS_IFACE_IS_VALID(iface_ptr) )
     {
        iface_state = ps_iface_state(iface_ptr);
        if ( iface_state != IFACE_DOWN )        
        {
          LOG_MSG_ERROR_1("Invalid physical iface state: %d", iface_state);
          return;
        }
        else
        {
          LOG_MSG_ERROR_3( "Don't register for physlink events if physical iface "
                           "((0x%x:%d)) is in %d state",
                           iface_ptr->name, iface_ptr->instance, iface_state );
        }
     }
     else
     {
       LOG_MSG_ERROR_1( "Invalid physical iface ptr(0x%x). Don't register for physlink events",
                        iface_ptr );
     }
     return;
   }

   if(ps_phys_link_event_cback_reg(
                                 wds_sp->um_iface_phys_link_ptr,
                                 PHYS_LINK_UP_EV,
                                 wds_sp->um_phys_link_up_buf_ptr
                                ) < 0 )
   {
      LOG_MSG_ERROR_0("PHYS LINK UP_EV reg failed" );
   }

   if(ps_phys_link_event_cback_reg(
                                 wds_sp->um_iface_phys_link_ptr,
                                 PHYS_LINK_DOWN_EV,
                                 wds_sp->um_phys_link_down_buf_ptr
                                ) < 0)
   {
      LOG_MSG_ERROR_0("PHYS LINK DOWN_EV reg failed" );
   }

   if(ps_phys_link_event_cback_reg(
                                 wds_sp->um_iface_phys_link_ptr,
                                 PHYS_LINK_707_DOS_ACK_EV,
                                 wds_sp->um_phys_link_dos_ack_buf_ptr
                                ) < 0 )
   {
      LOG_MSG_ERROR_0("PHYS LINK DOS_ACK_EV reg failed" );
   }
 } /* wdsi_reg_um_phys_link_ev() */

/*===========================================================================
  FUNCTION WDSI_DEREG_UM_PHYS_LINK_EV()

  DESCRIPTION
    Function to deregister phys link events on UM iface

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_dereg_um_phys_link_ev
(
  qmi_wdsi_state_type      * wds_sp
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (wds_sp);
  if ( wds_sp->um_iface_ptr != NULL )
  {
    /*---------------------------------------------------------------------
      Since de-reg is called after phys link is un-bound from the iface,
      access the un-bound phys link ptr through cache.
    ----------------------------------------------------------------------*/
    if (wds_sp->um_iface_phys_link_ptr == NULL)
    {
      LOG_MSG_ERROR_0( "Cached physlink ptr is NULL. Nothing to deregister" );
      return;
    }

    ps_phys_link_event_cback_dereg(
                                wds_sp->um_iface_phys_link_ptr,
                                PHYS_LINK_UP_EV,
                                wds_sp->um_phys_link_up_buf_ptr
                                );
    ps_phys_link_event_cback_dereg(
                                wds_sp->um_iface_phys_link_ptr,
                                PHYS_LINK_DOWN_EV,
                                wds_sp->um_phys_link_down_buf_ptr
                                );
    ps_phys_link_event_cback_dereg(
                                wds_sp->um_iface_phys_link_ptr,
                                PHYS_LINK_707_DOS_ACK_EV,
                                wds_sp->um_phys_link_dos_ack_buf_ptr
                                );
    wds_sp->um_iface_phys_link_ptr = NULL;
  }
  else
  {
     LOG_MSG_ERROR_0 ("UmIface ptr NULL before dereg'ing from physlink ev!");
     return;
  }
 }  /* wdsi_dereg_um_phys_link_ev() */

/*===========================================================================
  FUNCTION WDSI_REG_DUN_UM_PHYS_LINK_EV()

  DESCRIPTION
    Function to register phys link events on UM iface

  PARAMETERS
    um_iface_ptr - UM iface ptr to register

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_reg_dun_um_phys_link_ev
(
  ps_iface_type            * um_iface_ptr
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  LOG_MSG_INFO2_1("Reg DUN phys_link events (um_iface_ptr=0x%x)",
                  um_iface_ptr);
 /*---------------------------------------------------------------------
   Cache the um iface phys link
   - to be able to access phys link ptr even it is unbound from um iface
     when iface is torn down in the case of the phys link dynamic binding
 ----------------------------------------------------------------------*/
 qmi_wdsi_global.dun_um_iface_phys_link_ptr =
                                         PS_IFACE_GET_PHYS_LINK(um_iface_ptr);

 if (NULL == qmi_wdsi_global.dun_um_iface_phys_link_ptr)
 {
   LOG_MSG_ERROR_0("Phys link ptr NULL, returning" );
   return;
 }

 if(ps_phys_link_event_cback_reg(
                               qmi_wdsi_global.dun_um_iface_phys_link_ptr,
                               PHYS_LINK_UP_EV,
                               qmi_wdsi_global.dun_um_phys_link_up_buf_ptr
                              ) < 0 )
 {
    LOG_MSG_ERROR_0("PHYS LINK UP_EV reg failed" );
 }

 if(ps_phys_link_event_cback_reg(
                               qmi_wdsi_global.dun_um_iface_phys_link_ptr,
                               PHYS_LINK_DOWN_EV,
                               qmi_wdsi_global.dun_um_phys_link_down_buf_ptr
                              ) < 0)
 {
    LOG_MSG_ERROR_0("PHYS LINK DOWN_EV reg failed" );
 }

 } /* wdsi_reg_dun_um_phys_link_ev() */

/*===========================================================================
  FUNCTION WDSI_DEREG_DUN_UM_PHYS_LINK_EV()

  DESCRIPTION
    Function to deregister phys link events on UM iface

  PARAMETERS
    um_iface_ptr - UM iface ptr to deregister

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_dereg_dun_um_phys_link_ev
(
  ps_iface_type            * um_iface_ptr
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  LOG_MSG_INFO2_1("De-Reg DUN phys_link events (um_iface_ptr=0x%x)",
                  um_iface_ptr);
  if ( um_iface_ptr != NULL )
  {
    /*---------------------------------------------------------------------
      Since de-reg is called after phys link is un-bound from the iface,
      access the un-bound phys link ptr through cache.
    ----------------------------------------------------------------------*/
    if (qmi_wdsi_global.dun_um_iface_phys_link_ptr == NULL)
    {
      LOG_MSG_ERROR_0( "Cached physlink ptr is NULL. Nothing to deregister" );
      return;
    }

    ps_phys_link_event_cback_dereg(
                                qmi_wdsi_global.dun_um_iface_phys_link_ptr,
                                PHYS_LINK_UP_EV,
                                qmi_wdsi_global.dun_um_phys_link_up_buf_ptr
                                );
    ps_phys_link_event_cback_dereg(
                                qmi_wdsi_global.dun_um_iface_phys_link_ptr,
                                PHYS_LINK_DOWN_EV,
                                qmi_wdsi_global.dun_um_phys_link_down_buf_ptr
                                );
    qmi_wdsi_global.dun_um_iface_phys_link_ptr = NULL;
  }
  else
  {
     LOG_MSG_ERROR_0 ("UmIface ptr NULL before dereg'ing from physlink ev!");
     return;
  }
 }  /* wdsi_dereg_dun_um_phys_link_ev() */

/*===========================================================================
FUNCTION   WDSI_UM_PHYS_LINK_EV_HDLR_CB()

DESCRIPTION
  This callback function is called when one of the registered ps_phys_link
  events occur on Um interface. Various Um phys_link events are registered,
  each of which is used to send appropriate wds indications. A QMI command
  is posted to DCC task for processing the events.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
STATIC void wdsi_um_phys_link_ev_hdlr_cb
(
  ps_phys_link_type             *this_phys_link_ptr,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  void                          *user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (user_data_ptr);
  LOG_MSG_INFO2_1( "Recvd phys_link ev %d", event );

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_PHYS_LINK_EVT);
  if( cmd_ptr == NULL)
  {
    return;
  }

  cmd_ptr->cmd_id = QMI_CMD_PROCESS_PHYS_LINK_EVT;
  cmd_ptr->data.phys_link_status.phys_link_ptr = this_phys_link_ptr;
  cmd_ptr->data.phys_link_status.event = event;
  cmd_ptr->data.phys_link_status.event_info = event_info;
  cmd_ptr->data.phys_link_status.user_data_ptr = user_data_ptr;

  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
} /* wdsi_um_phys_link_ev_hdlr_cb() */

/*===========================================================================
FUNCTION   WDSI_DUN_UM_PHYS_LINK_EV_HDLR_CB()

DESCRIPTION
  This callback function is called when one of the registered ps_phys_link
  events occur on Um interface. Various Um phys_link events are registered,
  each of which is used to send appropriate wds indications. A QMI command
  is posted to DCC task for processing the events.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
STATIC void wdsi_dun_um_phys_link_ev_hdlr_cb
(
  ps_phys_link_type             *this_phys_link_ptr,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  void                          *user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (user_data_ptr);
  LOG_MSG_INFO2_1( "Recvd phys_link ev %d", event );

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_DUN_PHYS_LINK_EVT);
  if( cmd_ptr == NULL)
  {
    return;
  }

  cmd_ptr->cmd_id = QMI_CMD_PROCESS_DUN_PHYS_LINK_EVT;
  cmd_ptr->data.phys_link_status.phys_link_ptr = this_phys_link_ptr;
  cmd_ptr->data.phys_link_status.event = event;
  cmd_ptr->data.phys_link_status.event_info = event_info;
  cmd_ptr->data.phys_link_status.user_data_ptr = user_data_ptr;

  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
} /* wdsi_dun_um_phys_link_ev_hdlr_cb() */

#ifdef FEATURE_WINMOB_SIM

/*===========================================================================
  FUNCTION WDSI_HAS_ACTIVE_CLIENT

  DESCRIPTION
    Check if any active WDS clients on this WDS instance

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    TRUE  - control points in use
    FALSE - no control points in use

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean wdsi_has_active_client
(
  qmi_wdsi_state_type *  wds_sp
)
{
  qmi_wdsi_client_state_type *  cl_sp;   /* allocated WDS client   */
  int                           client_ix;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT (wds_sp);

  /* check if any client IDs are in use */
  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
    if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp) )
    {
      return TRUE;
    }
    cl_sp = cl_sp->next;
  }
  return FALSE;
} /* wdsi_has_active_client() */
#endif /* FEATURE_WINMOB_SIM */



/*===========================================================================
  FUNCTION WDSI_MEDIA_CONNECTED()

  DESCRIPTION
    Indicate that the RMNET interface media (data link/cable) is established.

    This function will generate the appropriate indications and send
    them over QMI control stream to give the host driver the 411.

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_media_connected
(
  qmi_wdsi_state_type *  wds_sp,
  boolean                reconfig_reqd
)
{
  ASSERT (wds_sp);

  /*-------------------------------------------------------------------------
    If there are any active client(s), send broadcast pkt_srvc_ind to all
    letting them know that packet data session is active on air interface
  -------------------------------------------------------------------------*/
  LOG_MSG_INFO1_1( "Media Connected (%08x)", wds_sp );

#ifdef FEATURE_WINMOB_SIM
  // need to featurize for WM builds as well
  if( !wdsi_has_active_client( wds_sp ) )
  {
    LOG_MSG_INFO2_0("No WDS clients active, ignore");
    return;
  }
#endif /* FEATURE_WINMOB_SIM */

  qmi_wds_pkt_srvc_status_ind( wds_sp,
                               NULL,  // broadcast
                               QMI_WDS_CONN_CONNECTED,
                               reconfig_reqd );

 } /* wdsi_media_connected() */



/*===========================================================================
  FUNCTION WDSI_MEDIA_DISCONNECTED()

  DESCRIPTION
    Indicate that the RMNET interface media (data link/cable) is
    disconnected.

    This function will generate the appropriate indications and send
    them over QMI control stream to give the host driver the 411.

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_media_disconnected
(
  qmi_wdsi_state_type *  wds_sp
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT (wds_sp);

  LOG_MSG_INFO1_1 ("Media Disconnected (%08x)", wds_sp);

  /*-------------------------------------------------------------------------
    send pkt_srvc_ind to all clients for media connected
  -------------------------------------------------------------------------*/
  qmi_wds_pkt_srvc_status_ind( wds_sp,
                               NULL,  // broadcast
                               QMI_WDS_CONN_DISCONNECTED,
                               FALSE );

} /* wdsi_media_disconnected() */

/*===========================================================================
  FUNCTION WDSI_GET_INSTANCE_FROM_WDS_SP()

  DESCRIPTION
    To obtain QMI WDS instance from wds_sp

  PARAMETERS
    wds_sp : service state ptr

  RETURN VALUE
    WDS instance if wds_sp is valid
    WDS_INSTANCE_MAX if wds_sp is invalid

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint8 wdsi_get_instance_from_wds_sp
(
  void *  sp
)
{
  qmi_wdsi_state_type  * wds_sp = (qmi_wdsi_state_type *)sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( (wds_sp == NULL) ||
       (wds_sp->constants.wds_inst >= WDS_INSTANCE_MAX) )
  {
    LOG_MSG_ERROR_1 ("Invalid wds_sp! (0x%x)", wds_sp);
    return WDS_INSTANCE_MAX;
  }

  return wds_sp->constants.wds_inst;

} /* wdsi_get_instance_from_wds_sp() */

/*===========================================================================
  FUNCTION WDSI_GET_INST_FROM_EP_AND_MUX_ID()

  DESCRIPTION
    To obtain QMI WDS instance from ep_id and mux_id

  PARAMETERS

  RETURN VALUE
    WDS instance if wds_sp is valid
    WDS_INSTANCE_MAX if wds_sp is invalid

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint8 wdsi_get_inst_from_ep_and_mux_id
(
  uint32    ep_id,
  uint8     mux_id
)
{
  qmi_wdsi_state_type  * wds_sp_v4;
  int                    i;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (ep_id == 0)
  {
    return WDS_INSTANCE_MAX;
  }

  for (i = 0; i < WDS_INSTANCE_MAX; i++)
  {
    wds_sp_v4 = qmi_wds_state[WDSI_IPV4_STATE][i];
    if ( wds_sp_v4 != NULL &&
         wds_sp_v4->binding.ep_id == ep_id &&
         wds_sp_v4->binding.mux_id == mux_id )
    {
      return i;
    }
  }

  return WDS_INSTANCE_MAX;

} /* wdsi_get_inst_from_ep_and_mux_id() */

/*===========================================================================
  FUNCTION WDSI_GET_UNBOUND_INST()

  DESCRIPTION
    To obtain a free (unbound) WDS instance from ep_id and mux_id

  PARAMETERS

  RETURN VALUE
    WDS instance if found
    WDS_INSTANCE_MAX if not found

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint8 wdsi_get_unbound_inst
(
  uint32     ep_id,
  uint8      mux_id,
  boolean    is_reversed
)
{
  uint8  inst = QMI_INSTANCE_MAX;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  // If mux_id is 0 and is not reversed, check if we need to use the
  // the instance in the legacy non-mux section
  if (mux_id == 0 && !is_reversed)
  {
    inst = qmux_get_inst_from_ep_id(ep_id);
  }

  // Find a free wds state in the mux section
  if (inst >= QMI_INSTANCE_MAX)
  {
    for (inst = QMI_INSTANCE_MAX; inst < WDS_INSTANCE_MAX; inst++)
    {
      if (qmi_wds_state[WDSI_IPV4_STATE][inst] == NULL ||
          qmi_wds_state[WDSI_IPV4_STATE][inst]->binding.ep_id == 0)
      {
        break;
      }
    }
  }

  return inst;

} /* wdsi_get_unbound_inst() */

/*===========================================================================
  FUNCTION QMI_WDSI_MAP_WDS_CALL_END_REASON()

  DESCRIPTION
    To obtain wds call end reason from iface call end reason

  PARAMETERS
    iface_call_end_reason

  RETURN VALUE
    wds_call_end_reason

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_wds_call_end_reason_e_type  qmi_wdsi_map_wds_call_end_reason
(
  ps_iface_net_down_reason_type iface_call_end_reason
)
{
  qmi_if_info_type  *qmi_if_info_ptr;
  qmi_if_asubs_id_type asub_id;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch ( iface_call_end_reason )
  {
    case PS_NET_DOWN_REASON_CLIENT_END:
      return QMI_WDS_CALL_END_REASON_CLIENT_END;

    case PS_NET_DOWN_REASON_NO_SRV:
      return QMI_WDS_CALL_END_REASON_NO_SRV;

    case PS_NET_DOWN_REASON_FADE:
      return QMI_WDS_CALL_END_REASON_FADE;

    case PS_NET_DOWN_REASON_REL_NORMAL:
      return QMI_WDS_CALL_END_REASON_REL_NORMAL;

    case PS_NET_DOWN_REASON_ACC_IN_PROG:
      return QMI_WDS_CALL_END_REASON_ACC_IN_PROG;

    case PS_NET_DOWN_REASON_ACC_FAIL:
      return QMI_WDS_CALL_END_REASON_ACC_FAIL;

    case PS_NET_DOWN_REASON_REDIR_OR_HANDOFF:
      return QMI_WDS_CALL_END_REASON_REDIR_OR_HANDOFF;

    case PS_NET_DOWN_REASON_CLOSE_IN_PROGRESS:
      return QMI_WDS_CALL_END_REASON_CLOSE_IN_PROGRESS;

    case PS_NET_DOWN_REASON_AUTH_FAILED:
      return QMI_WDS_CALL_END_REASON_AUTH_FAILED;

    case PS_NET_DOWN_REASON_INTERNAL_CALL_ENDED:
      return QMI_WDS_CALL_END_REASON_INTERNAL_CALL_END;

    case PS_NET_DOWN_REASON_INTERNAL_ERROR:
      return QMI_WDS_CALL_END_REASON_INTERNAL_ERROR;

    case PS_NET_DOWN_REASON_INTERNAL_UNKNOWN_CAUSE_CODE:
      return QMI_WDS_CALL_END_REASON_INTERNAL_UNKNOWN_CAUSE_CODE;

    case PS_NET_DOWN_REASON_CDMA_LOCK:
      return QMI_WDS_CALL_END_REASON_CDMA_LOCK;

    case PS_NET_DOWN_REASON_INTERCEPT:
      return QMI_WDS_CALL_END_REASON_INTERCEPT;

    case PS_NET_DOWN_REASON_REORDER:
      return QMI_WDS_CALL_END_REASON_REORDER;

    case PS_NET_DOWN_REASON_REL_SO_REJ:
      return QMI_WDS_CALL_END_REASON_REL_SO_REJ;

    case PS_NET_DOWN_REASON_INCOM_CALL:
      return QMI_WDS_CALL_END_REASON_INCOM_CALL;

    case PS_NET_DOWN_REASON_ALERT_STOP:
      return QMI_WDS_CALL_END_REASON_ALERT_STOP;

    case PS_NET_DOWN_REASON_ACTIVATION:
      return QMI_WDS_CALL_END_REASON_ACTIVATION;

    case PS_NET_DOWN_REASON_MAX_ACCESS_PROBE:
      return QMI_WDS_CALL_END_REASON_MAX_ACCESS_PROBE;

    case PS_NET_DOWN_REASON_CCS_NOT_SUPPORTED_BY_BS:
      return QMI_WDS_CALL_END_REASON_CCS_NOT_SUPPORTED_BY_BS;

    case PS_NET_DOWN_REASON_NO_RESPONSE_FROM_BS:
      return QMI_WDS_CALL_END_REASON_NO_RESPONSE_FROM_BS;

    case PS_NET_DOWN_REASON_REJECTED_BY_BS:
      return QMI_WDS_CALL_END_REASON_REJECTED_BY_BS;

    case PS_NET_DOWN_REASON_INCOMPATIBLE:
      return QMI_WDS_CALL_END_REASON_INCOMPATIBLE;

    case PS_NET_DOWN_REASON_ALREADY_IN_TC:
      return QMI_WDS_CALL_END_REASON_ALREADY_IN_TC;

    case PS_NET_DOWN_REASON_USER_CALL_ORIG_DURING_GPS:
      return QMI_WDS_CALL_END_REASON_USER_CALL_ORIG_DURING_GPS;

    case PS_NET_DOWN_REASON_USER_CALL_ORIG_DURING_SMS:
      return QMI_WDS_CALL_END_REASON_USER_CALL_ORIG_DURING_SMS;

    case PS_NET_DOWN_REASON_NO_CDMA_SRV:
      return QMI_WDS_CALL_END_REASON_NO_CDMA_SRV;

    case PS_NET_DOWN_REASON_CONF_FAILED:
      return QMI_WDS_CALL_END_REASON_CONF_FAILED;

    case PS_NET_DOWN_REASON_INCOM_REJ:
      return QMI_WDS_CALL_END_REASON_INCOM_REJ;

    case PS_NET_DOWN_REASON_NW_INITIATED_TERMINATION:
      return QMI_WDS_CALL_END_REASON_NETWORK_END;

    case PS_NET_DOWN_REASON_NO_GW_SRV:
      return QMI_WDS_CALL_END_REASON_NO_GW_SRV;

    case PS_NET_DOWN_REASON_LLC_SNDCP_FAILURE:
      return QMI_WDS_CALL_END_REASON_LLC_SNDCP_FAILURE;

    case PS_NET_DOWN_REASON_INSUFFICIENT_RESOURCES:
      return QMI_WDS_CALL_END_REASON_INSUFFICIENT_RESOURCES;

    case PS_NET_DOWN_REASON_OPTION_TEMP_OOO:
      return QMI_WDS_CALL_END_REASON_OPTION_TEMP_OOO;

    case PS_NET_DOWN_REASON_NSAPI_ALREADY_USED:
      return QMI_WDS_CALL_END_REASON_NSAPI_ALREADY_USED;

    case PS_NET_DOWN_REASON_REGULAR_DEACTIVATION:
      return QMI_WDS_CALL_END_REASON_REGULAR_DEACTIVATION;

    case PS_NET_DOWN_REASON_NETWORK_FAILURE:
      return QMI_WDS_CALL_END_REASON_NETWORK_FAILURE;

    case PS_NET_DOWN_REASON_UMTS_REATTACH_REQ:
      return QMI_WDS_CALL_END_REASON_UMTS_REATTACH_REQ;

    case PS_NET_DOWN_REASON_PROTOCOL_ERROR:
      return QMI_WDS_CALL_END_REASON_PROTOCOL_ERROR;

    case PS_NET_DOWN_REASON_OPERATOR_DETERMINED_BARRING:
      return QMI_WDS_CALL_END_REASON_OPERATOR_DETERMINED_BARRING;

    case PS_NET_DOWN_REASON_UNKNOWN_APN:
      return QMI_WDS_CALL_END_REASON_UNKNOWN_APN;

    case PS_NET_DOWN_REASON_UNKNOWN_PDP:
      return QMI_WDS_CALL_END_REASON_UNKNOWN_PDP;

    case PS_NET_DOWN_REASON_GGSN_REJECT:
      return QMI_WDS_CALL_END_REASON_GGSN_REJECT;

    case PS_NET_DOWN_REASON_ACTIVATION_REJECT:
      return QMI_WDS_CALL_END_REASON_ACTIVATION_REJECT;

    case PS_NET_DOWN_REASON_OPTION_NOT_SUPPORTED:
      return QMI_WDS_CALL_END_REASON_OPTION_NOT_SUPPORTED;

    case PS_NET_DOWN_REASON_OPTION_UNSUBSCRIBED:
      return QMI_WDS_CALL_END_REASON_OPTION_UNSUBSCRIBED;

    case PS_NET_DOWN_REASON_QOS_NOT_ACCEPTED:
      return QMI_WDS_CALL_END_REASON_QOS_NOT_ACCEPTED;

    case PS_NET_DOWN_REASON_TFT_SEMANTIC_ERROR:
      return QMI_WDS_CALL_END_REASON_TFT_SEMANTIC_ERROR;

    case PS_NET_DOWN_REASON_TFT_SYNTAX_ERROR:
      return QMI_WDS_CALL_END_REASON_TFT_SYNTAX_ERROR;

    case PS_NET_DOWN_REASON_UNKNOWN_PDP_CONTEXT:
      return QMI_WDS_CALL_END_REASON_UNKNOWN_PDP_CONTEXT;

    case PS_NET_DOWN_REASON_FILTER_SEMANTIC_ERROR:
      return QMI_WDS_CALL_END_REASON_FILTER_SEMANTIC_ERROR;

    case PS_NET_DOWN_REASON_FILTER_SYNTAX_ERROR:
      return QMI_WDS_CALL_END_REASON_FILTER_SYNTAX_ERROR;

    case PS_NET_DOWN_REASON_PDP_WITHOUT_ACTIVE_TFT:
      return QMI_WDS_CALL_END_REASON_PDP_WITHOUT_ACTIVE_TFT;

    case PS_NET_DOWN_REASON_INVALID_TRANSACTION_ID:
      return QMI_WDS_CALL_END_REASON_INVALID_TRANSACTION_ID;

    case PS_NET_DOWN_REASON_MESSAGE_INCORRECT_SEMANTIC:
      return QMI_WDS_CALL_END_REASON_MESSAGE_INCORRECT_SEMANTIC;

    case PS_NET_DOWN_REASON_INVALID_MANDATORY_INFO:
      return QMI_WDS_CALL_END_REASON_INVALID_MANDATORY_INFO;

    case PS_NET_DOWN_REASON_MESSAGE_TYPE_UNSUPPORTED:
      return QMI_WDS_CALL_END_REASON_MESSAGE_TYPE_UNSUPPORTED;

    case PS_NET_DOWN_REASON_MSG_TYPE_NONCOMPATIBLE_STATE:
      return QMI_WDS_CALL_END_REASON_MSG_TYPE_NONCOMPATIBLE_STATE;

    case PS_NET_DOWN_REASON_UNKNOWN_INFO_ELEMENT:
      return QMI_WDS_CALL_END_REASON_UNKNOWN_INFO_ELEMENT;

    case PS_NET_DOWN_REASON_CONDITIONAL_IE_ERROR:
      return QMI_WDS_CALL_END_REASON_CONDITIONAL_IE_ERROR;

    case PS_NET_DOWN_REASON_MSG_AND_PROTOCOL_STATE_UNCOMPATIBLE:
      return QMI_WDS_CALL_END_REASON_MSG_AND_PROTOCOL_STATE_UNCOMPATIBLE;

    case PS_NET_DOWN_REASON_APN_TYPE_CONFLICT:
      return QMI_WDS_CALL_END_REASON_APN_TYPE_CONFLICT;

    case PS_NET_DOWN_REASON_NO_GPRS_CONTEXT:
      return QMI_WDS_CALL_END_REASON_NO_GPRS_CONTEXT;

    case PS_NET_DOWN_REASON_FEATURE_NOT_SUPPORTED:
      return QMI_WDS_CALL_END_REASON_FEATURE_NOT_SUPPORTED;

    case PS_NET_DOWN_REASON_ILLEGAL_MS:
      return QMI_WDS_CALL_END_REASON_ILLEGAL_MS;

    case PS_NET_DOWN_REASON_ILLEGAL_ME:
      return QMI_WDS_CALL_END_REASON_ILLEGAL_ME;

    case PS_NET_DOWN_REASON_GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED:
      return QMI_WDS_CALL_END_REASON_GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED;

    case PS_NET_DOWN_REASON_GPRS_SERVICES_NOT_ALLOWED:
      return QMI_WDS_CALL_END_REASON_GPRS_SERVICES_NOT_ALLOWED;

    case PS_NET_DOWN_REASON_MS_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK:
      return QMI_WDS_CALL_END_REASON_MS_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK;

    case PS_NET_DOWN_REASON_IMPLICITLY_DETACHED:
      return QMI_WDS_CALL_END_REASON_IMPLICITLY_DETACHED;

    case PS_NET_DOWN_REASON_PLMN_NOT_ALLOWED:
      return QMI_WDS_CALL_END_REASON_PLMN_NOT_ALLOWED;

    case PS_NET_DOWN_REASON_LA_NOT_ALLOWED:
      return QMI_WDS_CALL_END_REASON_LA_NOT_ALLOWED;

    case PS_NET_DOWN_REASON_GPRS_SERVICES_NOT_ALLOWED_IN_THIS_PLMN:
      return QMI_WDS_CALL_END_REASON_GPRS_SERVICES_NOT_ALLOWED_IN_THIS_PLMN;

    case PS_NET_DOWN_REASON_PDP_DUPLICATE:
      return QMI_WDS_CALL_END_REASON_PDP_DUPLICATE;

    case PS_NET_DOWN_REASON_UE_RAT_CHANGE:
      return QMI_WDS_CALL_END_REASON_UE_RAT_CHANGE;

    case PS_NET_DOWN_REASON_APP_PREEMPTED:
      return QMI_WDS_CALL_END_REASON_APP_PREEMPTED;

    case PS_NET_DOWN_REASON_CONGESTION:
      return QMI_WDS_CALL_END_REASON_CONGESTION;

    case PS_NET_DOWN_REASON_NO_PDP_CONTEXT_ACTIVATED:
      return QMI_WDS_CALL_END_REASON_NO_PDP_CONTEXT_ACTIVATED;

    case PS_NET_DOWN_REASON_ACCESS_CLASS_DSAC_REJECTION:
      return QMI_WDS_CALL_END_REASON_ACCESS_CLASS_DSAC_REJECTION;

    case PS_NET_DOWN_REASON_CD_GEN_OR_BUSY:
      return QMI_WDS_CALL_END_REASON_CD_GEN_OR_BUSY;

    case PS_NET_DOWN_REASON_CD_BILL_OR_AUTH:
      return QMI_WDS_CALL_END_REASON_CD_BILL_OR_AUTH;

    case PS_NET_DOWN_REASON_CHG_HDR:
      return QMI_WDS_CALL_END_REASON_CHG_HDR;

    case PS_NET_DOWN_REASON_EXIT_HDR:
      return QMI_WDS_CALL_END_REASON_EXIT_HDR;

    case PS_NET_DOWN_REASON_HDR_NO_SESSION:
      return QMI_WDS_CALL_END_REASON_HDR_NO_SESSION;

    case PS_NET_DOWN_REASON_HDR_ORIG_DURING_GPS_FIX:
      return QMI_WDS_CALL_END_REASON_HDR_ORIG_DURING_GPS_FIX;

    case PS_NET_DOWN_REASON_HDR_CS_TIMEOUT:
      return QMI_WDS_CALL_END_REASON_HDR_CS_TIMEOUT;

    case PS_NET_DOWN_REASON_HDR_RELEASED_BY_CM:
      return QMI_WDS_CALL_END_REASON_HDR_RELEASED_BY_CM;

    default:
      qmi_if_info_ptr = qmi_if_info_get_ptr();
      if( qmi_if_info_ptr->inited )
      {
        asub_id = qmi_if_get_default_sub_id();
        LOG_MSG_INFO2_2(" sys_mode: %d, srv_status = %d ,",
                         qmi_if_info_ptr->ss_info[asub_id].sys_mode,
                         qmi_if_info_ptr->ss_info[asub_id].srv_status);
        if( SYS_SRV_STATUS_SRV == qmi_if_info_ptr->ss_info[asub_id].srv_status  )
        {
          /* There is service */
        }
        else
        {
          return QMI_WDS_CALL_END_REASON_NO_SRV;
        }
      }

      return QMI_WDS_CALL_END_REASON_UNSPECIFIED;

  } /* switch ( iface_call_end_reason ) */

} /* qmi_wdsi_map_wds_call_end_reason() */

/*===========================================================================
  FUNCTION QMI_WDSI_MAP_MH_FAILURE_REASON()

  DESCRIPTION
    To obtain wds error code from mode handler returned PS error

  PARAMETERS
    ps_errno

  RETURN VALUE
    qmi error code

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_type_v01  qmi_wdsi_map_mh_failure_reason_debug
(
  int16 ps_errno,
  int line_no
)
{
    qmi_error_type_v01 errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  switch ( ps_errno )
  {
    case DS_ENOERR:
      errval = QMI_ERR_NONE_V01;
      break;

    case DS_EFAULT:
      errval = QMI_ERR_INVALID_ARG_V01;
      break;

    case DS_EOPNOTSUPP:
      errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
      break;

    case DS_ENETDOWN:
      errval = QMI_ERR_INFO_UNAVAILABLE_V01; //for NSAPI
      break;

    case DS_ENONET: //HDR system not available
      errval = QMI_ERR_OP_NETWORK_UNSUPPORTED_V01; //for Set EVDO page monitor period
      break;

    default:
      errval = QMI_ERR_INTERNAL_V01;
      break;

  } /* switch ( pserrno ) */

  LOG_MSG_ERROR_3("qmi_wdsi_map_mh_failure_reason: ps_errno:%d, qmi err:%d, line_no:%d",
                   ps_errno, errval,line_no);

  return errval;

} /* qmi_wdsi_map_mh_failure_reason() */

/*===========================================================================
  FUNCTION WDSI_ALLOC_EVENT_CBACK_BUF()

  DESCRIPTION
    Initialize the ps_iface/phys_link cback buf_ptrs for Um Iface, Net Iface
    and Physlink event handling.

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_alloc_event_cback_buf
(
  qmi_wdsi_state_type *  wds_sp
)
{
  boolean is_err = FALSE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT (wds_sp);

  /*-------------------------------------------------------------------------
    Initialize the ps_iface cback buf_ptrs for Net iface event handling
  -------------------------------------------------------------------------*/
  // MPDP - increase # of ps_iface_event_bufs (ps_mem bufs for this)
  ds_qmi_cflog_amss_call("ps_iface_alloc_event_cback_buf(20 times)");

  do
  {
    wds_sp->net_iface_configuring_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_net_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->net_iface_configuring_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->net_iface_down_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_net_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->net_iface_down_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->net_iface_authenticating_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_net_iface_ev_cb, (void *) wds_sp );
        if(wds_sp->net_iface_authenticating_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }

    /*-------------------------------------------------------------------------
      Initialize the ps_iface cback buf_ptrs for Um iface event handling
    -------------------------------------------------------------------------*/
  #ifdef FEATURE_DATA_QMI_MCAST
    wds_sp->um_iface_mcast_reg_success_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_mcast_reg_success_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }


    wds_sp->um_iface_mcast_reg_failure_buf_ptr =
        ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_mcast_reg_failure_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }


    wds_sp->um_iface_mcast_dereg_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_mcast_dereg_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->um_iface_mbms_cont_act_success_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_mbms_cont_act_success_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->um_iface_mbms_cont_act_failure_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_mbms_cont_act_failure_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  

    wds_sp->um_iface_mbms_cont_deact_success_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_mbms_cont_deact_success_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }


    wds_sp->um_iface_mbms_cont_deact_failure_buf_ptr =
        ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_mbms_cont_deact_failure_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }

    wds_sp->um_iface_mcast_status_ex_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_mcast_status_ex_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }

  #endif /* FEATURE_DATA_QMI_MCAST */
  
    wds_sp->um_iface_embms_tmgi_activated_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_embms_tmgi_activated_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
    wds_sp->um_iface_embms_tmgi_deactivated_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_embms_tmgi_deactivated_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }

    wds_sp->um_iface_embms_tmgi_act_deact_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_embms_tmgi_act_deact_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->um_iface_embms_active_tmgi_list_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_embms_active_tmgi_list_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->um_iface_embms_available_tmgi_list_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_embms_available_tmgi_list_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->um_iface_embms_warning_tmgi_list_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_embms_warning_tmgi_list_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
  #ifdef FEATURE_DATA_EMBMS
    wds_sp->um_iface_embms_sai_list_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_embms_sai_list_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
  #endif /* FEATURE_DATA_EMBMS */
  
    wds_sp->um_iface_embms_content_desc_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_embms_content_desc_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }

    wds_sp->um_iface_outage_notification_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_outage_notification_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->um_iface_ext_ipconfig_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_ext_ipconfig_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->um_iface_ext_ipconfig_ex_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_ext_ipconfig_ex_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->um_iface_hdr_rate_inertia_succ_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_hdr_rate_inertia_succ_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->um_iface_hdr_rate_inertia_fail_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_hdr_rate_inertia_fail_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }

  #ifdef FEATURE_EIDLE_SCI
    wds_sp->um_iface_hdr_sm_succ_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_hdr_sm_succ_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->um_iface_hdr_sm_fail_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_hdr_sm_fail_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }

    wds_sp->um_iface_hdr_sm_sess_change_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_hdr_sm_sess_change_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
  #endif /* FEATURE_EIDLE_SCI */
  
    wds_sp->um_iface_rf_conditions_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_rf_conditions_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->um_iface_mt_request_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_mt_request_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }

    wds_sp->um_iface_fast_dormancy_status_buf_ptr =
    ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_fast_dormancy_status_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }

     wds_sp->um_iface_apn_param_changed_buf_ptr =
     ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
     if(wds_sp->um_iface_apn_param_changed_buf_ptr == NULL)
     {
       is_err = TRUE;
       break;
     }

    /*---------------------------------------------------------------------
      Initialize the phys_link cback buf_ptrs for Um phys_link event
      handling. Events are registered later when the call comes up.
     ---------------------------------------------------------------------*/
    ds_qmi_cflog_amss_call("ps_phys_link_alloc_event_cback_buf(3 times)");
    wds_sp->um_phys_link_up_buf_ptr =
    ps_phys_link_alloc_event_cback_buf( wdsi_um_phys_link_ev_hdlr_cb,
                                        (void *) wds_sp );
      if(wds_sp->um_phys_link_up_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }

    wds_sp->um_phys_link_down_buf_ptr =
    ps_phys_link_alloc_event_cback_buf( wdsi_um_phys_link_ev_hdlr_cb,
                                        (void *)wds_sp );
      if(wds_sp->um_phys_link_down_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }

    wds_sp->um_phys_link_dos_ack_buf_ptr =
    ps_phys_link_alloc_event_cback_buf( wdsi_um_phys_link_ev_hdlr_cb,
                                        (void *) wds_sp );
      if(wds_sp->um_phys_link_dos_ack_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
  #ifdef FEATURE_EPC_HANDOFF
    wds_sp->um_iface_handoff_init_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_handoff_init_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }

    wds_sp->um_iface_handoff_success_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_handoff_success_buf_ptr == NULL)
      {
        is_err = TRUE;
        break;
      }
  
    wds_sp->um_iface_handoff_failure_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_um_iface_ev_cb, (void *) wds_sp );
      if(wds_sp->um_iface_handoff_failure_buf_ptr == NULL)
     {
        is_err = TRUE;
        break;
        }
  #endif /* FEATURE_EPC_HANDOFF */
  }while(0);

  if(is_err == TRUE)
  {
    ASSERT(0);
  }
} /* wdsi_alloc_event_cback_buf() */

/*===========================================================================
  FUNCTION WDSI_ALLOC_WLAN_EVENT_CBACK_BUF()

  DESCRIPTION
    Initialize the ps_iface cback buf_ptrs for WLAN/EPDG Iface

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_alloc_wlan_event_cback_buf
(
  qmi_wdsi_state_type *  wds_sp
)
{
  boolean is_err = FALSE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  do
  {
    if(wds_sp == NULL)
    {
      is_err = TRUE;
      break;
    }

    /*-------------------------------------------------------------------------
      Initialize the ps_iface cback buf_ptrs for WLAN iface event handling
      -------------------------------------------------------------------------*/
    ds_qmi_cflog_amss_call("ps_iface_alloc_event_cback_buf(3 times)");
  
    wds_sp->wlan_iface_configuring_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_wlan_iface_ev_cb, (void *) wds_sp );
     if(wds_sp->wlan_iface_configuring_buf_ptr == NULL)
    {
       is_err = TRUE;
       break;
     }
  
  
    wds_sp->wlan_iface_down_buf_ptr =
      ps_iface_alloc_event_cback_buf( wdsi_wlan_iface_ev_cb, (void *) wds_sp );
    if(wds_sp->wlan_iface_down_buf_ptr == NULL)
    {
      is_err = TRUE;
      break;
     }


    wds_sp->wlan_iface_rev_ip_transport_config_buf_ptr =
        ps_iface_alloc_event_cback_buf( wdsi_wlan_iface_ev_cb, (void *) wds_sp );
  
    if(wds_sp->wlan_iface_rev_ip_transport_config_buf_ptr == NULL)
    {
      is_err = TRUE;
      break;
    }
  }while(0);

   if(is_err == TRUE)
   {
     ASSERT(0);
   }

} /* wdsi_alloc_wlan_event_cback_buf() */
/*===========================================================================
  FUNCTION QMI_WDSI_SWAP_CLIENTS()

  DESCRIPTION
    Swaps 2 clients

  PARAMETERS
    cl_sp1 - client 1
    cl_sp2 - client 2

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_update_client
(
  void *  cl_sp
)
{
  qmi_transaction_type *        x_p;
  qmi_wdsi_state_type *         wds_sp;
  int i;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(cl_sp);

  x_p = &((qmi_wdsi_client_state_type *)cl_sp)->common.transactions[0];
  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);
  for (i=MAX_PENDING_TRANSACTIONS; i; i--, x_p++ )
  {
    x_p->svc_sp = (void *)wds_sp;
  }

} /* qmi_wdsi_update_client() */

/*===========================================================================
  FUNCTION QMI_WDSI_MOVE_CLIENT_TO_EXT_STATE()

  DESCRIPTION
    Move client from one state to another.

  PARAMETERS
    cl_sp

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void  qmi_wdsi_move_client_to_ext_state
(
  qmi_wdsi_client_state_type *  cl_sp
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT (cl_sp != NULL);

  if(WDSI_IPV4_STATE == cl_sp->current_wds_state)
    cl_sp->current_wds_state = WDSI_IPV6_STATE;
  else
    cl_sp->current_wds_state = WDSI_IPV4_STATE;

  qmi_wdsi_update_client(cl_sp);
} /* qmi_wdsi_move_client_to_ext_state() */

/*===========================================================================
  FUNCTION QMI_WDSI_SYNC_CLIENTS()

  DESCRIPTION
    Synchronize clients' WDS state

  PARAMETERS
    inst:  QMI instance

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_sync_clients(uint8 inst)
{
  qmi_wdsi_state_type        * wds_sp;
  qmi_wdsi_state_type        * current;
  qmi_wdsi_client_state_type * cl_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (inst >= WDS_INSTANCE_MAX)
  {
    LOG_MSG_ERROR_1("Invalid inst %d", inst);
    ASSERT(0);
    return;
  }

  wds_sp = qmi_wds_state[WDSI_IPV4_STATE][inst];
  if (wds_sp == NULL)
  {
    LOG_MSG_ERROR_1("wds_sp for inst %d is NULL", inst);
    return;
  }

  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
    current = qmi_wds_state[cl_sp->current_wds_state][inst];

    //if legacy
    if (QMI_AF_ANY == cl_sp->bound_ip_type)
    {
      if(!current->is_primary_state)
      {
        qmi_wdsi_move_client_to_ext_state(cl_sp);
      }
    }
    else
    {
      if (cl_sp->bound_ip_type != current->cur_ip_call_type)
      {
          qmi_wdsi_move_client_to_ext_state(cl_sp);
      }
    }
    cl_sp = cl_sp->next;
  }
} /* qmi_wdsi_sync_clients() */

/*===========================================================================
  FUNCTION QMI_WDSI_SET_CLIENT_IP_PREF()

  DESCRIPTION
    Get the packet statistics

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_client_ip_pref
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_client_state_type *  wds_cl_sp;
  wds_set_client_ip_family_pref_req_msg_v01 req_msg;
  wds_set_client_ip_family_pref_resp_msg_v01 resp_msg;
  dsm_item_type *        response;
  uint8                  inst;
  qmi_error_type_v01          errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  response          = NULL;
  errval            = QMI_ERR_NONE_V01;
  wds_cl_sp = (qmi_wdsi_client_state_type *)cl_sp;
  inst = wdsi_get_instance_from_wds_sp(sp);
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_CLIENT_IP_FAMILY_PREF_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  LOG_MSG_INFO2_1 ("Got IP pref setting: %d", req_msg.ip_preference);

  if( req_msg.ip_preference != WDS_IP_FAMILY_IPV4_V01 &&
      req_msg.ip_preference != WDS_IP_FAMILY_IPV6_V01 )
  {
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  // reject the change to IP family if client is already bound to a call on a different IP family
  if( TRUE == wds_cl_sp->net_bound &&
      ((qmi_ip_family_e_type)req_msg.ip_preference) != wds_cl_sp->bound_ip_type )
  {
    LOG_MSG_ERROR_0("Cannot change IP preference while client is in a data call!");
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }
  else
  {
    wds_cl_sp->bound_ip_type = (qmi_ip_family_e_type)req_msg.ip_preference;
    qmi_wdsi_sync_clients(inst);
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_CLIENT_IP_FAMILY_PREF_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_client_ip_pref() */

#ifdef FEATURE_DATA_WLAN_MAPCON

/*===========================================================================
  FUNCTION QMI_WDSI_REV_IP_TRANSPORT_CONNECTION_IND_REG()

  DESCRIPTION
    Allow client to register for reverse IP transport connection indication

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_rev_ip_transport_connection_ind_reg
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_reverse_ip_transport_connection_ind_registration_req_msg_v01 req_msg;
  wds_reverse_ip_transport_connection_ind_registration_resp_msg_v01 resp_msg;
  qmi_wdsi_client_state_type *  wds_client_sp;
  qmi_wdsi_state_type *         wds_sp;
  qmi_error_type_v01   errval;
  qmi_wdsi_cmd_buf_type * cmd_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_REVERSE_IP_TRANSPORT_CONNECTION_IND_REGISTRATION_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  wds_client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);
  if (wds_sp == NULL)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }
  wds_client_sp->report_status.report_rev_ip_transport_connection_ind =
                  req_msg.register_for_ind? TRUE : FALSE;

  /* Generate CONNECTED indication if client is registering for it */
  if (wds_client_sp->report_status.report_rev_ip_transport_connection_ind &&
      (wds_sp->wlan_iface_ptr != NULL) &&
      (wds_sp->wlan_tx.conn == PS_IFACE_IOCTL_REVERSE_IP_TRANSPORT_CONNECTED))
  {

    cmd_ptr = (qmi_wdsi_cmd_buf_type *)
                  qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_GEN_REV_IP_CONNECTED_IND);
    if( cmd_ptr != NULL)
    {
      memset(cmd_ptr, 0, sizeof(qmi_wdsi_cmd_buf_type));
      cmd_ptr->cmd_id = QMI_CMD_WDS_GEN_REV_IP_CONNECTED_IND;
      cmd_ptr->data.rev_ip_conn_info.cl_sp = cl_sp;

      dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
    }
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_REVERSE_IP_TRANSPORT_CONNECTION_IND_REGISTRATION_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;

} /* qmi_wdsi_rev_ip_transport_connection_ind_reg() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_IPSEC_STATIC_SA_CONFIG()

  DESCRIPTION
    Retrieves the IPSEC Static SA for the ePDG call

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_ipsec_static_sa_config
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_get_ipsec_static_sa_config_resp_msg_v01* resp_msg = NULL;
  qmi_wdsi_state_type *         wds_sp;
  ps_iface_ioctl_ipsec_sa_type ipsec_params;
  sint15                        ps_errno;
  qmi_error_type_v01   errval;
  uint32                i;
  int                   j;
  secips_ipsec_sa_type* ipsec_sa = NULL;
  uint32                                  tmp_v4;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg,
                           sizeof(wds_get_ipsec_static_sa_config_resp_msg_v01),
                           wds_get_ipsec_static_sa_config_resp_msg_v01*);
  if(resp_msg == NULL)
  {
    qmi_svc_put_result_tlv(&response,(qmi_result_e_type)QMI_RESULT_FAILURE_V01,
                          (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
    return response;
  } 
  else
  {
    memset(resp_msg,0,sizeof(wds_get_ipsec_static_sa_config_resp_msg_v01));
  }
  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);
  if (wds_sp == NULL)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    If WLAN Call not up or it is not ePDG, return error
  -------------------------------------------------------------------------*/
  if ((wds_sp->wlan_iface_ptr == NULL) ||
      (IWLAN_S2B_IFACE != (ps_iface_name_enum_type)
          (PS_IFACE_GET_NAME_FROM_ID(PS_IFACE_GET_ID(wds_sp->wlan_iface_ptr)))))
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    LOG_MSG_ERROR_0 ("WLAN iface ptr NULL or not of type ePDG");
    goto send_result;
  }

  //TODO: Verify client subs here when WLAN supports multi subs
  memset(&ipsec_params, 0, sizeof(ps_iface_ioctl_ipsec_sa_type));
  if ((ps_iface_ioctl(wds_sp->wlan_iface_ptr,
                   PS_IFACE_IOCTL_GET_IPSEC_SA,
                   &ipsec_params,
                   &ps_errno) != 0) ||
      (ipsec_params.ipsec_sa == NULL))
  {
    errval = QMI_ERR_INTERNAL_V01;
    LOG_MSG_ERROR_2 ("Unable to retrieve ipsec sa parameter from iface 0x%x, err %d",
                     wds_sp->wlan_iface_ptr, ps_errno);
    goto send_result;
  }

  ipsec_sa = (secips_ipsec_sa_type*)ipsec_params.ipsec_sa;

  /* Fill in all the output params */
  resp_msg->spi_rx_valid = TRUE;
  resp_msg->spi_rx = ipsec_sa->spi_in;

  resp_msg->spi_tx_valid = TRUE;
  resp_msg->spi_tx = ipsec_sa->spi_out;

  resp_msg->ipsec_sa_protocol_valid = TRUE;
  resp_msg->ipsec_sa_protocol = (uint32)ipsec_sa->type;

  resp_msg->encapsulation_mode_valid = TRUE;
  resp_msg->encapsulation_mode = (uint32)ipsec_sa->encapsulation_mode;

  /* Destination Address*/
  resp_msg->dest_addr_valid = TRUE;
  if (ipsec_sa->dest_addr.type == IPV4_ADDR)
  {
    resp_msg->dest_addr.addr_family = WDS_DATA_CALL_ADDR_FAMILY_IPV4_V01;
    resp_msg->dest_addr.ip_addr_len = 4;
    tmp_v4 = ps_ntohl(ipsec_sa->dest_addr.addr.v4.ps_s_addr);
    memscpy(resp_msg->dest_addr.ip_addr, sizeof(resp_msg->dest_addr.ip_addr),
            &tmp_v4, sizeof(tmp_v4));
  }
  else
  {
    resp_msg->dest_addr.addr_family = WDS_DATA_CALL_ADDR_FAMILY_IPV6_V01;
    resp_msg->dest_addr.ip_addr_len  = 16;
    memscpy(resp_msg->dest_addr.ip_addr,
            sizeof(resp_msg->dest_addr.ip_addr),
            ipsec_sa->dest_addr.addr.v6.in6_u.u6_addr8,
            sizeof(ipsec_sa->dest_addr.addr.v6.in6_u.u6_addr8));
  }
  /* Local Address*/
  resp_msg->local_addr_valid = TRUE;
  if (ipsec_sa->local_addr.type == IPV4_ADDR)
  {
    resp_msg->local_addr.addr_family = WDS_DATA_CALL_ADDR_FAMILY_IPV4_V01;
    resp_msg->local_addr.ip_addr_len = 4;
    tmp_v4 = ps_ntohl(ipsec_sa->local_addr.addr.v4.ps_s_addr);
    memscpy(resp_msg->local_addr.ip_addr, sizeof(resp_msg->local_addr.ip_addr), 
      &tmp_v4, sizeof(tmp_v4));
  }
  else
  {
    resp_msg->local_addr.addr_family = WDS_DATA_CALL_ADDR_FAMILY_IPV6_V01;
    resp_msg->local_addr.ip_addr_len = 16;
    memscpy(resp_msg->local_addr.ip_addr, 
            sizeof(resp_msg->local_addr.ip_addr),
            ipsec_sa->local_addr.addr.v6.in6_u.u6_addr8, 
            sizeof(ipsec_sa->local_addr.addr.v6.in6_u.u6_addr8));
  }

  /* Crypto material */
  resp_msg->hash_algo_valid = TRUE;
  resp_msg->hash_algo = (wds_ipsec_crypto_algo_enum_v01)ipsec_sa->hash_algo;

  /* Hash key In */
  if (ipsec_sa->hash_size <= sizeof(resp_msg->hash_key_rx))
  {
    resp_msg->hash_key_rx_valid = TRUE;
    resp_msg->hash_key_rx_len = MIN(ipsec_sa->hash_size, sizeof(resp_msg->hash_key_rx));
    memscpy(resp_msg->hash_key_rx, 
            sizeof(resp_msg->hash_key_rx), 
            ipsec_sa->hash_key_in, 
            resp_msg->hash_key_rx_len);
  }

  /* Hash key Out */
  /* Initialize just the hash key array to 0 since len value is same for in and out*/
  if (ipsec_sa->hash_size <= sizeof(resp_msg->hash_key_tx))
  {
    resp_msg->hash_key_tx_valid = TRUE;
    resp_msg->hash_key_tx_len = MIN(ipsec_sa->hash_size, sizeof(resp_msg->hash_key_tx));
    memscpy(resp_msg->hash_key_tx, 
            sizeof(resp_msg->hash_key_tx), 
            ipsec_sa->hash_key_out, 
            resp_msg->hash_key_tx_len);
  }

  /* EXT Hash key In */
  resp_msg->ext_hash_key_rx_valid = TRUE;
  resp_msg->ext_hash_key_rx_len = MIN(ipsec_sa->hash_size, sizeof(resp_msg->ext_hash_key_rx));
  memscpy(resp_msg->ext_hash_key_rx, 
          sizeof(resp_msg->ext_hash_key_rx), 
          ipsec_sa->hash_key_in, 
          resp_msg->ext_hash_key_rx_len);

  /* EXT Hash key Out */
  /* Initialize just the hash key array to 0 since len value is same for in and out*/
  resp_msg->ext_hash_key_tx_valid = TRUE;
  resp_msg->ext_hash_key_tx_len = MIN(ipsec_sa->hash_size, sizeof(resp_msg->ext_hash_key_tx));
  memscpy(resp_msg->ext_hash_key_tx, 
          sizeof(resp_msg->ext_hash_key_tx), 
          ipsec_sa->hash_key_out, 
          resp_msg->ext_hash_key_tx_len);


  /* Crypto algo */
  resp_msg->crypto_algo_valid = TRUE;
  resp_msg->crypto_algo = (wds_ipsec_crypto_algo_enum_v01)ipsec_sa->crypto_algo;

  /* Crypto key In */
  resp_msg->crypto_key_rx_valid = TRUE;
  resp_msg->crypto_key_rx_len = MIN(ipsec_sa->crypto_key_size, sizeof(resp_msg->crypto_key_rx));
  memscpy(resp_msg->crypto_key_rx, 
          sizeof(resp_msg->crypto_key_rx), 
          ipsec_sa->crypto_key_in, 
          resp_msg->crypto_key_rx_len);

  /* Crypto key Out */
  /* Initialize just the crypto key array to 0 since len value is same for in and out*/
  resp_msg->crypto_key_tx_valid = TRUE;
  resp_msg->crypto_key_tx_len = MIN(ipsec_sa->crypto_key_size, sizeof(resp_msg->crypto_key_tx));
  memscpy(resp_msg->crypto_key_tx, 
          sizeof(resp_msg->crypto_key_tx), 
          ipsec_sa->crypto_key_out, 
          resp_msg->crypto_key_tx_len);


  /* Initialization Vector */
  resp_msg->iv_valid = TRUE;
  resp_msg->iv_len = MIN(ipsec_sa->iv_size, sizeof(resp_msg->iv));
  memscpy(resp_msg->iv, sizeof(resp_msg->iv), ipsec_sa->iv, resp_msg->iv_len);

  /* NAT-T specific data */
  /* Is UDP Encaps */
  resp_msg->is_udp_encaps_valid = TRUE;
  resp_msg->is_udp_encaps = ipsec_sa->is_udp_encaps;

  /* Nat Local and Remote IP address are valid only if is_udp_encaps is TRUE */
  if (ipsec_sa->is_udp_encaps)
  {
    /* Add the Nat Local IP Addr TLV only if address is valid */
    if ((ipsec_sa->natoa_i.type == IPV4_ADDR) || (ipsec_sa->natoa_i.type == IPV6_ADDR))
    {
      /* NAT Local IP address */
      resp_msg->nat_local_ip_addr_valid = TRUE;
      if (ipsec_sa->natoa_i.type == IPV4_ADDR)
      {
        resp_msg->nat_local_ip_addr.addr_family = WDS_DATA_CALL_ADDR_FAMILY_IPV4_V01;
        resp_msg->nat_local_ip_addr.ip_addr_len =  4;
        tmp_v4 = ps_ntohl(ipsec_sa->natoa_i.addr.v4.ps_s_addr);
        memscpy(resp_msg->nat_local_ip_addr.ip_addr, 
                sizeof(resp_msg->nat_local_ip_addr.ip_addr), 
                &tmp_v4, 
                sizeof(tmp_v4));
      }
      else
      {
        resp_msg->nat_local_ip_addr.addr_family = WDS_DATA_CALL_ADDR_FAMILY_IPV6_V01;
        resp_msg->nat_local_ip_addr.ip_addr_len =  16;
        memscpy(resp_msg->nat_local_ip_addr.ip_addr, 
                sizeof(resp_msg->nat_local_ip_addr.ip_addr),
                ipsec_sa->natoa_i.addr.v6.in6_u.u6_addr8, 
                sizeof(ipsec_sa->natoa_i.addr.v6.in6_u.u6_addr8));
      }
    }

    /* Add the Nat Remote IP Addr TLV only if address is valid */
    if ((ipsec_sa->natoa_r.type == IPV4_ADDR) || (ipsec_sa->natoa_r.type == IPV6_ADDR))
    {
      /* NAT Remote IP address */
      resp_msg->nat_remote_ip_addr_valid = TRUE;
      if (ipsec_sa->natoa_r.type == IPV4_ADDR)
      {
        resp_msg->nat_remote_ip_addr.addr_family = WDS_DATA_CALL_ADDR_FAMILY_IPV4_V01;
        resp_msg->nat_remote_ip_addr.ip_addr_len = 4;
        tmp_v4 = ps_ntohl(ipsec_sa->natoa_r.addr.v4.ps_s_addr);
        memscpy(resp_msg->nat_remote_ip_addr.ip_addr, 
                sizeof(resp_msg->nat_remote_ip_addr.ip_addr), 
                &tmp_v4, 
                sizeof(tmp_v4));
      }
      else
      {
        resp_msg->nat_remote_ip_addr.addr_family = WDS_DATA_CALL_ADDR_FAMILY_IPV6_V01;
        resp_msg->nat_remote_ip_addr.ip_addr_len = 16;
        memscpy(resp_msg->nat_remote_ip_addr.ip_addr, 
                sizeof(resp_msg->nat_remote_ip_addr.ip_addr), 
                ipsec_sa->natoa_r.addr.v6.in6_u.u6_addr8, 
                sizeof(ipsec_sa->natoa_r.addr.v6.in6_u.u6_addr8));
      }
    }
  } /* if (ipsec_sa->is_udp_encaps) */

  /* Process all the Cfg Attributes in a loop */
  for (i=0; i<ipsec_sa->cfg_attr_cnt && i<IPSEC_CFG_MAX_ATTRS; i++ )
  {
    switch (ipsec_sa->cfg_attr[i].type)
    {
       case IPSEC_CFG_INTERNAL_IP4_ADDRESS:
       {
         
         if (resp_msg->cfg_attr_internal_ipv4_address_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           resp_msg->cfg_attr_internal_ipv4_address[resp_msg->cfg_attr_internal_ipv4_address_len++] = 
             ps_ntohl(ipsec_sa->cfg_attr[i].value.ip4_address_ptr->ps_s_addr);
           resp_msg->cfg_attr_internal_ipv4_address_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_INTERNAL_IP4_NETMASK:
       {
         resp_msg->cfg_attr_internal_ipv4_netmask_valid = TRUE;
         resp_msg->cfg_attr_internal_ipv4_netmask = 
                ps_ntohl(ipsec_sa->cfg_attr[i].value.ip4_address_ptr->ps_s_addr);
         break;
       }
       case IPSEC_CFG_INTERNAL_IP4_DNS:
       {
         if (resp_msg->cfg_attr_internal_ipv4_dns_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           resp_msg->cfg_attr_internal_ipv4_dns[resp_msg->cfg_attr_internal_ipv4_dns_len++] = 
             ps_ntohl(ipsec_sa->cfg_attr[i].value.ip4_address_ptr->ps_s_addr);
           resp_msg->cfg_attr_internal_ipv4_dns_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_INTERNAL_IP4_NBNS:
       {
         if (resp_msg->cfg_attr_internal_ipv4_nbns_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           memscpy(&tmp_v4, 
                   sizeof(tmp_v4),
                   ipsec_sa->cfg_attr[i].value.data_ptr,
                   ipsec_sa->cfg_attr[i].value_len);
           resp_msg->cfg_attr_internal_ipv4_nbns[resp_msg->cfg_attr_internal_ipv4_nbns_len++] = 
                                             ps_ntohl(tmp_v4);
           resp_msg->cfg_attr_internal_ipv4_nbns_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_INTERNAL_ADDRESS_EXPIRY:
       {
         resp_msg->cfg_attr_internal_address_expiry_valid = TRUE;
         memscpy(&resp_msg->cfg_attr_internal_address_expiry, 
                 sizeof(resp_msg->cfg_attr_internal_address_expiry),
                 ipsec_sa->cfg_attr[i].value.data_ptr,
                 ipsec_sa->cfg_attr[i].value_len);
         break;
       }
       case IPSEC_CFG_INTERNAL_IP4_DHCP:
       {
         if (resp_msg->cfg_attr_internal_ipv4_dhcp_len< QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           resp_msg->cfg_attr_internal_ipv4_dhcp[resp_msg->cfg_attr_internal_ipv4_dhcp_len++] = 
             ps_ntohl(ipsec_sa->cfg_attr[i].value.ip4_address_ptr->ps_s_addr);
           resp_msg->cfg_attr_internal_ipv4_dhcp_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_APPLICATION_VERSION:
       {
         resp_msg->cfg_attr_application_version_valid = TRUE;
         resp_msg->cfg_attr_application_version_len =
             (uint8)MIN(ipsec_sa->cfg_attr[i].value_len, sizeof(resp_msg->cfg_attr_application_version));
         memscpy(resp_msg->cfg_attr_application_version, 
                 resp_msg->cfg_attr_application_version_len,
                 ipsec_sa->cfg_attr[i].value.data_ptr, 
                 ipsec_sa->cfg_attr[i].value_len);
         break;
       }
       case IPSEC_CFG_INTERNAL_IP6_ADDRESS:
       {
         if (resp_msg->cfg_attr_internal_ipv6_address_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           resp_msg->cfg_attr_internal_ipv6_address[resp_msg->cfg_attr_internal_ipv6_address_len].ipv6_prefix_length = 
             (uint8)ipsec_sa->cfg_attr[i].prefix_len;
           memscpy(resp_msg->cfg_attr_internal_ipv6_address[resp_msg->cfg_attr_internal_ipv6_address_len].ipv6_addr,
             sizeof(resp_msg->cfg_attr_internal_ipv6_address[resp_msg->cfg_attr_internal_ipv6_address_len].ipv6_addr),
             ipsec_sa->cfg_attr[i].value.ip6_address_ptr->in6_u.u6_addr8, 
             sizeof(ipsec_sa->cfg_attr[i].value.ip6_address_ptr->in6_u.u6_addr8));
           resp_msg->cfg_attr_internal_ipv6_address_len++;
		   resp_msg->cfg_attr_internal_ipv6_address_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_INTERNAL_IP6_DNS:
       {
         if (resp_msg->cfg_attr_internal_ipv6_dns_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           memscpy(resp_msg->cfg_attr_internal_ipv6_dns[resp_msg->cfg_attr_internal_ipv6_dns_len].ipv6_address, 
             sizeof(resp_msg->cfg_attr_internal_ipv6_dns[resp_msg->cfg_attr_internal_ipv6_dns_len].ipv6_address),
             ipsec_sa->cfg_attr[i].value.ip6_address_ptr->in6_u.u6_addr8, 
             sizeof(ipsec_sa->cfg_attr[i].value.ip6_address_ptr->in6_u.u6_addr8));
           resp_msg->cfg_attr_internal_ipv6_dns_len++;
           resp_msg->cfg_attr_internal_ipv6_dns_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_INTERNAL_IP6_NBNS:
       {
         if (resp_msg->cfg_attr_internal_ipv6_nbns_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           memscpy(resp_msg->cfg_attr_internal_ipv6_nbns[resp_msg->cfg_attr_internal_ipv6_nbns_len].ipv6_address,
             sizeof(resp_msg->cfg_attr_internal_ipv6_nbns[resp_msg->cfg_attr_internal_ipv6_nbns_len].ipv6_address),
             ipsec_sa->cfg_attr[i].value.data_ptr, 
             ipsec_sa->cfg_attr[i].value_len);
           resp_msg->cfg_attr_internal_ipv6_nbns_len++;
           resp_msg->cfg_attr_internal_ipv6_nbns_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_INTERNAL_IP6_DHCP:
       {
         if (resp_msg->cfg_attr_internal_ipv6_dhcp_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           memscpy(resp_msg->cfg_attr_internal_ipv6_dhcp[resp_msg->cfg_attr_internal_ipv6_dhcp_len].ipv6_address,
             sizeof(resp_msg->cfg_attr_internal_ipv6_dhcp[resp_msg->cfg_attr_internal_ipv6_dhcp_len].ipv6_address), 
             ipsec_sa->cfg_attr[i].value.ip6_address_ptr->in6_u.u6_addr8, 
             sizeof(ipsec_sa->cfg_attr[i].value.ip6_address_ptr->in6_u.u6_addr8));
           resp_msg->cfg_attr_internal_ipv6_dhcp_len++;
           resp_msg->cfg_attr_internal_ipv6_dhcp_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_INTERNAL_IP4_SUBNET:
       {
         if (resp_msg->cfg_attr_internal_ipv4_subnet_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           resp_msg->cfg_attr_internal_ipv4_subnet[resp_msg->cfg_attr_internal_ipv4_subnet_len].ipv4_subnet_address = 
             ps_ntohl(ipsec_sa->cfg_attr[i].value.ip4_subnet_ptr->addr.ps_s_addr);
           resp_msg->cfg_attr_internal_ipv4_subnet[resp_msg->cfg_attr_internal_ipv4_subnet_len].subnet_mask = 
             ps_ntohl(ipsec_sa->cfg_attr[i].value.ip4_subnet_ptr->subnet_mask.ps_s_addr);  
           resp_msg->cfg_attr_internal_ipv4_subnet_len++;
           resp_msg->cfg_attr_internal_ipv4_subnet_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_SUPPORTED_ATTRIBUTES:
       {resp_msg->cfg_attr_supported_attributes_len = 
                 (uint8)MIN(ipsec_sa->cfg_attr[i].value_len, sizeof(resp_msg->cfg_attr_supported_attributes));
         memscpy(resp_msg->cfg_attr_supported_attributes, 
                 resp_msg->cfg_attr_supported_attributes_len,
                 ipsec_sa->cfg_attr[i].value.data_ptr, 
                 ipsec_sa->cfg_attr[i].value_len);
         resp_msg->cfg_attr_supported_attributes_valid = TRUE;
         break;
       }
       case IPSEC_CFG_INTERNAL_IP6_SUBNET:
       {
         if (resp_msg->cfg_attr_internal_ipv6_subnet_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           resp_msg->cfg_attr_internal_ipv6_subnet[resp_msg->cfg_attr_internal_ipv6_subnet_len].ipv6_prefix_length = 
             ipsec_sa->cfg_attr[i].value.ip6_subnet_ptr->prefix_len;
           memscpy(resp_msg->cfg_attr_internal_ipv6_subnet[resp_msg->cfg_attr_internal_ipv6_subnet_len].ipv6_addr,
             sizeof(resp_msg->cfg_attr_internal_ipv6_subnet[resp_msg->cfg_attr_internal_ipv6_subnet_len].ipv6_addr), 
             ipsec_sa->cfg_attr[i].value.ip6_subnet_ptr->addr.in6_u.u6_addr8, 
             sizeof(ipsec_sa->cfg_attr[i].value.ip6_subnet_ptr->addr.in6_u.u6_addr8));
           resp_msg->cfg_attr_internal_ipv6_subnet_len++;
           resp_msg->cfg_attr_internal_ipv6_subnet_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_INTERNAL_IP4_PCSCF:
       {
         if (resp_msg->cfg_attr_internal_pcscf_ipv4_address_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           memscpy(&tmp_v4, 
                   sizeof(tmp_v4), 
                   ipsec_sa->cfg_attr[i].value.data_ptr,
                   ipsec_sa->cfg_attr[i].value_len);
           resp_msg->cfg_attr_internal_pcscf_ipv4_address[resp_msg->cfg_attr_internal_pcscf_ipv4_address_len] =
                              ps_ntohl(tmp_v4);
           resp_msg->cfg_attr_internal_pcscf_ipv4_address_len++;
           resp_msg->cfg_attr_internal_pcscf_ipv4_address_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_INTERNAL_IP6_PCSCF:
       {
         if (resp_msg->cfg_attr_internal_pcscf_ipv6_address_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           resp_msg->cfg_attr_internal_pcscf_ipv6_address[resp_msg->cfg_attr_internal_pcscf_ipv6_address_len].ipv6_prefix_length = 
             (uint8)ipsec_sa->cfg_attr[i].prefix_len;
           memscpy(resp_msg->cfg_attr_internal_pcscf_ipv6_address[resp_msg->cfg_attr_internal_pcscf_ipv6_address_len].ipv6_addr,
             sizeof(resp_msg->cfg_attr_internal_pcscf_ipv6_address[resp_msg->cfg_attr_internal_pcscf_ipv6_address_len].ipv6_addr),
             ipsec_sa->cfg_attr[i].value.data_ptr,
             ipsec_sa->cfg_attr[i].value_len);
           resp_msg->cfg_attr_internal_pcscf_ipv6_address_len++;
           resp_msg->cfg_attr_internal_pcscf_ipv6_address_valid =  TRUE;
         }
         break;
       }
       case IPSEC_CFG_3GPP2_MIP4_HA:
       {
         if (resp_msg->cfg_attr_3gpp2_mip4_ha_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           memscpy(&tmp_v4, 
                   sizeof(tmp_v4), 
                   ipsec_sa->cfg_attr[i].value.data_ptr,
                   ipsec_sa->cfg_attr[i].value_len);
           resp_msg->cfg_attr_3gpp2_mip4_ha[resp_msg->cfg_attr_3gpp2_mip4_ha_len] = ps_ntohl(tmp_v4);
           resp_msg->cfg_attr_3gpp2_mip4_ha_len++;
           resp_msg->cfg_attr_3gpp2_mip4_ha_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_3GPP2_MIP4_HOA:
       {
         if (resp_msg->cfg_attr_3gpp2_mip4_hoa_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           memscpy(&tmp_v4, 
                   sizeof(tmp_v4), 
                   ipsec_sa->cfg_attr[i].value.data_ptr,
                   ipsec_sa->cfg_attr[i].value_len);
           resp_msg->cfg_attr_3gpp2_mip4_hoa[resp_msg->cfg_attr_3gpp2_mip4_hoa_len] = ps_ntohl(tmp_v4);
           resp_msg->cfg_attr_3gpp2_mip4_hoa_len++;
           resp_msg->cfg_attr_3gpp2_mip4_hoa_valid = TRUE;;
         }
         break;
       }
       case IPSEC_CFG_3GPP2_MIP6_HA:
       {
         if (resp_msg->cfg_attr_3gpp2_mip6_ha_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           resp_msg->cfg_attr_3gpp2_mip6_ha[resp_msg->cfg_attr_3gpp2_mip6_ha_len].ipv6_prefix_length = 
             (uint8)ipsec_sa->cfg_attr[i].prefix_len;
           memscpy(resp_msg->cfg_attr_3gpp2_mip6_ha[resp_msg->cfg_attr_3gpp2_mip6_ha_len].ipv6_addr, 
             sizeof(resp_msg->cfg_attr_3gpp2_mip6_ha[resp_msg->cfg_attr_3gpp2_mip6_ha_len].ipv6_addr),
             ipsec_sa->cfg_attr[i].value.data_ptr, 
             ipsec_sa->cfg_attr[i].value_len);
           resp_msg->cfg_attr_3gpp2_mip6_ha_len++;
           resp_msg->cfg_attr_3gpp2_mip6_ha_valid = TRUE;
         }
         break;
       }
       case IPSEC_CFG_3GPP2_MIP6_HOA:
       {
         if (resp_msg->cfg_attr_3gpp2_mip6_hoa_len < QMI_WDS_IPSEC_SA_CFG_ATTR_MAX_V01 )
         {
           resp_msg->cfg_attr_3gpp2_mip6_hoa[resp_msg->cfg_attr_3gpp2_mip6_hoa_len].ipv6_prefix_length = 
             (uint8)ipsec_sa->cfg_attr[i].prefix_len;
           memscpy(resp_msg->cfg_attr_3gpp2_mip6_hoa[resp_msg->cfg_attr_3gpp2_mip6_hoa_len].ipv6_addr,
             sizeof(resp_msg->cfg_attr_3gpp2_mip6_hoa[resp_msg->cfg_attr_3gpp2_mip6_hoa_len].ipv6_addr),
             ipsec_sa->cfg_attr[i].value.data_ptr,
             ipsec_sa->cfg_attr[i].value_len);
           resp_msg->cfg_attr_3gpp2_mip6_hoa_len++;
           resp_msg->cfg_attr_3gpp2_mip6_hoa_valid = TRUE;
         }
         break;
       }
       default:
       {
         LOG_MSG_ERROR_1("Unhandled CFG_ATTR type %d",
                         ipsec_sa->cfg_attr[i].type);
         break;
       }
    } /* switch */
  } /* End for loop that processes all cfg attributes*/

  if (ipsec_sa->ts_list.ts_count > 0){
    resp_msg->traffic_selector_list_valid = TRUE;
    resp_msg->traffic_selector_list_len = MIN(ipsec_sa->ts_list.ts_count, QMI_WDS_IPSEC_SA_MAX_TS_COUNT_V01);
    /* Process Traffic Selector List */
    for (j=MIN(ipsec_sa->ts_list.ts_count, QMI_WDS_IPSEC_SA_MAX_TS_COUNT_V01) - 1; j >=0; j--)
    {
      resp_msg->traffic_selector_list[j].protocol = ipsec_sa->ts_list.ts[j].protocol;
      resp_msg->traffic_selector_list[j].start_port = ps_ntohs(ipsec_sa->ts_list.ts[j].start_port);
      resp_msg->traffic_selector_list[j].end_port = ps_ntohs(ipsec_sa->ts_list.ts[j].end_port);
      resp_msg->traffic_selector_list[j].start_address.addr_family = 
               (wds_data_call_addr_family_enum_v01)ipsec_sa->ts_list.ts[j].ip_vsn;
      resp_msg->traffic_selector_list[j].end_address.addr_family = 
               (wds_data_call_addr_family_enum_v01)ipsec_sa->ts_list.ts[j].ip_vsn;
      switch (ipsec_sa->ts_list.ts[j].ip_vsn)
      {
         case IP_V4:
           {
             resp_msg->traffic_selector_list[j].start_address.ip_addr_len = 
               resp_msg->traffic_selector_list[j].end_address.ip_addr_len = 4;
             tmp_v4 = ps_ntohl(ipsec_sa->ts_list.ts[j].start_address.ipv4_addr);
             memscpy(resp_msg->traffic_selector_list[j].start_address.ip_addr,
                     sizeof(resp_msg->traffic_selector_list[j].start_address.ip_addr),
                     &tmp_v4,sizeof(tmp_v4));
             tmp_v4 = ps_ntohl(ipsec_sa->ts_list.ts[j].end_address.ipv4_addr);
             memscpy(resp_msg->traffic_selector_list[j].end_address.ip_addr,
                     sizeof(resp_msg->traffic_selector_list[j].end_address.ip_addr),
                     &tmp_v4,sizeof(tmp_v4));
             break;
           }
         case IP_V6:
           {
             resp_msg->traffic_selector_list[j].start_address.ip_addr_len = 
               resp_msg->traffic_selector_list[j].end_address.ip_addr_len = 16;
             memscpy(resp_msg->traffic_selector_list[j].start_address.ip_addr, 
                     sizeof(resp_msg->traffic_selector_list[j].start_address.ip_addr), 
                     ipsec_sa->ts_list.ts[j].start_address.ipv6_addr.in6_u.u6_addr8, 
                     sizeof(ipsec_sa->ts_list.ts[j].start_address.ipv6_addr.in6_u.u6_addr8));
             memscpy(resp_msg->traffic_selector_list[j].end_address.ip_addr, 
                     sizeof(resp_msg->traffic_selector_list[j].end_address.ip_addr),
                     ipsec_sa->ts_list.ts[j].end_address.ipv6_addr.in6_u.u6_addr8, 
                     sizeof(ipsec_sa->ts_list.ts[j].end_address.ipv6_addr.in6_u.u6_addr8));
             break;
           }
         default:
           /* Shouldnt come here at all */
           LOG_MSG_ERROR_1("Invalid IP addr type %d recd from IPSEC",
                           ipsec_sa->ts_list.ts[j].ip_vsn);
           ASSERT(0);
           errval = QMI_ERR_INTERNAL_V01;
           goto send_result;
      }
    }
    /* Account for the TS List count. */
  }


  if(ipsec_sa->idr.type == SECIPSPKTDEFS_IDENT_TYPE_FQDR ||
     ipsec_sa->idr.type == SECIPSPKTDEFS_IDENT_TYPE_KEY_ID)
  {
    resp_msg->apn_valid = TRUE;
    memscpy(resp_msg->apn,sizeof(resp_msg->apn),
      ipsec_sa->idr.value.key_id.data_ptr,ipsec_sa->idr.value.key_id.length);
  }
  else
  {
    LOG_MSG_ERROR_1("IDr type is %d, not filling APN name",
                     ipsec_sa->idr.type);
  }

  if (ipsec_sa->aes_mode < AES_MODE_MAX_VALUE)
  {
    resp_msg->aes_mode_valid = TRUE;
    resp_msg->aes_mode = (wds_ipsec_aes_mode_enum_v01)ipsec_sa->aes_mode;
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_IPSEC_STATIC_SA_CONFIG_RESP_V01,
                               resp_msg,
                               sizeof(wds_get_ipsec_static_sa_config_resp_msg_v01),
                               errval,
                               &response);
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  return response;

} /* qmi_wdsi_get_ipsec_static_sa_config() */

/*===========================================================================
  FUNCTION QMI_WDSI_REV_IP_TRANSPORT_CONFIG_COMPLETE()

  DESCRIPTION
    Handles reverse IP transport configuration status
 
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_rev_ip_transport_config_complete
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_reverse_ip_transport_config_complete_req_msg_v01 req_msg;
  wds_reverse_ip_transport_config_complete_resp_msg_v01 resp_msg;
  qmi_wdsi_state_type *         wds_sp = NULL;
  sint15             ps_errno = 0;
  qmi_error_type_v01   errval;
  ps_iface_ioctl_reverse_ip_transport_config_status_type config_status = {0};
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_REVERSE_IP_TRANSPORT_CONFIG_COMPLETE_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);
  if (wds_sp == NULL)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  if ((!wds_sp->wlan_tx.wlan_tx_pending) || (req_msg.transaction_id != wds_sp->wlan_tx.wlan_tx_id))
  {
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  config_status.conn = wds_sp->wlan_tx.conn;
  config_status.status = req_msg.config_result;

  /* WLAN iface ptr will be NULL in case previous indication was for DISCONNECT */
  if (NULL != wds_sp->wlan_iface_ptr)
  {
    //TODO: Verify client subs here when WLAN supports multi subs
    if (ps_iface_ioctl(wds_sp->wlan_iface_ptr,
                       PS_IFACE_IOCTL_REVERSE_IP_TRANSPORT_CONFIG_STATUS,
                       &config_status,
                       &ps_errno) != 0)
    {
      errval = QMI_ERR_INTERNAL_V01;
      goto send_result;
    }
  }
  wds_sp->wlan_tx.wlan_tx_pending = FALSE;

send_result:
  if( (wds_sp != NULL) && (errval != QMI_ERR_NONE_V01) )
  {
      LOG_MSG_ERROR_4 ("qmi_wdsi_rev_ip_transport_config_complete: errval:%d,"
                       "invalid arg: outstanding %d"
                       " tx_id, invalid %d ps_error %d",errval,
                       wds_sp->wlan_tx.wlan_tx_pending,
                       wds_sp->wlan_tx.wlan_tx_id,
                       ps_errno);     
  }

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_REVERSE_IP_TRANSPORT_CONFIG_COMPLETE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_rev_ip_transport_config_complete() */

/*===========================================================================
  FUNCTION QMI_WDSI_INITIATE_ESP_REKEY()

  DESCRIPTION
    Initiates a ESP rekey with IPSEC

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_initiate_esp_rekey
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_initiate_esp_rekey_resp_msg_v01 resp_msg;
  qmi_wdsi_state_type *         wds_sp;
  sint15                        ps_errno;
  qmi_error_type_v01   errval;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/


  /*-------------------------------------------------------------------------
    Build the response from back to front
  -------------------------------------------------------------------------*/
  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);
  if (wds_sp == NULL)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  /*-------------------------------------------------------------------------
    If WLAN Call not up or it is not ePDG, return error
  -------------------------------------------------------------------------*/
  if ((wds_sp->wlan_iface_ptr == NULL) ||
      (IWLAN_S2B_IFACE != (ps_iface_name_enum_type)
          (PS_IFACE_GET_NAME_FROM_ID(PS_IFACE_GET_ID(wds_sp->wlan_iface_ptr)))))
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  //TODO: Verify client subs here when WLAN supports multi subs
  if (ps_iface_ioctl(wds_sp->wlan_iface_ptr,
                   PS_IFACE_IOCTL_INITIATE_ESP_REKEY,
                   NULL,
                   &ps_errno) != 0)
  {
    errval = QMI_ERR_INTERNAL_V01;
    LOG_MSG_ERROR_2 ("Unable to initiate ESP rekey on iface 0x%x, err %d",
                   wds_sp->wlan_iface_ptr, ps_errno);
    goto send_result;
  }

send_result:
  if(errval !=  QMI_ERR_NONE_V01)
  {
     LOG_MSG_ERROR_1("qmi_wdsi_initiate_esp_rekey errval:%d",
                     errval);
  }
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_INITIATE_ESP_REKEY_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_initiate_esp_rekey() */
#endif /* FEATURE_DATA_WLAN_MAPCON */

#if defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)
/*===========================================================================
  FUNCTION QMI_WDSI_EVDO_PAGE_MONITOR_PERIOD_CHANGED_CB()

  DESCRIPTION
    EVDO Page Monitor Period changed callback function registered with mode handler.

  PARAMETERS
    ds707_pkt_mgr_evdo_page_monitor_period_type : EVDO page monitor period

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_evdo_page_monitor_period_changed_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
  ps_sys_3gpp2_page_monitor_period_info_type     * ps_page_monitor = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(event_info_ptr);
  ps_page_monitor = (ps_sys_3gpp2_page_monitor_period_info_type *)event_info_ptr;

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_EVDO_PMP_CHANGE_EVT);
  if( cmd_ptr == NULL)
  {
    return;
  }

  cmd_ptr->cmd_id = QMI_CMD_PROCESS_EVDO_PMP_CHANGE_EVT;
  cmd_ptr->data.epmp.evdo_page_monitor_period = 
    ps_page_monitor->slotted_mode_option;
  cmd_ptr->data.epmp.evdo_force_long_sleep = 
    ps_page_monitor->long_sleep_enabled;
  cmd_ptr->subscription_id = subscription_id;

  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);

}/* qmi_wdsi_evdo_page_monitor_period_changed_cb */


/*===========================================================================
  FUNCTION QMI_WDSI_SET_EVDO_PMP_CB()

  DESCRIPTION
    Set EVDO Page Monitor Period callback function registered with mode handler.

  PARAMETERS
    evt : Either SUCCESS(0) or FAILURE(-1)
    failure_code : Valid if evt is FAILURE. Contains actual failure cause

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_wdsi_set_evdo_pmp_cb(int16 evt, 
                 ps_hdr_slotted_mode_failure_code_enum_type* failure_code)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  LOG_MSG_INFO2_1("Set EVDO PMP callback called, evt=%d", evt);
  if (failure_code)
  {
    LOG_MSG_INFO2_1("Failure code=%d", *failure_code);
  }
  cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_SET_EVDO_PMP_CB);
  if( cmd_ptr == NULL)
  {
    return;
  }

  cmd_ptr->cmd_id = QMI_CMD_PROCESS_SET_EVDO_PMP_CB;
  cmd_ptr->data.set_evdo_pmp_info.evt = evt;
  cmd_ptr->data.set_evdo_pmp_info.failure_code = 
    PS_HDR_SLOTTED_MODE_REQUEST_REJECTED; /* Initialize*/
  if ((0 != evt) && (NULL != failure_code)) /*It is a failure */
  {
    cmd_ptr->data.set_evdo_pmp_info.failure_code = *failure_code;
  }

  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);

}/* qmi_wdsi_set_evdo_pmp_cb */
#endif /*defined (FEATURE_CDMA_800) || defined (FEATURE_CDMA_1900)*/



/*===========================================================================
FUNCTION  QMI_WDSI_GENERATE_DATA_SYSTEM_STATUS_IND

DESCRIPTION
  This callback is called to notify clients about data system status changes.

PARAMETERS
  system_status - System status info like preferred network, rat mask,
                  so mask.
  subs_id: Subscription identifier

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
static void qmi_wdsi_generate_data_system_status_ind
(
  qmi_wdsi_curr_data_system_status_type  data_system_status,
  uint32                                 subscription_id
)
{
  qmi_wdsi_state_type                          * wds_sp;
  qmi_wdsi_client_state_type                   * cl_sp;
  uint8                                          state;
  uint8                                          inst;
  uint32                                         rat_mask;
  uint32                                         pref_data_sys;
  boolean                                        is_rats_family_same;
  uint32                                         last_rat_mask;
  uint32                                         last_so_mask;
  int                                            last_pref_network;
  int                                            curr_pref_network;
  boolean                                        diag_event_reported = FALSE;
  qmi_wdsi_curr_data_system_status_type        * last_data_system_status;
  ps_sys_system_status_diag_event_logging_type   system_status_log;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  memset(&system_status_log, 0, sizeof(system_status_log));

  curr_pref_network = data_system_status.preferred_network;
  
  if(curr_pref_network > PS_SYS_NETWORK_3GPP2)
  {
    LOG_MSG_ERROR_0("QMI-WDS only supports reporting pref nw as 3GPP or 3GPP2");
    return;
  }
  
  LOG_MSG_INFO2_3("In qmi_wdsi_generate_data_system_status_ind,"
                  "pref network %d rat mask 0x%x so mask 0x%x",
                  curr_pref_network,
                  data_system_status.network_info[curr_pref_network].rat_mask,
                  data_system_status.network_info[curr_pref_network].so_mask);

  rat_mask = (data_system_status.preferred_network == PS_SYS_NETWORK_3GPP) ?
              data_system_status.network_info[PS_SYS_NETWORK_3GPP].rat_mask :
              data_system_status.network_info[PS_SYS_NETWORK_3GPP2].rat_mask;
              
  pref_data_sys = wdsi_xlate_data_system_status_to_pref_data_sys(
    data_system_status.preferred_network, rat_mask);
    
  last_data_system_status = &qmi_wdsi_global.last_data_system_status;        
          
  /* Retrieve last data system status from cache*/
  last_pref_network = last_data_system_status->preferred_network;
  last_rat_mask = 
    last_data_system_status->network_info[last_pref_network].rat_mask;          
  last_so_mask = 
    last_data_system_status->network_info[last_pref_network].so_mask;
                    
  LOG_MSG_INFO2_3("In qmi_wdsi_generate_data_system_status_ind, "
                  "previous pref network %d  previous last rat mask 0x%x"
                  " previous so mask 0x%x",
                  last_pref_network, last_rat_mask, last_so_mask);

  is_rats_family_same =
    ((rat_mask & FAMILY_3GPP_WCDMA_RATS) && (last_rat_mask & FAMILY_3GPP_WCDMA_RATS)) || \
    ((rat_mask & FAMILY_3GPP_GSM_RATS) && (last_rat_mask & FAMILY_3GPP_GSM_RATS)) ||  \
    ((rat_mask & FAMILY_3GPP_LTE_RATS) && (last_rat_mask & FAMILY_3GPP_LTE_RATS)) ||  \
    ((rat_mask & FAMILY_3GPP_TDSCDMA_RATS) && (last_rat_mask & FAMILY_3GPP_TDSCDMA_RATS));
    
  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }
                 
      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp) &&
            (TRUE == cl_sp->report_status.report_data_system_status || 
             TRUE == cl_sp->report_status.report_limited_data_system_status) &&
             qmi_wdsi_verify_client_subs(cl_sp, subscription_id, FALSE) )
        {                    
          /* if client has registered for limited sys status indication. 
             Check if last and  and previous system status preferred network
             is 3gpp. Limited system status indication only comes in effect
             if data system status indication is not registered.
          */
          if(TRUE == cl_sp->report_status.report_limited_data_system_status &&
             FALSE == cl_sp->report_status.report_data_system_status &&
             curr_pref_network == PS_SYS_NETWORK_3GPP &&
             last_pref_network == PS_SYS_NETWORK_3GPP )
          {
              LOG_MSG_INFO2_0 ("qmi_wdsi_generate_data_system_status_ind : Checking RAT"
                               " family of previous and current system status ind"); 
                             
              /* if RAT of last and current system status belongs to same family then dont
                 send the system status indication to client
              */
              if(TRUE == is_rats_family_same)
              {
                LOG_MSG_INFO2_0("qmi_wdsi_generate_data_system_status_ind : Not sending"
                                "system status ind since previous RAT and current RAT belong"
                                "to same family");
                cl_sp = cl_sp->next;
                continue;
              }                         
          } 
          /* This flag is checked to send the diag event only once for all the clients */
          if(diag_event_reported == FALSE)
          {
            /* Diag event for system status indication */          
            system_status_log.pref_network = curr_pref_network;
            system_status_log.rat_value    = data_system_status.network_info[curr_pref_network].rat_mask;
            system_status_log.so_mask      = data_system_status.network_info[curr_pref_network].so_mask;
            system_status_log.subs_id      = (ps_sys_subscription_enum_type)subscription_id;   
            /* Set the flag to true so that the event is not generated for all the clients */
            diag_event_reported            = TRUE;
            event_report_payload(EVENT_QMI_SYSTEM_STATUS, 
                                 sizeof(ps_sys_system_status_diag_event_logging_type),
                                 (void*) &system_status_log);
          }
          
          qmi_wdsi_event_report_ind(wds_sp,
                                    cl_sp->common.clid,
                                    WDSI_REPORT_STATUS_DATA_SYSTEM_STATUS,
                                    0,
                                    0,
                                    NULL,
                                    QMI_WDS_BEARER_TECH_UNKNOWN,
                                    0,
                                    (qmi_wds_dormancy_status_e_type) 0,
                                    NULL,
                                      0,
                                    WDSI_CALL_UKNOWN,
                                    WDSI_DATA_CALL_NONE,                                    
                                    0,
                                    NULL,
                                    &data_system_status,
                                    NULL,
                                    NULL);
        }
        if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp) &&
            TRUE == cl_sp->report_status.report_preferred_data_system)
        {
          qmi_wdsi_event_report_ind(wds_sp,
                                    cl_sp->common.clid,
                                    WDSI_REPORT_STATUS_PREFERRED_DATA_STATUS,
                                    0,
                                    0,
                                    NULL,
                                    QMI_WDS_BEARER_TECH_UNKNOWN,
                                    0,
                                    (qmi_wds_dormancy_status_e_type) 0,
                                    NULL,
                                    pref_data_sys,
                                    WDSI_CALL_UKNOWN,
                                    WDSI_DATA_CALL_NONE,                                    
                                    0,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
        }
        cl_sp = cl_sp->next;
      } /* while */
    }
  }

  /* Update the cache of last data system status */
  memscpy(&qmi_wdsi_global.last_data_system_status,
          sizeof(qmi_wdsi_curr_data_system_status_type),
         &data_system_status,
         sizeof(qmi_wdsi_curr_data_system_status_type));

} /* qmi_wdsi_generate_data_system_status_ind */


/*===========================================================================
FUNCTION  QMI_WDSI_PROCESS_DATA_CALL_STATUS_CHANGE

DESCRIPTION
  This callback is called by qmi task when the preferred system changes.

PARAMETERS
  call_status: activated/terminated
  call_type:   Data call type
  addr_family: IP family
  subs_id: Subscription identifier

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
static void qmi_wdsi_process_data_call_status_change
(
  uint32 call_status,
  qmi_wdsi_data_call_e_type data_call_type, 
  uint8 addr_family,
  uint32 subs_id
)
{
  qmi_wdsi_state_type *         wds_sp;
  qmi_wdsi_client_state_type *  cl_sp;
  uint8                         state;
  uint8                         inst;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  LOG_MSG_INFO2_1("changing call status to %d", call_status);

  qmi_wdsi_global.last_data_call_status = (qmi_wdsi_call_status) call_status;
  qmi_wdsi_global.last_data_call_type = data_call_type;
  qmi_wdsi_global.last_data_call_addr_family =  addr_family;

  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }

      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp) &&
            TRUE == cl_sp->report_status.report_data_call_status_change &&
            qmi_wdsi_verify_client_subs(cl_sp, subs_id, TRUE))
        {
          LOG_MSG_INFO2_2("Sending call status Client %d  (wds_sp) %x",
                          cl_sp->common.clid, wds_sp);

          qmi_wdsi_event_report_ind(wds_sp,
                                      cl_sp->common.clid,
                                      WDSI_REPORT_STATUS_DATA_CALL_STATUS,
                                      0,
                                      0,
                                      NULL,
                                      QMI_WDS_BEARER_TECH_UNKNOWN,
                                      0,
                                      (qmi_wds_dormancy_status_e_type) 0,
                                      NULL,
                                      0,
                                      (qmi_wdsi_call_status) call_status,
                                      data_call_type,                                      
                                      addr_family,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);
        }
        cl_sp = cl_sp->next;
      } /* while */
    }
  }
} /* qmi_wdsi_process_data_call_status_change */

/*===========================================================================
FUNCTION  QMI_WDSI_GET_UM_STAT_IFACE

DESCRIPTION
  This function gets the um iface

PARAMETERS
new_pref_network - send the value to qmi

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
static ps_iface_type * qmi_wdsi_get_um_stat_iface
(
  ps_iface_type * rm_iface_ptr
)
{
  ps_iface_type * bridged_iface_ptr;
  bridged_iface_ptr = ps_iface_bridge_iface(rm_iface_ptr);
  if (bridged_iface_ptr == NULL)
  {
    LOG_MSG_ERROR_0("Iface is not bridged while trying to get stats, stats may not be valid");
    return rm_iface_ptr;
  }

  return bridged_iface_ptr;

  /* see if there is associated iface, if so we need to return the physical iface
  if (PS_IFACE_GET_ASSOC_IFACE(bridged_iface_ptr) != NULL)
  {
    return PS_IFACE_GET_ASSOC_IFACE(bridged_iface_ptr);
  }
  else
  {
    return bridged_iface_ptr;
  }
  */
} /* qmi_wdsi_get_um_stat_iface */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_DUN_DATA_COUNT()

  DESCRIPTION
    Retrieves the data count (TX/RX byte statistics) of the current DUN
    call if it is up; if not, returns the last DUN call's data count.

  PARAMETERS
    data_count - pointer to location to store data count

  RETURN VALUE
    TRUE on success, FALSE on failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_wdsi_get_dun_data_count
(
  qmi_wdsi_data_byte_count_type * data_count
)
{
  boolean success = FALSE;
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
  sint15 ps_errno;
  ps_iface_ioctl_data_count_type dun_data_count;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (data_count != NULL)
  {
    if (qmi_wdsi_global.modem_dun_um_iface_ptr != NULL &&
        qmi_wdsi_global.dun_state == QMI_WDS_CONN_CONNECTED)
    {
      memset(data_count, 0, sizeof(qmi_wdsi_data_byte_count_type));

      switch (qmi_wdsi_global.modem_dun_last_data_bearer)
      {
#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
        case QMI_WDS_BEARER_TECH_CDMA20001x:
        case QMI_WDS_BEARER_TECH_CDMA_EVDO_REV0:
        case QMI_WDS_BEARER_TECH_CDMA_EVDO_REVA:
        case QMI_WDS_BEARER_TECH_CDMA_EVDO_EHRPD:
          memset(&dun_data_count, 0, sizeof(ps_iface_ioctl_data_count_type));
          if (ps_iface_ioctl(qmi_wdsi_global.modem_dun_um_iface_ptr,
                             PS_IFACE_IOCTL_707_GET_DATA_COUNT,
                             &dun_data_count,
                             &ps_errno) != 0)
          {
            LOG_MSG_ERROR_1("Couldn't get 3GPP2 data count. IOCTL gave errno %d",
                            ps_errno);
          }
          else
          {
            data_count->txed_bytes = dun_data_count.txed_bytes;
            data_count->rxed_bytes = dun_data_count.rxed_bytes;
            success = TRUE;
          }
          break;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

#if defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)
        case QMI_WDS_BEARER_TECH_GPRS:
        case QMI_WDS_BEARER_TECH_UMTS:
        case QMI_WDS_BEARER_TECH_EDGE:
        case QMI_WDS_BEARER_TECH_HSDPA_WCDMA:
        case QMI_WDS_BEARER_TECH_WCDMA_HSUPA:
        case QMI_WDS_BEARER_TECH_HSDPA_HSUPA:
        case QMI_WDS_BEARER_TECH_LTE:
        case QMI_WDS_BEARER_TECH_HSDPAPLUS_WCDMA:
        case QMI_WDS_BEARER_TECH_HSDPAPLUS_HSUPA:
        case QMI_WDS_BEARER_TECH_DCHSDPAPLUS_WCDMA:
        case QMI_WDS_BEARER_TECH_DCHSDPAPLUS_HSUPA:
        case QMI_WDS_BEARER_TECH_HSDPAPLUS_64QAM:
        case QMI_WDS_BEARER_TECH_HSDPAPLUS_64QAM_HSUPA:
        case QMI_WDS_BEARER_TECH_TDSCDMA:
        case QMI_WDS_BEARER_TECH_TDSCDMA_HSDPA:

          if ((E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_BYTES_RX, 
                  qmi_wdsi_global.modem_dun_um_iface_ptr,
                  &data_count->rxed_bytes, 8))
            ||(E_SUCCESS != ps_stat_get_iface(PS_STAT_IFACE_BYTES_TX, 
                  qmi_wdsi_global.modem_dun_um_iface_ptr, 
                  &data_count->txed_bytes, 8)))
          {
            LOG_MSG_ERROR_0("Couldn't get 3GPP data count");
          }
          else
          {
            success = TRUE;
          }
          break;
#endif /* defined(FEATURE_GSM) || defined(FEATURE_WCDMA) || defined(FEATURE_LTE) || defined(FEATURE_TDSCDMA)*/

        default:
          LOG_MSG_ERROR_1("Can't get data count for unsupported data bearer %d",
                          qmi_wdsi_global.modem_dun_last_data_bearer);
      }

      if (success)
      {
        LOG_MSG_INFO2_3("Got byte stats for active data bearer %d: tx %ld rx %ld",
                        qmi_wdsi_global.modem_dun_last_data_bearer,
                        data_count->txed_bytes,
                        data_count->rxed_bytes);
      }
    }
    else
    {
      success = TRUE;
      *data_count = qmi_wdsi_global.modem_dun_last_call_data_count;
      LOG_MSG_INFO2_2("Using last call data count: tx %ld rx %ld",
                      data_count->txed_bytes, data_count->rxed_bytes);
    }
  }
  return success;
} /* qmi_wdsi_get_dun_data_count() */

/*===========================================================================
  FUNCTION QMI_WDSI_PROCESS_CMD()

  DESCRIPTION
    This function processes a QMI WDS command or event.

    It is called by the QMI command handler and will dispatch the
    associated command/event handler function.

  PARAMETERS
    cmd_ptr:  private data buffer containing the QMI WDS command
              information.

  RETURN VALUE
    None

  DEPENDENCIES
    QMI WDS must already have been initialized

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_process_cmd
(
  void *cmd_ptr
)
{
  qmi_wdsi_cmd_buf_type *cmd_buf_ptr = NULL;
/*-------------------------------------------------------------------------*/

  ASSERT(cmd_ptr);
  cmd_buf_ptr = (qmi_wdsi_cmd_buf_type *)cmd_ptr;

  switch(cmd_buf_ptr->cmd_id)
  {
    case QMI_CMD_WDS_INIT_CB:
      qmi_wdsi_process_svc_init(cmd_buf_ptr->data.init_cb.num_instances);
      break;

    case QMI_CMD_WDS_ALLOC_CLID_CB:
      qmi_wdsi_process_alloc_clid(&cmd_buf_ptr->data.clid_cb.common_msg_hdr);
      break;

    case QMI_CMD_WDS_DEALLOC_CLID_CB:
      qmi_wdsi_process_dealloc_clid(&cmd_buf_ptr->data.clid_cb.common_msg_hdr);
      break;

    case QMI_CMD_WDS_CMD_HDLR_CB:
      qmi_wdsi_process_cmd_hdlr(&cmd_buf_ptr->data.cmd_hdlr_cb.msg_hdr,
                                    cmd_buf_ptr->data.cmd_hdlr_cb.sdu_in);
      break;

    case QMI_CMD_SEND_PKT_STATS:
      qmi_wdsi_generate_pkt_stats_ind(cmd_buf_ptr->data.send_pkt_stats.clid);
      break;

    case QMI_CMD_SEND_DUN_PKT_STATS:
      qmi_wdsi_generate_dun_pkt_stats_ind(cmd_buf_ptr->data.send_pkt_stats.clid);
      break;

    case QMI_CMD_PROCESS_WDS_UM_IFACE_EVT:
      qmi_wdsi_process_um_iface_event(cmd_buf_ptr->data.iface_info.iface_ptr,
                                      cmd_buf_ptr->data.iface_info.event,
                                      cmd_buf_ptr->data.iface_info.event_info,
                                      cmd_buf_ptr->data.iface_info.wds_sp);
      break;

    case QMI_CMD_PROCESS_PHYS_LINK_EVT:
      qmi_wdsi_process_phys_link_event(
                           cmd_buf_ptr->data.phys_link_status.phys_link_ptr,
                           cmd_buf_ptr->data.phys_link_status.event,
                           cmd_buf_ptr->data.phys_link_status.event_info,
                           cmd_buf_ptr->data.phys_link_status.user_data_ptr);
      break;

    case QMI_CMD_PROCESS_DUN_PHYS_LINK_EVT:
      qmi_wdsi_process_dun_phys_link_event(
                           cmd_buf_ptr->data.phys_link_status.phys_link_ptr,
                           cmd_buf_ptr->data.phys_link_status.event,
                           cmd_buf_ptr->data.phys_link_status.event_info,
                           cmd_buf_ptr->data.phys_link_status.user_data_ptr);
      break;

    case QMI_CMD_PROCESS_DUN_CALL_INFO_EVT:
      qmi_wdsi_generate_dun_call_info_ind(
                           cmd_buf_ptr->data.dun_call_info.event,
                           cmd_buf_ptr->data.dun_call_info.iface_ptr,
                           cmd_buf_ptr->data.dun_call_info.event_info,
                           cmd_buf_ptr->data.dun_call_info.iface_name);
      break;

   case QMI_CMD_PROCESS_DATA_CALL_STATUS_EVT:
      /*
      qmi_wdsi_process_data_call_status_change(
                                  cmd_buf_ptr->data.data_call_status.status,
       (qmi_wdsi_data_call_e_type)cmd_buf_ptr->data.data_call_status.call_type);
      */ 
      break;

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
    case QMI_CMD_PROCESS_CALL_THROTTLE_CB:
      qmi_wdsi_call_throttle_info_request_complete(
                      cmd_buf_ptr->data.call_throttle_info.throttled_delay,
                      cmd_buf_ptr->data.call_throttle_info.ps_errno);
      break;
    case QMI_CMD_PROCESS_EVDO_PMP_CHANGE_EVT:
      qmi_wdsi_generate_evdo_pmp_change_ind(
        cmd_buf_ptr->data.epmp,
        cmd_buf_ptr->subscription_id);
      break;
    case QMI_CMD_PROCESS_SET_EVDO_PMP_CB:
      qmi_wdsi_generate_evdo_pmp_result_ind(
        cmd_buf_ptr->data.set_evdo_pmp_info.evt,
        cmd_buf_ptr->data.set_evdo_pmp_info.failure_code );
      break;
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

    case QMI_CMD_PROCESS_DUN_RMSM_EVENT:
      qmi_wdsi_process_dun_rmsm_event(
        cmd_buf_ptr->data.dun_ctrl_event_info.event_type,
        cmd_buf_ptr->data.dun_ctrl_event_info.call_allowed,
        cmd_buf_ptr->data.dun_ctrl_event_info.tech_type,
        cmd_buf_ptr->data.dun_ctrl_event_info.cb_data,
        cmd_buf_ptr->data.dun_ctrl_event_info.net_down_reason,
        cmd_buf_ptr->subscription_id);
      break;

    case QMI_CMD_WDS_DATA_SYSTEM_STATUS_CHANGE_EVT:
      qmi_wdsi_generate_data_system_status_ind
      (
        cmd_buf_ptr->data.data_system_status,
        cmd_buf_ptr->subscription_id
      );
      break;

    case QMI_CMD_SEND_FLOW_CTRL:
      qmi_wdsi_process_flow_ctrl_event(
          cmd_buf_ptr->data.flow_ctrl.ep_id,
          cmd_buf_ptr->data.flow_ctrl.mux_id,
          cmd_buf_ptr->data.flow_ctrl.is_v6,
          cmd_buf_ptr->data.flow_ctrl.uplink_flow_ctrl,
          FALSE);
      break;

     case QMI_CMD_PROCESS_WLAN_IFACE_EVT:
       qmi_wdsi_process_wlan_iface_evt(
              cmd_buf_ptr->data.wlan_evt_info.event,
              cmd_buf_ptr->data.wlan_evt_info.iface_ptr,
              cmd_buf_ptr->data.wlan_evt_info.event_info,
              cmd_buf_ptr->data.wlan_evt_info.wds_sp);
       break;

#ifdef FEATURE_DATA_LTE
    case QMI_CMD_WDS_LTE_ATTACH_PDN_LIST_CHANGE_EVT:
       qmi_wdsi_generate_lte_attach_pdn_list_change_ind
       (
         cmd_buf_ptr->data.lte_attach_pdn_list,
         cmd_buf_ptr->subscription_id
       );
    break;
#endif /* FEATURE_DATA_LTE */

    case QMI_CMD_WDS_PROFILE_CHANGED_EVT:
      wdsi_process_profile_changed_event(
         cmd_buf_ptr->data.profile_evt_info.event,
         cmd_buf_ptr->data.profile_evt_info.profile_count,
         cmd_buf_ptr->data.profile_evt_info.profiles_changes,
         cmd_buf_ptr->subscription_id);
      break;
     case QMI_CMD_WDS_THRPT_INFO_EVT:
       qmi_wdsi_generate_thrpt_info_change_ind
       (
          cmd_buf_ptr->data.thrpt_info_list,
          cmd_buf_ptr->subscription_id
       );
    break;

     case QMI_CMD_WDS_ROAMING_INFO_EVT:
      qmi_wdsi_generate_roaming_info_change_ind
    (
       cmd_buf_ptr->data.roaming_info_list,
       cmd_buf_ptr->subscription_id
    );
    break;
    case QMI_CMD_WDS_GEN_REV_IP_CONNECTED_IND:
    qmi_wdsi_generate_rev_ip_connected_ind
    (
       cmd_buf_ptr->data.rev_ip_conn_info.cl_sp
    );
    break;

     case QMI_CMD_WDS_OUTAGE_NOTIFICATION_EVT:
       qmi_wdsi_generate_outage_notifcation_ind
       (
         cmd_buf_ptr->data.outage_info,
         cmd_buf_ptr->subscription_id
       );
       break;

    case QMI_CMD_WDS_DL_THRPT_INFO_EVT:
      qmi_wdsi_generate_dl_thrpt_info_change_ind
      (
         cmd_buf_ptr->data.dl_thrpt_info,
         cmd_buf_ptr->subscription_id
      );
    break;
    default:
      LOG_MSG_ERROR_1("Unexpected cmd(%d) recd in QMI WDS cmd handler",
                      cmd_buf_ptr->cmd_id);
      ASSERT(0);
  }/* switch(cmd_buf_ptr->cmd_id) */

  qmi_wdsi_free_cmd_buf(cmd_ptr);
  return;
} /* qmi_wdsi_process_cmd() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_CMD_BUF()

  DESCRIPTION
    Allocate and assign a QMI WDS command buffer from the PS MEM heap
    based on the QMI CMD type

  PARAMETERS
    cmd_id - QMI command type

  RETURN VALUE
    cmd_buf_ptr - Pointer to the allocated command buffer

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void *qmi_wdsi_get_cmd_buf
(
  qmi_cmd_id_e_type cmd_id
)
{
  void *cmd_buf_ptr;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  LOG_MSG_INFO1_1("wdsi_get_cmd_buf cmd_id = %d",cmd_id);
  PS_SYSTEM_HEAP_MEM_ALLOC(cmd_buf_ptr, sizeof(qmi_wdsi_cmd_buf_type),
                           qmi_wdsi_cmd_buf_type*);
  return cmd_buf_ptr;

} /* qmi_wdsi_get_cmd_buf */

/*===========================================================================
  FUNCTION QMI_WDSI_VALIDATE_IP_FAMILY_PREF()

  DESCRIPTION
    Validate the IP family preferences

  PARAMETERS
    ip_family_pref - IP pref

  RETURN VALUE
    QMI_ERR_NONE_v01: If valid IP preference.
    QMI_ERR_INVALID_IP_FAMILY_PREF_v01: If invalid IP preference.

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static qmi_error_type_v01 qmi_wdsi_validate_ip_family_pref
(
  uint8  ip_family_pref
)
{
  switch (ip_family_pref)
  {
    case QMI_AF_INET:         /* IPv4        */
    case QMI_AF_INET6:        /* IPv6        */
    case QMI_AF_UNSPEC:       /* UNSPECIFIED */
      return QMI_ERR_NONE_V01;

    default:
      LOG_MSG_INFO2_1("Invalid value of IP family preference:%d ",
                      ip_family_pref);
      return QMI_ERR_INVALID_IP_FAMILY_PREF_V01;
  }
} /* qmi_wdsi_validate_ip_family_pref */

/*===========================================================================
FUNCTION  QMI_WDSI_GET_RMNET_DATA_CALL_TYPE

DESCRIPTION
  This function returns the data call type for RmNet Calls

PARAMETERS
  um_iface_ptr : The um iface ptr for which the proc_id is sought
  iface_up     : Flag indicating whether the said iface is UP now

DEPENDENCIES
  None.

RETURN VALUE
  call_type : embedded RmNet, tethered RmNet or NONE.

SIDE EFFECTS
  None.

===========================================================================*/
static void qmi_wdsi_get_rmnet_data_call_type
(
  qmi_wdsi_data_call_e_type *data_call_type,
  rmnet_instance_e_type rmnet_inst
)
{
  rmnet_meta_sm_proc_id_e_type proc_id = RMNET_PROC_ID_MAX;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (data_call_type == NULL)
  {
    LOG_MSG_ERROR_0("NULL data_call_type address");
    return;
  }

  *data_call_type = WDSI_DATA_CALL_NONE;
  if (rmnet_meta_sm_get_proc_id_from_inst(&proc_id, rmnet_inst) != TRUE)
  {
    LOG_MSG_ERROR_1("Can't get prod_id for rmnet inst [%d]", rmnet_inst);
    return;
  }

  switch(proc_id)
  {
    case RMNET_PROC_ID_APPS1:
    {
      *data_call_type = WDSI_DATA_CALL_EMBEDDED;
      break;
    }

    case RMNET_PROC_ID_LAPTOP1:
    {
      *data_call_type = WDSI_DATA_CALL_TETHERED_RMNET;
      break;
    }

    default:
    {
      LOG_MSG_INFO2_1( "Unknown proc_id [%d]", proc_id);
      return;
    }
  }

  LOG_MSG_INFO3_3("rmnet inst [%d] proc_id [%d] data_call_type [%d]",
                  rmnet_inst, proc_id, *data_call_type);

  return;
} /* qmi_wdsi_get_rmnet_data_call_type() */

/*===========================================================================
  FUNCTION QMI_WDSI_ENTITLEMENT_CB()

  DESCRIPTION
    Entitlement callback registered with UMTS RMSM

  PARAMETERS
    tech_type:      Technology type is 3GPP / 3GPP2
    event_name :    Event name, eg Silent Redial or Dun Call
    subs_id: Subscription identifier
    event_info_ptr: Event related info
    user_data_ptr:  User call back pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_entitlement_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr;
  ps_sys_event_dun_ctrl_entitlement_check_info_type event_info;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  cmd_ptr = NULL;
  event_info = * (ps_sys_event_dun_ctrl_entitlement_check_info_type *)event_info_ptr;

  LOG_MSG_INFO1_1("qmi_wdsi_entitlement_cb for tech 0x%x", tech_type);

  /* This callback is run in the DS context. Post a command to QMI. */
  cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_DUN_RMSM_EVENT);
  if (cmd_ptr == NULL)
  {
    return;
  }
  
  cmd_ptr->cmd_id = QMI_CMD_PROCESS_DUN_RMSM_EVENT;
  cmd_ptr->data.dun_ctrl_event_info.event_type =
                                              WDSI_DUN_CTRL_EVENT_ENTITLEMENT;
  cmd_ptr->data.dun_ctrl_event_info.tech_type = event_info.tech_type;
  cmd_ptr->data.dun_ctrl_event_info.call_allowed= 0;
  cmd_ptr->data.dun_ctrl_event_info.cb_data = event_info.cb_data;
  cmd_ptr->data.dun_ctrl_event_info.net_down_reason = 
                                             PS_NET_DOWN_REASON_NOT_SPECIFIED;
  cmd_ptr->subscription_id = subscription_id;
  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
  return;
} /* qmi_wdsi_entitlement_cb() */

/*===========================================================================
  FUNCTION QMI_WDSI_SILENT_REDIAL_CB()

  DESCRIPTION
    Silent redial callback registered with UMTS RMSM

  PARAMETERS
    tech_type:      Technology type is 3GPP / 3GPP2
    event_name :    Event name, eg Silent Redial or Dun Call
    subs_id: Subscription identifier
    event_info_ptr: Event related info
    user_data_ptr:  User call back pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_silent_redial_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr;
  ps_sys_event_dun_ctrl_silent_redial_check_info_type event_info;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmd_ptr = NULL;
  event_info = * (ps_sys_event_dun_ctrl_silent_redial_check_info_type *)event_info_ptr;
  /* This callback is run in the DS context. Post a command to QMI. */
  LOG_MSG_INFO1_1("qmi_wdsi_silent_redial_cb for tech 0x%x", tech_type);

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_DUN_RMSM_EVENT);
  if( cmd_ptr == NULL)
  {
    return;
  }
  
  cmd_ptr->cmd_id                           = QMI_CMD_PROCESS_DUN_RMSM_EVENT;
  cmd_ptr->data.dun_ctrl_event_info.event_type      =
                                           WDSI_DUN_CTRL_EVENT_SILENT_REDIAL;
  cmd_ptr->data.dun_ctrl_event_info.tech_type = event_info.tech_type;
  cmd_ptr->data.dun_ctrl_event_info.call_allowed= 0;
  cmd_ptr->data.dun_ctrl_event_info.cb_data = event_info.cb_data;
  cmd_ptr->data.dun_ctrl_event_info.net_down_reason = event_info.net_down_reason;
  cmd_ptr->subscription_id = subscription_id;

  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);

  return;
} /* qmi_wdsi_silent_redial_cb() */

/*===========================================================================
  FUNCTION QMI_WDSI_PROCESS_DUN_RMSM_EVENT()

  DESCRIPTION
    Event handler for entitlement and silent redial events received from
    DUN RMSM

  PARAMETERS
    event_type           Specifies event is DUN Entitlement or Silent Redial
    call_allowed         Boolean to specify if dun call / silent redial is allowed
    tech_type            Tech type specifies Mode handler type - 3GPP / 3GPP2
    cb_data              Info stored by 3GPP
    net_down_reason      Call failure reason [significant in silent redial]

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_process_dun_rmsm_event
(
  qmi_wdsi_dun_ctrl_event_e_type event_type,
  boolean                        call_allowed,
  ps_sys_tech_enum_type          tech_type,
  unsigned char                  cb_data,
  ps_iface_net_down_reason_type  net_down_reason,
  uint32                         subscription_id
)
{
  qmi_wdsi_state_type        *wds_sp;
  qmi_wdsi_client_state_type *cl_sp;
  boolean                     send_indication;
  boolean                     allow_call;
  boolean                     dun_call_processed;
  static uint8                call_id = 0;
  int16                       retval =0, pserr = 0;
  ps_sys_ioctl_dun_ctrl_response_type  dun_sr_response;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT( (event_type > WDSI_DUN_CTRL_EVENT_INVALID) &&
          (event_type < WDSI_DUN_CTRL_EVENT_MAX) );

  cl_sp                 = NULL;
  wds_sp                = NULL;
  send_indication       = TRUE;
  dun_call_processed    = FALSE;

  allow_call = (WDSI_DUN_CTRL_EVENT_SILENT_REDIAL == event_type)? FALSE: TRUE;

  LOG_MSG_INFO1_1("Processing DUN RMSM event of type %d", event_type);

  if (WDSI_DUN_CTRL_EVENT_TIMER_EXPIRY == event_type)
  /* If we are processing a DUN call control timer expiry, we just need to
   * cleanup and get out of here. */
  {
    qmi_wdsi_dun_ctrl_call_cleanup(subscription_id);
    return;
  }

  if (WDSI_DUN_CTRL_EVENT_CALL_PROCESSED == event_type)
  /* If we aren't processing an entitlement or silent redial event,
   * we might as well proceed to sending the indication. */
  {
    send_indication = FALSE;
    dun_call_processed = TRUE;
  }
  else if (FALSE == qmi_wdsi_global.dun_ctrl_info.is_active)
  /* Check if there is an active client handling DUN control.
   * If not, allow the DUN call. */
  {
    LOG_MSG_INFO1_0("No client registered for entitlement!");
    send_indication = FALSE;
  }
  else if (TRUE == qmi_wdsi_global.dun_ctrl_info.call_info.is_valid)
  {
    LOG_MSG_INFO1_1("Received duplicate indication for event %d", event_type);
    send_indication = FALSE;
  }
  else
  {
    if (FALSE == qmi_wdsi_global.dun_ctrl_info.report_status.report_entitlement_event)
    /* Check if the controlling client seeks entitlement indications.
     * If not, take allow the DUN call. */
    {
      send_indication = FALSE;
    }
    else if ( (event_type == WDSI_DUN_CTRL_EVENT_SILENT_REDIAL) &&
              (FALSE == qmi_wdsi_global.dun_ctrl_info.report_status.report_silent_redial_event) )
    {
      send_indication = FALSE;
    }
  }

  if (TRUE == send_indication)
  /* If we need to send an indication to the controlling control point,
   * go ahead and do it. */
  {
    cl_sp  = qmi_wdsi_global.dun_ctrl_info.ctrl_cl_sp;
    ASSERT(cl_sp);

    wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);
    ASSERT(wds_sp);

    allow_call = qmi_wdsi_global.dun_ctrl_info.allow_dun_call;

    call_id++;
    qmi_wdsi_global.dun_ctrl_info.call_info.event_type  = event_type;
    qmi_wdsi_global.dun_ctrl_info.call_info.net_down_reason
                                                        = net_down_reason;
    qmi_wdsi_global.dun_ctrl_info.call_info.cb_data     = cb_data;
    qmi_wdsi_global.dun_ctrl_info.call_info.tech_type   = tech_type;
    qmi_wdsi_global.dun_ctrl_info.call_info.is_valid    = TRUE;

    qmi_wdsi_global.dun_ctrl_info.pending_call_id       = call_id;

    qmi_wdsi_generate_dun_ctrl_ind(wds_sp,cl_sp,event_type,allow_call);
  }
  /* If we don't need to send an indication, just let RMSM know and bail out. */
  else if (event_type == WDSI_DUN_CTRL_EVENT_ENTITLEMENT || 
           event_type == WDSI_DUN_CTRL_EVENT_SILENT_REDIAL)
  {
    if (event_type == WDSI_DUN_CTRL_EVENT_ENTITLEMENT)
    {
     /*For entitlement use cached client pref.
       For SilentRedail default value is False */
      allow_call = qmi_wdsi_global.dun_ctrl_info.allow_dun_call;
    }
    LOG_MSG_INFO1_1("Taking default DUN action (%d) for entitlement or silentRedail",allow_call);
    dun_sr_response.cb_data = cb_data;
    dun_sr_response.allow_call = allow_call;
    retval = ps_sys_ioctl_ex(tech_type,
                             PS_SYS_IOCTL_DUN_CTRL_RESPONSE,
                             subscription_id,
                             (void*)&dun_sr_response,&pserr);
    if(retval != 0)
    {
      LOG_MSG_INFO1_2("DUN ENTITLEMENT RESPONSE NOT SENT %d ps_err %d",
                      retval, pserr);
    }
    else
    {
      dun_call_processed = TRUE;
    }
  }

  if (dun_call_processed)
  {
    qmi_wdsi_dun_ctrl_call_complete_ind(allow_call,
                                        subscription_id);
  }
} /* qmi_wdsi_process_dun_rmsm_event() */

/*===========================================================================
  FUNCTION QMI_WDSI_DUN_CTRL_CALL_COMPLETE_IND()

  DESCRIPTION
    Sends out a DUN control indication to client(s)

  PARAMETERS
    event_type : event for which the indication needs to be sent
    call_allowed: Whether the call was allowed or denied

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_dun_ctrl_call_complete_ind
(
  boolean call_allowed,
  uint32  subscription_id
)
{
  uint8                       state;
  uint8                       inst;
  qmi_wdsi_state_type        *wds_sp;
  qmi_wdsi_client_state_type *cl_sp;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = NULL;
  cl_sp  = NULL;

  LOG_MSG_INFO2_1("DUN call processed: %d", call_allowed);

  /* Search for clients that had registered for DUN control indications. */
  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }
  
      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if ( TRUE == cl_sp->report_status.report_dun_call_processed &&
             qmi_wdsi_verify_client_subs(cl_sp, subscription_id, TRUE) )
        {
          /* Send out the indication to the clients as necessary. */
          qmi_wdsi_generate_dun_ctrl_ind(wds_sp,
                                         cl_sp,
                                         WDSI_DUN_CTRL_EVENT_CALL_PROCESSED,
                                         call_allowed);
        }
        cl_sp = cl_sp->next;
      }
    }
  }
} /* qmi_wdsi_dun_ctrl_call_complete_ind() */

/*===========================================================================
  FUNCTION QMI_WDSI_DUN_CTRL_IND()

  DESCRIPTION
    Generates and sends out a DUN control indication to client(s)

  PARAMETERS
    wds_sp      : WDS state pointer
    cl_sp       : Client state pointer
    event_type  : event for which the indication needs to be sent
    call_allowed: Whether the call was allowed or denied

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_generate_dun_ctrl_ind
(
  qmi_wdsi_state_type            *wds_sp,
  qmi_wdsi_client_state_type     *cl_sp,
  qmi_wdsi_dun_ctrl_event_e_type  event_type,
  boolean                         call_allowed
)
{
  uint8                       cl_id;
  uint8                       pending_call_id;
  wds_dun_ctrl_event_report_ind_msg_v01 indication;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT( wds_sp && cl_sp &&
         (event_type > WDSI_DUN_CTRL_EVENT_INVALID) &&
          (event_type < WDSI_DUN_CTRL_EVENT_TIMER_EXPIRY) );

  memset(&indication,0,sizeof(wds_dun_ctrl_event_report_ind_msg_v01));
  cl_id    = cl_sp->common.clid;
  pending_call_id = qmi_wdsi_global.dun_ctrl_info.pending_call_id;

  ASSERT((cl_id != QMI_SVC_CLID_UNUSED) && (cl_id != QMI_SVC_CLID_BROADCAST));

  switch (event_type)
  {
    case WDSI_DUN_CTRL_EVENT_CALL_PROCESSED:
      qmi_wdsi_global.dun_ctrl_info.pending_call_id = 0;
      indication.dun_call_notification_valid = TRUE;
      indication.dun_call_notification = (wds_dun_allow_pref_enum_v01)call_allowed;
      break;

    case WDSI_DUN_CTRL_EVENT_SILENT_REDIAL:
      indication.previous_dun_failure_reason_valid = TRUE;
      indication.previous_dun_failure_reason.call_end_reason = 
        (uint16)(0x0000FFFF & qmi_wdsi_global.dun_ctrl_info.call_info.net_down_reason);
      indication.previous_dun_failure_reason.call_end_reason_type = 
	  	(uint16)(qmi_wdsi_global.dun_ctrl_info.call_info.net_down_reason >> 16);
      /* This fall-through is intentional. We need to arm the timer in
       * case of silent redial as well. */
    case WDSI_DUN_CTRL_EVENT_ENTITLEMENT:
      (void) timer_set( &(qmi_wdsi_global.dun_call_control_timer),
                        WDSI_DUN_CALL_CONTROL_WAIT_PERIOD, 0, T_SEC );
      break;

    default:
      LOG_MSG_INFO1_1("Ignoring trigger for unexpected DUN ctrl indication: %d",
                      event_type);
      return;
  }

  LOG_MSG_INFO2_2( "Generating indication of type %d with call_id %d",
                   event_type, pending_call_id );
  indication.dun_call_id_valid = TRUE;
  indication.dun_call_id       = pending_call_id;
  indication.dun_ctrl_event    = (wds_dun_ctrl_event_enum_v01)event_type;
  if (FALSE == qmi_wdsi_send_ind(wds_sp,
                                cl_sp,
                                QMI_WDS_DUN_CTRL_EVENT_REPORT_IND_V01,
                                sizeof(wds_dun_ctrl_event_report_ind_msg_v01),
                                &indication,TRUE))
  {
    LOG_MSG_INFO2_0 ("Unable to send DUN control indication");
  }
  else
  {
    LOG_MSG_INFO2_0 ("Sent DUN control indication");
  }
} /* qmi_wdsi_generate_dun_ctrl_ind() */

/*===========================================================================
  FUNCTION QMI_WDSI_INIT_DUN_CTRL_PREF_TO_DEFAULT()

  DESCRIPTION
    Resets the DUN control preference cache to defaults

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_init_dun_ctrl_pref_to_default
(
  void
)
{
  /* Clean up any pending DUN calls */
  qmi_wdsi_dun_ctrl_call_cleanup(PS_SYS_DEFAULT_SUBS);

  /* Clean up the cache to indicate that there is no controlling control
   * point. */
  memset((void*)&qmi_wdsi_global.dun_ctrl_info,
         0,
         sizeof(qmi_wdsi_global.dun_ctrl_info));

  /* Set the DUN call allow preference to TRUE for a good measure. */
  qmi_wdsi_global.dun_ctrl_info.allow_dun_call = TRUE;
} /* qmi_wdsi_init_dun_ctrl_pref_to_default */

/*===========================================================================
  FUNCTION QMI_WDSI_DUN_CTRL_CALL_CLEANUP()

  DESCRIPTION
    Cleans up DUN control call info from the cache

  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_dun_ctrl_call_cleanup
(
  uint32  subscription_id
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr;
  boolean                call_allowed;
  int16                  retval =0, pserr = 0;
  ps_sys_ioctl_dun_ctrl_response_type  dun_sr_response;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmd_ptr = NULL;
  call_allowed = FALSE;

  /* If there is an active data call, allow/deny it appropriately before
   * invalidating the cache. */
  if (qmi_wdsi_global.dun_ctrl_info.call_info.is_valid)
  {
    if (WDSI_DUN_CTRL_EVENT_ENTITLEMENT == 
                 qmi_wdsi_global.dun_ctrl_info.call_info.event_type
        || WDSI_DUN_CTRL_EVENT_SILENT_REDIAL ==
                 qmi_wdsi_global.dun_ctrl_info.call_info.event_type)
    {
      dun_sr_response.cb_data = qmi_wdsi_global.dun_ctrl_info.call_info.cb_data;
      dun_sr_response.allow_call = qmi_wdsi_global.dun_ctrl_info.allow_dun_call;
      retval = ps_sys_ioctl_ex(qmi_wdsi_global.dun_ctrl_info.call_info.tech_type,
                               PS_SYS_IOCTL_DUN_CTRL_RESPONSE,
                               subscription_id,(void*)&dun_sr_response,&pserr);
      if(retval != 0)
      {
        LOG_MSG_INFO1_2("DUN ENTITLEMENT RESPONSE NOT SENT %d ps err %d",
                        retval, pserr);
      }
      
      call_allowed = qmi_wdsi_global.dun_ctrl_info.allow_dun_call;
    }
 
    /* Post a command to QMI to send out an indication to other clients. */
    cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_DUN_RMSM_EVENT);
    if( cmd_ptr != NULL)
    {
      cmd_ptr->cmd_id                        = QMI_CMD_PROCESS_DUN_RMSM_EVENT;
      cmd_ptr->data.dun_ctrl_event_info.event_type  =
                                           WDSI_DUN_CTRL_EVENT_CALL_PROCESSED;
      cmd_ptr->data.dun_ctrl_event_info.call_allowed = call_allowed;
      cmd_ptr->subscription_id = subscription_id;
      dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
    }
  }

  /* Clear the DUN call control timer for a good measure. */
  (void) timer_clr( &(qmi_wdsi_global.dun_call_control_timer), T_NONE );

  /* Invalidate the call control cache. */
  memset(&qmi_wdsi_global.dun_ctrl_info.call_info,0,
         sizeof(qmi_wdsi_global.dun_ctrl_info.call_info));
} /* qmi_wdsi_dun_ctrl_call_cleanup() */

/*===========================================================================
  FUNCTION QMI_WDSI_DUN_CALL_CONTROL_TIMER_CB()

  DESCRIPTION
    Resets the DUN call control timer after processing the pending DUN call

  PARAMETERS
    user_data: user data pointer set as part of timer_def

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_dun_call_control_timer_cb
(
  timer_cb_data_type user_data
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cmd_ptr = NULL;

  LOG_MSG_INFO1_0("DUN call control timer has expired");

  /* The DUN call control timer has expired. Clean up the existing DUN call
   * as required. */
  cmd_ptr = (qmi_wdsi_cmd_buf_type *)qmi_wdsi_get_cmd_buf(QMI_CMD_PROCESS_DUN_RMSM_EVENT);
  if( cmd_ptr != NULL)
  {
    cmd_ptr->cmd_id                        = QMI_CMD_PROCESS_DUN_RMSM_EVENT;
    cmd_ptr->data.dun_ctrl_event_info.event_type =
                                           WDSI_DUN_CTRL_EVENT_TIMER_EXPIRY;
    cmd_ptr->subscription_id = ps_sys_get_default_data_subscription();
    dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
  }
} /* qmi_wdsi_dun_call_control_timer_cb() */


#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
/*===========================================================================
  FUNCTION WDSI_XLATE_APP_SCM_TO_HDR_ENUM()

  DESCRIPTION
    Translates the application input slotted mode option to HDR appropriate
    enum.

  PARAMETERS
    app_scm   : Slotted Mode Option input by application
 
  RETURN VALUE
    hdrscmidle_sm_override_enum_type value

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint8  wdsi_xlate_app_scm_to_hdr_enum
(
  uint8            app_scm
)
{
  switch(app_scm)
  {
    case WDSI_EVDO_SLOT_CYCLE_213_MSECS:
      return 2;
    case WDSI_EVDO_SLOT_CYCLE_426_MSECS:
      return 1;
    case WDSI_EVDO_SLOT_CYCLE_1280_MSECS:
      return 3;
    case WDSI_EVDO_SLOT_CYCLE_DEFAULT:
      return 0;
    default:
      return 0;
  }
}
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

/*===========================================================================
  FUNCTION WDSI_XLATE_DATA_SYSTEM_STATUS_TO_PREF_DATA_SYS()

  DESCRIPTION
    Translates the Data system status to preferred data system value
 
  PARAMETERS
    preferred_network   : Current preferred network
    rat_mask            : RAT Mask for preferred network

  RETURN VALUE
    Preferred Data system

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static uint32 wdsi_xlate_data_system_status_to_pref_data_sys
(
  uint8            preferred_network,
  uint32           rat_mask
)
{
  uint32 pref_data_sys = (uint32)WDSI_SYSTEM_UNKNOWN;
  switch (preferred_network)
  {
    case PS_SYS_NETWORK_3GPP:
      if(rat_mask & PS_SYS_RAT_3GPP_GPRS)
      {
        pref_data_sys = (uint32)WDSI_SYSTEM_GPRS; 
      }
      else if(rat_mask & PS_SYS_RAT_3GPP_WCDMA)
      {
        pref_data_sys = (uint32)WDSI_SYSTEM_WCDMA; 
      }
      else if(rat_mask & PS_SYS_RAT_3GPP_LTE)
      {
        pref_data_sys = (uint32)WDSI_SYSTEM_LTE; 
      }
      else if(rat_mask & PS_SYS_RAT_3GPP_TDSCDMA)
      {
        pref_data_sys = (uint32)WDSI_SYSTEM_TDSCDMA; 
      }
      break;
    case PS_SYS_NETWORK_3GPP2:
      if(rat_mask & PS_SYS_RAT_3GPP2_1X)
      {
        pref_data_sys = (uint32)WDSI_SYSTEM_1X; 
      }
      else if((rat_mask & PS_SYS_RAT_3GPP2_EVDO_REV0) ||
              (rat_mask & PS_SYS_RAT_3GPP2_EVDO_REVA) ||
              (rat_mask & PS_SYS_RAT_3GPP2_EVDO_REVB)) 
      {
        pref_data_sys = (uint32)WDSI_SYSTEM_EVDO; 
      }
      break;
    default: 
      LOG_MSG_INFO2_1("Unknown preferred network %d", preferred_network);
  }
  return pref_data_sys;
} /* wdsi_xlate_data_system_status_to_pref_data_sys() */

#ifdef FEATURE_EPC_HANDOFF
/*===========================================================================
  FUNCTION WDSI_REG_IFACE_HANDOFF_EVENT()

  DESCRIPTION
    Function to register handoff events on UM iface

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_reg_iface_handoff_event
(
  qmi_wdsi_state_type *  wds_sp
)
{
    ps_iface_event_enum_type      err_ev = IFACE_EVENT_MAX;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

do{
  if (0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_HANDOFF_INIT_EV,
                                   wds_sp->um_iface_handoff_init_buf_ptr))
  {
      err_ev = IFACE_HANDOFF_INIT_EV;
      break;
  }

  if (0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_HANDOFF_STATUS_SUCCESS_EV,
                                   wds_sp->um_iface_handoff_success_buf_ptr))
  {
      err_ev = IFACE_HANDOFF_STATUS_SUCCESS_EV;
      break; 
  }

  if (0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_HANDOFF_STATUS_FAILURE_EV,
                                   wds_sp->um_iface_handoff_failure_buf_ptr))
  {
      err_ev = IFACE_HANDOFF_STATUS_FAILURE_EV;
      break; 
  }
}while(0);

  if(err_ev != IFACE_EVENT_MAX)
  {
    LOG_MSG_ERROR_1("Couldn't register for Handoff Iface event %d",err_ev);
    ASSERT(0);
    return;
  }

  LOG_MSG_INFO2_0("Handoff events registered");

} /* wdsi_reg_iface_handoff_event() */

/*===========================================================================
  FUNCTION WDSI_DEREG_IFACE_HANDOFF_EVENT()

  DESCRIPTION
    Function to de-register handoff events on UM iface

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_dereg_iface_handoff_event
(
  qmi_wdsi_state_type *  wds_sp
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_HANDOFF_INIT_EV,
                             wds_sp->um_iface_handoff_init_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_HANDOFF_STATUS_SUCCESS_EV,
                             wds_sp->um_iface_handoff_success_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_HANDOFF_STATUS_FAILURE_EV,
                             wds_sp->um_iface_handoff_failure_buf_ptr);

  LOG_MSG_INFO2_0("Handoff events deregistered");

} /* wdsi_dereg_iface_handoff_event() */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_HANDOFF_EV_IND()

DESCRIPTION
    Called when handoff events occur.
    Used to indicate information associated with the events

PARAMETERS
  wds_sp     : wds state pointer
  event      : handoff event
  event_info : handoff event info

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_handoff_ev_ind
(
  qmi_wdsi_state_type         * wds_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info
)
{
  qmi_wdsi_client_state_type * cl_sp = NULL;
  uint32                       handoff_info;
  wds_handoff_information_ind_msg_v01 indication;

  ASSERT (wds_sp);

  memset(&indication,0,sizeof(wds_handoff_information_ind_msg_v01));
  switch (event)
  {
    case IFACE_HANDOFF_INIT_EV:
      handoff_info = WDS_HANDOFF_INIT_V01;
      break;
    case IFACE_HANDOFF_STATUS_SUCCESS_EV:
      handoff_info = WDS_HANDOFF_SUCCESS_V01;
      break;
    case IFACE_HANDOFF_STATUS_FAILURE_EV:
      handoff_info = WDS_HANDOFF_FAILURE_V01;
      break;
    default:
      DATA_ERR_FATAL("Unhandled event!");
      return;
  }
  indication.handoff_information = (wds_handoff_information_type_enum_v01)handoff_info;

  if(handoff_info != WDS_HANDOFF_FAILURE_V01)
  {
    /* Include SRAT and TRAT info*/
    indication.handoff_event_info_valid = TRUE;
    indication.handoff_event_info.srat =
      (wds_bearer_tech_rat_ex_enum_v01)event_info.handoff_event_info.srat;
    indication.handoff_event_info.trat =
      (wds_bearer_tech_rat_ex_enum_v01)event_info.handoff_event_info.trat;
  }
  else
  {
    /* Include SRAT and TRAT info & failure code reason info in case of failure event*/
    indication.handoff_event_info_valid = TRUE;
    indication.handoff_event_info.srat =
      (wds_bearer_tech_rat_ex_enum_v01)event_info.handoff_failure_event_info.srat;
    indication.handoff_event_info.trat =
        (wds_bearer_tech_rat_ex_enum_v01)event_info.handoff_failure_event_info.trat;
    indication.handoff_failure_reason_valid = TRUE;
    indication.handoff_failure_reason.failure_reason_type = 
       (wds_verbose_call_end_reason_type_enum_v01)(event_info.handoff_failure_event_info.ho_failure_reason >> 16);
    indication.handoff_failure_reason.failure_reason = 
              (uint16)(0x0000FFFF&event_info.handoff_failure_event_info.ho_failure_reason);
  }

  /* Generate ind to all clients registered for the event  */
  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
    if ( (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp)) &&
         (cl_sp->report_status.report_handoff_information_change) &&
          qmi_wdsi_verify_client_subs(cl_sp, wds_sp->binding.subscription_id, TRUE) )
    {
      qmi_wdsi_send_ind(wds_sp, cl_sp, QMI_WDS_HANDOFF_INFORMATION_IND_V01,
                   sizeof(wds_handoff_information_ind_msg_v01),&indication,TRUE);
    }
    cl_sp = cl_sp->next;
  } /* while */
} /* qmi_wdsi_generate_handoff_ev_ind() */
#endif /* FEATURE_EPC_HANDOFF */

/*===========================================================================
  FUNCTION WDSI_REG_IFACE_EMBMS_EVENT()

  DESCRIPTION
    Function to register eMBMS events on UM iface

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_reg_iface_embms_event
(
  qmi_wdsi_state_type *  wds_sp
)
{
    ps_iface_event_enum_type      err_ev = IFACE_EVENT_MAX;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (wds_sp->reg_embms_iface_ev == TRUE)
  {
    LOG_MSG_INFO2_0("eMBMS events already registered");
    return;
  }

do
{
  if (0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_EMBMS_TMGI_ACTIVATED_EV,
                                   wds_sp->um_iface_embms_tmgi_activated_buf_ptr))
  {
      err_ev = IFACE_EMBMS_TMGI_ACTIVATED_EV;
      break;
  }

  if (0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_EMBMS_TMGI_DEACTIVATED_EV,
                                   wds_sp->um_iface_embms_tmgi_deactivated_buf_ptr))
  {
      err_ev = IFACE_EMBMS_TMGI_DEACTIVATED_EV;
      break;
  }

  if (0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_EMBMS_TMGI_ACTIVATE_DEACTIVATE_RESPONSE_EV,
                                   wds_sp->um_iface_embms_tmgi_act_deact_buf_ptr))
  {
      err_ev = IFACE_EMBMS_TMGI_ACTIVATE_DEACTIVATE_RESPONSE_EV;
      break;
  }

  if (0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_EMBMS_ACTIVE_TMGI_LIST_EV,
                                   wds_sp->um_iface_embms_active_tmgi_list_buf_ptr))
  {
      err_ev = IFACE_EMBMS_ACTIVE_TMGI_LIST_EV;
      break; 
  }

  if (0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_EMBMS_AVAILABLE_TMGI_LIST_EV,
                                   wds_sp->um_iface_embms_available_tmgi_list_buf_ptr))
  {
      err_ev = IFACE_EMBMS_AVAILABLE_TMGI_LIST_EV;
      break;
  }

  if (0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_EMBMS_WARNING_TMGI_LIST_EV,
                                   wds_sp->um_iface_embms_warning_tmgi_list_buf_ptr))
  {
      err_ev = IFACE_EMBMS_WARNING_TMGI_LIST_EV;
      break;
  }

#ifdef FEATURE_DATA_EMBMS
  if (0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_EMBMS_AVAILABLE_SAI_LIST_EV,
                                   wds_sp->um_iface_embms_sai_list_buf_ptr))
  {
      err_ev = IFACE_EMBMS_AVAILABLE_SAI_LIST_EV;
      break;
  }
#endif /* FEATURE_DATA_EMBMS */
  if (0 != ps_iface_event_cback_reg(wds_sp->um_iface_ptr,
                                   IFACE_EMBMS_CONTENT_DESC_CONTROL_EV,
                                   wds_sp->um_iface_embms_content_desc_buf_ptr))
  {
      err_ev = IFACE_EMBMS_CONTENT_DESC_CONTROL_EV;
      break;
  }

}while(0);

  if(err_ev != IFACE_EVENT_MAX)
  {
     LOG_MSG_ERROR_1("Couldn't register for eMBMS iface event: %d",err_ev);
     ASSERT(0);
  }

  wds_sp->reg_embms_iface_ev = TRUE;

  LOG_MSG_INFO2_0("eMBMS events registered");

} /* wdsi_reg_iface_embms_event() */

/*===========================================================================
  FUNCTION WDSI_DEREG_IFACE_EMBMS_EVENT()

  DESCRIPTION
    Function to de-register eMBMS events on UM iface

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_dereg_iface_embms_event
(
  qmi_wdsi_state_type *  wds_sp
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (wds_sp->reg_embms_iface_ev != TRUE)
  {
    LOG_MSG_INFO2_0("eMBMS events not registered");
    return;
  }

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_EMBMS_TMGI_ACTIVATED_EV,
                             wds_sp->um_iface_embms_tmgi_activated_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_EMBMS_TMGI_DEACTIVATED_EV,
                             wds_sp->um_iface_embms_tmgi_deactivated_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_EMBMS_TMGI_ACTIVATE_DEACTIVATE_RESPONSE_EV,
                             wds_sp->um_iface_embms_tmgi_act_deact_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_EMBMS_ACTIVE_TMGI_LIST_EV,
                             wds_sp->um_iface_embms_active_tmgi_list_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_EMBMS_AVAILABLE_TMGI_LIST_EV,
                             wds_sp->um_iface_embms_available_tmgi_list_buf_ptr);

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_EMBMS_WARNING_TMGI_LIST_EV,
                             wds_sp->um_iface_embms_warning_tmgi_list_buf_ptr);

#ifdef FEATURE_DATA_EMBMS
  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_EMBMS_AVAILABLE_SAI_LIST_EV,
                             wds_sp->um_iface_embms_sai_list_buf_ptr);
#endif /* FEATURE_DATA_EMBMS */

  ps_iface_event_cback_dereg(wds_sp->um_iface_ptr,
                             IFACE_EMBMS_CONTENT_DESC_CONTROL_EV,
                             wds_sp->um_iface_embms_content_desc_buf_ptr);

  wds_sp->reg_embms_iface_ev = FALSE;

  LOG_MSG_INFO2_0("eMBMS events deregistered");

} /* wdsi_dereg_iface_embms_event() */

/*===========================================================================
  FUNCTION WDSI_REQUEST_AVAILABLE_EMBMS_EVENTS()

  DESCRIPTION
    Function to request MH to send availabe eMBMS events

  PARAMETERS
    wds_sp - WDS instance state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_request_available_embms_events
(
  qmi_wdsi_state_type *  wds_sp
)
{
  int                                     return_val     = 0;
  int16                                   ps_errno       = DS_ENOERR;
  ps_iface_embms_generate_events_info_type    event_request;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  memset(&event_request, 0, sizeof(ps_iface_embms_generate_events_info_type));

  event_request.embms_event = PS_IFACE_EMBMS_GENERATE_SAI_LIST_EV;
  
  // Call IOCTL to request MH to send available eMBMS events
  return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                              PS_IFACE_IOCTL_EMBMS_GENERATE_EVENTS,
                              &event_request,
                              &ps_errno);
  
  if (0 != return_val )
  {
    LOG_MSG_ERROR_1("Cannot request eMBMS events, ps_errno:%d ", ps_errno);
  }
  else
  {
    LOG_MSG_INFO1_0("Request embms events complete success ");
  }

} /* wdsi_request_available_embms_events() */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_EMBMS_EV_IND()

DESCRIPTION
    Called when eMBMS events occur.
    Used to indicate information associated with the events

PARAMETERS
  wds_sp     : wds state pointer
  event      : eMBMS event
  event_info : eMBMS event info

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_embms_ev_ind
(
  qmi_wdsi_state_type         * wds_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info
)
{
  qmi_wdsi_client_state_type * cl_sp = NULL;
  qmi_wdsi_client_state_type * temp_cl_sp;
  ps_iface_embms_tmgi_type   * tmgi_list = NULL;
#ifdef FEATURE_DATA_EMBMS
  ps_iface_embms_frequency_sai_info *sai_list = NULL;
#endif /* FEATURE_DATA_EMBMS */
  void  *embms_content_desc = NULL;

  ASSERT (wds_sp);

  // Get client state pointer
  switch (event)
  {
    case IFACE_EMBMS_TMGI_ACTIVATED_EV:
      cl_sp = (qmi_wdsi_client_state_type *)
                     event_info.embms_tmgi_act_ind_info.client_id;
      break;
    case IFACE_EMBMS_TMGI_DEACTIVATED_EV:
      cl_sp = (qmi_wdsi_client_state_type *)
                     event_info.embms_tmgi_deact_ind_info.client_id;
      tmgi_list = event_info.embms_tmgi_deact_ind_info.tmgi_list.list;
      break;
    case IFACE_EMBMS_TMGI_ACTIVATE_DEACTIVATE_RESPONSE_EV:
      cl_sp = (qmi_wdsi_client_state_type *)
                     event_info.embms_tmgi_act_deact_ind_info.client_id;
      break;
    case IFACE_EMBMS_ACTIVE_TMGI_LIST_EV:
    case IFACE_EMBMS_AVAILABLE_TMGI_LIST_EV:
    case IFACE_EMBMS_WARNING_TMGI_LIST_EV:
      cl_sp = (qmi_wdsi_client_state_type *)
                     event_info.embms_tmgi_list_ind_info.client_id;
      tmgi_list = event_info.embms_tmgi_list_ind_info.tmgi_list.list;
      break;
#ifdef FEATURE_DATA_EMBMS
    case IFACE_EMBMS_AVAILABLE_SAI_LIST_EV:
      cl_sp = (qmi_wdsi_client_state_type *)
                     event_info.embms_sai_list_ind_info.client_id;
      sai_list        = event_info.embms_sai_list_ind_info.freq_sai_info;
      break;
#endif /* FEATURE_DATA_EMBMS */
     case IFACE_EMBMS_CONTENT_DESC_CONTROL_EV:
       cl_sp = (qmi_wdsi_client_state_type *)PS_IFACE_EMBMS_RESERVED_CLIENT_ID;
       embms_content_desc = event_info.embms_content_desc_info.content_description;
       break;
    default:
      LOG_MSG_ERROR_1("Unknown eMBMS event [%d]", event);
      return;
  }

  LOG_MSG_INFO2_2("Recvd eMBMS event [%d] cl_sp [%p]", event, cl_sp);
  ASSERT(cl_sp);

  /* If cl_sp != PS_IFACE_EMBMS_RESERVED_CLIENT_ID, the event is generated by
   * client initiated eMBMS operation. Send event only to that client.
   */
  if (cl_sp != (qmi_wdsi_client_state_type *)PS_IFACE_EMBMS_RESERVED_CLIENT_ID)
  {
    // Validate client
    temp_cl_sp = wds_sp->client_list;
    while (temp_cl_sp != NULL)
    {
      if (temp_cl_sp == cl_sp)
      {
        break;
      }
      temp_cl_sp = temp_cl_sp->next;
    }

    if ( (temp_cl_sp == NULL) ||
         (wds_sp != qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp)) )
    {
      LOG_MSG_ERROR_1("Invalid client [%p]", cl_sp);
      if (tmgi_list != NULL)
      {
        PS_SYSTEM_HEAP_MEM_FREE(tmgi_list);
      }
#ifdef FEATURE_DATA_EMBMS
      // Free the SAI list allocated in wdsi_um_iface_ev_cb()
      if (sai_list != NULL)
      {
        PS_SYSTEM_HEAP_MEM_FREE(sai_list);
      }
#endif /* FEATURE_DATA_EMBMS */
      if (embms_content_desc != NULL)
      {
        PS_SYSTEM_HEAP_MEM_FREE(embms_content_desc);
      }
      return;
    }

    // Send event to the client
    if ( (event == IFACE_EMBMS_TMGI_ACTIVATED_EV) ||
         (event == IFACE_EMBMS_TMGI_DEACTIVATED_EV) )
    {
      qmi_wdsi_tmgi_status_ind(wds_sp, cl_sp, event, event_info);
    }
    else if (event == IFACE_EMBMS_TMGI_ACTIVATE_DEACTIVATE_RESPONSE_EV)
    {
      qmi_wdsi_tmgi_act_deact_ind(wds_sp, cl_sp, event, event_info);
    }
    else if ( (event == IFACE_EMBMS_ACTIVE_TMGI_LIST_EV) ||
              (event == IFACE_EMBMS_AVAILABLE_TMGI_LIST_EV) ||
              (event == IFACE_EMBMS_WARNING_TMGI_LIST_EV) )
    {
      qmi_wdsi_tmgi_list_ind(wds_sp, cl_sp, event, event_info, FALSE);
    }
#ifdef FEATURE_DATA_EMBMS
    else if (event == IFACE_EMBMS_AVAILABLE_SAI_LIST_EV)
    {
      qmi_wdsi_sai_list_ind(wds_sp, cl_sp, event, event_info, FALSE);
    }
#endif /* FEATURE_DATA_EMBMS */
    else if (event == IFACE_EMBMS_CONTENT_DESC_CONTROL_EV)
    {
      qmi_wdsi_embms_content_desc_control_ind(wds_sp, cl_sp, event, 
                                              event_info, FALSE);
    }

    // Free the TMGI list allocated in wdsi_um_iface_ev_cb()
    if (tmgi_list != NULL)
    {
      PS_SYSTEM_HEAP_MEM_FREE(tmgi_list);
    }
#ifdef FEATURE_DATA_EMBMS
    // Free the SAI list allocated in wdsi_um_iface_ev_cb()
    if (sai_list != NULL)
    {
      PS_SYSTEM_HEAP_MEM_FREE(sai_list);
    }
#endif /* FEATURE_DATA_EMBMS */
    if (embms_content_desc != NULL)
    {
      PS_SYSTEM_HEAP_MEM_FREE(embms_content_desc);
    }
    return;
  }

  /* cl_sp == PS_IFACE_EMBMS_RESERVED_CLIENT_ID: Modem initiated eMBMS event
   * Generate ind to all clients registered for the event
   */
  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
    if ( wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp) &&
         qmi_wdsi_verify_client_subs(cl_sp, wds_sp->binding.subscription_id,
                                     TRUE) )
    {
      if ( (event == IFACE_EMBMS_TMGI_ACTIVATED_EV) ||
           (event == IFACE_EMBMS_TMGI_DEACTIVATED_EV) || 
           (event == IFACE_EMBMS_TMGI_ACTIVATE_DEACTIVATE_RESPONSE_EV) )
      {
        // We no longer generate modem inited status event
        LOG_MSG_ERROR_1("Ignoring modem inited TMGI status event %d", event);
      }
      else if ( (event == IFACE_EMBMS_ACTIVE_TMGI_LIST_EV) ||
                (event == IFACE_EMBMS_AVAILABLE_TMGI_LIST_EV) ||
                (event == IFACE_EMBMS_WARNING_TMGI_LIST_EV) )
      {
        if (cl_sp->report_status.report_tmgi_list)
        {
          qmi_wdsi_tmgi_list_ind(wds_sp, cl_sp, event, event_info, TRUE);
        }
      }
#ifdef FEATURE_DATA_EMBMS
      else if (event == IFACE_EMBMS_AVAILABLE_SAI_LIST_EV)
      {
        if (cl_sp->report_status.report_sai_list)
        {
          qmi_wdsi_sai_list_ind(wds_sp, cl_sp, event, event_info, TRUE);
        }
      }      
#endif /* FEATURE_DATA_EMBMS */
      else if (event == IFACE_EMBMS_CONTENT_DESC_CONTROL_EV)
      {
        if (cl_sp->report_status.report_embms_content_desc_change)
        {
          LOG_MSG_INFO1_1(" cl_sp [%p]  registered for cnt desc", cl_sp);
          qmi_wdsi_embms_content_desc_control_ind(wds_sp, cl_sp, event, 
                                                  event_info, FALSE);
        }
      }
    }
    cl_sp = cl_sp->next;
  } /* while */

  // Free the TMGI list allocated in wdsi_um_iface_ev_cb()
  if (tmgi_list != NULL)
  {
    PS_SYSTEM_HEAP_MEM_FREE(tmgi_list);
  }

#ifdef FEATURE_DATA_EMBMS
  // Free the SAI list allocated in wdsi_um_iface_ev_cb()
  if (sai_list != NULL)
  {
    PS_SYSTEM_HEAP_MEM_FREE(sai_list);
  }
#endif /* FEATURE_DATA_EMBMS */
  if (embms_content_desc != NULL)
  {
    PS_SYSTEM_HEAP_MEM_FREE(embms_content_desc);
  }
} /* qmi_wdsi_generate_embms_ev_ind() */

/*===========================================================================
FUNCTION QMI_WDSI_TMGI_STATUS_IND()

DESCRIPTION
  Send eMBMS TMGI status indication to a client

PARAMETERS
  wds_sp     : wds state pointer
  cl_sp      : client state pointer
  event      : eMBMS TMGI status event
  event_info : eMBMS TMGI event info

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_tmgi_status_ind
(
  qmi_wdsi_state_type         * wds_sp,
  qmi_wdsi_client_state_type  * cl_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info
)
{
  uint32                      tmgi_status = 0;
  wds_embms_tmgi_activate_ind_msg_v01 status_ind;
  ps_iface_embms_tmgi_list_type * ps_tmgi_list;
  uint16                      ind_type = 0;
  uint8                       cl_id;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(wds_sp && cl_sp);

  cl_id = cl_sp->common.clid;
  memset(&status_ind,0,sizeof(wds_embms_tmgi_activate_ind_msg_v01));
  
  if (event == IFACE_EMBMS_TMGI_ACTIVATED_EV)
  {
    ind_type = QMI_WDS_EMBMS_TMGI_ACTIVATE_IND_V01;
    status_ind.activate_status = (wds_embms_tmgi_activate_status_enum_v01)
        event_info.embms_tmgi_act_ind_info.act_info_code;
    status_ind.tranx_id_valid = TRUE;
    status_ind.tranx_id = (int16)event_info.embms_tmgi_act_ind_info.debug_trace_id;

    // Copy TMGI
    memscpy(status_ind.tmgi.tmgi,
            sizeof(status_ind.tmgi.tmgi),
           event_info.embms_tmgi_act_ind_info.tmgi_session_info.tmgi,
            sizeof(event_info.embms_tmgi_act_ind_info.tmgi_session_info.tmgi));

    status_ind.tmgi.session_id_valid = 
        event_info.embms_tmgi_act_ind_info.tmgi_session_info.session_id_present ? 1 : 0;

    status_ind.tmgi.session_id =
        event_info.embms_tmgi_act_ind_info.tmgi_session_info.session_id;
  }
  else if (event == IFACE_EMBMS_TMGI_DEACTIVATED_EV)
  {
    ind_type = QMI_WDS_EMBMS_TMGI_DEACTIVATE_IND_V01;
    ps_tmgi_list = &event_info.embms_tmgi_deact_ind_info.tmgi_list;
    tmgi_status = event_info.embms_tmgi_deact_ind_info.info_code;
    if ( (tmgi_status >> 16) == PS_IFACE_EMBMS_CAUSE_CATEGORY_1 )
    {
      ind_type = WDSI_CMD_VAL_EMBMS_TMGI_ACTIVATE;
    }
    else if ( (tmgi_status >> 16) == PS_IFACE_EMBMS_CAUSE_CATEGORY_2 )
    {
      if (tmgi_status == IFACE_EMBMS_TMGI_DEACTIVATION_CLIENT_INITIATED)
      {
        tmgi_status = WDSI_TMGI_STATUS_SUCCESS;
      }
    }
    else
    {
      LOG_MSG_ERROR_1("Unknown deactivate status [%d]", tmgi_status);
      return;
    }

    // We can only have one TMGI in deactivate event
    if (ps_tmgi_list->num_tmgi != 1)
    {
      LOG_MSG_ERROR_1("Num TMGI must be 1 [%d] in deactivate event",
                      ps_tmgi_list->num_tmgi);
      return;
    }
    status_ind.activate_status = (wds_embms_tmgi_activate_status_enum_v01)
                                   tmgi_status;
    status_ind.tranx_id_valid = TRUE;
    status_ind.tranx_id = (int16)event_info.embms_tmgi_deact_ind_info.debug_trace_id;
    // Copy TMGI
    memscpy(status_ind.tmgi.tmgi, 
            sizeof(status_ind.tmgi.tmgi),
            ps_tmgi_list->list[0].tmgi, 
            sizeof(ps_tmgi_list->list[0].tmgi));
    status_ind.tmgi.session_id_valid = ps_tmgi_list->list[0].session_id_present ? 1 : 0;
    status_ind.tmgi.session_id = ps_tmgi_list->list[0].session_id;
  }
  else
  {
    LOG_MSG_ERROR_1("Unknown eMBMS status event [%d]", event);
    return;
  }
  qmi_wdsi_send_ind(wds_sp,
                     cl_sp,
                     ind_type,
                     sizeof(wds_embms_tmgi_activate_ind_msg_v01),//same size for both activate and deactivate
                     &status_ind,TRUE);
} /* qmi_wdsi_tmgi_status_ind() */

/*===========================================================================
FUNCTION QMI_WDSI_TMGI_ACT_DEACT_IND()

DESCRIPTION
  Send eMBMS TMGI act_deact status indication to a client

PARAMETERS
  wds_sp     : wds state pointer
  cl_sp      : client state pointer
  event      : eMBMS TMGI status event
  event_info : eMBMS TMGI event info

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_tmgi_act_deact_ind
(
  qmi_wdsi_state_type         * wds_sp,
  qmi_wdsi_client_state_type  * cl_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info
)
{
  uint32                      act_tmgi_status = 0;
  uint32                      deact_tmgi_status = 0;
  int16                       debug_trace_id = -1;
  uint8                       cl_id;
  wds_embms_tmgi_act_deact_ind_msg_v01 indication;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(wds_sp && cl_sp);

  cl_id = cl_sp->common.clid;
  memset(&indication,0,sizeof(wds_embms_tmgi_act_deact_ind_msg_v01));
  debug_trace_id = (int16)event_info.embms_tmgi_act_deact_ind_info.debug_trace_id;
  act_tmgi_status = event_info.embms_tmgi_act_deact_ind_info.act_info_code;
  deact_tmgi_status = event_info.embms_tmgi_act_deact_ind_info.deact_info_code; 

  if (deact_tmgi_status == IFACE_EMBMS_TMGI_DEACTIVATION_CLIENT_INITIATED)
  {
    deact_tmgi_status = WDSI_TMGI_STATUS_SUCCESS;
  }

  // Copy ACT TMGI
  memscpy(indication.act_tmgi.tmgi,
          sizeof(indication.act_tmgi.tmgi),
         event_info.embms_tmgi_act_deact_ind_info.act_tmgi_session_info.tmgi,
         sizeof(event_info.embms_tmgi_act_deact_ind_info.act_tmgi_session_info.tmgi));
  indication.act_tmgi.session_id_valid = 
      event_info.embms_tmgi_act_deact_ind_info.act_tmgi_session_info.session_id_present ? 1 : 0;
  indication.act_tmgi.session_id =
      event_info.embms_tmgi_act_deact_ind_info.act_tmgi_session_info.session_id;

  // Copy DEACT TMGI
  memscpy(indication.deact_tmgi.tmgi,
          sizeof(indication.deact_tmgi.tmgi),
          event_info.embms_tmgi_act_deact_ind_info.deact_tmgi_session_info.tmgi,
          sizeof(event_info.embms_tmgi_act_deact_ind_info.deact_tmgi_session_info.tmgi));
  indication.deact_tmgi.session_id_valid = 
      event_info.embms_tmgi_act_deact_ind_info.deact_tmgi_session_info.session_id_present ? 1 : 0;
  indication.deact_tmgi.session_id =
      event_info.embms_tmgi_act_deact_ind_info.deact_tmgi_session_info.session_id;

  // Debug Trace ID
  indication.tranx_id_valid  = TRUE;
  indication.tranx_id = debug_trace_id;

  // Deact status
  indication.deact_status = deact_tmgi_status;

  // Act status
  indication.act_status = act_tmgi_status;

  // Send indication
  qmi_wdsi_send_ind(wds_sp,
                    cl_sp,
                    QMI_WDS_EMBMS_TMGI_ACT_DEACT_IND_V01,
                    sizeof(wds_embms_tmgi_act_deact_ind_msg_v01),
                    &indication,TRUE);
} /* qmi_wdsi_tmgi_act_deact_ind() */

/*===========================================================================
FUNCTION QMI_WDSI_TMGI_LIST_IND()

DESCRIPTION
  Send eMBMS TMGI list indication/response to a client

PARAMETERS
  wds_sp     : wds state pointer
  cl_sp      : client state pointer
  event      : eMBMS TMGI list event
  event_info : eMBMS TMGI event info
  modem_inited: If is modem iniatied event

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_tmgi_list_ind
(
  qmi_wdsi_state_type         * wds_sp,
  qmi_wdsi_client_state_type  * cl_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  boolean                       modem_inited
)
{
  dsm_item_type             * response = NULL;
  wds_embms_tmgi_list_query_resp_msg_v01* resp_msg =  NULL;
  qmi_error_type_v01            errval = QMI_ERR_NONE_V01; 
  qmi_wdsi_tmgi_list_type                  * v_out_tmgi = NULL;
  ps_iface_embms_tmgi_list_info_type       * ps_tmgi_list;
  uint8                                      cl_id;
  qmi_cmd_buf_type                         * cmd_buf_p = NULL;
  uint32                      warning_reason = 0;
  boolean                     warning_reason_tlv = FALSE;
  int16                       debug_trace_id = -1;
  int                         i;
  wds_embms_tmgi_list_ind_msg_v01* indication =  NULL;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(wds_sp && cl_sp);

  cl_id = cl_sp->common.clid;
  ps_tmgi_list = &event_info.embms_tmgi_list_ind_info;

  // Allocate output TMGI list buffer
  PS_SYSTEM_HEAP_MEM_ALLOC(v_out_tmgi, sizeof(qmi_wdsi_tmgi_list_type),
                           qmi_wdsi_tmgi_list_type*);
  if (v_out_tmgi == NULL)
  {
    return;
  }
  memset(v_out_tmgi, 0, sizeof(qmi_wdsi_tmgi_list_type));

  // TMGI list type
  if (event == IFACE_EMBMS_ACTIVE_TMGI_LIST_EV)
  {
    v_out_tmgi->tmgi_list_type = WDSI_TMGI_LIST_TYPE_ACTIVE;
  }
  else if (event == IFACE_EMBMS_AVAILABLE_TMGI_LIST_EV)
  {
    v_out_tmgi->tmgi_list_type = WDSI_TMGI_LIST_TYPE_AVAILABLE;
  }
  else if (event == IFACE_EMBMS_WARNING_TMGI_LIST_EV)
  {
    v_out_tmgi->tmgi_list_type = WDSI_TMGI_LIST_TYPE_OOS_WARNING;
    if ( (ps_tmgi_list->info_code >> 16) == PS_IFACE_EMBMS_CAUSE_CATEGORY_4)
    {
      warning_reason = ps_tmgi_list->info_code & 0x0000FFFF;
      warning_reason_tlv = TRUE;
    }
  }
  else
  {
    LOG_MSG_ERROR_1("Unknown eMBMS list event [%d]", event);
    PS_SYSTEM_HEAP_MEM_FREE(v_out_tmgi);
    return;
  }

  // TMGI list
  if (ps_tmgi_list->tmgi_list.num_tmgi > WDSI_MAX_TMGI_NUM)
  {
    LOG_MSG_ERROR_1("Too many TMGIs [%d] in the list",
                    ps_tmgi_list->tmgi_list.num_tmgi);
    PS_SYSTEM_HEAP_MEM_FREE(v_out_tmgi);
    return;
  }

  v_out_tmgi->tmgi_list_len = ps_tmgi_list->tmgi_list.num_tmgi;
  for (i = 0; i < ps_tmgi_list->tmgi_list.num_tmgi; i++)
  {
    memscpy(v_out_tmgi->tmgi_list[i].tmgi,
            sizeof(v_out_tmgi->tmgi_list[i].tmgi),
            ps_tmgi_list->tmgi_list.list[i].tmgi,
            sizeof(ps_tmgi_list->tmgi_list.list[i].tmgi));

    v_out_tmgi->tmgi_list[i].session_id_valid = 
           ps_tmgi_list->tmgi_list.list[i].session_id_present ? 1 : 0;

    v_out_tmgi->tmgi_list[i].session_id =
           ps_tmgi_list->tmgi_list.list[i].session_id;
  }

  // Debug Trace ID
  debug_trace_id = (int16)ps_tmgi_list->debug_trace_id;

  /* ------------------------------------------------------------------------
   * For modem initiated TMGI list event, send indication
   * ----------------------------------------------------------------------*/

  if (modem_inited)
  {
    PS_SYSTEM_HEAP_MEM_ALLOC(indication,
                           sizeof(wds_embms_tmgi_list_ind_msg_v01),
                           wds_embms_tmgi_list_ind_msg_v01*);
    if(indication == NULL)
    {
      LOG_MSG_ERROR_0("Heap memory not available to send TMGI list ind");
      PS_SYSTEM_HEAP_MEM_FREE(v_out_tmgi);
      return;
    }
    else
    {
      memset(indication,0,sizeof(wds_embms_tmgi_list_ind_msg_v01));
    }
    indication->tmgi_list_valid = TRUE;
    indication->tmgi_list.tmgi_list_len = v_out_tmgi->tmgi_list_len;
    indication->tmgi_list.list_type = v_out_tmgi->tmgi_list_type;
    for (i = 0; i < v_out_tmgi->tmgi_list_len; i++)
    {
      memscpy(indication->tmgi_list.tmgi_list[i].tmgi,
            sizeof(indication->tmgi_list.tmgi_list[i].tmgi),
            v_out_tmgi->tmgi_list[i].tmgi,
            sizeof(v_out_tmgi->tmgi_list[i].tmgi));
      indication->tmgi_list.tmgi_list[i].session_id_valid = 
            v_out_tmgi->tmgi_list[i].session_id_valid;
      indication->tmgi_list.tmgi_list[i].session_id =
            v_out_tmgi->tmgi_list[i].session_id;
    }
    // Debug Trace ID 
    indication->tranx_id_valid = TRUE;
	indication->tranx_id = debug_trace_id;

    // Warning reason TLV
    if(TRUE == warning_reason_tlv)
    {
      indication->warn_reason_valid = TRUE;
      indication->warn_reason = (wds_embms_oos_warning_reason_enum_v01)warning_reason;
    }

    // Send indication
    qmi_wdsi_send_ind(wds_sp,
                      cl_sp,
                      QMI_WDS_EMBMS_TMGI_LIST_IND_V01,
                      sizeof(wds_embms_tmgi_list_ind_msg_v01),
                      indication,TRUE);
    PS_SYSTEM_HEAP_MEM_FREE(v_out_tmgi);
    PS_SYSTEM_HEAP_MEM_FREE(indication);
    return;
  } /* modem_inited */

  /* -----------------------------------------------------------------------------
   * Non-modem initiated. Get request from pending queue and send response
   * ---------------------------------------------------------------------------*/
  if (v_out_tmgi->tmgi_list_type == WDSI_TMGI_LIST_TYPE_ACTIVE)
  {
    cmd_buf_p = cl_sp->tmgi_active_list_cmd_buf_p;
    cl_sp->tmgi_active_list_cmd_buf_p = NULL;
  }
  else if (v_out_tmgi->tmgi_list_type == WDSI_TMGI_LIST_TYPE_AVAILABLE)
  {
    cmd_buf_p = cl_sp->tmgi_avail_list_cmd_buf_p;
    cl_sp->tmgi_avail_list_cmd_buf_p = NULL;
  }

  if (cmd_buf_p == NULL)
  {
    LOG_MSG_ERROR_2("No pending TMGI list request for client %d type %d",
                    cl_id, v_out_tmgi->tmgi_list_type);
    PS_SYSTEM_HEAP_MEM_FREE(v_out_tmgi);
    return;
  }

  ASSERT( (cmd_buf_p->x_p != NULL) && 
          (cmd_buf_p->x_p->cl_sp == (qmi_common_client_state_type *)cl_sp));
  PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg,
                           sizeof(wds_embms_tmgi_list_query_resp_msg_v01),
                           wds_embms_tmgi_list_query_resp_msg_v01*);
  if(resp_msg == NULL)
  {
    wdsi_tmgi_send_response(cmd_buf_p, NULL, QMI_ERR_INTERNAL_V01,TRUE);
    PS_SYSTEM_HEAP_MEM_FREE(v_out_tmgi);
    return;  
  }
  else
  {
    memset(resp_msg,0,sizeof(wds_embms_tmgi_list_query_resp_msg_v01));
  }
  // Warning reason TLV
  if (TRUE == warning_reason_tlv)
  {
    resp_msg->warn_reason_valid = TRUE;
    resp_msg->warn_reason = (wds_embms_oos_warning_reason_enum_v01)warning_reason;

  }
  // TMGI list TLV
  resp_msg->tmgi_list_valid = TRUE;
  resp_msg->tmgi_list.tmgi_list_len = v_out_tmgi->tmgi_list_len;
  resp_msg->tmgi_list.list_type = v_out_tmgi->tmgi_list_type;
  for (i = 0; i < v_out_tmgi->tmgi_list_len; i++)
  {
    memscpy(resp_msg->tmgi_list.tmgi_list[i].tmgi,
            sizeof(resp_msg->tmgi_list.tmgi_list[i].tmgi),
            v_out_tmgi->tmgi_list[i].tmgi,
            sizeof(v_out_tmgi->tmgi_list[i].tmgi));
    resp_msg->tmgi_list.tmgi_list[i].session_id_valid = 
            v_out_tmgi->tmgi_list[i].session_id_valid;
    resp_msg->tmgi_list.tmgi_list[i].session_id =
            v_out_tmgi->tmgi_list[i].session_id;
  }
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_EMBMS_TMGI_LIST_QUERY_RESP_V01,
                               resp_msg,
                               sizeof(wds_embms_tmgi_list_query_resp_msg_v01),
                               errval,
                               &response);
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  PS_SYSTEM_HEAP_MEM_FREE(v_out_tmgi);
  wdsi_tmgi_send_response(cmd_buf_p, response, errval,FALSE);

} /* qmi_wdsi_tmgi_list_ind() */

/*===========================================================================
FUNCTION   WDSI_COPY_TMGI_LIST_FROM_EVENT()

DESCRIPTION
  This function allocates memory and copy the TMGI list
  from the event_info to the cmd_ptr event_info. 

PARAMETERS:
  event         : type of event
  event_info    : info ptr for the event
  cmd_ptr       : DCC command buffer ptr

DEPENDENCIES
  Called from wdsi_um_iface_cb()

RETURN VALUE
  TRUE: Operation is successful
  FALSE: Operation failed 

SIDE EFFECTS
  None
===========================================================================*/
static boolean wdsi_copy_tmgi_list_from_event
(
  ps_iface_event_enum_type   event,
  ps_iface_event_info_u_type * event_info,
  qmi_wdsi_cmd_buf_type      * cmd_ptr
)
{
  ps_iface_embms_tmgi_type *tmgi_list = NULL;
  ps_iface_embms_tmgi_type **tmgi_list_pp = NULL;
  uint8 num_tmgi = 0;

  ASSERT( event_info && cmd_ptr );

  /* Need to alloc memory and copy TMGI list since the one in the
   * event_info will be freed after callback.
   */
  if (event == IFACE_EMBMS_TMGI_DEACTIVATED_EV)
  {
    tmgi_list = event_info->embms_tmgi_deact_ind_info.tmgi_list.list;
    tmgi_list_pp = &(cmd_ptr->data.iface_info.event_info.embms_tmgi_deact_ind_info.tmgi_list.list);
    num_tmgi = event_info->embms_tmgi_deact_ind_info.tmgi_list.num_tmgi;
  }
  else if ( (event == IFACE_EMBMS_ACTIVE_TMGI_LIST_EV) ||
            (event == IFACE_EMBMS_AVAILABLE_TMGI_LIST_EV) ||
            (event == IFACE_EMBMS_WARNING_TMGI_LIST_EV) )
  {
    tmgi_list = event_info->embms_tmgi_list_ind_info.tmgi_list.list;
    tmgi_list_pp = &(cmd_ptr->data.iface_info.event_info.embms_tmgi_list_ind_info.tmgi_list.list);
    num_tmgi = event_info->embms_tmgi_list_ind_info.tmgi_list.num_tmgi;
  }
  else
  {
    LOG_MSG_ERROR_1("Unknown event %d", event);
    return FALSE;
  }

  *tmgi_list_pp = NULL;

  if (num_tmgi > WDSI_MAX_TMGI_NUM)
  {
    LOG_MSG_ERROR_1("Invalid num TMGI [%d]", num_tmgi);
    return FALSE;
  }

  if (num_tmgi > 0)
  {
    PS_SYSTEM_HEAP_MEM_ALLOC(*tmgi_list_pp,
                        num_tmgi * sizeof(ps_iface_embms_tmgi_type),
                             ps_iface_embms_tmgi_type*);
    if (*tmgi_list_pp != NULL)
    {
      memscpy(*tmgi_list_pp, 
              num_tmgi * sizeof(ps_iface_embms_tmgi_type),
              tmgi_list, 
              num_tmgi * sizeof(ps_iface_embms_tmgi_type));
    }
    else
    {
      return FALSE;
    }
  }

  return TRUE;

} /* wdsi_copy_tmgi_list_from_event() */

/*===========================================================================
  FUNCTION WDSI_SEND_TMGI_LIST_RESPONSE()

  DESCRIPTION
    Send eMBMS TMGI list query response.

  PARAMETERS
    cmd_buf_p : ptr to cmd buffer
    response  : response ptr 
    errval    : error value
    is_result_needed: Result TLV will not pushed into response
                      incase of FALSE.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_tmgi_send_response
(
  qmi_cmd_buf_type           * cmd_buf_p,
  dsm_item_type              * response,
  qmi_error_type_v01             errval,
  boolean                      is_result_needed
)
{
  qmi_result_type_v01   result;
  boolean             retval;

  ASSERT(cmd_buf_p);
  if( is_result_needed == TRUE)
  {
    result = (errval == QMI_ERR_NONE_V01? QMI_RESULT_SUCCESS_V01
                                     : QMI_RESULT_FAILURE_V01);
  
    retval = qmi_svc_put_result_tlv(&response, result, errval);
    if ( FALSE == retval )
    {
      LOG_MSG_ERROR_0("Couldn't generate response");
      dsm_free_packet(&response);
      ds_qmi_fw_free_cmd_buf(&cmd_buf_p);
      return;
    }
  }

  if ( FALSE == qmi_wdsi_send_response(cmd_buf_p, response) )
  {
    LOG_MSG_ERROR_0("Unable to send response!" );
    dsm_free_packet(&response);
    ds_qmi_fw_free_cmd_buf(&cmd_buf_p);
    return;
  }

} /* wdsi_tmgi_send_response() */

/*===========================================================================
  FUNCTION WDSI_CLEAN_PEND_REQ()

  DESCRIPTION
    Clean TMGI pending requests. Send response to all pending requests.

  PARAMETERS
    wds_sp    : wds state pointer
    cl_sp     : client state pointer

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void wdsi_tmgi_clean_pend_req
(
  qmi_wdsi_state_type         * wds_sp,
  qmi_error_type_v01              errval
)
{
  qmi_wdsi_client_state_type * cl_sp;
  qmi_cmd_buf_type           * cmd_buf_p;

  ASSERT(wds_sp);

  LOG_MSG_INFO2_1("Clean TMGI pending queues for wds_sp [%x]", wds_sp);

  // All clients of wds_sp
  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
    if ( wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp) )
    {
      if (cl_sp->tmgi_active_list_cmd_buf_p != NULL)
      {
        cmd_buf_p = cl_sp->tmgi_active_list_cmd_buf_p;
        cl_sp->tmgi_active_list_cmd_buf_p = NULL;
        wdsi_tmgi_send_response(cmd_buf_p, NULL, errval,TRUE);
      }

      if (cl_sp->tmgi_avail_list_cmd_buf_p != NULL)
      {
        cmd_buf_p = cl_sp->tmgi_avail_list_cmd_buf_p;
        cl_sp->tmgi_avail_list_cmd_buf_p = NULL;
        wdsi_tmgi_send_response(cmd_buf_p, NULL, errval,TRUE);
      }
#ifdef FEATURE_DATA_EMBMS
      if (cl_sp->sai_list_cmd_buf_p != NULL)
      {
        cmd_buf_p = cl_sp->sai_list_cmd_buf_p;
        cl_sp->sai_list_cmd_buf_p = NULL;
        wdsi_tmgi_send_response(cmd_buf_p, NULL, errval,TRUE);
      }
#endif /* FEATURE_DATA_EMBMS */
    }
    cl_sp = cl_sp->next;
  } /* while */

} /* wdsi_tmgi_clean_pend_req() */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_EXTENDED_IP_CONFIG_EV_IND()

DESCRIPTION
    Used to indicate change notifications in extended IP configuration
    of the packet data session

PARAMETERS
    wds_sp                : service provided state pointer
    config_change_mask    : Mask indicating config items updated.

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_extended_ip_config_ev_ind
(
  qmi_wdsi_state_type *                      wds_sp,
  ps_iface_ioctl_extended_ip_config_ex_type  config_change_mask
)
{
  qmi_wdsi_client_state_type *  cl_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT (wds_sp);

  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
     if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
    {
      if (cl_sp->report_status.report_extended_ip_config &&
          qmi_wdsi_verify_client_subs(cl_sp, 
                                      wds_sp->binding.subscription_id, TRUE))
      {
         qmi_wdsi_extended_ip_config_ev_ind( wds_sp, cl_sp->common.clid, 
                                             config_change_mask );
      }
    }
    cl_sp = cl_sp->next;
  }
} /* qmi_wdsi_generate_extended_ip_config_ev_ind */

/*===========================================================================
  FUNCTION QMI_WDSI_EXTENDED_IP_CONFIG_EV_IND()

  DESCRIPTION
    Is called when any of the iface events registered for occur.
    Sends an indication to the client.

  PARAMETERS
    wds_sp                : service provided state pointer
    cl_id                 : client ID
    config_change_mask    : Mask indicating the updated config items.

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_extended_ip_config_ev_ind
(
  qmi_wdsi_state_type *          wds_sp,
  uint8                                      cl_id,
  ps_iface_ioctl_extended_ip_config_ex_type  config_change_mask
)
{
  qmi_wdsi_client_state_type *   cl_sp;
  wds_extended_ip_config_ind_msg_v01 indication;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(wds_sp);

  memset(&indication,0,sizeof(wds_extended_ip_config_ind_msg_v01));
  cl_sp = qmi_wdsi_get_cl_sp_by_clid(wds_sp, cl_id);

  LOG_MSG_INFO2_1 ("qmi_wdsi_extended_ip_config_ev_ind(), mask: 0x%x", 
                   config_change_mask);
  indication.changed_ip_config_valid =  TRUE;
  indication.changed_ip_config = (wds_req_settings_mask_v01)config_change_mask;
  qmi_wdsi_send_ind(wds_sp,
                    cl_sp,
                    QMI_WDS_EXTENDED_IP_CONFIG_IND_V01,
                    sizeof(wds_extended_ip_config_ind_msg_v01),
                    &indication,TRUE);
} /* qmi_wdsi_extended_ip_config_ev_ind() */

  
#ifdef FEATURE_DATA_LTE

/*===========================================================================
  FUNCTION QMI_WDSI_LTE_ATTACH_PDN_LIST_CHANGE_CB()

  DESCRIPTION
    This the callback that we have registered with PS Sys layer for
    lte attach pdn list change event. 

  PARAMETERS
    tech_type      : technology for which system status has changed
    event_name     : Event name
    event_info_ptr : List of LTE attach PDN's
    user_data_ptr  : Optional user data to be sent.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_lte_attach_pdn_list_change_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
  qmi_wds_lte_attach_pdn_list_type * wds_attach_pdn_list;
  ps_sys_3gpp_lte_attach_pdn_list_type * attach_pdn_list;
  int pdn_cnt;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(event_info_ptr);
  attach_pdn_list = (ps_sys_3gpp_lte_attach_pdn_list_type *)event_info_ptr;
 
  cmd_ptr = (qmi_wdsi_cmd_buf_type *)
              qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_LTE_ATTACH_PDN_LIST_CHANGE_EVT);

  if( cmd_ptr == NULL)
  {
    return;
  }

  wds_attach_pdn_list = &cmd_ptr->data.lte_attach_pdn_list;

  wds_attach_pdn_list->attach_pdn_profile_list_num = 
    attach_pdn_list->attach_pdn_profile_list_num;

  for (pdn_cnt=0; pdn_cnt < attach_pdn_list->attach_pdn_profile_list_num; pdn_cnt++)
  {
    wds_attach_pdn_list->attach_pdn_profile_list[pdn_cnt] = 
      attach_pdn_list->attach_pdn_profile_list[pdn_cnt];
  }

  cmd_ptr->cmd_id = QMI_CMD_WDS_LTE_ATTACH_PDN_LIST_CHANGE_EVT;
  cmd_ptr->subscription_id = subscription_id;

  dcc_send_cmd_ex (DCC_QMI_CMD, cmd_ptr);
} /* qmi_wdsi_lte_attach_pdn_list_change_cb() */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_LTE_ATTACH_PDN_LIST_CHANGE_IND()

DESCRIPTION
    Used to indicate change notifications in lte attach PDN list 

PARAMETERS
    lte_attach_pdn_list    : List of LTE attach PDN profiles
    subs_id: Subscription identifier

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_lte_attach_pdn_list_change_ind
(
  qmi_wds_lte_attach_pdn_list_type lte_attach_pdn_list,
  uint32                           subscription_id
)
{
  qmi_wdsi_state_type *         wds_sp;
  qmi_wdsi_client_state_type *  cl_sp;
  uint8                         state;
  uint8                         inst;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
 
  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }

      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
        {
          if (cl_sp->report_status.report_attach_pdn_list_change &&
              qmi_wdsi_verify_client_subs(cl_sp, subscription_id, FALSE))
          {
            qmi_wdsi_lte_attach_pdn_list_change_ind(wds_sp, 
                                                    cl_sp->common.clid,
                                                    &lte_attach_pdn_list);
          }
        }
        cl_sp = cl_sp->next;
      } /* while */
    }
  }
} /* qmi_wdsi_generate_lte_attach_pdn_list_change_ind */

/*===========================================================================
  FUNCTION QMI_WDSI_LTE_ATTACH_PDN_LIST_CHANGE_IND()

  DESCRIPTION
    Sends indication to clients registered for LTE attach pdn list change

  PARAMETERS
    wds_sp                : service provided state pointer
    cl_id                 : client ID
    lte_attach_pdn_list   : List of LTE attach PDN profiles

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_lte_attach_pdn_list_change_ind
(
  qmi_wdsi_state_type *                 wds_sp,
  uint8                                 cl_id,
  qmi_wds_lte_attach_pdn_list_type *   lte_attach_pdn_list
)
{
  qmi_wdsi_client_state_type *        cl_sp;
  wds_lte_attach_pdn_list_ind_msg_v01 indication;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(wds_sp && lte_attach_pdn_list);

  /*-------------------------------------------------------------------------
    Build indication from the back to the front
  -------------------------------------------------------------------------*/
  memset(&indication,0,sizeof(wds_lte_attach_pdn_list_ind_msg_v01));
  cl_sp = qmi_wdsi_get_cl_sp_by_clid(wds_sp, cl_id);

  LOG_MSG_INFO2_1 ("Indicate change notification in attach pdn list"
                   "to clid=%d", cl_id);
  indication.attach_pdn_list_valid = TRUE;
  indication.attach_pdn_list_len = lte_attach_pdn_list->attach_pdn_profile_list_num;
  
  memscpy(indication.attach_pdn_list,
          sizeof(indication.attach_pdn_list),
          lte_attach_pdn_list->attach_pdn_profile_list,
         (lte_attach_pdn_list->attach_pdn_profile_list_num * 
          sizeof(lte_attach_pdn_list->attach_pdn_profile_list[0]) ));
  qmi_wdsi_send_ind(wds_sp,
                    cl_sp,
                    WDSI_CMD_VAL_LTE_ATTACH_PDN_LIST_IND,
                    sizeof(wds_lte_attach_pdn_list_ind_msg_v01),
                   &indication,TRUE);
 } /* qmi_wdsi_lte_attach_pdn_list_change_ind() */

/*===========================================================================
  FUNCTION QMI_WDSI_SET_DATA_PATH()

  DESCRIPTION
    Sets the data path of the PDN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_set_data_path
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *  wds_sp;
  dsm_item_type *       response;
  wds_set_data_path_req_msg_v01 req_msg;
  wds_set_data_path_resp_msg_v01 resp_msg;
  qmi_error_type_v01      errval;
  int                   return_val;
  int16                 ps_errno = DS_ENOERR;
  ps_iface_ioctl_data_path_info_type     set_data_path;
  qmi_wdsi_client_state_type * client_sp;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&set_data_path, 0, sizeof(ps_iface_ioctl_data_path_info_type));

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_DATA_PATH_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  set_data_path.data_path = (uint32)req_msg.data_path;
  if( set_data_path.data_path != IFACE_DATA_PATH_HARDWARE &&
      set_data_path.data_path != IFACE_DATA_PATH_SOFTWARE )
  {
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  if ( wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED )
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  if( !wds_sp->um_iface_ptr )
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d", client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                              PS_IFACE_IOCTL_SET_DATA_PATH_BRIDGE_MODE,
                              &set_data_path,
                              &ps_errno);
  
  if (return_val != DSS_SUCCESS)
  {
    LOG_MSG_ERROR_1("Set data path request failed, ps_errno:%d ", ps_errno);

    switch (ps_errno)
  {
      case DS_EINVAL:
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01; 
        break;

      case DS_EOPNOTSUPP:
        errval = QMI_ERR_NO_EFFECT_V01; 
        break;

      case DS_NOMEMORY:
        errval = QMI_ERR_NO_MEMORY_V01;
        break;

      default:
    errval = QMI_ERR_INTERNAL_V01;
        break;
    }
    goto send_result;
  }

  send_result:
  if(errval != QMI_ERR_NONE_V01)
  {
    LOG_MSG_ERROR_3("qmi_wdsi_set_data_path: errval: %d, invalid request(%d), ps_errno:%d ",
                     errval, set_data_path.data_path, ps_errno);
  }
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_DATA_PATH_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_data_path() */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_DATA_PATH()

  DESCRIPTION
    Gets the data path of the PDN

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_data_path
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *                 wds_sp;
  dsm_item_type *                       response;
  wds_get_data_path_resp_msg_v01 resp_msg;
  ps_iface_ioctl_data_path_info_type    get_data_path;
  int16                                 ps_errno = DS_ENOERR;
  int16                                 return_val = DSS_SUCCESS;

  qmi_error_type_v01     errval;
  qmi_wdsi_client_state_type * client_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  /*-------------------------------------------------------------------------
    Build the response from back to front
  -------------------------------------------------------------------------*/
  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  /*-------------------------------------------------------------------------
    Call the ioctl and check result
  -------------------------------------------------------------------------*/
  memset(&get_data_path, 0, sizeof(ps_iface_ioctl_data_path_info_type));

  if ( wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED )
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  if( !wds_sp->um_iface_ptr )
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d", client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                              PS_IFACE_IOCTL_GET_DATA_PATH_BRIDGE_MODE,
                              &get_data_path,
                              &ps_errno);

  if (return_val != DSS_SUCCESS)
  {
    LOG_MSG_ERROR_2("ps_sys_ioctl ret [%d] errno [%d]", return_val, ps_errno);
    switch (ps_errno)
    {
      case DS_NOMEMORY:
        errval = QMI_ERR_NO_MEMORY_V01;
        break;
      default:
        errval = QMI_ERR_INTERNAL_V01;
        break;
    }
    goto send_result;
  }

  resp_msg.data_path_valid = TRUE;
  resp_msg.data_path = (uint32) get_data_path.data_path;

  if( resp_msg.data_path != IFACE_DATA_PATH_HARDWARE &&
      resp_msg.data_path != IFACE_DATA_PATH_SOFTWARE )
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

send_result:

  if(errval != QMI_ERR_NONE_V01)
  {
    LOG_MSG_ERROR_3("qmi_wdsi_get_data_path: errval: %d, ps_errno:%d, Invalid Data path:%d",
                     errval, ps_errno, resp_msg.data_path);
  }

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_DATA_PATH_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
}

#endif /* FEATURE_DATA_LTE */

#ifdef FEATURE_DATA_EMBMS
/*===========================================================================
  FUNCTION QMI_WDSI_EMBMS_SAI_LIST_QUERY()

  DESCRIPTION
    Queries the currently available SAI(Service Area Identity) list

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_embms_sai_list_query
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  qmi_wdsi_state_type *  wds_sp;
  qmi_wdsi_client_state_type *client_sp;
  dsm_item_type *       response;
  wds_embms_sai_list_query_resp_msg_v01* resp_msg = NULL;
  qmi_error_type_v01      errval;
  int                   return_val;
  int16                 ps_errno = DS_ENOERR;
  ps_iface_embms_sai_info_type  ps_get_sai;
  int16                 debug_trace_id = -1;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&ps_get_sai, 0, sizeof(ps_get_sai));

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *) cl_sp;

  PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg,
                           sizeof(wds_embms_sai_list_query_resp_msg_v01),
                           wds_embms_sai_list_query_resp_msg_v01*);
  if(resp_msg == NULL)
  {
    qmi_svc_put_result_tlv(&response, (qmi_result_e_type)QMI_RESULT_FAILURE_V01, 
                           (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
    return response;
  }
  else
  {
    memset(resp_msg,0,sizeof(wds_embms_sai_list_query_resp_msg_v01));
  }

  // Check if eMBMS call is up
  if ( (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED) ||
       (wds_sp->is_embms_inst != TRUE) )
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  // Check if there are pending query requests
  if (client_sp->sai_list_cmd_buf_p != NULL)
  {
      errval = QMI_ERR_NO_EFFECT_V01;
      goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d", client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  // Call ioctl to query SAI list. Use cl_sp as client_id
  ps_get_sai.client_id = cl_sp;
  ps_get_sai.debug_trace_id = debug_trace_id;

  return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                              PS_IFACE_IOCTL_EMBMS_GET_SAI_LIST,
                              &ps_get_sai,
                              &ps_errno);
  
  // If success, put the request in the pending queue.
  // We will send response upon SAI list event.
  if (0 == return_val )
  {
    client_sp->sai_list_cmd_buf_p = cmd_buf_p;
    PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
    return QMI_SVC_RESPONSE_PENDING;
  }
  else
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  send_result:
  if(errval != QMI_ERR_NONE_V01)
  {
    LOG_MSG_ERROR_3("qmi_wdsi_embms_sai_list_query: errval:%d, ps_errno:%d, is_embms_inst: %d",
                       errval, ps_errno, wds_sp->is_embms_inst);
  }
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_EMBMS_SAI_LIST_QUERY_RESP_V01,
                               resp_msg,
                               sizeof(wds_embms_sai_list_query_resp_msg_v01),
                               errval,
                               &response);
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  return response;
} /* qmi_wdsi_embms_sai_list_query() */

/*===========================================================================
  FUNCTION QMI_WDSI_CONVERT_SAI_INFO()

  DESCRIPTION
    Converts the PS sai list to wds sai list info

  PARAMETERS
   ps_sai_list:    Input SAI list from PS event
   buf:            Buf to be written to
   buf_mem_size:   Total allocated buf size
   num_bytes_copied: Actual number of bytes written to buffer

  RETURN VALUE
    TRUE  : Success
    FALSE : Failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_wdsi_convert_sai_info
(
   ps_iface_embms_sai_info_type           *  ps_sai_list,
   wds_embms_sai_list_per_freq_type_v01   *  freq_sai_list,
   uint32                                 *  freq_sai_list_len,
   wds_embms_sai_list_per_freq_ex_type_v01*  freq_sai_list_ex,
   uint32                                 *  freq_sai_list_ex_len
)
{
  uint8                               wds_num_freq = 0;
  uint8                               i = 0;
  uint8                               temp_cnt = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (ps_sai_list == NULL ||  freq_sai_list == NULL || freq_sai_list_ex == NULL ||
      freq_sai_list_len == NULL || freq_sai_list_ex_len == NULL)
  {
    LOG_MSG_ERROR("Null parameter passed. Cannot write sai buf ",0,0,0);
    return FALSE;
  }
  *freq_sai_list_ex_len = ps_sai_list->num_frequencies;;
  
    //Find how many freq are only 2 bytes in the list
  for (i = 0; i < ps_sai_list->num_frequencies; i++)
  {
    if (ps_sai_list->freq_sai_info[i].frequency < 0x10000)
    {
      wds_num_freq++; 
    }
  }
  *freq_sai_list_len = wds_num_freq;
  wds_num_freq = 0;
  for (i = 0; i < ps_sai_list->num_frequencies; i++)
  {
    if (ps_sai_list->freq_sai_info[i].frequency < 0x10000)
    {
      freq_sai_list[wds_num_freq].frequency = (uint16)ps_sai_list->freq_sai_info[i].frequency;
      freq_sai_list[wds_num_freq].is_serving_frequency = ps_sai_list->freq_sai_info[i].is_serving_frequency;
      freq_sai_list[wds_num_freq].sai_list_len = ps_sai_list->freq_sai_info[i].num_sais;
      for (temp_cnt = 0;temp_cnt < ps_sai_list->freq_sai_info[i].num_sais; temp_cnt++)
      {
        freq_sai_list[wds_num_freq].sai_list[temp_cnt] = (uint32) ps_sai_list->freq_sai_info[i].sai_list[temp_cnt];
      }
      wds_num_freq++;
    }
    freq_sai_list_ex[i].frequency = ps_sai_list->freq_sai_info[i].frequency;
    freq_sai_list_ex[i].is_serving_frequency = ps_sai_list->freq_sai_info[i].is_serving_frequency;
    freq_sai_list_ex[i].sai_list_len = ps_sai_list->freq_sai_info[i].num_sais;
    for (temp_cnt = 0;temp_cnt < ps_sai_list->freq_sai_info[i].num_sais; temp_cnt++)
    {
      freq_sai_list_ex[i].sai_list[temp_cnt] = (uint32) ps_sai_list->freq_sai_info[i].sai_list[temp_cnt];
    }
  }
  return TRUE;
} /* qmi_wdsi_convert_sai_info */

/*===========================================================================
FUNCTION QMI_WDSI_SAI_LIST_IND()

DESCRIPTION
  Send eMBMS SAI list indication/response to a client

PARAMETERS
  wds_sp     : wds state pointer
  cl_sp      : client state pointer
  event      : eMBMS TMGI list event
  event_info : eMBMS TMGI event info
  modem_inited: If is modem iniatied event

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_sai_list_ind
(
  qmi_wdsi_state_type         * wds_sp,
  qmi_wdsi_client_state_type  * cl_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  boolean                       modem_inited
)
{
  dsm_item_type                  * response = NULL;
  qmi_error_type_v01                 errval = QMI_ERR_NONE_V01;
  ps_iface_embms_sai_info_type   * ps_sai_list;
  uint8                            cl_id;
  qmi_cmd_buf_type               * cmd_buf_p = NULL;
  int16                            debug_trace_id = -1;
  wds_embms_sai_list_query_resp_msg_v01* resp_msg = NULL;
  wds_embms_sai_list_ind_msg_v01       * indication = NULL;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(wds_sp && cl_sp);

  cl_id       = cl_sp->common.clid;
  ps_sai_list = &event_info.embms_sai_list_ind_info;

  // SAI list
  if (ps_sai_list->num_frequencies > WDSI_MAX_SAI_NUM_FREQ)
  {
    LOG_MSG_ERROR_1("Too many SAI Frequencies [%d] in the list",
                    ps_sai_list->num_frequencies);
    return;
  }

  // Debug Trace ID
  debug_trace_id = (int16)ps_sai_list->debug_trace_id;
  if(modem_inited)
  {
    PS_SYSTEM_HEAP_MEM_ALLOC(indication, sizeof(wds_embms_sai_list_ind_msg_v01),
                  wds_embms_sai_list_ind_msg_v01*); 
    if (indication != NULL)
    {
      memset(indication, 0, sizeof(wds_embms_sai_list_ind_msg_v01));
    }
    else
    {
      return;
    }
    /*-------------------------------------------------------------------------
      Convert the throughput info retrieved from PS to wds sai structure
    -------------------------------------------------------------------------*/
      
    if(!qmi_wdsi_convert_sai_info(ps_sai_list,
                                  &(indication->freq_sai_list[0]),
                                  &indication->freq_sai_list_len,
                                  &(indication->freq_sai_list_ex[0]),
                                  &indication->freq_sai_list_ex_len))
    {
      PS_SYSTEM_HEAP_MEM_FREE(indication);
      return;
    }
    else
    {
      if(indication->freq_sai_list_len)
      {
        indication->freq_sai_list_valid = TRUE;
      }
      if(indication->freq_sai_list_ex_len)
      {
        indication->freq_sai_list_ex_valid = TRUE;
      }
    }
    if(debug_trace_id != -1)
    {
      indication->tranx_id_valid = TRUE;
      indication->tranx_id = debug_trace_id;
    }
    // Send indication
    if (FALSE == qmi_wdsi_send_ind(wds_sp,
                                   cl_sp,
                                   QMI_WDS_EMBMS_SAI_LIST_IND_V01,
                                   sizeof(wds_embms_sai_list_ind_msg_v01),
                                   indication,
                                   TRUE))
    {
      LOG_MSG_INFO2_0 ("Unable to send SAI list indication");
    }
    else
    {
      LOG_MSG_INFO2_1 ("Sent SAI list indication to client %d", cl_id);
    }
    PS_SYSTEM_HEAP_MEM_FREE(indication);
    return;
  }
  //NON - Modem inited
  cmd_buf_p = cl_sp->sai_list_cmd_buf_p;
  cl_sp->sai_list_cmd_buf_p = NULL;
  if (cmd_buf_p == NULL)
  {
    LOG_MSG_ERROR_1("No pending SAI list request for client %d ", cl_id);
    return;
  }
  PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg, sizeof(wds_embms_sai_list_query_resp_msg_v01),
                wds_embms_sai_list_query_resp_msg_v01*); 
  if (resp_msg != NULL)
  {
    memset(resp_msg, 0, sizeof(wds_embms_sai_list_query_resp_msg_v01));
  }
  else
  {
    wdsi_tmgi_send_response(cmd_buf_p, NULL, QMI_ERR_NO_MEMORY_V01,FALSE);
    return;
  }
  /*-------------------------------------------------------------------------
  Convert the throughput info retrieved from PS to wds sai structure
-------------------------------------------------------------------------*/
    
  if(!qmi_wdsi_convert_sai_info(ps_sai_list,
                                &resp_msg->freq_sai_list[0],
                                &resp_msg->freq_sai_list_len,
                                &resp_msg->freq_sai_list_ex[0],
                                &resp_msg->freq_sai_list_ex_len))
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }
  else
  {
    if(resp_msg->freq_sai_list_len)
    {
      resp_msg->freq_sai_list_valid = TRUE;
    }
    if(resp_msg->freq_sai_list_ex_len)
    {
      resp_msg->freq_sai_list_ex_valid = TRUE;
    }
  }
  /* -----------------------------------------------------------------------------
   * Non-modem initiated. Get request from pending queue and send response
   * ---------------------------------------------------------------------------*/

  ASSERT((cmd_buf_p->x_p != NULL) &&
         (cmd_buf_p->x_p->cl_sp == (qmi_common_client_state_type *)cl_sp));

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_EMBMS_SAI_LIST_QUERY_RESP_V01,
                               resp_msg,
                               sizeof(wds_embms_sai_list_query_resp_msg_v01),
                               errval,
                               &response);
  wdsi_tmgi_send_response(cmd_buf_p, response, errval,FALSE);
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
} /* qmi_wdsi_sai_list_ind() */

/*===========================================================================
FUNCTION   WDSI_COPY_SAI_LIST_FROM_EVENT()

DESCRIPTION
  This function allocates memory and copy the SAI(Service Area Identity) list
  from the event_info to the cmd_ptr event_info. 

PARAMETERS:
  event         : type of event
  event_info    : info ptr for the event
  cmd_ptr       : DCC command buffer ptr

DEPENDENCIES
  Called from wdsi_um_iface_cb()

RETURN VALUE
  TRUE: Operation is successful
  FALSE: Operation failed 

SIDE EFFECTS
  None
===========================================================================*/
static boolean wdsi_copy_sai_list_from_event
(
  ps_iface_event_enum_type   event,
  ps_iface_event_info_u_type * event_info,
  qmi_wdsi_cmd_buf_type      * cmd_ptr
)
{
  ps_iface_embms_frequency_sai_info   *sai_list = NULL;
  ps_iface_embms_frequency_sai_info   **sai_list_pp = NULL;
  uint8 num_frequencies = 0;

  ASSERT( event_info && cmd_ptr );

  /* Need to alloc memory and copy SAI list since the one in the
   * event_info will be freed after callback.
   */
  if ( event == IFACE_EMBMS_AVAILABLE_SAI_LIST_EV)
  {
    num_frequencies = event_info->embms_sai_list_ind_info.num_frequencies;
    sai_list        = event_info->embms_sai_list_ind_info.freq_sai_info;
    sai_list_pp     = &(cmd_ptr->data.iface_info.event_info.embms_sai_list_ind_info.freq_sai_info);
  }
  else
  {
    LOG_MSG_ERROR_1("Unknown event %d", event);
    return FALSE;
  }

  *sai_list_pp  = NULL; 

  if (num_frequencies > WDSI_MAX_SAI_NUM_FREQ)
  {
    LOG_MSG_ERROR_1("Invalid num Freq for SAI [%d]", num_frequencies);
    return FALSE;
  }

  if (num_frequencies > 0)
  {
    PS_SYSTEM_HEAP_MEM_ALLOC(*sai_list_pp,
                            num_frequencies * sizeof(ps_iface_embms_frequency_sai_info),
                            ps_iface_embms_frequency_sai_info*);
    if (*sai_list_pp != NULL)
    {
      memscpy(*sai_list_pp,
              num_frequencies * sizeof(ps_iface_embms_frequency_sai_info), 
              sai_list, 
              num_frequencies * sizeof(ps_iface_embms_frequency_sai_info));
    }
    else
    {
      return FALSE;
    }
  }
  return TRUE;

} /* wdsi_copy_sai_list_from_event() */
#endif /* FEATURE_DATA_EMBMS */

/*===========================================================================
FUNCTION WDSI_PROCESS_PROFILE_CHANGED_EVENT()

DESCRIPTION: This function is called from DCC task and is used to process
  Profile based events generated by DS_Profile.
  WDSI_PROFILE_CHANGED_EVENT_CB() posts a QMI command to
  handle these events in the DCC task. This function posts an
  indication to all the registered control points respectively.
 
PARAMETERS
  event             : DS_Profile event occurred
  profile_count     : Number of profiles on which the event occurred
  profiles_changes  : pointer to all the changed profiles data

RETURN VALUE
  ptr to response

DEPENDENCIES
  None

SIDE EFFECTS
  None
===========================================================================*/
static void wdsi_process_profile_changed_event
(
  ds_profile_event_etype              event,
  uint32                              profile_count,
  ds_profile_changes_info           * profiles_changes,
  uint32                              subs_id
)
{

  qmi_wdsi_client_state_type  * cl_sp     = NULL;
  qmi_wdsi_state_type *         wds_sp    = NULL;
  wds_profile_changed_ind_msg_v01   indication;
  uint8                         state;
  uint8                         inst;
  uint8                         mask;
  uint8                         profile_type;
  uint8                         profile_num;
  uint8                         cl_profile_type;
  uint8                         cl_profile_num;
  uint8                         num_configs;
  uint8                         index;
  uint8                         i;
  uint32                        cl_subs_id;

  LOG_MSG_INFO2("Processing Event: [%d], profile_count: [%d]", event,profile_count,0);

  if (profiles_changes == NULL)
  {
    DATA_ERR_FATAL("Profile Changes or client state or wds state is NULL!");
    return;
  }

  switch (event)
  {
    case DS_PROFILE_CREATE_PROFILE_EVENT:
    case DS_PROFILE_MODIFY_PROFILE_EVENT:
    case DS_PROFILE_DELETE_PROFILE_EVENT:
      break;

    case DS_PROFILE_RESET_PROFILE_EVENT:
      /* Mapping RESET_PROFILE_EVENT to MODIFY_PROFILE event to send out to client */
      event = DS_PROFILE_MODIFY_PROFILE_EVENT;
      break;

    default:
      LOG_MSG_INFO2("Invalid Event: [%d], Discarding event!", event,0,0);
      ASSERT(0);
      return;
  }
  memset(&indication,0,sizeof(wds_profile_changed_ind_msg_v01));
  /* Currently this callback support only one profile per callback.*/
  for (i=0; i < profile_count; i++)
  {
    profile_type = ( uint8 )profiles_changes[i].profile_tech;
    profile_num  = ( uint8 )profiles_changes[i].profile_num;
    indication.profile_changed_ind_valid = TRUE;
    indication.profile_changed_ind.profile_type= (wds_profile_type_enum_v01)profiles_changes[i].profile_tech;
    indication.profile_changed_ind.profile_index = ( uint8 )profiles_changes[i].profile_num;
    indication.profile_changed_ind.profile_change_evt = (wds_profile_changed_event_enum_v01)event;
    for( state = 0; state < WDSI_MAX_STATE; state++ )
    {
      for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
      {
        wds_sp = qmi_wds_state[state][inst];
        if (wds_sp == NULL)
        {
          continue;
        }

        cl_sp = wds_sp->client_list;
        
        while (cl_sp != NULL)
        {
          cl_subs_id = qmi_wdsi_resolve_client_subs(cl_sp);
          if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp) &&
             (TRUE == cl_sp->report_status.report_profile_change_events) &&
              qmi_wdsi_verify_client_subs(cl_sp, subs_id, FALSE))
          {
            if (cl_sp->config_evt_list.profile_change_evt_list != NULL)
            {
              mask = cl_sp->config_evt_list.report_on_tech_mask;
              num_configs = cl_sp->config_evt_list.profile_change_evt_list->num_configs;

              LOG_MSG_INFO2 ("Profile_Change_List configured, mask:(%d), num_configs: (%d)",
                             mask, num_configs , 0);
              if (mask)
              {
                if ((mask == QMI_WDS_MASK_PROFILE_ALL) ||
                   ((mask & QMI_WDS_MASK_PROFILE_3GPP) && (profile_type == DS_PROFILE_TECH_3GPP)) ||
                   ((mask & QMI_WDS_MASK_PROFILE_3GPP2) && (profile_type == DS_PROFILE_TECH_3GPP2)) ||
                   ((mask & QMI_WDS_MASK_PROFILE_EPC) && (profile_type == DS_PROFILE_TECH_EPC)))
                {
                  LOG_MSG_INFO2 ("Sending [%d] Event indication to clid: %d",
                                 event,cl_sp->common.clid,0);
                  qmi_wdsi_send_ind(wds_sp, cl_sp, QMI_WDS_PROFILE_EVENT_REGISTER_IND_V01,
                          sizeof(wds_profile_changed_ind_msg_v01),&indication,TRUE);
                }
              }
              else
              {
                 /* Check if this client is configured to recieve indications on the modified profile */
                for (index = 0; index < num_configs; index++)
                {
                  cl_profile_type = cl_sp->config_evt_list.profile_change_evt_list->config_tuple[index].profile_type;
                  cl_profile_num = cl_sp->config_evt_list.profile_change_evt_list->config_tuple[index].profile_num;

                  if (profile_type == cl_profile_type && profile_num == cl_profile_num)
                  {
                    LOG_MSG_INFO2 ("Sending [%d] Event indication to clid: %d",
                                   event,cl_sp->common.clid,0);
                    qmi_wdsi_send_ind(wds_sp, cl_sp, QMI_WDS_PROFILE_EVENT_REGISTER_IND_V01, 
                             sizeof(wds_profile_changed_ind_msg_v01),&indication,TRUE);
                    break;
                  }
                }/*End of for - num_configs*/
              }/*Else - mask*/
            }/*NULL check - config_evt_list.profile_change_evt_list*/
          }
          cl_sp = cl_sp->next;

        }/*While- cl_sp*/

      }/*For- qmi_instances*/

    }/*For- wds_states*/

  }/*For- profile_count*/
  for (i=0; i< profile_count; i++)
  {
    if (profiles_changes[i].changed_idents_array)
    {
      PS_SYSTEM_HEAP_MEM_FREE(profiles_changes[i].changed_idents_array);
    }
    
  }
  PS_SYSTEM_HEAP_MEM_FREE(profiles_changes);

}/* wdsi_process_profile_changed_event*/
/*===========================================================================
FUNCTION WDSI_PROFILE_CHANGE_CB()

DESCRIPTION: This callback function is called when profile based events
  happen on any Profile. An indication will be sent to
  registered clients.
 
PARAMETERS
  event             : DS_Profile event occurred
  profile_count     : Number of profiles on which the event occurred
  profiles_changes  : pointer to all the changed profiles data
  user_data         : data passed during callback registeration

RETURN VALUE
  ptr to response

DEPENDENCIES
  None

SIDE EFFECTS
  None
===========================================================================*/
static void wdsi_profile_change_cb
(
  ds_profile_event_etype            event,
  unsigned int                      profile_count,
  ds_profile_changes_info         * profiles_changes,
  void                            * user_data,
  ds_profile_subs_etype             subs_id
)
{
  qmi_wdsi_cmd_buf_type * cmd_ptr;
  ds_profile_changes_info* wds_profiles_changes = NULL;
  unsigned int count = 0;
  unsigned int i = 0;


  LOG_MSG_INFO2("Profile Change Event: [%d] Recieved!", event,0,0);

  if (profile_count == 0)
  {
    LOG_MSG_INFO2("Profile Count is 0, Not posting cmd to dcc!", 0,0,0);
    return;
  }

  if (profiles_changes == NULL)
  {
    DATA_ERR_FATAL("Profile Changes or client state or wds state is NULL!");
    return;
  }

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)
                 qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_PROFILE_CHANGED_EVT);
  if( cmd_ptr == NULL)
  {
    return;
  }

  /* user_data field is not used currently */
  memset(cmd_ptr, 0, sizeof(qmi_wdsi_cmd_buf_type));
  cmd_ptr->cmd_id = QMI_CMD_WDS_PROFILE_CHANGED_EVT;

  cmd_ptr->data.profile_evt_info.event            = event;
  cmd_ptr->data.profile_evt_info.profile_count    = profile_count;
  cmd_ptr->subscription_id                        = (uint32)subs_id;

  PS_SYSTEM_HEAP_MEM_ALLOC(wds_profiles_changes,
                           sizeof( ds_profile_changes_info) * profile_count,
                           ds_profile_changes_info*);
  if( wds_profiles_changes == NULL )
  {
    qmi_wdsi_free_cmd_buf(cmd_ptr);
    return;
  }
  memset(wds_profiles_changes,0x0,sizeof( ds_profile_changes_info) * profile_count);
  for(i=0;i<profile_count;i++)
  {
    count = profiles_changes[i].idents_num;
    if (0 != count)
    {
      PS_SYSTEM_HEAP_MEM_ALLOC(wds_profiles_changes[i].changed_idents_array,
	  	                       sizeof( ds_profile_identifier_type) * count,
                               ds_profile_identifier_type*);
   
      if (NULL == wds_profiles_changes[i].changed_idents_array)
      {
        LOG_MSG_INFO2( "FAIL to Allocate wds change profiles", 0, 0, 0 );  
        for (i=0; i< profile_count; i++)
        {
          if (wds_profiles_changes[i].changed_idents_array)
          {
             PS_SYSTEM_HEAP_MEM_FREE(wds_profiles_changes[i].changed_idents_array);
          }
        }
        PS_SYSTEM_HEAP_MEM_FREE(wds_profiles_changes);
        qmi_wdsi_free_cmd_buf(cmd_ptr);
        return;
      }

      memset(profiles_changes[i].changed_idents_array, 0, 
             sizeof( ds_profile_identifier_type) * count);
    }
    memscpy(wds_profiles_changes[i].changed_idents_array,
            sizeof( ds_profile_identifier_type) * count,
            profiles_changes[i].changed_idents_array,
            sizeof( ds_profile_identifier_type) * count);
    wds_profiles_changes[i].idents_num = profiles_changes[i].idents_num;
    wds_profiles_changes[i].profile_num = profiles_changes[i].profile_num;
    wds_profiles_changes[i].profile_tech = profiles_changes[i].profile_tech;
  }
  cmd_ptr->data.profile_evt_info.profiles_changes = wds_profiles_changes;
  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);

} /*wdsi_profile_change_cb*/

/*===========================================================================
FUNCTION QMI_WDSI_CONFIGURE_PROFILE_EVENT_LIST()

DESCRIPTION:  Configures the profile event list for the control point. This
  function also registers with DS_Profile layer to recieve
  profile based events. The configured profile event list is
  overridden everytime a new valid request to configure a list
  comes in.

PARAMETERS
  sp        : service provided state pointer
  cmd_buf_p : ptr to cmd buffer
  cl_sp     : client state pointer
  sdu_in    : incoming request

RETURN VALUE
  ptr to response
 
DEPENDENCIES
  None

SIDE EFFECTS
  None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_configure_profile_event_list
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *               response;
  wds_config_profile_list_req_msg_v01 *req_msg = NULL;
  wds_config_profile_list_resp_msg_v01 resp_msg;
  uint16             register_set_len = 0;
  uint8              i = 0;
  ds_profile_tech_etype       index;
  qmi_error_type_v01   errval;
  qmi_wdsi_client_state_type  * client_sp;

  ds_profile_status_etype           profile_status;
  ds_profile_hndl_type              profile_hndl;

  uint8 profile_type = 0;
  uint8 profile_num = 0;
  uint8 new_tech_mask = 0;
  uint32 subs_id = 0;

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval      = QMI_ERR_NONE_V01;
  profile_status = DS_PROFILE_REG_RESULT_SUCCESS;
  memset(&profile_hndl, 0, sizeof(profile_hndl));
  memset(&resp_msg,0,sizeof(resp_msg));

  PS_SYSTEM_HEAP_MEM_ALLOC(req_msg,
                           sizeof(wds_config_profile_list_req_msg_v01),
                           wds_config_profile_list_req_msg_v01*);
  if(req_msg == NULL)
  {
    qmi_svc_put_result_tlv(&response, (qmi_result_e_type)QMI_RESULT_FAILURE_V01,
                          (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
    return response;
  }
  else
  {
    memset(req_msg,0,sizeof(wds_config_profile_list_req_msg_v01));
  }

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_CONFIGURE_PROFILE_EVENT_LIST_REQ_V01,
                                       sdu_in,
                                       req_msg,
                                       sizeof(wds_config_profile_list_req_msg_v01));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  client_sp = (qmi_wdsi_client_state_type *) cl_sp;

  /*-----------------------------------------------------------------------
    Perform validity checks
  -----------------------------------------------------------------------*/

  if((req_msg->profile_event_register_valid != TRUE && req_msg->profile_event_register_len == 0))
  {
    LOG_MSG_INFO1_0("Removing previous configured spec!");
    if (client_sp->config_evt_list.profile_change_evt_list != NULL)
    {
      PS_SYSTEM_HEAP_MEM_FREE(client_sp->config_evt_list.profile_change_evt_list);
      client_sp->config_evt_list.report_on_tech_mask = 0;
    }
    goto send_result;
  }

  subs_id = qmi_wdsi_resolve_client_subs(client_sp);

  for (i=0; i < req_msg->profile_event_register_len; i++)
  {
    profile_type = req_msg->profile_event_register[i].profile_type;
    profile_num  = req_msg->profile_event_register[i].profile_index;

    /*Special case to report events on all technologies, for all valid profiles*/
    if (profile_type == WDSI_PROFILE_EVENT_ALL)
    {
      new_tech_mask = QMI_WDS_MASK_PROFILE_ALL;
      break;
    }

    else if (profile_num == WDSI_PROFILE_EVENT_ALL)
    {
      switch (profile_type)
      {
         case DS_PROFILE_TECH_3GPP:
           new_tech_mask |= QMI_WDS_MASK_PROFILE_3GPP;
           break;

         case DS_PROFILE_TECH_3GPP2:
           new_tech_mask |= QMI_WDS_MASK_PROFILE_3GPP2;
           break;

         case DS_PROFILE_TECH_EPC:
           new_tech_mask |= QMI_WDS_MASK_PROFILE_EPC;
           break;

         default:
           LOG_MSG_INFO2 ("Invalid Profile Type: (%d) ",profile_type,0,0);
           errval = QMI_ERR_INVALID_PROFILE_V01;
           goto send_result;
      }
    }
    else
    {
      /*Validating here each profile_type and profile_num with DS_Profile*/ 

      /*Begin transaction allocates a profile_hndl and validates internally
        with DS_Profile*/
      profile_status = 
        ds_profile_begin_transaction_per_sub
        (DS_PROFILE_TRN_READ, 
        (ds_profile_tech_etype)profile_type,
        (ds_profile_num_type)profile_num,
        (ds_profile_subs_etype)subs_id,
         &profile_hndl);

      /*If profile doesn't exist, return QMI error Invalid profile */
      if (profile_status != DS_PROFILE_REG_RESULT_SUCCESS)
      {
        LOG_MSG_ERROR ("Begin Transaction failed. Error %d", profile_status, 0, 0);
        errval = QMI_ERR_INVALID_PROFILE_V01;
        goto send_result;
      }

      /*Free the allocated DS-Profile handle */
      (void)ds_profile_end_transaction(profile_hndl, 
                                       DS_PROFILE_ACTION_CANCEL);
    }
  }
  register_set_len = sizeof(wds_profile_event_register_type_v01)*(req_msg->profile_event_register_len);
  if (client_sp->config_evt_list.profile_change_evt_list != NULL)
  {
    LOG_MSG_INFO2 ("Replace old config list with new list for this client "
                   "num_configs: %d, previous mask: %d, new mask: %d",
                   req_msg->profile_event_register_len,
                   client_sp->config_evt_list.report_on_tech_mask,
                   new_tech_mask);

    PS_SYSTEM_HEAP_MEM_FREE(client_sp->config_evt_list.profile_change_evt_list);
    client_sp->config_evt_list.report_on_tech_mask = 0;
  }

  PS_SYSTEM_HEAP_MEM_ALLOC (client_sp->config_evt_list.profile_change_evt_list, 
                            register_set_len, void*);

  if ( client_sp->config_evt_list.profile_change_evt_list == NULL)
  {
    errval = QMI_ERR_NO_MEMORY_V01;
    goto send_result;
  }

  memset( client_sp->config_evt_list.profile_change_evt_list, 0, register_set_len );

  /*Register DS-Profile callback for profile change events if the request 
    came to modem for the first time. */

  if (!qmi_wdsi_global.profile_reg_list.is_registered_ds_profile_events)
  {
    LOG_MSG_INFO2_0("Registering with DS_PROFILE for profile based events");

    for ( index = DS_PROFILE_TECH_MIN; index < DS_PROFILE_TECH_MAX; index++ )
    {
      for (subs_id = 0; subs_id < DS_PROFILE_ACTIVE_SUBSCRIPTION_MAX; subs_id++)
      {
        qmi_wdsi_global.profile_reg_list.ds_reg_profile_hndl_list[index][subs_id] = 
           ds_profile_register_callback_per_sub(DS_PROFILE_UNSPECIFIED_NUM,
                                      (ds_profile_tech_etype) index,
                                      wdsi_profile_change_cb,
                                      NULL,
                                      (ds_profile_subs_etype)(subs_id + 1));
        if( !qmi_wdsi_global.profile_reg_list.ds_reg_profile_hndl_list[index][subs_id])
      {
          LOG_MSG_INFO2_0("Error configuring profile event registration!");
        errval = QMI_ERR_INTERNAL_V01;
        goto send_result;
      } 
    }
    }
    qmi_wdsi_global.profile_reg_list.is_registered_ds_profile_events = TRUE;
  }
  for (i=0; i < req_msg->profile_event_register_len; i++)
  {
    client_sp->config_evt_list.profile_change_evt_list->config_tuple[i].profile_type = 
           req_msg->profile_event_register[i].profile_type;
    client_sp->config_evt_list.profile_change_evt_list->config_tuple[i].profile_num = 
           req_msg->profile_event_register[i].profile_index;
  }
  client_sp->config_evt_list.profile_change_evt_list->num_configs = 
                                   req_msg->profile_event_register_len;
  client_sp->config_evt_list.report_on_tech_mask = new_tech_mask;

send_result:
  PS_SYSTEM_HEAP_MEM_FREE(req_msg);
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_CONFIGURE_PROFILE_EVENT_LIST_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_configure_profile_event_list */

/*===========================================================================
  FUNCTION QMI_WDSI_SET_THROUGHPUT_INFO_IND_FREQ()

  DESCRIPTION
    Sets the throughput info timer(in milliseconds) by calling into the
    PS SYS layer. This timer is used to generate the rate at which
    throughput information is generated.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_set_throughput_info_ind_freq
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_set_throughput_info_ind_freq_req_msg_v01  req_msg;
  wds_set_throughput_info_ind_freq_resp_msg_v01  resp_msg;
  qmi_error_type_v01      errval = QMI_ERR_NONE_V01;
  int16                   return_val;
  int16                 ps_errno = DS_ENOERR;
  
#define WDSI_TRPT_TIMER_DEFAULT       (1000)
#define WDSI_TRPT_TIMER_MIN           (50)

  ps_sys_conf_throughput_timer_type        trpt_info_timer;
  uint32                                   subscription_id = 0;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&trpt_info_timer, 0, sizeof(ps_sys_conf_throughput_timer_type));
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_THROUGHPUT_INFO_IND_FREQ_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  response = NULL;
  errval = QMI_ERR_NONE_V01;

  if (req_msg.report_interval_valid)
  {
    if (req_msg.report_interval < WDSI_TRPT_TIMER_MIN && req_msg.report_interval != 0)
    {
      errval = QMI_ERR_INVALID_ARG_V01;
      LOG_MSG_INFO2_1("Invalid interval input %d ", req_msg.report_interval);
      goto send_result;
    }
    trpt_info_timer = req_msg.report_interval;
  }
  else
  {
    /* Send default timer interval if input TLV is not present*/
    trpt_info_timer = WDSI_TRPT_TIMER_DEFAULT;
  }
 
  subscription_id = qmi_wdsi_resolve_client_subs(cl_sp);

  return_val = ps_sys_conf_set_ex(PS_SYS_TECH_ALL,
                                  PS_SYS_CONF_THROUGHPUT_INFO_TIMER,
                                  (ps_sys_subscription_enum_type) subscription_id,
                                  &trpt_info_timer,
                                  &ps_errno);

  if (return_val != DSS_SUCCESS)
  {
    LOG_MSG_ERROR_2("ps_sys_conf_set ret [%d] errno [%d]", 
                    return_val, ps_errno);

    switch (ps_errno)
    {
      case DS_NOMEMORY:
        errval = QMI_ERR_NO_MEMORY_V01;
        break;
      case DS_EOPNOTSUPP:
      case DS_EINVAL:
         errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
      default:
        errval = QMI_ERR_INTERNAL_V01;
        break;
    }
  }

  send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_THROUGHPUT_INFO_IND_FREQ_REQ_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;

} /* qmi_wdsi_set_throughput_info_ind_freq */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_LAST_THROUGHPUT_INFO()

  DESCRIPTION
    Queries for the last reported throughput information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_last_throughput_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *                     response;
  qmi_error_type_v01                    errval;
  int16                               ps_errno = 0;
  int16                               return_val;
  ps_sys_throughput_info_list_type     * ps_trpt_info = NULL;
  uint32                                 subscription_id = 0;
  wds_get_last_throughput_info_resp_msg_v01 *resp_msg;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
 
  PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg, sizeof(wds_get_last_throughput_info_resp_msg_v01),
               wds_get_last_throughput_info_resp_msg_v01*);

  if (resp_msg == NULL)
  {
    qmi_svc_put_result_tlv(&response,(qmi_result_e_type)QMI_RESULT_FAILURE_V01, 
                          (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
    return response;
  }
  memset(resp_msg,0,sizeof(wds_get_last_throughput_info_resp_msg_v01));
  PS_SYSTEM_HEAP_MEM_ALLOC(ps_trpt_info, sizeof(ps_trpt_info->num_trpt_info) +
               PS_SYS_MAX_NUM_THROUGHPUT_INFO * sizeof(ps_sys_throughput_info_type),
               ps_sys_throughput_info_list_type*);

  if (ps_trpt_info == NULL)
  {
    goto send_result;
  }
  memset(ps_trpt_info, 0, sizeof(ps_trpt_info->num_trpt_info) +
    PS_SYS_MAX_NUM_THROUGHPUT_INFO * sizeof(ps_sys_throughput_info_type));

  subscription_id = qmi_wdsi_resolve_client_subs(cl_sp);
  /*-------------------------------------------------------------------------
    Retrieve attach pdn list information by calling into PS Sys Layer
  -------------------------------------------------------------------------*/
  return_val = ps_sys_conf_get_ex(PS_SYS_TECH_ALL,
                                  PS_SYS_CONF_THROUGHPUT_INFO,
                                  (ps_sys_subscription_enum_type) subscription_id,
                                  (void *)ps_trpt_info,
                                  &ps_errno);

  if (return_val != DSS_SUCCESS)
  {
    LOG_MSG_ERROR_2("ps_sys_conf_get ret [%d] errno [%d]", return_val, ps_errno);
    switch (ps_errno)
    {
      case DS_NOMEMORY:
        errval = QMI_ERR_NO_MEMORY_V01;
        break;
      case DS_EOPNOTSUPP:
      case DS_EINVAL:
        errval = QMI_ERR_INFO_UNAVAILABLE_V01;
        break;
      default:
        errval = QMI_ERR_INTERNAL_V01;
        break;
    }
    goto send_result;
  }
 
  /*-------------------------------------------------------------------------
    Convert the throughput info retrieved from PS to wds thrpt structure
  -------------------------------------------------------------------------*/
  if(!qmi_wdsi_convert_throughput_info(ps_trpt_info,
                                       &resp_msg->throughput_info_len, 
                                       resp_msg->throughput_info))
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }
  else
  {
    resp_msg->throughput_info_valid = TRUE;
  }

  send_result:
    PS_SYSTEM_HEAP_MEM_FREE(ps_trpt_info);
    QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_LAST_THROUGHPUT_INFO_RESP_V01,
                                   resp_msg,
                                   sizeof(wds_get_last_throughput_info_resp_msg_v01),
                                   errval,
                                   &response);
    PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  return response;
  
} /* qmi_wdsi_get_last_throughput_info */

/*===========================================================================
  FUNCTION QMI_WDSI_THRPT_INFO_CHANGE_CB()

  DESCRIPTION
    This the callback that we have registered with PS Sys layer for
    throughput info event

  PARAMETERS
    tech_type      : technology for which system status has changed
    event_name     : Event name
    event_info_ptr : List of thrpughput information
    user_data_ptr  : Optional user data to be sent.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_thrpt_info_change_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
  ps_sys_throughput_info_list_type         * wds_thrpt_info_list;
  ps_sys_throughput_info_list_type           * ps_trpt_info_list;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(event_info_ptr);
  ps_trpt_info_list = (ps_sys_throughput_info_list_type *)event_info_ptr;
  
  if (ps_trpt_info_list->num_trpt_info > PS_SYS_MAX_NUM_THROUGHPUT_INFO)
  {
    LOG_MSG_ERROR_1("Max thrpt reached %d", ps_trpt_info_list->num_trpt_info);
    return;
  }    
  
  LOG_MSG_INFO2_1("Num thrpt info %d", ps_trpt_info_list->num_trpt_info);
  cmd_ptr = (qmi_wdsi_cmd_buf_type *)
              qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_THRPT_INFO_EVT);

  if( cmd_ptr == NULL)
  {
    return;
  }

  PS_SYSTEM_HEAP_MEM_ALLOC(wds_thrpt_info_list, sizeof(ps_trpt_info_list->num_trpt_info) + 
                       ps_trpt_info_list->num_trpt_info * sizeof(ps_sys_throughput_info_type),
                       ps_sys_throughput_info_list_type*); 
  
  if (wds_thrpt_info_list == NULL)
  {
    qmi_wdsi_free_cmd_buf(cmd_ptr);
    return;
  }

  memset(wds_thrpt_info_list, 0, sizeof(ps_trpt_info_list->num_trpt_info) +
         ps_trpt_info_list->num_trpt_info * sizeof(ps_sys_throughput_info_type));

  memscpy(wds_thrpt_info_list,
          sizeof(ps_trpt_info_list->num_trpt_info) + \
          ps_trpt_info_list->num_trpt_info * sizeof(ps_sys_throughput_info_type),
          ps_trpt_info_list,
          sizeof(ps_trpt_info_list->num_trpt_info) + \
          ps_trpt_info_list->num_trpt_info * sizeof(ps_sys_throughput_info_type));
  cmd_ptr->cmd_id = QMI_CMD_WDS_THRPT_INFO_EVT;
  cmd_ptr->data.thrpt_info_list = wds_thrpt_info_list;
  cmd_ptr->subscription_id = subscription_id;

  dcc_send_cmd_ex (DCC_QMI_CMD, cmd_ptr);
} /* qmi_wdsi_thrpt_info_change_cb() */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_THRPT_INFO_CHANGE_IND()

DESCRIPTION
    Used to indicate change notifications in throughput info list

PARAMETERS
    thrpt_info_list    : Throughput info list

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_thrpt_info_change_ind
(
  ps_sys_throughput_info_list_type  * thrpt_info_list,
  uint32                              subscription_id
)
{
  qmi_wdsi_state_type *         wds_sp;
  qmi_wdsi_client_state_type *  cl_sp;
  uint8                         state;
  uint8                         inst;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }

      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
        {
          if (cl_sp->report_status.report_thrpt_info_change &&
              qmi_wdsi_verify_client_subs(cl_sp, subscription_id, FALSE))
          {
            qmi_wdsi_thrpt_info_list_change_ind(wds_sp, 
                                                cl_sp->common.clid,
                                                thrpt_info_list);
          }
        }
        cl_sp = cl_sp->next;
      } /* while */
    }
  }

  /* Free the memory allocated in callback fn*/
  PS_SYSTEM_HEAP_MEM_FREE(thrpt_info_list);
} /* qmi_wdsi_generate_thrpt_info_change_ind */

/*===========================================================================
  FUNCTION QMI_WDSI_THRPT_INFO_LIST_CHANGE_IND()

  DESCRIPTION
    Sends indication to clients registered for throughput info change

  PARAMETERS
    wds_sp                : service provided state pointer
    cl_id                 : client ID
    thrpt_info_list       : throughput info list

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_thrpt_info_list_change_ind
(
  qmi_wdsi_state_type *                 wds_sp,
  uint8                                 cl_id,
  ps_sys_throughput_info_list_type    * thrpt_info_list
)
{
  qmi_wdsi_client_state_type *        cl_sp;
  wds_throughput_info_ind_msg_v01*    indication;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(wds_sp && thrpt_info_list);

  /*-------------------------------------------------------------------------
    Build indication from the back to the front
  -------------------------------------------------------------------------*/
  cl_sp = qmi_wdsi_get_cl_sp_by_clid(wds_sp, cl_id);
  PS_SYSTEM_HEAP_MEM_ALLOC(indication, sizeof(wds_throughput_info_ind_msg_v01),
               wds_throughput_info_ind_msg_v01*);

  if (indication == NULL)
  {
    return;
  }
  memset(indication,0,sizeof(wds_throughput_info_ind_msg_v01));

  /*-------------------------------------------------------------------------
    Convert the throughput info retrieved from PS to wds thrpt structure
  -------------------------------------------------------------------------*/
  if(!qmi_wdsi_convert_throughput_info(thrpt_info_list,
                                       &indication->throughput_info_len, 
                                       indication->throughput_info))
  {
    LOG_MSG_ERROR_0("Converting wds thrpt failed ");
    PS_SYSTEM_HEAP_MEM_FREE(indication);
    return;
  }
  else
  {
    indication->throughput_info_valid  = TRUE;
  }

  if (FALSE == qmi_wdsi_send_ind(wds_sp,
                                 cl_sp,
                                 QMI_WDS_THROUGHPUT_INFO_IND_V01,
                                 sizeof(wds_throughput_info_ind_msg_v01),
                                 indication,
                                 TRUE))
  {
     LOG_MSG_INFO2_0("Unable to send thrpt info list change indication ");
  }
  PS_SYSTEM_HEAP_MEM_FREE(indication);
} /* qmi_wdsi_thrpt_info_list_change_ind() */
    
/*===========================================================================
  FUNCTION QMI_WDSI_CONVERT_THROUGHPUT_INFO()

  DESCRIPTION
    Converts the throughput info into QMI throughput info output strcuture

  PARAMETERS
   thrpt_info_list:   Input throughput info list from PS
   trpt_buf:          Buf to be written to
   trpt_buf_mem_size: Total allocated buf size
   total_buf_size:    Actual number of bytes written to buffer

  RETURN VALUE
    TRUE : Success
    FALSE : Failure

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_wdsi_convert_throughput_info
(
   ps_sys_throughput_info_list_type  *  thrpt_info_list,
   uint32                            *  throughput_info_len,
   wds_throughput_info_type_v01      *  thrpt_info
)
{
  int                                    bearer_cnt = 0;
  uint8                                  apn_len = 0;
  uint8                                  mux_id = 0;
  uint32                                 ep_id = 0;
  int                                    count = 0;
  wds_throughput_info_type_v01*          thrpt_info_ptr = NULL;
  uint32                                 ep_type = 0;
  uint32                                 peripheral_iface_id = 0;
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (thrpt_info_list == NULL ||
      throughput_info_len == NULL ||
      thrpt_info == NULL )
  {
    LOG_MSG_ERROR_0("Null parameter passed. Cannot write thrpt buf ");
    return FALSE;
  }
  *throughput_info_len = thrpt_info_list->num_trpt_info;
  if ( thrpt_info_list->num_trpt_info > PS_SYS_MAX_NUM_THROUGHPUT_INFO )
  {
    LOG_MSG_ERROR_1("Num thrpt info %d exceeded max. Cannot write out buf",
                    thrpt_info_list->num_trpt_info);
    return FALSE;
  }

  for (count = 0; count < thrpt_info_list->num_trpt_info; count++)
  {
    thrpt_info_ptr = &thrpt_info[count];
    apn_len = strlen(thrpt_info_list->trpt_info[count].apn_string);
    if (apn_len > PS_SYS_MAX_APN_LEN)
    {
      LOG_MSG_ERROR_1("apn len too large %d", apn_len);
      return FALSE;        
    }

    memscpy(thrpt_info_ptr->apn_string,
            sizeof(thrpt_info_ptr->apn_string),
            thrpt_info_list->trpt_info[count].apn_string,
            apn_len);

    thrpt_info_ptr->ip_type = (wds_ip_type_enum_v01)thrpt_info_list->trpt_info[count].ip_type;
    thrpt_info_ptr->tech_type = (wds_technology_type_enum_v01)thrpt_info_list->trpt_info[count].tech_type;
    thrpt_info_ptr->subscription = (wds_bind_subscription_enum_v01)thrpt_info_list->trpt_info[count].subscription;
    thrpt_info_ptr->uplink_actual_rate = thrpt_info_list->trpt_info[count].uplink_actual_rate;
    thrpt_info_ptr->uplink_allowed_rate = thrpt_info_list->trpt_info[count].uplink_allowed_rate;
    thrpt_info_ptr->uplink_queue_size = thrpt_info_list->trpt_info[count].uplink_queue_size;
    thrpt_info_ptr->throughput_signal = (wds_higher_throughput_enum_v01)thrpt_info_list->trpt_info[count].throughput_quality;
    thrpt_info_ptr->valid_port = WDS_END_POINT_ID_V01;
    /* SIO port ignored here */
    thrpt_info->data_port = 0;

    /* Retrieve ep type, iface id, mux id from RMNET */
    rmnet_meta_sm_get_ep_mux_id_by_um_iface(
      thrpt_info_list->trpt_info[count].iface_ptr,
      &ep_id,
      &mux_id);
    
    ep_type  = (ep_id & 0xFF000000) >> 24;
    thrpt_info_ptr->ep_id.ep_type= ep_type;
    peripheral_iface_id = (ep_id & 0x00FFFFFF);
    thrpt_info_ptr->ep_id.iface_id = peripheral_iface_id;
    thrpt_info_ptr->mux_id = mux_id;
    thrpt_info_ptr->bearer_rlp_mac_id_throughput_info_len = 
        thrpt_info_list->trpt_info[count].bearer_throughput_info_list.num_bearers;

    if ( thrpt_info_list->trpt_info[count].\
        bearer_throughput_info_list.num_bearers > DS_SYS_MAX_BEARER )
    {
      LOG_MSG_ERROR_1("Num bearer %d exceeded max !",thrpt_info_list->trpt_info[count].\
                      bearer_throughput_info_list.num_bearers);
      return FALSE;        
    }

    for (bearer_cnt = 0;bearer_cnt < thrpt_info_list->trpt_info[count].\
         bearer_throughput_info_list.num_bearers; bearer_cnt++)
    {
      thrpt_info_ptr->bearer_rlp_mac_id_throughput_info[bearer_cnt].bearer_rlp_mac_id = 
        thrpt_info_list->trpt_info[count].bearer_throughput_info_list.bearer_trpt_info[bearer_cnt].\
                         bearer_rlp_mac_id;
      thrpt_info_ptr->bearer_rlp_mac_id_throughput_info[bearer_cnt].uplink_actual_rate = 
       thrpt_info_list->trpt_info[count].bearer_throughput_info_list.bearer_trpt_info[bearer_cnt].\
                         bearer_uplink_actual_rate;
      thrpt_info_ptr->bearer_rlp_mac_id_throughput_info[bearer_cnt].uplink_queue_size =
       thrpt_info_list->trpt_info[count].bearer_throughput_info_list.bearer_trpt_info[bearer_cnt].\
                         bearer_uplink_queue_size;
      thrpt_info_ptr->bearer_rlp_mac_id_throughput_info[bearer_cnt].is_primary = 
       thrpt_info_list->trpt_info[count].bearer_throughput_info_list.bearer_trpt_info[bearer_cnt].\
                         is_default_bearer;
    }
  } 
  return TRUE;
} /* qmi_wdsi_convert_throughput_info */


/*===========================================================================
  FUNCTION QMI_WDSI_GET_ROAMING_INFO()

  DESCRIPTION
    Queries for the last reported roaming information.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_roaming_info
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
    dsm_item_type *       response;
    wds_get_roaming_info_resp_msg_v01* resp_msg = NULL;
    qmi_error_type_v01      errval;

    ps_sys_subscription_enum_type             subscription_id = 0;
    uint8                                     index           = 0;
    uint8                                     temp_len        = 0;
    int16                                     ps_errno        = 0;
    int16                                     return_val      = 0;
    ps_sys_roaming_disallowed_info_type     * roaming_info_list = NULL;

    response = NULL;
    errval = QMI_ERR_NONE_V01;

    PS_SYSTEM_HEAP_MEM_ALLOC(resp_msg,
                           sizeof(wds_get_roaming_info_resp_msg_v01),
                           wds_get_roaming_info_resp_msg_v01*);
    if(resp_msg == NULL)
    {
      qmi_svc_put_result_tlv(&response, (qmi_result_e_type)QMI_RESULT_FAILURE_V01,
                            (qmi_error_e_type)QMI_ERR_NO_MEMORY_V01);
      return response;
    }
    else
    {
      memset(resp_msg,0,sizeof(wds_get_roaming_info_resp_msg_v01));
    }
	
    PS_SYSTEM_HEAP_MEM_ALLOC(roaming_info_list, sizeof(ps_sys_roaming_disallowed_info_type),
                             ps_sys_roaming_disallowed_info_type*);
    if (roaming_info_list == NULL)
    {
      goto send_result;
    }

    memset(roaming_info_list, 0, sizeof(ps_sys_roaming_disallowed_info_type));
    subscription_id = (ps_sys_subscription_enum_type)qmi_wdsi_resolve_client_subs(cl_sp);

    /*-------------------------------------------------------------------------
      Retrieve apn_list information by calling into PS Sys Layer
    -------------------------------------------------------------------------*/
    return_val = ps_sys_conf_get_ex(PS_SYS_TECH_3GPP,
                                    PS_SYS_CONF_3GPP_ROAMING_DISALLOWED_INFO,
                                    subscription_id,
                                    (void *)roaming_info_list,
                                    &ps_errno);
    if (return_val != DSS_SUCCESS)
    {
      LOG_MSG_ERROR_2("ps_sys_conf_get ret [%d] errno [%d]", return_val, ps_errno);
      switch (ps_errno)
      {
        case DS_NOMEMORY:
          errval = QMI_ERR_NO_MEMORY_V01;
          break;

        case DS_EOPNOTSUPP:
        case DS_EINVAL:
          errval = QMI_ERR_INFO_UNAVAILABLE_V01;
          break;

         default:
           errval = QMI_ERR_INTERNAL_V01;
           break;
      }
      goto send_result;
    }

    if (!(roaming_info_list->is_roaming_disallowed) || 
        roaming_info_list->num_apn_names == 0)
    {
        // return no APN info in response with success	
        LOG_MSG_INFO2_2("Roaming Disallowed: %d, Total APNs: %d", 
                        roaming_info_list->is_roaming_disallowed, 
                        roaming_info_list->num_apn_names);
        goto send_result;
    }
    else
    {
        LOG_MSG_INFO2_1("Num apn's in roaming:  %d", roaming_info_list->num_apn_names);
        resp_msg->roaming_apn_name_list_valid = TRUE;
        resp_msg->roaming_apn_name_list_len = roaming_info_list->num_apn_names;
        for (index = 0 ; index < roaming_info_list->num_apn_names; index++)
        {
          temp_len = strlen((char *)roaming_info_list->apn_list[index].apn_name);

          if (temp_len > PS_SYS_MAX_APN_LEN)
          {
            LOG_MSG_ERROR_0("Incorrect APN length!");
            errval = QMI_ERR_INTERNAL_V01;
            memset(resp_msg,0,sizeof(wds_get_roaming_info_resp_msg_v01));
            goto send_result; 
          }
          memscpy(resp_msg->roaming_apn_name_list[index].apn_name, 
                  sizeof(resp_msg->roaming_apn_name_list[index].apn_name), 
                  roaming_info_list->apn_list[index].apn_name, temp_len);
        }
    }
send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_ROAMING_INFO_RESP_V01,
                                 resp_msg,
                                 sizeof(wds_get_roaming_info_resp_msg_v01),
                                 errval,
                                 &response);
  if (roaming_info_list != NULL)
  {
    PS_SYSTEM_HEAP_MEM_FREE(roaming_info_list);
  }
  PS_SYSTEM_HEAP_MEM_FREE(resp_msg);
  return response;
}
 	


/*===========================================================================
  FUNCTION QMI_WDSI_ROAMING_INFO_CHANGE_CB()

  DESCRIPTION
    This the callback that we have registered with PS Sys layer for
    roaming info event

  PARAMETERS
    tech_type      : technology for which system status has changed
    event_name     : Event name
    event_info_ptr : List of roaming information
    user_data_ptr  : Optional user data to be sent.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_roaming_info_change_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type                      * cmd_ptr             = NULL;
  ps_sys_roaming_disallowed_info_type        * ps_roaming_info     = NULL;
  ps_sys_roaming_disallowed_info_type        * wds_ps_roaming_info = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(event_info_ptr);

  if (event_name != PS_SYS_EVENT_3GPP_ROAMING_DISALLOWED_INFO)
  {
      LOG_MSG_INFO2_1("Dropping packet, Incorrect event name:  %d", event_name);
  }

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)
              qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_ROAMING_INFO_EVT);

  if( cmd_ptr == NULL)
  {
    LOG_MSG_ERROR_0("Unable to allocate QMI WDS cmd buffer");
    return;
  }

  ps_roaming_info = (ps_sys_roaming_disallowed_info_type *) event_info_ptr;

  PS_SYSTEM_HEAP_MEM_ALLOC(wds_ps_roaming_info, sizeof(ps_sys_roaming_disallowed_info_type),
                           ps_sys_roaming_disallowed_info_type*);
  if (wds_ps_roaming_info == NULL)
  {
    qmi_wdsi_free_cmd_buf(cmd_ptr);    
    return;
  }

  memset(wds_ps_roaming_info, 
         0, 
         sizeof(ps_sys_roaming_disallowed_info_type));


  memscpy(wds_ps_roaming_info,
          sizeof(ps_sys_roaming_disallowed_info_type),
          ps_roaming_info, 
          sizeof(ps_sys_roaming_disallowed_info_type));

  cmd_ptr->cmd_id = QMI_CMD_WDS_ROAMING_INFO_EVT;
  cmd_ptr->data.roaming_info_list = wds_ps_roaming_info;
  cmd_ptr->subscription_id = subscription_id;

  dcc_send_cmd_ex (DCC_QMI_CMD, cmd_ptr);
} /* qmi_wdsi_roaming_info_change_cb() */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_ROAMING_INFO_CHANGE_IND()

DESCRIPTION
    Used to indicate change notifications in roaming info list

PARAMETERS
    roaming_info_list    : Roaming info list

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_roaming_info_change_ind
(
  ps_sys_roaming_disallowed_info_type        * roaming_info_list,
  uint32                                       subscription_id
)
{
  qmi_wdsi_state_type *                        wds_sp;
  qmi_wdsi_client_state_type *                 cl_sp;
  uint8                                        state;
  uint8                                        inst;
  uint8                                        index               = 0;
  uint8                                        temp_len            = 0;
  wds_roaming_info_ind_msg_v01               * indication;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (roaming_info_list == NULL) 
  {
    DATA_ERR_FATAL("Roaming Info List: NULL, No indication!");
  }
  if(roaming_info_list->num_apn_names <= 0)
  {
    PS_SYSTEM_HEAP_MEM_FREE(roaming_info_list); 
    return;
  }
  LOG_MSG_INFO2_1("Num apn's in roaming:  %d", roaming_info_list->num_apn_names);

  PS_SYSTEM_HEAP_MEM_ALLOC(indication,sizeof(wds_roaming_info_ind_msg_v01),
                            wds_roaming_info_ind_msg_v01*);

  if ( indication == NULL)
  {
    PS_SYSTEM_HEAP_MEM_FREE(roaming_info_list);
    return;
  }
  
  memset(indication,0,sizeof(wds_roaming_info_ind_msg_v01));
  indication->roaming_apn_name_list_valid = TRUE;
  indication->roaming_apn_name_list_len = roaming_info_list->num_apn_names;
  
  for (index = 0 ; index < roaming_info_list->num_apn_names; index++)
  {
    temp_len = 0;
    temp_len = strlen((char *)roaming_info_list->apn_list[index].apn_name);

    if (temp_len > PS_SYS_MAX_APN_LEN)
    {
      LOG_MSG_ERROR_0("Incorrect APN length!");
      PS_SYSTEM_HEAP_MEM_FREE(roaming_info_list);
      PS_SYSTEM_HEAP_MEM_FREE(indication);
      return;
    }
    memscpy(indication->roaming_apn_name_list[index].apn_name,
            sizeof(indication->roaming_apn_name_list[index].apn_name),
            roaming_info_list->apn_list[index].apn_name,
            temp_len);
  }
  
  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }

      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
        {
          if (cl_sp->report_status.report_roaming_info_change &&
              qmi_wdsi_verify_client_subs(cl_sp, subscription_id,FALSE))
          {
            qmi_wdsi_send_ind(wds_sp,
                              cl_sp,
                              QMI_WDS_ROAMING_INFO_IND_V01,
                              sizeof(wds_roaming_info_ind_msg_v01),
                              indication,
                              TRUE);
          }
        }
        cl_sp = cl_sp->next;
      } /* while */
    }
  }

  /* Free the memory allocated in callback fn*/
  PS_SYSTEM_HEAP_MEM_FREE(roaming_info_list);

  /*Free the allocated ind buffer*/
  PS_SYSTEM_HEAP_MEM_FREE(indication);
} /* qmi_wdsi_generate_roaming_info_change_ind */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_REV_IP_CONNECTED_IND()

DESCRIPTION
    Used to indicate reverse IP transport CONNECTED

PARAMETERS
    cl_sp    : Client to which indication needs to be sent

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_rev_ip_connected_ind
(
  void           * cl_sp
)
{
  wds_reverse_ip_transport_connection_ind_msg_v01  indication;

  qmi_wdsi_client_state_type *  wds_client_sp;
  qmi_wdsi_state_type *         wds_sp;

  memset(&indication,0,sizeof(wds_reverse_ip_transport_connection_ind_msg_v01));
  wds_client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);
  if ((wds_sp == NULL) ||
      (wds_sp->wlan_iface_ptr == NULL) ||
      (wds_sp->wlan_tx.conn != PS_IFACE_IOCTL_REVERSE_IP_TRANSPORT_CONNECTED))
  {
    LOG_MSG_ERROR_0("Invalid WDS sp or WLAN iface ptr or connection status ");
    return;
  }

  if (wdsi_add_rev_ip_connected_ind_params(wds_sp->wlan_iface_ptr, &indication))
  {
    ps_iface_name_enum_type      iface_name;
    iface_name = (ps_iface_name_enum_type)
            (PS_IFACE_GET_NAME_FROM_ID(PS_IFACE_GET_ID(wds_sp->wlan_iface_ptr)));    
    /* Add tech name, tx id and coonection status */
    indication.tech_name_valid  = TRUE;    
    indication.tech_name = (wds_technology_name_enum_v01)iface_name;
    indication.rev_ip_transport_conn_status = WDS_REVERSE_IP_TRANSPORT_CONNECTED_V01;
    indication.transaction_id = wds_sp->wlan_tx.wlan_tx_id;

    /* Send extra ind to client */
    qmi_wdsi_send_ind(wds_sp, cl_sp, QMI_WDS_REVERSE_IP_TRANSPORT_CONNECTION_IND_V01, 
            sizeof(wds_reverse_ip_transport_connection_ind_msg_v01),&indication,TRUE);
  }
}

#ifdef FEATURE_DATA_PS_DHCPV6
/*===========================================================================
  FUNCTION QMI_WDSI_REMOVE_DELEGATED_IPV6_PREFIX()

  DESCRIPTION
    This function removes the delegated prefixes from the prefix
    management table and free it up for further use by different
    host.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_remove_delegated_ipv6_prefix
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  wds_remove_delegated_ipv6_prefix_req_msg_v01 req_msg;
  wds_remove_delegated_ipv6_prefix_resp_msg_v01 resp_msg;
  qmi_error_type_v01      errval;
  int                   return_val = 0;
  int16                 ps_errno = DS_ENOERR;
  qmi_wdsi_state_type *  wds_sp;
  ps_iface_addr_family_type ip_family;
  boolean               remove_all_prefixes = TRUE;
  ps_iface_addr_mgmt_prefix_type ps_delegated_prefix;
  uint8                 prefix_count = 0;
  qmi_wdsi_client_state_type * client_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp =(qmi_wdsi_client_state_type *)cl_sp;
  response = NULL;
  errval = QMI_ERR_NONE_V01;

  memset(&ps_delegated_prefix, 0, sizeof(ps_iface_addr_mgmt_prefix_type));
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_REMOVE_DELEGATED_IPV6_PREFIX_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  if ( wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED )
  {
    LOG_MSG_INFO2_0("Call not up. Cannot remove_prefix");
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  if (!PS_IFACE_IS_VALID(wds_sp->um_iface_ptr)) 
  {
    LOG_MSG_INFO2_0("Invalid Um iface ptr");
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
   LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d", client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  ip_family = ps_iface_get_addr_family(wds_sp->um_iface_ptr);
  if(!ps_iface_addr_family_is_v6(wds_sp->um_iface_ptr))
  {
    LOG_MSG_ERROR_1("Invalid IP family %d", ip_family);
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }
  
  if (req_msg.ipv6_prefix.ipv6_prefix_length > WDSI_MAX_IPV6_PREFIX_LENGTH_IN_BITS)
  {
    LOG_MSG_ERROR_1("Invalid prefix length %d", req_msg.ipv6_prefix.ipv6_prefix_length);
    errval = QMI_ERR_INVALID_ARG_V01;
    goto send_result;
  }

  ps_delegated_prefix.prefix_len = req_msg.ipv6_prefix.ipv6_prefix_length;
  for (prefix_count = 0; prefix_count < WDSI_MAX_IPV6_PREFIX_LEN; prefix_count++)
  {
    ps_delegated_prefix.prefix.in6_u.u6_addr8[prefix_count] = 
      req_msg.ipv6_prefix.ipv6_addr[prefix_count];
  }
  if(!(req_msg.ipv6_prefix_valid))
  {
    remove_all_prefixes = FALSE;
  }
  /*---------------------------------------------------------------------------
    Remove the delegated IPV6 prefix
  ---------------------------------------------------------------------------*/
  return_val = ps_iface_addr_mgmt_remove_delegated_v6_prefixes(wds_sp->um_iface_ptr,
                                                               remove_all_prefixes,
                                                               ps_delegated_prefix,
                                                               &ps_errno);

  if (return_val < 0) 
  {
    LOG_MSG_ERROR_2("Cannot remove prefix, return_val %d, pserrno: %d", 
                     return_val, ps_errno); 

    switch (ps_errno)
    {
      case DS_NOMEMORY:
        errval = QMI_ERR_NO_MEMORY_V01;
        break;
      case DS_EFAULT:
         errval = QMI_ERR_INVALID_ARG_V01;
      default:
         errval = QMI_ERR_INTERNAL_V01;
         break;
    }
    goto send_result;
  }

  send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_REMOVE_DELEGATED_IPV6_PREFIX_REQ_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
}/* qmi_wdsi_remove_delegated_ipv6_prefix */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_DELEGATED_IPV6_PREFIX()

  DESCRIPTION
  This function generates a delegated prefix for the IPV6 client.

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_delegated_ipv6_prefix
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *       response;
  qmi_error_type_v01      errval;
  int                   return_val = 0;
  int16                 ps_errno = DS_ENOERR;
  qmi_wdsi_state_type *           wds_sp;
  ps_iface_addr_family_type       ip_family;
  struct ps_in6_addr              src_addr= {{{0},}};
  ps_iface_addr_mgmt_prefix_type ps_delegated_prefix;
  qmi_wdsi_client_state_type         * client_sp;
  uint8 prefix_count = 0;
  wds_get_delegated_ipv6_prefix_req_msg_v01 req_msg;
  wds_get_delegated_ipv6_prefix_resp_msg_v01 resp_msg;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&ps_delegated_prefix, 0, sizeof(ps_iface_addr_mgmt_prefix_type));

  wds_sp = (qmi_wdsi_state_type *) sp;
  client_sp = (qmi_wdsi_client_state_type *)cl_sp;
  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GET_DELEGATED_IPV6_PREFIX_REQ_V01,
                                       sdu_in,
                                      &req_msg,
                                      sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  if ( wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED )
  {
    LOG_MSG_INFO2_0("Call not up. Cannot get prefix");
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  if (!PS_IFACE_IS_VALID(wds_sp->um_iface_ptr)) 
  {
    LOG_MSG_INFO2_0("Invalid Um iface ptr");
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  if (!qmi_wdsi_verify_client_subs(client_sp, wds_sp->binding.subscription_id,
                                   TRUE))
  {
    LOG_MSG_ERROR_2( "Error: Client subs doesn't match current data call subs"
                    " Client subs %d Call subs %d",client_sp->subscription_id,
                     wds_sp->binding.subscription_id );
    errval = QMI_ERR_INCOMPATIBLE_STATE_V01;
    goto send_result;
  }

  ip_family = ps_iface_get_addr_family(wds_sp->um_iface_ptr);
  if(!ps_iface_addr_family_is_v6(wds_sp->um_iface_ptr))
  {
    LOG_MSG_ERROR_1("Invalid IP family %d", ip_family);
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }
  memscpy(src_addr.in6_u.u6_addr8,sizeof(src_addr.in6_u.u6_addr8),
          req_msg.src_ipv6_addr,sizeof(req_msg.src_ipv6_addr));
  /*---------------------------------------------------------------------------
    Generate the delegated IPV6 prefix
  ---------------------------------------------------------------------------*/
  return_val = ps_iface_addr_mgmt_generate_v6_prefix(wds_sp->um_iface_ptr, 
                                                     wds_sp->rmnet_iface_ptr,
                                                     &src_addr, 
                                                     &ps_delegated_prefix, 
                                                     &ps_errno); 
  
  if (return_val < 0)
  {
    LOG_MSG_ERROR_2("Cannot get prefix, return_val %d, ps_errno", 
                    return_val, ps_errno);

    switch (ps_errno)
    {
      case DS_NOMEMORY:
        errval = QMI_ERR_NO_MEMORY_V01;
        break;
      case DS_EPREFIXEXHAUSTED:
         errval = QMI_ERR_INSUFFICIENT_RESOURCES_V01;
      default:
         errval = QMI_ERR_INTERNAL_V01;
         break;
    }
    goto send_result;
  }
  resp_msg.ipv6_prefix_valid = TRUE;
  resp_msg.ipv6_prefix.ipv6_prefix_length = ps_delegated_prefix.prefix_len;
  for (prefix_count = 0; prefix_count < WDSI_MAX_IPV6_PREFIX_LEN; prefix_count++)
  {
    resp_msg.ipv6_prefix.ipv6_addr[prefix_count] = 
      ps_delegated_prefix.prefix.in6_u.u6_addr8[prefix_count];
  }

    /* clear guard timer as IP address queried in QMI */
    rmnet_v6_sm_clear_guard_timer(wds_sp->binding.rmnet_inst);

  send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_DELEGATED_IPV6_PREFIX_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_get_delegated_ipv6_prefix */
#endif /* FEATURE_DATA_PS_DHCPV6 */

/*===========================================================================
  FUNCTION QMI_WDS_GET_FC_STATS()

  DESCRIPTION
    This function retrieves WDS flow control stats

  PARAMETERS
    num_flow_enable: address of flow enable cnt
    num_flow_disable: address of flow disable cnt

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_wds_get_fc_stats
(
  uint32  * num_flow_enable,
  uint32  * num_flow_disable
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (num_flow_enable == NULL || num_flow_disable == NULL)
  {
    return;
  }

  *num_flow_enable = qmi_wdsi_global.num_flow_enable;
  *num_flow_disable = qmi_wdsi_global.num_flow_disable;

} /* qmi_qos_get_fc_stats() */

/*===========================================================================
  FUNCTION QMI_WDSI_BIND_SUBSCRIPTION()

  DESCRIPTION
    Bind the WDS client to a data subscription.
 
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp_in  : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_bind_subscription
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp_in,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              * response;
  wds_bind_subscription_req_msg_v01 req_msg;
  wds_bind_subscription_resp_msg_v01 resp_msg;
  qmi_wdsi_client_state_type * cl_sp;
  qmi_error_type_v01   errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cl_sp = (qmi_wdsi_client_state_type *)cl_sp_in;

  response = NULL;
  errval = QMI_ERR_NONE_V01;

  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_BIND_SUBSCRIPTION_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  if ((req_msg.subscription >= QMI_WDSI_SUBS_MAX || 
       req_msg.subscription < QMI_WDSI_SUBS_DEFAULT) &&
       req_msg.subscription != QMI_WDSI_SUBS_DONT_CARE)
  {
      LOG_MSG_ERROR_1("Invalid subs id %d",req_msg.subscription);
      errval = QMI_ERR_INVALID_ARG_V01;
      goto send_result;
  }

  cl_sp->subscription_id = (qmi_wdsi_subs_enum_type)req_msg.subscription;
  LOG_MSG_INFO1_2("Cl %d bound to subs %d", cl_sp->common.clid,
                   cl_sp->subscription_id);

send_result:

  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_BIND_SUBSCRIPTION_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;

} /* qmi_wdsi_bind_subscription() */

/*===========================================================================
FUNCTION QMI_WDSI_GET_BIND_SUBSCRIPTION()

  DESCRIPTION
    Queries for the data subscription of the client
 
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp_in  : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_get_bind_subscription
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp_in,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              * response;
  qmi_wdsi_client_state_type * cl_sp;
  qmi_error_type_v01   errval;
  wds_get_bind_subscription_resp_msg_v01 resp_msg;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  cl_sp = (qmi_wdsi_client_state_type *)cl_sp_in;

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&resp_msg,0,sizeof(resp_msg));
  resp_msg.subscription_valid = TRUE;
  resp_msg.subscription = (wds_bind_subscription_enum_v01)cl_sp->subscription_id;
  LOG_MSG_INFO1_2("cl %d retrieved ad subs %d", cl_sp->common.clid,
                   cl_sp->subscription_id);
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_BIND_SUBSCRIPTION_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;

} /* qmi_wdsi_get_bind_subscription() */

/*===========================================================================
  FUNCTION QMI_WDSI_VERIFY_CLIENT_SUBS()

  DESCRIPTION
    This function verifies if the client subscription is applicable to
    the event subscription.
 
  PARAMETERS
    cl_sp         : client state pointer
    event_subs_id : Subscription of the event
    call_specific : Identifies if the request is related to a data call

  RETURN VALUE
   TRUE : if the event is applicable to client
   FALSE: otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static boolean qmi_wdsi_verify_client_subs
(
  qmi_wdsi_client_state_type         * cl_sp,
  uint32                               event_subs_id,
  boolean                              call_specific
)
{
  boolean                             compare_result = FALSE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT(cl_sp);

  if (event_subs_id >= QMI_WDSI_SUBS_MAX || 
      event_subs_id <= QMI_WDSI_SUBS_DEFAULT)
  {
    //event subs should be valid for resolving
     LOG_MSG_ERROR_1( "Cannot resolve: Invalid subs passed %d", event_subs_id );
     return FALSE;
  }

  if (cl_sp->subscription_id == event_subs_id)
  {
    //Client subs and event subs match
    compare_result = TRUE;
    goto send_result;
  }

  if (event_subs_id == ps_sys_get_default_data_subscription())
  {
    if (cl_sp->subscription_id == QMI_WDSI_SUBS_DEFAULT ||
        cl_sp->subscription_id == QMI_WDSI_SUBS_DONT_CARE)
    {
      //Send to DDS and Don't care clients
      compare_result = TRUE;
      goto send_result;
    }
  }
  else
  {
    if (cl_sp->subscription_id == QMI_WDSI_SUBS_DONT_CARE &&
        call_specific == TRUE) 
    {
      //Send all call specific events to don't care clients
      compare_result = TRUE;
      goto send_result;
    }
  }

send_result:
  LOG_MSG_INFO1_4( "Cl %d subs %d, event subs %d compare_result %d", 
                   cl_sp->common.clid,
                   cl_sp->subscription_id, event_subs_id, compare_result );
  return compare_result;
}/* qmi_wdsi_verify_client_subs */

/*===========================================================================
  FUNCTION QMI_WDSI_RESOLVE_CLIENT_SUBS()

  DESCRIPTION
    This function resolves the client subscription.
 
  PARAMETERS
    cl_sp         : client state pointer

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
uint32 qmi_wdsi_resolve_client_subs
(
  void         * cl_sp
)
{
  qmi_wdsi_client_state_type *       client_sp;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT(cl_sp);

  client_sp = (qmi_wdsi_client_state_type *)cl_sp;

  if (client_sp->subscription_id == QMI_WDSI_SUBS_DONT_CARE || 
      client_sp->subscription_id == QMI_WDSI_SUBS_DEFAULT)
  {
    LOG_MSG_INFO3_1("Resolved cl subs to DDS subs_id = %d",
                     ps_sys_get_default_data_subscription());
    return ps_sys_get_default_data_subscription();
  }
  else
  {
    LOG_MSG_INFO3_1("Resolved cl subs as subs_id = %d",
                     client_sp->subscription_id);
    return(client_sp->subscription_id);
  }
}/* qmi_wdsi_resolve_client_subs */

/*===========================================================================
  FUNCTION QMI_WDSI_REG_PS_SYS_EVENTS()

  DESCRIPTION
    This function registers for PS system level events on all subscriptions 
    at boot up.
 
  PARAMETERS
    None

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_reg_ps_sys_events
(  
  void
)
{
  int                      sub_ind = 0;
  ps_sys_event_enum_type   event_id   = PS_SYS_EVENT_MIN;
  int16                    result;
  int16                    dss_errno;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for (sub_ind = PS_SYS_PRIMARY_SUBS; sub_ind < PS_SYS_SUBS_MAX; sub_ind++)
  {

    result = ps_sys_event_reg_ex(PS_SYS_TECH_ALL,
                                 PS_SYS_EVENT_SYSTEM_STATUS_CHANGE,
                                 (ps_sys_subscription_enum_type)sub_ind,
                                 wdsi_data_system_status_change_cb,
                                 NULL,
                                 &dss_errno);
    if (result < 0)
    {
      event_id = PS_SYS_EVENT_SYSTEM_STATUS_CHANGE;
      break;
    }

    result = ps_sys_event_reg_ex(PS_SYS_TECH_ALL,
                                 PS_SYS_EVENT_DUN_CTRL_ENTITLEMENT_CHECK,
                                 (ps_sys_subscription_enum_type)sub_ind,
                                 qmi_wdsi_entitlement_cb,
                                 NULL,
                                 &dss_errno);
    if(result < 0)
    {
      event_id = PS_SYS_EVENT_DUN_CTRL_ENTITLEMENT_CHECK;
      break;
    }

    result = ps_sys_event_reg_ex(PS_SYS_TECH_ALL,
                                 PS_SYS_EVENT_DUN_CTRL_SILENT_REDIAL_CHECK,
                                 (ps_sys_subscription_enum_type)sub_ind,
                                 qmi_wdsi_silent_redial_cb,
                                 NULL,
                                 &dss_errno);
    if(result < 0)
    {
        event_id = PS_SYS_EVENT_DUN_CTRL_SILENT_REDIAL_CHECK;
        break;
    }

  #ifdef FEATURE_DATA_LTE
    result = ps_sys_event_reg_ex(PS_SYS_TECH_3GPP,
                                 PS_SYS_EVENT_3GPP_LTE_ATTACH_PDN_LIST_CHANGE,
                                 (ps_sys_subscription_enum_type)sub_ind,
                                 qmi_wdsi_lte_attach_pdn_list_change_cb,
                                 NULL,
                                 &dss_errno);
    if(result < 0)
    {
        event_id = PS_SYS_EVENT_3GPP_LTE_ATTACH_PDN_LIST_CHANGE;
        break;
    }
  #endif /* FEATURE_DATA_LTE */

    result = ps_sys_event_reg_ex(PS_SYS_TECH_ALL,
                                 PS_SYS_EVENT_THROUGHPUT_INFO,
                                 (ps_sys_subscription_enum_type)sub_ind,
                                 qmi_wdsi_thrpt_info_change_cb,
                                 NULL,
                                 &dss_errno);
    if(result < 0)
    {
        event_id = PS_SYS_EVENT_THROUGHPUT_INFO;
        break;
    }

    result = ps_sys_event_reg_ex(PS_SYS_TECH_3GPP,
                                 PS_SYS_EVENT_3GPP_ROAMING_DISALLOWED_INFO,
                                 (ps_sys_subscription_enum_type)sub_ind,
                                 qmi_wdsi_roaming_info_change_cb,
                                 NULL,
                                 &dss_errno);
    if(result < 0)
    {
        event_id = PS_SYS_EVENT_3GPP_ROAMING_DISALLOWED_INFO;
        break;
    }

    result = ps_sys_event_reg_ex(PS_SYS_TECH_3GPP2,
                                 PS_SYS_EVENT_3GPP2_OUTAGE_NOTIFICATION,
                                 (ps_sys_subscription_enum_type)sub_ind,
                                 qmi_wdsi_outage_notification_cb,
                                 NULL,
                                 &dss_errno);
    if(result < 0)
    {
        event_id = PS_SYS_EVENT_3GPP2_EVDO_PAGE_MONITOR_PERIOD_CHANGE;
        break;
    }
   #if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
    result = ps_sys_event_reg_ex(PS_SYS_TECH_3GPP2,
                                 PS_SYS_EVENT_3GPP2_EVDO_PAGE_MONITOR_PERIOD_CHANGE,
                                 (ps_sys_subscription_enum_type)sub_ind,
                                 qmi_wdsi_evdo_page_monitor_period_changed_cb,
                                 NULL,
                                 &dss_errno);
    if(result < 0)
    {
        event_id = PS_SYS_EVENT_3GPP2_EVDO_PAGE_MONITOR_PERIOD_CHANGE;
        break;
    }
    #endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */ 
   
    result = ps_sys_event_reg_ex(PS_SYS_TECH_ALL,
                                 PS_SYS_EVENT_DL_THROUGHPUT_INFO,
                                 (ps_sys_subscription_enum_type)sub_ind,
                                 qmi_wdsi_dl_thrpt_info_change_cb,
                                 NULL,
                                 &dss_errno);
    if(result < 0)
    {
        event_id = PS_SYS_EVENT_THROUGHPUT_INFO;
        break;
    }
  } /* end for */

  if(result < 0)
  {
    LOG_MSG_ERROR_2("Couldn't reg for ps sys event_id = %d Err : (%d)",
                    event_id, dss_errno);
    ASSERT(0);
    return;
  }

}/* qmi_wdsi_reg_ps_sys_events */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_CAPABILITIES()

  DESCRIPTION
    Queries the modem capabilities

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_capabilities
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *                     response;
  wds_get_capabilities_req_msg_v01 req_msg;
  wds_get_capabilities_resp_msg_v01 resp_msg;
  qmi_error_type_v01                    errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));

  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_GET_CAPABILITIES_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  if (req_msg.extended_embms_frequency_valid && req_msg.extended_embms_frequency)
  {
    //Modem supports extended 32-bit frequency values; Report true;
    resp_msg.extended_embms_frequency_valid = TRUE;
    resp_msg.extended_embms_frequency = TRUE;
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_GET_CAPABILITIES_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
}/* qmi_wdsi_get_capabilities */

/*===========================================================================
  FUNCTION QMI_WDSI_OUTAGE_NOTIFICATION_CB()

  DESCRIPTION
    This the callback that we have registered with PS Sys layer for
    outage notification event

  PARAMETERS
    tech_type      : technology for which system status has changed
    event_name     : Event name
    event_info_ptr : Event info ptr
    user_data_ptr  : Optional user data to be sent.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_outage_notification_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type                        * cmd_ptr             = NULL;
  ps_sys_event_outage_notification_type        * ps_outage_info     = NULL;
  ps_sys_event_outage_notification_type        * wds_ps_outage_info = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(event_info_ptr);

  if (event_name != PS_SYS_EVENT_3GPP2_OUTAGE_NOTIFICATION)
  {
      LOG_MSG_INFO2_1("Dropping packet, Incorrect event name:  %d", event_name);
  }

  cmd_ptr = (qmi_wdsi_cmd_buf_type *)
              qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_OUTAGE_NOTIFICATION_EVT);

  if( cmd_ptr == NULL)
  {
    LOG_MSG_ERROR_0("Unable to allocate QMI WDS cmd buffer");
    return;
  }

  ps_outage_info = (ps_sys_event_outage_notification_type *) event_info_ptr;
  wds_ps_outage_info = &cmd_ptr->data.outage_info;
  wds_ps_outage_info->time_to_outage = ps_outage_info->time_to_outage;
  wds_ps_outage_info->duration       = ps_outage_info->duration;

  cmd_ptr->cmd_id = QMI_CMD_WDS_OUTAGE_NOTIFICATION_EVT;
  cmd_ptr->subscription_id = subscription_id;

  dcc_send_cmd_ex (DCC_QMI_CMD, cmd_ptr);
}/* qmi_wdsi_outage_notification_cb */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_LTE_ATTACH_PDN_LIST_CHANGE_IND()

DESCRIPTION
    Used to indicate change notifications in lte attach PDN list 

PARAMETERS
    outage_info      : Outage info
    subscription_id  : Subscription identifier

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_outage_notifcation_ind
(
   ps_sys_event_outage_notification_type outage_info,
   uint32                                subscription_id
)
{
  qmi_wdsi_state_type *         wds_sp;
  qmi_wdsi_client_state_type *  cl_sp;
  uint8                         state;
  uint8                         inst;
  qmi_wdsi_int_if_ev_e_type     event;
  ps_iface_event_info_u_type    event_info;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  event = WDSI_INT_IF_EV_OUTAGE_NOTIFICATION;
  event_info.outage_notification_info.duration = outage_info.duration;
  event_info.outage_notification_info.time_to_outage =
    outage_info.time_to_outage;

  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }

      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
        {
          if (cl_sp->internal_iface_ev_reg_mask & (0x00000001 << (event-1)) &&
              qmi_wdsi_verify_client_subs(cl_sp, 
                                          wds_sp->binding.subscription_id,
                                          TRUE))
          {
            qmi_wdsi_internal_iface_ev_ind( wds_sp,
                                            cl_sp,
                                            event,
                                            event_info);
          }
        }
        cl_sp = cl_sp->next;
      } /* while */
    }
  }
} /* qmi_wdsi_generate_outage_notifcation_ind */


/*===========================================================================
  FUNCTION QMI_WDSI_SET_LTE_DATA_CALL_TYPE()

  DESCRIPTION
    Set the LTE Data call type for VoLTE calls.
 
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp_in  : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_lte_data_call_type
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp_in,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              * response;
  qmi_wdsi_state_type        * wds_sp;
  wds_set_lte_data_call_type_req_msg_v01 req_msg;
  wds_set_lte_data_call_type_resp_msg_v01 resp_msg;
  qmi_error_type_v01   errval;
  ps_iface_type*     um_iface_ptr = NULL;
  sint15             ps_err_no = 0;
  ps_iface_ioctl_3gpp_lte_reestab_calltype_enum_type ps_ioctl_lte_call_type;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  wds_sp = (qmi_wdsi_state_type *)sp;
  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));
  
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_LTE_DATA_CALL_TYPE_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
    
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  
  if ((req_msg.call_type > WDS_LTE_CALL_TYPE_VOLTE_V01)|| 
      (req_msg.call_type < WDS_LTE_CALL_TYPE_DEFAULT_V01))
  {
      errval = QMI_ERR_INVALID_ARG_V01;
      goto send_result;
  }

  ps_ioctl_lte_call_type = (ps_iface_ioctl_3gpp_lte_reestab_calltype_enum_type)
                             req_msg.call_type;

  if (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED)
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  um_iface_ptr = wds_sp->um_iface_ptr;
  if(PS_IFACE_IS_VALID(wds_sp->um_iface_ptr) == FALSE)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  if (ps_iface_ioctl(um_iface_ptr, PS_IFACE_IOCTL_3GPP_SET_LTE_REESTAB_CALLTYPE,
                     &ps_ioctl_lte_call_type, &ps_err_no) != 0)
  {
    LOG_MSG_ERROR_1("Couldn't set the Lte data call type , err: %d",
                    ps_err_no);
    switch (ps_err_no)
    {
      case DS_EFAULT:
        errval = QMI_ERR_INVALID_ARG_V01;
        break;

      case DS_EOPNOTSUPP:
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
        break;

      case DS_EINVAL:
        errval = QMI_ERR_INVALID_OPERATION_V01;
        break;

      default:
        errval = QMI_ERR_INTERNAL_V01;
        break;
    }
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_LTE_DATA_CALL_TYPE_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_lte_data_call_type() */

/*===========================================================================
  FUNCTION QMI_WDSI_ENCODE_MSG()

  DESCRIPTION
    This function is a wrapper functions for qmi_svc_idl_message_encode
    assgins error and result codes to response and invlokes idl encode function.
 
  PARAMETERS
    message_id : unique message ID.
    resp_msg   : input response buffer.
    size       : size of resp_msg
    err_code   : error code to be filled in the response
    response   : output dsm item pointer which has all the result TLV's

  RETURN VALUE
    TRUE is successful othewise FALSE

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_wdsi_encode_msg
(
  uint16_t             message_id,
  void *               resp_msg,
  uint32_t             size,
  qmi_error_type_v01     err_code,
  dsm_item_type **     response
)
{
  qmi_result_type_v01 result;
  qmi_response_type_v01* res_ptr = NULL;
  /*---------------------------------------------------------------------------*/
  result = (err_code == QMI_ERR_NONE_V01? QMI_RESULT_SUCCESS_V01
                                     : QMI_RESULT_FAILURE_V01);
  res_ptr = (qmi_response_type_v01*)resp_msg;
  res_ptr->result = (qmi_result_type_v01)result;
  res_ptr->error = (qmi_error_type_v01)err_code;

  if( !qmi_svc_idl_message_encode(wds_svc_obj,
      QMI_IDL_RESPONSE,message_id,resp_msg,size,response))
  {
    dsm_free_packet(response);
    *response = NULL;
    LOG_MSG_ERROR_1("Encoding failed for message id %d",message_id);
    if(!qmi_svc_put_result_tlv(response,(qmi_result_e_type)QMI_RESULT_FAILURE_V01,
                              (qmi_error_e_type)QMI_ERR_INTERNAL_V01))
    {
      dsm_free_packet(response);
      return FALSE;
    }
  }
  return TRUE;
}


/*===========================================================================
  FUNCTION QMI_WDSI_DECODE_MSG()

  DESCRIPTION
    This function is a wrapper functions for qmi_svc_idl_message_decode
    assgins error and result codes to response and invlokes idl encode function.
 
  PARAMETERS
    message_id : unique message ID.
    msg_ptr      : input buffer with all the TLV's.
    req_msg     : c struct to be filled
    req_size     : sizeof c structure

  RETURN VALUE
    qmi_error_type_v01

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_error_type_v01 qmi_wdsi_decode_msg
(
  uint16_t          message_id,
  dsm_item_type **  msg_ptr,
  void *            req_msg,
  uint32_t          req_size
)
{
  if(req_msg != NULL)
  {
    return (qmi_error_type_v01)qmi_svc_idl_message_decode(wds_svc_obj,
               message_id,msg_ptr,req_msg,req_size);
  }
  else
  {
    return QMI_ERR_INTERNAL_V01;
  }
}

/*===========================================================================
  FUNCTION QMI_WDSI_SET_DL_THRPT_INFO_IND_FREQ()

  DESCRIPTION
    Sets the downlink throughput info indication frequency by calling into
    PS SYS layer
 
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp_in  : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_dl_thrpt_info_ind_freq
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp_in,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              * response;
  qmi_wdsi_client_state_type * cl_sp;

  uint8              type;
  uint16             len;
  uint16             expected_len;
  void *             value;

  qmi_error_e_type   errval;
  qmi_result_e_type  result;
  boolean            retval;
  uint32             dl_timer;
  boolean            got_timer_tlv = FALSE;
  int16              return_val = 0;
  int16              ps_errno = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp && cmd_buf_p && cl_sp_in && sdu_in);

  cl_sp = (qmi_wdsi_client_state_type *)cl_sp_in;

  response = NULL;
  errval = QMI_ERR_NONE;

  while (*sdu_in)
  {
    if( !qmi_svc_get_tl( sdu_in, &type, &len ) )
    {
      continue;
    }

    // special value 0 = variable length or don't care (unrecognzied TLV)
    expected_len = 0;
    value = NULL;
    switch (type)
    {
      case WDSI_PRM_TYPE_DL_THRPT_TIMER:
        expected_len = sizeof(dl_timer);
        value = (void *) &dl_timer;
        got_timer_tlv = TRUE;
        break;

      default:
        LOG_MSG_INFO2_1 ("Unrecognized TLV type (%d)", type);
        break;
    }

    if(!qmi_svc_validate_type_length( type,
                                       len,
                                       expected_len,
                                       FILE_ID_DS_QMI_WDS,__LINE__)  )
    {
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }

    /*-----------------------------------------------------------------------
      if value is NULL, skip past the current TLV
    -----------------------------------------------------------------------*/
    if (len != PS_UTILS_DSM_PULLUP( sdu_in, value, len))
    {
      errval = QMI_ERR_MALFORMED_MSG;
      goto send_result;
    }
  } /* while */

  if (!(got_timer_tlv))
  {
    errval = QMI_ERR_MISSING_ARG;
    goto send_result;
  }

  cl_sp->downlink_report_interval = dl_timer;
  return_val = qmi_wdsi_update_downlink_throughput_interval( cl_sp, TRUE,
                                                             &ps_errno );

  if (return_val != DSS_SUCCESS)
  {
    LOG_MSG_ERROR_2("ps_sys_conf_set ret [%d] errno [%d]", 
                    return_val, ps_errno);

    switch (ps_errno)
    {
      case DS_NOMEMORY:
        errval = QMI_ERR_NO_MEMORY;
        break;
      case DS_EOPNOTSUPP:
      case DS_EINVAL:
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED;
        break;
      default:
        errval = QMI_ERR_INTERNAL;
        break;
    }
  }

send_result:
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);

  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;

} /* qmi_wdsi_set_dl_thrpt_info_ind_freq() */

/*===========================================================================
  FUNCTION QMI_WDSI_DL_THRPT_INFO_CHANGE_CB()

  DESCRIPTION
    This the callback that we have registered with PS Sys layer for
    throughput info event

  PARAMETERS
    tech_type      : technology for which system status has changed
    event_name     : Event name
    event_info_ptr : List of thrpughput information
    user_data_ptr  : Optional user data to be sent.

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_dl_thrpt_info_change_cb
(
  ps_sys_tech_enum_type                          tech_type,
  ps_sys_event_enum_type                         event_name,
  ps_sys_subscription_enum_type                  subscription_id,
  void                                         * event_info_ptr,
  void                                         * user_data_ptr
)
{
  qmi_wdsi_cmd_buf_type *cmd_ptr = NULL;
  ps_sys_dl_throughput_info_type            *ps_dl_thrpt_info_ptr;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(event_info_ptr);
  ps_dl_thrpt_info_ptr = (ps_sys_dl_throughput_info_type *)event_info_ptr;
  
  cmd_ptr = (qmi_wdsi_cmd_buf_type *)
              qmi_wdsi_get_cmd_buf(QMI_CMD_WDS_DL_THRPT_INFO_EVT);

  if( cmd_ptr == NULL)
  {
    return;
  }

  cmd_ptr->data.dl_thrpt_info.downlink_allowed_rate = 
    ps_dl_thrpt_info_ptr->downlink_allowed_rate;
  cmd_ptr->data.dl_thrpt_info.confidence_level = 
    ps_dl_thrpt_info_ptr->confidence_level;
  cmd_ptr->cmd_id = QMI_CMD_WDS_DL_THRPT_INFO_EVT;
  cmd_ptr->subscription_id = subscription_id;

  dcc_send_cmd_ex (DCC_QMI_CMD, cmd_ptr);
} /* qmi_wdsi_dl_thrpt_info_change_cb() */


/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_DL_THRPT_INFO_CHANGE_IND()

DESCRIPTION
    Used to indicate change notifications in downlink throughput info list

PARAMETERS
    dl_thrpt_info_ptr    : DL Throughput info ptr
    subscription_id      : Subs identifier

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_dl_thrpt_info_change_ind
(
  ps_sys_dl_throughput_info_type    dl_thrpt_info,
  uint32                            subscription_id
)
{
  qmi_wdsi_state_type *         wds_sp;
  qmi_wdsi_client_state_type *  cl_sp;
  uint8                         state;
  uint8                         inst;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  for( state = 0; state < WDSI_MAX_STATE; state++ )
  {
    for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
    {
      wds_sp = qmi_wds_state[state][inst];
      if (wds_sp == NULL)
      {
        continue;
      }

      cl_sp = wds_sp->client_list;
      while (cl_sp != NULL)
      {
        if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
        {
          if (cl_sp->report_status.report_dl_thrpt_info_change &&
              qmi_wdsi_verify_client_subs(cl_sp, subscription_id, FALSE))
          {
            qmi_wdsi_dl_thrpt_info_list_change_ind(wds_sp, 
                                                   cl_sp->common.clid,
                                                   &dl_thrpt_info);
          }
        }
        cl_sp = cl_sp->next;
      } /* while */
    }
  }
} /* qmi_wdsi_generate_dl_thrpt_info_change_ind */

/*===========================================================================
  FUNCTION QMI_WDSI_DL_THRPT_INFO_LIST_CHANGE_IND()

  DESCRIPTION
    Sends indication to clients registered for downlink throughput info 

  PARAMETERS
    wds_sp                : service provided state pointer
    cl_id                 : client ID
    dl_thrpt_info_ptr     : downlink throughput info ptr

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_dl_thrpt_info_list_change_ind
(
  qmi_wdsi_state_type *                 wds_sp,
  uint8                                 cl_id,
  ps_sys_dl_throughput_info_type      * dl_thrpt_info_ptr
)
{
  dsm_item_type *                     ind;
  qmi_wdsi_client_state_type *        cl_sp;
  qmi_wds_downlink_thrpt_info_type    wds_thrpt_info;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(wds_sp && dl_thrpt_info_ptr);

  /*-------------------------------------------------------------------------
    Build indication from the back to the front
  -------------------------------------------------------------------------*/
  ind = NULL;
  cl_sp = qmi_wdsi_get_cl_sp_by_clid(wds_sp, cl_id);

  wds_thrpt_info.downlink_allowed_rate = 
    dl_thrpt_info_ptr->downlink_allowed_rate;
  wds_thrpt_info.confidence_level = dl_thrpt_info_ptr->confidence_level;

 
  if(FALSE == qmi_svc_put_param_tlv(&ind,
                                    WDSI_PRM_TYPE_DL_THROUGHPUT_CONFIDENCE_LEVEL,
                                    sizeof(wds_thrpt_info.confidence_level),
                                    &wds_thrpt_info.confidence_level))
  {
    dsm_free_packet(&ind);
    return;
  }
 
  if(FALSE == qmi_svc_put_param_tlv(&ind,
                                    WDSI_PRM_TYPE_DL_THROUGHPUT_INFO,
                                    sizeof(wds_thrpt_info.downlink_allowed_rate),
                                    &wds_thrpt_info.downlink_allowed_rate))
  {
    dsm_free_packet(&ind);
    return;
  }
 
  if (FALSE == qmi_wdsi_send_ind(wds_sp,
                                 cl_sp,
                                 WDSI_CMD_VAL_DL_THRPT_INFO_IND,
                                 0,
                                 ind,
                                 FALSE))
  {
     LOG_MSG_INFO2_0("Unable to send dl thrpt info change indication ");
  }
} /* qmi_wdsi_dl_thrpt_info_list_change_ind() */

/*===========================================================================
  FUNCTION QMI_WDSI_UPDATE_DOWNLINK_THROUGHPUT_INTERVAL()

  DESCRIPTION
    Sends indication to clients registered for downlink throughput info 

  PARAMETERS
    cl_sp          : client state pointer
    client_inited  : TRUE- if client inited, FALSE-if due to client release
    ps_errno       : Err no

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
int16 qmi_wdsi_update_downlink_throughput_interval
(
  qmi_wdsi_client_state_type  * cl_sp_in,
  boolean                       client_inited,
  int16                       * ps_errno
)
{
  qmi_wdsi_state_type *         wds_sp;
  qmi_wdsi_client_state_type *  cl_sp;
  uint8                         state;
  uint8                         inst;
  uint32                        subscription_id = 0;
  uint32                        min_timer = 0;
  int16                         return_val = 0;
  int16                         err_no = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  subscription_id = qmi_wdsi_resolve_client_subs(cl_sp_in);

  if ( cl_sp_in->downlink_report_interval == 0 )
  {
    //Disable timer
    min_timer = 0;
  }
  else
  {
    if (!client_inited)
    {
      min_timer = WDSI_MAX_TIMER_INTERVAL; 
    }
    else
    {
      min_timer = cl_sp_in->downlink_report_interval; 
    }
    for( state = 0; state < WDSI_MAX_STATE; state++ )
    {
      for( inst = 0; inst < WDS_INSTANCE_MAX; inst++ )
      {
        wds_sp = qmi_wds_state[state][inst];
        if (wds_sp == NULL)
        {
          continue;
        }
        cl_sp = wds_sp->client_list;
        while (cl_sp != NULL)
        {
          if (wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp))
          {
             if (( cl_sp->downlink_report_interval != 0) &&
                 ( subscription_id == qmi_wdsi_resolve_client_subs(cl_sp) ) &&
                   cl_sp != cl_sp_in)
             {
                min_timer = MIN(cl_sp->downlink_report_interval, min_timer);
             }
          }
          cl_sp = cl_sp->next;
        } /* while */
      }/* inner for */
    }/* outer for */

    if (min_timer == WDSI_MAX_TIMER_INTERVAL) 
    {
      /*-------------------------------------------------------------------------
        No more clients with min reporting interval found; Disable the timer
      ------------------------------------------------------------------------*/
      min_timer = 0;
    }
  } 
  return_val = ps_sys_conf_set_ex(PS_SYS_TECH_ALL,
                                  PS_SYS_CONF_DL_THROUGHPUT_INFO_TIMER,
                                  (ps_sys_subscription_enum_type) subscription_id,
                                  &min_timer,
                                  &err_no);
  *ps_errno = err_no;
  return return_val;
}/* qmi_wdsi_update_downlink_throughput_interval */

/*===========================================================================
  FUNCTION QMI_WDSI_GET_DOWNLINK_THROUGHPUT_INFO_PARAMS()

  DESCRIPTION
    Queries for the downlink throughput info params

  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp     : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type*  qmi_wdsi_get_downlink_throughput_info_params
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type *                     response;
  qmi_error_e_type                    errval;
  qmi_result_e_type                   result;
  boolean                             retval;
  int16                               ps_errno = 0;
  int16                               return_val;
  uint32                              subscription_id = 0;
  uint32                              min_dl_timer = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp && cmd_buf_p && cl_sp && sdu_in);

  response = NULL;
  errval = QMI_ERR_NONE;


  subscription_id = qmi_wdsi_resolve_client_subs(cl_sp);
  /*-------------------------------------------------------------------------
    Retrieve min dl timer interval information by calling into PS Sys Layer
  -------------------------------------------------------------------------*/
  return_val = ps_sys_conf_get_ex(PS_SYS_TECH_ALL,
                                  PS_SYS_CONF_DL_MIN_THROUGHPUT_TIMER,
                                  (ps_sys_subscription_enum_type) subscription_id,
                                  (void *)&min_dl_timer,
                                  &ps_errno);

  if (return_val != DSS_SUCCESS)
  {
    LOG_MSG_ERROR_2("ps_sys_conf_get_ex ret [%d] errno [%d]", return_val, ps_errno);
    switch (ps_errno)
    {
      case DS_NOMEMORY:
        errval = QMI_ERR_NO_MEMORY;
        break;
      case DS_EOPNOTSUPP:
      case DS_EINVAL:
        errval = QMI_ERR_INFO_UNAVAILABLE;
        break;
      default:
        errval = QMI_ERR_INTERNAL;
        break;
    }
    goto send_result;
  }

  if (errval == QMI_ERR_NONE)
  {
    if ( FALSE == qmi_svc_put_param_tlv( &response,
                                         WDSI_PRM_TYPE_MIN_DL_THRPT_TIMER,
                                         sizeof(min_dl_timer),
                                         &min_dl_timer) )
    {      
      errval = QMI_ERR_NO_MEMORY;
      dsm_free_packet(&response);
    }
  }

  send_result:
    result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                     : QMI_RESULT_FAILURE);

    retval = qmi_svc_put_result_tlv(&response, result, errval);
    CHECK_RETVAL();
    return response;
} /* qmi_wdsi_get_downlink_throughput_info_params */


/*===========================================================================
  FUNCTION QMI_WDS_EMBMS_CONTENT_DESC_UPDATE()

  DESCRIPTION
   This message requests is for eMBMS content description parameters update
 
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp_in  : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_embms_content_desc_update
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp_in,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type              * response;
  qmi_wdsi_client_state_type * cl_sp;
  
  qmi_error_e_type   errval;
  qmi_result_e_type  result;
  int32              qmi_result = 0;
  boolean            retval;
  int16              return_val = 0;
  int16              ps_errno = 0;
  uint32             req_buf_len = 0;
  uint32             req_msg_len = 0;
  uint8 *            req_buf = NULL;

  wds_embms_content_desc_update_req_msg_v01      req_msg;
  qmi_idl_service_object_type                    svc_obj;
  ps_iface_embms_content_desc_update_type        embms_content;
  qmi_wdsi_state_type      * wds_sp = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT(sp && cmd_buf_p && cl_sp_in && sdu_in);

  cl_sp = (qmi_wdsi_client_state_type *)cl_sp_in;
  wds_sp = qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp);

  if (NULL == wds_sp)
  {
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

  svc_obj = wds_get_service_object_v01();
  memset(&embms_content, 0, sizeof(ps_iface_embms_content_desc_update_type));

  response = NULL;
  errval = QMI_ERR_NONE;

  // Check if eMBMS call is up
  if ( (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED) ||
       (wds_sp->is_embms_inst != TRUE) )
  {
    errval = QMI_ERR_OUT_OF_CALL;
    goto send_result;
  }

  req_msg_len = sizeof(wds_embms_content_desc_update_req_msg_v01);
  req_buf_len = dsm_length_packet( *sdu_in );
  
  if ( req_buf_len > 0 )
  {
    PS_SYSTEM_HEAP_MEM_ALLOC (req_buf, req_buf_len, uint8*); 
    if (req_buf != NULL)
    {
      if ( req_buf_len == PS_UTILS_DSM_PULLUP( sdu_in, req_buf, req_buf_len ) )
      {
         /*-----------------------------------------------------------------------
           Decodes a QMI message body from the wire format to the C structure
         -----------------------------------------------------------------------*/
         qmi_result = qmi_idl_message_decode(svc_obj,
                                             QMI_IDL_REQUEST,
                                             QMI_WDS_EMBMS_CONTENT_DESC_UPDATE_REQ_V01,
                                             req_buf,
                                             req_buf_len,
                                             &req_msg,
                                             req_msg_len);
         if ( 0 != qmi_result ) 
         {
           LOG_MSG_ERROR_0("decode failed");
           errval = QMI_ERR_MALFORMED_MSG;
           goto send_result;
         } 
      }
    }
    else
    {
      LOG_MSG_ERROR_0("decode: no memory for buffer");
      errval = QMI_ERR_NO_MEMORY;
      goto send_result;
    }
  }
  else
  {
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }
 
  embms_content.size                = req_msg_len;
  embms_content.content_description = &req_msg;

  return_val = ps_iface_ioctl(wds_sp->um_iface_ptr,
                              PS_IFACE_IOCTL_EMBMS_CONTENT_DESC_UPDATE,
                              &embms_content,
                              &ps_errno);

  if (return_val == -1)
  {
    errval = QMI_ERR_INTERNAL;
    goto send_result;
  }

send_result:
  if (req_buf != NULL) 
  {
    PS_SYSTEM_HEAP_MEM_FREE(req_buf);
  }
  result = (errval == QMI_ERR_NONE ? QMI_RESULT_SUCCESS
                                   : QMI_RESULT_FAILURE);

  retval = qmi_svc_put_result_tlv(&response, result, errval);
  CHECK_RETVAL();

  return response;

} /* qmi_wdsi_embms_content_desc_update() */

/*===========================================================================
  FUNCTION QMI_WDSI_EMBMS_CONTENT_DESC_CONTROL_IND()

  DESCRIPTION
    Sends indication to clients registered for content desc control ind

  PARAMETERS
    wds_sp                : service provided state pointer
    cl_id                 : client ID
    lte_attach_pdn_list   : List of LTE attach PDN profiles

  RETURN VALUE
    void

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_wdsi_embms_content_desc_control_ind
(
  qmi_wdsi_state_type         * wds_sp,
  qmi_wdsi_client_state_type  * cl_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info,
  boolean                       modem_inited
)
{
  ps_iface_embms_content_desc_update_type * ps_content_desc;
  qmi_idl_service_object_type               svc_obj;
  dsm_item_type                    * ind = NULL;
  qmi_error_e_type    eval               = QMI_IDL_LIB_NO_ERR;
  uint32              rsp_buf_len = 0;
  uint8 *             rsp_buf     = NULL;
  uint32              size_buf    =0;
  boolean             retval = FALSE;
  int32     err_val     = QMI_IDL_LIB_NO_ERR;
  wds_embms_content_desc_control_ind_msg_v01  wds_ind;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT(wds_sp && cl_sp);
  ps_content_desc = &event_info.embms_content_desc_info;
  svc_obj = wds_get_service_object_v01();

  memset(&wds_ind,0,sizeof(wds_embms_content_desc_control_ind_msg_v01));
  if (ps_content_desc->size != sizeof(wds_embms_content_desc_control_ind_msg_v01))
  {
     LOG_MSG_ERROR_1("Invalid size %d", ps_content_desc->size);
     return;
  }
  memscpy(&wds_ind, ps_content_desc->size, ps_content_desc->content_description,
          ps_content_desc->size);

  //Encode the QMI message into QMUX pkt structure

  /*--------------------------------------------------------------------------------
    Accessor function for getting the maximum message length of a response
    message. Message length includes c struct size, size of type and size of length.
  ----------------------------------------------------------------------------------*/
  eval = qmi_idl_get_max_message_len( svc_obj, QMI_IDL_INDICATION,
                                      QMI_WDS_EMBMS_CONTENT_DESC_CONTROL_IND_V01,
                                      &rsp_buf_len );


  if ( eval == QMI_IDL_LIB_NO_ERR )
  {
    PS_SYSTEM_HEAP_MEM_ALLOC(rsp_buf,rsp_buf_len,uint8*);
    if ( rsp_buf != NULL )
    {
      memset(rsp_buf, 0x00, rsp_buf_len);
      err_val = qmi_idl_message_encode( svc_obj,
                                        QMI_IDL_INDICATION,   // IDL message type
                                        QMI_WDS_EMBMS_CONTENT_DESC_CONTROL_IND_V01,   // QMI SVC cmd type
                                        &wds_ind,        // pointer to c structure
                                        sizeof(wds_embms_content_desc_control_ind_msg_v01),   // size of c structure which is to be encoded
                                        rsp_buf,      // buffer to contain encoded message data
                                        rsp_buf_len,  // size of buffer, should be maximum size of the encoded c structure
                                        &size_buf     // pointer to store length of the encoded message
                                      );

      if ( err_val == QMI_IDL_LIB_NO_ERR )
      {
        if ( size_buf != dsm_pushdown_packed( &ind, 
                                              &rsp_buf[0], 
                                              size_buf, 
                                              DSM_DS_SMALL_ITEM_POOL) )
        {
          LOG_MSG_ERROR_1("Pushdown Failed for encode %d", size_buf);
          dsm_free_packet(&ind);
        }
        else
        {
          LOG_MSG_INFO1_1 (" Encode success rsp_buf %d ", rsp_buf);
          retval = TRUE;
        }
      }
    }
  }

  if ( retval == TRUE) 
  {
    // Send indication 
    if (FALSE == qmi_wdsi_send_ind(wds_sp,
                                   cl_sp,
                                   WDSI_CMD_VAL_EMBMS_CONTENT_DESC_CONTROL_IND,
                                   0,
                                   ind,
                                   FALSE))
    {
      LOG_MSG_INFO2_0 ("Unable to send embms update ind");
    }
  }
  else
  {
     LOG_MSG_INFO2_0 ("IDL enocde error in embms content desc ind");
  }

  if ( rsp_buf != NULL ) 
  {
    PS_SYSTEM_HEAP_MEM_FREE(rsp_buf);
  }
} /* qmi_wdsi_embms_content_desc_control_ind() */

/*===========================================================================
FUNCTION   WDSI_COPY_EMBMS_CONTENT_DESC_UPDATE()

DESCRIPTION
  This function allocates memory and copy the embms update content
  from the event_info to the cmd_ptr event_info. 

PARAMETERS:
  event         : type of event
  event_info    : info ptr for the event
  cmd_ptr       : DCC command buffer ptr

DEPENDENCIES
  Called from wdsi_um_iface_cb()

RETURN VALUE
  TRUE: Operation is successful
  FALSE: Operation failed 

SIDE EFFECTS
  None
===========================================================================*/
static boolean wdsi_copy_embms_content_desc_update
(
  ps_iface_event_enum_type     event,
  ps_iface_event_info_u_type * event_info,
  qmi_wdsi_cmd_buf_type      * cmd_ptr
)
{
  ps_iface_embms_content_desc_update_type *content_desc = NULL;
  void                                   **content_desc_pp = NULL;
  uint32                                   content_desc_size = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT( event_info && cmd_ptr );

  /* Need to alloc memory and copy embms content since the one in the
   * event_info will be freed after callback.
   */
  if ( event == IFACE_EMBMS_CONTENT_DESC_CONTROL_EV)
  {
    content_desc_size = event_info->embms_content_desc_info.size;
    content_desc      = event_info->embms_content_desc_info.content_description;
    content_desc_pp   = &(cmd_ptr->data.iface_info.event_info.embms_content_desc_info.content_description);
  }
  else
  {
    LOG_MSG_ERROR_1("Unknown event %d", event);
    return FALSE;
  }

  if (content_desc_size <= 0)
  {
    LOG_MSG_ERROR_1("Invalid size of content [%d]", content_desc_size);
    return FALSE;
  }

  *content_desc_pp  = NULL; 
  PS_SYSTEM_HEAP_MEM_ALLOC(*content_desc_pp,
                            content_desc_size,
                            void *);
  if (*content_desc_pp != NULL)
  {
    memscpy(*content_desc_pp, content_desc_size, content_desc, content_desc_size);
  }
  else
  {
    return FALSE;
  }
 
  return TRUE;
} /* wdsi_copy_embms_content_desc_update() */

/*===========================================================================
FUNCTION QMI_WDSI_GENERATE_APN_PARAM_CHANGED_IND()

DESCRIPTION
    Called when IFACE_APN_PARAM_CHANGED_EV has occured.
    Used to indicate information associated with the event

PARAMETERS
  wds_sp     : wds state pointer
  event      : apn param changed generic event
  event_info : apn param change info

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_wdsi_generate_apn_param_changed_ind
(
  qmi_wdsi_state_type         *wds_sp,
  ps_iface_event_enum_type      event,
  ps_iface_event_info_u_type    event_info
  )
{
  qmi_wdsi_client_state_type *cl_sp = NULL;
  ps_iface_changed_apn_param_info_type *apn_info = NULL;
  uint32 temp_len = 0;
  wds_apn_param_info_change_ind_msg_v01 *indication = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(wds_sp);

  if (event != IFACE_APN_PARAM_CHANGED_EV)
  {
    LOG_MSG_ERROR_1("Invalid event received for APN Param, event: %d",
                    event);
    ASSERT(0);
    return;
  }

  PS_SYSTEM_HEAP_MEM_ALLOC(indication, sizeof(wds_apn_param_info_change_ind_msg_v01),
                            wds_apn_param_info_change_ind_msg_v01*);

  if (NULL == indication)
  {
    LOG_MSG_ERROR_1("Out of Memory, event: %d", event);
    return;
  }

  memset(indication, 0, sizeof(wds_apn_param_info_change_ind_msg_v01));

  apn_info = (ps_iface_changed_apn_param_info_type *)&event_info.apn_param_change_info_type;

  if (NULL == apn_info)
  {
    LOG_MSG_ERROR_1("Invalid event payload received for APN Param, event: %d",
                    event);
    ASSERT(0);
  }

  if (apn_info->apn_mask & PS_IFACE_APN_PARAM_APN_NAME)
  {
    indication->changed_apn_string_info_valid = TRUE;
    /*old apn value*/
    temp_len = strlen(apn_info->old_apn_param_values.apn_name);
    memscpy(indication->changed_apn_string_info[0].apn_string,
            QMI_WDS_APN_NAME_MAX_V01 + 1,
            apn_info->old_apn_param_values.apn_name,
            temp_len);

    /*new apn value*/
    temp_len = strlen(apn_info->new_apn_param_values.apn_name);
    memscpy(indication->changed_apn_string_info[1].apn_string,
            QMI_WDS_APN_NAME_MAX_V01 + 1,
            apn_info->new_apn_param_values.apn_name,
            temp_len);
  }
  if (apn_info->apn_mask & PS_IFACE_APN_PARAM_PDP_TYPE)
  {
    indication->changed_pdp_type_info_valid = TRUE;
    indication->changed_pdp_type_info[0] = (wds_pdp_type_enum_v01)apn_info->old_apn_param_values.pdp_type;
    indication->changed_pdp_type_info[1] = (wds_pdp_type_enum_v01)apn_info->new_apn_param_values.pdp_type;
  }
  cl_sp = wds_sp->client_list;
  while (cl_sp != NULL)
  {
    if ((wds_sp == qmi_wdsi_get_wds_sp_by_cl_sp(cl_sp)) &&
        (cl_sp->report_status.report_apn_param_changed) &&
        qmi_wdsi_verify_client_subs(cl_sp, wds_sp->binding.subscription_id, TRUE))
    {
      qmi_wdsi_send_ind(wds_sp,
                        cl_sp,
                        QMI_WDS_APN_PARAM_INFO_CHANGE_IND_V01,
                        sizeof(wds_apn_param_info_change_ind_msg_v01),
                        indication,
                        TRUE);
    }
    cl_sp = cl_sp->next;
  }/* while */
  
  PS_SYSTEM_HEAP_MEM_FREE(indication);
} 

/*===========================================================================
  FUNCTION QMI_WDSI_SET_SILENT_REDIAL()

  DESCRIPTION
    Request Modehandler to perform silent redial.
 
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp_in  : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_set_silent_redial
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp_in,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type                     *response;
  qmi_wdsi_state_type               *wds_sp;
  qmi_error_type_v01                errval;
  ps_iface_type                     *um_iface_ptr = NULL;
  sint15                            ps_err_no = 0;
  wds_set_silent_redial_req_msg_v01  req_msg;
  wds_set_silent_redial_resp_msg_v01 resp_msg; 
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  wds_sp = (qmi_wdsi_state_type *)sp;
  ASSERT(wds_sp);

  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));
  
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_SET_SILENT_REDIAL_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
    
  if(errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }

  if (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED)
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  um_iface_ptr = wds_sp->um_iface_ptr;
  if(PS_IFACE_IS_VALID(wds_sp->um_iface_ptr) == FALSE)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  if (req_msg.set_silent_redial_valid)
  {
    if (ps_iface_ioctl(um_iface_ptr, PS_IFACE_IOCTL_SET_SILENT_REDIAL,
                      (void*)&req_msg.set_silent_redial, &ps_err_no) != 0)
    {
      LOG_MSG_ERROR_1("Couldn't perform silent redial, err: %d",
                      ps_err_no);
      switch (ps_err_no)
      {
        case DS_EFAULT:
          errval = QMI_ERR_INVALID_ARG_V01;
          break;

        case DS_EOPNOTSUPP:
          errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
          break;

        case DS_EINVAL:
          errval = QMI_ERR_INVALID_OPERATION_V01;
          break;

        default:
          errval = QMI_ERR_INTERNAL_V01;
          break;
      }
    }
  }
  else
  {
    errval = QMI_ERR_MISSING_ARG_V01;
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_SET_SILENT_REDIAL_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_set_silent_redial() */

/*===========================================================================
  FUNCTION QMI_WDSI_KEEP_ALIVE_DATA_SESSION()

  DESCRIPTION
    Request the modem to keep data session alive
 
  PARAMETERS
    sp        : service provided state pointer
    cmd_buf_p : ptr to cmd buffer
    cl_sp_in  : client state pointer
    sdu_in    : incoming request

  RETURN VALUE
    ptr to response

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static dsm_item_type * qmi_wdsi_keep_alive_data_session
(
  void *            sp,
  void *            cmd_buf_p,
  void *            cl_sp_in,
  dsm_item_type **  sdu_in
)
{
  dsm_item_type         * response;
  qmi_wdsi_state_type   * wds_sp;
  qmi_error_type_v01      errval;
  ps_iface_type         * um_iface_ptr = NULL;
  sint15                  ps_err_no = 0;

  wds_keep_alive_data_session_req_msg_v01  req_msg;
  wds_keep_alive_data_session_resp_msg_v01 resp_msg;
  ps_iface_ioctl_keep_alive_type           ps_ioctl_keep_alive;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT(sp);

  wds_sp = (qmi_wdsi_state_type *)sp;
  response = NULL;
  errval = QMI_ERR_NONE_V01;
  memset(&req_msg,0,sizeof(req_msg));
  memset(&resp_msg,0,sizeof(resp_msg));
  
  // Check if call is UP
  if (wds_sp->pkt_svc_state != QMI_WDS_CONN_CONNECTED)
  {
    errval = QMI_ERR_OUT_OF_CALL_V01;
    goto send_result;
  }

  um_iface_ptr = wds_sp->um_iface_ptr;
  if (PS_IFACE_IS_VALID(wds_sp->um_iface_ptr) == FALSE)
  {
    errval = QMI_ERR_INTERNAL_V01;
    goto send_result;
  }

  // Decode the request
  errval = QMI_WDSI_DECODE_REQUEST_MSG(QMI_WDS_KEEP_ALIVE_DATA_SESSION_REQ_V01,
                                       sdu_in,
                                       &req_msg,
                                       sizeof(req_msg));
  if (errval != QMI_ERR_NONE_V01)
  {
    goto send_result;
  }
  
  // Call PS ioctl
  ps_ioctl_keep_alive = (ps_iface_ioctl_keep_alive_type)req_msg.keep_alive;

  if (ps_iface_ioctl(um_iface_ptr,
                     PS_IFACE_IOCTL_KEEP_ALIVE,
                     &ps_ioctl_keep_alive,
                     &ps_err_no) != 0)
  {
    LOG_MSG_ERROR_1("Couldn't set keep alive flag , err: %d", ps_err_no);
    switch (ps_err_no)
    {
      case DS_EFAULT:
        errval = QMI_ERR_INVALID_ARG_V01;
        break;

      case DS_EOPNOTSUPP:
        errval = QMI_ERR_OP_DEVICE_UNSUPPORTED_V01;
        break;

      case DS_EINVAL:
      case DS_ENETDOWN:
        errval = QMI_ERR_INVALID_OPERATION_V01;
        break;

      default:
        errval = QMI_ERR_INTERNAL_V01;
        break;
    }
  }

send_result:
  QMI_WDSI_ENCODE_RESPONSE_MSG(QMI_WDS_KEEP_ALIVE_DATA_SESSION_RESP_V01,
                               &resp_msg,
                               sizeof(resp_msg),
                               errval,
                               &response);
  return response;
} /* qmi_wdsi_keep_alive_data_session() */