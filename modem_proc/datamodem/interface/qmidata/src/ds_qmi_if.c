/*===========================================================================

                            D S _ Q M I _ I F . C

DESCRIPTION

  The Data Services WWAN external interface source file.

  This module will externalize the minimal but complete API for modules
  outside of data services to interface to WWAN logic.

  JD - Note some internal APIs exist in here currently - need to break this
       out into external and internal inter-module API files once logic is
       fleshed out.

EXTERNALIZED FUNCTIONS
  qmi_if_init()
    Initialize the WWAN interface layer

  qmi_if_reg_cm()
    Register for CM event reporting

  qmi_if_dereg_cm()
    Deregister CM event reporting

  qmi_if_media_connected()
    Indicate that the RMNET interface media (cable) is "connected".
  
  qmi_if_media_disconnected()
    Indicate that the RMNET interface media (cable) is "disconnected".

  qmi_if_get_max_channel_rate()
    This is used to obtain the max channel rate on the current radio
    technology in use

  qmi_if_get_current_channel_rate()
    This is used to obtain the current(instantaneous) channel rate on the current radio
    technology in use

  qmi_if_get_current_radio_if()
    Used to get the current servign system

  qmi_if_get_power_state
    It returns the current power status and battery level after querying them
    from the external charger module  
  
Copyright (c) 2004-2016 Qualcomm Technologies Incorporated.
All Rights Reserved.
Qualcomm Confidential and Proprietary.
===========================================================================*/
/*===========================================================================

                            EDIT HISTORY FOR FILE
  $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/datamodem/interface/qmidata/src/ds_qmi_if.c#1 $

when        who    what, where, why
--------    ---    ----------------------------------------------------------
06/13/16    vrk    Added support for LTE-U 256 bands.
10/21/14    sk     QMI-DMS Service QCSI migration.
03/13/14    sah    Added support for tertiary subscription
02/13/14    vrk    Added cmd_type to qmi_dms_process_mmgsdi_operation_complete
11/27/13    sah    Fix to update PRL info in case of missing prl init event
09/27/13    wc     Support dynamic port configuration
07/30/13    vrk    Fix to allocate cmd_ptr for CM_PH_EVENT_CDMA_LOCK_MODE 
06/11/13    ms     KW error fixes.
06/07/13    rk     Add secondary subscription changes for mmgsdi
01/24/13    rk     Fix to prevent timing attack on qmi_if_check_spc routine.
06/11/12    sb     Fix to move to correct UIM state in case of CARD ERROR
                   event.
03/29/12    sa     New QMI utils api for spc checks.
03/09/12    sj     Add functionality to determine max tx and rx rates for TDSCDMA 
02/28/12    sj     Add support for TDSCDMA  
01/25/12    sj     Cache mode_capability from CM 
11/02/11    wc     Add qmi_dms_get_current_prl_info
10/10/11    sj     Add support for caching LTE band capability value 
10/21/11    wc     Fix incorrect prl_only value returned by dms_get_prl_ver
10/04/11    sa     Q6 free floating changes for QMI.
08/15/11    sa     GSDI cleanup changes.
06/22/11    wc     Send PRL init indication when PRL is loaded
04/27/11    ua     CMI-4 compliance. 
03/08/11    ua     Retreiving WCDMA/HSDPA/HSUPA default data rates from RRC.
02/15/11    kk     Added support for PRL_ONLY TLV in PRL_INFO message.
02/09/11    kk     Added support for LTE Data rates.
01/10/11    ss     Cleaning up of Globals for thread safety in Q6 Free 
                   Floating environment.
12/17/10    kk     Added log messages before ASSERTs.
06/21/10    kk     Fix to align to new MMGSDI APIs for PERSO requests.
06/19/10    vs     Changes for Dual IP support over single QMI instance
06/07/10    kk     Fix to update app_type and uim_state from all possible
                   events.
05/19/10    kk     Fix to prevent stale memory access.
05/05/10    kk     To allow opening of 1X or GW session based on featurization
05/05/10    kk     Fix to allow proper processing of SUBSCRIPTION_READY and
                   PIN events from MMGSDI.
11/10/09    jee    Changes to support MMGSDI re-architecture
10/22/09    kk     Windows7 compliance - WDS changes and BER/PER/FER support.
10/16/09    kk     Windows7 compliance - new messages and ATCoP dependencies.
10/09/09    kk     Windows7 compliance - NAS changes.
10/08/09    kk     Windows7 compliance - DMS changes.
02/19/09    am     DS Task De-coupling effort and introduction of DCC task.
08/23/06    ks     Changes to support multiple qmi/rmnet instances.
07/06/06    ks     Posting DS cmds for SS and PH events generated by CM to
                   send NAS responses in DS context. Other clean up
06/07/06    ks     Fixed signal strength reporting
05/01/06    ks     Handling new CM_PH events for NAS Register and Attach.
04/18/06    ks     Changed return value of qmi_if_get_sig_strength() to void.
03/06/06    ks     Using ps_iface_ioctl() to obtain data bearer rates.
09/08/05    ks     Major clean up. Added support to listen to CM phone_events.
                   Changed name to qmi_if.
05/31/05   jd/ks   Code review updates
05/11/05    ks     changed some names.
03/18/05    ks     Added Masks for Power State.
10/27/04    jd     Return linkspeed 153.6kbps
                   Added media connect/disconnect apis.
07/12/04    jd     Revamped qmi_if.  Added CM SS object client.
04/12/04    jd     added qmi_if_uim_used() to indicate if SIM is in use
03/16/04    jd     added qmi_if_connected() to indicate if in pkt service
03/16/04    jd     Added qmi_if_get_link_speed to return current link speed
04/20/04    jd     Initial implementation
===========================================================================*/


/*===========================================================================

                          INCLUDE FILES FOR MODULE

===========================================================================*/

/* Common definitions and customization headers */
#include "datamodem_variation.h"
#include "comdef.h"
#include "customer.h"


/* global headers */
#include "msg.h"
#include "err.h"

/* For EFS operations */
#include "fs_errno.h"
#include "fs_public.h"
#include "fs_sys_types.h"

/* external module's interface headers */
#include "cm.h"
#include "ps_iface_ioctl.h"
#include "ps_iface.h"
#include "ds3gmgr.h"

/* serving task & module headers */
#include "dcc_task_defs.h"
#include "dcc_task_svc.h"
#include "ds_qmi_wds.h"

#include "ds_qmi_task.h"
#include "ds_qmi_dms.h"
#include "ds_qmi_svc.h"
#include "ds_qmi_if.h"
#include "ds_qmi_if_ext.h"
#include "ds_qmi_defs.h"
#include "ds_qmux_ext.h"
#include "ds_qmi_svc_ext.h"
#include "ds_qmi_cflog.h"

#include <stringl/stringl.h>

/* power state bitmask */
#include "qmi_charger.h"

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM)
/* GPRS/EDGE multislot default */
#include "gmm.h"
#if defined(FEATURE_WCDMA)
/* WCDMA HSUPA category default */
#ifdef FEATURE_SEGMENT_LOADING
#include "mcfg_seg_load.h"
#include "IWCDMA.h"
#else
#include "rrcdata.h"
#endif /*FEATURE_SEGMENT_LOADING*/

#endif /* defined(FEATURE_WCDMA) */
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */

#include "mmgsdisessionlib.h"
#include "ds_Utils_DebugMsg.h"
#include "ps_system_heap.h"
#include "qmi_crit_sect.h"
#include "sys_m_reset.h"
#include "ps_utils.h"

/*---------------------------------------------------------------------------
  Serving system changed bitmask - ?
---------------------------------------------------------------------------*/
#define QMI_CM_SRV_SYS_CHANGED_MASK (0x00                   |   \
                                     CM_SS_P_REV_IN_USE_MASK |  \
                                     CM_SS_SRV_STATUS_MASK  |   \
                                     CM_SS_SRV_DOMAIN_MASK  |   \
                                     CM_SS_SRV_CAPABILITY_MASK  | \
                                     CM_SS_SYS_MODE_MASK    |   \
                                     CM_SS_ROAM_STATUS_MASK |   \
                                     CM_SS_SRV_IND_MASK         | \
                                     CM_SS_SYS_ID_MASK          | \
                                     CM_SS_HDR_SRV_STATUS_MASK  | \
                                     CM_SS_HDR_ROAM_STATUS_MASK | \
                                     CM_SS_HDR_ACTIVE_PROT_MASK | \
                                     CM_SS_SID_MASK | \
                                     CM_SS_NID_MASK | \
                                     CM_SS_BASE_STATION_PARMS_CHGD_MASK | \
                                     CM_SS_DEF_ROAM_IND_MASK | \
                                     CM_SS_CDMA_TIME_CHGD_MASK | \
                                     CM_SS_SIM_STATE_MASK | \
                                     CM_SS_MOBILITY_MGMT_MASK | \
                                     CM_SS_LAC_TAC_RAC_CHGD_MASK | \
                                     CM_SS_CELL_INFO_MASK | \
                                     CM_SS_SYS_PRL_MATCH_MASK | \
                                     CM_SS_CCS_SUPPORTED_MASK | \
                                     CM_SS_MCC_MASK | \
                                     CM_SS_IMSI_11_12_MASK | \
                                     CM_SS_SYS_FORBIDDEN_MASK )
/*---------------------------------------------------------------------------
  signal strength fields bitmask - ?
---------------------------------------------------------------------------*/
#define QMI_CM_SIGNAL_STR_CHANGE_MASK (0x00            | \
                                     CM_SS_RSSI_MASK | \
                                     CM_SS_ECIO_MASK | \
                                     CM_SS_IO_MASK   | \
                                     CM_SS_SINR_MASK | \
                                     CM_SS_BER_MASK  | \
                                     CM_SS_FER_MASK  | \
                                     CM_SS_RSRQ_MASK | \
                                     CM_SS_HDR_PER_MASK )

/*---------------------------------------------------------------------------
  For GSM and WCDMA, CM sends error rate on a 1 to 100 scale (as UINT8).
  For CDMA 1x and HDR, CM sends error rate on a 1 to 10000 scale (as UINT16).
  This multiplication factor is needed for normalization.
---------------------------------------------------------------------------*/
#define QMI_IF_GW_ERR_RATE_MULT_FACTOR 100
#define QMI_IF_MAX_GW_ERR_RATE         100
#define QMI_IF_MAX_CDMA_ERR_RATE       10000

/* --------------------------------------------------------------------------
  If MMGSDI session registration is not done/failed this will be the default value
  ---------------------------------------------------------------------------*/
#define QMI_IF_UNUSED_SESSION_ID    0xFFFFFFFF


/*===========================================================================

                                GLOBAL DATA

===========================================================================*/


/* This is the default QMI_IF command buffer. Make sure that it does not grow
 * beyond 512 bytes. In case you need a command buffer larger than 512 bytes,
 * declare a separate structure. */
typedef struct
{
  uint16  cmd_id; /* qmi_cmd_id_e_type */
  union
  {
    struct
    {
      qmi_if_cm_ss_info_type  info;
      cm_ss_event_e_type      event;
      sys_modem_as_id_e_type  asubs_id;
    } cm_ss;

    struct
    {
      qmi_if_cm_ph_info_type  info;
      cm_ph_event_e_type      event;
    } cm_ph;

    struct
    {
      qmi_if_cm_call_info_type    info;
      cm_call_event_e_type        event;
    } cm_call_evt;

    struct
    {
      uint8    otksl_flag;
    } otksl_update;

    struct
    {
      void *                user_data;
      cm_ph_cmd_err_e_type  err_type;
    } cm_ph_err;

    struct
    {
      void *                 user_data;
      cm_call_cmd_e_type     call_cmd;
      cm_call_cmd_err_e_type err_type;
    } cm_call_err;

    struct
    {
#define MAX_MMGSDI_BUFFER_LEN  512
      struct
      {
        mmgsdi_cnf_enum_type  cnf_type;
        mmgsdi_cnf_type       cnf_data;
        uint8                 read_cnf_data[MAX_MMGSDI_BUFFER_LEN];
      } mmgsdi_cnf_info;
      qmi_if_mmgsdi_evt_info_type mmgsdi_evt_info;
    } mmgsdi;

  } data;
} qmi_if_cmd_buf_type;

/*---------------------------------------------------------------------------
  WWAN device radio information
---------------------------------------------------------------------------*/
qmi_if_info_type  qmi_if_info;

/* remove later */
boolean pending_rssi_ind; //only for regular rssi var NOT for hdr_rssi

/*---------------------------------------------------------------------------
  Whether the device is configured to allow EGPRS connections (3GPP only)
  For non-3GPP technologies, this should be set to FALSE by default
---------------------------------------------------------------------------*/
boolean qmi_if_edge_feature_support;

static qmi_crit_sect_type qmi_if_spc_crit_section;

/*===========================================================================

                            FORWARD DECLARATIONS

===========================================================================*/

static void qmi_if_cm_ss_event_cb
(
  cm_ss_event_e_type            ss_event,    /* SS event that just occured */
  const cm_mm_msim_ss_info_s_type *  ss_info_ptr  /* ptr to serving system info */
);

static void qmi_if_ph_event_cb
(
  cm_ph_event_e_type        ph_event,
  const cm_ph_info_s_type * ph_info_ptr
);

static void qmi_if_call_event_cb
(
  cm_call_event_e_type           call_event,
  const cm_mm_call_info_s_type * call_info_ptr
);

#ifdef FEATURE_MMGSDI_SESSION_LIB
static void qmi_if_mmgsdi_session_reg 
(
  void
);

static void qmi_if_mmgsdi_session_evt_cb 
(
  const mmgsdi_event_data_type *event
);

static void qmi_if_mmgsdi_session_open_cb 
(
  mmgsdi_return_enum_type status,
  mmgsdi_cnf_enum_type    cnf,
  const mmgsdi_cnf_type  *cnf_ptr
);
#endif /* FEATURE_MMGSDI_SESSION_LIB */

static void qmi_if_determine_tds_rates
(
  uint32* tx_rate, 
  uint32* rx_rate
);

static void *qmi_if_get_cmd_buf
(
  qmi_cmd_id_e_type cmd_id
);

#define qmi_if_free_cmd_buf(buf_ptr) PS_SYSTEM_HEAP_MEM_FREE(buf_ptr)

// Failed attempt counter for qmi_if_check_spc()
static uint8 qmi_spc_attempt_counter;
#define QMI_MAX_SPC_ATTEMPTS    15

static void qmi_if_process_cmd
(
  void * cmd_ptr
);
/*= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

                        EXTERNAL FUNCTION DEFINTIONS

= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =*/

/*===========================================================================
  FUNCTION QMI_IF_INIT()

  DESCRIPTION
    Initialize the QMI interface layer
    This layer contains all the logic required for QMI subsystem to 
    interface with external modules, and vice versa.

  PARAMETERS
    None

  RETURN VALUE
    TRUE  - initialization succeeded
    FALSE - initialization failed

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_if_init
(
  void
)
{
#ifndef TEST_FRAMEWORK
  qmi_if_cmd_buf_type *  cmd_ptr;
#endif // TEST_FRAMEWORK

  nv_item_type      *dcc_nv_item_ptr;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  memset(&qmi_if_info, 0, sizeof(qmi_if_info_type));

  QMI_INIT_CRIT_SECTION(&qmi_if_spc_crit_section);

  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC_ASSERT(dcc_nv_item_ptr, sizeof(nv_item_type),
                                  nv_item_type*);
  if( dcc_nv_item_ptr == NULL )
  {
    return FALSE;
  }

  /* OTKSL Flag used to check OTKSL has already been entered or not*/
  qmi_if_info.otksl_valid = FALSE;

  /* Read and cache some NV SPC check related items */
  memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
  qmi_if_info.sec_code_nv_status = dcc_get_nv_item(NV_SEC_CODE_I, dcc_nv_item_ptr);
  if(NV_DONE_S == qmi_if_info.sec_code_nv_status)
  {
    qmi_if_info.nv_sec_code = dcc_nv_item_ptr->sec_code;
  }
  qmi_if_info.otksl_nv_status = dcc_get_nv_item(NV_OTKSL_I, dcc_nv_item_ptr);
  if(NV_DONE_S == qmi_if_info.otksl_nv_status)
  {
    qmi_if_info.nv_otksl = dcc_nv_item_ptr->otksl;
  }
  qmi_if_info.otksl_flag_nv_status = dcc_get_nv_item(NV_OTKSL_FLAG_I, dcc_nv_item_ptr);
  if (NV_DONE_S == qmi_if_info.otksl_flag_nv_status)
  {
    qmi_if_info.nv_otksl_flag = dcc_nv_item_ptr->otksl_flag;
  }

  /*-------------------------------------------------------------------------
    Intialize the below to CM UNinitialized values:
    CM_NETWORK_SEL_MODE_PREF_NONE=-1; CM_MODE_PREF_NONE=-1
  -------------------------------------------------------------------------*/
  qmi_if_info.ph_info.mode_pref = (cm_mode_pref_e_type )-1;                                         
  qmi_if_info.ph_info.oprt_mode = (sys_oprt_mode_e_type )-1; 
  qmi_if_info.ph_info.cdma_lock_mode = (cm_cdma_lock_mode_e_type )-1;                                         

  qmi_if_info.spc_inited = TRUE;
  /*-------------------------------------------------------------------------
    Initialize the WWAN CM client & register for serving system and
    phone events
  -------------------------------------------------------------------------*/
  if( CM_CLIENT_OK != cm_client_init( CM_CLIENT_TYPE_RM_NETWORK_INTERFACE,
                                      &qmi_if_info.cm_client_id) )
  {
    LOG_MSG_ERROR_0 ("WWAN interface layer initialization failed!");
    PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);
    return FALSE;
  }

  /*-------------------------------------------------------------------------
    register call manager multimode serving system event notification
  -------------------------------------------------------------------------*/
  if( CM_CLIENT_OK != cm_mm_client_ss_reg_msim(
                        qmi_if_info.cm_client_id,
                        qmi_if_cm_ss_event_cb,
                        CM_CLIENT_EVENT_REG,
                        CM_SS_EVENT_SRV_CHANGED,    /* min event to report */
                        CM_SS_EVENT_REG_REJECT,        /* max event to report */
                        NULL,                          /* other client errors */
                        SYS_MODEM_AS_ID_MASK_ANY))     /*Subs_id mask */
                      
  {
    PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);
    DATA_ERR_FATAL("CM client SS event reg failed");
    return FALSE;
  }

  if( CM_CLIENT_OK != 
        cm_client_ph_reg( qmi_if_info.cm_client_id,
                          qmi_if_ph_event_cb,  /* cm_ph_event_f_type */
                          CM_CLIENT_EVENT_REG,
                          CM_PH_EVENT_OPRT_MODE,
                          CM_PH_EVENT_PRL_INIT,
                          NULL /* err cb */ ) )
  {
    PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);
    DATA_ERR_FATAL("CM client PH event reg failed");
    return FALSE;
  }

  if( CM_CLIENT_OK != 
        cm_client_ph_reg( qmi_if_info.cm_client_id,
                          qmi_if_ph_event_cb,  /* cm_ph_event_f_type */
                          CM_CLIENT_EVENT_REG,
                          CM_PH_EVENT_CDMA_LOCK_MODE,
                          CM_PH_EVENT_CDMA_LOCK_MODE,
                          NULL /* err cb */ ) )
  {
    PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);
    DATA_ERR_FATAL("CM client PH event reg failed");
    return FALSE;
  }

  if (!cm_ph_cmd_get_ph_info(NULL, NULL, qmi_if_info.cm_client_id))
  {
    LOG_MSG_ERROR("cm_ph_cmd_get_ph_info() req failed ", 0, 0, 0);
  }


  if( CM_CLIENT_OK != 
        cm_mm_client_call_reg( qmi_if_info.cm_client_id,
                               qmi_if_call_event_cb,  /* cm_mm_call_event_f_type */
                               CM_CLIENT_EVENT_REG,
                               CM_CALL_EVENT_ORIG,
                               CM_CALL_EVENT_OTASP_STATUS,
                               NULL /* err cb */ ) )
  {
    PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);
    DATA_ERR_FATAL("CM client PH event reg failed");
    return FALSE;
  }

#ifdef FEATURE_MMGSDI_SESSION_LIB
  qmi_if_info.session_info[QMI_IF_MMGSD_GW_PROV_PRI_SESSION].app_type = MMGSDI_APP_NONE;
  qmi_if_info.session_info[QMI_IF_MMGSD_GW_PROV_PRI_SESSION].session_id= QMI_IF_UNUSED_SESSION_ID;
  
  qmi_if_info.session_info[QMI_IF_MMGSD_1X_PROV_PRI_SESSION].app_type = MMGSDI_APP_NONE;
  qmi_if_info.session_info[QMI_IF_MMGSD_1X_PROV_PRI_SESSION].session_id= QMI_IF_UNUSED_SESSION_ID;
  
#ifdef FEATURE_DUAL_SIM
  qmi_if_info.session_info[QMI_IF_MMGSD_GW_PROV_SEC_SESSION].app_type = MMGSDI_APP_NONE;
  qmi_if_info.session_info[QMI_IF_MMGSD_GW_PROV_SEC_SESSION].session_id= QMI_IF_UNUSED_SESSION_ID;
#endif

#ifdef FEATURE_TRIPLE_SIM
  qmi_if_info.session_info[QMI_IF_MMGSD_GW_PROV_TER_SESSION].app_type = MMGSDI_APP_NONE;
  qmi_if_info.session_info[QMI_IF_MMGSD_GW_PROV_TER_SESSION].session_id= QMI_IF_UNUSED_SESSION_ID;
#endif

  /*-----------------------------------------------------------------------
      Request client id for QMI from mmgsdi
  -----------------------------------------------------------------------*/  
  if ( MMGSDI_SUCCESS != mmgsdi_client_id_and_evt_reg(
                                      qmi_if_mmgsdi_evt_cback,
                                      qmi_if_mmgsdi_resp_cback, 
                                      (mmgsdi_client_data_type)NULL ) )
  {
    PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);
    DATA_ERR_FATAL("MMGSDI client id & event reg failed");
    return FALSE;
  }
#endif /* FEATURE_MMGSDI_SESSION_LIB */

#if defined(FEATURE_WCDMA) || defined(FEATURE_GSM)
  /* Determine the current GPRS multislot classes */
  qmi_if_info.gw_info.gprs_multislot_class = gmm_read_gprs_multislot_class();
  memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
  /* if the item successfully read, use that value */
  if (NV_DONE_S == dcc_get_nv_item(NV_MULTISLOT_CLASS_I, dcc_nv_item_ptr))
  {
    /* check the valid GPRS multislot range which is 1-18 and 30-34 */
    if ((( 1 <= dcc_nv_item_ptr->multislot_class) && 
         (18 >= dcc_nv_item_ptr->multislot_class)) || 
        ((30 <= dcc_nv_item_ptr->multislot_class) &&
         (34 >= dcc_nv_item_ptr->multislot_class)))
    {
      qmi_if_info.gw_info.gprs_multislot_class =
        dcc_nv_item_ptr->multislot_class;
    }
  }
  
  /* Determine the current EDGE multislot classes */
  qmi_if_info.gw_info.edge_multislot_class = gmm_read_edge_multislot_class();
  memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
  /* if the item successfully read, use that value */
  if (NV_DONE_S == dcc_get_nv_item(NV_EDGE_MULTISLOT_CLASS_I, 
                                   dcc_nv_item_ptr))
  {
    /* check the valid EDGE multislot range which is 1-34 */
    if (( 0 < dcc_nv_item_ptr->edge_multislot_class) && 
        (34 >= dcc_nv_item_ptr->edge_multislot_class))
    {
      qmi_if_info.gw_info.edge_multislot_class =
        dcc_nv_item_ptr->edge_multislot_class;
    }
  }

  /* Determine whether EDGE is supported */
  #if defined(FEATURE_GSM_EGPRS) && !defined(FEATURE_EDGE_CAPABILITY_NOT_SUPPORTED)
  memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
  if (NV_DONE_S == dcc_get_nv_item(NV_EDGE_FEATURE_SUPPORT_I,
                                   dcc_nv_item_ptr))
  {
    qmi_if_edge_feature_support = dcc_nv_item_ptr->edge_feature_support;
  }
  else
  {
    /* Default to enabled (this is the same behavior as in NAS MM) */
    qmi_if_edge_feature_support = TRUE;
  }
  #else
  /* EDGE is disabled by feature flag configuration */
  qmi_if_edge_feature_support = FALSE;
  #endif /* defined(FEATURE_GSM_EGPRS) && !defined(FEATURE_EDGE_CAPABILITY_NOT_SUPPORTED) */
  /* For WCDMA/HSDPA/HSUPA, retreive the default data rates from RRC */
#endif /* defined(FEATURE_WCDMA) || defined(FEATURE_GSM) */

  /* Cache the TX/RX rate for TDSCDMA after reading HSDPA/HSUPA category */
  qmi_if_determine_tds_rates(&qmi_if_info.tds_info.tx_rate, &qmi_if_info.tds_info.rx_rate);
  
#ifndef TEST_FRAMEWORK
  /*-------------------------------------------------------------------------
    Activate the registered callback functions with CM.
    Activating these by posting a DCC cmd (instead of doing in init()
    to avoid having a lot of cm events during dcc_task init time
    leading to exhaustion of DCC cmd buffers
  -------------------------------------------------------------------------*/
  cmd_ptr = (qmi_if_cmd_buf_type *)qmi_if_get_cmd_buf(QMI_CMD_CM_CLIENT_ACTIVATE);

  if(cmd_ptr != NULL)
  {
    cmd_ptr->cmd_id = QMI_CMD_CM_CLIENT_ACTIVATE;
    dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
  }
  else
  {
    ASSERT(0);
  }
#endif /* TEST_FRAMEWORK */

  pending_rssi_ind = FALSE; 
  qmi_task_set_common_cmd_handler(qmi_if_process_cmd);

  PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);
  return TRUE;
} /* qmi_if_init() */


/*===========================================================================
  FUNCTION QMI_IF_REG_CM()

  DESCRIPTION
    Register the CM SS & PH event notification

  PARAMETERS
    None

  RETURN VALUE
    TRUE  - registration succeeded
    FALSE - registration failed

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_if_reg_cm
(
  void
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  /*-------------------------------------------------------------------------  
    Activate the registered callback functions with CM.
    Activating these by posting a DCC cmd (instead of doing in init()
    to avoid having a lot of cm events during ds_task init time
    leading to exhaustion of DCC cmd buffers
  -------------------------------------------------------------------------*/  
  if( CM_CLIENT_OK != cm_client_act( qmi_if_info.cm_client_id ) )
  {
    DATA_ERR_FATAL("CM client callback activation failed");
    return FALSE;
  }

  return TRUE;
} /* qmi_if_reg_cm() */



/*===========================================================================
  FUNCTION QMI_IF_DEREG_CM()

  DESCRIPTION
    Deregister the CM SS & PH event notification

  PARAMETERS
    None

  RETURN VALUE
    TRUE  - Deregistration succeeded
    FALSE - Deregistration failed

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_if_dereg_cm
(
  void
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  /*-------------------------------------------------------------------------  
    deactivate CM event reporting
  -------------------------------------------------------------------------*/  
  if( CM_CLIENT_OK != cm_client_deact( qmi_if_info.cm_client_id ) )
  {
    LOG_MSG_ERROR_0("CM client callback deactivation failed");
    return FALSE;
  }

  return TRUE;
} /* qmi_if_dereg_cm() */

/*===========================================================================
  FUNCTION QMI_IF_GET_WCDMA_DEFAULT_CHANNEL_RATE()

  DESCRIPTION
    Get the WCDMA including HSDPA/HSUPA default/maximum data channel rate using
    RRC API..

  PARAMETERS
    tx_rate      : Tx rate to be reported
    rx_rate      : Rx rate to be reported

  RETURN VALUE
    none

  DEPENDENCIES
    none

  SIDE EFFECTS
    None
===========================================================================*/
 void qmi_if_get_wcdma_default_channel_rate
(
  uint32 *            tx_rate, 
  uint32 *            rx_rate 
)
{
#ifdef FEATURE_WCDMA
  rrc_data_rate_info_type data_rate;

#ifdef FEATURE_SEGMENT_LOADING
  interface_t *ds_qmi_wcdma_tbl = NULL;
  ds_qmi_wcdma_tbl = get_wcdma_interface(); 
  if(NULL != ds_qmi_wcdma_tbl)
  {
    data_rate = IWCDMA_rrc_get_data_rate_for_ds(ds_qmi_wcdma_tbl);
  }
  else
  {
    LOG_MSG_ERROR_0("Got invalid ds_qmi_wcdma_tbl");
    return;
  }
#else
  data_rate = rrc_get_data_rate_for_ds();
#endif/* FEATURE_SEGMENT_LOADING */

  *tx_rate = data_rate.ul_ded_rate;
  *rx_rate = data_rate.dl_ded_rate;
#else 
  *tx_rate = 0;
  *rx_rate = 0;
  LOG_MSG_ERROR_0("Invalid Channel data rate request");
#endif /* FEATURE_WCDMA */

}/* qmi_if_get_wcdma_default_channel_rate */

/*===========================================================================
  FUNCTION QMI_IF_GET_TDSCDMA_DEFAULT_CHANNEL_RATE()

  DESCRIPTION
    Get the TDSCDMA default/maximum data channel rate 

  PARAMETERS
    tx_rate      : Tx rate to be reported
    rx_rate      : Rx rate to be reported

  RETURN VALUE
    none

  DEPENDENCIES
    none

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_get_tdscdma_default_channel_rate
(
  uint32 *            tx_rate, 
  uint32 *            rx_rate 
)
{
  *tx_rate = qmi_if_info.tds_info.tx_rate;
  *rx_rate = qmi_if_info.tds_info.rx_rate;
}/* qmi_if_get_tdscdma_default_channel_rate */

/*===========================================================================
FUNCTION      QMI_IF_IS_SUBS_ID_VALID

DESCRIPTION   This function validates the subscription index

DEPENDENCIES  None.

RETURN VALUE  TRUE or FALSE based on whether subs_id is valid or not.

SIDE EFFECTS  None.
===========================================================================*/
static boolean qmi_if_is_subs_id_valid
(
  qmi_if_asubs_id_type subs_id
)
{
 /* Range check */
  if((subs_id < QMI_IF_AS_ID_MIN) || (subs_id >= QMI_IF_AS_ID_MAX))
  {
    LOG_MSG_ERROR_1("qmi_if_is_subs_id_valid: Invalid subs_id:%d.",subs_id);
    return FALSE;
  }
 return TRUE;
}/* qmi_if_is_subs_id_valid() */

/*===========================================================================
FUNCTION      qmi_if_get_default_sub_id

DESCRIPTION   This function gets the default data subscription from ds3gpp
              and validates.

DEPENDENCIES  None.

RETURN VALUE  returns default data subscription id

SIDE EFFECTS  None.
===========================================================================*/
qmi_if_asubs_id_type qmi_if_get_default_sub_id
(
  void
)
{
  qmi_if_asubs_id_type asub_id = QMI_IF_AS_ID_MIN;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  asub_id = (qmi_if_asubs_id_type)ds3g_get_ps_subs_id();
  if(!qmi_if_is_subs_id_valid((qmi_if_asubs_id_type)asub_id))
  { 
    /*Lets take Default as primary*/
    LOG_MSG_INFO1_0("qmi_if_get_default_sub_id: return Default sub_id:0");
    asub_id = QMI_IF_AS_ID_1;
  }
  return asub_id;
}

/*===========================================================================
  FUNCTION QMI_IF_GET_DEFAULT_CHANNEL_RATE()

  DESCRIPTION
    Get the current serving system's default/maximum data channel rate.

  PARAMETERS
    tx_rate      : Tx rate to be reported
    rx_rate      : Rx rate to be reported

  RETURN VALUE
    none

  DEPENDENCIES
    none

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_if_get_default_channel_rate
( 
  uint32 *            tx_rate, 
  uint32 *            rx_rate 
)
{
  qmi_channel_info_s_type supp_channel_info;
  qmi_if_asubs_id_type asub_id;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (rx_rate && tx_rate);

  memset(&supp_channel_info, 0, sizeof(supp_channel_info));

  /*always use default data subscription for getting channel rate*/
  asub_id = qmi_if_get_default_sub_id();

  switch( qmi_if_info.ss_info[asub_id].sys_mode )
  {
    case SYS_SYS_MODE_NO_SRV:
    case SYS_SYS_MODE_AMPS:
    case SYS_SYS_MODE_GPS:
    {
      supp_channel_info.supp_channel = QMI_CHANNEL_SUPP_MIN;
      break;
    }

    case SYS_SYS_MODE_CDMA:
    {
      supp_channel_info.supp_channel = QMI_CHANNEL_SUPP_CDMA;
      break;
    }

    case SYS_SYS_MODE_HDR:
    {
      supp_channel_info.supp_channel = QMI_CHANNEL_SUPP_HDR_REV0;
      /* EVDO Rev0 */
      if (qmi_if_info.ss_info[asub_id].hdr_active_prot == SYS_ACTIVE_PROT_HDR_REL0)
      {
        supp_channel_info.supp_channel = QMI_CHANNEL_SUPP_HDR_REV0;
      }
      /* EVDO RevA */
      if (qmi_if_info.ss_info[asub_id].hdr_active_prot == SYS_ACTIVE_PROT_HDR_RELA)
      {
        supp_channel_info.supp_channel = QMI_CHANNEL_SUPP_HDR_REVA;
      }
      break;
    }

    case SYS_SYS_MODE_GSM:
    {
      if( qmi_if_info.ss_info[asub_id].srv_capability == SYS_SRV_DOMAIN_PS_ONLY ||
          qmi_if_info.ss_info[asub_id].srv_capability == SYS_SRV_DOMAIN_CS_PS )
      {
        if (  qmi_if_info.ss_info[asub_id].cell_srv_ind.egprs_supp && qmi_if_edge_supported() ) // EDGE
        {
          supp_channel_info.supp_channel = QMI_CHANNEL_SUPP_EDGE;
          supp_channel_info.extend.gprs_edge.multislot_class = 
                                       qmi_if_info.gw_info.edge_multislot_class;
        }
        else  // GPRS
        {
          supp_channel_info.supp_channel = QMI_CHANNEL_SUPP_GPRS;
                    /* current GPRS multislot class */
          supp_channel_info.extend.gprs_edge.multislot_class = 
                                       qmi_if_info.gw_info.gprs_multislot_class;
        }
      }
      else
      {
        supp_channel_info.supp_channel = QMI_CHANNEL_SUPP_MIN;
      }
      break;
    }

    case SYS_SYS_MODE_GW:
    case SYS_SYS_MODE_WCDMA:
    {
      if( qmi_if_info.ss_info[asub_id].srv_capability == SYS_SRV_DOMAIN_PS_ONLY ||
          qmi_if_info.ss_info[asub_id].srv_capability == SYS_SRV_DOMAIN_CS_PS )
      {
        supp_channel_info.supp_channel = QMI_CHANNEL_SUPP_WCDMA;
      }
      break;
    }

    case SYS_SYS_MODE_LTE:
    case SYS_SYS_MODE_GWL:
    {
      supp_channel_info.supp_channel = QMI_CHANNEL_SUPP_LTE;
      break;
    }
    case SYS_SYS_MODE_TDS:
    {
      supp_channel_info.supp_channel = QMI_CHANNEL_SUPP_TDSCDMA;
      break;
    }

    default:
    {
      supp_channel_info.supp_channel = QMI_CHANNEL_SUPP_MIN;
      LOG_MSG_INFO1_0 ("Invalid sys mode!");
      break;
    }
  } /* end switch */

  qmi_svc_ext_get_default_channel_rates( supp_channel_info, tx_rate, rx_rate );
} /* qmi_if_get_default_channel_rate() */


/*===========================================================================
  FUNCTION QMI_IF_GET_MAX_CHANNEL_RATE()

  DESCRIPTION
    Get the current serving system's maximum data channel rate.

  PARAMETERS
    None

  RETURN VALUE
    none

  DEPENDENCIES
    none

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_get_max_channel_rate
(
  ps_iface_type *      iface_ptr,
  uint32 *             tx_rate,
  uint32 *             rx_rate
)
{
  ps_iface_ioctl_data_bearer_rate  channel_rate_info;
  sint15                           ps_errno;
  int                              retval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (rx_rate && tx_rate);

  if(iface_ptr != NULL)
  {
    retval = ps_iface_ioctl(iface_ptr, 
                            PS_IFACE_IOCTL_GET_DATA_BEARER_RATE, 
                            &channel_rate_info,
                            &ps_errno);
  
    if(retval == 0)
    {
      if((channel_rate_info.max_tx_bearer_data_rate >=0) &&
         (channel_rate_info.max_rx_bearer_data_rate >=0))
      {
        *tx_rate = (uint32) channel_rate_info.max_tx_bearer_data_rate;
        *rx_rate = (uint32) channel_rate_info.max_rx_bearer_data_rate;
        return;
      }
    }
  }

  *rx_rate = 0;
  *tx_rate = 0;

  /*--------------------------------------------------------------------
    Need this fallback mechanism to report MAX channel rates when not 
    in a call. Also used for cases when ioctl doesn't correct max values
  --------------------------------------------------------------------*/

  qmi_if_get_default_channel_rate( tx_rate, rx_rate );

} /* qmi_if_get_max_channel_rate() */



/*===========================================================================
  FUNCTION QMI_IF_GET_CURRENT_CHANNEL_RATE()

  DESCRIPTION
    Get the current data channel rate.

  PARAMETERS
    None

  RETURN VALUE
    none

  DEPENDENCIES
    none

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_get_current_channel_rate
(
  ps_iface_type *      iface_ptr,
  uint32 *             tx_rate,
  uint32 *             rx_rate
)
{
  ps_iface_ioctl_data_bearer_rate  channel_rate_info;
  sint15                           ps_errno;
  int                              retval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  ASSERT (rx_rate && tx_rate);

  if(iface_ptr == NULL)
  {
    /*--------------------------------------------------------------------
      The Call is not up, so return the CURRENT channel rate as 0
    --------------------------------------------------------------------*/
    *tx_rate = 0;
    *rx_rate = 0;
    return;
  }
  retval = ps_iface_ioctl(iface_ptr, 
                          PS_IFACE_IOCTL_GET_DATA_BEARER_RATE, 
                          &channel_rate_info,
                          &ps_errno);
  if(retval == 0)
  {
    if((channel_rate_info.current_tx_bearer_data_rate >=0) &&
       (channel_rate_info.current_rx_bearer_data_rate >=0))
    {
      *tx_rate = (uint32) channel_rate_info.current_tx_bearer_data_rate;
      *rx_rate = (uint32) channel_rate_info.current_rx_bearer_data_rate;
      return;
    }
  }

  /*--------------------------------------------------------------------
    Return unknown if lower layers don't return the current rates
  --------------------------------------------------------------------*/
  *tx_rate = 0xFFFFFFFF;
  *rx_rate = 0xFFFFFFFF;
} /* qmi_if_get_current_channel_rate() */

/*===========================================================================
  FUNCTION QMI_IF_GET_POWER_STATE()

  DESCRIPTION
    Returns the current power status and battery level.
    The external charger module is queried to obtain these values.

  PARAMETERS - Output
   power status  : current power status (bitmask)
   battery level : current battery level

  RETURN VALUE
    None
 
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_get_power_state
(
  uint8 * power_status,
  uint8 * battery_lvl
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  ASSERT (power_status && battery_lvl);

  /*-------------------------------------------------------------------------
    Power fault is not detected yet
  -------------------------------------------------------------------------*/
  *power_status = 0;
  if(TRUE == qmi_charger_is_ext_pwr_src_used())
  {
    *power_status |= QMI_PWR_ST_EXT_POWER_SRC_MASK;
  }

  if(TRUE == qmi_charger_is_battery_connected())
  {
    *power_status |= QMI_PWR_ST_BAT_CONNECTED_MASK;
  }

  if(TRUE == qmi_charger_is_charging())
  {
    *power_status |= QMI_PWR_ST_CHARGING_MASK;
  }

  /*-------------------------------------------------------------------------
    Determine battery level by querying external charger module
  -------------------------------------------------------------------------*/
  *battery_lvl = qmi_charger_get_battery_level();

} /* qmi_if_get_power_state() */

/*===========================================================================
  FUNCTION QMI_IF_CHECK_SPC()

  DESCRIPTION
  	This function checks the SPC and OTKSL for r/w to NV items like ACCOLC 

  PARAMETERS - spc code, bCheck_otksl - if need to check for OTKSL if SPC fails 

  RETURN VALUE
    SPC Check Result 
 
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_if_spc_result_e_type qmi_if_check_spc
(
  uint8* spc_code, boolean bCheck_otksl
)
{
  qmi_if_spc_result_e_type spc_chk_result = QMI_SPC_OK; 

  nv_sec_code_type       sec_code;
  uint8                  i;
  qmi_if_cmd_buf_type *  cmd_ptr;
  int                    spc_mismatch = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  LOG_MSG_INFO2_0 ("qmi_if_check_spc() START");

  if(FALSE == qmi_if_info.spc_inited)
  {
    return QMI_SPC_ERR_INTERNAL;
  }

  QMI_ENTER_CRIT_SECTION(&qmi_if_spc_crit_section);

  /* Read SEC CODE from NV */
  if(qmi_if_info.sec_code_nv_status != NV_DONE_S)
  {
    LOG_MSG_INFO2_0 ("QMI_SPC_FAIL");
    spc_chk_result = QMI_SPC_FAIL;
  }
  else
  {
    sec_code = qmi_if_info.nv_sec_code;
    /* Start out assuming it is ok */
    spc_chk_result = QMI_SPC_OK;

    /* Now check every character in the code, and make sure they match! */
    for (i = 0; i < NV_SEC_CODE_SIZE; i++) 
    {
      spc_mismatch |= (*(spc_code+i) ^ sec_code.digits[i]);
    }

    if (spc_mismatch)
      {
        LOG_MSG_INFO2_0 ("QMI_SPC_FAIL 1");
        spc_chk_result = QMI_SPC_FAIL;
    }
  }

  if (bCheck_otksl) 
  {
    /* Only check the OTKSL if the SPC did not match. */
    if (QMI_SPC_FAIL == spc_chk_result)
    {
      /* Read OTKSL CODE from NV.  Only allow OTKSL to be used if this code is
         actually set, if it is inactive then OTKSL support has not been
         provisioned. */
      if(NV_DONE_S == qmi_if_info.otksl_nv_status)
      {
        sec_code = qmi_if_info.nv_otksl;
        /* Start out assuming it is ok */
        spc_chk_result = QMI_SPC_OK;
        spc_mismatch = 0;
        /* Now check every character in the code, and make sure they match! */
        for (i = 0; i < NV_SEC_CODE_SIZE; i++) 
        {
          spc_mismatch |= (*(spc_code+i) ^ sec_code.digits[i]); 
        }
        
        if (spc_mismatch)
          {
            spc_chk_result = QMI_SPC_FAIL;
        }

        /* See if the OTKSL code matched. */
        if (QMI_SPC_OK == spc_chk_result)
        {
          /* Check the current value of the OTKSL Flag.  Only allow OTKSL to be
             used if this flag is actually set, if it is inactive then OTKSL
             support has not been provisioned.

             Although this says it is a flag, it is really a decrementing
             counter for the number of retries remaining.*/
          if (NV_DONE_S == qmi_if_info.otksl_flag_nv_status)
          {
            /* Check that there are either retries remaining in the OTKSL Flag
               counter or that the correct OTKSL has already been entered since
               power-up. */
            if ((0 < qmi_if_info.nv_otksl_flag) || 
                                              (TRUE == qmi_if_info.otksl_valid))
            {
              /* If the OTKSL has not been entered before, need to update the
                 OTKSL Flag counter and global. */
              if (TRUE != qmi_if_info.otksl_valid)
              {
                cmd_ptr= (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_PROCESS_OTKSL_FLAG_UPDATE);
                if (cmd_ptr != NULL )
                {
                  /* Post a command to process updating of OTKSL flag in DCC task */
                  cmd_ptr->cmd_id = QMI_CMD_PROCESS_OTKSL_FLAG_UPDATE;
                  cmd_ptr->data.otksl_update.otksl_flag = qmi_if_info.nv_otksl_flag - 1;
                  dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
                }
                
                /*dcc_nv_item_ptr->otksl_flag--;
                (void) dcc_put_nv_item(NV_OTKSL_FLAG_I, dcc_nv_item_ptr);
                qmi_if_info.otksl_valid = TRUE;*/
              }
            }
          }
        }
      }
    }
  }

  if(spc_chk_result == QMI_SPC_FAIL)
  {
    // Inc the falied attempt counter 
    qmi_spc_attempt_counter++;
    if (qmi_spc_attempt_counter > QMI_MAX_SPC_ATTEMPTS) 
    {
      spc_chk_result = QMI_SPC_LOCKED;

      if(cm_rpm_check_reset_allowed())
      {
        /* Issue a power down command to sys monitor */
        ds_qmi_cflog_amss_call("sys_m_initiate_poweroff()");
        LOG_MSG_INFO1_0("Triggered Sys Initate Poweroff");
        sys_m_initiate_poweroff();
      }
      else
      {
        LOG_MSG_ERROR_1("qmi_spc_attempt_counter:%d exceeded MAX_Val.CM denied shutdown",qmi_spc_attempt_counter);
      }
    }
  }
  else
  {
    qmi_spc_attempt_counter = 0;
  }

  QMI_LEAVE_CRIT_SECTION(&qmi_if_spc_crit_section);
  LOG_MSG_INFO2_0 ("qmi_if_check_spc() END");
  return spc_chk_result;
} /* qmi_if_check_spc() */


/*===========================================================================
  FUNCTION QMI_IF_PROCESS_CM_SS_EVENT()

  DESCRIPTION
    Process the CM SS event generated and call coresponding functions in
    QMI services to generate indications
  PARAMETERS
    ss_event  :  CM SS event
    ss_info   :  serving system info obtained from CM SS event
    asubs_id  :   On which subscription event was received
    
  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_process_cm_ss_event
(
  cm_ss_event_e_type      ss_event,
  qmi_if_cm_ss_info_type  ss_info,
  sys_modem_as_id_e_type  asubs_id
)
{
  boolean is_dev_mode_changed = FALSE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(!qmi_if_is_subs_id_valid(asubs_id))
  {
    LOG_MSG_ERROR_1("CM SS event received for invalid subs_id:%d. Discard",asubs_id);
    return;
  }

  LOG_MSG_INFO2_4("Processing CM SS event (%x), changed_fields = (0x%x) (0x%x)"
                   "on subs_id:%d",
                   ss_event,
                   QWORD_HIGH(ss_info.changed_fields),
                   QWORD_LOW(ss_info.changed_fields),
                   asubs_id);

  switch (ss_event)
  {
    /*-----------------------------------------------------------------------
      On serving system change (as indicated by CM in changed_fields) or on 
      serving system event info ev (don't check changed fields in this case)
      - send serving system indication
      - send channel rate indication
    -----------------------------------------------------------------------*/
    case CM_SS_EVENT_SRV_CHANGED:
    case CM_SS_EVENT_INFO:
    {
      if ( ( (ss_event == CM_SS_EVENT_SRV_CHANGED) && 
             (ss_info.changed_fields & QMI_CM_SRV_SYS_CHANGED_MASK) ) ||
           (ss_event == CM_SS_EVENT_INFO) )
      {
        LOG_MSG_INFO2_1("Got new serving system info, saving it in index : %d",asubs_id);
        if(asubs_id == SYS_MODEM_AS_ID_1)
        {
           /*In single sim SVLTE case, if hybrid stack operational status changed then 
                       Device mode is changed b/w SVLTE and CSFB. Trigger an DMS indication to inform clients*/
           is_dev_mode_changed = ((qmi_if_info.ss_info[SYS_MODEM_AS_ID_1].is_hybr_stack_operational != 
                                  ss_info.is_hybr_stack_operational)?TRUE:FALSE);
        }
        memscpy(&qmi_if_info.ss_info[asubs_id],
                sizeof(qmi_if_cm_ss_info_type),
               &ss_info,
               sizeof(qmi_if_cm_ss_info_type));
        qmi_if_info.inited = TRUE;

        //Convert asubs_id to PS subs id before sending to WDS
        qmi_wds_generate_channel_rate_ind(QMI_IF_CH_RATE_TRIGGER_SS_CHANGE,1,asubs_id +1);
        qmi_wds_generate_channel_rate_ind(QMI_IF_CH_RATE_TRIGGER_SS_CHANGE,0,asubs_id +1);
        
        if(is_dev_mode_changed)
        {
          qmi_dms_device_mode_changed();
        }
      }
      break;
    }

    default:
      break;
  }
} /* qmi_if_process_cm_ss_event() */



/*===========================================================================
  FUNCTION QMI_IF_PROCESS_CM_PH_EVENT()

  DESCRIPTION
    Process the CM SS event generated and call coresponding functions in
    QMI services to generate indications

  PARAMETERS
    ph_event  :  CM Ph event
    ph_info   :  Phone info obtained from CM Ph event
    
  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_process_cm_ph_event
(
  cm_ph_event_e_type      ph_event,
  qmi_if_cm_ph_info_type  ph_info    
)
{
  nv_stat_enum_type  nv_status;
  nv_item_type      *dcc_nv_item_ptr;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  LOG_MSG_INFO1_1("Processing Phone Event 0x%X from CM", ph_event);

  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC_ASSERT(dcc_nv_item_ptr, sizeof(nv_item_type),
                                  nv_item_type*);
  if( dcc_nv_item_ptr == NULL )
  {
    return;
  }

  switch (ph_event)
  {
    case CM_PH_EVENT_INFO_AVAIL:
      {
        /*  Update ph cache */
        if( CM_MODE_PREF_EMERGENCY != ph_info.mode_pref) 
        {
          qmi_if_info.ph_info.mode_pref = ph_info.mode_pref;
        }
        qmi_if_info.ph_info.prl_only  = ph_info.prl_only;
        qmi_if_info.ph_info.band_capability = ph_info.band_capability;
#ifdef LTE_BAND_NUM
        memscpy(&qmi_if_info.ph_info.lte_band_capability,
                sizeof(sys_lte_band_mask_e_type),
                &ph_info.lte_band_capability,
                sizeof(sys_lte_band_mask_e_type));
#else
        qmi_if_info.ph_info.lte_band_capability = ph_info.lte_band_capability;
#endif /* LTE_BAND_NUM */
        qmi_if_info.ph_info.tds_band_capability = ph_info.tds_band_capability;
        qmi_if_info.ph_info.mode_capability = ph_info.mode_capability;
        qmi_if_info.ph_info.oprt_mode = ph_info.oprt_mode;
        break;
      }

    case CM_PH_EVENT_INFO:
      qmi_if_info.ph_info.oprt_mode = ph_info.oprt_mode;
      /* code to handle prl info in cases where prl init event
       is not recieved and has to be updated through get_ph_info called during init
       This if condition makes sure prl is filled in only when prl init is missed */
      if ( (qmi_if_info.prl_info_valid  != TRUE) && ( ph_info.is_prl_load_complete == TRUE ) )
      {
        qmi_if_info.ph_info.prl_id   = ph_info.prl_id;
        qmi_if_info.ph_info.prl_only = ph_info.prl_only;
        qmi_if_info.prl_info_valid   = TRUE;
        qmi_dms_generate_prl_init_ind();
      }
      break;

    case CM_PH_EVENT_SYS_SEL_PREF:
      /* If emergency mode is sent in mode_pref from CM, 
         we need to set that boolean and not update mode_pref field 
         so that qmi sys_sel_pref IND message can send both TLVs.
      */
      if( CM_MODE_PREF_EMERGENCY != ph_info.mode_pref) 
      {
        qmi_if_info.ph_info.mode_pref = ph_info.mode_pref;
      }
      break;

    case CM_PH_EVENT_OPRT_MODE:
      /* If transitioning out of PLPM -> ONLINE remove the PLPM NV Flag */
      if ((SYS_OPRT_MODE_LPM == qmi_if_info.ph_info.oprt_mode) && 
          (SYS_OPRT_MODE_ONLINE == ph_info.oprt_mode))
      {
        /* Check PLPM NV */
        /* Read the nv for LPM persistence flag */
        nv_status = dcc_get_nv_item( NV_LPM_PERSISTENCE_I, dcc_nv_item_ptr );
        if (NV_DONE_S == nv_status)
        {
          /* Clear nv for LPM or set it for P_LPM only if the nv doesn't match
             the mode request*/
          if (dcc_nv_item_ptr->lpm_persistence)
          {
            /* Clear the PLPM Flag */
            dcc_nv_item_ptr->lpm_persistence = 0;
            if (NV_DONE_S != dcc_put_nv_item(NV_LPM_PERSISTENCE_I, dcc_nv_item_ptr))
            {
              LOG_MSG_ERROR_1("Could not set NV_LPM_PERSISTENCE_I to %d",
                              dcc_nv_item_ptr->lpm_persistence);
            }
          }
        }

        /* Update the mode preference, as power cycle mode prefs are lost after
         * toggling LPM, but we don't get a PH event. */

          if (!cm_ph_cmd_get_ph_info(NULL, NULL, qmi_if_info.cm_client_id))
          {
            LOG_MSG_ERROR_0("cm_ph_cmd_get_ph_info() req failed ");
          }
        }

      if (qmi_if_info.ph_info.oprt_mode != ph_info.oprt_mode)
      {
        qmi_if_info.ph_info.oprt_mode = ph_info.oprt_mode;
        qmi_dms_generate_oprt_mode_ind(qmi_if_info.ph_info.oprt_mode);
        qmi_wds_process_oprt_mode (qmi_if_info.ph_info.oprt_mode);
      }
      break;

    case CM_PH_EVENT_CURR_NAM:
      break;

    case CM_PH_EVENT_DDTM_STATUS:
      break;

    case CM_PH_EVENT_PRL_INIT:
      qmi_if_info.ph_info.prl_id   = ph_info.prl_id;
      qmi_if_info.ph_info.prl_only = ph_info.prl_only;
      qmi_if_info.prl_info_valid   = TRUE;
      qmi_dms_generate_prl_init_ind();
      break;

    case CM_PH_EVENT_CDMA_LOCK_MODE:
      /* Send the indication only when the state changes */
        LOG_MSG_INFO1_2 ("qmi_if_process_cm_ph_event()"
                         "prev cdma lock mode %d, "
                         "new cdma lock mode %d",
                         qmi_if_info.ph_info.cdma_lock_mode,
                         ph_info.cdma_lock_mode);
      if (qmi_if_info.ph_info.cdma_lock_mode != ph_info.cdma_lock_mode)
      {
        qmi_if_info.ph_info.cdma_lock_mode = ph_info.cdma_lock_mode;
        qmi_dms_generate_cdma_lock_mode_ind(qmi_if_info.ph_info.cdma_lock_mode);
      }
      break;

    default:
      LOG_MSG_INFO1_1 ("Shouldn't be getting this event (%d) here", ph_event);
//      ASSERT(0);
  }

  PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);
} /* qmi_if_process_cm_ph_event() */

/*===========================================================================
  FUNCTION QMI_IF_PROCESS_CM_CALL_EVENT()

  DESCRIPTION
    Process the CM SS event generated and call coresponding functions in
    QMI services to generate indications

  PARAMETERS
    call_event  :  CM call event
    call_info   :  call event info
    
  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_process_cm_call_event
(
  cm_call_event_e_type      call_event,
  qmi_if_cm_call_info_type  call_info    
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  LOG_MSG_INFO1_1("Processing Call Event 0x%X from CM", call_event);

  switch (call_event)
  {
  case CM_CALL_EVENT_ORIG:

    case CM_CALL_EVENT_CONNECT:
    case CM_CALL_EVENT_END:
      if ((CM_CALL_EVENT_ORIG == call_event) &&
          (CM_CALL_TYPE_PS_DATA  == call_info.call_type))
      {
        qmi_wds_callhist_save_phone_num(call_info.phone_num_len,
                                        call_info.phone_num_buf);
      }
      qmi_if_info.call_info.call_event     = call_event;
      qmi_if_info.call_info.call_type      = call_info.call_type;
      qmi_if_info.call_info.call_id        = call_info.call_id;
      qmi_dms_process_call_event();
      break;

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
#if defined(FEATURE_OTASP)
    case CM_CALL_EVENT_OTASP_STATUS:
      qmi_if_info.call_info.call_event     = call_event;
      qmi_if_info.call_info.call_type      = call_info.call_type;
      qmi_if_info.call_info.otasp_state    = call_info.otasp_state;
      qmi_dms_process_call_event();
      break;
#endif /* defined(FEATURE_OTASP) */
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

    default:
      ASSERT(0);
  }
} /* qmi_if_process_cm_call_event() */

/*===========================================================================
  FUNCTION QMI_IF_PROCESS_OTKSL_FLAG_UPDATE()

  DESCRIPTION
    Updates the otksl flag NV item in DCC task

  PARAMETERS
    otksl_flag  :  otksl flag value
    
  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_process_otksl_flag_update
(
  uint8      otksl_flag
)
{
  nv_item_type      *dcc_nv_item_ptr;

  LOG_MSG_INFO2_0 ("qmi_if_process_otksl_flag_update() START");
  /*-------------------------------------------------------------------------
    Allocate temporary memory for the NV item
  -------------------------------------------------------------------------*/
  PS_SYSTEM_HEAP_MEM_ALLOC_ASSERT(dcc_nv_item_ptr, sizeof(nv_item_type),
                                  nv_item_type*);
  if( dcc_nv_item_ptr == NULL )
  {
    return;
  }

  memset(dcc_nv_item_ptr, 0, sizeof(nv_item_type));
  dcc_nv_item_ptr->otksl_flag = otksl_flag;

  (void) dcc_put_nv_item(NV_OTKSL_FLAG_I, dcc_nv_item_ptr);
  qmi_if_info.otksl_valid = TRUE;

  /* Update local cache */
  qmi_if_info.nv_otksl_flag = otksl_flag;
  PS_SYSTEM_HEAP_MEM_FREE(dcc_nv_item_ptr);

  LOG_MSG_INFO2_0 ("qmi_if_process_otksl_flag_update() END");
} /* qmi_if_process_otksl_flag_update() */

/*===========================================================================

                            INTERNAL FUNCTIONS

===========================================================================*/

/*===========================================================================
  FUNCTION QMI_IF_CM_SS_EVENT_CB()

  DESCRIPTION
    WWAN interface callback for CM serving system event.

    This function is called by CM when a serving system event occurs.  
    Note that the callback is called in CM (i.e. not DS) context.

  PARAMETERS
    ss_event:     event that just occurred.
    ss_info_ptr:  current serving system info

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_if_cm_ss_event_cb
(
  cm_ss_event_e_type            ss_event,    /* SS event that just occured */
  const cm_mm_msim_ss_info_s_type *  ss_info_ptr  /* ptr to serving system info */
)
{
  qmi_if_cmd_buf_type *  cmd_ptr;
  uint8 stack_id,i;  
  sys_sys_mode_e_type curr_sys_mode;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (!ss_info_ptr) 
  {
    LOG_MSG_ERROR_0("ss_info_ptr is NULL");
    return;
  }

  if( (ss_info_ptr->number_of_stacks == 0) || (ss_info_ptr->number_of_stacks > CM_NO_STACKS) )
  {
    LOG_MSG_ERROR_1("invalid number of Stacks:%d in ss event",ss_info_ptr->number_of_stacks);
    return;
  }

  /*By default it is main stack*/
  stack_id = 0;
  /*Get the current sysmode and select that stack*/
  curr_sys_mode = ds3g_get_current_preferred_mode_ex(ss_info_ptr->asubs_id);
  
  for( i = 0; i < ss_info_ptr->number_of_stacks; i++ )
  {
    if(ss_info_ptr->stack_info[i].sys_mode == curr_sys_mode)
    {
      stack_id = i;
      break;
    }
  }

  /*-------------------------------------------------------------------------
    Post a cmd to QMI (DS task)  if an ss event of interest has occured
  -------------------------------------------------------------------------*/
  switch(ss_event)
  {
    case CM_SS_EVENT_SRV_CHANGED:
    /* CM_SS_EVENT_INFO event will be generated by CM only in below cases:
      (1) after coming out of power collapse to convey latest ss_info snapshot
      (2) only if we explicitly request for ss info using 
          cm_ss_cmd_get_ss_info() api */
    case CM_SS_EVENT_INFO:
    case CM_SS_EVENT_REG_REJECT:
      cmd_ptr = (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_NEW_CM_SS_INFO);
      if( cmd_ptr != NULL)
      {
        memset( cmd_ptr, 0x00, sizeof(*cmd_ptr) );        
        cmd_ptr->cmd_id = QMI_CMD_NEW_CM_SS_INFO;
        cmd_ptr->data.cm_ss.info.changed_fields = 
                    (ss_info_ptr->changed_fields_subs | ss_info_ptr->stack_info[stack_id].changed_fields);
        cmd_ptr->data.cm_ss.info.srv_status = ss_info_ptr->stack_info[stack_id].srv_status;
        cmd_ptr->data.cm_ss.info.srv_capability = ss_info_ptr->stack_info[stack_id].srv_capability;
        cmd_ptr->data.cm_ss.info.sys_mode = ss_info_ptr->stack_info[stack_id].sys_mode;
        cmd_ptr->data.cm_ss.info.cell_srv_ind = ss_info_ptr->stack_info[stack_id].cell_srv_ind;
        if (ss_info_ptr->stack_info[stack_id].sys_mode == SYS_SYS_MODE_HDR)
        {
          cmd_ptr->data.cm_ss.info.hdr_hybrid =
                           ss_info_ptr->stack_info[stack_id].rat_mode_info.hdr_mode_info.hdr_hybrid;
          cmd_ptr->data.cm_ss.info.hdr_active_prot = 
                           ss_info_ptr->stack_info[stack_id].rat_mode_info.hdr_mode_info.hdr_active_prot;
        }
        if(ss_info_ptr->number_of_stacks == CM_NO_STACKS)
        {  /*As of now this is used only in case of single sim case to determine device mode is SVLTE or not
             if hybrid stack is operational then device mode is SVLTE else CSFB */
            cmd_ptr->data.cm_ss.info.is_hybr_stack_operational = 
                ss_info_ptr->stack_info[CM_NO_STACKS-1].is_operational;
        }
        cmd_ptr->data.cm_ss.asubs_id = ss_info_ptr->asubs_id;
        cmd_ptr->data.cm_ss.event = ss_event;
        dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
      }
      break; 

    default:
      break;
  }
} /* qmi_if_cm_ss_event_cb() */

/*===========================================================================
  FUNCTION QMI_IF_PH_EVENT_CB()

  DESCRIPTION
    Callback function called from CM when a phone event occurs
    
  PARAMETERS
    ph_event    : phone event
    ph_info_ptr : event info

  RETURN VALUE
    ptr to response
    
  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_if_ph_event_cb
(
  cm_ph_event_e_type        ph_event,
  const cm_ph_info_s_type * ph_info_ptr
)
{
  qmi_if_cmd_buf_type *  cmd_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (!ph_info_ptr) 
  {
    LOG_MSG_ERROR_0("ph_info_ptr is NULL");
    return;
  }
  /*-------------------------------------------------------------------------
    Post a cmd to QMI (DCC task)  if an ss event of interest has occured
  -------------------------------------------------------------------------*/

  LOG_MSG_INFO2_1 ("qmi_if_cm_ph_event() ph_event %d", ph_event);
  switch(ph_event)
  {
    case CM_PH_EVENT_INFO_AVAIL:
    {
      cmd_ptr = (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_NEW_CM_PH_INFO);

      if ( cmd_ptr == NULL )
      {
        return;
      }

      memset( cmd_ptr, 0x00, sizeof(*cmd_ptr) );
      cmd_ptr->cmd_id = QMI_CMD_NEW_CM_PH_INFO;
      cmd_ptr->data.cm_ph.info.mode_pref = ph_info_ptr->mode_pref;
      cmd_ptr->data.cm_ph.info.band_capability = ph_info_ptr->band_capability;
#ifdef LTE_BAND_NUM
      memscpy(&cmd_ptr->data.cm_ph.info.lte_band_capability,
              sizeof(sys_lte_band_mask_e_type),
              &ph_info_ptr->lte_band_capability,
              sizeof(sys_lte_band_mask_e_type));
#else
      cmd_ptr->data.cm_ph.info.lte_band_capability = ph_info_ptr->lte_band_capability;
#endif /* LTE_BAND_NUM */
      cmd_ptr->data.cm_ph.info.tds_band_capability = ph_info_ptr->tds_band_capability;
      cmd_ptr->data.cm_ph.info.mode_capability = ph_info_ptr->mode_capability;
      cmd_ptr->data.cm_ph.info.prl_only  = ph_info_ptr->prl_pref_only;
      cmd_ptr->data.cm_ph.info.oprt_mode = ph_info_ptr->oprt_mode;
      cmd_ptr->data.cm_ph.event = ph_event;
      dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
      break; 
    }

    case CM_PH_EVENT_SYS_SEL_PREF:
    {

      cmd_ptr = (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_NEW_CM_PH_INFO);
      if ( cmd_ptr == NULL )
      {
        return;
      }
    
      memset( cmd_ptr, 0x00, sizeof(*cmd_ptr) );

      /* Alloc for nas and map to cmd_ptr->cmd.qmi.data.nas */
      cmd_ptr->cmd_id = QMI_CMD_NEW_CM_PH_INFO;
      cmd_ptr->data.cm_ph.info.mode_pref = ph_info_ptr->mode_pref;
      cmd_ptr->data.cm_ph.info.band_capability = ph_info_ptr->band_capability;
#ifdef LTE_BAND_NUM
      memscpy(&cmd_ptr->data.cm_ph.info.lte_band_capability,
              sizeof(sys_lte_band_mask_e_type),
              &ph_info_ptr->lte_band_capability,
              sizeof(sys_lte_band_mask_e_type));
#else
      cmd_ptr->data.cm_ph.info.lte_band_capability = ph_info_ptr->lte_band_capability;
#endif /* LTE_BAND_NUM */
      cmd_ptr->data.cm_ph.info.oprt_mode = ph_info_ptr->oprt_mode;
      cmd_ptr->data.cm_ph.event = ph_event;
      dcc_send_cmd_ex (DCC_QMI_CMD, cmd_ptr);
      break; 
    }

    case CM_PH_EVENT_INFO:
    {
      /* QMI_CMD_CM_PRL_INIT and QMI_CMD_NEW_CM_OPRT_MODE_INFO  are handled under the same case in qmi task */
      cmd_ptr = (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_CM_PRL_INIT);
      if ( cmd_ptr == NULL )
      {
        return;
      }

      memset( cmd_ptr, 0x00, sizeof(*cmd_ptr) );
      
      cmd_ptr->cmd_id = QMI_CMD_CM_PRL_INIT;
      cmd_ptr->data.cm_ph.info.oprt_mode = ph_info_ptr->oprt_mode;
      cmd_ptr->data.cm_ph.event = ph_event;
      cmd_ptr->data.cm_ph.info.is_prl_load_complete = ph_info_ptr->is_prl_load_complete;
      if ( ph_info_ptr->is_prl_load_complete == TRUE )
      {
        cmd_ptr->data.cm_ph.info.prl_id = ph_info_ptr->prl_id;
        cmd_ptr->data.cm_ph.info.prl_only = ph_info_ptr->prl_pref_only;
      }
      dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
      break;
    }
    case CM_PH_EVENT_OPRT_MODE:  
    {
      cmd_ptr = (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_NEW_CM_OPRT_MODE_INFO);
      if( cmd_ptr != NULL)
      {
        cmd_ptr->cmd_id = QMI_CMD_NEW_CM_OPRT_MODE_INFO;
        cmd_ptr->data.cm_ph.info.oprt_mode = ph_info_ptr->oprt_mode;
        cmd_ptr->data.cm_ph.event = ph_event;
        dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
      }
      break; 
    }

    case CM_PH_EVENT_PRL_INIT:  
    {
      cmd_ptr = (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_CM_PRL_INIT);
      if( cmd_ptr != NULL) {
        cmd_ptr->cmd_id = QMI_CMD_CM_PRL_INIT;
        cmd_ptr->data.cm_ph.event = ph_event;
        cmd_ptr->data.cm_ph.info.prl_id = ph_info_ptr->prl_id;
        cmd_ptr->data.cm_ph.info.prl_only = ph_info_ptr->prl_pref_only;
        dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
      }
      break; 
    }

    case CM_PH_EVENT_CDMA_LOCK_MODE:  
    {
      cmd_ptr = (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_CDMA_LOCK_MODE);
      if( cmd_ptr != NULL)
      {
         cmd_ptr->cmd_id = QMI_CMD_CDMA_LOCK_MODE;
         cmd_ptr->data.cm_ph.event = ph_event;
         cmd_ptr->data.cm_ph.info.cdma_lock_mode = 
           (boolean)ph_info_ptr->cdma_lock_mode;
         dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
      }
      break; 
    }

    default:
      break;
  }
} /* qmi_if_ph_event_cb() */

/*===========================================================================
FUNCTION  QMI_IF_INFO_GET_PTR

DESCRIPTION
  Returns the ptr to qmi_if_info.

DEPENDENCIES
  None

RETURNS
  Ptr to global variable qmi_if_info.

SIDE EFFECTS
  None

===========================================================================*/
qmi_if_info_type * qmi_if_info_get_ptr
(
  void
)
{
  return &qmi_if_info;
}

/*===========================================================================
FUNCTION  QMI_IF_CALL_EVENT_CB

DESCRIPTION
  CM call event callback function

DEPENDENCIES
  None

RETURNS
  None

SIDE EFFECTS
  Adds command in DS command buffer

===========================================================================*/
static void qmi_if_call_event_cb
(
  cm_call_event_e_type           call_event,
  const cm_mm_call_info_s_type * call_info_ptr
)
{
  qmi_if_cmd_buf_type *  cmd_ptr;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (!call_info_ptr) 
  {
    LOG_MSG_ERROR_0("call_info_ptr is NULL");
    return;
  }
  LOG_MSG_INFO2_1("Call_event %d received in qmi_if_call_event_cb",call_event);
  switch(call_event)
  {
    case CM_CALL_EVENT_ORIG:
    case CM_CALL_EVENT_CONNECT:
    case CM_CALL_EVENT_END:
      cmd_ptr = (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_PROCESS_CALL_EVT);
      if( cmd_ptr != NULL)
      {
        cmd_ptr->cmd_id = QMI_CMD_PROCESS_CALL_EVT;
        cmd_ptr->data.cm_call_evt.event = call_event;
        cmd_ptr->data.cm_call_evt.info.call_event = call_event;
        cmd_ptr->data.cm_call_evt.info.call_type  = 
                                                      call_info_ptr->call_type;
        cmd_ptr->data.cm_call_evt.info.call_id = 
                                                      call_info_ptr->call_id;
        if (call_info_ptr->call_type == CM_CALL_TYPE_PS_DATA && call_event == CM_CALL_EVENT_ORIG)
        {
          cmd_ptr->data.cm_call_evt.info.phone_num_len =
                   MIN(call_info_ptr->num.len, CM_MAX_NUMBER_CHARS);
          memscpy(cmd_ptr->data.cm_call_evt.info.phone_num_buf,
                  cmd_ptr->data.cm_call_evt.info.phone_num_len,
                  call_info_ptr->num.buf,
                  cmd_ptr->data.cm_call_evt.info.phone_num_len);
        }
        dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
      }
      break;

#if defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900)
#if defined(FEATURE_OTASP)
    case CM_CALL_EVENT_OTASP_STATUS:
      if ((CM_CALL_TYPE_STD_OTASP     == call_info_ptr->call_type) ||
          (CM_CALL_TYPE_NON_STD_OTASP == call_info_ptr->call_type))
      {
        cmd_ptr = (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_PROCESS_CALL_EVT);
        if( cmd_ptr != NULL)
        {
          cmd_ptr->cmd_id = QMI_CMD_PROCESS_CALL_EVT;
          cmd_ptr->data.cm_call_evt.event = call_event;
          cmd_ptr->data.cm_call_evt.info.call_type  = 
                                                      call_info_ptr->call_type;
          cmd_ptr->data.cm_call_evt.info.otasp_state = 
                           call_info_ptr->mode_info.info.cdma_call.otasp_status;
          dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
        }
      }
      break;
#endif /* defined(FEATURE_OTASP) */
#endif /* defined(FEATURE_CDMA_800) || defined(FEATURE_CDMA_1900) */

    default:
       break;
  }
} /* qmi_if_call_event_cb */

#ifdef FEATURE_MMGSDI_SESSION_LIB
/*===========================================================================
  FUNCTION QMI_IF_MMGSDI_RESP_CBACK()

  DESCRIPTION
    Callback function called by mmgsdi to return response

  PARAMETERS
    status  : return status
    cnf     : type of cnf response
    cnf_ptr : response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_mmgsdi_resp_cback
(
  mmgsdi_return_enum_type  status, 
  mmgsdi_cnf_enum_type     cnf,
  const mmgsdi_cnf_type *  cnf_ptr
)
{
  qmi_if_cmd_buf_type *  cmd_ptr;
  int32                    len = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  LOG_MSG_INFO2_1("Got response from MMGSDI for cnf_type: %d, posting cmd to DCC",
                  cnf);
  cmd_ptr = (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_MMGSDI_OPERATION_COMPLETE);
  if( cmd_ptr != NULL)
  {
    cmd_ptr->cmd_id = QMI_CMD_MMGSDI_OPERATION_COMPLETE;
    cmd_ptr->data.mmgsdi.mmgsdi_cnf_info.cnf_type = cnf;
    cmd_ptr->data.mmgsdi.mmgsdi_cnf_info.cnf_data = *cnf_ptr;
    if (cnf == MMGSDI_READ_CNF)
    {
      if (cnf_ptr->read_cnf.read_data.data_ptr != NULL)
      {
        len = MIN(cnf_ptr->read_cnf.read_data.data_len,
                  MAX_MMGSDI_BUFFER_LEN);
        memscpy(cmd_ptr->data.mmgsdi.mmgsdi_cnf_info.read_cnf_data,
                len,
                cnf_ptr->read_cnf.read_data.data_ptr, 
                len);
        cmd_ptr->data.mmgsdi.mmgsdi_cnf_info.cnf_data.read_cnf.\
          read_data.data_ptr = 
          &(cmd_ptr->data.mmgsdi.mmgsdi_cnf_info.read_cnf_data[0]);
      }
    }
    dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
  }
} /* qmi_if_mmgsdi_resp_cback */



/*===========================================================================
  FUNCTION QMI_IF_MMGSDI_EVT_CBACK()

  DESCRIPTION
    Callback function called by mmgsdi to report events

  PARAMETERS
    event  : Info about the event generated

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_mmgsdi_evt_cback
(
  const mmgsdi_event_data_type *  event
)
{
  ASSERT(event);
  LOG_MSG_INFO2_1("Mmgsdi event received %d", event->evt);
  switch(event->evt)
  {
    case MMGSDI_CARD_INSERTED_EVT: 
    case MMGSDI_CARD_ERROR_EVT:
    case MMGSDI_CARD_REMOVED_EVT:
      qmi_dms_mmgsdi_evt_cback(event);
      break;
    default:
      break;
  }
} /* qmi_if_mmgsdi_evt_cback */

/*===========================================================================
  FUNCTION QMI_IF_PROCESS_MMGSDI_OPERATION_COMPLETE()

  DESCRIPTION
    To send a response to the QMI pin operation requested by the client.
    
  PARAMETERS
    cnf_type : Type of MMGSDI PIN confirmation
    cnf_data : Response data

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
void qmi_if_process_mmgsdi_operation_complete
(
  mmgsdi_cnf_enum_type    cnf_type,
  mmgsdi_cnf_type        *cnf_data
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
    
  switch(cnf_type)
  {
    case MMGSDI_CLIENT_ID_AND_EVT_REG_CNF:
      if (MMGSDI_SUCCESS 
        != cnf_data->client_id_and_evt_reg_cnf.response_header.mmgsdi_status)
      {
        DATA_ERR_FATAL("MMGSDI session registration failed");
        return;
      }
      qmi_if_info.mmgsdi_client_id = 
        cnf_data->client_id_and_evt_reg_cnf.response_header.client_id;

      qmi_if_mmgsdi_session_reg ();
      break;

    case MMGSDI_SESSION_READ_PRL_CNF:
    case MMGSDI_READ_CNF:
      qmi_dms_process_mmgsdi_operation_complete(cnf_type,
                                                cnf_data);
      break;

    default:
      LOG_MSG_INFO1_1("Received unhandled cnf_type %d from mmgsdi", cnf_type);
      break;
  }
} /* qmi_if_process_mmgsdi_operation_complete */

/*===========================================================================
  FUNCTION QMI_IF_MAP_MMGSDI_STATUS_TO_ERRVAL

  DESCRIPTION
    To obtain QMI client-specific error message from MMGSDI error message
    
  PARAMETERS
    mmgsdi_status   : MMGSDI return value
    line.. Line number where MMGSDI status is not success

  RETURN VALUE
    errval          : QMI client-specific error message

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
qmi_error_e_type qmi_if_map_mmgsdi_status_to_errval
(
  mmgsdi_return_enum_type  mmgsdi_status,
  unsigned int       line
)
{
  qmi_error_e_type  errval;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  switch(mmgsdi_status)
  {
    case MMGSDI_WARNING_NO_INFO_GIVEN:
    case MMGSDI_INCOMPAT_PIN_STATUS:
      errval = QMI_ERR_NO_EFFECT;
      break;

    case MMGSDI_INCORRECT_CODE:
    case MMGSDI_INCORRECT_PARAMS:
      errval = QMI_ERR_INCORRECT_PIN;
      break;

    case MMGSDI_CODE_BLOCKED:
      errval = QMI_ERR_PIN_BLOCKED;
      break;

    case MMGSDI_CODE_PERM_BLOCKED:
      errval = QMI_ERR_PIN_PERM_BLOCKED;
      break;

    case MMGSDI_PIN_NOT_INITIALIZED:
      errval = QMI_ERR_SIM_NOT_INITIALIZED;
      break;

    case MMGSDI_ACCESS_DENIED:
      errval = QMI_ERR_ACCESS_DENIED;
      break;

    default:
      LOG_MSG_INFO2_0("Unhandled mmgsdi_status received");
      errval = QMI_ERR_INTERNAL;
  }

  LOG_MSG_INFO2_3("Mmgsdi_status = %d at line no. %d is not success , errval = %d", mmgsdi_status,line,errval);
  return errval;
} /* qmi_if_map_mmgsdi_status_to_errval() */


/*===========================================================================
  FUNCTION QMI_IF_MMGSDI_SESSION_REG()

  DESCRIPTION
    To open a GW MMGSDI session
    
  PARAMETERS
    None

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_if_mmgsdi_session_reg 
(
  void
)
{
  mmgsdi_return_enum_type        status;
  /*-----------------------------------------------------------------------
    open GW and 1X primary and GW secondary provisioning mmgsdi sessions
  -----------------------------------------------------------------------*/
  status = mmgsdi_session_open(qmi_if_info.mmgsdi_client_id,
                               MMGSDI_GW_PROV_PRI_SESSION, 
                               NULL, 
                               qmi_if_mmgsdi_session_evt_cb,
                               FALSE,
                               qmi_if_mmgsdi_session_open_cb, 
                               QMI_IF_MMGSD_GW_PROV_PRI_SESSION);

  if ( MMGSDI_SUCCESS != status )
  {
      LOG_MSG_ERROR_1("qmi_if_mmgsdi_session_reg: Session Open GW Primary"
                      "Registration Failed %d ", status);
  }

  status = mmgsdi_session_open(qmi_if_info.mmgsdi_client_id,
                               MMGSDI_1X_PROV_PRI_SESSION, 
                               NULL, 
                               qmi_if_mmgsdi_session_evt_cb,
                               FALSE,
                               qmi_if_mmgsdi_session_open_cb, 
                               QMI_IF_MMGSD_1X_PROV_PRI_SESSION);

  if ( MMGSDI_SUCCESS != status )
  {
      LOG_MSG_ERROR_1("qmi_if_mmgsdi_session_reg: Session Open 1X Primary"
                      "Registration Failed %d ", status);
  }

#ifdef FEATURE_DUAL_SIM
  status = mmgsdi_session_open(qmi_if_info.mmgsdi_client_id,
                               MMGSDI_GW_PROV_SEC_SESSION, 
                               NULL, 
                               qmi_if_mmgsdi_session_evt_cb,
                               FALSE,
                               qmi_if_mmgsdi_session_open_cb, 
                               QMI_IF_MMGSD_GW_PROV_SEC_SESSION);

  if ( MMGSDI_SUCCESS != status )
  {
     LOG_MSG_ERROR_1("qmi_if_mmgsdi_session_reg: Session Open GW Secondary"
                     "Registration Failed %d ", status);
  }
#endif

#ifdef FEATURE_TRIPLE_SIM
  status = mmgsdi_session_open(qmi_if_info.mmgsdi_client_id,
                               MMGSDI_GW_PROV_TER_SESSION, 
                               NULL, 
                               qmi_if_mmgsdi_session_evt_cb,
                               FALSE,
                               qmi_if_mmgsdi_session_open_cb, 
                               QMI_IF_MMGSD_GW_PROV_TER_SESSION);

  if ( MMGSDI_SUCCESS != status )
  {
     LOG_MSG_ERROR_1("qmi_if_mmgsdi_session_reg: Session Open GW Tertiary"
                     "Registration Failed %d ", status);
    return;
  }
#endif

} /* qmi_mmgsdi_session_reg () */


/*===========================================================================
FUNCTION QMI_IF_MMGSDI_SESSION_EVT_CB()

DESCRIPTION
  Callback for MMGSDI GW session related events

PARAMETERS 
  event     : Pointer to the structure conatining info about the event

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_if_mmgsdi_session_evt_cb 
(
  const mmgsdi_event_data_type *event
)
{
  qmi_if_cmd_buf_type *cmd_ptr = NULL;
  qmi_if_mmgsd_session_e_type  session_type;
  uint32  index;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (NULL == event) 
  {
    LOG_MSG_ERROR_0("qmi_if_mmgsdi_session_evt_cb: event pointer is NULL ");
    return;
  }

  for(index=QMI_IF_MMGSD_GW_PROV_PRI_SESSION; index < QMI_IF_MMGSD_MAX_SESSION; index++)
  {
    if(qmi_if_info.session_info[index].session_id == event->session_id)
    {
      session_type = index;
      break;
    }
  }

  if (index == QMI_IF_MMGSD_MAX_SESSION)
  {
    LOG_MSG_ERROR_1("qmi_if_mmgsdi_session_evt_cb:invalid session ID = %d",
                    event->session_id);
    return;
  }

  LOG_MSG_INFO2_4("qmi_if_mmgsdi_session_evt_cb: event=%d, " 
                "client_id=0x%x, session_id=0x%x, ,slot=%d ", 
              event->evt,event->client_id,event->session_id,
              event->data.subscription_ready.app_info.slot);
  switch (event->evt)
  {
    case MMGSDI_SUBSCRIPTION_READY_EVT:
    case MMGSDI_SESSION_CHANGED_EVT:
      qmi_if_info.session_info[session_type].app_type
        = event->data.subscription_ready.app_info.app_data.app_type;
       LOG_MSG_INFO2_1("qmi_if_mmgsdi_session_evt_cb: Processing " 
                       "MMGSDI_SUBSCRIPTION_READY_EVT for client_id %d",
                       event->client_id);
      cmd_ptr = (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_MMGSDI_SESSION_READY);
      if( cmd_ptr == NULL)
      {
        return;
      }
      cmd_ptr->cmd_id = QMI_CMD_MMGSDI_SESSION_READY;
      cmd_ptr->data.mmgsdi.mmgsdi_evt_info.event = event->evt;
      cmd_ptr->data.mmgsdi.mmgsdi_evt_info.card_err_info = 
                 event->data.card_error.info;
      if (event->evt == MMGSDI_SUBSCRIPTION_READY_EVT)
      {
        cmd_ptr->data.mmgsdi.mmgsdi_evt_info.app_type =
          event->data.subscription_ready.app_info.app_data.app_type;
      }
      else if (event->evt == MMGSDI_SESSION_CHANGED_EVT)
      {
        cmd_ptr->data.mmgsdi.mmgsdi_evt_info.app_type =
          event->data.session_changed.app_info.app_data.app_type;
        cmd_ptr->data.mmgsdi.mmgsdi_evt_info.activated =
          event->data.session_changed.activated;
      }
      dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
      return;

    case MMGSDI_PIN1_EVT:
    case MMGSDI_PIN2_EVT:
      cmd_ptr = (qmi_if_cmd_buf_type *) qmi_if_get_cmd_buf(QMI_CMD_PROCESS_PIN_EVT);
      if( cmd_ptr == NULL)
      {
        return;
      }
      cmd_ptr->cmd_id = QMI_CMD_PROCESS_PIN_EVT;
      cmd_ptr->data.mmgsdi.mmgsdi_evt_info.slot = event->data.pin.slot;
      cmd_ptr->data.mmgsdi.mmgsdi_evt_info.pin =
        event->data.pin.pin_info;
      dcc_send_cmd_ex(DCC_QMI_CMD, cmd_ptr);
      break;

    default:
      LOG_MSG_INFO2_2("qmi_if_mmgsdi_session_evt_cb: Unhandled event %d for "
                      "client_id %d. Ignore.", event->evt, event->client_id);
  }
} /* qmi_mmgsdi_session_evt_cb() */


/*===========================================================================
FUNCTION QMI_IF_MMGSDI_SESSION_OPEN_CB()

DESCRIPTION
  Session open callback (GW)

PARAMETERS
  status       - success or failure 
  cnf, cnf_ptr - type & result being retrieved 

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None
===========================================================================*/
static void qmi_if_mmgsdi_session_open_cb 
(
  mmgsdi_return_enum_type status,
  mmgsdi_cnf_enum_type    cnf,
  const mmgsdi_cnf_type  *cnf_ptr
)
{
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if( NULL == cnf_ptr )
  {
    LOG_MSG_ERROR_0("qmi_if_mmgsdi_session_open_cb: MMGSDI session open "
                    "failure as cnf_ptr is NULL");
    return;
  }
  if(cnf_ptr->session_open_cnf.response_header.client_data >= QMI_IF_MMGSD_MAX_SESSION)
  {
    LOG_MSG_ERROR_1("qmi_if_mmgsdi_session_open_cb: MMGSDI session open "
                    "failure as client data invalid",
                    cnf_ptr->session_open_cnf.response_header.client_data );
    return;
  }
  /*-------------------------------------------------------------------------
    Copy the session id into a variable local to the file
  -------------------------------------------------------------------------*/
  if ((MMGSDI_SESSION_OPEN_CNF == cnf) 
       && (MMGSDI_SESSION_OPEN_CNF 
           == cnf_ptr->session_open_cnf.response_header.response_type))
  {
    if ((MMGSDI_SUCCESS == status) && (MMGSDI_SUCCESS 
         == cnf_ptr->session_open_cnf.response_header.mmgsdi_status))
    {
      qmi_if_info.session_info[cnf_ptr->session_open_cnf.response_header.client_data].session_id 
                              = cnf_ptr->session_open_cnf.session_id;
    }

    else
    {
      LOG_MSG_ERROR_2("qmi_if_mmgsdi_session_open_cb: Session open cb "
                      "failure status %d and mmgsdi_status %d ",
                      status,
                      cnf_ptr->session_open_cnf.response_header.response_type);
    }
  }

  else
  {
      LOG_MSG_ERROR_2("qmi_if_mmgsdi_session_open_cb: Improper command confirmation "
                      "cnf %d response_type %d",
                      cnf,
                      cnf_ptr->session_open_cnf.response_header.response_type);
  }
  
}
#endif /* FEATURE_MMGSDI_SESSION_LIB */


/*===========================================================================
  FUNCTION QMI_IF_DETERMINE_TDS_RATES()

  DESCRIPTION
    Determines the maximum TDS TX and RX rate based on HSUPA and HSDPA category
    read from NV

  PARAMETERS
    tx_rate : Max TDS TX rate
    rx_rate : Max TDS RX rate

  RETURN VALUE
    None

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_if_determine_tds_rates(uint32* tx_rate, uint32* rx_rate)
{
  int efs_ret;

  /* Initialize values */
  uint8 hsdpa_cat = 0; 
#ifdef FEATURE_TDSCDMA_HSUPA
  uint8 hsupa_cat = 0;
#endif /* FEATURE_TDSCDMA_HSUPA */
  mcfg_fs_e_type        file_type = MCFG_FS_TYPE_EFS;
  mcfg_fs_sub_id_e_type mcfg_subs_id = MCFG_FS_SUBID_NONE;

  efs_ret = mcfg_fs_read("/nv/item_files/modem/tdscdma/rrc/hsdpa_cat", &hsdpa_cat, 
                         sizeof(uint8), file_type, mcfg_subs_id);
  if ((efs_ret != MCFG_FS_STATUS_OK))
  {
    LOG_MSG_ERROR_1("EFS read on TDS RRC HSDPA Cat failed errno=%d",
                    mcfg_fs_errno( file_type ));
  }

#ifdef FEATURE_TDSCDMA_HSUPA
  
  efs_ret = mcfg_fs_read("/nv/item_files/modem/tdscdma/rrc/hsupa_cat", &hsupa_cat, 
                         sizeof(uint8), file_type, mcfg_subs_id);
  if ((efs_ret != MCFG_FS_STATUS_OK))
  {
    LOG_MSG_ERROR_1("EFS read on TDS RRC HSUPA Cat failed errno=%d",
                    mcfg_fs_errno( file_type ));
  }

  switch(hsupa_cat)
  {
    case 1: 
      *tx_rate = 550800;  /* 0.5508 Mbps */
      break;
    case 2: 
      *tx_rate = 832400;  /* 0.8324 Mbps */
      break;
    case 3:
      *tx_rate = 1106400;  /* 1.1064 Mpbs */
      break;
    case 4:
      *tx_rate = 1669600;  /* 1.6696 Mpbs */
      break;
    case 5:
      *tx_rate = 2232000;  /* 2.2320 Mbps */
      break;
    case 6:
      *tx_rate = 2232000;  /* 2.2320 Mbps */
      break;
    default:
      LOG_MSG_ERROR_1 ("Unrecognized HSUPA Cat=%d, defaulting tx_rate to 0",
                       hsupa_cat);
      *tx_rate = 0;
  }
#else /* UE cannot support UPA for uplink, default to R4 rate */
  *tx_rate = 384000;       /* 384 Kbps */
#endif /* FEATURE_TDSCDMA_HSUPA */

  switch(hsdpa_cat)
  {
    case 1:
    case 2:
    case 3:
      *rx_rate = 550000;  /* 0.55 Mbps*/
      break;
    case 4:
    case 5:
    case 6:
      *rx_rate = 1100000;  /* 1.1 Mbps*/
      break;
    case 7:
    case 8:
    case 9:
      *rx_rate = 1600000;  /* 1.6 Mbps*/
      break;
    case 10:
    case 11:
    case 12:
      *rx_rate = 2200000;  /* 2.2 Mbps*/
      break;
    case 13:
    case 14:
    case 15:
      *rx_rate = 2800000;  /* 2.8 Mbps*/
      break;
    case 16:
    case 17:
    case 18:
      *rx_rate = 2500000;  /* 2.5 Mbps*/
      break;
    case 19:
    case 20:
    case 21:
      *rx_rate = 3300000;  /* 3.3 Mbps*/
      break;
    case 22:
    case 23:
    case 24:
      *rx_rate = 4200000;  /* 4.2 Mbps*/
      break;
    default:
      LOG_MSG_ERROR_1 ("Unrecognized HSDPA Cat=%d, defaulting rx_rate to 0",
                       hsdpa_cat);
      *rx_rate = 0;
  }
} /* qmi_if_determine_tds_rates() */

/*===========================================================================
  FUNCTION  QMI_IF_EDGE_SUPPORTED

  DESCRIPTION
    Determines whether EDGE is configured as enabled or disabled

  PARAMETERS
    None

  RETURN VALUE
    True if EGPRS is supported by the current configuration, false otherwise

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
boolean qmi_if_edge_supported
(
  void
)
{
  return qmi_if_edge_feature_support;
} /* qmi_if_edge_supported() */



/*===========================================================================
  FUNCTION QMI_IF_GET_CMD_GET_BUF

  DESCRIPTION
    Allocate and assign a QMI IF command buffer from the PS MEM heap
    based on the QMI IF type
    
  PARAMETERS
    cmd_id - QMI command type
   
  RETURN VALUE
    cmd_buf_ptr - Pointer to the allocated command buffer

  DEPENDENCIES
    None

  SIDE EFFECTS
    None
===========================================================================*/
static void *qmi_if_get_cmd_buf
(
  qmi_cmd_id_e_type cmd_id
)
{
  LOG_MSG_INFO1_1("cmd_id = %d",cmd_id);
  switch (cmd_id)
  {
    case QMI_CMD_CM_CLIENT_ACTIVATE:
    case QMI_CMD_PROCESS_OTKSL_FLAG_UPDATE:
    case QMI_CMD_NEW_CM_OPRT_MODE_INFO:
    case QMI_CMD_PROCESS_CALL_EVT:
    case QMI_CMD_PROCESS_PIN_EVT:
    case QMI_CMD_MMGSDI_SESSION_READY:
    case QMI_CMD_MMGSDI_OPERATION_COMPLETE:
    case QMI_CMD_CM_PRL_INIT:
    case QMI_CMD_NEW_CM_SS_INFO:
    case QMI_CMD_NEW_CM_PH_INFO:
    case QMI_CMD_CDMA_LOCK_MODE:
    {
      qmi_if_cmd_buf_type *cmd_buf_ptr = NULL;
      PS_SYSTEM_HEAP_MEM_ALLOC(cmd_buf_ptr, sizeof(qmi_if_cmd_buf_type),
                               qmi_if_cmd_buf_type*);
      return ((void*)cmd_buf_ptr);
    }

    default:
       break;
  }
  return NULL;
} /* qmi_if_get_cmd_buf */

/*===========================================================================
  FUNCTION QMI_IF_PROCESS_CMD

  DESCRIPTION
    This function processes a QMI IF command or event.

    It is called by the QMI command handler and will dispatch the
    associated command/event handler function.

  PARAMETERS
    cmd_ptr:  private data buffer containing the QMI IF command
              information.

  RETURN VALUE
    None

  DEPENDENCIES
    QMI IF must already have been initialized

  SIDE EFFECTS
    None
===========================================================================*/
static void qmi_if_process_cmd
(
  void * cmd_ptr
)
{
  qmi_if_cmd_buf_type *cmd_buf_ptr = NULL;
/*-------------------------------------------------------------------------*/

  ASSERT(cmd_ptr);
  cmd_buf_ptr = (qmi_if_cmd_buf_type *)cmd_ptr;

  switch(cmd_buf_ptr->cmd_id)
  {
    case QMI_CMD_CM_CLIENT_ACTIVATE:
      if( FALSE == qmi_if_reg_cm() )
      {
        LOG_MSG_ERROR_0("cm_client_act() failed, couldn't initialize QMI_IF module!");
      }
      break;
    case QMI_CMD_PROCESS_OTKSL_FLAG_UPDATE:
      qmi_if_process_otksl_flag_update(
                                cmd_buf_ptr->data.otksl_update.otksl_flag);
      break;
    case QMI_CMD_PROCESS_CALL_EVT:
      qmi_if_process_cm_call_event(
                                cmd_buf_ptr->data.cm_call_evt.event,
                                cmd_buf_ptr->data.cm_call_evt.info);
      break;

  #ifdef FEATURE_MMGSDI_SESSION_LIB
    case QMI_CMD_PROCESS_PIN_EVT:
      qmi_dms_process_mmgsdi_event(
        &cmd_buf_ptr->data.mmgsdi.mmgsdi_evt_info,
        (qmi_cmd_id_e_type) cmd_buf_ptr->cmd_id);
      break;

    case QMI_CMD_MMGSDI_SESSION_READY:
      qmi_dms_process_uim_get_state(
          cmd_buf_ptr->data.mmgsdi.mmgsdi_evt_info.event,
          cmd_buf_ptr->data.mmgsdi.mmgsdi_evt_info.card_err_info,
          cmd_buf_ptr->data.mmgsdi.mmgsdi_evt_info.activated);
      break;

    case QMI_CMD_MMGSDI_OPERATION_COMPLETE:
      qmi_if_process_mmgsdi_operation_complete(
        cmd_buf_ptr->data.mmgsdi.mmgsdi_cnf_info.cnf_type,
        &cmd_buf_ptr->data.mmgsdi.mmgsdi_cnf_info.cnf_data);
      break;

  #endif /* FEATURE_MMGSDI_SESSION_LIB */
    case QMI_CMD_NEW_CM_OPRT_MODE_INFO:
    case QMI_CMD_CM_PRL_INIT:
    case QMI_CMD_CDMA_LOCK_MODE:
      qmi_if_process_cm_ph_event( cmd_buf_ptr->data.cm_ph.event,
                                  cmd_buf_ptr->data.cm_ph.info );
      break;

    case QMI_CMD_NEW_CM_PH_INFO:
      qmi_if_process_cm_ph_event(cmd_buf_ptr->data.cm_ph.event,
                                 cmd_buf_ptr->data.cm_ph.info);
      
      break;

    case QMI_CMD_NEW_CM_SS_INFO:
      qmi_if_process_cm_ss_event(cmd_buf_ptr->data.cm_ss.event,
                                 cmd_buf_ptr->data.cm_ss.info,
                                 cmd_buf_ptr->data.cm_ss.asubs_id);
      break;

    default:
      LOG_MSG_INFO2_1 ("Ignoring QMI IF cmd %d", cmd_buf_ptr->cmd_id);
      break;

  }/* switch(cmd_buf_ptr->cmd_id) */

  qmi_if_free_cmd_buf(cmd_ptr);
  LOG_MSG_INFO2_0 ("QMI_DCC_SEND_CMD_EX: De Allocated QMI IF cmd buf" );
  return;
} /* qmi_if_process_cmd() */
