/*===========================================================================

            U M T S   S P E C I F I C   M O D E   H A N D L E R

        A C C E S S   C O N T R O L   L I S T   D E F I N I T I O N S
 
     F O R   R O U T I N G   V I A   T H E   U M T S   I N T E R F A C E

GENERAL DESCRIPTION
  The UMTS/GPRS specific routing ACL is used to enable policy and address
  based routing across the UMTS interface.

EXTERNALIZED FUNCTIONS

INITIALIZATION AND SEQUENCING REQUIREMENTS

Copyright (c) 2002 -2015 by Qualcomm Technologies, Incorporated.  All Rights Reserved.

===========================================================================*/

/*===========================================================================

                      EDIT HISTORY FOR FILE

 $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/datamodem/3gpp/ps/src/ds_3gpp_rt_acl.c#1 $ $DateTime: 2016/12/13 08:00:03 $ $Author: mplcsds1 $
 
when       who     what, where, why
--------   ---     ----------------------------------------------------------
03/04/12   vs      Fixes a multi pdn same apn issue
09/15/11   mct     Allow arbitration on default ifaces
06/21/11   dvk     Fixed compilation warnings.
11/18/10   asn     Added IP compat chk for arbitration candidates
11/17/10   vk      Added flag in policy to support bypassing the preferred 
                   system check
10/29/10   asn     Remove logic to deny Iface when it's going down
10/26/10   ars     For UMTS, the post proc will prematurely return with incorrect
                   ip type if an ipv4 call is brought with ipv4v6 profile 
                   and NV 1876 disabled.
10/01/10   sa      Fixed bug which doesn't allow WLAN + WCDMA/GSM call.
10/01/10   vk      Fixed issue where handoff flag is not set for default PDN
08/24/10   asn     PS Arbitration support
08/23/10   asn     TE and embedded sharing Iface scenario check 
07/18/10   asn     Support for Arbitration - round II
07/07/10   vk      Allow zero profile id for non-socket calls
06/17/10   as      Fusion additions
04/04/10   vk      Added support for attach profile configuration
04/03/10   vk      Added support for MSG2.0 based logging
04/02/10   vrk     UMTS interRAT support
01/04/10   vk      Removing certain macros from PDP reg API header file
                   that cause problems with autogenerated RPC stub code
04/15/08   asn     Fix bug which allows IPv6 call when NV is disabled
05/15/07   aw      Removed changes related to IM CN Subsystem Flag.
03/23/07   aw      Added support for IM CN Subsystem Flag in PCO.
03/13/07   vd      Added fix so that IFACE_UNSPEC_ADDR_FAMILY opens a path.
02/21/07   rr      Added fix for case insensitive comparison of APNs.
02/15/07   aw      Removed the banned string APIs.
11/03/06   rsl     Fixed issue in compare_pdp_profile where route_lookup
                   was failing for V6 IFACEs.
10/06/06   asn     Added RT_ACL support to allow Socket App with is_routeable
                   set to bind to an IFACE IN_USE (TE)
07/13/06   rsl     Added preferred mode check in is_cfg_shareable to fix an issue
                   where WLAN calls were trying to go through UMTS IFACE.
07/07/06   rr      Added pdp comparison in dsumtsps_compare_pdp_profile_info
                   to looked up Iface to ensure applications using same 
                   profile get same Iface.
06/26/06   rr      Added support for APN override.
05/31/06   rsl     looked_up iface is no more locked for a particular app,
                   the app that does a ppp_open gets the iface allocated
           even if it's already looked_up.  Removed corresponding check
           in is_cfg_shareable and is_cfg_supported.
03/20/06   rr      1)Removed (policy_info_ptr->iface.info.name == UMTS_IFACE
                   check for looked up Iface from dsumtsps_rt_is_cfg_shareable
                   2) Set iface type to IPV4 if call to be originated is IPV4 
                   or PPP in post processing function.
12/01/05   rr      Modified dsumtsps_compare_pdp_profile_info for IPV6.
05/12/05   rr      Added IPV6 code.
05/11/05   rr      Fixed Lint errors/warnings.
04/13/05   rr      Fixed check to validate profile numbers so that only last
                   byte of profile number is checked for validity. 
03/09/05   rc      Added check to compare profile information such as APN,
                   PDP type and PDP address while checking if the interface
                   is shareable.
11/22/04   rr      Added check in dsumtsps_rt_is_cfg_supported and 
                   dsumtsps_rt_is_cfg_shareable to ensure that Profile
                   numbers are unique if either numbers are different or
                   they belong to different families
09/10/04   sb      Secondary PDP changes
06/16/04   rc      Removed ASSERT(0) in ACL_CFG_SUPPORTED_DEF and
                   ACL_CFG_SHAREABLE_DEF if there is error in retreiving
                   the default profile number for sockets. 
06/04/04   rc      Fixed Lint errors/warnings.
01/31/04   usb     Added support for lookup_only routing policy flag,
                   also removed some redundant if checks.
01/27/04   vsk     M-PDP support 1539
11/03/03   rc      Wrap ACL_PREF_MODE_CLASS around !FEATURE_DATA_WCDMA_PS. 
11/03/03   usb     Don't block the iface if lookup_only flag is set.
09/25/03   vsk     check for profile number > & not for >= DS_UMTS_MAX_PDP_PROFILE_NUM
07/24/03   vsk     Made code ready to be used with new PS routing policy, but 
                   not supporting the complete M-PDP support
07/22/03   usb     Support for app specified policy information, 
                   routing support for mutliple PDP contexts.
05/14/03    usb    Added new rules to support routing when multiple modes
                   are active.
04/18/03    vsk    In the post proc function,pass the profile pointer passed
                   in rather than the profile number
02/05/03    vsk    In the post proc function, set the profile number to
                   DSUMTSPS_SOCKS_CALL_PROF_REQ_NUM for a sockets call.
01/24/03    vsk    Added support for PDP profiles. 
11/13/02    rc     Added multimode support for GPRS.
10/10/02    rc     Added code to support multiple socket applications
09/09/02    om     Created Module.

===========================================================================*/

/* <EJECT> */ 
/*===========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/
#include "datamodem_variation.h"
#include "comdef.h"
#include "customer.h"

#if defined(FEATURE_DATA_LTE)|| defined(FEATURE_DATA_WCDMA_PS) || defined(FEATURE_GSM_GPRS)

#include "amssassert.h"
#include "ps_acl.h"
#include "ps_aclrules.h"
#include "ds_3gpp_rt_acl.h"
#include "ps_iface.h"
#include "ps_sys.h"
#include "ps_sys_ioctl.h"
#include "ds_3gpp_hdlr.h"
#include "ds_3gpp_pdn_context.h"
#include "ds_3gpp_apn_table.h"
#include "ds_3gpp_nv_manager.h"
#ifdef FEATURE_DATA_LTE
#include "ds_eps_pdn_context.h"
#include "ds_eps_tlb.h"
#endif
#include "dsumtspdpreg.h"
#include "dsumtspdpregint.h"
#include "ds3gmgr.h"
#include "ds3gprofile_validator.h"
#include "ds3gutil.h"

#ifdef FEATURE_DATA_WLAN_MAPCON
#include "ds_mppm_ext_i.h"
#endif /* FEATURE_DATA_WLAN_MAPCON */

#include <stringl/stringl.h>
#ifdef FEATURE_DATA_PS_IWLAN_3GPP
#include "iwlan_3gpp_rt_acl.h"
#endif /*FEATURE_DATA_PS_IWLAN_3GPP*/

#ifdef FEATURE_DATA_PS_IPV6
#include "ps_iface_addr_v6.h"

#include "ds_3gpp_roaming_hdlr.h"
#include "ds_3gpp_device_ev_hdlr.h"

/* RMNET instance invalid*/
#define RM_INST_INVALID -1
/* remove after adding to ps_aclrules.h */
#define ACL_DENY_REASON_IFACE_IN_USE_CFG_MATCH  -3

/*---------------------------------------------------------------------------
MACRO  DS3GPP_IFACE_IS_CALL_TYPE_MATCHED

DESCRIPTION   
  Given the if_ptr and call type to be originated, determines if iface in use
  can be shared with new call being originated. Iface is allowed to be shared
  if one of the following two condition is satisfied:
  1. New call being originated is of type DS_UMTS_PDP_TYPE_IP_ANY
  2. New call is of same type as that of the iface


RETURN VALUE
  TRUE - If iface can be shared with new call
  FALSE - Otherwise
---------------------------------------------------------------------------*/
#define DS3GPP_IFACE_IS_CALL_TYPE_MATCHED(if_ptr, call_type_originate) \
 (((ds_pdn_context_type_e)(call_type_originate) ==\
                                               DS_3GPP_PDP_TYPE_IP_ANY) || \
  (ps_iface_addr_family_is_v4((ps_iface_type*) if_ptr) && \
  (ds_pdn_context_type_e) (call_type_originate) == \
   DS_3GPP_PDP_TYPE_IPV4) || \
  (ps_iface_addr_family_is_v6((ps_iface_type*) if_ptr) && \
  (ds_pdn_context_type_e) (call_type_originate) == \
   DS_3GPP_PDP_TYPE_IPV6))

#endif

/*--------------------------------------------------------------------------- 
  Flag to store pdp_type_to_be_changed
---------------------------------------------------------------------------*/
static boolean ds_3gpp_rt_acl_pdp_type_to_be_changed = FALSE;

/*===========================================================================

                        FORWARD FUNCTION DECLARATIONS

===========================================================================*/

boolean ds3gpp_get_profile_apn_name
( 
  uint32                       pdp_profile_num,
  uint32                       subs_id,
  ds3g_apn_name_type         * apn_name
);

boolean ds3gpp_is_pref_pkt_sys_mode
( 
  acl_policy_info_type        *policy_info_ptr,
  sys_sys_mode_e_type          mode
);

static void ds_3gpp_rt_acl_set_pdp_type_to_be_changed
(
  boolean flag
)
{
  ds_3gpp_rt_acl_pdp_type_to_be_changed = flag;
  DS_3GPP_MSG1_MED("pdp_type_to_be_changed: %d",flag);
}

static boolean ds_3gpp_rt_acl_get_pdp_type_to_be_changed
(
  void
)
{
  DS_3GPP_MSG1_MED("pdp_type_to_be_changed: %d",ds_3gpp_rt_acl_pdp_type_to_be_changed);
  return ds_3gpp_rt_acl_pdp_type_to_be_changed;
}

static uint32 ds_3gpp_rt_acl_get_profile_num_from_policy
(
  acl_policy_info_type *policy_info_ptr
);
/*=========================================================
FUNCTION DS_3GPP_SET_LINGER_TIMER_VAL

DESCRIPTION
  This function sets the iface linger timeout value for embedded calls.
  The linger timer value is retrieved from the UMTS PDP profile registry from
  the profile number being passed. For tethered calls linger timeout value would be
  set to 'zero' as iface lingering is not supported for DUN calls.

PARAMETERS
  pdp_profile_num -- The pdp profile number on which the Iface is to be brought
                     up.
  if_ptr          -- The iface ptr for the selected Iface.
  is_sock_orig - whether call originated is embedded call.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

==========================================================*/
static void ds_3gpp_set_linger_timer_val
(
  uint16            pdp_profile_num, 
  sys_modem_as_id_e_type subs_id,
  ps_iface_type     *if_ptr,
  boolean           is_sock_orig
)
{
  ds_umts_pdp_profile_status_etype status;
  ds_umts_linger_params_type       linger_params_data;
  uint32                           linger_timeout_val = 0;

  /*----------------------------------------------------------------------
    Retrieve linger timer value from profile
  ----------------------------------------------------------------------*/
  status = ds_umts_get_pdp_profile_linger_params_info_per_subs(pdp_profile_num, 
                                                      dsumts_subs_mgr_get_subs_id(subs_id), 
                                                      &linger_params_data);
  DS_3GPP_MSG3_HIGH("getting Linger params from profile %d valid:%d, timer value: %d",
                    pdp_profile_num,linger_params_data.valid_flag,linger_params_data.linger_timeout_val);


  if (is_sock_orig)
  {
    if (status != DS_UMTS_PDP_SUCCESS)
    {
      DS_3GPP_MSG1_ERROR("Linger parameters could not be retrieved from profile err %d",
                          (uint32)status);
    }
    else
    {
      if (linger_params_data.valid_flag)
      {
        /*-----------------------------------------------------------------
          Linger parameters are valid, fill from retrieved value
        ------------------------------------------------------------------*/
        if (linger_params_data.allow_linger_flag)
        {
          linger_timeout_val = (uint32)linger_params_data.linger_timeout_val;
        }
      }
    }
  }
  else
  {
    DS_3GPP_MSG0_HIGH("Setting linger timeout value for tethered call to 0");
    linger_timeout_val = 0;
  }

  if (ps_iface_set_linger_timeout_val(
          if_ptr, 
          SEC_TO_MSEC(linger_timeout_val))
        < 0) 
  {
    DS_3GPP_MSG2_HIGH("Could not set Linger Timer value for iface: 0x%p and profile : %d",
                       if_ptr, pdp_profile_num);
  }
  else
  {
    DS_3GPP_MSG3_HIGH("Set Linger Timer value for iface: 0x%p and profile : %d to %d",
                       if_ptr, pdp_profile_num, linger_timeout_val);
  }
} /* ds_3gpp_set_linger_timer_val */

/*===========================================================================
FUNCTION DS3GPP_COMPARE_PDP_PROFILE_INFO

DESCRIPTION
  This function compares the PDP profile passed in the policy with
  the profile information of the interface that is already in use.
  This function is called by the routing layer.
  
PARAMETERS
  umtsps_iface_inst  - Interface in use.
  pdp_profile_number - Profile number passed in the policy 
  
DEPENDENCIES
  None.
  
RETURN VALUE
  TRUE - If the PDP profile information of the profile matches the profile
         information for the interface in use.
  FASLE - Otherwise.         
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
boolean ds3gpp_compare_pdp_profile_info
(
  ps_iface_type           * ps_iface_p,         /* Interface in use*/
  uint32                    pdp_profile_number, /* PDP profile number*/
  acl_policy_info_type    * policy_info_ptr,    /* Policy Information */
  int                     * reason_for_deny_p   /* Policy Deny reason */ 
)
{
  ds_pdn_context_s         *pdn_cntx_p = NULL;
  ds_umts_pdp_profile_type  profile_info;
  ds_umts_pdp_profile_type *pdn_cntx_profile_p = NULL;
  ds_umts_pdp_profile_status_etype result;     
  byte                      apn_requested[DS_UMTS_MAX_APN_STRING_LEN+1];
                           /* Pointer to APN string in Policy*/
  byte                     *resolved_apn_p = NULL;
  ds_3gpp_iface_s          *ds_3gpp_iface_p = NULL;
#ifdef FEATURE_DATA_LTE
  sys_modem_as_id_e_type            resolved_subs_id = SYS_MODEM_AS_ID_NONE;
#endif /* FEATURE_DATA_LTE */

  if(reason_for_deny_p == NULL)
  {
     DATA_ERR_FATAL("ds3gpp_compare_pdp_profile_info :reason_for_deny is NULL");
     return FALSE;
  }

  *reason_for_deny_p = ACL_DENY_REASON_POL_NO_MATCH; 
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(apn_requested,0,DS_UMTS_MAX_APN_STRING_LEN+1);
  /* This API works only when PS Iface NOT in DOWN or GOING_DOWN state */

  ds_3gpp_iface_p = (ds_3gpp_iface_s *) ps_iface_p->client_data_ptr;
  if (ds_3gpp_iface_p == NULL) 
  {
    DS_3GPP_MSG2_ERROR("Denying Iface [0x%x:%x] as the corresponding DS3GPP iface is NULL."
                                   "Assert", ps_iface_p->name,
                                             ps_iface_p->instance);
    ASSERT(0);
    return FALSE;
  }
  /*---------------------------------------------------------------------------
    Get the PDN context pointer from the DS Iface
  ---------------------------------------------------------------------------*/
  pdn_cntx_p = (ds_pdn_context_s*)(ds_3gpp_iface_p->client_data_ptr);
  
  if(!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
  {
    DS_3GPP_MSG2_ERROR("Denying Iface [0x%x:%x]. Associated PDN is NULL. "
                       "Failed to perform profile comparison",
                               ps_iface_p->name,
                               ps_iface_p->instance);
    return FALSE;
  }

  result = ds_umts_get_pdp_profile_all_data_per_subs((uint16)pdp_profile_number, 
                                dsumts_subs_mgr_get_subs_id_from_policy_subs_id(policy_info_ptr->subs_id),
                                                            &profile_info); 
  if( result != DS_UMTS_PDP_SUCCESS )
  {
    DS_3GPP_MSG2_ERROR("Error %d in retrieving profile info:%d",
		       result,pdp_profile_number);
    *reason_for_deny_p = ACL_DENY_REASON_INVALID_PROFILE;
    return FALSE;
  }

  /*--------------------------------------------------------------------- 
    Copy the apn from profile
    Override the apn if policy info ptr is populated with an apn
  ---------------------------------------------------------------------*/
  (void)strlcpy((char *) apn_requested, 
                (char *) profile_info.context.apn,
                 DS_UMTS_MAX_APN_STRING_LEN+1); 

  if ((policy_info_ptr->apn.length != 0) && 
      (policy_info_ptr->apn.length <= DS_UMTS_MAX_APN_STRING_LEN))
  {
    (void) strlcpy((char *) apn_requested, 
                       (char *) policy_info_ptr->apn.name,
		       (policy_info_ptr->apn.length)+1); 
  }
#ifdef FEATURE_DATA_LTE
  /*--------------------------------------------------------------------- 
  If Profile's apn is NULL and policy info ptr apn is not populated
  then try to get the resolved apn from attach sm. If resolved apn
  is present populate it.
  ---------------------------------------------------------------------*/
  else if((policy_info_ptr->apn.length == 0) && 
          (profile_info.context.apn[0] == '\0'))
  {
    if( ds3g_resolve_subs_id(policy_info_ptr->subs_id ,&resolved_subs_id )
        == FALSE )
    {
      DS_3GPP_MSG1_ERROR("Error in obtaining resolved sub id. "
                         "Policy PS Sub ID is %d",
                         policy_info_ptr->subs_id);
      return FALSE;
    }
    if(ds_eps_pdn_cntxt_get_resolved_apn_per_attach_sm(
                                         apn_requested,
                                         resolved_subs_id))
    {   

      DATA_3GPP_MSG_SPRINTF_1(MSG_LEGACY_HIGH, 
                    "Resolved APN in Attach SM is %s",
                     apn_requested);
    }
  }
#endif /* FEATURE_DATA_LTE */

  if (ds3g_profile_validate_apn_name((char*)apn_requested, 
                strlen((char*)apn_requested)) == FALSE) 
  {
     *reason_for_deny_p = ACL_DENY_REASON_APN_FORMAT_INVALID;
     DS_3GPP_MSG0_HIGH("policy apn format is invalid");
     return FALSE;
  }

  pdn_cntx_profile_p = &(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile);

  /*--------------------------------------------------------------------------
    Get the resolved APN if applicable
  --------------------------------------------------------------------------*/
    if(ds_pdn_cntxt_get_resolved_apn_name(pdn_cntx_p, 
                                          &resolved_apn_p) == FALSE)
    {
      DS_3GPP_MSG0_LOW("Resolved APN unavailable in the APN table");
    }

  /*-------------------------------------------------------------------------
    Compare the profile information of the profile number passed in the 
    policy with the profile information of an interface in use.
    If the profile numbers match, return TRUE.
    If the pdp_type, APN and pdp_addr match, return TRUE.
    For IPV6, we do not support Stateful autoconfiguration so if both the 
    profiles are of type IPV6, return TRUE.
  -------------------------------------------------------------------------*/

  if(resolved_apn_p != NULL)
  {
    DATA_3GPP_MSG_SPRINTF_2(MSG_LEGACY_HIGH , 
                    "Resolved APN in APN table is %s,"
                    "APN in Pdn Cntx is %s",
                     resolved_apn_p,
                     pdn_cntx_profile_p->context.apn);
  }
  else
  {
    DATA_3GPP_MSG_SPRINTF_1(MSG_LEGACY_HIGH, 
                    "APN in Pdn Cntx is %s",pdn_cntx_profile_p->context.apn);
  }

  /*----------------------------------------------------------------------------
    Compare the APN requested with the APN in the PDN context and the resolved
    APN name. If either of them pass, we can pass the iface with config class 
  ----------------------------------------------------------------------------*/
  if( 
      ( strncasecmp((char*)pdn_cntx_profile_p->context.apn,
                  (char*)apn_requested,DS_UMTS_MAX_APN_STRING_LEN+1) == 0 )||
      (
        (resolved_apn_p != NULL) && 
        ( strncasecmp((char*)resolved_apn_p, (char*)apn_requested,
                      DS_UMTS_MAX_APN_STRING_LEN+1) == 0 )
      )
    )
  { 
    if (((pdn_cntx_profile_p->context.pdp_addr.ip_vsn == DS_IP_V4) ||  
         (pdn_cntx_profile_p->context.pdp_addr.ip_vsn == DS_IP_V4V6)) &&
          pdn_cntx_profile_p->context.pdp_addr.pdp_addr.pdp_addr_ipv4 != 0)
    { 
      if (((profile_info.context.pdp_addr.ip_vsn == DS_IP_V4) || 
           (profile_info.context.pdp_addr.ip_vsn == DS_IP_V4V6)) &&
            profile_info.context.pdp_addr.pdp_addr.pdp_addr_ipv4 !=0)
      {
        if (pdn_cntx_profile_p->context.pdp_addr.pdp_addr.pdp_addr_ipv4 != 
            profile_info.context.pdp_addr.pdp_addr.pdp_addr_ipv4)
        {
           *reason_for_deny_p = ACL_DENY_REASON_IP_ADDRESS_MISMATCH;
           DS_3GPP_MSG3_HIGH("V4 addr does not match pdn cntxt: 0x%x, policy: 0x%x",
                        pdn_cntx_profile_p->context.pdp_addr.pdp_addr.pdp_addr_ipv4,
                            profile_info.context.pdp_addr.pdp_addr.pdp_addr_ipv4,0);
           DS_3GPP_MSG3_HIGH("Pnd cntxt ip vsn: %d, policy ip vsn: %d",
                            pdn_cntx_profile_p->context.pdp_addr.ip_vsn,
                            profile_info.context.pdp_addr.ip_vsn,0);
           return FALSE;
        }
      }
    }

    if(profile_info.context.pdp_type == DS_UMTS_PDP_PPP  &&
       pdn_cntx_profile_p->context.pdp_type != DS_UMTS_PDP_PPP )
   {
     DS_3GPP_MSG2_HIGH("PDP types do not match. pdn cntxt PDP type: %d, "
                       "policy PDP type %d", pdn_cntx_profile_p->context.pdp_type,
                        profile_info.context.pdp_type); 
     *reason_for_deny_p = ACL_DENY_REASON_IP_PDP_MISMATCH;
     return FALSE;
   }
   return TRUE;
  }

  *reason_for_deny_p = ACL_DENY_REASON_APN_MISMATCH;
  return FALSE;

} /* ds3gpp_compare_pdp_profile_info() */



#ifdef FEATURE_DATA_PS_IPV6

/*===========================================================================
FUNCTION DS3GPP_DETERMINE_CALL_TYPE_TO_BE_ORIGINATED

DESCRIPTION
  This functions determines the call type to be originated based on pdp 
  profile type, policy provided by application and ipv6 failover mode nv 
  item. 
  Processing is done as per Net Policy Enforcement table in IPV6 design 
  document.

PARAMETERS
  context_info -- pdp context information for the call 
  policy_info_ptr -- network policy provided by application

DEPENDENCIES
  None.
  
RETURN VALUE
  ds_umts_originate_call_e_type - V4, V6, PPP or ANY if call type to be 
                                  originated is valid.
  DS_UMTS_PDP_TYPE_FAIL - Otherwise.         
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
ds_pdn_context_type_e ds3gpp_determine_call_type_to_be_originated
(
  const ds_umts_pdp_context_type  *context_info_p,    /* PDP context info*/
  const acl_policy_info_type*    policy_info_ptr
)
{
  ds_pdn_context_type_e call_type_orig; /* call type to originate*/
  if(context_info_p == NULL)
  {
    DS_3GPP_MSG0_ERROR("Invalid Context type requested");
    call_type_orig= DS_3GPP_PDP_TYPE_FAIL;
    return call_type_orig;
  }
  switch(context_info_p->pdp_type)
  {
   case DS_UMTS_PDP_IPV4: 
    {
     switch(policy_info_ptr->ip_family)
      {
       case IPV4_ADDR:
       case IP_ANY_ADDR:
       case IFACE_UNSPEC_ADDR_FAMILY:
            call_type_orig= DS_3GPP_PDP_TYPE_IPV4;
            break;
       
       case IPV6_ADDR:
       default:
            call_type_orig= DS_3GPP_PDP_TYPE_FAIL;
            break;
       }
    }
    break;
 
   case DS_UMTS_PDP_PPP:
   {
     if(policy_info_ptr->ip_family == IPV4_ADDR)
     {
        call_type_orig= DS_3GPP_PDP_TYPE_PPP;
     }
     else
     {
       DS_3GPP_MSG1_ERROR("Invalid IP family req in Policy for PPP call %d",
                          policy_info_ptr->ip_family);
       call_type_orig= DS_3GPP_PDP_TYPE_FAIL;
     }
   }
        break;
   
   case DS_UMTS_PDP_IPV6: 
    {
     switch( policy_info_ptr->ip_family )
      {
       case IPV6_ADDR:
       case IP_ANY_ADDR:
       case IFACE_UNSPEC_ADDR_FAMILY:
            call_type_orig = DS_3GPP_PDP_TYPE_IPV6;            
            break;
       
       case IPV4_ADDR:
       default:
            DS_3GPP_MSG0_HIGH("Invalid IP Addr type or Policy type requested");
            call_type_orig= DS_3GPP_PDP_TYPE_FAIL;
            break;
       }
    }
    break;

  case DS_UMTS_PDP_IPV4V6:
    switch( policy_info_ptr->ip_family )
      {
       case IPV6_ADDR:
         call_type_orig = DS_3GPP_PDP_TYPE_IPV6;            
         break;
       case IPV4_ADDR:
         call_type_orig = DS_3GPP_PDP_TYPE_IPV4;
            break;
       case IP_ANY_ADDR:
       case IFACE_UNSPEC_ADDR_FAMILY:
         call_type_orig = DS_3GPP_PDP_TYPE_IP_ANY;
         break;
       default:
            DS_3GPP_MSG0_HIGH("Invalid IP Addr type or Policy type requested");
            call_type_orig= DS_3GPP_PDP_TYPE_FAIL;
            break;
       }    
    break;

   default:
        DS_3GPP_MSG0_ERROR("Invalid Context type requested");
        call_type_orig= DS_3GPP_PDP_TYPE_FAIL;
        break;
   }
 return call_type_orig;
}

#endif

/*===========================================================================
FUNCTION DS3GPP_RT_ACL_POST_PROC

DESCRIPTION
   This function performs the post routing lookup actions.  This funtion is 
   called for the interface which is picked up as the most preferred interface 
   during lookupo based upon client requirements (policy) and other system 
   parameters.  
   For UMTS appropriate profile information is stored for the specified 
   interface and this information is used for pdp activation later.
  
PARAMETERS  
  *ipfilter_info_ptr  - Ip filter information
  *policy_info_ptr    - Policy information
  *this_if_ptr        - Ptr to the interface
    
DEPENDENCIES 
  None.
  
RETURN VALUE 
  None.
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
/*lint -esym(715,pkt_info_ptr) */
ACL_POST_PROC_DEF( ds3gpp_rt_acl_post_proc )
{
  uint32   pdp_profile_num= 0;
  ds_pdn_context_s *pdn_cntx_p = NULL;
  ds_3gpp_iface_s  *ds_iface_p = NULL;
  ds_3gpp_iface_s  *ds_iface_other_p = NULL;
  ps_iface_type *if_ptr = (ps_iface_type *) this_if_ptr;
  ps_iface_addr_family_type this_iface_ip_type = IP_ADDR_INVALID;
  ps_iface_addr_family_type companion_iface_ip_type = IP_ADDR_INVALID;
  boolean ds_3gpp_profile_is_valid = FALSE;
#ifdef FEATURE_DATA_PS_IPV6   
  ds_pdn_context_type_e call_type_originate;
  int     tmp_result = -1;
#endif  
  int ds_companion_iface_index = -1;
  uint8 req_apn_length;
  ds_apn_ip_support_type_e ip_support = DS_IP_TYPE_INVALID;
  sys_modem_as_id_e_type resolved_subs_id = SYS_MODEM_AS_ID_NONE;
  ds_sys_subscription_enum_type ds_subs_id = DS_SYS_DEFAULT_SUBS;
  boolean                       sock_orig = FALSE;
  ds_umts_pdp_profile_type       prof_context;
#ifdef FEATURE_DATA_LTE
  byte                           apn_requested[DS_UMTS_MAX_APN_STRING_LEN+1];
#endif /* FEATURE_DATA_LTE */

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  if(policy_info_ptr->bring_up == FALSE)
  {
    DS_3GPP_MSG0_HIGH("Bring up flag: False. No Post proc needed");
    return;
  }

  ds_iface_p = (ds_3gpp_iface_s*)(if_ptr->client_data_ptr);
  DS_3GPP_MSG1_MED("Post proc for ds iface:0X%x",ds_iface_p);

  /*----------------------------------------------------------------------------
    This is a block where we determine if we need post processing or not.
    This has to be done under a critical section since the flag can be inspected
    from multiple task contexts
  ----------------------------------------------------------------------------*/
  dssnet6_enter_crit_sect();
  ds3gpp_enter_global_crit_section();
  if(ds_iface_p->post_proc_done_flag == TRUE)
  {
    DS_3GPP_MSG0_HIGH("Post proc already done for this iface. Skip now");

    if(policy_info_ptr->handoff_ctxt.handoff_class != 
                                                  PS_IFACE_HANDOFF_CLASS_NONE)
    {
      /* Still need to set handoff attach flag, if set in policy
      */
      pdn_cntx_p = (ds_pdn_context_s *)ds_iface_p->client_data_ptr;
      ASSERT(pdn_cntx_p != NULL);

      ds_pdn_cntxt_set_handover_attach_flag(pdn_cntx_p, TRUE);
      DS_3GPP_MSG0_HIGH("Setting handover attach flag");
    }

    ds3gpp_leave_global_crit_section();
    dssnet6_leave_crit_sect();
    return;
  }
  else
  {
    /*--------------------------------------------------------------------------
      Set the post_proc_done_flag
    --------------------------------------------------------------------------*/
    ds_iface_p->post_proc_done_flag = TRUE;

  }

  if(ds_iface_p->client_data_ptr == NULL)
  {
    if( ds3g_resolve_subs_id(policy_info_ptr->subs_id ,&resolved_subs_id ) == FALSE) 
    {
       DS_3GPP_MSG1_ERROR("Error in obtaining resolved sub id. "
                          "Policy PS Sub ID is %d", policy_info_ptr->subs_id);
      
       ds3gpp_leave_global_crit_section();
       dssnet6_leave_crit_sect();
       return;
    }

    if(ds3g_is_ipv6_enabled() == TRUE)
    {
      ds_3gpp_pdn_context_v6_sm_update(ds_iface_p,resolved_subs_id);
    }

    /*-------------------------------------------------------------------------
      Allocate a PDN context for the iface. If no PDN context is available,
      (which is unlikely given the fact that there are 2 ifaces for default PDN 
      and 4 for non default PDNs and that we have 5 PDN contexts) we would fail
      the bring up.
    -------------------------------------------------------------------------*/
    DS_3GPP_MSG0_HIGH("Allocating new PDN Context..");


    pdn_cntx_p = ds_pdn_cntxt_allocate_new_pdn_context(resolved_subs_id);

    if(!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
    {
       DS_3GPP_MSG0_HIGH("Failure to allocate a PDN context, Exiting post_proc");
       ds3gpp_leave_global_crit_section();
       dssnet6_leave_crit_sect();
       return;
    }
  }
  // if the pdn context is already created
  else
  {
    pdn_cntx_p = (ds_pdn_context_s *)ds_iface_p->client_data_ptr;
    // if iface is not in down state, we need to exit
    if (ps_iface_state(if_ptr) != IFACE_DOWN)
    {
      DS_3GPP_MSG0_HIGH("Iface not in down state, do not do post processing.");
      ds3gpp_leave_global_crit_section();
      dssnet6_leave_crit_sect();
      return;
    }/* Iface is not in Down state */
  }

  /*-------------------------------------------------------------------------
    Mark the DS iface as being in use so that this iface is not reserved
    for dual IP bearer scenarios.
  -------------------------------------------------------------------------*/
  ds_iface_p->in_use = TRUE;

  /*-------------------------------------------------------------------------
      Assign the PDN context pointer to the client data pointer of the DS iface
      We have to note the DS iface pointer inside the PDN context struct
      Without that operation, the binding between the PS, DS ifaces and the PDN
      context will not be complete.
      However we cannot do that now because we have not set the IP type of PS
      Iface and without that, we will not be able to store the DS iface in the
      correct index of the DS Iface table in PDN context.
    -------------------------------------------------------------------------*/
  if(ds_iface_p->client_data_ptr == NULL)
  {
    ds_iface_p->client_data_ptr = (void*)pdn_cntx_p;
  }
    
  DS_3GPP_MSG2_HIGH("Interface 0x%x post proc DS Iface ptr:0x%x ",
              (uint32)this_if_ptr, if_ptr->client_data_ptr);

  pdp_profile_num = ds_3gpp_rt_acl_get_profile_num_from_policy(policy_info_ptr);
                    
  if(ds_3gpp_profile_cache_get_cache_index((pdp_profile_num & 0x000000FF), 
          dsumts_subs_mgr_get_subs_id_from_policy_subs_id(policy_info_ptr->subs_id)) == -1)
  {
    DS_3GPP_MSG1_ERROR("Invalid pdp prof number:%d",pdp_profile_num);
    ASSERT(0);
    return;
  }
  
  /*-------------------------------------------------------------------------
     Store the profile number specified for the call in the Call table
     if the interface is not currently in USE, This is to ensure that
     this is done ONLY when the interface is selected for the first time
     If an UP interface is selected by routing, this function is anyway
     called
  -------------------------------------------------------------------------*/
  if(!PS_IFACE_IS_IN_USE(if_ptr) &&
     (ps_iface_state(if_ptr) == IFACE_DOWN ))
  {
    memset(&prof_context, 0, sizeof(ds_umts_pdp_profile_type));
    ds_umts_get_pdp_profile_all_data_per_subs(pdp_profile_num,
                         dsumts_subs_mgr_get_subs_id(resolved_subs_id),
                                              &(prof_context));
    
    ds_3gpp_profile_is_valid = ds_pdn_cntxt_process_pdp_profile_info(pdn_cntx_p,
                                          pdp_profile_num,
                                          &ip_support, &prof_context);

    if (ds_3gpp_profile_is_valid == FALSE) 
    {
       DS_3GPP_MSG1_ERROR("pdp profile is not valid anymore %d ",pdp_profile_num);
    }
    pdn_cntx_p->ds_pdn_context_dyn_p->profile_is_valid = ds_3gpp_profile_is_valid;

    if ( policy_info_ptr->bring_up )
    {
      /*---------------------------------------------------------------------
        Set the iface linger timeout value only for embedded call 
        bring up scenarios.
      ---------------------------------------------------------------------*/
      if(PS_IFACE_PROC_ID_LOCAL == PS_IFACE_GET_PROC_ID(if_ptr))
      {
        sock_orig = TRUE;
      }
	  
      ds_3gpp_set_linger_timer_val(
                                    (uint16)pdp_profile_num, 
                                    resolved_subs_id, 
                                    if_ptr, 
                                    sock_orig
                                   );
      DS_3GPP_MSG3_HIGH("post_proc(): linger timer values set to %d ",if_ptr->iface_private.linger_timeout_val,0,0);
    }

    /*-----------------------------------------------------------------------
      Check if any profile parameters have been overridded by user. We 
      support APN override at present.
    -----------------------------------------------------------------------*/
    if(policy_info_ptr->apn.length != 0)
    {
      if (policy_info_ptr->apn.length < DS_UMTS_MAX_APN_STRING_LEN)
     {
       req_apn_length = policy_info_ptr->apn.length;
       memset(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn, 0, 
                   (DS_UMTS_MAX_APN_STRING_LEN + 1));

      // strlcpy copies (n-1) char and terminates it with null.
      (void) strlcpy((char *) pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn, 
            (char *) policy_info_ptr->apn.name, req_apn_length+1);
      DATA_3GPP_MSG_SPRINTF_1(MSG_LEGACY_HIGH , 
                              "APN overwrite in post proc is %s",
                              pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn);
     }
    }
#ifdef FEATURE_DATA_LTE
    /*------------------------------------------------------------------------------- 
      If pdn context's apn is NULL and resolved apn is populated
      popuate the pdn context's apn with resolved apn
    -------------------------------------------------------------------------------*/
    else if (pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn[0] == '\0')
    {    
      if(ds_eps_pdn_cntxt_get_resolved_apn_per_attach_sm(
                                        apn_requested,
                                        resolved_subs_id))
      {
        (void) strlcpy((char *)pdn_cntx_p->ds_pdn_context_dyn_p->
                        pdp_profile.context.apn, 
                       (char *) apn_requested,
                        DS_UMTS_MAX_APN_STRING_LEN+1); 
      }
    }
#endif /* #ifdef FEATURE_DATA_LTE */


    DS_3GPP_MSG1_HIGH("Profile pdp type is %d",pdn_cntx_p->ds_pdn_context_dyn_p->
                      pdp_profile.context.pdp_type);

    if(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type == DS_UMTS_PDP_IPV4V6 &&
       ds_3gpp_rt_acl_get_pdp_type_to_be_changed() == FALSE)
    {
      DS_3GPP_MSG1_MED("Need companion iface? pdp_type: %d", 
                pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type);

      if((ps_iface_get_addr_family(if_ptr) == IFACE_IPV4_ADDR_FAMILY) &&
         (ds3g_is_ipv6_enabled()== FALSE))
      {
        /*----------------------------------------------------------------------
          We need not allocate an Iface of the other IP type if the call being
          made is of type V4 and the NV item to turn on V6 stack is not enabled
        ----------------------------------------------------------------------*/
        DS_3GPP_MSG0_HIGH("V6 NV not enabled. Not allocating V6 iface");
      }
      else
      {
        ds_iface_other_p = ds_pdn_cntxt_allocate_ds_iface();
      } //determine if we need to allocate iface of other IP type

      if(ds_iface_other_p == NULL)
      {
        /*-------------------------------------------------------------------- 
          Mark that the PDP type has to be changed from Dual IP bearer to the
          IP family of the iface currently being brought up.
        --------------------------------------------------------------------*/
        ds_3gpp_rt_acl_set_pdp_type_to_be_changed(TRUE);
        DS_3GPP_MSG0_HIGH("Profile Dual IP bearer. Cannot allocate other iface");
      }
      else
      {
        DS_3GPP_MSG2_HIGH("Allocated companion iface 0x%x:0x%x", 
                ds_iface_other_p->ps_iface.name, 
                ds_iface_other_p->ps_iface.instance);
        ds_subs_id = ds3gsubsmgr_subs_id_cm_to_ds(resolved_subs_id);

        PS_IFACE_SET_SUBS_ID(&(ds_iface_other_p->ps_iface), ds_subs_id);

        ds_iface_other_p->client_data_ptr = (void*) pdn_cntx_p;
        /*
          Since we are allocating the other iface only here, we need to set
          is_sock_orig flag here. this is coz ds_pdn_cntxt_processPdpProfileInfo
          would not have done it
        */

        /*----------------------------------------------------------------------
          Also set the flag to indicate that there is no need to do any post
          processing.
        ----------------------------------------------------------------------*/
        ds_iface_other_p->post_proc_done_flag = TRUE;

        if(ds3g_is_ipv6_enabled() == TRUE)
        {
          ds_3gpp_pdn_context_v6_sm_update(ds_iface_other_p,resolved_subs_id);
        }

      }
    } /* allocation of Iface for other IP type */

    /*-----------------------------------------------------------------------
      Determine Call type to be originated. Since Iface is not in use, set 
      the Iface type to the type of call going to be originated. 
      After setting the IP type of PS iface, we know in which index of PDN, 
      the DS Iface is to be stored. It is at the end of this switch-case that
      the binding between the PS, DS Ifaces and PDN context is complete.
    -----------------------------------------------------------------------*/
#ifdef FEATURE_DATA_PS_IPV6
    call_type_originate = ds3gpp_determine_call_type_to_be_originated
             ( &(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context), policy_info_ptr);
    switch(call_type_originate)
    {
      case DS_3GPP_PDP_TYPE_IPV6:
	this_iface_ip_type = IFACE_IPV6_ADDR_FAMILY;
        tmp_result = ps_iface_set_addr_family(if_ptr, this_iface_ip_type);
        if (tmp_result == -1)
        {
          DS_3GPP_MSG2_ERROR("ps_iface_set_addr_family failed if_ptr = %d "
			     "addr_family = %d", 
			     if_ptr, IFACE_IPV6_ADDR_FAMILY);
          ASSERT(0);
        }
      break;
 
      case DS_3GPP_PDP_TYPE_IP_ANY:
        switch(ds3g_get_failover_mode())
        {
          /*------------------------------------------------------------
            We are not supporting V4/V6 desired till now. So default to 
            V4/V6 preferred.
          ------------------------------------------------------------*/

          case IPV4_DESIRED:
          case IPV4_PREFERRED:
            this_iface_ip_type = IFACE_IPV4_ADDR_FAMILY;
            tmp_result = ps_iface_set_addr_family(if_ptr, this_iface_ip_type);
            if (tmp_result == -1)
            {
              DS_3GPP_MSG2_ERROR("ps_iface_set_addr_family failed if_ptr = %d "
                             "addr_family = %d",if_ptr, IFACE_IPV4_ADDR_FAMILY);
              ASSERT(0);
            }
          break;

          case IPV6_DESIRED:
          case IPV6_PREFERRED: 
            this_iface_ip_type = IFACE_IPV6_ADDR_FAMILY;
            tmp_result = ps_iface_set_addr_family(if_ptr, this_iface_ip_type); 
            if (tmp_result == -1)
            {
              DS_3GPP_MSG2_ERROR("ps_iface_set_addr_family failed if_ptr = %d "
                           "addr_family = %d", if_ptr, IFACE_IPV6_ADDR_FAMILY);
              ASSERT(0);
            }
            break;

          default:
            DS_3GPP_MSG1_HIGH("ds3gpp_failover_mode set to invalid value %d",
                     ds3g_get_failover_mode());
            ASSERT(0);
            break;
          }
      break;

      /*-------------------------------------------------------------------
        Call to be originated is of type IPV4 or PPP. Set the UM iface to 
        IPV4 as IPV6 is not supported for TE calls. 
      --------------------------------------------------------------------*/
      default:
        this_iface_ip_type = IFACE_IPV4_ADDR_FAMILY;
        tmp_result = ps_iface_set_addr_family(if_ptr, this_iface_ip_type);
        if (tmp_result == -1)
        {
          DS_3GPP_MSG2_ERROR("ps_iface_set_addr_family failed if_ptr = %d " 
                            "addr_family = %d",if_ptr, IFACE_IPV4_ADDR_FAMILY);
          ASSERT(0);
        }

        break;
    }
    switch(this_iface_ip_type)
    {
      case IFACE_IPV4_ADDR_FAMILY:
        pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[DS_3GPP_PDN_CONTEXT_IPV4_IFACE]=\
   	              (ds_3gpp_iface_s*)(if_ptr->client_data_ptr);

        if(ds_3gpp_rt_acl_get_pdp_type_to_be_changed() == TRUE)
        {
          /*--------------------------------------------------------------
            This is a case where we could not get the iface for other IP
            type traffic. In this case we set the PDP type to be V4

            Change the value in ip_support so that we update the APN table
            correctly.
          --------------------------------------------------------------*/
          pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type = DS_UMTS_PDP_IPV4;
          ip_support = DS_IPV4_SINGLE_BEARER;
        }

        DS_3GPP_MSG3_HIGH("iface post_proc 0x%x:0x%x pdp_type:%d", 
                           if_ptr->name, if_ptr->instance,
                           pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type);

        /*----------------------------------------------------------------
          Store info about the other iface. This will be used only if the
          other DS Iface pointer is non-null
        ----------------------------------------------------------------*/
        companion_iface_ip_type = IFACE_IPV6_ADDR_FAMILY;
        ds_companion_iface_index = DS_3GPP_PDN_CONTEXT_IPV6_IFACE;
        if(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type != DS_UMTS_PDP_IPV4V6)
        {
          pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[ds_companion_iface_index] = NULL;
        }

        break;
      case IFACE_IPV6_ADDR_FAMILY:
        pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[DS_3GPP_PDN_CONTEXT_IPV6_IFACE]=\
     	              (ds_3gpp_iface_s*)(if_ptr->client_data_ptr);

        if(ds_3gpp_rt_acl_get_pdp_type_to_be_changed() == TRUE)
        {
          /*--------------------------------------------------------------
            This is a case where we could not get the iface for other IP
            type traffic. In this case we set the PDP type to be V6

            Change the value in ip_support so that we update the APN table
            correctly.
          --------------------------------------------------------------*/
          pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type = DS_UMTS_PDP_IPV6;
          ip_support = DS_IPV6_SINGLE_BEARER;       
        }

        DS_3GPP_MSG3_HIGH("iface post_proc 0x%x:0x%x pdp_type:%d", 
                           if_ptr->name, if_ptr->instance,
                           pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type);  

        /*----------------------------------------------------------------
          Store info about the other iface. This will be used only if the
          other DS Iface pointer is non-null
        ----------------------------------------------------------------*/
        companion_iface_ip_type = IFACE_IPV4_ADDR_FAMILY;
        ds_companion_iface_index = DS_3GPP_PDN_CONTEXT_IPV4_IFACE;
        if(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type != DS_UMTS_PDP_IPV4V6)
        {
          pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[ds_companion_iface_index] = NULL;
        }

        break;
      default:
        DS_3GPP_MSG0_ERROR("Unexpected iface ip type!");
        break;
    }

    /*--------------------------------------------------------------------
      Set the IP type of the other iface and store it in the correct index
      in the PDN context
    --------------------------------------------------------------------*/
    if(ds_iface_other_p != NULL)
    {
      tmp_result = ps_iface_set_addr_family(&(ds_iface_other_p->ps_iface),\
                                            companion_iface_ip_type);
      if (tmp_result == -1)
      {
        DS_3GPP_MSG2_ERROR("ps_iface_set_addr_family failed if_ptr = %d "
                           "addr_family = %d", 
                           &(ds_iface_other_p->ps_iface), 
                           companion_iface_ip_type);
        ASSERT(0);
      }

      ASSERT(ds_companion_iface_index == DS_3GPP_PDN_CONTEXT_IPV4_IFACE ||
             ds_companion_iface_index == DS_3GPP_PDN_CONTEXT_IPV6_IFACE);

      pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[ds_companion_iface_index]
                                                                = ds_iface_other_p;
    }

    DS_3GPP_MSG2_HIGH("iface post_proc 0x%x:0x%x companion iface is NULL", 
                       if_ptr->name, if_ptr->instance);                   
    /*----------------------------------------------------------------------------
      Finally, update the APN table so that we have some info in the table while 
      the call is initated.
    ----------------------------------------------------------------------------*/
      if(ds_apn_table_add_pdn(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn,
                                       ip_support,
                                       pdn_cntx_p) != DS3G_SUCCESS)
      {
        DS_3GPP_MSG2_ERROR("Error updating APN tbl. Pdn: 0x%x, IP support::%d",
            pdn_cntx_p,ip_support);
      }
      else
      {
         DS_3GPP_MSG2_MED("Succesfully updated APN tbl. Pdn: 0x%x," 
           "IP support::%d",pdn_cntx_p,ip_support);

      }
   
#endif
  }//PS_IFACE_IS_IN_USE
  else
  {
    DS_3GPP_MSG1_HIGH("Interface already in use:prof :%d", pdp_profile_num);
  }

#ifdef FEATURE_EPC_HANDOFF
  /*----------------------------------------------------------------------------
    If this is handover attach, mark the boolean in PDN context so that we send
    out the orig params correctly
  ----------------------------------------------------------------------------*/
  if(policy_info_ptr->handoff_ctxt.handoff_class != PS_IFACE_HANDOFF_CLASS_NONE)
  {
    ds_pdn_cntxt_set_handover_attach_flag(pdn_cntx_p, TRUE);
    DS_3GPP_MSG0_HIGH("Post proc for handover case");
  }
#endif /* FEATURE_EPC_HANDOFF */

  /*-------------------------------------------------------------------------
    Reset the pdp_type_to_be_changed flag
  -------------------------------------------------------------------------*/
  ds_3gpp_rt_acl_set_pdp_type_to_be_changed(FALSE);
  DS_3GPP_MSG0_MED("Post proc complete");
  ds3gpp_leave_global_crit_section();
  dssnet6_leave_crit_sect();

} /* ds3gpp_rt_acl_post_proc() */

/*===========================================================================
FUNCTION check_ip_compatibility

DESCRIPTION
  Check IP addr compatibility
  
PARAMETERS  
  req_ip_family : Iface ptr
  if_ip_family  : fallback deny reaon
      
DEPENDENCIES 
  None.
  
RETURN VALUE 
  boolean 
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
boolean check_ip_compatibility
(
  ps_iface_addr_family_type req_ip_family,
  ps_iface_addr_family_type if_ip_family
)
{

  boolean ret = FALSE;

  DS_3GPP_MSG2_MED( "chk IP compat: addr type req [%d], if [%d]", 
                     req_ip_family, if_ip_family);

  switch(if_ip_family)
  {
  case IPV4_ADDR: 
    {
      switch(req_ip_family)
      {
        case IPV4_ADDR:
        case IP_ANY_ADDR:
        case IFACE_UNSPEC_ADDR_FAMILY:
          ret = TRUE;
          break;
       
        case IPV6_ADDR:
        default:
          DS_3GPP_MSG1_HIGH("chk IP compat: failed, IP Addr type "
                            "[%d] req in Policy", req_ip_family);
          ret = FALSE;
          break;
       }
    }/*IPv4*/
  break;
 
  case IPV6_ADDR:
  {
    switch(req_ip_family)
    {
      case IPV6_ADDR:
      case IP_ANY_ADDR:
      case IFACE_UNSPEC_ADDR_FAMILY:
        ret = TRUE;
        break;
       
      case IPV4_ADDR:
      default:
        DS_3GPP_MSG0_HIGH("chk IP compat: failed, IP Addr type [%d] req in Policy");
        ret = FALSE;
        break;
    }
  }/*IPv6*/
  break;
   
  case IFACE_UNSPEC_ADDR_FAMILY:
  case IP_ANY_ADDR: 
  {
    switch( req_ip_family )
    {
      case IPV6_ADDR:
      case IPV4_ADDR:
      case IP_ANY_ADDR:
      case IFACE_UNSPEC_ADDR_FAMILY:
        ret = TRUE;            
        break;
       
      default:
        DS_3GPP_MSG0_HIGH("chk IP compat: failed, IP Addr type [%d] req in Policy");
        ret = FALSE;
        break;
    }
  }
  break;

  default:
    DS_3GPP_MSG0_ERROR("Invalid Iface IP family type");
    ret = FALSE;
    break;
  }

  DS_3GPP_MSG1_ERROR("chk compat ret [%d]",ret);
  return ret;

}/*check_ip_compatibility()*/

/*===========================================================================
FUNCTION get_deny_reason_code_by_cfg

DESCRIPTION
  Used to override Iface deny reason by type
  
PARAMETERS  
  *if_ptr   : Iface ptr
   fallback : fallback deny reaon
      
DEPENDENCIES 
  None.
  
RETURN VALUE 
  integer reason code
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
static int get_deny_reason_code_by_iface_type
(
  ps_iface_type        *if_ptr,
  int                   fallback
)
{

  DS_3GPP_MSG1_HIGH( "Iface deny reason [%d]" ,
                     fallback);
  
  return fallback;
}/* get_deny_reason_code_by_iface_type() */

/*===========================================================================
FUNCTION get_deny_reason_code_by_cfg

DESCRIPTION
  This function checks to see if preferred system is 
  
PARAMETERS  
  *policy_info_ptr    - Policy information
      
DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : Interface is available (either idle or in use but shareable)
  FALSE: Interface is NOT available (in use and not shareable)
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
static int get_deny_reason_code_by_cfg
(
  ps_iface_type        *if_ptr,
  acl_policy_info_type *policy_info_ptr
)
{
  uint32                     pol_pdp_profile_num;
  int                        reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH ;
  boolean                    iface_state_is_up;
  boolean                    iface_in_use;
  ps_iface_state_enum_type   iface_state;
  boolean                    iface_cfg_match_prf, iface_cfg_match_ip;

  if(policy_info_ptr == NULL || if_ptr == NULL)
  {
    DS_3GPP_MSG2_ERROR("get_deny_reason_code_by_cfg: policy ptr = 0x%x  "
                       "iface ptr = 0x%x",policy_info_ptr,if_ptr);
    return reason_for_deny;
  }
  /* get the profile pointer passed */
  pol_pdp_profile_num = ds_3gpp_rt_acl_get_profile_num_from_policy(policy_info_ptr);

  if(ds_3gpp_profile_cache_get_cache_index((pol_pdp_profile_num & 0x000000FF),
           dsumts_subs_mgr_get_subs_id_from_policy_subs_id(policy_info_ptr->subs_id)) == -1)
  {
    DS_3GPP_MSG1_ERROR("Invalid pdp prof number:%d",pol_pdp_profile_num);
    return ACL_DENY_REASON_INVALID_PROFILE_ID;
  }
  iface_in_use      = PS_IFACE_IS_IN_USE(if_ptr);
  iface_state       = ps_iface_state(if_ptr);
  iface_state_is_up = ( (iface_state != IFACE_DOWN) && (iface_state != IFACE_GOING_DOWN) );


   DS_3GPP_MSG3_MED("Iface [0x%x:%x], policy pdp profile [%d], Prf [%d] ",
                     if_ptr->name, if_ptr->instance, pol_pdp_profile_num);
   DS_3GPP_MSG2_MED("state [%d], in use? [%d]",
                     iface_state, iface_in_use);

  if( iface_state_is_up )
  {
    iface_cfg_match_prf = ds3gpp_compare_pdp_profile_info( if_ptr, 
                                                           pol_pdp_profile_num, 
                                                           policy_info_ptr,
                                                           &reason_for_deny );

    if( iface_cfg_match_prf == FALSE )
    {
      DS_3GPP_MSG1_ERROR( "Iface Bringup Fail for deny reason %d",reason_for_deny);
      return reason_for_deny;
    }

    iface_cfg_match_ip  = check_ip_compatibility( policy_info_ptr->ip_family, 
                                                  ps_iface_get_addr_family(if_ptr) );

    if(iface_cfg_match_ip == FALSE) 
    {
      DS_3GPP_MSG0_ERROR( "Iface Bringup Fail for IP Version mismatch");
      return ACL_DENY_REASON_IP_VERSION_MISMATCH;
    }

    DS_3GPP_MSG2_ERROR("Iface [0x%x:%x] is UP and cfg match, DENY IN_USE_CFG_MATCH",
                     if_ptr->name, if_ptr->instance);
    return ACL_DENY_REASON_IFACE_IN_USE_CFG_MATCH;
  }
  else
  {
    DS_3GPP_MSG3_ERROR( "Iface [0x%x:%x] DENY POL_NO_MATCH, Prf [%d]", 
                       if_ptr->name, if_ptr->instance, pol_pdp_profile_num );
    return ACL_DENY_REASON_POL_NO_MATCH;
  }

}/* get_deny_reason_code_by_cfg() */

/*===========================================================================
FUNCTION DS_3GPP_RT_ACL_IS_CLAT_SUPPORTED

DESCRIPTION
  This function returns the CLAT_SUPPORTED field for the passed profile or
  resolved profile passed in Policy

PARAMETERS
  arg_val_ptr - IOCTL payload pointer
  subs_id     - subscription id
  ps_error    - incase any error occured, details of it

DEPENDENCIES
  None.

RETURN VALUE
  0  - Success
  -1 - Failure
       DS_EFAULT   if NULL pointers passed.
       DS_ENETDOWN if PDN contexts are not valid.

SIDE EFFECTS
  None.
===========================================================================*/
int ds_3gpp_rt_acl_is_clat_supported
(
  void                    *arg_val_ptr,
  sys_modem_as_id_e_type   subs_id,
  int16                   *ps_errno
)
{
  ps_sys_ioctl_clat_support_type  *clat_supp_ptr = NULL;
  acl_policy_info_type            *policy_info_ptr = NULL;
  uint32                           policy_prof_id = 0;
  sys_modem_as_id_e_type           resolved_subs_id = SYS_MODEM_AS_ID_NONE;
  boolean                          is_clat_enabled = FALSE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if( ps_errno == NULL )
  {
    return -1;
  }

  if (arg_val_ptr == NULL)
  {
    *ps_errno = DS_EFAULT;
    return -1;
  }

  clat_supp_ptr   = (ps_sys_ioctl_clat_support_type*)arg_val_ptr;
  policy_info_ptr = clat_supp_ptr->acl_policy_info_ptr;

  /*---------------------------------------------------------------------
    Fail IOCTL if current preferred mode per APN is not 3GPP
  ---------------------------------------------------------------------*/
  if( (!(ds3gpp_is_pref_pkt_sys_mode(policy_info_ptr,
                                     SYS_SYS_MODE_LTE)))   &&
      (!(ds3gpp_is_pref_pkt_sys_mode(policy_info_ptr,
                                     SYS_SYS_MODE_WCDMA))) &&
      (!(ds3gpp_is_pref_pkt_sys_mode(policy_info_ptr,
                                     SYS_SYS_MODE_GSM)))   &&
      (!(ds3gpp_is_pref_pkt_sys_mode(policy_info_ptr,
                                     SYS_SYS_MODE_TDS)))
    )
  {
    *ps_errno = DS_EINVAL;
    return -1;
  }

  /*-------------------------------------------------------------------------
    Get Profile ID from policy
  -------------------------------------------------------------------------*/
  policy_prof_id = ds_3gpp_rt_acl_get_profile_num_from_policy(policy_info_ptr);

  /*-------------------------------------------------------------------------
    Get the resolved subs id
  -------------------------------------------------------------------------*/
  if( ds3g_resolve_subs_id(policy_info_ptr->subs_id ,&resolved_subs_id ) 
        == FALSE) 
  {
    *ps_errno = DS_EINVAL;
    return -1;
  }


  /*-------------------------------------------------------------------------
    Get CLAT value from the profile id
  -------------------------------------------------------------------------*/
  if( DS_UMTS_PDP_SUCCESS != ds_umts_get_pdp_profile_clat_enabled(
                               policy_prof_id,
                               dsumts_subs_mgr_get_subs_id(resolved_subs_id),
                               &is_clat_enabled) )
  {
    *ps_errno = DS_EINVAL;
    return -1;
  }

  clat_supp_ptr->is_clat_supported = is_clat_enabled;
  *ps_errno = DS_ENOERR;
  return 0;
} /* ds_3gpp_rt_acl_is_clat_supported */

/*===========================================================================
FUNCTION DS_3GPP_RT_ACL_INIT_RULE

DESCRIPTION
  This function performs initial rules

PARAMETERS  
  *this_if_ptr        - Ptr to the interface
  *ipfilter_info_ptr  - Ip filter information
  *policy_info_ptr    - Policy information

DEPENDENCIES 
  None.

RETURN VALUE 
  TRUE : Interface is available (either idle or in use but shareable)
  FALSE: Interface is NOT available (in use and not shareable)

SIDE EFFECTS 
  None.
===========================================================================*/
ACL_IS_AVAILABLE_DEF2( ds_3gpp_rt_acl_init_rule )
{
  sys_modem_as_id_e_type  resolved_subs_id = SYS_MODEM_AS_ID_NONE;
  sys_sys_mode_e_type     cur_nw_mode = SYS_SYS_MODE_NONE;
  boolean                 roaming_status = FALSE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(reason_for_deny == NULL )
  {
     DS_3GPP_MSG0_ERROR("reason_for_deny ptr is NULL");
     return FALSE;
  }

  /* check if subscription passed from application is valid for present configuration */
  if (ds3gsubsmgr_is_subs_valid_in_current_config(
            ds3gsubsmgr_subs_id_ds_to_ds3g(policy_info_ptr->subs_id))!= TRUE)
  {
    DS_3GPP_MSG1_ERROR("Invalid Subscription number:%d",policy_info_ptr->subs_id);
    *reason_for_deny = ACL_DENY_REASON_SUBS_ID_MISMATCH;
    return FALSE;
  }
  
  /* Get the resolved subs id */
  if( ds3g_resolve_subs_id(policy_info_ptr->subs_id ,&resolved_subs_id ) 
        == FALSE) 
  {
    *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
    DS_3GPP_MSG1_ERROR("Deny Iface invalid Policy SUB ID %d",
                       policy_info_ptr->subs_id);

    return FALSE;
  }
  
  ds3gpp_enter_global_crit_section();
  roaming_status = ds_3gpp_roaming_get_status(resolved_subs_id);
  cur_nw_mode = ds3g_get_current_network_mode_ex(resolved_subs_id);
  ds3gpp_leave_global_crit_section();

  return TRUE;
} /* ds_3gpp_rt_acl_init_rule() */

/*===========================================================================
FUNCTION ds3gpp_rt_is_pref_sys

DESCRIPTION
  This function checks to see if preferred system is 
  
PARAMETERS  
  *this_if_ptr        - Ptr to the interface
  *ipfilter_info_ptr  - Ip filter information
  *policy_info_ptr    - Policy information
      
DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : Interface is available (either idle or in use but shareable)
  FALSE: Interface is NOT available (in use and not shareable)
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
/*lint -esym(715,pkt_info_ptr) */
ACL_IS_AVAILABLE_DEF2( ds3gpp_rt_is_pref_sys )
{
  ps_iface_type *if_ptr = (ps_iface_type *) this_if_ptr;
  uint32 pdp_profile_num = 0;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* For Fusion, check if we are on preferred system 
     and if it is available 
   */
  if(reason_for_deny == NULL )
  {
     DS_3GPP_MSG0_ERROR("reason_for_deny ptr is NULL");
     return FALSE;
  }
  /*----------------------------------------------------------------------------
    Skip the preferred system check if handoff is being performed. This is 
    necessary because:
    1. Compatibility check performed after trat iface selection will otherwise 
       fail on the srat iface
    2. Routing performed to transfer initial context during LTE attach
       procedure will otherwise fail (as DSD preferred system does not change 
       until full service is acquired, which will only occur after attach is 
       complete. 
  ---------------------------------------------------------------------------*/

#ifdef FEATURE_EPC_HANDOFF
  if(policy_info_ptr->handoff_ctxt.handoff_class != PS_IFACE_HANDOFF_CLASS_NONE)
  {
    DS_3GPP_MSG2_HIGH( "DS_3GPP_RT_ACL: Iface [%x:%d] NOT DENIED, HO routing", 
                if_ptr->name, if_ptr->instance);
    return TRUE;
  }
#endif 
  /*------------------------------------------------------------------------ 
    PS framwork only does this data path routing for those Ifaces in UP state
    */
  if((policy_info_ptr->bring_up == 0) && (policy_info_ptr->lookup_only == 0))
  {
    return TRUE;
  }

  if(policy_info_ptr->allow_less_pref_sys == TRUE)
  {
    DS_3GPP_MSG2_HIGH( "DS_3GPP_RT_ACL: Iface [%x:%d] NOT DENIED, allow less pref sys set", 
                if_ptr->name, if_ptr->instance);
    return TRUE;
  }

  pdp_profile_num = ds_3gpp_rt_acl_get_profile_num_from_policy(policy_info_ptr);
               
  if(ds_3gpp_profile_cache_get_cache_index((pdp_profile_num & 0x000000FF),
              dsumts_subs_mgr_get_subs_id_from_policy_subs_id(policy_info_ptr->subs_id)) == -1)
  {
    DS_3GPP_MSG1_ERROR("Invalid pdp prof number:%d",pdp_profile_num);
    *reason_for_deny = ACL_DENY_REASON_INVALID_PROFILE_ID;
    return FALSE;
  }

  if( 
      (!(ds3gpp_is_pref_pkt_sys_mode(policy_info_ptr, SYS_SYS_MODE_LTE))) && 
      (!(ds3gpp_is_pref_pkt_sys_mode(policy_info_ptr, SYS_SYS_MODE_WCDMA))) &&
      (!(ds3gpp_is_pref_pkt_sys_mode(policy_info_ptr, SYS_SYS_MODE_GSM)))
#ifdef FEATURE_TDSCDMA
      &&
      (!(ds3gpp_is_pref_pkt_sys_mode(policy_info_ptr, SYS_SYS_MODE_TDS)))
#endif /*FEATURE_TDSCDMA*/
    )
  {
    *reason_for_deny = ACL_DENY_REASON_UNPREFERRED_RAT;
    return FALSE;
  }
  return TRUE;
}

/*===========================================================================
FUNCTION DS_3GPP_RT_IS_CFG_SUPP

DESCRIPTION
  This function checks to see if the specified PS Iface (which is IN_USE)
  is available for others to use.
  
PARAMETERS  
  *this_if_ptr        - Ptr to the interface
  *ipfilter_info_ptr  - Ip filter information
  *policy_info_ptr    - Policy information
      
DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : Interface is available (either idle or in use but shareable)
  FALSE: Interface is NOT available (in use and not shareable)
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
/*lint -esym(715,pkt_info_ptr) */
ACL_CFG_SUPPORTED_DEF2( ds_3gpp_rt_is_cfg_supp )
{
  ps_iface_type *if_ptr = (ps_iface_type *) this_if_ptr;
  sys_modem_as_id_e_type resolved_subs_id = SYS_MODEM_AS_ID_NONE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(reason_for_deny == NULL || if_ptr == NULL)
  {
     DS_3GPP_MSG2_ERROR("ds_3gpp_rt_is_cfg_supp :reason_for_deny ptr"
                        "=0x%x or iface ptr = 0x%x",reason_for_deny,if_ptr);
     return FALSE;
  }
  
  *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
  
  /*-------------------------------------------------------------------------
    The following rules determine if the iface is available/not
    - if interface is not in use, it is available
    - if interface is in use by a TE2 return FALSE
    - if interface is in use by sockets & routing is also done for 
      sockets, then iface is available : return TRUE
    - if interface is in use by TE2 & routing is done by sockets,
      iface is only available for routeable entities (which can be routed 
      in presence of TE2 calls), return FALSE for all others
  -------------------------------------------------------------------------*/


   if( ds3g_resolve_subs_id(policy_info_ptr->subs_id ,&resolved_subs_id ) == FALSE) 
   {
       DS_3GPP_MSG1_ERROR("Error in obtaining resolved sub id. "
                          "Policy PS Sub ID is %d", policy_info_ptr->subs_id);
       *reason_for_deny = ACL_DENY_REASON_SUBS_ID_MISMATCH;
       return FALSE;
   }

   if (ds_3gpp_hdlr_nv_refresh_in_progress(resolved_subs_id))
   {
     *reason_for_deny = ACL_DENY_REASON_NV_REFRESH_IN_PROGRESS;
     return FALSE;   
   }

   /* Deny iface during thermal mitigation:
        1) Deny if no calls are allowed
        2) Deny if only IMS is allowed but apn type is not IMS
   */
   if ((ds_3gpp_pdn_cntxt_get_th_mit_pdn_state() 
          == DS3GEVENTMGR_TH_MIT_TEAR_DOWN_BLOCK_ALL_CALLS) ||
       (ds_3gpp_pdn_cntxt_get_th_mit_pdn_state()
          == DS3GEVENTMGR_TH_MIT_ALLOW_ONLY_IMS_CALLS &&
        (policy_info_ptr->apn_type != PS_IFACE_APN_TYPE_IMS &&
        PS_IFACE_GET_APN_TYPE(if_ptr) != PS_IFACE_APN_TYPE_IMS))
      )
   {
     *reason_for_deny = ACL_DENY_REASON_THERMAL_MITIGATION;
     return FALSE;
   }

  /* iface not in use hence available */
  if(!PS_IFACE_IS_IN_USE(if_ptr))
  {
    return TRUE;
  }
  /* iface in use, cfg no-match, Iface is shareable, hence available for sockets */
  else if(PS_IFACE_IS_SHAREABLE(if_ptr))
  {
    return TRUE;
  }
  else
  {
  /* iface in use by TE2 and cannot be shared by non routeable sockets */  
    /* Iface in_use, not available for TE, check if cfg matches */
    *reason_for_deny = get_deny_reason_code_by_cfg( if_ptr, policy_info_ptr );
    DS_3GPP_MSG3_HIGH( "Iface [0x%x:%x], DENY reason [%d]", 
                       if_ptr->name, if_ptr->instance, *reason_for_deny );
  return FALSE;
  }

} /* ds_3gpp_rt_is_cfg_supp() */


/*===========================================================================
FUNCTION DS3GPP_RT_IS_CFG_SUPPORTED

DESCRIPTION
   This function checks to see if the configuration requested can be 
   supported by the specified interface ie can the interface be aciveted
   using the specified configuration.
  
PARAMETERS  
  *this_if_ptr        - Ptr to the interface
  *ipfilter_info_ptr  - Ip filter information
  *policy_info_ptr    - Policy information
    
DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : config can be supported
  FALSE: config cannot be supported (bad config or interface already 
         activated using a different config)
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
ACL_CFG_SUPPORTED_DEF( ds3gpp_rt_is_cfg_supported )
{
  uint32  pdp_profile_num = 0;
  
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  /*-------------------------------------------------------------------------
    The following rules determine if the cfg can be supported
    - if pdp profile number is 0 & incoming call is from laptop, ASSERT
    as this is not supposed to occur. Laptop always specifies a valid 
    pdp profile
    - if policy is UP only don't check config, return TRUE
    - if profile number is '0', retrieve sockets call profile num from 
      EFS
    - if profile number is out of range, return FALSE;
    - if interface is in use & profile number req is not same as current
      profile number on the interface, return FALSE, unless UP preferred
      is specified
    - if interface is in use & profile information (APN, PDP type and PDP addr)
      of req. profile number is not the same as information of the current 
      profile number on the interface, return FALSE, unless UP preferred
      is specified
    - If iface is in use, check the profile definition to 
      see if the parameters are valid 
    - if interface is not in use but is looked_up & policy also specifies 
      lookup then if the profile number req is not same as the current 
      profile number on the interface, return FALSE 
    - if interface is not in use but is looked_up & policy also specifies 
      lookup, then if profile information of the req. profile number is not 
      the same as information of the current profile number of the interface,  
      return FALSE, unless UP preferred is specified
  -------------------------------------------------------------------------*/
  
  /*-------------------------------------------------------------------------
    If the policy UP only is specified, then any UP iface can be used 
    irrespctive of the configuration its using. Also no need to validate
    the config that's passed in the policy.
  -------------------------------------------------------------------------*/
  if( policy_info_ptr->policy_flag == DSS_IFACE_POLICY_UP_ONLY )
  {
    return TRUE;
  }
  
  /* get the profile pointer passed  if any */
  pdp_profile_num = ds_3gpp_rt_acl_get_profile_num_from_policy(policy_info_ptr);

  if(ds_3gpp_profile_cache_get_cache_index((pdp_profile_num & 0x000000FF),
             dsumts_subs_mgr_get_subs_id_from_policy_subs_id(policy_info_ptr->subs_id)) == -1)
  {
    DS_3GPP_MSG3_ERROR("Invalid pdp prof number:%d",pdp_profile_num,0,0);
    return FALSE;
  }

#ifdef FEATURE_DATA_PS_IWLAN_3GPP
  /*-------------------------------------------------------------------------
    If the profile requested is already used by an IWLAN iface return
    FALSE. We don't allow simultaneous UMTS/IWLAN calls using the same
    profile.
  -------------------------------------------------------------------------*/
  if(iwlan_3gpp_rt_is_profile_in_use(pdp_profile_num, policy_info_ptr) == 
      TRUE)
  {
    DS_3GPP_MSG1_ERROR("error profile number:%d is in use by WLAN",pdp_profile_num);
    return FALSE;
  }
#endif /*FEATURE_DATA_PS_IWLAN_3GPP*/
  return TRUE;

} /* ds3gpp_rt_is_cfg_supported() */

/*===========================================================================
FUNCTION DS3GPP_RT_IS_CFG_SUPPORTED2

DESCRIPTION
   This function checks to see if the configuration requested can be 
   supported by the specified interface ie can the interface be aciveted
   using the specified configuration.
  
PARAMETERS  
  *this_if_ptr        - Ptr to the interface
  *ipfilter_info_ptr  - Ip filter information
  *policy_info_ptr    - Policy information

   
DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : config can be supported
  FALSE: config cannot be supported (bad config or interface already 
         activated using a different config)
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
ACL_CFG_SUPPORTED_DEF2( ds3gpp_rt_is_cfg_supported2 )
{
  uint32  pdp_profile_num = 0;
  ds_umts_pdp_profile_status_etype result;    
  ps_iface_type *if_ptr = (ps_iface_type *) this_if_ptr;
  ps_iface_type *companion_if_ptr = NULL;
  ds_pdn_context_s *pdn_cntx_p = NULL;
  sys_modem_as_id_e_type resolved_subs_id = SYS_MODEM_AS_ID_NONE;
  boolean                is_emergency_auth_fail = FALSE;
  int	                 comp_iface_rm_inst = 0;

#ifdef FEATURE_DATA_PS_IPV6
  ds_pdn_context_type_e           call_type_originate;
  ds_umts_pdp_profile_type        profile_info;
  ds_apn_ip_support_type_e        ip_support;
#endif
  ds_3gpp_iface_s                *ds_3gpp_iface_p;
  uint8                           iface_index = 0;
  byte                            apn_requested[DS_UMTS_MAX_APN_STRING_LEN+1];
  ps_iface_net_down_reason_type   down_reason = PS_NET_DOWN_REASON_NOT_SPECIFIED;
  boolean                         roaming_status = FALSE;
  ds_umts_pdp_type_enum_type      pdp_type_to_use;
  sys_sys_mode_e_type             cur_nw_mode;
#ifdef FEATURE_DATA_LTE
  ds_eps_tlb_per_subs_info_type    *tlb_hndl = NULL;
#endif
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(reason_for_deny == NULL )
  {
    DS_3GPP_MSG0_ERROR("ds3gpp_rt_is_cfg_supported2: deny reason is NULL");
    return FALSE;
  }

  *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;

  memset(apn_requested,0,DS_UMTS_MAX_APN_STRING_LEN+1);
  if(policy_info_ptr == NULL )
  {
    DS_3GPP_MSG0_ERROR("ds3gpp_rt_is_cfg_supported2: policy ptr is NULL ");
    return FALSE;
  }

  if(! ds3g_resolve_subs_id(policy_info_ptr->subs_id ,&resolved_subs_id )) 
  {
    *reason_for_deny = ACL_DENY_REASON_SUBS_ID_MISMATCH;
    DS_3GPP_MSG1_ERROR("Deny Iface invalid Policy SUB ID %d",
                       policy_info_ptr->subs_id);
    return FALSE;
  }
  if(if_ptr == NULL)
  {
    DS_3GPP_MSG0_ERROR("ds3gpp_rt_is_cfg_supported2: Iface ptr is NULL ");
    return FALSE;
  }

#ifdef FEATURE_DATA_LTE
  tlb_hndl = ds_eps_tlb_get_per_subs_info_hndl(resolved_subs_id);
  if (ds_eps_tlb_validate_per_subs_info_hndl(tlb_hndl))
  {
     ds3gpp_enter_global_crit_section();
     if((!(policy_info_ptr->tlb_mode)) &&
     (tlb_hndl->tlb_state.mode == LTE_TLB_MODE_A || 
        tlb_hndl->tlb_state.mode == LTE_TLB_MODE_B))
     {
       DS_3GPP_MSG1_HIGH("UE is in TLB mode: %d Denied",
                          tlb_hndl->tlb_state.mode);
       *reason_for_deny = ACL_DENY_REASON_TEST_LOOPBACK_MODE_A_OR_B_ENABLED;
       ds3gpp_leave_global_crit_section();
       return FALSE;
     }
     ds3gpp_leave_global_crit_section();
  }
#endif

  /*-------------------------------------------------------------------------
    Get the DS Iface pointer from the PS Iface. 
    -------------------------------------------------------------------------*/
  ds_3gpp_iface_p = (ds_3gpp_iface_s*)(if_ptr->client_data_ptr);
  ASSERT (ds_3gpp_iface_p != NULL);

  DS_3GPP_MSG2_LOW("Iface [0x%x:%x]", if_ptr->name, if_ptr->instance);
   
  if (ds_3gpp_nv_manager_get_multi_pdn_same_apn(resolved_subs_id) == TRUE) 
  {
    if (PS_IFACE_IS_IN_USE(if_ptr)) 
    {
      DS_3GPP_MSG0_HIGH("Iface is in use");
      if((policy_info_ptr->bring_up == 0) && (policy_info_ptr->lookup_only == 0))
      {
        DS_3GPP_MSG0_HIGH("Allow Data path call bringup");
      }
      else
      {
        *reason_for_deny = ACL_DENY_REASON_IFACE_IN_USE;
        DS_3GPP_MSG2_HIGH("Deny, Iface [0x%x:%x]",
                               if_ptr->name,if_ptr->instance);
        return FALSE;
      }
    }
  }
  /*-------------------------------------------------------------------------
    The following rules determine if the cfg can be supported
    - if pdp profile number is 0 & incoming call is from laptop, ASSERT
    as this is not supposed to occur. Laptop always specifies a valid
    pdp profile
    - if policy is UP only don't check config, return TRUE
    - if profile number is '0', retrieve sockets call profile num from
      EFS
    - if profile number is out of range, return FALSE;
    - if interface is in use & profile number req is not same as current
      profile number on the interface, return FALSE, unless UP preferred
      is specified
    - if interface is in use & profile information (APN, PDP type and PDP addr)
      of req. profile number is not the same as information of the current
      profile number on the interface, return FALSE, unless UP preferred
      is specified
    - If iface is in use, check the profile definition to
      see if the parameters are valid
    - if interface is not in use but is looked_up & policy also specifies
      lookup then if the profile number req is not same as the current
      profile number on the interface, return FALSE
    - if interface is not in use but is looked_up & policy also specifies
      lookup, then if profile information of the req. profile number is not
      the same as information of the current profile number of the interface,
      return FALSE, unless UP preferred is specified
  -------------------------------------------------------------------------*/

  /* get the profile pointer passed  if any */
  pdp_profile_num = ds_3gpp_rt_acl_get_profile_num_from_policy(policy_info_ptr);

  if(ds_3gpp_profile_cache_get_cache_index((pdp_profile_num & 0x000000FF),
           dsumts_subs_mgr_get_subs_id_from_policy_subs_id(policy_info_ptr->subs_id)) == -1)
  {
    DS_3GPP_MSG1_ERROR("Invalid pdp prof number:%d",pdp_profile_num);
    *reason_for_deny = ACL_DENY_REASON_INVALID_PROFILE_ID;
    return FALSE;
  }

#ifdef FEATURE_DATA_PS_IPV6
  
  result = (ds_umts_pdp_profile_status_etype)
         ds_umts_get_pdp_profile_all_data_per_subs((uint16)pdp_profile_num, 
                  dsumts_subs_mgr_get_subs_id_from_policy_subs_id(policy_info_ptr->subs_id), 
                                          &profile_info);
  if( result != DS_UMTS_PDP_SUCCESS )
  {
    DS_3GPP_MSG2_ERROR("Error %d in retrieving profile info:%d",
                       result,pdp_profile_num);
    *reason_for_deny = ACL_DENY_REASON_INVALID_PROFILE;
    return FALSE;
  } 


  if( (is_emergency_auth_fail) &&
      (FALSE == profile_info.emergency_calls_are_supported) )
  {
    DS_3GPP_MSG0_ERROR("Authentication failure on Emergency call ,no Non Emergency calls"
                       "allowed till Emergency call ends");
    *reason_for_deny = ACL_DENY_REASON_EMERGENCY_AUTH_FAILURE;
    return FALSE;
  }

  if (TRUE == profile_info.emergency_calls_are_supported)
  {
    DS_3GPP_MSG1_ERROR("Profile %d is for making emergency calls. Deny non-emergency IFace",
                       pdp_profile_num);
    *reason_for_deny = ACL_DENY_REASON_EMERGENCY_IFACE_ONLY;
    return FALSE;
  }

  ds3gpp_enter_global_crit_section();
  roaming_status = ds_3gpp_roaming_get_status(resolved_subs_id);
  ds3gpp_leave_global_crit_section();
  
  if (roaming_status == TRUE)
  {
    if (profile_info.roaming_disallowed)
    { 
      DS_3GPP_MSG1_ERROR("Profile %d is not allowed while on roaming",
                         pdp_profile_num);
      *reason_for_deny = ACL_DENY_REASON_APN_DISALLOWED_ON_ROAMING;
      return FALSE;
    }
  }

  cur_nw_mode = ds3g_get_current_network_mode_ex(resolved_subs_id);

/*-----------------------------------------------------------------------
    Update the PDP type in PDN context in following scenarios
    If UE is in Roaming and roaming PDP type is configured or
    If UE is in Home and Home override PDP type is configured
    Note: Use Roaming status cached in rt_acl during first iface for all
    subsequent ifaces so that we use the same roaming status throughout
    routing & postproc.
  -----------------------------------------------------------------------*/
  if( DS_3GPP_IS_3GPP_CURRENT_MODE(cur_nw_mode) )
  {
    pdp_type_to_use = ds_3gpp_pdn_context_determine_pdp_type(
                        resolved_subs_id,
                        &profile_info.context,
                        roaming_status);
    profile_info.context.pdp_type = pdp_type_to_use;
  }

  call_type_originate = ds3gpp_determine_call_type_to_be_originated(
                           &profile_info.context, policy_info_ptr);

  /*-------------------------------------------------------------------------
    If call type is IPV6 Check that IPv6 NV item is valid 
  -------------------------------------------------------------------------*/
  if( ( call_type_originate == DS_3GPP_PDP_TYPE_IPV6 ) &&
      ( !ds3g_is_ipv6_enabled() ) )
  {
    DS_3GPP_MSG1_ERROR( "DS3GPP_RT_ACL: FAIL CALL, IPv6 NV not set,"
                        " req ip family [%d]!",policy_info_ptr->ip_family);
    *reason_for_deny = ACL_DENY_REASON_V6_DISABLED;
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    Fail the call since type of call to be originated could not be determined
    Should we fail the call here or should we do it in Mode handler. If
    failing it in Mode Handler is more efficient, let the call go through.
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(call_type_originate == DS_3GPP_PDP_TYPE_FAIL)
  {
    *reason_for_deny = ACL_DENY_REASON_IP_VERSION_MISMATCH;
    return FALSE;
  }

  /*-------------------------------------------------------------------- 
    APN requested is populated from profile
    --------------------------------------------------------------------*/
  (void) strlcpy((char *) apn_requested, 
                 (char *) profile_info.context.apn,
                 DS_UMTS_MAX_APN_STRING_LEN+1); 
 /*-----------------------------------------------------------------------
    APN written from the profile is overwritten if policy info ptr's
    apn is not NULL
  -----------------------------------------------------------------------*/
  if ((policy_info_ptr->apn.length != 0) && 
      (policy_info_ptr->apn.length <= DS_UMTS_MAX_APN_STRING_LEN))
  {
    (void) strlcpy((char *) apn_requested, 
                   (char *) policy_info_ptr->apn.name,
		   (policy_info_ptr->apn.length)+1);    
  }
#ifdef FEATURE_DATA_LTE
  /*---------------------------------------------------------------------------
    If apn is not overridden in the policy and if apn in the profile is NULL,
    try to see if there exists a resolved apn in the attach SM, 
    If it does then override the apn_req with this resolved apn. 
    NULL Apn will always go out as resolved apn of attach SM.
  ---------------------------------------------------------------------------*/
  else if((policy_info_ptr->apn.length == 0) &&
          (profile_info.context.apn[0] == '\0'))
  {
    if(ds_eps_pdn_cntxt_get_resolved_apn_per_attach_sm(
                                         apn_requested,
                                         resolved_subs_id))
    {
       DATA_3GPP_MSG_SPRINTF_1(MSG_LEGACY_HIGH, 
                    "Resolved APN in Attach SM is %s",
                     apn_requested);

    }
  }
#endif /* FEATURE_DATA_LTE */

  if (ds3g_profile_validate_apn_name((char*)apn_requested, 
                strlen((char*)apn_requested)) == FALSE) 
  {
     *reason_for_deny = ACL_DENY_REASON_APN_FORMAT_INVALID;
     DS_3GPP_MSG0_HIGH("policy apn format is invalid");
     return FALSE;
  }

  /*-----------------------------------------------------------------------
    Check if UI Data is Disabled 
  -----------------------------------------------------------------------*/
  if (!ds3gpp_device_ev_hdlr_is_apn_allowed
        ((char*)apn_requested, resolved_subs_id, &down_reason))
  {
    if (down_reason == PS_NET_DOWN_REASON_DATA_SETTINGS_DISABLED)
    {
      *reason_for_deny = ACL_DENY_REASON_DATA_SETTING_DISABLED;
    }
    else if (down_reason == PS_NET_DOWN_REASON_DATA_ROAMING_SETTINGS_DISABLED)
    {
      *reason_for_deny = ACL_DENY_REASON_DATA_ROAMING_SETTING_DISABLED;
    }
    else
    {
      *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
    }

    DS_3GPP_MSG1_ERROR("Profile %d is disallowed due to UI setting",
                       pdp_profile_num);

    return FALSE;
  }

  if(0 == (uint32)policy_info_ptr->pdp_info)
  {
     DS_3GPP_MSG3_HIGH("Profile number used %d and apn requested is %s ",
                       pdp_profile_num,
                       profile_info.context.apn,0);
  }
  /*-----------------------------------------------------------------------
    Check if the APN supports the IP type of this iface  
  -----------------------------------------------------------------------*/
  ds3gpp_enter_global_crit_section();

  if ((ds_pdn_cntxt_get_apn_ip_support_info(apn_requested, &ip_support,resolved_subs_id) 
                      == TRUE) &&
      (ds_pdn_cntxt_is_pdn_associated_for_apn(apn_requested,resolved_subs_id) == TRUE)
      )
  { 

  DS_3GPP_MSG1_MED("Found an entry in apn table. IP Support: %d",ip_support);
  /*--------------------------------------------------------------------------
  If we have the multi_pdn_same_apn NV set, we must allow initiating new
  pdn context to same APN and NOT share an existing iface even if it
  is in a connection to APN of interest.
  Hence below logic is applicable only if NV is NOT set
  --------------------------------------------------------------------------*/
  if (ds_3gpp_nv_manager_get_multi_pdn_same_apn(resolved_subs_id) == FALSE) 
  {
    /*----------------------------------------------------------------------
      There is an entry in the APN already. We can pass this iface under the
      following cases:
        - This iface is already bound to a PDN context that has a dual IP
          bearer pipe.
        - The iface is not bound to any PDN but there is already a PDN cntx
          with a pipe of the other IP type. In this case, we will allocate
          a new PDN context in the post processing part.
    ----------------------------------------------------------------------*/
    switch(ip_support)
    {
      case DS_IPV4V6:
      {      
        /*--------------------------------------------------------------------
          This is the case where a PDN context with dual IP bearer pipe exists
          Ensure that it is this iface that belongs to the PDN context. If
          not, return FALSE
        --------------------------------------------------------------------*/
        if(ds_pdn_cntxt_get_v4_pdn_context(apn_requested, &pdn_cntx_p,resolved_subs_id)
             != DS3G_SUCCESS)
        {
          //We came into this switch because we found the APN name in the table
          ASSERT(0);
        }
        else
        {
          if(ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p) == FALSE)
          {
            ASSERT(0);
            ds3gpp_leave_global_crit_section();
            return FALSE;
          }
          /*--------------------------------------------------------------------
            Ensure that the iface under question is one of the ifaces in the PDN
            context
          --------------------------------------------------------------------*/
          if(if_ptr != 
             &(pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
               [DS_3GPP_PDN_CONTEXT_IPV4_IFACE]->ps_iface)
             &&
             if_ptr != 
             &(pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
               [DS_3GPP_PDN_CONTEXT_IPV6_IFACE]->ps_iface))
          {
            /*------------------------------------------------------------------
              "this" Iface is not a part of PDN that has a dual IP pipe established.
              There is another Iface.
            ------------------------------------------------------------------*/
            *reason_for_deny = ACL_DENY_REASON_IFACE_MISMATCH;

            /*------------------------------------------------------------------
              Iface is not a part of PDN that has a dual IP pipe established.
              Fail this Iface
            ------------------------------------------------------------------*/
            ds3gpp_leave_global_crit_section();
            return FALSE;
          } /* Iface part of PDN? */
          else
          {
            /*--------------------------------------------------------------------
              Iface on which this function was called is a part of the PDN context
              which has a Dual IP bearer connection established to the APN of interest
            --------------------------------------------------------------------*/

            /*------------------------------------------------------------------
              Iface under consideration belongs to the PDN context. Make sure 
              that the IP type of the iface under consideration matches with the
              call type to originate
            ------------------------------------------------------------------*/
            if(ds_pdn_cntxt_check_iface_type_matches(if_ptr, call_type_originate)!=TRUE)
            {
            
              /* V4V6 call -> althought V4V6 mismatch we cannot , incase of dual IP V4 V6 ,the first iface is already in use.
               * Hence technically for Dual IP PDN V4 ,if we check orig_call = V6  , we can fail as IP_version mismatch
               */
              *reason_for_deny = get_deny_reason_code_by_iface_type( 
                                     if_ptr,
                                     ACL_DENY_REASON_IP_VERSION_MISMATCH );
              ds3gpp_leave_global_crit_section();
              return FALSE;
            }
            *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
          }
        }/* APN name found in table */
      }
      break;

      case DS_SINGLE_BEARER:
      {
        /*--------------------------------------------------------------------
          This is the case where a PDN context with single IP bearer pipe 
          exists. The following cases are possible

          - Iface is bound to one of the exiting PDN
            - In this case, ensure that the call type to orig is the same as
              the Iface type. If not, deny this Iface
          - Iface is not bound to an existing PDN. Ensure that we can pass this
            iface so as to request a PDN of the new IP type. If not, deny
        --------------------------------------------------------------------*/
        switch(call_type_originate)
        {
          case DS_3GPP_PDP_TYPE_PPP:
          case DS_3GPP_PDP_TYPE_IPV4:
            /*----------------------------------------------------------------
              We have to examine if there is a V4 PDN context existing already
              If it does, we have to ensure that the Iface under consideration
              if associated with the V4 PDN. If not, deny iface
            ----------------------------------------------------------------*/
            if(ds_pdn_cntxt_get_v4_pdn_context(apn_requested, &pdn_cntx_p,resolved_subs_id)
                                                             != DS3G_SUCCESS)
            {
            //We came into the outer switch because we found the APN name in 
            // the table
              ASSERT(0);
            }
            else if(pdn_cntx_p != NULL)
            {
              if(if_ptr != 
                 &(pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                   [DS_3GPP_PDN_CONTEXT_IPV4_IFACE]\
                   ->ps_iface))
              {
                /*--------------------------------------------------------------
                  "this" iface is not the one bound to the PDN context. Therefore
                  there is another Iface that is in a connection to the APN
                  of interest.
                --------------------------------------------------------------*/
                *reason_for_deny = ACL_DENY_REASON_IFACE_MISMATCH; 
                /*--------------------------------------------------------------
                  This iface is not bound to the existing V4 PDN. Deny it
                --------------------------------------------------------------*/
                ds3gpp_leave_global_crit_section();
                return FALSE;
              }
            } /* V4 PDN context exists*/
            else
            {
              /*----------------------------------------------------------------
                We do not have a V4 PDN context. This means there is no other
                Iface of the same IP type as "this" Iface connected to the APN
                of interest. set reason for deny accordingly
              ----------------------------------------------------------------*/


              /*----------------------------------------------------------------
                V4 PDN context does not exist. Make sure that this iface is not
                already bound to a PDN context. This can especially happen with
                the default ifaces since they are always bound to the default 
                PDN context. If the iface is bound to a PDN context, deny it.

                Else, do the following:
                Set flag pdp_type_to_be_changed so that we set the PDP type in 
                PDN context accordingly in post processing. This is because we 
                should not request a dual IP bearer while connecting to PDN
              ----------------------------------------------------------------*/
              if(DSPDNCNTX_GET_PDN_FROM_IFACE(if_ptr) != 0)
              {
                /*--------------------------------------------------------------
                  Deny the iface since it is bound to a PDN context
                --------------------------------------------------------------*/
                *reason_for_deny = get_deny_reason_code_by_cfg( if_ptr, 
                                                                policy_info_ptr );
                DS_3GPP_MSG0_HIGH("Req v4 iface already bound to a PDN");
                ds3gpp_leave_global_crit_section();
                return FALSE;
              }
              else
              {
                *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
                if(policy_info_ptr->bring_up == TRUE)
                {
                  ds_3gpp_rt_acl_set_pdp_type_to_be_changed(TRUE);
                }
              }
            }
            break;

          case DS_3GPP_PDP_TYPE_IPV6:
            /*----------------------------------------------------------------
              We have to examine if there is a V6 PDN context existing already
              If it does, we have to ensure that the Iface under consideration
              if associated with the V6 PDN. If not, deny iface
            ----------------------------------------------------------------*/
            if(ds_pdn_cntxt_get_v6_pdn_context(apn_requested, &pdn_cntx_p,resolved_subs_id)
                                                             != DS3G_SUCCESS)
            {
            //We came into the outer switch because we found the APN name in 
            // the table
              ASSERT(0);
            }
            else if(pdn_cntx_p != NULL)
            {
              if(if_ptr != 
                 &(pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                   [DS_3GPP_PDN_CONTEXT_IPV6_IFACE]\
                   ->ps_iface))
              {
                /*--------------------------------------------------------------
                  "this" iface is not the one bound to the PDN context. Therefore
                  there is another Iface that is in a connection to the APN
                  of interest.
                --------------------------------------------------------------*/
                *reason_for_deny = ACL_DENY_REASON_IFACE_MISMATCH; 
                /*--------------------------------------------------------------
                  This iface is not bound to the existing V6 PDN. Deny it
                --------------------------------------------------------------*/
                ds3gpp_leave_global_crit_section();
                return FALSE;
              }
            }/* V6 PDN context exists */
            else
            {
              /*----------------------------------------------------------------
                We do not have a V6 PDN context. This means there is no other
                Iface of the same IP type "this" Iface connected to the APN of
                interest. set deny reason accordingly.
              ----------------------------------------------------------------*/

              /*----------------------------------------------------------------
                V6 PDN context does not exist. Make sure that this iface is not
                already bound to a PDN context. This can especially happen with
                the default ifaces since they are always bound to the default 
                PDN context. If the iface is bound to a PDN context, deny it.

                Else, do the following:
                Set flag pdp_type_to_be_changed so that we set the PDP type in 
                PDN context accordingly in post processing. This is because we 
                should not request a dual IP bearer while connecting to PDN
              ----------------------------------------------------------------*/
              if(DSPDNCNTX_GET_PDN_FROM_IFACE(if_ptr) != 0)
              {
                /*--------------------------------------------------------------
                  Deny the iface since it is bound to a PDN context
                --------------------------------------------------------------*/
                DS_3GPP_MSG0_HIGH("Req V6 iface already bound to a PDN");
                *reason_for_deny = get_deny_reason_code_by_cfg( if_ptr,
                                                                policy_info_ptr );
                ds3gpp_leave_global_crit_section();
                return FALSE;
              }
              else
              {
                *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
                if(policy_info_ptr->bring_up == TRUE)
                {
                  ds_3gpp_rt_acl_set_pdp_type_to_be_changed(TRUE);
                }
              }
            }
            break;

          case DS_3GPP_PDP_TYPE_IP_ANY:
            /*------------------------------------------------------------------
              This is a case where the call can be of any IP type. Since the
              call can be any IP type, we must ensure that we return the Iface
              that is already bound to the PDN.
              In other words, if there is/are one/two Single bearer PDN cntxt
              existing, we should not pass an Iface that is not bound to either
            ------------------------------------------------------------------*/

            /*----------------------------------------------------------------
              We have to examine if there is a V4 PDN context existing already
              If it does, we have to ensure that the Iface under consideration
              if associated with the V4 PDN. If not, deny iface
            ----------------------------------------------------------------*/
            if(ds_pdn_cntxt_get_v4_pdn_context(apn_requested, &pdn_cntx_p,resolved_subs_id)
                                                             != DS3G_SUCCESS)
            {
            //We came into the outer switch because we found the APN name in 
            // the table
              ASSERT(0);
            }
            else if(pdn_cntx_p != NULL)
            {
              if(if_ptr == 
                 &(pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                   [DS_3GPP_PDN_CONTEXT_IPV4_IFACE]\
                   ->ps_iface))
              {
                /*--------------------------------------------------------------
                  This is the Iface that is in a connection to the APN
                --------------------------------------------------------------*/
                *reason_for_deny = get_deny_reason_code_by_iface_type( 
                                     if_ptr, 
                                     ACL_DENY_REASON_IFACE_IN_USE_CFG_MATCH );

                /*--------------------------------------------------------------
                  Break from the inner switch.
                  This iface will pass if the subsequent checks pass 
                --------------------------------------------------------------*/
                break;
              }
            } /* V4 PDN context exists*/

            /*----------------------------------------------------------------
              We have to examine if there is a V6 PDN context existing already
              If it does, we have to ensure that the Iface under consideration
              if associated with the V6 PDN. If not, deny iface
            ----------------------------------------------------------------*/
            if(ds_pdn_cntxt_get_v6_pdn_context(apn_requested, &pdn_cntx_p,resolved_subs_id)
                                                             != DS3G_SUCCESS)
            {
            //We came into the outer switch because we found the APN name in 
            // the table
              ASSERT(0);
            }
            else if(pdn_cntx_p != NULL)
            {
              if(if_ptr == 
                 &(pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                   [DS_3GPP_PDN_CONTEXT_IPV6_IFACE]\
                   ->ps_iface))
              {
                /*--------------------------------------------------------------
                  This is the Iface that is in a connection to the APN
                --------------------------------------------------------------*/
                *reason_for_deny = get_deny_reason_code_by_iface_type( 
                                     if_ptr, 
                                     ACL_DENY_REASON_IFACE_IN_USE_CFG_MATCH );

                /*--------------------------------------------------------------
                  Break from the inner switch.
                  This iface will pass if the subsequent checks pass 
                --------------------------------------------------------------*/
                break;
              }
            } /* V6 PDN context exists*/

            /*----------------------------------------------------------------
              If we are here, it means that "this" Iface does not belong to
              any existing single IP bearer PDN context. So there is another
              Iface of the desired IP type in a connection to the APN.
            ----------------------------------------------------------------*/
            *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;

            /*----------------------------------------------------------------
              If we are here, it means that the iface under consideration does
              not belong to any existing single IP bearer PDN context.DENY
            ----------------------------------------------------------------*/
            ds3gpp_leave_global_crit_section();
            return FALSE;
          default:
            DS_3GPP_MSG1_HIGH("Call type to orig invalid. Call_type: %d", 
                       call_type_originate);
            ASSERT(0);
            break;
        }/* Switch call type to orig */
      }/* DS_SINGLE_BEARER */
        break;

      case DS_IPV4_ONLY:
      {
        /*--------------------------------------------------------------------
          This is a case where we know that the APN suport is for V4 only.
          If the call_type_to_orig is V6, deny Iface

          If the call type is V4, ensure that we pass only the Iface that is
          bound to the PDN context
        --------------------------------------------------------------------*/
        if(call_type_originate == DS_3GPP_PDP_TYPE_IPV4 ||
           call_type_originate == DS_3GPP_PDP_TYPE_PPP ||
           call_type_originate == DS_3GPP_PDP_TYPE_IP_ANY)
        {
          /*----------------------------------------------------------------
            We have to examine if there is a V4 PDN context existing already
            If it does, we have to ensure that the Iface under consideration
            if associated with the V4 PDN. If not, deny iface
          ----------------------------------------------------------------*/
          if(ds_pdn_cntxt_get_v4_pdn_context(apn_requested, &pdn_cntx_p,resolved_subs_id)
                                                             != DS3G_SUCCESS)
          {
          /* We came into the outer switch because we found the APN name 
           * in the table 
           */
            DATA_ERR_FATAL("No V4 iface not bound this PDN");
          }
          else if(pdn_cntx_p != NULL)
          {
            if(if_ptr != 
               &(pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                 [DS_3GPP_PDN_CONTEXT_IPV4_IFACE]\
                 ->ps_iface))
            {
              /*----------------------------------------------------------------
                There is another Iface of the desired IP type in a connection
                to the APN.
              ----------------------------------------------------------------*/
              *reason_for_deny = ACL_DENY_REASON_IFACE_MISMATCH;
              ds3gpp_leave_global_crit_section();
              return FALSE;
            }
            else
            {
              *reason_for_deny = get_deny_reason_code_by_iface_type( 
                                   if_ptr, 
                                   ACL_DENY_REASON_IFACE_IN_USE_CFG_MATCH );
            }
          } /* V4 PDN context exists*/
          else
          {
            DATA_ERR_FATAL("Could not locate V4 PDN context");
          }
        }
        else if(call_type_originate == DS_3GPP_PDP_TYPE_IPV6)
        {
          /*--------------------------------------------------------------
            No iface of the desired IP type is in a connection to the APN.
          --------------------------------------------------------------*/
          *reason_for_deny = ACL_DENY_REASON_V6_DISALLOWED_SUBS_LIMITED;  
          ds3gpp_leave_global_crit_section();
          return FALSE;
        }
      }//DS_IPV4_ONLY
        break;

      case DS_IPV6_ONLY:
      {
        /*--------------------------------------------------------------------
          This is a case where we know that the APN suport is for V6 only.
          If the call_type_to_orig is V4/PPP, deny Iface

          If the call type is V6, ensure that we pass only the Iface that is
          bound to the PDN context
        ---------------------------------------------------------------------*/
        if(call_type_originate == DS_3GPP_PDP_TYPE_IPV4 ||
           call_type_originate == DS_3GPP_PDP_TYPE_PPP )
        {
          /*----------------------------------------------------------------
            No iface of the desired IP type is in a connection to the APN.
          ----------------------------------------------------------------*/
          *reason_for_deny = ACL_DENY_REASON_V4_DISALLOWED_SUBS_LIMITED; 
          ds3gpp_leave_global_crit_section();
          return FALSE; 
        }
        else if(call_type_originate == DS_3GPP_PDP_TYPE_IPV6 ||
                call_type_originate == DS_3GPP_PDP_TYPE_IP_ANY)
        {
          /*----------------------------------------------------------------
            We have to examine if there is a V6 PDN context existing already
            If it does, we have to ensure that the Iface under consideration
            if associated with the V6 PDN. If not, deny iface
          ----------------------------------------------------------------*/
          if(ds_pdn_cntxt_get_v6_pdn_context(apn_requested, &pdn_cntx_p,resolved_subs_id)
                                                             != DS3G_SUCCESS)
          {
          //We came into the outer switch because we found the APN name in 
          // the table
            ASSERT(0);
          }
          else if(pdn_cntx_p != NULL)
          {
            if(if_ptr != 
               &(pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                 [DS_3GPP_PDN_CONTEXT_IPV6_IFACE]\
                 ->ps_iface))
            {
              *reason_for_deny = ACL_DENY_REASON_IFACE_MISMATCH;  
              ds3gpp_leave_global_crit_section();
              return FALSE;
            }
            else
            {
              *reason_for_deny = get_deny_reason_code_by_iface_type( 
                                   if_ptr, 
                                   ACL_DENY_REASON_IFACE_IN_USE_CFG_MATCH );
               DS_3GPP_MSG0_HIGH("Could not locate V6 PDN context");
            }
          } /* V6 PDN context exists*/
          else
          {
            DATA_ERR_FATAL("Could not locate V6 PDN context");
          }
        }
      }//DS_IPV6_ONLY
        break;

      default:
        DS_3GPP_MSG1_HIGH("IP support type of the APN is :%d. Asserting",ip_support);
        ASSERT(0);
        break;

    }/* Switch ip_support of APN */
  } /*  (ds_3gpp_allow_multi_pdn_same_apn == FALSE )*/

    /*
    If the "multi pdn same apn" flag is set as TRUE and dynamic PDN /iface binding
    is not being used , routing should fail for an iface whose companion iface
    (bound to the same PDN) is down / not in use.
    This doesnot apply for dualip bearer scenarios, in which case an APP should
    still be able to use the iface.
    */
    else if (ds_3gpp_nv_manager_get_multi_pdn_same_apn(resolved_subs_id) == TRUE)
    {
      pdn_cntx_p = (ds_pdn_context_s*)(ds_3gpp_iface_p->client_data_ptr);
      if (pdn_cntx_p == NULL) 
      {
        DS_3GPP_MSG1_MED("PDN Context is NULL for iface 0x%x", 
                           ds_3gpp_iface_p);  

      } 
      else
      {
        ds_pdn_cntxt_get_ip_support_info_for_pdn(pdn_cntx_p,&ip_support);
        DS_3GPP_MSG2_MED("IP support for PDN 0x%x is set as %d",
                           pdn_cntx_p, ip_support);

        switch (ip_support)
        {
          case DS_SINGLE_BEARER:
          case DS_IPV4_ONLY:
          case DS_IPV6_ONLY:
          case DS_IPV4_SINGLE_BEARER:
          case DS_IPV6_SINGLE_BEARER:
          {
            if(ps_iface_addr_family_is_v6(if_ptr))
            {
              iface_index = DS_3GPP_PDN_CONTEXT_IPV4_IFACE;
            }
            else if(ps_iface_addr_family_is_v4(if_ptr))
            {
              iface_index = DS_3GPP_PDN_CONTEXT_IPV6_IFACE;
            }
            else
            {
              DS_3GPP_MSG0_ERROR("Address family not set");
              *reason_for_deny = ACL_DENY_REASON_IP_VERSION_MISMATCH; 
              ds3gpp_leave_global_crit_section();
              return FALSE;
            } 
          
            if (pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[iface_index] != NULL)
            {
              companion_if_ptr = &pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[iface_index]->ps_iface;

              // If the companion iface is not down or is in use, 
              // then we should deny this iface for the APP.
              if( (ps_iface_state(companion_if_ptr) != IFACE_DOWN) ||
                   PS_IFACE_IS_IN_USE(companion_if_ptr))
              {
                *reason_for_deny = ACL_DENY_REASON_COMPANION_IFACE_IN_USE; 
                DS_3GPP_MSG0_HIGH("Requested iface is bound to a "
                                   "PDN already being used");
                 ds3gpp_leave_global_crit_section();
                 return FALSE;
              }
            }

            else
            {
              DS_3GPP_MSG0_MED("Companion iface is null");
            } 

            break;
          }
		  /*------------------------------------------------------------------------------ 
           When Multi PDN same APN is enabled, Calls originated with different RMNET inst
           have to be rejected, Only exception is when RMnet instance numbers are INVALID
           (DUN and Modem calls)
          ------------------------------------------------------------------------------*/
           case DS_IPV4V6:

             if(ps_iface_addr_family_is_v6(if_ptr))
             {
               iface_index = DS_3GPP_PDN_CONTEXT_IPV4_IFACE;
             }
             else if(ps_iface_addr_family_is_v4(if_ptr))
             {
               iface_index = DS_3GPP_PDN_CONTEXT_IPV6_IFACE;
             }

             if (pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[iface_index] != NULL)
             {

               companion_if_ptr = &pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                                  [iface_index]->ps_iface;

               if (companion_if_ptr == NULL)
               {
                 DS_3GPP_MSG0_ERROR("Comp iface ptr is NULL,Invalid scenario");
                 ds3gpp_leave_global_crit_section();
                 return FALSE;
               }

               comp_iface_rm_inst = PS_IFACE_GET_RM_INST_HANDLE(companion_if_ptr);

               DS_3GPP_MSG2_HIGH("COMP_RMNET_INST:%d,POLICY_RMNET_INST:%d",comp_iface_rm_inst,
                                 policy_info_ptr->rm_inst_handle);

               if((policy_info_ptr->rm_inst_handle != RM_INST_INVALID) &&
                  (comp_iface_rm_inst != RM_INST_INVALID) &&
                  (comp_iface_rm_inst != policy_info_ptr->rm_inst_handle))
               {

                 *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
                 DS_3GPP_MSG1_HIGH("Iface with RMNET_INST:%d already exists,"
                                   " Deny iface",comp_iface_rm_inst);
                 ds3gpp_leave_global_crit_section();
                 return FALSE;
               }
             }
             break;
          default:
            DS_3GPP_MSG0_MED("IP support is set as DS_IPV4V6");
            break;
			

        } /* switch (ip_support) */
      } /* PDN Cntxt ptr was not null*/
    } /*  (ds_3gpp_allow_multi_pdn_same_apn == TRUE )*/
  } /* APN entry present in the APN table and pdn exists */

  ds3gpp_leave_global_crit_section();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    Fail the call since iface is already up and iface type is different from
    what is being requested by application.
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( (PS_IFACE_IS_IN_USE(if_ptr)) && 
       DS3GPP_IFACE_IS_CALL_TYPE_MATCHED(if_ptr,call_type_originate ) == FALSE)
  {
    *reason_for_deny = get_deny_reason_code_by_iface_type( 
                         if_ptr, 
                         ACL_DENY_REASON_IP_VERSION_MISMATCH );

    /*-------------------------------------------------------------------------
      Another thing to do here is to reset the pdp_type_to_be_changed flag
      It is possible that we set this for this iface.
    -------------------------------------------------------------------------*/
    if(policy_info_ptr->bring_up == TRUE)
    {
      ds_3gpp_rt_acl_set_pdp_type_to_be_changed(FALSE);
    }
    DS_3GPP_MSG1_HIGH("PS Iface:0x%x in use and not sharable",if_ptr);
    return FALSE;
  }
#endif

  if( (ps_iface_state(if_ptr) != IFACE_DOWN) ||
      PS_IFACE_IS_IN_USE(if_ptr) ||
      ds_3gpp_iface_p->post_proc_done_flag == TRUE )
  {
    if (!PS_IFACE_IS_SUBS_ID_MATCH(if_ptr))
    {
      *reason_for_deny = ACL_DENY_REASON_IFACE_AND_POL_FAMILY_MISMATCH;
       DS_3GPP_MSG2_HIGH("Requested  Policy ps subs id: %d and "
                         "iface ps subs id: %d do not match", 
                         policy_info_ptr->subs_id, 
                         PS_IFACE_GET_SUBS_ID(if_ptr));
       return FALSE;
    }
  /*-------------------------------------------------------------------------
    If the iface is in use (it is either UP or going to be UP), make 
    sure that specified config matches with the config being used by the 
    iface, unless policy UP preferred is specified in which case its 
    acceptable to use the iface even if it is configured differently.
  -------------------------------------------------------------------------*/
    if(ds3gpp_compare_pdp_profile_info(if_ptr, 
                                       pdp_profile_num,
                                       policy_info_ptr,
                                       reason_for_deny) == FALSE)
    {
      if ( *reason_for_deny == ACL_DENY_REASON_POL_NO_MATCH)
      {
        if (policy_info_ptr->policy_flag != DSS_IFACE_POLICY_UP_SPEC)
        {
          ds_3gpp_rt_acl_set_pdp_type_to_be_changed(FALSE);
        }
        {
          DS_3GPP_MSG1_HIGH("Req profile:%d does not match iface profile",
                                                          pdp_profile_num);
          return FALSE;
        }
      }
      else
      {
        DS_3GPP_MSG1_HIGH(" Req profile:%d does not match iface profile",
                                                      *reason_for_deny);
        return FALSE;
      }
    }
    /*--------------------------------------------------------------------------
    If the multi_pdn_same_apn NV is set, we would not have done IP type check 
    anywhere prior to this point. So now, check if IP type matches.
    --------------------------------------------------------------------------*/
    if (ds_3gpp_nv_manager_get_multi_pdn_same_apn(resolved_subs_id) == TRUE) 
    {
      if (DS3GPP_IFACE_IS_CALL_TYPE_MATCHED(if_ptr,call_type_originate ) == FALSE)
      {
        DS_3GPP_MSG2_HIGH("PS Iface [0x%x:%x] is not shareable. IP type "
                          "does not match",if_ptr->name,if_ptr->instance);
        *reason_for_deny = ACL_DENY_REASON_IP_VERSION_MISMATCH;
        return FALSE;
      }
    }
  }
  return TRUE;

} /* ds3gpp_rt_is_cfg_supported2() */
/*===========================================================================
FUNCTION DS3GPP_ACL_IS_PREF_PKT_MODE

DESCRIPTION
  This function checks if the policy is set to prereg. If yes, then
  returns FALSE unconditionally. Else runs the pref mode check

PARAMETERS  
  *policy_info_ptr    - Policy information
   mode               - System mode

DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : If pref mode is GWL
  FALSE: If prereg flag is set
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
boolean ds3gpp_acl_is_pref_pkt_mode
( 
  acl_policy_info_type *policy_info_ptr,
  sys_sys_mode_e_type   mode 
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  if(policy_info_ptr == NULL)
  {
    DS_3GPP_MSG0_ERROR("NULL acl policy ptr");
    return FALSE;
  }

#ifdef FEATURE_DATA_OPTHO
  if ( policy_info_ptr->handoff_ctxt.handoff_class == 
                                    PS_IFACE_HANDOFF_CLASS_EPC_PREREG
     )
  {
    DS_3GPP_MSG0_HIGH("Policy Set to prereg. Fail pref class check.");
    return FALSE;
  }
  else
#endif /* FEATURE_DATA_OPTHO */
  {
    return ds3gpp_is_pref_pkt_sys_mode(policy_info_ptr, mode);
  }
} /* ds3gpp_acl_is_pref_pkt_mode */

/*===========================================================================
FUNCTION DS3GPP_IS_PDN_PREF_PKT_MODE

DESCRIPTION
  This function checks if a given mode is the pref pkt mode for the 3GPP PDN
  contained in the passed acl policy info.

PARAMETERS  
  *policy_info_ptr    - Policy information
   mode               - System mode

DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : If pref mode is GWL
  FALSE: If prereg flag is set
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
boolean ds3gpp_is_pref_pkt_sys_mode
( 
  acl_policy_info_type        *policy_info_ptr,
  sys_sys_mode_e_type          mode
)
{
  ds3g_apn_name_type                apn_name;
  ds_pkt_sys_mode_e_type            apn_pkt_mode;
  boolean                           ret_val = FALSE;
  sys_modem_as_id_e_type            resolved_subs_id = SYS_MODEM_AS_ID_NONE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

#ifdef FEATURE_DATA_WLAN_MAPCON
  /*----------------------------------------------------------------------------
    Get APN name for MAPCON. If MAPCON feature is not defined, passing a
    valid APN name ptr is enough, no need to handle the name get failure.
  ----------------------------------------------------------------------------*/
  if(ds3gpp_get_policy_apn_name(policy_info_ptr, &apn_name) == FALSE)
  {
    DS_3GPP_MSG0_ERROR( "ds3gpp_is_pref_pkt_sys_mode: failed to get APN ");
    return FALSE;
  }
#endif /*FEATURE_DATA_WLAN_MAPCON*/
  if( ds3g_resolve_subs_id(policy_info_ptr->subs_id ,&resolved_subs_id ) == FALSE) 
  {
    DS_3GPP_MSG1_ERROR("Error in obtaining resolved sub id. "
                       "Policy PS Sub ID is %d", policy_info_ptr->subs_id);
    return FALSE;
  }

  apn_pkt_mode = ds3g_sys_sys_mode_to_ds_apn_sys_mode(mode);
  ret_val = ds3g_is_apn_pref_pkt_mode_ex(apn_pkt_mode, &apn_name, resolved_subs_id);
  if(ret_val)
  {
    DS_3GPP_MSG2_MED( "ds3gpp_is_pref_pkt_sys_mode: mode %d - pref: %d ",
                    apn_pkt_mode,ret_val);
  }
  return ret_val;

} /*ds3gpp_is_pref_pkt_sys_mode*/

/*===========================================================================
FUNCTION DS3GPP_GET_POLICY_APN_NAME

DESCRIPTION
  This function gets APN name from the given acl policy.

PARAMETERS  
  *policy_info_ptr    - Policy information
  *apn_name_ptr       - ptr to the apn name holder for output

DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : APN name is successfully retrieved
  FALSE: Failed to get APN name
  
SIDE EFFECTS 
  None.
 ===========================================================================*/
boolean ds3gpp_get_policy_apn_name
( 
  acl_policy_info_type       *policy_info_ptr,
  ds3g_apn_name_type         *apn_name_ptr
)
{
  uint32                         pdp_profile_num= 0;
#ifdef FEATURE_DATA_LTE
  sys_modem_as_id_e_type  resolved_subs_id = SYS_MODEM_AS_ID_NONE;
#endif /* FEATURE_DATA_LTE */

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if((policy_info_ptr == NULL) || (apn_name_ptr == NULL))
  {
    DS_3GPP_MSG2_ERROR("policy_info_ptr:0x%x,apn_name_ptr:0x%x",
                       policy_info_ptr,
                       apn_name_ptr);
    return FALSE;
  }

  /*-----------------------------------------------------------------------
    Check if any profile parameters have been overridded by user. We 
    support APN override at present.
  -----------------------------------------------------------------------*/
  memset (apn_name_ptr, 0, sizeof(ds3g_apn_name_type));

  if ( policy_info_ptr->apn.length != 0 &&
       strlen((char *)policy_info_ptr->apn.name) != 0 )
  {
    /*-------------------------------------------------------------------------
      initialize APN name first before loading to it
    -------------------------------------------------------------------------*/
    apn_name_ptr->apn_string_len = strlen((char *)policy_info_ptr->apn.name);

    if( apn_name_ptr->apn_string_len < DS_SYS_MAX_APN_LEN )
    {
      strlcpy(apn_name_ptr->apn_string,
              (char *)policy_info_ptr->apn.name,
              apn_name_ptr->apn_string_len+1);
    }
    else
    {
      DS_3GPP_MSG1_ERROR("Invalid length of APN in policy info: %d",
                                   policy_info_ptr->apn.length);

      return FALSE;
    }
  }
  else
  {
    pdp_profile_num = ds_3gpp_rt_acl_get_profile_num_from_policy(policy_info_ptr);
               
    if(ds_3gpp_profile_cache_get_cache_index((pdp_profile_num & 0x000000FF),
             dsumts_subs_mgr_get_subs_id_from_policy_subs_id(policy_info_ptr->subs_id)) == -1)
    {
      DS_3GPP_MSG1_ERROR("Invalid pdp prof number:%d",pdp_profile_num);
      return FALSE;
    }

    if (ds3gpp_get_profile_apn_name(pdp_profile_num, policy_info_ptr->subs_id, apn_name_ptr) == FALSE)
    {
      DS_3GPP_MSG1_ERROR("Could not obtain apn name for profile num %d",
                                   pdp_profile_num);
      return FALSE;
    }
  }
#ifdef FEATURE_DATA_LTE
  if( ds3g_resolve_subs_id(policy_info_ptr->subs_id ,&resolved_subs_id )
        == FALSE )
  {
    DS_3GPP_MSG1_ERROR("Error in obtaining resolved sub id. "
                       "Policy PS Sub ID is %d",
                       policy_info_ptr->subs_id);
    return FALSE;
  }
  /*---------------------------------------------------------------------------- 
    At this point check to see if apn string is NULL and if resolved apn is
    populated in attach SM, populate the apn string with resolved apn
  ----------------------------------------------------------------------------*/
  if (apn_name_ptr->apn_string[0] == '\0')
  {
    if(ds_eps_pdn_cntxt_get_resolved_apn_per_attach_sm(
                                           (byte *)apn_name_ptr->apn_string,
                                           resolved_subs_id))
    {
      apn_name_ptr->apn_string_len = strlen((char *)(apn_name_ptr->apn_string));

    }
  }
#endif /* FEATURE_DATA_LTE */

  return TRUE; 
} 
/*===========================================================================
FUNCTION DS3GPP_GET_PROFILE_APN_NAME

DESCRIPTION
  This function gets the APN name for the 3GPP profile in the passed acl
  policy.

PARAMETERS  
  pdp_profile_num     - 3gpp profile id
  *apn_name_ptr       - ptr to the apn name holder for output

DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : APN name is successfully retrieved
  FALSE: Failed to get APN name
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
boolean ds3gpp_get_profile_apn_name
( 
  uint32                       pdp_profile_num,
  uint32                       subs_id,
  ds3g_apn_name_type         * apn_name_ptr
)
{
  ds_umts_pdp_profile_type         profile_info;
  ds_umts_pdp_profile_status_etype result;     
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  if (apn_name_ptr == NULL)
  {
    DS_3GPP_MSG0_ERROR("ds3gpp_rt_acl_get_apn_name: NULL apn_name_ptr");
    return FALSE;
  }

  result = ds_umts_get_pdp_profile_all_data_per_subs((uint16)pdp_profile_num, 
                             dsumts_subs_mgr_get_subs_id_from_policy_subs_id(subs_id),
                                            &profile_info); 
  if( result != DS_UMTS_PDP_SUCCESS )
  {
    DS_3GPP_MSG2_ERROR("Error %d in retrieving APN name for 3gpp profile:%d",
                       result,pdp_profile_num);
    return FALSE;
  }

  /*-------------------------------------------------------------------------
    initialize APN name first before loading to it
  -------------------------------------------------------------------------*/
  memset (apn_name_ptr, 0, sizeof(ds3g_apn_name_type));
  apn_name_ptr->apn_string_len = (uint32)strlen((char *)profile_info.context.apn);

  if(apn_name_ptr->apn_string_len >= DS_SYS_MAX_APN_LEN ) 
  {
    return FALSE;
  }
    strlcpy(apn_name_ptr->apn_string,
            (char *)profile_info.context.apn,
            apn_name_ptr->apn_string_len+1);
  return TRUE;
} /* ds3gpp_get_profile_apn_name */

/*===========================================================================
FUNCTION DS_3GPP_RT_ACL_GET_PROFILE_NUM_FROM_POLICY

DESCRIPTION
   This function get sthe profile number from the Policy information passed by
   Client Application. If the profile number is 0, it returns the default socket or 
   tethered profile number based on the type of client (tethered or embedded) 
   performing route lookup/bringup.
  
PARAMETERS  
  *policy_info_ptr    - Policy information
    
DEPENDENCIES 
  None.
  
RETURN VALUE 
  Profile number
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
static uint32 ds_3gpp_rt_acl_get_profile_num_from_policy
(
  acl_policy_info_type *policy_info_ptr
)
{
  uint32   pdp_profile_num = 0;
  byte  socks_def_prof_num=0;
  byte  rmnet_def_prof_num=0;
  ds_umts_pdp_profile_status_etype result;     

  if (policy_info_ptr == NULL) 
  {
     DS_3GPP_MSG0_ERROR("Policy info pointer is null");
     ASSERT(0);
     return pdp_profile_num;
  }

  /* get the profile pointer passed  if any */
  pdp_profile_num = (uint32)policy_info_ptr->pdp_info;

  if (pdp_profile_num == 0) 
  {
    if(PS_IFACE_PROC_ID_LOCAL == policy_info_ptr->proc_id)
    {
    /*PS_IFACE_PROC_ID_LOCAL corresponds to Modem Embedded call */
    /*---------------------------------------------------------------------
        If the origination is from sockets & profile number is 0,
        we have a sockets call which requests default profile. Get the 
        default profile number now
      ---------------------------------------------------------------------*/
      result = ds_umts_get_pdp_profile_num_for_sock_calls_per_subs(
                 dsumts_subs_mgr_get_subs_id_from_policy_subs_id(
                    policy_info_ptr->subs_id),
                 &socks_def_prof_num);
      if( result != DS_UMTS_PDP_SUCCESS )
      {
        DS_3GPP_MSG1_ERROR("Error in retrieving def prof number:%d",result);
      }
      pdp_profile_num = socks_def_prof_num;
    }
    else
    {
      /*---------------------------------------------------------------------
        It is an rmnet call & profile number is 0. Get the
        default profile number for rment
      ---------------------------------------------------------------------*/
      result = ds_umts_get_pdp_profile_num_for_rmnet_calls_per_subs(
                    dsumts_subs_mgr_get_subs_id_from_policy_subs_id(
                    policy_info_ptr->subs_id),
                    &rmnet_def_prof_num);
      if( result != DS_UMTS_PDP_SUCCESS )
      {
        DS_3GPP_MSG1_ERROR("Error in retrieving def prof number:%d",result);
      }
      pdp_profile_num = rmnet_def_prof_num;
    }
  }
  
  return pdp_profile_num;
}

/*===========================================================================
FUNCTION DS3GPP_RT_IS_CFG_SHAREABLE

DESCRIPTION
   This function Checks to see if the interface can be allowed to share
   one more user of the interface provided the configuration matches
  
PARAMETERS  
  *this_if_ptr        - Ptr to the interface
  *ipfilter_info_ptr  - Ip filter information
  *policy_info_ptr    - Policy information
    
DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : Inteface not activated or already activated with same config.
  FALSE: Interface not shareable, using different config
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
ACL_CFG_SHAREABLE_DEF( ds3gpp_rt_is_cfg_shareable )
{
  uint32            pdp_profile_num = 0;   
  ds_3gpp_iface_s  *ds_iface_p = NULL;
  ps_iface_type    *if_ptr = (ps_iface_type *) this_if_ptr;
  int               reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
    The following rules determine if the interface can 
    - if pdp profile number is 0 & incoming call is from laptop, ASSERT
    as this is not supposed to occur. Laptop always specifies a valid 
    pdp profile
    - if profile number is '0', retrieve sockets call profile num from 
      EFS
    - if iface is in use or looked_up & the profile number
      requested is same as that in use by the interface, return TRUE
    - for all other cases, return FALSE
  -------------------------------------------------------------------------*/

  pdp_profile_num = ds_3gpp_rt_acl_get_profile_num_from_policy(policy_info_ptr);
 
  if(ds_3gpp_profile_cache_get_cache_index((pdp_profile_num & 0x000000FF),
                                           dsumts_subs_mgr_get_subs_id_from_policy_subs_id(policy_info_ptr->subs_id)) == -1)
  {
    DS_3GPP_MSG1_ERROR("Invalid profile number:%d",pdp_profile_num);
    return FALSE;
  }


  /*-------------------------------------------------------------------------
    Handle 2 cases:
    (1) is_routeable is set: Below logic will ret TRUE for IFACE in_use if 
        one is available with the same PDP configuration
    (2) is_routeable is NOT set: If the IFACE is in_use or looked_up use this
        IFACE if the PDP configuration matches
    Only if the preferred packet mode is W or G, then we want to use the UMTS_IFACE,
    otherwise return false.
  -------------------------------------------------------------------------*/
  ds_iface_p = (ds_3gpp_iface_s*)(if_ptr->client_data_ptr); 

  if(PS_IFACE_IS_IN_USE(if_ptr)&&
     (ds3gpp_acl_is_pref_pkt_mode(policy_info_ptr, SYS_SYS_MODE_LTE)||
      ds3gpp_acl_is_pref_pkt_mode(policy_info_ptr, SYS_SYS_MODE_WCDMA)||
      ds3gpp_acl_is_pref_pkt_mode(policy_info_ptr, SYS_SYS_MODE_GSM)
#ifdef FEATURE_TDSCDMA
      ||
      ds3gpp_acl_is_pref_pkt_mode(policy_info_ptr, SYS_SYS_MODE_TDS) 
#endif
     ) &&
       (ds3gpp_compare_pdp_profile_info(if_ptr,
                                        pdp_profile_num, 
                                        policy_info_ptr,
                                        &reason_for_deny) == TRUE)
     )
  {
    if (PS_IFACE_IS_SHAREABLE(if_ptr))
    {
      DS_3GPP_MSG1_HIGH("3GPP iface:0x:%x is shareable",ds_iface_p);
      return TRUE;
    }
    else
    {
      DS_3GPP_MSG1_HIGH("3GPP iface:0x:%x is shareable check failed",ds_iface_p);
    }
  }

  DS_3GPP_MSG1_HIGH("3GPP iface:0x:%x is not shareable",ds_iface_p);
  return FALSE;
} /* ds3gpp_rt_is_cfg_shareable() */


/*===========================================================================
FUNCTION ds3gpp_rt_emergency_calls_is_cfg_shareable

DESCRIPTION
   This function Checks to see if the interface can be allowed to share
   one more user of the interface provided the configuration matches
  
PARAMETERS  
  *this_if_ptr        - Ptr to the interface
  *ipfilter_info_ptr  - Ip filter information
  *policy_info_ptr    - Policy information
    
DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : Inteface not activated or already activated with same config.
  FALSE: Interface not shareable, using different config
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
ACL_CFG_SHAREABLE_DEF( ds3gpp_rt_emergency_calls_is_cfg_shareable )
{
#ifdef FEATURE_EMERGENCY_PDN
  uint32   pdp_profile_num = 0;
  ds_3gpp_iface_s  *ds_iface_p = NULL;
  ps_iface_type *if_ptr = (ps_iface_type *) this_if_ptr;

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /* get the profile pointer passed  if any */
  pdp_profile_num = (uint32)policy_info_ptr->pdp_info;

  ds_iface_p = (ds_3gpp_iface_s*)(if_ptr->client_data_ptr); 

  if (ds_iface_p != NULL) 
  {
    ds_pdn_context_s *pdn_cntx_p = (ds_pdn_context_s*)(ds_iface_p->client_data_ptr);
    if (ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
    {
      if (pdp_profile_num == pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile_num)
      {          
        if (PS_IFACE_IS_SHAREABLE(if_ptr))
        {
          DS_3GPP_MSG1_HIGH("3GPP Iface:0x:%x is shareable with new request"
                            ,ds_iface_p);
          return TRUE;
        }         
      }
      else 
      {
        DS_3GPP_MSG1_HIGH("Iface is already in a emergency call to profile %d",
                                pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile_num);
      }
    }
    else 
    {
      //There is no PDN context associated with this Iface. So its not in use.
      DS_3GPP_MSG0_HIGH("This Iface is not in use");
      return TRUE;
    }
  }  

  DS_3GPP_MSG1_HIGH("3GPP iface:0x:%x is not shareable",ds_iface_p);
  return FALSE;
#endif /* FEATURE_EMERGENCY_PDN */
  DS_3GPP_MSG0_HIGH("3GPP iface is not shareable, Emergency PDN"
                    "feature disabled");

  return FALSE;
} /* ds3gpp_rt_emergency_calls_is_cfg_shareable() */

/*===========================================================================
FUNCTION DS3GPP_RT_EMERGENCY_CALLS_IS_CFG_SUPPORTED

DESCRIPTION
   This function checks to see if the configuration requested can be 
   supported by the specified interface ie can the interface be aciveted
   using the specified configuration.
  
PARAMETERS  
  *this_if_ptr        - Ptr to the interface
  *ipfilter_info_ptr  - Ip filter information
  *policy_info_ptr    - Policy information

   
DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : config can be supported
  FALSE: config cannot be supported (bad config or interface already 
         activated using a different config)
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
ACL_CFG_SUPPORTED_DEF2( ds3gpp_rt_emergency_calls_is_cfg_supported )
{
#ifdef FEATURE_EMERGENCY_PDN
  uint32  pdp_profile_num = 0;  
  ds_umts_pdp_profile_status_etype result;    
  ps_iface_type *if_ptr = (ps_iface_type *) this_if_ptr;
  ds_umts_pdp_profile_type profile_info;
  sys_modem_as_id_e_type            resolved_subs_id = SYS_MODEM_AS_ID_NONE;
  ds_umts_pdp_type_enum_type        pdp_type_to_use = DS_UMTS_PDP_IPV4V6;
  sys_sys_mode_e_type               cur_nw_mode;
  boolean                 roaming_status = FALSE;

#ifdef FEATURE_DATA_PS_IPV6
  ds_pdn_context_type_e call_type_originate;  
#endif

  ds_3gpp_iface_s  *ds_3gpp_iface_p = NULL;
  ds_3gpp_iface_s  *companion_ds_3gpp_iface_p = NULL;
  ps_iface_addr_family_type addr_family = IPV4_ADDR;

  /*-------------------------------------------------------------------------
    Get the DS Iface pointer from the PS Iface. 
    -------------------------------------------------------------------------*/
  ds_3gpp_iface_p = (ds_3gpp_iface_s*)(if_ptr->client_data_ptr);
  ASSERT (ds_3gpp_iface_p != NULL);

  *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;  

  /* get the profile num */
  pdp_profile_num = (uint32)policy_info_ptr->pdp_info;  

  if (pdp_profile_num == 0) 
  {
    //profile for emergency calls cannot be the default profile.
    DS_3GPP_MSG0_ERROR("Trying to use default profile for "
                       "emergency calls.Deny IFace");
    *reason_for_deny = ACL_DENY_REASON_INVALID_PROFILE_ID;
    return FALSE;
  }
    
  result = (ds_umts_pdp_profile_status_etype)
         ds_umts_get_pdp_profile_all_data_per_subs((uint16)pdp_profile_num, 
                                                   dsumts_subs_mgr_get_subs_id_from_policy_subs_id(policy_info_ptr->subs_id),
                                                   &profile_info);
  if( result != DS_UMTS_PDP_SUCCESS )
  {
    DS_3GPP_MSG2_ERROR("Error %d in retrieving profile info:%d",
                       result,pdp_profile_num);
    *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
    return FALSE;
  } 

  if (profile_info.emergency_calls_are_supported != TRUE)
  {
    DS_3GPP_MSG1_ERROR("%d is not the profile for emergency calls. "
                       "Deny Emergency Iface",pdp_profile_num);  
    *reason_for_deny = ACL_DENY_REASON_EMERGENCY_IFACE_ONLY;
    return FALSE;
  }  
  else 
  {
    DS_3GPP_MSG1_ERROR("IFace Lookup to make an emergency call to profile %d", 
                                                          pdp_profile_num);
  }

  /* Deny Iface if we are already in an emergency call to another PDN.*/
  {
    ds_pdn_context_s *pdn_cntx_p = (ds_pdn_context_s*)(ds_3gpp_iface_p->client_data_ptr);
    if (ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
    {
      if (pdp_profile_num != pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile_num)
      {          
        DS_3GPP_MSG3_HIGH("3GPP Iface:0x:%x is already in a emergency call "
                          "to profile %d",
                           if_ptr->name,
                           if_ptr->instance, 
                           pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile_num);
        *reason_for_deny = ACL_DENY_REASON_IFACE_IN_USE;  
        return FALSE;
      }         
    }
  }

  if ( ds3g_resolve_subs_id(policy_info_ptr->subs_id,&resolved_subs_id ))
  {
    cur_nw_mode = ds3g_get_current_network_mode_ex(resolved_subs_id);

    /*-----------------------------------------------------------------------
      Update the PDP type in PDN context in following scenarios
      If UE is in Roaming and roaming PDP type is configured or
      If UE is in Home and Home override PDP type is configured
      Note: Use Roaming status cached in rt_acl during first iface for all
      subsequent ifaces so that we use the same roaming status throughout
      routing & postproc.
    -----------------------------------------------------------------------*/
    if( DS_3GPP_IS_3GPP_CURRENT_MODE(cur_nw_mode) )
    {
      roaming_status = ds_3gpp_roaming_get_status(resolved_subs_id);
      pdp_type_to_use = ds_3gpp_pdn_context_determine_pdp_type(
                          resolved_subs_id,
                          &profile_info.context,
                          roaming_status);
      profile_info.context.pdp_type = pdp_type_to_use;
    }
  }
  else
  {
    *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
    DS_3GPP_MSG1_ERROR("Deny Iface invalid Policy SUB ID %d",
                       policy_info_ptr->subs_id);
    return FALSE;
  }

#ifdef FEATURE_DATA_PS_IWLAN_3GPP
  /*-------------------------------------------------------------------------
    If the profile requested is already used by an IWLAN iface return
    FALSE. We don't allow simultaneous UMTS/IWLAN calls using the same
    profile.
  -------------------------------------------------------------------------*/
  if(iwlan_3gpp_rt_is_profile_in_use(pdp_profile_num, policy_info_ptr) == 
      TRUE)
  {
    DS_3GPP_MSG1_ERROR("error profile number:%d is in use by WLAN",
                       pdp_profile_num);
    return FALSE;
  }
#endif /*FEATURE_DATA_PS_IWLAN_3GPP*/


#ifdef FEATURE_DATA_PS_IPV6
  
  call_type_originate = ds3gpp_determine_call_type_to_be_originated(
                           &profile_info.context, policy_info_ptr);

  /*-------------------------------------------------------------------------
    If call type is IPV6 Check that IPv6 NV item is valid 
  -------------------------------------------------------------------------*/
  if( ( call_type_originate == DS_3GPP_PDP_TYPE_IPV6 ) &&
      ( ds3g_is_ipv6_enabled() == FALSE) )
  {
    *reason_for_deny = ACL_DENY_REASON_V6_DISABLED;
    return FALSE;
  }

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    Fail the call since type of call to be originated could not be determined.
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(call_type_originate == DS_3GPP_PDP_TYPE_FAIL)
  {
    *reason_for_deny = ACL_DENY_REASON_IP_VERSION_MISMATCH;
    return FALSE;
  }

  addr_family = ps_iface_get_addr_family(if_ptr);

  switch(call_type_originate)
  {
    case DS_3GPP_PDP_TYPE_IPV6:
      if (addr_family != IFACE_IPV6_ADDR_FAMILY)
      {
        DS_3GPP_MSG2_HIGH("Call type to originate is %d. But Iface "
                          "Addr family is %d. Deny",
                           call_type_originate,
                           addr_family);
        *reason_for_deny = ACL_DENY_REASON_IP_VERSION_MISMATCH;
        return FALSE;
      }
      break;
 
      case DS_3GPP_PDP_TYPE_IP_ANY:
        switch(ds3g_get_failover_mode())
        {
          /*------------------------------------------------------------
            We are not supporting V4/V6 desired till now. So default to 
            V4/V6 preferred.
          ------------------------------------------------------------*/

          case IPV4_DESIRED:
          case IPV4_PREFERRED:
            if (addr_family != IFACE_IPV4_ADDR_FAMILY)
            {
              DS_3GPP_MSG2_HIGH("Call type to originate is %d. But Iface "
                                "Addr family is %d. Deny",
                                call_type_originate,
                                addr_family);
              *reason_for_deny = ACL_DENY_REASON_IP_VERSION_MISMATCH;
              return FALSE;
            }
          break;

          case IPV6_DESIRED:
          case IPV6_PREFERRED: 
            if (addr_family != IFACE_IPV6_ADDR_FAMILY)
            {
              DS_3GPP_MSG2_HIGH("Call type to originate is %d. But Iface "
                                "Addr family is %d. Deny",
                                call_type_originate,
                                addr_family);
              *reason_for_deny = ACL_DENY_REASON_IP_VERSION_MISMATCH;
              return FALSE;
            } 
          break;
                
          default:
            ASSERT(0);
            DS_3GPP_MSG1_HIGH("ds3gpp_failover_mode set to invalid value %d",
                              ds3g_get_failover_mode());
            break;
        }
      break;

      /*-------------------------------------------------------------------
        Call to be originated is of type IPV4 or PPP. Set the UM iface to 
        IPV4 as IPV6 is not supported for TE calls. 
      --------------------------------------------------------------------*/
      default:
        if (addr_family != IFACE_IPV4_ADDR_FAMILY)
        {
          DS_3GPP_MSG2_HIGH("Call type to originate is %d. But Iface "
                            "Addr family is %d. Deny",
                            call_type_originate,
                            addr_family);
          *reason_for_deny = ACL_DENY_REASON_IP_VERSION_MISMATCH;
          return FALSE;
        } 
        break;
    }

  if ( policy_info_ptr->apn.length != 0)
  {
    DS_3GPP_MSG0_HIGH("Overriding APN name for the emergency PDN is not allowed");
  }
      
  ds3gpp_enter_global_crit_section();

  //Get the Companion Iface and see if that is associated with an emergency call.
  //If it is the same call; then we are good.
  //If the companion Iface is on a different emergency call; then deny this IFace.
  //since we can have only 1 emergency call at any 1 time.

  companion_ds_3gpp_iface_p = ds_pdn_cntxt_get_companion_iface_for_emergency_calls(
                                    ds_3gpp_iface_p
                              );

  if (companion_ds_3gpp_iface_p != NULL)
  {
    if ((companion_ds_3gpp_iface_p->client_data_ptr != NULL) &&
        (companion_ds_3gpp_iface_p->client_data_ptr != 
                           ds_3gpp_iface_p->client_data_ptr))
    {
      DS_3GPP_MSG0_HIGH("Companion Iface is on a different emergency call."
                        " Deny Iface");
      ds3gpp_leave_global_crit_section();
      return FALSE;
    }
  }

  ds3gpp_leave_global_crit_section();

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    Fail the call since iface is already up and iface type is different from
    what is being requested by application.
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if ( (PS_IFACE_IS_IN_USE(if_ptr)) && 
       DS3GPP_IFACE_IS_CALL_TYPE_MATCHED(if_ptr,call_type_originate ) == FALSE)
  {
    /* todo: check this reason code */
    *reason_for_deny = get_deny_reason_code_by_iface_type( 
                         if_ptr, 
                         ACL_DENY_REASON_IP_VERSION_MISMATCH );
       
    DS_3GPP_MSG1_HIGH("PS Iface:0x%x in use and not sharable",if_ptr);
    return FALSE;
  }   
#endif  

  return TRUE;
#endif /* FEATURE_EMERGENCY_PDN */
  DS_3GPP_MSG0_HIGH("Profile does not support emergency calls. Deny Iface");
  *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
  return FALSE;
} /* ds3gpp_rt_emergency_calls_is_cfg_supported() */

/*===========================================================================
FUNCTION ds3gpp_rt_emergency_calls_is_pref_sys

DESCRIPTION
  This function checks to see if preferred system for emergency call is WWAN
  
PARAMETERS  
  *this_if_ptr        - Ptr to the interface
  *ipfilter_info_ptr  - Ip filter information
  *policy_info_ptr    - Policy information
      
DEPENDENCIES 
  None.
  
RETURN VALUE 
  TRUE : Interface is available (WWAN is preferred)
  FALSE: Interface is NOT available (WLAN is peferred)
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
/*lint -esym(715,pkt_info_ptr) */
ACL_IS_AVAILABLE_DEF2( ds3gpp_rt_emergency_calls_is_pref_sys )
{
  ps_iface_type *if_ptr = (ps_iface_type *) this_if_ptr;
  uint32 pdp_profile_num = 0;
  ds_umts_pdp_profile_status_etype result;
  ds_umts_pdp_profile_type profile_info;
  sys_modem_as_id_e_type resolved_subs_id = SYS_MODEM_AS_ID_NONE;
  ds3g_apn_name_type apn_name;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(reason_for_deny == NULL )
  {
     DS_3GPP_MSG0_ERROR("reason_for_deny ptr is NULL");
     return FALSE;
  }
 
  /* Get the resolved subs id */
  if( ds3g_resolve_subs_id(policy_info_ptr->subs_id ,&resolved_subs_id) 
        == FALSE) 
  {
    *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
    DS_3GPP_MSG1_ERROR("Deny Iface invalid Policy SUB ID %d",
                       policy_info_ptr->subs_id);
    return FALSE;
  }

  /*  PS framwork only does this data path routing for those Ifaces in UP state  */
  if((policy_info_ptr->bring_up == 0) && (policy_info_ptr->lookup_only == 0))
  {
    return TRUE;
  }

  if(policy_info_ptr->allow_less_pref_sys == TRUE)
  {
    DS_3GPP_MSG2_HIGH( "DS_3GPP_RT_ACL: Iface [%x:%d] NOT DENIED, allow less pref sys set", 
                if_ptr->name, if_ptr->instance);
    return TRUE;
  }

  pdp_profile_num = ds_3gpp_rt_acl_get_profile_num_from_policy(policy_info_ptr);
               
  memset(&profile_info, 0, sizeof(ds_umts_pdp_profile_type));
  result = (ds_umts_pdp_profile_status_etype)
             ds_umts_get_pdp_profile_all_data_per_subs(
                (uint16)pdp_profile_num,
                 dsumts_subs_mgr_get_subs_id_from_policy_subs_id(policy_info_ptr->subs_id),
                 &profile_info);

   if( result != DS_UMTS_PDP_SUCCESS )
   {
     DS_3GPP_MSG2_ERROR("Error %d in retrieving profile info:%d",
                         result,pdp_profile_num);
     *reason_for_deny = ACL_DENY_REASON_POL_NO_MATCH;
     return FALSE;
   } 

   memset(&apn_name, 0, sizeof(ds3g_apn_name_type));
   memscpy(apn_name.apn_string, DS_SYS_MAX_APN_LEN,
   	       profile_info.context.apn, DS_UMTS_MAX_APN_STRING_LEN+1);
   apn_name.apn_string_len = strlen(apn_name.apn_string);

  /* Check if IWLAN is preferred RAT for emergency call */
  if( (ds3g_is_apn_pref_pkt_mode_ex(DS_PKT_SYS_MODE_IWLAN, &apn_name,
                                   resolved_subs_id)) || 
      (!ds3g_is_apn_pref_pkt_mode_ex(DS_PKT_SYS_MODE_LTE, &apn_name,
                                   resolved_subs_id)) )    
  {
    DS_3GPP_MSG2_HIGH("DS_3GPP_RT_ACL: Iface [%x:%d] DENIED, WLAN/Non-LTE is preferred RAT", 
                       if_ptr->name, if_ptr->instance);
    *reason_for_deny = ACL_DENY_REASON_UNPREFERRED_RAT;
    return FALSE;
  }
  return TRUE;
}/* ds3gpp_rt_emergency_calls_is_pref_sys */

/*===========================================================================
FUNCTION ds3gpp_rt_acl_emergency_calls_post_proc

DESCRIPTION
   This function performs the post routing lookup actions.  This funtion is 
   called for the interface which is picked up as the most preferred interface 
   during lookupo based upon client requirements (policy) and other system 
   parameters.  
   For UMTS appropriate profile information is stored for the specified 
   interface and this information is used for pdp activation later.
  
PARAMETERS  
  *ipfilter_info_ptr  - Ip filter information
  *policy_info_ptr    - Policy information
  *this_if_ptr        - Ptr to the interface
    
DEPENDENCIES 
  None.
  
RETURN VALUE 
  None.
  
SIDE EFFECTS 
  None.
  
===========================================================================*/
/*lint -esym(715,pkt_info_ptr) */
ACL_POST_PROC_DEF( ds3gpp_rt_acl_emergency_calls_post_proc )
{
#ifdef FEATURE_EMERGENCY_PDN
  uint32                           pdp_profile_num= 0;
  ds_pdn_context_s                *pdn_cntx_p = NULL;
  ds_3gpp_iface_s                 *ds_iface_p = NULL;
  ds_3gpp_iface_s                 *ds_iface_other_p = NULL;
  ps_iface_type                   *if_ptr = (ps_iface_type *) this_if_ptr;
  int                              ds_companion_iface_index = -1;
  ds_apn_ip_support_type_e         ip_support = DS_IP_TYPE_INVALID;
  sys_modem_as_id_e_type           resolved_subs_id = SYS_MODEM_AS_ID_NONE;
  ds_sys_subscription_enum_type    ds_subs_id = DS_SYS_DEFAULT_SUBS;  
  boolean ds_3gpp_profile_is_valid = FALSE;
  ds_umts_pdp_profile_type       prof_context;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  if(policy_info_ptr->bring_up == FALSE)
  {
    DS_3GPP_MSG0_HIGH("Bring up flag: False. No Post proc needed");
    return;
  }

  if( ds3g_resolve_subs_id(policy_info_ptr->subs_id ,
                             &resolved_subs_id ) == FALSE) 
  {
     DS_3GPP_MSG1_ERROR("Error in obtaining resolved sub id. "
                        "Policy PS Sub ID is %d", policy_info_ptr->subs_id);
     return;
  }

  ds_iface_p = (ds_3gpp_iface_s*)(if_ptr->client_data_ptr);
  DS_3GPP_MSG1_MED("Post proc for ds iface:0x%x",ds_iface_p);

  /*----------------------------------------------------------------------------
    This is a block where we determine if we need post processing or not.
    This has to be done under a critical section since the flag can be inspected
    from multiple task contexts
  ----------------------------------------------------------------------------*/
  dssnet6_enter_crit_sect();
  ds3gpp_enter_global_crit_section();
  if(ds_iface_p->post_proc_done_flag == TRUE)
  {
    DS_3GPP_MSG0_HIGH("Post proc already done for this iface. Skip now");

    if(policy_info_ptr->handoff_ctxt.handoff_class != 
                                                  PS_IFACE_HANDOFF_CLASS_NONE)
    {
      /* Still need to set handoff attach flag, if set in policy
      */
      pdn_cntx_p = (ds_pdn_context_s *)ds_iface_p->client_data_ptr;

      if(!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
      {
        return;
      }

      ds_pdn_cntxt_set_handover_attach_flag(pdn_cntx_p, TRUE);
      DS_3GPP_MSG0_HIGH("Setting handover attach flag");
    }

    ds3gpp_leave_global_crit_section();
    dssnet6_leave_crit_sect();
    return;
  }
  else
  {
    /*--------------------------------------------------------------------------
      Set the post_proc_done_flag
    --------------------------------------------------------------------------*/
    ds_iface_p->post_proc_done_flag = TRUE;

  }

  if(ds3g_is_ipv6_enabled() == TRUE)
  {
    ds_3gpp_pdn_context_v6_sm_update(ds_iface_p,resolved_subs_id);
  }

  if (ds_iface_p->client_data_ptr == NULL)
  {
    /*-------------------------------------------------------------------------
      Allocate a PDN context for the iface. If no PDN context is available,
      (which is unlikely given the fact that there are 2 ifaces for default PDN 
      and 4 for non default PDNs and that we have 5 PDN contexts) we would fail
      the bring up.
    -------------------------------------------------------------------------*/
    DS_3GPP_MSG0_HIGH("Allocating new PDN Context..");

    pdn_cntx_p = ds_pdn_cntxt_allocate_new_pdn_context(resolved_subs_id);

    if(!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
    {
       ds3gpp_leave_global_crit_section();
       dssnet6_leave_crit_sect();
       return;
    }

  }
  // if the pdn context is already created
  else
  {
    pdn_cntx_p = (ds_pdn_context_s *)ds_iface_p->client_data_ptr;
    // if iface is not in down state, we need to exit
    if (ps_iface_state(if_ptr) != IFACE_DOWN)
    {
      DS_3GPP_MSG0_HIGH("Iface not in down state, do not do post processing.");
      ds3gpp_leave_global_crit_section();
      dssnet6_leave_crit_sect();
      return;
    }/* Iface is not in Down state */
  }

  /*-------------------------------------------------------------------------
    Mark the DS iface as being in use so that this iface is not reserved
    for dual IP bearer scenarios.
  -------------------------------------------------------------------------*/
  ds_iface_p->in_use = TRUE;

  /*-------------------------------------------------------------------------
      Assign the PDN context pointer to the client data pointer of the DS iface
      We have to note the DS iface pointer inside the PDN context struct
      Without that operation, the binding between the PS, DS ifaces and the PDN
      context will not be complete.
      However we cannot do that now because we have not set the IP type of PS
      Iface and without that, we will not be able to store the DS iface in the
      correct index of the DS Iface table in PDN context.
    -------------------------------------------------------------------------*/
  if(ds_iface_p->client_data_ptr == NULL)
  {
    ds_iface_p->client_data_ptr = (void*)pdn_cntx_p;
  }
    
  DS_3GPP_MSG2_HIGH("Interface 0x%x post proc DS Iface ptr:0x%x ",
              (uint32)this_if_ptr, if_ptr->client_data_ptr);

  pdp_profile_num = (uint32)policy_info_ptr->pdp_info;
  
  /*-------------------------------------------------------------------------
     Store the profile number specified for the call in the Call table
     if the interface is not currently in USE, This is to ensure that
     this is done ONLY when the interface is selected for the first time
     If an UP interface is selected by routing, this function is anyway
     called
  -------------------------------------------------------------------------*/
  if (!PS_IFACE_IS_IN_USE(if_ptr) &&
      (ps_iface_state(if_ptr) == IFACE_DOWN ))
  {
    memset(&prof_context, 0, sizeof(ds_umts_pdp_profile_type));
    ds_umts_get_pdp_profile_all_data_per_subs(pdp_profile_num,
                         dsumts_subs_mgr_get_subs_id(resolved_subs_id),
                                              &(prof_context));

    ds_3gpp_profile_is_valid = ds_pdn_cntxt_process_pdp_profile_info(pdn_cntx_p,
                                          pdp_profile_num,
                                          &ip_support, &prof_context);
    if (ds_3gpp_profile_is_valid == FALSE) 
    {
       DS_3GPP_MSG1_ERROR("pdp profile is not valid anymore %d ",pdp_profile_num);
    }
    pdn_cntx_p->ds_pdn_context_dyn_p->profile_is_valid = ds_3gpp_profile_is_valid;

    DS_3GPP_MSG1_HIGH("Profile pdp type is %d",
                      pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type);

    if (pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type ==
                                                         DS_UMTS_PDP_IPV4V6 )
    {
      DS_3GPP_MSG1_MED("Need companion iface for pdp_type: %d", 
                pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type);

      if ((ps_iface_get_addr_family(if_ptr) == IFACE_IPV4_ADDR_FAMILY) &&
         (ds3g_is_ipv6_enabled() == FALSE))
      {
        /*----------------------------------------------------------------------
          We need not allocate an Iface of the other IP type if the call being
          made is of type V4 and the NV item to turn on V6 stack is not enabled
        ----------------------------------------------------------------------*/
        DS_3GPP_MSG0_HIGH("V6 NV not enabled. Not allocating V6 iface");
      }
      else
      {
        ds_iface_other_p = ds_pdn_cntxt_get_companion_iface_for_emergency_calls(
                                                              ds_iface_p);
        if (ds_iface_other_p != NULL)
        {        
          DS_3GPP_MSG2_HIGH("Allocated companion iface 0x%x:0x%x", 
                            ds_iface_other_p->ps_iface.name, 
                            ds_iface_other_p->ps_iface.instance);
          ds_iface_other_p->in_use = TRUE;
          ds_iface_other_p->client_data_ptr = (void*) pdn_cntx_p;
          ds_iface_other_p->post_proc_done_flag = TRUE;
          ds_subs_id = ds3gsubsmgr_subs_id_cm_to_ds(resolved_subs_id);
          PS_IFACE_SET_SUBS_ID(&(ds_iface_other_p->ps_iface), ds_subs_id);	  
        }
        else 
        {
          DATA_ERR_FATAL("Unable to find companion Iface");
        }

        if(ds3g_is_ipv6_enabled() == TRUE)
        {
          ds_3gpp_pdn_context_v6_sm_update(ds_iface_other_p,resolved_subs_id);
        }

      } //determine if we need to allocate iface of other IP type      
    }

    switch(ps_iface_get_addr_family(if_ptr))
    {
      case IFACE_IPV4_ADDR_FAMILY:
        pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                   [DS_3GPP_PDN_CONTEXT_IPV4_IFACE]=\
                   (ds_3gpp_iface_s*)(if_ptr->client_data_ptr);

        DS_3GPP_MSG3_HIGH("iface post_proc 0x%x:0x%x pdp_type:%d", 
                           if_ptr->name, 
                           if_ptr->instance,
                           pdn_cntx_p->ds_pdn_context_dyn_p->
                           pdp_profile.context.pdp_type);

        /*----------------------------------------------------------------
          Store info about the other iface. This will be used only if the
          other DS Iface pointer is non-null
        ----------------------------------------------------------------*/
        ds_companion_iface_index = DS_3GPP_PDN_CONTEXT_IPV6_IFACE;
        if(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type != 
                                                     DS_UMTS_PDP_IPV4V6)
        {
          pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                        [ds_companion_iface_index] = NULL;
        }
        break;

      case IFACE_IPV6_ADDR_FAMILY:
        pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                    [DS_3GPP_PDN_CONTEXT_IPV6_IFACE]=\
                    (ds_3gpp_iface_s*)(if_ptr->client_data_ptr);

        DS_3GPP_MSG3_HIGH("iface post_proc 0x%x:0x%x pdp_type:%d", 
                           if_ptr->name, 
                           if_ptr->instance,
                           pdn_cntx_p->ds_pdn_context_dyn_p->
                                pdp_profile.context.pdp_type);

        /*----------------------------------------------------------------
          Store info about the other iface. This will be used only if the
          other DS Iface pointer is non-null
        ----------------------------------------------------------------*/       
        ds_companion_iface_index = DS_3GPP_PDN_CONTEXT_IPV4_IFACE;
        if(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type !=
                                                          DS_UMTS_PDP_IPV4V6)
        {
          pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                     [ds_companion_iface_index] = NULL;
        }
        break;

      default:
        DS_3GPP_MSG0_ERROR("Unexpected iface ip type!");
        break;
    }

    /*--------------------------------------------------------------------
      Set the IP type of the other iface and store it in the correct index
      in the PDN context
    --------------------------------------------------------------------*/
    if(ds_iface_other_p != NULL)
    {      
      ASSERT(ds_companion_iface_index == DS_3GPP_PDN_CONTEXT_IPV4_IFACE ||
             ds_companion_iface_index == DS_3GPP_PDN_CONTEXT_IPV6_IFACE);

      pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                        [ds_companion_iface_index]= ds_iface_other_p;
    }

    DS_3GPP_MSG2_HIGH("iface post_proc 0x%x:0x%x companion iface is NULL", 
                       if_ptr->name, if_ptr->instance);                           

  }//PS_IFACE_IS_IN_USE
  else
  {
    DS_3GPP_MSG1_HIGH("Interface already in use:prof :%d", pdp_profile_num);
  }

#ifdef FEATURE_EPC_HANDOFF
  /*----------------------------------------------------------------------------
    If this is handover attach, mark the boolean in PDN context so that we send
    out the orig params correctly
  ----------------------------------------------------------------------------*/
  if(policy_info_ptr->handoff_ctxt.handoff_class != PS_IFACE_HANDOFF_CLASS_NONE)
  {
    ds_pdn_cntxt_set_handover_attach_flag(pdn_cntx_p, TRUE);
    DS_3GPP_MSG0_HIGH("Post proc for handover case");
  }
#endif /* FEATURE_EPC_HANDOFF */

  DS_3GPP_MSG0_MED("Post proc complete");
  ds3gpp_leave_global_crit_section();
  dssnet6_leave_crit_sect();

#endif /* FEATURE_EMERGENCY_PDN */

} /* ds3gpp_rt_acl_post_proc() */

/*===========================================================================


                 ACCESS CONTROL LIST NAME DEFINITIONS

===========================================================================*/

/***  UMTS ACL ***/
ACL_DEF( ds3gpp_rt_acl )
/*lint -e641 -e718 -e746*/
ACL_START
  PASS_QUICK( ACL_DEFAULT_CLASS, IS_POL_INFO_NULL() );
  /*lint -e57 -e58 */
  DENY( DIFFERENT_IFACE_NAME_REQUIRED() );
  DENY( DIFFERENT_IFACE_ID_REQUIRED() );
  /*lint -e731 */
  DENY_WITH_ANY_REASON( SPECIFIED_CONFIG_NOT_SUPPORTED2(                                ds_3gpp_rt_acl_init_rule));
  DENY_WITH_ANY_REASON( SPECIFIED_CONFIG_NOT_SUPPORTED2(
                ds3gpp_rt_is_pref_sys));
  DENY( IFACE_UP_REQUIRED_BUT_NOT_UP() );
  DENY_WITH_ANY_REASON( SPECIFIED_CONFIG_NOT_SUPPORTED2(ds_3gpp_rt_is_cfg_supp) );
  DENY( SPECIFIED_CONFIG_NOT_SUPPORTED(ds3gpp_rt_is_cfg_supported) );
  DENY_WITH_ANY_REASON( SPECIFIED_CONFIG_NOT_SUPPORTED2(ds3gpp_rt_is_cfg_supported2) );
  /*lint -e506  */
  PASS( ACL_IFNAME_CLASS, REQUIRED_IFACE_TYPE_IS((ps_iface_name_enum_type)UMTS_IFACE));
  /*lint +e506 */
#ifdef FEATURE_WCDMA 
  PASS( ACL_PREF_MODE_CLASS, 
        IFACE_IS_PREF_MODE_DEF2( ds3gpp_acl_is_pref_pkt_mode, SYS_SYS_MODE_WCDMA) ); 
#endif
#ifdef FEATURE_DATA_LTE 
  PASS( ACL_PREF_MODE_CLASS, 
        IFACE_IS_PREF_MODE_DEF2( ds3gpp_acl_is_pref_pkt_mode, SYS_SYS_MODE_LTE) ); 
#endif
#ifdef FEATURE_GSM_GPRS
  PASS( ACL_PREF_MODE_CLASS, 
        IFACE_IS_PREF_MODE_DEF2( ds3gpp_acl_is_pref_pkt_mode, SYS_SYS_MODE_GSM) ); 
#endif
#ifdef FEATURE_TDSCDMA   
  PASS( ACL_PREF_MODE_CLASS,   
        IFACE_IS_PREF_MODE_DEF2( ds3gpp_acl_is_pref_pkt_mode, SYS_SYS_MODE_TDS) )
#endif
  /*lint -e506 -e778*/
  PASS( ACL_CONFIG_CLASS, 
        SPECIFIED_CONFIG_IS_SHAREABLE(ds3gpp_rt_is_cfg_shareable) );   
  PASS( ACL_UP_PREF_CLASS, IFACE_UP_PREFERRED_AND_UP() );
  PASS( ACL_IFGROUP_CLASS, REQUIRED_IFACE_TYPE_IS((uint16)IFACE_EPC_GROUP) );
  PASS( ACL_IFGROUP_CLASS, REQUIRED_IFACE_TYPE_IS((ps_iface_name_enum_type)WWAN_GROUP));
  PASS( ACL_IFGROUP_CLASS, REQUIRED_IFACE_TYPE_IS((ps_iface_name_enum_type)ANY_DEFAULT_GROUP));
#ifdef FEATURE_DATA_PS_IWLAN_3GPP
  PASS( ACL_IFGROUP_CLASS, REQUIRED_IFACE_TYPE_IS((ps_iface_name_enum_type)IFACE_3GPP_GROUP));
#endif
  /*lint +e506 +e778*/
  /*lint -e506 -e774*/
  PASS( ACL_DEFAULT_CLASS, ALL );
  /*lint +e506 +e774*/
ACL_END
/*lint +e641  +e718 +e746*/



/***  ACL for IFace Selection to make an emergency call. ***/
ACL_DEF(ds3gpp_rt_acl_emergency_calls)
/*lint -e641 -e718 -e746*/
ACL_START
  /*lint -e57 -e58 */

  DENY( DIFFERENT_IFACE_NAME_REQUIRED() );
  DENY( DIFFERENT_IFACE_ID_REQUIRED() );

  /*lint -e731 */

  DENY( IFACE_UP_REQUIRED_BUT_NOT_UP() );
  DENY_WITH_ANY_REASON( SPECIFIED_CONFIG_NOT_SUPPORTED2(
                          ds3gpp_rt_emergency_calls_is_cfg_supported) );
  DENY_WITH_ANY_REASON( SPECIFIED_CONFIG_NOT_SUPPORTED2(
			  ds3gpp_rt_emergency_calls_is_pref_sys) );

  /*lint +e506 */
  /*lint -e506 -e778*/

  PASS( ACL_EMRG_CLASS, 
        SPECIFIED_CONFIG_IS_SHAREABLE(ds3gpp_rt_emergency_calls_is_cfg_shareable) );   

  /*lint +e506 +e778*/
  /*lint -e506 -e774*/
  PASS( ACL_DEFAULT_CLASS, ALL );
  /*lint +e506 +e774*/
ACL_END
/*lint +e641  +e718 +e746*/

#endif /* defined(FEATURE_DATA_LTE)|| defined(FEATURE_DATA_WCDMA_PS) || defined(FEATURE_GSM_GPRS) */
