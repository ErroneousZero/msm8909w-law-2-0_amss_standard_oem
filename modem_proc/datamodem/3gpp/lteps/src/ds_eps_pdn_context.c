/*!
  @file
  ds_eps_pdn_context.c

  @brief
  REQUIRED brief one-sentence description of this C module.

  @detail
  OPTIONAL detailed description of this C module.
  - DELETE this section if unused.

*/

/*===========================================================================

  Copyright (c) 2009-2014-2016 Qualcomm Technologies Incorporated. All Rights Reserved

  Qualcomm Proprietary

  Export of this technology or software is regulated by the U.S. Government.
  Diversion contrary to U.S. law prohibited.

  All ideas, data and information contained in or disclosed by
  this document are confidential and proprietary information of
  Qualcomm Technologies Incorporated and all rights therein are expressly reserved.
  By accepting this material the recipient agrees that this material
  and the information contained therein are held in confidence and in
  trust and will not be used, copied, reproduced in whole or in part,
  nor its contents revealed in any manner to others without the express
  written permission of Qualcomm Technologies Incorporated.

===========================================================================*/

/*===========================================================================

                        EDIT HISTORY FOR MODULE

This section contains comments describing changes made to the module.
Notice that changes are listed in reverse chronological order.

  $Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/datamodem/3gpp/lteps/src/ds_eps_pdn_context.c#1 $ $DateTime: 2016/12/13 08:00:03 $ $Author: mplcsds1 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
09/12/13   dvk     Merged fix to tear down 3gpp2 call when moving from 1x/HDR 
                   to 3gpp system if handoff is not allowed. 
09/10/12   ss      Added support for IPV4 link MTU IE for Rel10.
08/30/12   ss      Fixed stack overflow in pdn_conn_rej_hdlr.
3/13/12    rr      Reject EPS bearer activate indication with invalid ESM cause code
9/09/11    rr      Added support for fallback from Dual IP to single IP when nw rejects
                   with specific cause codes in UMTS mode
06/15/11   ars     Fixed compiler Warnings
04/25/11   hs      Fixed issue in Silent redial - due to new state check
04/05/11   sch     Filled DNS server Ipv4 addr req container in PCO
10/01/10   ars     Enabled processing auth parameters from info
06/17/10   as      Fusion additions
05/17/10   hs      Added APN disable and PDN inactivity feature support.
04/04/10   vk      Added support for attach profile configuration
04/03/10   vk      Added support for MSG2.0 based logging
04/02/10   vrk     UMTS interRAT support
02/10/10   vd      Replaced lte_nas_esm_message_description.h with cm_gw.h
02/04/10   vd      Using changed flow functions.
01/23/10   vk      Added helper macros for virtual function dispatch
01/04/10   vk      Removing certain macros from PDP reg API header file
                   that cause problems with autogenerated RPC stub code
12/23/09   sa      Fix to return ERROR for PPP call type in LTE mode.
===========================================================================*/

/*===========================================================================

                           INCLUDE FILES

===========================================================================*/

#include "datamodem_variation.h"
#include "customer.h"
#include "comdef.h"

#ifdef FEATURE_DATA_LTE

#ifdef TEST_FRAMEWORK
#error code not present
#endif /* TEST_FRAMEWORK */


#include "ds_3gpp_pdn_context.h"
#include "ds_3gpp_hdlr.h"
#include "ds_3gpp_apn_table.h"
#include "ds_eps_pdn_throttle_sm.h"
#include "dstask.h"
#include "dsepsesmif.h"
#include "dsumtspspco.h"
#include "ds_3gpp_bearer_context.h"
#include "ds3gmgr.h"
#include "ds3gutil.h"
#include "ds3gprofile_validator.h"
#include "dsgen_iface_hdlr.h"
#include "cm_gw.h"
#include "ds_3gpp_flow_manager.h"
#include "ds_eps_bearer_context.h"
#include "ds_eps_pdn_context.h"
#include "ds_flow_control.h"
#include "ds_eps_bearer_flow_manager.h"
#include "ds_eps_flow_manager.h"
#include "ds3gmshif.h"
#include "ds_3gppi_utils.h"
#include "ds_3gpp_pdn_throttle_sm.h"
#include "ds_eps_throughput_hdlr.h"
#include "ds3gdsdif.h"
#include "ds_eps_bearer_context.h"
#include "ds_dsd_apm_ext_i.h"
#include "ds_3gpp_network_override_hdlr.h"
#include "dsumtspdpregint.h"
#include "ds3gcmif.h"

#include "dsutil.h"
#include <stringl/stringl.h>
#include "emm_ext_msg.h"
#include "dsmsgr.h"

#include "ds_3gpp_throttle_sm.h"
#include "ps_sys_event.h"
#include "ds_dsd_ext_i.h"
#include "ps_crit_sect.h"
#include "ds_3gpp_pdn_limit_hdlr.h"
#include "ds_3gpp_nv_manager.h"
#include "emm_irat_if_msg.h"

#include "lte_ml1_ext_api.h"
#include "lte_mac.h"
#include "ds_3gpp_op_pco_hdlr.h"
#include "ds_eps_stats.h"
#include "ds3geventmgr.h"
#include "ds_3gpp_apn_switch_mgr.h"
#include "ps_dpm.h"

/*===========================================================================

                   INTERNAL DEFINITIONS AND TYPES

===========================================================================*/

#define DS_EPS_CA_NOTIFY_CA_SCELL_CONFIGURED  0
#define DS_EPS_CA_NOTIFY_CA_SCELL_ACTIVATED   1

typedef enum 
{
  DS_EPS_BRINGUP_ATTACH_PDN_FAIL = 0,
  DS_EPS_BRINGUP_ATTACH_PDN_PEND_REDIAL,
  DS_EPS_BRINGUP_ATTACH_PDN_SUCCESS   
} ds_eps_bringup_attach_pdn_result_e;

#define DS_EPS_SET_ESM_CAUSE(info, cause_code)  \
    info->esm_cause.valid = TRUE;               \
    info->esm_cause.esm_cause = cause_code;     \
    

/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_BRING_UP_ATTACH_PDN

DESCRIPTION
  This function is responsible for the initiation of sending out PDN conn
  request during attach process. This function accesses the PDP registry,
  caches info in the PDN context, binds Ifaces and PDNs appropriately and
  calls iface active bring up.

  This function is called from 3GPP HDLR for EMM attach or from Resume handler
  to bring up the connection to default PDN

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  DS_EPS_BRINGUP_ATTACH_PDN_FAIL - if the attach APN is disabled
  DS_EPS_BRINGUP_ATTACH_PDN_PEND_REDIAL - if all operatins went
                      fine in Pending Redial handling
  DS_EPS_BRINGUP_ATTACH_PDN_SUCCESS - if all operations went fine
                      when it is not Pending Redial handling

SIDE EFFECTS
  None.

===========================================================================*/
LOCAL ds_eps_bringup_attach_pdn_result_e ds_eps_pdn_cntxt_bring_up_attach_pdn
(
  sys_modem_as_id_e_type    subs_id
);
/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_RESUME_IND_HDLR

DESCRIPTION
  This function is used to perform the actions needed at the PDN context
  level when resume indication is received.

PARAMETERS
  subs_id: Subscription Id

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
LOCAL void ds_eps_pdn_cntxt_resume_ind_hdlr
(
  sys_modem_as_id_e_type subs_id
);

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_PLMN_ID_CHG_HDLR

DESCRIPTION
  This function is used to handle the message from NAS. This message is sent
  whenever there is a change in PLMN

  Here we validate the message ID and we copy the PLMN in the payload of the
  message to the container maintained in DS

PARAMETERS
  msgrtype  - UMID of the message sent
  dsmsg_ptr - Pointer to the payload

DEPENDENCIES
  None.

RETURN VALUE
  TRUE  - if the message header is correct and we can handle the message
  FALSE - otherwise

  Note: We will not return FALSE for errors in the message payload

SIDE EFFECTS
  None.
===========================================================================*/
LOCAL boolean ds_eps_pdn_cntx_plmn_id_chg_hdlr
(
  msgr_umid_type             msgrtype,
  const msgr_hdr_struct_type *dsmsg_ptr
);

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_ATTACH_COMPLETE_IND_HDLR

DESCRIPTION
  This function is used to handle the message from NAS. This message is sent
  when NAS gets the L2 ack for attach complete message. This is the message
  that marks the completion of attach procedure.

  Clients that are interested in the completion of attach (EPC for instance)
  will be notified at this point.

  Note: This message has no payload.

PARAMETERS
  msgrtype  - UMID of the message sent
  dsmsg_ptr - Pointer to the payload

DEPENDENCIES
  None.

RETURN VALUE
  TRUE  - if the message header is correct and we can handle the message
  FALSE - otherwise

  Note: We will not return FALSE for errors in the message payload

SIDE EFFECTS
  None.
===========================================================================*/
LOCAL boolean ds_eps_pdn_cntx_attach_complete_ind_hdlr
(
  msgr_umid_type             msgrtype,
  const msgr_hdr_struct_type *dsmsg_ptr
);

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_RESET_ATTACH_SM_PARAMS

DESCRIPTION
  This function is used to reset the attch state machine parameters

PARAMETERS 
  None

DEPENDENCIES
  None.

RETURN VALUE
  None
 
SIDE EFFECTS
  None.
===========================================================================*/
LOCAL void ds_eps_pdn_cntx_reset_attach_sm_params
(
  sys_modem_as_id_e_type subs_id
);

/*===========================================================================
FUNCTION DS_EPS_ATTACH_SM_HANDLE_ATTACH_COMPLETE_IND

DESCRIPTION
  Update ATTACH SM state to attach_complete

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
LOCAL void ds_eps_attach_sm_handle_attach_complete_ind
(
  ds_dsd_attach_complete_type attach_type,
  sys_modem_as_id_e_type      subs_id
);

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_IS_ATTACH_PDN_UP

DESCRIPTION
  This function is used to check if attach PDN is UP.

PARAMETERS 
  None
 
DEPENDENCIES
  None.

RETURN VALUE
  True  - If attach PDN is UP.
  False - If attach PDN is not UP.
 
SIDE EFFECTS
  None.
===========================================================================*/
LOCAL boolean ds_eps_pdn_cntxt_is_attach_pdn_up
(
  sys_modem_as_id_e_type    subs_id
);

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_T3402_CHANGED_IND_HDLR

DESCRIPTION
  This function is used to handle the message from NAS. This message is sent
  whenever there is a change in T3402 timer value

  Here we validate the message ID and we copy the timer value in the payload of the
  message to the container maintained in DS

PARAMETERS
  msgr_type  - UMID of the message sent
  dsmsg_ptr - Pointer to the payload

DEPENDENCIES
  None.

RETURN VALUE
  TRUE  - if the message header is correct 
  FALSE - otherwise  

SIDE EFFECTS
  None.
===========================================================================*/ 
LOCAL boolean ds_eps_pdn_cntx_t3402_changed_ind_hdlr
(
  msgr_umid_type             msgr_type,
  const msgr_hdr_struct_type *dsmsg_ptr
);

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_VALIDATE_APN_NAME_AND_DECODE

DESCRIPTION
  This function is used to validate resolved apn name return by network 
  according to LTE spc
  also match with apn name in the profile


PARAMETERS
  pdn_cntx_ptr  - PDN Context variable
  lte_info_ptr - cm call info ptr
  decoded_apn - to store decoded apn
  disable_apn_matching - TRUE/FALSE

DEPENDENCIES
  None.

RETURN VALUE
  TRUE  - if apn parameter is valid and accepted  
  FALSE - otherwise  

SIDE EFFECTS
  None.
===========================================================================*/ 
LOCAL boolean ds_eps_pdn_cntx_validate_apn_name_and_decode
(
   ds_pdn_context_s               *pdn_cntx_p,
   cm_lte_call_info_s_type        *lte_info_ptr,
   byte                           *decoded_apn,
   boolean                         disable_apn_matching
);

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_CPHY_CA_EVENT_HDLR

DESCRIPTION
  This function is used to handle the LTE_CPHY_CA_EVENT_IND message from LTE
  ML1. MH will cache the p and s cell info for carrier aggregation.

PARAMETERS
  msgr_type  - UMID of the message sent
  dsmsg_ptr - Pointer to the payload

DEPENDENCIES
  None.

RETURN VALUE
  TRUE  - if the message header is correct 
  FALSE - otherwise  

SIDE EFFECTS
  None.
===========================================================================*/ 
static boolean ds_eps_pdn_cntxt_cphy_ca_event_hdlr
(
  msgr_umid_type             msgr_type,
  const msgr_hdr_struct_type *dsmsg_ptr
);

/*===========================================================================

                         LOCAL VARIABLES

===========================================================================*/
extern ds_pdn_context_s ds_pdn_context_tbl[DS_3GPP_MAX_PDN_CONTEXT];
/*---------------------------------------------------------------------------
  Variable used to find out if V6 NV item has been set or not.
---------------------------------------------------------------------------*/

#ifdef FEATURE_EPC_HANDOFF

/*---------------------------------------------------------------------------
  Variable to keep track of whether the EPC mode handler has
  registered with LTE MH
---------------------------------------------------------------------------*/
ds_3gpp_if_emm_attach_hdlr_f_type ds_eps_pdn_cntxt_emm_attach_hdlr_f = NULL;

#endif /* FEATURE_EPC_HANDOFF */


/*------------------------------------------------------------------------------
 Hold LTE attach PDN dual IP fall back IP type from NV
------------------------------------------------------------------------------*/
static ds_eps_attach_fb_info_type ds_eps_lte_attach_fb_ip_type[DS3GSUBSMGR_SUBS_ID_MAX];

/*----------------------------------------------------------------------------
  LTE Attach procedure state machine
----------------------------------------------------------------------------*/
ds_eps_attach_sm_s ds_eps_attach_sm[DS3GSUBSMGR_SUBS_ID_MAX] = {{NULL}};

/*----------------------------------------------------------------------------
  EMM T3402 value initialized to its default value: 12 mins(720000 ms). 
  Ref: ETSI TS 124301 V9.8.0 Sec 8.2.26.1
----------------------------------------------------------------------------*/
static uint32 ds_eps_t3402_value = 720000;

/*---------------------------------------------------------------------------
  Default profile
---------------------------------------------------------------------------*/
#define DS_EPS_DEF_PROF 0
#define DS_EPS_INVALID_PROF 0xFFFF
#define DS_EPS_PDN_CNTX_MIN_THROT_FAILURE_CNT 3

/*---------------------------------------------------------------------------
  Caches if CA/SCell is active at ML1
---------------------------------------------------------------------------*/
static boolean ds_eps_lte_active_scell[DS3GSUBSMGR_SUBS_ID_MAX] = {0};


/*===========================================================================

                    INTERNAL FUNCTION PROTOTYPES

===========================================================================*/



/*===========================================================================

                                FUNCTIONS

===========================================================================*/
/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_GET_T3402_TIMER_VAL

DESCRIPTION
  Returns T3402 timer value maintained within DS that is obtained via
  NAS_EMM_T3402_CHANGED_IND.

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
 T3402 timer value

SIDE EFFECTS
  None.

===========================================================================*/
uint32 ds_eps_pdn_cntxt_get_t3402_timer_val()
{
  return ds_eps_t3402_value;
}

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_SET_T3402_TIMER_VAL

DESCRIPTION
  Updates T3402 timer value maintained within DS that is obtained via
  NAS_EMM_T3402_CHANGED_IND.

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void ds_eps_pdn_cntxt_set_t3402_timer_val(uint32 new_t3402_val)
{
  DS_LTE_MSG1_HIGH("ds_eps_set_t3402_timer_val: Updating T3402 to %d", 
                   new_t3402_val);
  ds_eps_t3402_value = new_t3402_val;
}

/*===========================================================================
FUNCTION DS_EPS_GET_LTE_ATTACH_DUAL_IP_FB_STATUS

DESCRIPTION 
  This function returns the flag which tells whether dual IP FB feature is
  enabled or not
 
PARAMETERS
  None
 
DEPENDENCIES
  None 

RETURN VALUE
  TRUE: If the feature is enabled
  FALSE: Otherwise
 
SIDE EFFECTS
  None.
===========================================================================*/
boolean ds_eps_get_lte_attach_dual_ip_fb_status
(
  sys_modem_as_id_e_type    subs_id
)
{

  if(!ds3gsubsmgr_is_subs_id_valid(subs_id))
  {
    return DS_EPS_ATTACH_FB_IP_TYPE_MIN;
  }

  DS_3GPP_MSG1_MED("Returning Dual IP FB feature status : %d",
                   ds_eps_lte_attach_fb_ip_type[subs_id].fallback_enabled);
  return ds_eps_lte_attach_fb_ip_type[subs_id].fallback_enabled;

}

/*===========================================================================
FUNCTION DS_EPS_GET_LTE_ATTACH_DUAL_IP_FB_IP_TYPE

DESCRIPTION 
  This function returns Attach Dual IP FB IP type.
 
PARAMETERS
  None
DEPENDENCIES
  The fall back IP type is to be used when the network responds with a
  PDN Conn Rej with ESM cause #28 for Initial Attach request (only). 

RETURN VALUE
  Cached PDN IP type that UE will fall back to for certain attach failures with
  specific ESM cause codes
SIDE EFFECTS
  None.
===========================================================================*/
ds_eps_attach_fb_type ds_eps_get_lte_attach_dual_ip_fb_ip_type
(  
  sys_modem_as_id_e_type    subs_id
)
{
  ds_eps_attach_fb_type             fb_ip_type = DS_EPS_ATTACH_FB_IP_TYPE_MIN;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  if (!ds3gsubsmgr_is_subs_id_valid(subs_id))
  { 
    return FALSE; 
  }


  if(ds_eps_lte_attach_fb_ip_type[subs_id].fallback_enabled == TRUE)
  {
    DS_3GPP_MSG1_MED("Returning Attach FB ip type : %d",
                     ds_eps_lte_attach_fb_ip_type[subs_id].fallback_ip_type);
    fb_ip_type = ds_eps_lte_attach_fb_ip_type[subs_id].fallback_ip_type;
  }
  else
  {
    DS_3GPP_MSG0_HIGH("Dual IP fallback feature disabled!!!!");
  }

  return fb_ip_type;
}

/*===========================================================================
FUNCTION DS_EPS_SET_LTE_ATTACH_DUAL_IP_FB_IP_TYPE

DESCRIPTION 
  This function sets Attach Dual IP FB IP type.
 
PARAMETERS
  None
DEPENDENCIES
  The fall back IP type is to be used when the network responds with a
  PDN Conn Rej with ESM cause #28 for Initial Attach request (only). 

RETURN VALUE
  None
SIDE EFFECTS
  None.
===========================================================================*/
void ds_eps_set_lte_attach_dual_ip_fb_ip_type
(
  boolean                           activation_status,
  ds_eps_attach_fb_type             attach_fb_ip_type,
  sys_modem_as_id_e_type            subs_id
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  DS_3GPP_MSG1_MED("Setting Attach FB ip type activation status :%d",
                   activation_status);

  if (!ds3gsubsmgr_is_subs_id_valid(subs_id))
  {
    return;
  }

  ds_eps_lte_attach_fb_ip_type[subs_id].fallback_enabled = activation_status;
  if(activation_status == TRUE)
  {
    if(attach_fb_ip_type <= DS_EPS_ATTACH_FB_IP_TYPE_MIN ||
       attach_fb_ip_type >= DS_EPS_ATTACH_FB_IP_TYPE_MAX)
    {
      DS_3GPP_MSG0_HIGH("Invalid FB IP Type passed, default value V4 selected");
      ds_eps_lte_attach_fb_ip_type[subs_id].fallback_ip_type = 
                                            DS_EPS_ATTACH_FB_IP_TYPE_IPV4;
    }
    else
    {
      ds_eps_lte_attach_fb_ip_type[subs_id].fallback_ip_type = attach_fb_ip_type;
    }
  }
  else
  {
    DS_3GPP_MSG0_HIGH("Dual IP fallback feature disabled!!!!");
    ds_eps_lte_attach_fb_ip_type[subs_id].fallback_ip_type = 
                                           DS_EPS_ATTACH_FB_IP_TYPE_MIN;
  }

  return;
}

/*===========================================================================
FUNCTION  ds_eps_pdn_cntxt_check_if_apn_switch_needed

DESCRIPTION
  This functions checks the CC and decides whether APN switching is needed
  or not and according sends a REJECT IND to APM
 
PARAMETERS
  lte_call_info_ptr:                   LTE call information
  apn_switch_is_needed_p:              Flag that stores value about switching

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.

===========================================================================*/
void ds_eps_pdn_cntxt_check_if_apn_switch_needed
(
  cm_lte_call_info_s_type  *lte_call_info_ptr,
  boolean                  *apn_switch_is_needed_p,
  sys_modem_as_id_e_type    subs_id
)
{
  do
  {
    if(apn_switch_is_needed_p == NULL)
    {
      DS_LTE_MSG0_ERROR ("Invalid APN switch flag passed ");
      break;
    }

    if (ds_3gpp_nv_manager_get_switch_apn_on_reject(subs_id) == FALSE)
    {
      DS_LTE_MSG0_HIGH("Switch APN on reject NV is set to FALSE");
      *apn_switch_is_needed_p = FALSE;
      break;
    }

    if(lte_call_info_ptr == NULL)
    {
      DS_LTE_MSG0_ERROR("Input Params are not valid");
      break;
    }

    DS_LTE_MSG3_HIGH("ESM Local is valid: %d, EMM Failure Cause: %d,"
                     "ESM is valid: %d ", 
                     lte_call_info_ptr->esm_local_cause.valid,
                     lte_call_info_ptr->emm_failure_cause.cause_type,
                     lte_call_info_ptr->esm_cause.valid);

   /*----------------------------------------------------------------------- 
     For DCM we have a special requirement saying when T3402 timer expires
     NAS sends local cause code saying ATTACH_FAILED, in that case we need
     to switch APN and acquire PS services on next available one
    -----------------------------------------------------------------------*/ 

    if((ds_3gpp_nv_manager_get_global_throttling(subs_id) == TRUE) &&
       (lte_call_info_ptr->esm_local_cause.valid == TRUE &&
       lte_call_info_ptr->esm_local_cause.local_cause == EMM_ATTACH_FAILED))
    {
      *apn_switch_is_needed_p = TRUE;
    }
    else
    {
      if (lte_call_info_ptr->esm_local_cause.valid == TRUE ||
          lte_call_info_ptr->emm_failure_cause.cause_type != LTE_NAS_IRAT_NONE)
      {
        *apn_switch_is_needed_p = FALSE;
      }
      else if (lte_call_info_ptr->esm_cause.valid == TRUE &&
               lte_call_info_ptr->esm_cause.esm_cause == NAS_ESM_PDN_CONN_DOES_NOT_EXIST )
      {
        DS_LTE_MSG1_HIGH("ESM Cause: %d", lte_call_info_ptr->esm_cause.esm_cause);
        *apn_switch_is_needed_p = FALSE;
      }
      else
      {
        *apn_switch_is_needed_p = TRUE;
      }
    }
    DS_LTE_MSG1_HIGH("APN Switch is needed: %d", *apn_switch_is_needed_p);
  }
  while (0); 

  return;
}



/*===========================================================================
FUNCTION DS_EPS_GET_ATTACH_PROF

DESCRIPTION
  This function returns the profile number to be used to establish the
  default PDN connection during LTE attach.
 
  1. Query APM for the attach profile id and verify if this is a valid profile.
     If so use return this profile.
  2. If step 1 fails; return the profile used for socket calls.
  3. Is step 2 also fails; use the statically defined default profile DS_EPS_DEF_PROF.

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  uint16 - the profile number to be used for attaching to the LTE network.

SIDE EFFECTS
  None.

===========================================================================*/
uint16 ds_eps_get_attach_prof
( 
  sys_modem_as_id_e_type    subs_id
)
{
  uint16 attach_prof = DS_EPS_DEF_PROF;
  ds_umts_pdp_profile_status_etype    profile_status = DS_UMTS_PDP_SUCCESS;
  ds_dsd_apm_req_pay_load apm_payload = {0};
  ds_dsd_ext_error_code dsd_result = DS_DSD_APM_SUCCESS;
/*-------------------------------------------------------------------------*/
  do
  {
    //Request the attach profile from APM
    apm_payload.req_field_mask = DS_DSD_REQ_PROFILE_ID_FIELD_MASK;
    dsd_result = ds_dsd_apm_req_ex(DS_DSD_APM_ATTCH_REQ, &apm_payload,subs_id);

    if (DS_DSD_APM_SUCCESS == dsd_result)
    {
      boolean profile_is_valid = FALSE;

      /* Check if this is a valid profile id. */
      profile_status = ds_umts_get_pdp_profile_context_info_is_valid_per_subs(
          apm_payload.profile_id,
          dsumts_subs_mgr_get_subs_id(subs_id), 
          &profile_is_valid
      );

      if (TRUE == profile_is_valid && profile_status == DS_UMTS_PDP_SUCCESS)
      {
         attach_prof = apm_payload.profile_id;
         break;
      }
      else
      {
        DS_LTE_MSG2_HIGH("Attach profile is invalid %d, returning profile status is %d ",
                         profile_is_valid,profile_status);
        attach_prof = ds_eps_get_default_socket_profile(subs_id);
        break;
      }
    }
    else 
    {
      DS_LTE_MSG2_ERROR("Unable to get the attach profile from APM, "
                        "return_code %d, attach_apn_avail %d",
                        dsd_result,apm_payload.attach_apn_avail);
      if (dsd_result == DS_DSD_APM_ALL_ATTACH_APN_BLOCKED)
      {
        DS_LTE_MSG0_ERROR("All LTE attach APNs are blocked");
        attach_prof = DS_EPS_INVALID_PROF;
      }
#ifdef FEATURE_DATA_WLAN_MAPCON
      else if (dsd_result == DS_DSD_APM_ATTACH_NOT_ALLOWED) 
      {
        DS_LTE_MSG0_ERROR("APM blocked LTE attach");
        return DS_EPS_INVALID_PROF;
      }
#endif /*FEATURE_DATA_WLAN_MAPCON*/
      else if( (dsd_result == DS_DSD_APM_INVALID_APM) && 
               (apm_payload.attach_apn_avail == DS_DSD_APM_EFS_CONFIG_ERROR) )
      {
        /*----------------------------------------------------------------------- 
         We couldn't get a valid profile from APM because of attach APN EFS error.
         Using the default socket profile if the APN is unblocked
         -----------------------------------------------------------------------*/
         attach_prof = ds_eps_get_default_socket_profile(subs_id);
      }
    }
  } while(0);

  DS_LTE_MSG1_HIGH("Profile Id used for attach is %d", attach_prof);
  return attach_prof;
}
/*===========================================================================
FUNCTION DS_EPS_PDN_IP_FILL_PPP_PARAMS_PPP_PARAMS_FROM_PROFILE

DESCRIPTION
  This function fills in the PPP authentication and IPCP packet information
  for a PDP-IP call from the PDP profile specified for the call
    
PARAMETERS  
    *orig_params_p     - Ptr to  Call origination parameters 
    pdp_profile_p      - Ptr to the PDP profile parameters
    subs_id            - Subscription Id

DEPENDENCIES
  None.
  
RETURN VALUE
  none  

SIDE EFFECTS
  orig_params_ptr is updated with the PPP packet information from the profile
  
===========================================================================*/
LOCAL boolean ds_eps_pdn_ip_fill_ppp_params_from_profile
(
  pdn_connection_data_T              *orig_params_p,
  const ds_umts_pdp_profile_type     *profile_p,
  boolean                            *auth_info_being_sent,
  sys_modem_as_id_e_type              subs_id
)
{
  boolean result;
  net_cfg_params_mask_e_type valid_fields = 
      (net_cfg_params_mask_e_type)0x00000000; /* IPCP options to be requested*/

  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*-------------------------------------------------------------------------
   Fill in Protocol specific options : for IP, this would contain the PPP 
   pkts (lcp, ipcp ) The purpose of the protocol configuration options
   information element is to transfer external network protocol options 
   associated with a PDP context activation . The IE is defined in 10.5.6.3.
  -------------------------------------------------------------------------*/

  /*-------------------------------------------------------------------------
   start off assuming that the field is not valid ( nothing filled in ) 
  -------------------------------------------------------------------------*/
  orig_params_p->protocol_config_options.valid  = FALSE; 
  
  /*-------------------------------------------------------------------------
    Config protocol field is 0x80 : ref: TS24.008 sec 10.5.6.3
    MSB should be 1 (ext field) protocol field b0-b2 should be 0x0 
    Initilize this field
  -------------------------------------------------------------------------*/
  orig_params_p->protocol_config_options.config_protocol   = PROT_CFG_IE_OCT3_VAL; 
  orig_params_p->protocol_config_options.num_protocol_ids  = 0;
    
  DS_LTE_MSG1_HIGH("In ds_eps_pdn_ip_fill_ppp_params_from_profile: "
                   "Auth type %d",profile_p->auth.auth_type);

  /*-------------------------------------------------------------------------
    Use the auth info from profile
  -------------------------------------------------------------------------*/
  *auth_info_being_sent = FALSE;
  result = ds_pdn_cntxt_fill_auth_params_from_profile (
                  &(orig_params_p->protocol_config_options),
                    profile_p, subs_id);

  if(result) {
    DS_LTE_MSG0_LOW("Auth Info generation Success ");
    *auth_info_being_sent = TRUE;
  }

  /*-------------------------------------------------------------------------
    Request Primary and Secondary DNS addresses from the network.
    Since we are populating values from profile, only request DNS address.
  -------------------------------------------------------------------------*/
  valid_fields = (net_cfg_params_mask_e_type)
    (NET_CFG_PRM_PRI_DNS_MASK | NET_CFG_PRM_SEC_DNS_MASK);

  /*--------------------------------------------------------------------------
    Handle error case and return failure before trying to fill IPV4/IPV6 
    DNS containers.
  ---------------------------------------------------------------------------*/
  if((profile_p->context.pdp_type != DS_UMTS_PDP_IPV4 ) &&
     (profile_p->context.pdp_type != DS_UMTS_PDP_IPV6) && 
     (profile_p->context.pdp_type != DS_UMTS_PDP_IPV4V6) )
  {
     DS_LTE_MSG1_ERROR("Iface has invalid IP type %d",profile_p->context.pdp_type);
     return DS3G_FAILURE;
  }

  if((profile_p->context.pdp_type == DS_UMTS_PDP_IPV4) ||
     (profile_p->context.pdp_type == DS_UMTS_PDP_IPV4V6) )
  {
    DS_LTE_MSG2_HIGH("IPCP DNS options P:%lx S:%lx",
              profile_p->dns_addr.primary_dns_addr.pdp_addr.pdp_addr_ipv4,
                     profile_p->dns_addr.secondary_dns_addr.pdp_addr.pdp_addr_ipv4);
    result = ds_pdn_cntxt_fill_ipcp_orig_params
             (
               &(orig_params_p->protocol_config_options),
               FALSE,
               profile_p->dns_addr.primary_dns_addr.pdp_addr.pdp_addr_ipv4,
               profile_p->dns_addr.secondary_dns_addr.pdp_addr.pdp_addr_ipv4,
               FALSE,
               profile_p->dns_addr.primary_dns_addr.pdp_addr.pdp_addr_ipv4,
               profile_p->dns_addr.secondary_dns_addr.pdp_addr.pdp_addr_ipv4,
               valid_fields
             );
    if (result == FALSE)
    {
      /*-------------------------------------------------------------------
        If an error occurs in encoding pkt, do not include the pkt but
        proceed with call If we return error here, call setup would fail and
        the user would'nt know why?  and all subsequent call attemtps for the
        PDP ctxt would also fail (using the same params)
       ------------------------------------------------------------------*/
      DS_LTE_MSG0_LOW("IPCP packet generation failed");
    }

    result = ds_3gpp_pdn_cntxt_fill_ipv4_dns_container
             (
               &(orig_params_p->protocol_config_options)
             );
    if (result == FALSE)
    {
      /*-------------------------------------------------------------------
       If an error occurs in encoding pkt, do not include the pkt but
      proceed with call If we return error here, call setup would fail and
      the user would'nt know why?  and all subsequent call attemtps for the
      PDP ctxt would also fail (using the same params)
      ------------------------------------------------------------------*/
      DS_LTE_MSG0_LOW("DNS Server IPv4 addr Req container could not be " \
                       "included");
    }
  }
  if((profile_p->context.pdp_type == DS_UMTS_PDP_IPV6) ||
     (profile_p->context.pdp_type == DS_UMTS_PDP_IPV4V6))
  {
    result = ds_pdn_cntxt_fill_ipv6_dns_params
             (
               &(orig_params_p->protocol_config_options)
             );

    if (result == FALSE)
    {
      /*---------------------------------------------------------------------
        If an error occurs in encoding pkt, do not include the pkt but
        proceed with call If we return error here, call setup would fail and
        the user would'nt know why?  and all subsequent call attemtps for the
        PDP ctxt would also fail (using the same params)
      ---------------------------------------------------------------------*/
      DS_LTE_MSG0_LOW("IPV6 DNS Genaration Failed");
    }
  }

  return DS3G_SUCCESS;

}


/*===========================================================================
FUNCTION DS_EPS_PDN_IP_FILL_PPP_PARAMS_PPP_PARAMS_FROM_INFO

DESCRIPTION
  This function fills in the PPP authentication and IPCP packet information
  for a PDN-IP call from the PPP auht information passed in when bringing
  up the interface. This is the case for a Laptop PDP-IP call where in the
  middle of PPP negotiation, we trigger the call setup and pass the ppp info

PARAMETERS
    *orig_params_ptr     - Ptr to  Call origination parameters
    *pdp_profile_parms   - Profile parameters
    ppp_info_ptr         - pointer to the ppp auth/ipcp information
    pdp_call_type        - PDP Type of call to be originated
    subs_id              - Subscription id

DEPENDENCIES
  None.

RETURN VALUE
  none

SIDE EFFECTS
  orig_params_ptr is updated with the PPP packet information from the profile

===========================================================================*/
LOCAL boolean ds_eps_pdn_ip_fill_ppp_params_from_info
(
  pdn_connection_data_T           *orig_params_p,
  ds_umts_pdp_profile_type        *profile_p,
  const network_params_info_type  *ppp_info_p,
  boolean                         *auth_info_being_sent,
  sys_modem_as_id_e_type           subs_id
)
{
  boolean result = TRUE;
  net_cfg_params_mask_e_type valid_fields = 
                             (net_cfg_params_mask_e_type)0x00000000; 
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  DS_LTE_MSG0_HIGH("In ds_eps_pdn_ip_fill_ppp_params_from_info:");
  
  /*-------------------------------------------------------------------------
    Check to see if the parameters pdp_profile_parms and ppp_info_ptr are
    valid.
  -------------------------------------------------------------------------*/
  if (profile_p == NULL)
    return DS3G_FAILURE;

  if(ppp_info_p == NULL)
  {
    DS_LTE_MSG0_HIGH("Fill PPP params from Profile");
    return ds_eps_pdn_ip_fill_ppp_params_from_profile
            (orig_params_p, profile_p, auth_info_being_sent, subs_id);
  }
  /*-------------------------------------------------------------------------
   Fill in Protocol specific options : for IP, this would contain the PPP
   pkts (lcp, ipcp ) The purpose of the protocol configuration options
   information element is to transfer external network protocol options
   associated with a PDP context activation . The IE is defined in 10.5.6.3.
  -------------------------------------------------------------------------*/

  /*-------------------------------------------------------------------------
   start off assuming that the field is not valid ( nothing filled in )
  -------------------------------------------------------------------------*/
  orig_params_p->protocol_config_options.valid  = FALSE;

  /*-------------------------------------------------------------------------
    Config protocol field is 0x80 : ref: TS24.008 sec 10.5.6.3
    MSB should be 1 (ext field) protocol field b0-b2 should be 0x0
    Initilize this field
  -------------------------------------------------------------------------*/
  orig_params_p->protocol_config_options.config_protocol   = PROT_CFG_IE_OCT3_VAL;
  orig_params_p->protocol_config_options.num_protocol_ids  = 0;
 
  /*----------------------------------------------------------------------
   Fill AUTH Parameters
  -------------------------------------------------------------------------*/
  *auth_info_being_sent = FALSE;
  if( (ppp_info_p->valid_fields & NET_CFG_PRM_AUTH_PREF_MASK)||
      (ppp_info_p->valid_fields & NET_CFG_PRM_AUTH_USERNAME_MASK)||
      (ppp_info_p->valid_fields & NET_CFG_PRM_AUTH_PASSWORD_MASK) )
  {
    DS_LTE_MSG1_HIGH("Auth type %d from Info",ppp_info_p->auth_info.auth_type);

    /*-------------------------------------------------------------------------
      Store the auth type from the ppp info in the pdp profile info.
    -------------------------------------------------------------------------*/
    result = ds_pdn_cntxt_fill_auth_params_from_info (
                   &(orig_params_p->protocol_config_options),
                     profile_p, ppp_info_p, subs_id);
  }
  else
  {
    /*-------------------------------------------------------------------------
      Use the auth info from profile
    -------------------------------------------------------------------------*/
    result = ds_pdn_cntxt_fill_auth_params_from_profile (
                    &(orig_params_p->protocol_config_options),
                      profile_p, subs_id);
  }

  if( TRUE == result)
  {
    *auth_info_being_sent = TRUE;
  } 

  /*-------------------------------------------------------------------------
    Request Primary and Secondary DNS addresses from the network.
  -------------------------------------------------------------------------*/
  DS_LTE_MSG0_HIGH("IPCP DNS options specified");

  if((profile_p->context.pdp_type == DS_UMTS_PDP_IPV4) 
     || (profile_p->context.pdp_type == DS_UMTS_PDP_IPV4V6))
  {
    if( (ppp_info_p->valid_fields & NET_CFG_PRM_PRI_DNS_MASK)||
        (ppp_info_p->valid_fields & NET_CFG_PRM_SEC_DNS_MASK)||
        (ppp_info_p->valid_fields & NET_CFG_PRM_PRI_NBNS_MASK)||
        (ppp_info_p->valid_fields & NET_CFG_PRM_SEC_NBNS_MASK) )
    {
      valid_fields = (net_cfg_params_mask_e_type) (ppp_info_p->valid_fields);
  /*---------------------------------------------------------------------------
    We convert the DNS address from Little Endian to Big Endian before
    sending the request to OTA, since QMI sends information in Little Endian
    format, however modifications to the profile are sent in Big Endian format
  ---------------------------------------------------------------------------*/
      result = ds_pdn_cntxt_fill_ipcp_orig_params 
              (
               &(orig_params_p->protocol_config_options),
               TRUE,
               ds_3gpp_chng_byte_order(ppp_info_p->ipcp_info.primary_dns),
               ds_3gpp_chng_byte_order(ppp_info_p->ipcp_info.secondary_dns),
               TRUE,
               ds_3gpp_chng_byte_order(ppp_info_p->ipcp_info.primary_nbns),
               ds_3gpp_chng_byte_order(ppp_info_p->ipcp_info.secondary_nbns),
               valid_fields
             );

      if (!result)
      {
        /*---------------------------------------------------------------------
          If an error occurs in encoding pkt, do not include the pkt but
          proceed with call If we return error here, call setup would fail and
          the user would'nt know why?  and all subsequent call attemtps for the
          PDP ctxt would also fail (using the same params)
        ---------------------------------------------------------------------*/
        DS_LTE_MSG0_LOW("IPCP packet generation failed to copy from info");
      }
    }
    else
    {
      /*-------------------------------------------------------------------------
        Request Primary and Secondary DNS addresses from the network.
        Since we are populating values from profile, only request DNS address.
      -------------------------------------------------------------------------*/
      valid_fields = (net_cfg_params_mask_e_type)
                     (NET_CFG_PRM_PRI_DNS_MASK | NET_CFG_PRM_SEC_DNS_MASK);

      DS_LTE_MSG2_HIGH("IPCP DNS options from profile P:%lx S:%lx",
                profile_p->dns_addr.primary_dns_addr.pdp_addr.pdp_addr_ipv4,
                       profile_p->dns_addr.secondary_dns_addr.pdp_addr.pdp_addr_ipv4);
      result = ds_pdn_cntxt_fill_ipcp_orig_params
             (
                 &(orig_params_p->protocol_config_options),
                 FALSE,
                 profile_p->dns_addr.primary_dns_addr.pdp_addr.pdp_addr_ipv4,
                 profile_p->dns_addr.secondary_dns_addr.pdp_addr.pdp_addr_ipv4,
                 FALSE,
                 profile_p->dns_addr.primary_dns_addr.pdp_addr.pdp_addr_ipv4,
                 profile_p->dns_addr.secondary_dns_addr.pdp_addr.pdp_addr_ipv4,
                 valid_fields
             );
      if (result == FALSE)
      {
        /*-------------------------------------------------------------------
        If an error occurs in encoding pkt, do not include the pkt but
        proceed with call If we return error here, call setup would fail and
        the user would'nt know why?  and all subsequent call attemtps for the
        PDP ctxt would also fail (using the same params)
         ------------------------------------------------------------------*/
        DS_LTE_MSG0_LOW("IPCP packet generation failed to copy from profile");
      }
    }
    result = ds_3gpp_pdn_cntxt_fill_ipv4_dns_container
             (
               &(orig_params_p->protocol_config_options)
             );
    if (result == FALSE)
    {
      /*-------------------------------------------------------------------
       If an error occurs in encoding pkt, do not include the pkt but
      proceed with call If we return error here, call setup would fail and
      the user would'nt know why?  and all subsequent call attemtps for the
      PDP ctxt would also fail (using the same params)
      ---------------------------------------------------------------------*/
      DS_LTE_MSG0_LOW("Could not include DNS Server IPv4 addr req container");
    }
  }

  if((profile_p->context.pdp_type == DS_UMTS_PDP_IPV6) ||
     (profile_p->context.pdp_type == DS_UMTS_PDP_IPV4V6))
  {
    result = ds_pdn_cntxt_fill_ipv6_dns_params   
             (
               &(orig_params_p->protocol_config_options)
             );


    if (!result)
    {
      /*---------------------------------------------------------------------
        If an error occurs in encoding pkt, do not include the pkt but
        proceed with call If we return error here, call setup would fail and
        the user would'nt know why?  and all subsequent call attemtps for the
        PDP ctxt would also fail (using the same params)
      ---------------------------------------------------------------------*/
      DS_LTE_MSG0_LOW("IPV6 DNS Genaration Failed");
    }
  }

  return DS3G_SUCCESS;
}

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_UPDATE_NTW_OVERRIDDEN_EPS_ORIG_PARAMS

DESCRIPTION
  This function updates the eps_orig params because the IP type
  corresponding to a particular apn has been overridden by the
  network.

PARAMETERS
  eps_orig_params_p - Pointer to EPS orig parameters
  pdn_ptr  - Pdn ptr

DEPENDENCIES
  None.

RETURN VALUE
  boolean TRUE - If the updation is successful
  `       FALSE - Otherwise

SIDE EFFECTS

===========================================================================*/

static boolean ds_eps_pdn_cntxt_update_ntw_overridden_eps_orig_params
(
   pdn_connection_data_T         *eps_orig_params_p,
   ds_pdn_context_s              *pdn_cntx_p,
   ds_network_overrridden_ip_type_e ntw_overridden_ip
  
)
{
  boolean                       ret_val = FALSE;
  ds_umts_pdp_profile_type      *profile_p = NULL;
  ds_dsd_apm_ind_pay_load       ind_payload;
  sys_modem_as_id_e_type           subs_id=SYS_MODEM_AS_ID_NONE;
  /*--------------------------------------------------------------------------*/

  memset(&ind_payload, 0, sizeof(ds_dsd_apm_ind_pay_load));

  if (eps_orig_params_p == NULL)
  {
    DS_LTE_MSG0_ERROR("EPS Orig params is NULL");
    return ret_val;
  }

  if(!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
  {
    return ret_val;
  }

  if(! ds_3gpp_pdn_cntxt_get_subs_id_from_pdn(pdn_cntx_p,&subs_id))
  {
    return ret_val;
  }

  profile_p = &(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile);

  if (profile_p == NULL)
  {
    DS_LTE_MSG0_ERROR("Profile ptr is NULL");
    return ret_val;
  }

  DS_LTE_MSG1_MED("Nw Overridden IP is %d",ntw_overridden_ip);

  /*--------------------------------------------------------------------- 
    Failure is returned for IPV6 if
    1. IPV6 NV is not turned on
    2. Profile type is V4 but Network overridden IP is IPV6 only
    Failure is returned for IPV4 if
    1. Profile type is V6 and Network overridden IP is IPV4 only
    If successful, update the PDN cache and APN table.
  -----------------------------------------------------------------------*/
  if (ntw_overridden_ip == PDP_IPV6)
  {
    if (((profile_p->context.pdp_type == DS_UMTS_PDP_IPV6) || 
         (profile_p->context.pdp_type == DS_UMTS_PDP_IPV4V6)) && 
        (ds3g_is_ipv6_enabled()))
    {
      DS_LTE_MSG0_MED("Updating the outgoing PDN request to IPV6");
      eps_orig_params_p->pdn_type = NAS_ESM_IPV6;
      profile_p->context.pdp_type = DS_UMTS_PDP_IPV6;
      (void)ds_pdn_cntxt_update_apn_table(pdn_cntx_p->ds_pdn_context_dyn_p
                      ->pdp_profile.context.apn,DS_IPV6_ONLY, pdn_cntx_p); 
      DS_3GPP_APM_SET_INVALID_V4_IPADDR(ind_payload, 
                                        PS_NET_DOWN_REASON_IP_V6_ONLY_ALLOWED);
      ret_val = TRUE;
    }
    else
    {
      DS_LTE_MSG2_ERROR("global_allow_ipv6:%d:Profile PDP type",
                        ds3g_is_ipv6_enabled() ,profile_p->context.pdp_type);
    }
  }
  else if (ntw_overridden_ip == PDP_IPV4)
  {
    if((profile_p->context.pdp_type == DS_UMTS_PDP_IPV4) || 
         (profile_p->context.pdp_type == DS_UMTS_PDP_IPV4V6)) 
    {
      DS_LTE_MSG0_MED("Updating the outgoing PDN request to IPV4");
      eps_orig_params_p->pdn_type = NAS_ESM_IPV4;
      profile_p->context.pdp_type = DS_UMTS_PDP_IPV4;
      (void)ds_pdn_cntxt_update_apn_table(pdn_cntx_p->ds_pdn_context_dyn_p
                       ->pdp_profile.context.apn,DS_IPV4_ONLY, pdn_cntx_p); 
      DS_3GPP_APM_SET_INVALID_V6_IPADDR(ind_payload,
                                        PS_NET_DOWN_REASON_IP_V4_ONLY_ALLOWED);
      ret_val = TRUE;
    }
    else
    {
      DS_LTE_MSG1_ERROR("Profile PDP type",profile_p->context.pdp_type);
    }
  }

  return ret_val;
} /*ds_eps_pdn_cntxt_update_ntw_overridden_eps_orig_params*/

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_FILLORIGPARAMS

DESCRIPTION
  This function fills all origination parameters. This function can be called
  either from get_pdn_connectivity_msg (Attach) or from the orig call hander
  in 3gpp_hdlr (UE init pdn connectivity).

PARAMETERS
  Pointer to pdn connection data to filled by DS EPS.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
boolean ds_eps_pdn_cntxt_fillOrigParams
(
  ds_pdn_context_s                 *pdn_cntx_p,
  pdn_connection_data_T            *eps_orig_params_p,
  const ds_3gpp_pdn_call_info_type *call_info_p
)
{
  boolean                          result = FALSE;
  boolean                          auth_info_being_sent = FALSE;
  uint8                            apn_encoded_length =0; /* encoding APN*/
  ds_umts_pdp_profile_type         *profile_p;
  network_params_info_type         *ppp_info_p=NULL;   /* ppp auth & ipcp info  */
  ds_network_overrridden_ip_type_e ntw_overridden_ip = PDP_UNDEFINED;
  sys_modem_as_id_e_type           subs_id=SYS_MODEM_AS_ID_NONE;
  void                            *fill_op_pco_ptr = NULL;
  boolean                          pco_id_collision = FALSE;
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if(! ds_3gpp_pdn_cntxt_get_subs_id_from_pdn(pdn_cntx_p,&subs_id))
  {
    return FALSE;
  }
  profile_p = &(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile);

  /*-------------------------------------------------------------------------
    Verify the input parameters
  -------------------------------------------------------------------------*/
  if (eps_orig_params_p == NULL)
  {
    DATA_ERR_FATAL("Input ptr in NULL");
    return FALSE;
  }

  /*-------------------------------------------------------------------- 
    Check if ip type has been overridden by the network  
   --------------------------------------------------------------------*/

  if ((ntw_overridden_ip = ds_3gpp_network_override_hdlr_get_overridden_ip(
      (byte *)profile_p->context.apn, subs_id)) != PDP_UNDEFINED)
  {
    DATA_3GPP_MSG_SPRINTF_2(MSG_LEGACY_HIGH,"IP is nw overriden for apn:%s,"
                      "network_overridden_ip_type:%d",profile_p->context.apn,
                      ntw_overridden_ip);

    result = ds_eps_pdn_cntxt_update_ntw_overridden_eps_orig_params
               (eps_orig_params_p,pdn_cntx_p,ntw_overridden_ip);

    if (!result)
    {
      DS_LTE_MSG0_LOW("Returning Failure from orig_params");
      return FALSE;
    }
  }
  else
  {
    if(profile_p->context.pdp_type == DS_UMTS_PDP_IPV4)
    {
      eps_orig_params_p->pdn_type = NAS_ESM_IPV4;
    }
    else if(profile_p->context.pdp_type == DS_UMTS_PDP_IPV6)
    {
      eps_orig_params_p->pdn_type = NAS_ESM_IPV6;
    }
    else if (profile_p->context.pdp_type == DS_UMTS_PDP_IPV4V6)
    {
      if(ds3g_is_ipv6_enabled() == FALSE)
      {
        eps_orig_params_p->pdn_type = NAS_ESM_IPV4;
        DS_LTE_MSG0_HIGH("Updating the IP type to IPV4 only since IPV6 "
                         "NV is disabled");
        (void)ds_pdn_cntxt_update_apn_table(pdn_cntx_p->ds_pdn_context_dyn_p
                        ->pdp_profile.context.apn,DS_IPV4_ONLY, pdn_cntx_p); 
        pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type = 
            DS_UMTS_PDP_IPV4;
      }
      else
      {
         eps_orig_params_p->pdn_type = NAS_ESM_IPV4V6;
      }
    }
    else
    {
      DS_LTE_MSG1_ERROR("PDP type not supported. PDP type: %d",profile_p->context.pdp_type);
      return FALSE;
    }
  }

  /*-------------------------------------------------------------------------
    Fill in the PCO
  -------------------------------------------------------------------------*/
  memset(&(eps_orig_params_p->protocol_config_options),
         0, sizeof(protocol_cfg_options_T));
  /*-------------------------------------------------------------------------
    valid flag will be set by the pco subfunctions if they get called
  -------------------------------------------------------------------------*/
  eps_orig_params_p->protocol_config_options.valid = FALSE;
  eps_orig_params_p->protocol_config_options.config_protocol = 0;
  eps_orig_params_p->protocol_config_options.num_protocol_ids = 0;

  if((call_info_p->info_ptr != NULL) &&
     (((network_params_info_type *)(call_info_p->info_ptr))->valid_fields) )
  {
    ppp_info_p =  (network_params_info_type *) call_info_p->info_ptr;
  }
  /*  This is to handle Redial scenarios. Call_Info while redialing should
        not be taken from profile if valid info was requested by application 
        during call_origination. In redial scenarios Info_ptr will be NULL and 
        info_null Flag in PDN will be FALSE if Valid info is passed by APP
        */
  if((call_info_p->info_ptr == NULL) && 
     (pdn_cntx_p->ds_pdn_context_dyn_p->info_null == FALSE && 
     (pdn_cntx_p->ds_pdn_context_dyn_p->info.valid_fields)))
  {
    ppp_info_p = &(pdn_cntx_p->ds_pdn_context_dyn_p->info);
    DS_LTE_MSG0_HIGH("Redial Scenario, Using Cached Info from PDN ");
  }

  DS_LTE_MSG0_LOW("Fill PPP params ");
  result = ds_eps_pdn_ip_fill_ppp_params_from_info(
                    eps_orig_params_p,
                    profile_p,
                    ppp_info_p,
                    &auth_info_being_sent,
                    subs_id);

  if (result == FALSE)
  {
    DS_LTE_MSG0_LOW("Error in filling PPP parameters");
  }

  /*-----------------------------------------------------------------------
    Check if OP PCO contents would need to be populated, If so populate
    the OP PCO contents, query from ATP(only app for now)
  -------------------------------------------------------------------------*/
  fill_op_pco_ptr = ds_3gpp_op_pco_holder_search_apn_entry(pdn_cntx_p);

  if(fill_op_pco_ptr != NULL)
  {

    DS_3GPP_MSG0_ERROR("FILL OP PCO contents for LTE");

    (void)ds_pdn_cntxt_fill_oper_pco_info_from_app(
       &(eps_orig_params_p->protocol_config_options),fill_op_pco_ptr);

    pco_id_collision = ds_pdn_cntxt_check_op_pco_collision(profile_p,
                                                          fill_op_pco_ptr);
  }

  /*------------------------------------------------------------------------- 
    If PCO ID is collided, then there is no need to fill the profile contents
    for the same PCO ID.
    We can only have one PCO ID. This would mena configuration is incorrect
    ------------------------------------------------------------------------*/
  if((!pco_id_collision) && (ds_pdn_cntxt_fill_oper_pco_info_from_profile(
    &(eps_orig_params_p->protocol_config_options), profile_p) == DS3G_FAILURE))
{
    /*-------------------------------------------------------------------
      If an error occurs in encoding pkt, do not include the pkt but
      proceed with call If we return error here, call setup would fail and
      the user would'nt know why?  and all subsequent call attemtps for the
      PDP ctxt would also fail (using the same params)
    ------------------------------------------------------------------*/
    DS_LTE_MSG0_HIGH("Operator reserved Pco packet generation failed");

}

// 
#ifdef FEATURE_DATA_IMS
  /*-------------------------------------------------------------------------
    Get the request_pcscf_address_flag from profile registry to see if pcscf
    address should be requested for this profile.
  -------------------------------------------------------------------------*/
  /* Create a pcscf address request */
  if( ds_pdn_cntxt_gen_pcscf_address_request_packet(\
        &(eps_orig_params_p->protocol_config_options),
         profile_p ,
         subs_id) == DS3G_FAILURE )
  {
    /*-------------------------------------------------------------------
      If an error occurs in encoding pkt, do not include the pkt but
      proceed with call If we return error here, call setup would fail and
      the user would'nt know why?  and all subsequent call attemtps for the
      PDP ctxt would also fail (using the same params)
    ------------------------------------------------------------------*/
    DS_LTE_MSG0_HIGH("PCSCF Address request packet generation failed");
  }

  /*-------------------------------------------------------------------------
    Get the im_cn_flag from call table to see if im cn flag should be
    requested for this call.
  -------------------------------------------------------------------------*/
  if(profile_p->im_cn_flag == TRUE)
  {
    if( ds_bearer_cntxt_is_IMCN_call_up(subs_id) == TRUE)
    {
      DS_LTE_MSG0_ERROR("Call with IM CN Flag already up");
      return DS3G_FAILURE;
    }
    else
    {
      if(ds_pdn_cntxt_gen_im_cn_subsystem_request_packet(
          &(eps_orig_params_p->protocol_config_options)) == DS3G_FAILURE)
      {
        DS_LTE_MSG0_HIGH("IM CN flag generate failed.");
      }
      DS_LTE_MSG0_LOW("IM CN flag generate success");
    }
  }
#endif


  /*-------------------------------------------------------------------------
    Determine IP address allocation setting from the profile and fill the
    PCO accordingly
  -------------------------------------------------------------------------*/
  ds_pdn_cntxt_fill_address_alloc_param(
                               &(eps_orig_params_p->protocol_config_options),
                               profile_p);
#if defined(FEATURE_DATA_WCDMA_PS) || defined(FEATURE_GSM_GPRS)

    ds_pdn_cntxt_fill_bcm_indication(&(eps_orig_params_p->protocol_config_options));

#endif /* defined(FEATURE_DATA_WCDMA_PS) || defined(FEATURE_GSM_GPRS) */
  /*-------------------------------------------------------------------------
    Fill IPV4 Link MTU Request if profile pdp_type is IPV4 or IPV4V6
  --------------------------------------------------------------------------*/
  ds_pdn_cntxt_fill_ipv4v6_link_mtu_container
    (&(eps_orig_params_p->protocol_config_options), profile_p, subs_id);

  /*-------------------------------------------------------------------------
    Fill local address support in TFT container
  --------------------------------------------------------------------------*/
  ds_pdn_cntxt_fill_ipv4v6_local_address_support_container(
                               &(eps_orig_params_p->protocol_config_options),
                               profile_p);  

  /*-------------------------------------------------------------------------
    Fill in the APN Name
  -------------------------------------------------------------------------*/
  eps_orig_params_p->apn_name.valid = FALSE;
  memset(eps_orig_params_p->apn_name.address, 0, MAX_APN_ADR_LEN);

  /*-------------------------------------------------------------------------
    Start with a default APN
  -------------------------------------------------------------------------*/
  eps_orig_params_p->apn_name.apn_addr_len  = 0;

  //APN name should not be sent out for Emergency PDN requests.
  if (!DS_3GPP_PDN_SUPPORTS_EMERGENCY_SERVICES(pdn_cntx_p))
  {  
  apn_encoded_length = ds_pdn_cntxt_store_encoded_apn(
    eps_orig_params_p->apn_name.address, profile_p->context.apn);
  }

  DS_LTE_MSG1_HIGH("APN Name:length=%d", apn_encoded_length);

  if(apn_encoded_length > 1 )
  {
    eps_orig_params_p->apn_name.valid         = TRUE;

    /*-----------------------------------------------------------------------
      Fill the total length of the encoded APN
    -----------------------------------------------------------------------*/
    eps_orig_params_p->apn_name.apn_addr_len = apn_encoded_length;
  }

  /*-------------------------------------------------------------------------
    Initialize the ESM transfer flag and PCO ciphering flag to be FALSE
  -------------------------------------------------------------------------*/
  eps_orig_params_p->esm_info_transfer_flag = FALSE;
  eps_orig_params_p->pco_ciphering_flag = FALSE;

  /*-------------------------------------------------------------------------
    Fill in the esm_information. This is to be set only if we are sending APN
    name
  -------------------------------------------------------------------------*/
  if((!ds_pdn_cntxt_is_ue_attached(subs_id)) && 
       (apn_encoded_length > 1 || auth_info_being_sent))
  {
    eps_orig_params_p->esm_info_transfer_flag = TRUE;

    /*-------------------------------------------------------------------------
      Mark ciphering is needed if PAP is to be sent
    -------------------------------------------------------------------------*/
    if( auth_info_being_sent == TRUE)
    {
      eps_orig_params_p->pco_ciphering_flag = TRUE;
    }
  }

  return DS3G_SUCCESS;
} /* ds_eps_pdn_cntxt_getOrigParams */

/*===========================================================================
FUNCTION ds_eps_get_pdn_connectivity_msg()

DESCRIPTION
  Generates the protocol config options- PCO and other parameters used for
  the PDN connectivity message sent by ESM as part of the attach procedure.

PARAMETERS
  Pointer to pdn connection data to filled by DS EPS.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void ds_eps_get_pdn_connectivity_msg
(
  pdn_connection_data_T *pdn_connection_data_ptr
                                         /* Pointer to pdn connection data */
)
{

} /* ds_eps_get_pdn_connectivity_msg */

/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_REJECT_BEARER_ACTIVATION

DESCRIPTION
  This function is used to clean up the iface from PDN context when the
  network returns a pipe of an IP type that is not needed by the app.

  This functions dissociates the iface from PDN, dissociates the iface from
  bearer and phys link. It also enqueues a command to request connection to
  the same PDN with a different IP type.

PARAMETERS
  pdn_cntx_p  - Pointer to the PDN context
  ds_iface_p  - pointer to the DS Iface that has to be dissociated

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
LOCAL void ds_eps_pdn_cntxt_reject_bearer_activation
(
  ds_pdn_context_s  *pdn_cntx_p,
  ds_3gpp_iface_s   *ds_iface_p
)
{
  int              iface_index;
  ds_3gpp_iface_s  *ds_3gpp_iface_p;
  ds_cmd_type      *cmd_ptr = NULL;
  ds_pdn_context_s **data_ptr = NULL;
  sys_modem_as_id_e_type             subs_id = SYS_MODEM_AS_ID_NONE;
  ps_iface_down_mh_event_info_type   down_info;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
   if(ds_iface_p == NULL ||
      (ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p) == FALSE))
  {
    ASSERT(0);
    return;
  }

  if(!ds_3gpp_pdn_cntxt_get_subs_id_from_pdn(pdn_cntx_p, &subs_id))
  {
    return;
  }

  memset(&down_info, 0, sizeof(ps_iface_down_mh_event_info_type));
  down_info.down_reason = PS_NET_DOWN_REASON_REGULAR_DEACTIVATION;

  down_info.bearer_tech = pdn_cntx_p->ds_pdn_context_dyn_p->bearer_tech;

  if (down_info.bearer_tech.rat_value == DS_SYS_RAT_EX_NULL_BEARER)
  {
    down_info.bearer_tech.technology = DS_SYS_NETWORK_3GPP;
    down_info.bearer_tech.rat_value =
      ds_3gpp_map_sys_mode_to_ds_sys_rat
        (ds3gpp_get_current_network_mode(subs_id));
    down_info.bearer_tech.so_mask = ds_3gpp_bearer_cntxt_get_so_mask(subs_id);
  }
  
  /*-------------------------------------------------------------------------
    Post Phys link Down indication
  -------------------------------------------------------------------------*/
  if(!ds_bearer_cntx_validate_bearer_context((ds_bearer_context_s*)
                 (pdn_cntx_p->ds_pdn_context_dyn_p->def_bearer_context_ptr)))
  {
    DS_LTE_MSG0_ERROR("Bearer context passed is Invalid");
    return;
  }

  ps_phys_link_down_ind(
   &(((ds_bearer_context_s*)(pdn_cntx_p->ds_pdn_context_dyn_p->def_bearer_context_ptr))
     ->phys_link));

  /*-------------------------------------------------------------------------
    Post Iface Down indication on the iface that has to be dissociated
  -------------------------------------------------------------------------*/
  ps_iface_down_ind(&(ds_iface_p->ps_iface), &down_info);

  /*-------------------------------------------------------------------------
    Unbind the phys link and the default flow of both ifaces. This can be done
    by just calling ps_flow_go_null_ind
  -------------------------------------------------------------------------*/

  for(iface_index = 0;
      iface_index < DS_3GPP_MAX_IFACE_PER_PDN_CONTEXT;
      iface_index++)
  {
    ds_3gpp_iface_p = pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[iface_index];
    if (ds_3gpp_iface_p == NULL)
    {
      continue;
    }

    ps_flow_go_null_ind(PS_IFACE_GET_DEFAULT_FLOW(&(ds_3gpp_iface_p->ps_iface)),
                        PS_EIC_NOT_SPECIFIED);

    /*-----------------------------------------------------------------------
      Dissociate the PDN context from the DS Iface passed in
    -----------------------------------------------------------------------*/
    if(ds_iface_p == ds_3gpp_iface_p)
    {
      pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[iface_index] = NULL;
    }
  }/* for each Iface in the PDN context */


  /*-------------------------------------------------------------------------
    Remove the binding from DS Iface to the PDN context
  -------------------------------------------------------------------------*/
  ds_iface_p->client_data_ptr = NULL;

  /*-------------------------------------------------------------------------
    Mark the DS Iface as not in use
  -------------------------------------------------------------------------*/
  ds_iface_p->in_use = FALSE;


  /*-------------------------------------------------------------------------
    Post Phys link gone indication
  -------------------------------------------------------------------------*/
  ps_phys_link_gone_ind(
   &(((ds_bearer_context_s*)(pdn_cntx_p->ds_pdn_context_dyn_p->
                             def_bearer_context_ptr))->phys_link));

  /*-------------------------------------------------------------------------
    Free the bearer context and return it to the free pool
  -------------------------------------------------------------------------*/
  ds_bearer_cntxt_free_bearer_inst(
                   (ds_bearer_context_s*)pdn_cntx_p->ds_pdn_context_dyn_p
                   ->def_bearer_context_ptr);

  ds_bearer_cntxt_deregister_pdn_context(
                   (ds_bearer_context_s*)pdn_cntx_p->ds_pdn_context_dyn_p
                   ->def_bearer_context_ptr);

  ds_bearer_cntxt_return_bearer_to_free_pool(
                   (ds_bearer_context_s*)pdn_cntx_p->ds_pdn_context_dyn_p
                   ->def_bearer_context_ptr);

  /*-------------------------------------------------------------------------
    Enqueue a command to resend the PDN connectivity request.
  -------------------------------------------------------------------------*/
  cmd_ptr = ds_allocate_cmd_buf(sizeof(ds_pdn_context_s*));
  if( (cmd_ptr == NULL) || (cmd_ptr->cmd_payload_ptr == NULL) )
  {
    ASSERT(0);
    return;
  }

  cmd_ptr->hdr.cmd_id = DS_CMD_3GPP_PDN_CONN_REQ_RESEND;
  data_ptr = (ds_pdn_context_s**)cmd_ptr->cmd_payload_ptr;
  *data_ptr = pdn_cntx_p;

  ds_put_cmd_ext(cmd_ptr);

} /* ds_eps_pdn_cntxt_reject_bearer_activation */



/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_VALIDATE_PDN_REJECT

DESCRIPTION
  This function is used by check if PDN connectivity request corresponding
  to the specified APN needs to be blocked. The rejected PDN context's apn is
  compared with the apn_reject_sm's apn and if a match occurs the boolean
  to block a PDN is set. apn_reject_sm's APN is read from the EFS and if
  it is not populated the function returns FALSE.
  Based on the cause codes passed, appropriate action is taken.

PARAMETERS
  ds_pdn_context_s         *rejected_pdn_cntx_p,
  cm_call_mode_info_s_type *mode_info_p
 
DEPENDENCIES
  None.

RETURN VALUE
   True - If apn in attach_reject_sm is not populated.
   False - If apn in apn_reject_sm is populated.

SIDE EFFECTS
  None.

===========================================================================*/
boolean ds_eps_pdn_cntx_validate_pdn_reject
(
  ds_pdn_context_s         *rejected_pdn_cntx_p,
  cm_call_mode_info_s_type *mode_info_p
)
{
  boolean ret_val = FALSE;
  boolean result = FALSE;
  esm_cause_enum_T esm_cause = NAS_ESM_NO_FAILURE;
  sys_modem_as_id_e_type subs_id = SYS_MODEM_AS_ID_NONE;;
 /*- - - - - - - - - - - - -  - - - - - - - - - - - - - - - - - - - - - - -*/

  if(!ds_3gpp_pdn_cntx_validate_pdn_context(rejected_pdn_cntx_p))
  {
    return ret_val;
  }

  if(DS_3GPP_PDN_SUPPORTS_EMERGENCY_SERVICES(rejected_pdn_cntx_p) == TRUE)
  {
    DS_3GPP_MSG0_ERROR("Emergency pdn, dont throttle");
    return ret_val;
  }

  if (mode_info_p == NULL)
  {
    DS_LTE_MSG0_ERROR("Mode_info_p is NULL");
    return ret_val;
  }

  if(! ds_3gpp_pdn_cntxt_get_subs_id_from_pdn(rejected_pdn_cntx_p,&subs_id))
  {
    return ret_val;
  }

  /*----------------------------------------------------------------------- 
    Check if apn_reject_name is configured in the EFS, Here value is read
    from the cache and not from the EFS.
    -----------------------------------------------------------------------*/

  result = ds_3gpp_pdn_throt_validate_apn_reject_name(subs_id);

  if (!result)
  {
    DS_LTE_MSG0_HIGH("APN reject EFS NV is unset");
    return ret_val;
  }

  /*------------------------------------------------------------------------- 
    Check if the APN set in the EFS and APN in the rejected PDN context
    are the same. Also at this point set the return value to TRUE, No
    other PDN reject handling is necesessary beyond this point.
    Also if strcasecmp returns true, set the ret_val to TRUE.
  -------------------------------------------------------------------------*/
  if(strcasecmp((char*)ds_3gpp_pdn_throt_apn_reject_sm[subs_id].apn,
                (char*)rejected_pdn_cntx_p->
                ds_pdn_context_dyn_p->pdp_profile.context.apn) == 0)
  {
    ret_val = TRUE;

    DS_LTE_MSG0_LOW("Validate cause codes to perform APN reject throttling !");

    /*----------------------------------------------------------------------- 
    Extract the cause codes from call_info_p and determine what each cause
    code maps to
    ------------------------------------------------------------------------*/
    if (mode_info_p->info.lte_call.esm_cause.valid)
    {
      esm_cause = mode_info_p->info.lte_call.esm_cause.esm_cause;
      
      switch (esm_cause)
      {

        /*-------------------------------------------------------------------- 
          Perform Infinite throttling
         -------------------------------------------------------------------*/
        DS_3GPP_MSG1_MED("ESM cause code received is:%d",esm_cause);

        case NAS_ESM_UNKNOWN_PDN_TYPE:
        case NAS_ESM_REQ_SERV_OPT_NOT_SPECIFIED:

          result = ds_3gpp_pdn_throt_set_apn_reject_pdn_blocked(TRUE,subs_id);

          if(result)
          {
            DS_LTE_MSG0_HIGH("Permanent Failure: Setting pdn_blocked to:TRUE");
          }

          break;
       
        case NAS_ESM_OPTR_DETERMINED_BARRING:
        case NAS_ESM_INSUFFICIENT_RESOURCES:
        case NAS_ESM_UNKNOWN_MISSING_APN:
        case NAS_ESM_USER_AUTHENTICATION_FAILED:
        case NAS_ESM_OPN_REJ_SERVICING_GW_OR_PDN_GW:
        case NAS_ESM_ACTIVATION_REJECTED:
        case NAS_ESM_SERV_OPT_NOT_SUPPORTED:
        case NAS_ESM_SERV_OPT_TEMP_OUT_OF_ORDER:
        case NAS_ESM_NETWORK_FAILURE:
        case NAS_ESM_PDN_CONN_DOES_NOT_EXIST:
        case NAS_ESM_SYMANTICALLY_INVALID_MSG:
        case NAS_ESM_INVALID_MANDATORY_INFORMATION:
        case NAS_ESM_MSG_TYPE_NON_EXISTANT:
        case NAS_ESM_MSG_TYPE_INCOMPATIBLE_PROT_STATE:
        case NAS_ESM_INFO_ELEMENT_NON_EXISTANT:
        case NAS_ESM_CONDITIONAL_IE_ERR:
        case NAS_ESM_MSG_INCOMPATIBLE_WITH_PRO_STATE:
        case NAS_ESM_PROTOCOL_ERROR:

          result = ds_3gpp_pdn_throt_set_apn_reject_pdn_blocked(TRUE,subs_id);

          if(result)
          {
            DS_LTE_MSG0_HIGH("Temporary Failure: Setting pdn_blocked to:TRUE");
            ds_3gpp_pdn_throt_apn_reject_t3402_timer_start(subs_id);
          }

          break;

        default:
          DS_LTE_MSG0_LOW("No Throttling needed");
          break;
      }
    }
    else if(mode_info_p->info.lte_call.esm_local_cause.valid)
    {
      switch(mode_info_p->info.lte_call.esm_local_cause.local_cause)
      {
         case ESM_PROC_TIME_OUT:

          result = ds_3gpp_pdn_throt_set_apn_reject_pdn_blocked(TRUE,subs_id);

          if(result)
          {
            DS_LTE_MSG0_HIGH("Temporary Failure: Setting pdn_blocked to:TRUE");
            ds_3gpp_pdn_throt_apn_reject_t3402_timer_start(subs_id);
          }

          break;

         default:
          DS_LTE_MSG0_LOW("No Throttling needed");
          break;
      }
    }
    else
    {
      DS_LTE_MSG0_ERROR ("Both ESM local cause and ESM cause Valid flags are not set:"
                          " No timer value to be started");
    }
  }
  else
  {
    DS_3GPP_MSG0_HIGH("No APN throttling to be performed, APN match fails");
  }

  return ret_val;
}

/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_PDN_CONN_REJ_IND_HDLR

DESCRIPTION
  This function is used to handle the PDN connection reject indication.
  The only function that is to be done here is to update the APN table

  If a connection of the other IP type has already been made and if the APN
  table says that the APN supports single IP bearer, it has to be changed to
  the IP type of the existing call.

  Ex. V4 call was already made. APN table has Single IP bearer support for
  this APN. V6 call was rejected. Update the APN type to V4 only.

  Note: However when the V4 call goes away, we no longer have any info about
  the IP type of the APN. Hence when the V4 call goes away, we will send out
  a request of type V6 if a V6 app comes up.

PARAMETERS
  mode_info_ptr_i:  Mode specific information

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void ds_eps_pdn_cntxt_pdn_conn_rej_ind_hdlr
(
  ds_pdn_context_s         *rejected_pdn_cntx_p,
  cm_call_mode_info_s_type *mode_info_p
)
{
  esm_cause_enum_T                 esm_cause;
  uint16                           profiles_list[DS_3GPP_CFG_PROFILES_MAX + 1];
  int                              index;
  byte                             prof_apn_name[DS_UMTS_MAX_APN_STRING_LEN+1];
  ds_umts_pdp_profile_status_etype result;
  void*                            throt_sm_ptr = NULL;
  dsgwl_ps_call_info_u_type        *call_info = NULL;
  void                             *pdn_throt_sm_ptr = NULL;
  ps_iface_net_down_reason_type    v4_prev_failure_cause_code = 
                                   PS_NET_DOWN_REASON_NOT_SPECIFIED;
  ps_iface_net_down_reason_type    v6_prev_failure_cause_code = 
                                   PS_NET_DOWN_REASON_NOT_SPECIFIED;
  boolean                          api_return_val = DS3G_FAILURE;
  ps_iface_net_down_reason_type    ps_down_reason = 
                                   PS_NET_DOWN_REASON_NOT_SPECIFIED;
#ifdef FEATURE_DATA_REL10
  byte                             *apn = NULL;
  byte                             decoded_apn[DS_UMTS_MAX_APN_STRING_LEN];
#endif /*FEATURE_DATA_REL10*/
  boolean                          release_10_check = FALSE;
  boolean                          throttling_is_allowed = FALSE;
                                   /* throttling_is_allowed flag ensures that we 
                                      don't increment throttling counter for LTE
                                      Attach Failure scenarios if this is a VZW 
                                      configuration. */
  sys_modem_as_id_e_type            subs_id  = SYS_MODEM_AS_ID_NONE;
  boolean                           srv_req_throt_is_needed = FALSE;
  boolean                           srv_req_timeout = FALSE;
  boolean                           allow_infinite_throttling = FALSE;
  uint8                             max_active_pdn_context = 0;
  ds_3gpp_throt_rat_e_type          rat_type = DS_3GPP_THROT_RAT_GLOBAL;
                                    /* RAT on which throttling needs to
                                       be performed */
  ds_3gpp_pdn_throt_ident_info_type throt_ident_info;
  boolean                           perform_rel11_throt = FALSE;
  ds_bearer_context_s               *bearer_context_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&throt_ident_info, 0, sizeof(ds_3gpp_pdn_throt_ident_info_type));  

  if(! ds_3gpp_pdn_cntxt_get_subs_id_from_pdn(rejected_pdn_cntx_p,&subs_id))
  {
    return;
  }
  
  rejected_pdn_cntx_p->ds_pdn_context_dyn_p->apn_param_chg_teardown = FALSE;
  
  throttling_is_allowed = ( ds_eps_attach_sm_is_ue_attached(subs_id) ||
                            (ds_3gpp_nv_manager_get_reg_pdn_throttling(subs_id)) );

  if (ds_3gpp_nv_manager_get_enable_pdn_throt_per_rat(subs_id))
  {
    rat_type = DS_3GPP_THROT_RAT_LTE;
  }

  if(mode_info_p == NULL)
  {
    DS_LTE_MSG0_ERROR("Pdn Rej Ind: In Params Null. APN table could be wrong");
  }
  else
  {
    /*------------------------------------------------------------------------- 
      Check if a PDN corresponding to a particular APN needs to be throttled.
      The value of the apn is read from the EFS and if the ds_eps_apn_reject_sm's
      apn is populated, PDN corresponding to a particular APN will need to be
      throttled and returned.
      If api_return_val is TRUE it means no further throttling checks will be
      necessary.
      -------------------------------------------------------------------------*/
    api_return_val = ds_eps_pdn_cntx_validate_pdn_reject(rejected_pdn_cntx_p,mode_info_p);

    if (api_return_val)
    {
      DS_LTE_MSG0_HIGH("Return from ds_eps_pdn_cntxt_pdn_conn_rej_ind_hdlr becuase APN reject "
                        "throttling is set , No further throttling needed");
      return;
    }

    /*------------------------------------------------------------------------
      Check if the ESM cause is valid. If it is valid and is set to either of
      the three following values:
        NAS_ESM_PDN_TYPE_IPV4_ONLY_ALLOWED - 50
        NAS_ESM_PDN_TYPE_IPV6_ONLY_ALLOWED - 51
        MULTPL_PDN_CONN_TO_APN_NOT_ALLOWED - 55

      we have to update the APN table to reflect the correct IP support for
      the APN
    ------------------------------------------------------------------------*/
    if(mode_info_p->info.lte_call.esm_cause.valid)
    {
      esm_cause = mode_info_p->info.lte_call.esm_cause.esm_cause;

      ds_3gpp_pdn_throt_fill_ident_info
      (
         &throt_ident_info, 
         rejected_pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn,
         DS_3GPP_THROTTLE_TYPE_NOT_SPECIFIED,
         subs_id,
         FALSE,
         rat_type
      );

      pdn_throt_sm_ptr = 
        ds_3gpp_pdn_throt_sm_get_throttle_sm_per_rat(&throt_ident_info, FALSE);

      (void)ds_eps_bearer_cntxt_map_cause_codes(
        CALL_END_ESM_CAUSE_TO_PS_IFACE_CAUSE_CODES,
        &ps_down_reason,
        (const void*)mode_info_p
      );

      /*---------------------------------------------------------------------- 
        If Global throttling is enabled and cause code is #65/#66 and
        Rel 11 throttling is enabled fall into the REL 11 throttling category
        ----------------------------------------------------------------------*/
      if((ds_3gppi_is_rel_11_supported()) && 
         ((esm_cause == NAS_ESM_MAX_PDP_CONTEXT_REACHED) || 
         (esm_cause ==  NAS_ESM_APN_NOT_SUPPORTED_IN_PLMN_RAT_COMBINATION)))
      {
        DS_3GPP_MSG0_HIGH("REL11 fallback set");
        perform_rel11_throt = TRUE;
      }

    /*------------------------------------------------------------------------
       in the global throttling case also for cause codes 26,27 we have to do 
       release 10 throttling
      ------------------------------------------------------------------------*/
      if( ds_3gpp_nv_manager_get_global_throttling(subs_id) &&
          ((esm_cause!=NAS_ESM_INSUFFICIENT_RESOURCES) &&
           (esm_cause!=NAS_ESM_UNKNOWN_MISSING_APN))   &&
           !perform_rel11_throt)
      {
        DS_3GPP_MSG0_HIGH("Entered global throttling, non REL11");
        ds_3gpp_bearer_cntxt_global_throttling(rejected_pdn_cntx_p, 
                                               pdn_throt_sm_ptr,
                                               SYS_SYS_MODE_LTE,
                                               ps_down_reason );
      }
      else if((ds_3gpp_throt_sm_is_cc_sp_throttling_enabled(subs_id) == TRUE )&&
	      ((esm_cause!=NAS_ESM_INSUFFICIENT_RESOURCES) &&
               (esm_cause!=NAS_ESM_UNKNOWN_MISSING_APN)))             
      {
        ds_eps_pdn_throt_handle_pdn_conn_rej(rejected_pdn_cntx_p, esm_cause, subs_id);	
	return;
      }
      else
      {
        switch (esm_cause)
        {
          case NAS_ESM_PDN_TYPE_IPV4_ONLY_ALLOWED:
          /*---------------------------------------------------------------------
            Perform regular throttling on the rejected PDP type -- IPV6
            Recompute the IP support for the APN. Update APN table if necessary
            Save the overridden network type
          -----------------------------------------------------------------------*/
            DS_LTE_MSG1_HIGH("Perform regular throt on the rejected IP type:%d",
                              DS_UMTS_PDP_TYPE_IPV6);
  
            if (throttling_is_allowed)
            {
              ds_3gpp_pdn_throt_perform_reg_throttling(pdn_throt_sm_ptr,
              rejected_pdn_cntx_p, (void *)ps_down_reason,DS_UMTS_PDP_IPV6, 
              rat_type);
            }  
            ds_pdn_cntxt_recompute_ip_support_for_apn(rejected_pdn_cntx_p);
              /*------------------------------------------------------------------- 
              Network override handler has to kick in if
              1. REL version is REL 11 or
              2. SRV_REQ_THROT is not enabled
              -------------------------------------------------------------------*/
            if(ds_3gppi_is_rel_11_supported() ||
               (!ds_3gpp_throttle_is_srv_req_throttle_behavior_t3402_enabled(subs_id)))
            {
              ds_3gpp_network_override_hdlr_set_overridden_ip
                (rejected_pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn, 
                 PDP_IPV4, subs_id);
            }
            break;
          case NAS_ESM_PDN_TYPE_IPV6_ONLY_ALLOWED:
          /*---------------------------------------------------------------------
            Perform regular throttling on the rejected PDP type -- IPV4
              Recompute the IP support for the APN. Update APN table if necessary
          -----------------------------------------------------------------------*/
            DS_LTE_MSG1_HIGH("Perform regular throt on the rejected IP type:%d",
                               DS_UMTS_PDP_TYPE_IPV4);
  
            if (throttling_is_allowed)
            {
              ds_3gpp_pdn_throt_perform_reg_throttling(pdn_throt_sm_ptr,
              rejected_pdn_cntx_p,(void *)ps_down_reason,DS_UMTS_PDP_IPV4,
              rat_type);
            }  

            ds_pdn_cntxt_recompute_ip_support_for_apn(rejected_pdn_cntx_p);
  
            if(ds_3gppi_is_rel_11_supported() ||
               (!ds_3gpp_throttle_is_srv_req_throttle_behavior_t3402_enabled(subs_id)))
            {
              ds_3gpp_network_override_hdlr_set_overridden_ip
                (rejected_pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn, 
                 PDP_IPV6, subs_id);
            }
            break;
          /*-------------------------------------------------------------------- 
            The reception of PDN CONNECTIVITY REJECTS with the below set of ESM
            cause codes would result in throttling algoritm being applied
            to the particular PDN in a slightly different manner
          ---------------------------------------------------------------------*/
          case NAS_ESM_UNKNOWN_MISSING_APN:
#ifdef FEATURE_DATA_REL10
            if(ds_3gpp_nv_manager_get_nv_lte_rel_10(subs_id))
            {
              release_10_check = TRUE;
            }
#endif /*FEATURE_DATA_REL10*/  
          case NAS_ESM_OPTR_DETERMINED_BARRING: 
          case NAS_ESM_USER_AUTHENTICATION_FAILED:
          case NAS_ESM_SERV_OPT_NOT_SUPPORTED:
          case NAS_ESM_REQ_SERV_OPT_NOT_SPECIFIED:
          case NAS_ESM_APN_RESTRICT_VAL_INCOMPAT_WITH_ACT_CONTEXT:
          /*-------------------------------------------------------------------- 
            If the ptr is available get the last failure cause code stored
            for IPV4 and IPV6 from the core throttle sm by invoking the api
            ds_3gpp_pdn_throt_get_prev_cause_code().
            Once the cause codes are available, Compare the current cause
            codes being processed with the received cause codes, If the cause
            codes are the same then do INFINITE THROTTLING.
            If NULL or if NV is unset continue with the normal throttling
            algorithm 
          -------------------------------------------------------------------*/
            if (release_10_check == FALSE && throttling_is_allowed)
            {
              allow_infinite_throttling = ds_3gpp_nv_manager_get_allow_infinite_throttling(subs_id);
              if((pdn_throt_sm_ptr == NULL) || (!allow_infinite_throttling))
              {
                DS_LTE_MSG1_MED("Perform regular throttling, allow_infinite_throt:%d",
                                 allow_infinite_throttling);
      
                ds_3gpp_pdn_throt_perform_reg_throttling(pdn_throt_sm_ptr,
                rejected_pdn_cntx_p,(void *)ps_down_reason,rejected_pdn_cntx_p
                                                   ->ds_pdn_context_dyn_p->
                                                   pdp_profile.context.pdp_type,
                                                   rat_type);
              }
              else
              {
                api_return_val = ds_3gpp_pdn_throt_get_prev_cause_code(
                                              pdn_throt_sm_ptr,
                                              &v4_prev_failure_cause_code,
                                              &v6_prev_failure_cause_code);
      
                if(api_return_val)
                {
                  /*---------------------------------------------------------------- 
                    Check if the failure cause code must be set for IPV4 throttling
                    ----------------------------------------------------------------*/
                  if((rejected_pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type == 
                     DS_UMTS_PDP_IPV4)|| (rejected_pdn_cntx_p->
                     ds_pdn_context_dyn_p->pdp_profile.context.pdp_type ==  DS_UMTS_PDP_IPV4V6))
                  {
                    if(ps_down_reason == v4_prev_failure_cause_code)
                    {
                      DS_LTE_MSG2_HIGH(
                        "Starting INFINITE THROTTLING, esm_cause:%d, pdp_type:%d",
                        (int)v4_prev_failure_cause_code,
                        rejected_pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type);
                      
                      ds_3gpp_pdn_throt_handle_perm_conn_failure(pdn_throt_sm_ptr,
					  	                 (void *)ps_down_reason,
                                                                 DS_UMTS_PDP_IPV4,
                                                                 subs_id,
                                                                 rejected_pdn_cntx_p);
                      
                    }
                    else
                    {
                     /*------------------------------------------------------------------ 
                        Two consecutive cause codes received are diffent, Set the last
                        cause code received and perform regular throttling for IPV4
                      ------------------------------------------------------------------*/
                      DS_LTE_MSG0_HIGH("Set Failure Cause code and perform regular throt "
                                       " for IPV4");
      
                      ds_3gpp_pdn_throt_perform_reg_throttling(pdn_throt_sm_ptr,
                                                               rejected_pdn_cntx_p,
                                                               (void *)ps_down_reason,
                                                               DS_UMTS_PDP_IPV4,
                                                               rat_type);
      
                    } // IPV4 - Infinite throttling else case
                  } // IPV4 throttling sm check
                  /*---------------------------------------------------------------- 
                    Check if the failure cause code must be set for IPV6 throttling
                   ----------------------------------------------------------------*/
                  if((rejected_pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type == 
                     DS_UMTS_PDP_IPV6)|| (rejected_pdn_cntx_p->ds_pdn_context_dyn_p->
                                          pdp_profile.context.pdp_type ==  DS_UMTS_PDP_IPV4V6))
                  {
                    if(ps_down_reason == v6_prev_failure_cause_code)
                    {
                      DS_LTE_MSG2_HIGH(
                        "Starting INFINITE THROTTLING, esm_cause:%d, pdp_type:%d",
                        (int)v6_prev_failure_cause_code,
                      rejected_pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.
                        context.pdp_type);
                      
                      ds_3gpp_pdn_throt_handle_perm_conn_failure(pdn_throt_sm_ptr,
					  	                 (void *)ps_down_reason,
                                                                 DS_UMTS_PDP_IPV6,
                                                                 subs_id,
                                                                 rejected_pdn_cntx_p);
                    }
                    else
                    {
                     /*------------------------------------------------------------------ 
                        Two consecutive cause codes received are diffent, Set the last
                        cause code received and perform regular throttling for IPV6
                     ------------------------------------------------------------------*/
                     DS_LTE_MSG0_HIGH("Set Failure Cause code and perform regular throt "
                                      " for IPV6");
      
                     ds_3gpp_pdn_throt_perform_reg_throttling(pdn_throt_sm_ptr,
                                                              rejected_pdn_cntx_p,
                                                              (void *)ps_down_reason,
                                                              DS_UMTS_PDP_IPV6,
                                                              rat_type);
      
                    } // IPV6 - Infinite throttling else case
                  } // IPV6 throttling sm check
                }
                else
                {
                  DS_LTE_MSG0_ERROR("Failure to get last failure cause code, Perform"
                                    " regular throttling!");
      
                  ds_3gpp_pdn_throt_perform_reg_throttling(pdn_throt_sm_ptr,
                  rejected_pdn_cntx_p,(void *)ps_down_reason,rejected_pdn_cntx_p->
                                                           ds_pdn_context_dyn_p->
                                                           pdp_profile.context.pdp_type,
                                                           rat_type);
                 }
              } // PDN throttling SM check
            } /*release_10_check == FALSE && throttling_is_allowed*/
            break;
          /*-------------------------------------------------------------------- 
            The below set of ESM cause codes would result in throttling
            algoritm  being applied to the particular PDN on which the
            PDN CONNECTIVITY REJECT was received
          ---------------------------------------------------------------------*/
          case NAS_ESM_INSUFFICIENT_RESOURCES:
#ifdef FEATURE_DATA_REL10
            if(ds_3gpp_nv_manager_get_nv_lte_rel_10(subs_id))
            {
              release_10_check = TRUE;
            }
#endif /*FEATURE_DATA_REL10*/
          case NAS_ESM_OPN_REJ_SERVICING_GW_OR_PDN_GW:
          case NAS_ESM_ACTIVATION_REJECTED:
          case NAS_ESM_SERV_OPT_TEMP_OUT_OF_ORDER:
          case NAS_ESM_NETWORK_FAILURE:
          case NAS_ESM_INVALID_MANDATORY_INFORMATION:
          case NAS_ESM_PROTOCOL_ERROR:
          /* ------------------------------------------------------------------
             Support for Additional ESM cause codes ( Apr 2012 requirements)
          ---------------------------------------------------------------------*/
          case NAS_ESM_SYMANTICALLY_INVALID_MSG:
          case NAS_ESM_MSG_TYPE_NON_EXISTANT:
          case NAS_ESM_MSG_TYPE_INCOMPATIBLE_PROT_STATE:
          case NAS_ESM_INFO_ELEMENT_NON_EXISTANT:
          case NAS_ESM_CONDITIONAL_IE_ERR:
          case NAS_ESM_MSG_INCOMPATIBLE_WITH_PRO_STATE:
          case NAS_ESM_PTI_ALREADY_IN_USE:
  
          /*---------------------------------------------------------------- 
              Perform Regular Throttling and set the last failure cause code 
          
          ------------------------------------------------------------------*/
            if (release_10_check == FALSE && throttling_is_allowed)
            {
              ds_3gpp_pdn_throt_perform_reg_throttling(pdn_throt_sm_ptr,
              rejected_pdn_cntx_p,
              (void *)ps_down_reason,rejected_pdn_cntx_p->ds_pdn_context_dyn_p->
              pdp_profile.context.pdp_type, rat_type);
  
            }
            break;

	  case NAS_ESM_MAX_PDP_CONTEXT_REACHED:
            if( ds_3gpp_nv_manager_get_nv_lte_rel_version(subs_id) >= 
                LTE_3GPP_REL11 )
          {
              max_active_pdn_context
                = ds_3gpp_pdn_get_current_active_context(subs_id);
              DS_LTE_MSG2_HIGH("Max simultaneous PDP count %d on subs_id %d",
                               max_active_pdn_context, subs_id);
              ds_3gpp_pdn_set_max_simul_active_pdp_context(
                             max_active_pdn_context, subs_id);
          }
          break;

          case NAS_ESM_APN_NOT_SUPPORTED_IN_PLMN_RAT_COMBINATION:
            if( ds_3gpp_nv_manager_get_nv_lte_rel_version(subs_id) >= LTE_3GPP_REL11 )
            {
              /*---------------------------------------------------------------------
                if the network returns a cause (#66) permanently throttle that apn 
                The apn is unblocked only on sim removal and power reboot procedures
              ----------------------------------------------------------------------*/
              pdn_throt_sm_ptr = ds_3gpp_pdn_throt_sm_get_throttle_sm(
                              rejected_pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn,
                              FALSE,
                              TRUE,
                              DS_3GPP_THROTTLE_TYPE_NOT_SPECIFIED,
                              subs_id);

              ds_3gpp_pdn_throt_handle_perm_conn_failure(pdn_throt_sm_ptr,
                                                         (void *)ps_down_reason,
                                                          DS_UMTS_PDP_IPV4V6, 
                                                         subs_id,
                                                         rejected_pdn_cntx_p);
              ds_3gppi_throt_sm_set_current_sys_mode(pdn_throt_sm_ptr,
                                                     DS_UMTS_PDP_IPV4V6,
                                                     SYS_SYS_MODE_LTE);
            }
            break;

          default:
          // do nothing
            break;
        }
      }
#ifdef FEATURE_DATA_REL10
      do
      {
      /* release_10_check flag will be true only if FEATURE_DATA_REL10
         is enabled; nv item is  LTE_3GPP_REL10 and the cause code
         is one of the conflicting one.   */
      if (release_10_check == TRUE)
      {
        /*---------------------------------------------------------------- 
          Perform global APN throttling for these cause codes. Create a 
          PDN throt SM exclusively for globally throttling the given APN
          across all PLMNs.
        ------------------------------------------------------------------*/
        if(mode_info_p->info.lte_call.pdn_reject_ind.access_point_name.valid)
        {
          apn = mode_info_p->info.lte_call.pdn_reject_ind. \
                access_point_name.address;
          if (apn == NULL)
          {
            DS_LTE_MSG0_ERROR("APN ptr retrieved from pdn_reject_ind is NULL");
            break;
          }
          memset(decoded_apn, 0, DS_UMTS_MAX_APN_STRING_LEN);
          if(ds_3gpp_pdn_context_decode_apn_name_non_strict(apn,
                      (uint32)mode_info_p->info.lte_call. \
                      pdn_reject_ind.access_point_name.apn_addr_len,
                      decoded_apn) == TRUE)
          {
            apn = decoded_apn;
          }
          else
          {
            DATA_3GPP_MSG_SPRINTF_1(MSG_LEGACY_HIGH,"Unable to decode APN %s"
                                    ", Not doing any throttling", (char*)apn);
            break;
          }
          DATA_3GPP_MSG_SPRINTF_1(MSG_LEGACY_HIGH,
                                  "APN being throttled via pdn_rej_ind: %s",
                                  (char*)apn);
        }
        else
        {
          apn = rejected_pdn_cntx_p->ds_pdn_context_dyn_p->
                                     pdp_profile.context.apn;
          DATA_3GPP_MSG_SPRINTF_1(MSG_LEGACY_HIGH,
                                  "APN being throttled via pdn_ctxt_ptr: %s",
                                  (char*)apn);
        }

        ds_3gpp_pdn_throt_lte_handle_reject_with_t3396_ie(
                                                &mode_info_p->info.lte_call,
                                                apn, 
                                                ps_down_reason,
                                                subs_id,
                                                rejected_pdn_cntx_p);
      } /*release_10_check == TRUE*/
      }while(0);/*This while lets execution break out if there is an error*/
#endif /*FEATURE_DATA_REL10*/
    } // if cause code is valid

    /*--------------------------------------------------------------------------
      We also have to check if the cause code returned in local_cause reflects
      a condition where Acces Control List failure happened.
      There is a list of APN specified in the UICC and if a rejection happens
      because connection to an APN not present in the list was attempted, we
      have to disable LTE using the same CM API that is used in other cases
      In global throttling case there is no throttling for local cause codes
    --------------------------------------------------------------------------*/

    if ((!ds_3gpp_nv_manager_get_global_throttling(subs_id))&&
	    (!ds_3gpp_throt_sm_is_cc_sp_throttling_enabled(subs_id)))
    {
      if (mode_info_p->info.lte_call.emm_failure_cause.cause_type !=
            LTE_NAS_IRAT_NONE)
      {
        /* Map the EMM cause code so that we can send it to APM. */
      (void)ds_eps_bearer_cntxt_map_cause_codes(
           CALL_END_EMM_CAUSE_TO_PS_IFACE_CAUSE_CODES,
        &ps_down_reason,
           (const void*)mode_info_p);

        if (ds_eps_bearer_cntxt_examine_if_emm_cause_throt_needed 
             (&mode_info_p->info.lte_call,subs_id))
        {
          srv_req_throt_is_needed = TRUE;

          if (mode_info_p->info.lte_call.emm_failure_cause.cause_type ==
                LTE_NAS_IRAT_T3417_EXPIRY)
          {
            srv_req_timeout = TRUE;
          }

        } /* If Srv req throt is needed*/

      } /* If EMM Cause code is valid*/

      else if(mode_info_p->info.lte_call.esm_local_cause.valid)
      {
        /* Map the local cause code so that we can send it to APM. */
        (void)ds_eps_bearer_cntxt_map_cause_codes(
          CALL_END_ESM_CAUSE_TO_PS_IFACE_CAUSE_CODES,
          &ps_down_reason,
          (const void*)mode_info_p);

      switch(mode_info_p->info.lte_call.esm_local_cause.local_cause)
      {
        case ACL_FAILURE:
        {
          DS_LTE_MSG0_HIGH("ACL check failure indicated by lower layers");
          /*--------------------------------------------------------------------
            Get the Min APN list from EFS. If this item does not exist, there is
            no need to detach
          --------------------------------------------------------------------*/
          if(ds_3gpp_cfg_get_subsid(DS_3GPP_CFG_PROFILE_LIST,
                             (unsigned char *) &profiles_list[0],
                             (sizeof(uint16) * DS_3GPP_CFG_PROFILES_MAX),
                             subs_id)== -1)
          {
            DS_LTE_MSG0_HIGH("Cannot get MIN APN LIST. Not detaching");
            break;
          }

          if(profiles_list[0] >=  DS_3GPP_CFG_PROFILES_MAX)
          {
            DS_LTE_MSG0_HIGH("Invalid Min APN list. Not detaching");
            break;
          }

          for(index = 1; index <= profiles_list[0]; index++)
          {
            if(ds_3gpp_profile_cache_get_cache_index(profiles_list[index], 
                                  dsumts_subs_mgr_get_subs_id(subs_id)) == -1)
            {
              DS_LTE_MSG1_ERROR("Invalid prof number: %d in Min APN list. Cont",
                                profiles_list[index]);
              continue;
            }

            /*------------------------------------------------------------------
              Memset the local APN name buffer before poking into each profile
            ------------------------------------------------------------------*/
            memset(prof_apn_name,0,DS_UMTS_MAX_APN_STRING_LEN+1);

            result = ds_umts_get_pdp_profile_context_info_apn_per_subs(
                                                           profiles_list[index],
                                                 dsumts_subs_mgr_get_subs_id(subs_id),
                                                                  prof_apn_name,
                                                    DS_UMTS_MAX_APN_STRING_LEN);
            if( result != DS_UMTS_PDP_SUCCESS )
            {
              DS_LTE_MSG2_ERROR("Err %d in getting APN info. Prof: %d. Cont.",
                                 result,profiles_list[index]);
              continue;
            }

            if(strcasecmp((char*)prof_apn_name,
                           (char*)rejected_pdn_cntx_p->ds_pdn_context_dyn_p->
                          pdp_profile.context.apn) == 0)
            {
              DS_LTE_MSG0_HIGH("APN listed in MIN APN list. Disabling LTE");
              ds3g_msh_disable_lte_selection_ex(subs_id);
              break;
            }
            else
            {
              DS_LTE_MSG1_HIGH("APN diff from name listed in prof: %d. Cont.",
                               profiles_list[index]);
            }
          } //loop through the min apn list

          break;
        } // ACL failure

        case ESM_PROC_TIME_OUT:
        {
          if (throttling_is_allowed)
          {
            /*--------------------------------------------------------------------
              Now perform a check to see if the minimum throt failure cnt has been
              set, (DS_EPS_PDN_CNTX_MIN_THROT_FAILURE_CNT) - 1) is passed because 
              ds_3gpp_pdn_throt_perform_reg_throttling increments the throttle
              count by one before starting the throttle timer.
              --------------------------------------------------------------------*/
              ds_3gpp_pdn_throt_validate_min_failure_count(rejected_pdn_cntx_p,
              rejected_pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type,
              (DS_EPS_PDN_CNTX_MIN_THROT_FAILURE_CNT) - 1, rat_type);
  
              ds_3gpp_pdn_throt_perform_reg_throttling(pdn_throt_sm_ptr,
                rejected_pdn_cntx_p,(void *)ps_down_reason,rejected_pdn_cntx_p->
                ds_pdn_context_dyn_p->pdp_profile.context.pdp_type, rat_type);

          }
          break;
        }
        
          default:
          {
            DS_LTE_MSG1_HIGH("No Throttling performed,Local cause code is %d",
                              mode_info_p->info.lte_call.esm_local_cause.local_cause);
            break;
          }
        }//switch on the local cause
      } //If ESM local cause is valid
       
      if (srv_req_throt_is_needed && 
          (!DS_3GPP_PDN_SUPPORTS_EMERGENCY_SERVICES(rejected_pdn_cntx_p)))
        {
        DS_LTE_MSG0_HIGH("Service req throt is needed");
          /*--------------------------------------------------------------------
            Allocate memory for the container in which we are going to copy the 
            LTE call params we got from CM.
          --------------------------------------------------------------------*/
          call_info = (dsgwl_ps_call_info_u_type *)modem_mem_alloc(
                                     sizeof(dsgwl_ps_call_info_u_type),
                                     MODEM_MEM_CLIENT_DATA_CRIT);
          if(call_info == NULL)
          {
            DS_LTE_MSG2_LOW("Heap Memory Allocation failed for client: %d size: %d",
                              MODEM_MEM_CLIENT_DATA,
                             (sizeof(dsgwl_ps_call_info_u_type)));
            ASSERT(0);
            return;
          }
          else
          {
            memset((void*)call_info, 0, sizeof(dsgwl_ps_call_info_u_type));
          }

          /*--------------------------------------------------------------------
            Copy the contents of LTE_CALL_INFO from the CM object to this
            container object
          --------------------------------------------------------------------*/
          memscpy((void*)&(call_info->lte_call),
                  sizeof(call_info->lte_call),
                  (void*)&(mode_info_p->info.lte_call),
                  sizeof(cm_lte_call_info_s_type));

            /*------------------------------------------------------------------
              Get a handle to the service request throttling state machine. Make
              sure that a core sm is created if it does not exist. This is coz
              we need to feed failure. If we were only querying some info, we
              need not create SM if it does not exist
            ------------------------------------------------------------------*/
            throt_sm_ptr = ds_3gpp_throt_sm_get_throttling_sm(TRUE, 
                                                              subs_id);

            if(throt_sm_ptr != NULL)
            {
              DS_LTE_MSG0_HIGH("Got Srv req throt sm. Feeding Failure");
              /*--------------------------------------------------------------------
              Now perform a check to see if the minimum throt failure cnt has been
              set, (DS_EPS_PDN_CNTX_MIN_THROT_FAILURE_CNT) - 1) is passed because 
              ds_3gpp_throt_sm_feed_failure increments the throttle
              count by one before starting the throttle timer.				 
              --------------------------------------------------------------------*/
              if (srv_req_timeout &&
                  ds_dsd_apm_is_apn_switch_support(subs_id))
              {
              ds3gpp_enter_global_crit_section();
              ds_3gpp_throt_sm_validate_min_failure_count(throt_sm_ptr, 
                                 subs_id, 
                   (DS_EPS_PDN_CNTX_MIN_THROT_FAILURE_CNT - 1));
              ds3gpp_leave_global_crit_section();  						  
              }
              ds_3gpp_throt_sm_feed_failure(throt_sm_ptr,
                                            subs_id,
                                            rejected_pdn_cntx_p);
            }
            else
            {
              DS_LTE_MSG0_LOW("Cannot get throt sm. Not throttling");
            } //if throt sm was available

          /*------------------------------------------------------------------
            Free the memory allocated for call_info
          -------------------------------------------------------------------*/
          modem_mem_free((void *)call_info, MODEM_MEM_CLIENT_DATA_CRIT);
      } /* Srq req throt is needed*/
      else
      {
        DS_LTE_MSG0_LOW("Service req throt is not needed");
      } /* Srq req throt is not needed*/

    } /* Global throttling is not enabled*/
  } /* Mode info ptr is not NULL*/
   
  ds_3gpp_pdn_throt_advertise_blocked_apns_current_plmn(subs_id);
#ifdef FEATURE_DATA_LTE
  ds_3gpp_pdn_cntxt_disable_lte_if_attach_profile_unavailable(subs_id);
#endif /* FEATURE_DATA_LTE */
 
    /*-----------------------------------------------------------------
      We need to check for APN Switching action if this is last standing
      PDN 
    ------------------------------------------------------------------*/
  if ( (FALSE == dsPdnContext_is_any_other_normal_pdn_up(rejected_pdn_cntx_p, subs_id))&&
       (TRUE == (ds_pdn_cntxt_is_default(rejected_pdn_cntx_p)))
     )
  {
    bearer_context_ptr = rejected_pdn_cntx_p->ds_pdn_context_dyn_p->
                              def_bearer_context_ptr;
    if(ds_bearer_cntx_validate_bearer_context(bearer_context_ptr))
    {
      ds_3gpp_apn_switch_mgr_populate_switching_payload_per_rat(
          bearer_context_ptr->ds_bearer_context_dyn_p->call_mode, 
          DS_DSD_APM_REJECT_NETWORK_CAUSE,
          (uint16)rejected_pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile_num,
          rejected_pdn_cntx_p->ds_pdn_context_dyn_p->state,
          &(mode_info_p->info),subs_id);  
    }
    else
    {
      DS_LTE_MSG1_ERROR("Invalid bearer context:0x%x, couldnt post reject ind",
                         bearer_context_ptr);
    }
  }


} /* ds_eps_pdn_cntxt_pdn_conn_rej_ind_hdlr */

/*===========================================================================
FUNCTION  ds_eps_pdn_cntxt_handle_dedicated_bearer_activation

DESCRIPTION
  This function handles the EPS bearer setup of a dedicated bearer.

PARAMETERS
  mode_info_ptr_i:  Mode specific information
  cm_act_res_p : CM response information.
  lte_info_ptr : LTE specific mode information.
  bearer_cntx_p : Bearer context to activate.
  subs_id       : Subscription id

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/

static boolean ds_eps_pdn_cntxt_handle_dedicated_bearer_activation
(
  cm_call_id_type                  call_id,
  const cm_call_mode_info_s_type   *mode_info_ptr_i,
  cm_act_bearer_rsp_s_type         *cm_act_res_p,
  cm_lte_call_info_s_type          *lte_info_ptr,
  ds_bearer_context_s              *bearer_cntx_p,
  sys_modem_as_id_e_type            subs_id
)

{
  ds_pdn_context_s               *pdn_cntx_p = NULL;
  ds_pdn_context_s               *pdn_cntx_awaiting_bearer_alloc_p = NULL;
  ds_bearer_context_s            *def_bearer_cntx_p = NULL;
  int                             ret_val = 0;
  int16                           ds_errno =0;
  boolean                         result = DS3G_SUCCESS;

  /*---------------------------------------------------------------------
    Verify if the default bearer exists.
  -----------------------------------------------------------------------*/
  def_bearer_cntx_p = 
    ds_bearer_cntxt_get_bearer_from_eps_id(lte_info_ptr->lbi, subs_id);

  if(!ds_bearer_cntx_validate_bearer_context(def_bearer_cntx_p))
  {
    DS_LTE_MSG2_ERROR("Default bearer does not exist: lbi=%d bearer_id=%d",
                      lte_info_ptr->lbi, lte_info_ptr->eps_bearer_id);

    DS_EPS_SET_ESM_CAUSE(lte_info_ptr, NAS_ESM_UNKNOWN_EPS_BEARER_CONTEXT);    
    return DS3G_FAILURE;
  }

  /*---------------------------------------------------------------------
    Retrieve the PDN Associated with default bearer.
  -----------------------------------------------------------------------*/
  pdn_cntx_p = def_bearer_cntx_p->ds_bearer_context_dyn_p->pdn_context_ptr;

  if(!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
  {
    return DS3G_FAILURE;
  }

  if (DS_3GPP_PDN_SUPPORTS_EMERGENCY_SERVICES(pdn_cntx_p))
  {
     cm_act_res_p->is_emergency_bearer = TRUE;
  }

  /*-------------------------------------------------------------------------
    Ensure that the PDN state is correct. If the PDN state is in GOING_DOWN,
    then we have to reject the bearer activation.
    As a result of rejecting bearer activation, we will get a CALL_END from
    CM during which we clean up our resources.
  -------------------------------------------------------------------------*/
  if(pdn_cntx_p->ds_pdn_context_dyn_p->state == DS_PDN_CONTEXT_STATE_GOING_DOWN)
  {
    DS_LTE_MSG0_HIGH("Got Activate Bearer Indication while PDN going down - Rejecting");

    /*----------------------------------------------------------------------
      We might not have allocated a bearer context for (in case of N/w init
      QOS bearer being set up
    ----------------------------------------------------------------------*/
    if(ds_bearer_cntx_validate_bearer_context(bearer_cntx_p))
    {
      /*----------------------------------------------------------------------
        This is a UE init QOS call. The PDN context is going down. So set the
        state of the dedicated bearer also accordingly. Vamsi to correct this
        if needed
      ----------------------------------------------------------------------*/
      ds_bearer_cntxt_set_bearer_state(bearer_cntx_p,
                                   DS_BEARER_CONTEXT_STATE_GOING_DOWN);
    }

    return DS3G_FAILURE;

  } /* If PDN context is in going down */


  /*---------------------------------------------------------------------
    Verify if this is the default bearer for the associated PDN.
  -----------------------------------------------------------------------*/
  if(def_bearer_cntx_p !=(ds_bearer_context_s *)pdn_cntx_p->ds_pdn_context_dyn_p
     ->def_bearer_context_ptr)
  {
    DS_LTE_MSG2_ERROR("Invalid Linked bearer ID passed lbi:%d, bearer_id: %d",
                      lte_info_ptr->lbi, lte_info_ptr->eps_bearer_id);
    DS_EPS_SET_ESM_CAUSE(lte_info_ptr, NAS_ESM_UNKNOWN_EPS_BEARER_CONTEXT);       
    return DS3G_FAILURE;
  }

  /*---------------------------------------------------------------------
    Verify if the dedicated bearer exists.
  -----------------------------------------------------------------------*/
  bearer_cntx_p =
    ds_bearer_cntxt_get_bearer_from_eps_id(lte_info_ptr->eps_bearer_id, subs_id);

  if(bearer_cntx_p != NULL)
  {
    DS_LTE_MSG2_ERROR("Dedicated bearer already exists:lbi=%d bearer_id=%d",
                      lte_info_ptr->lbi, lte_info_ptr->eps_bearer_id);
    DS_EPS_SET_ESM_CAUSE(lte_info_ptr, NAS_ESM_SEMANTIC_ERR_IN_TFT_OPERATION);           
    return DS3G_FAILURE;
  }

  /*------------------------------------------------------------------------- 
    Do not allocate bearer resources if there is any PDN 
    already awaiting free bearer resources unless its an emergency PDN
    (or) the same PDN itself requesting for dedicated bearer activation.
  -------------------------------------------------------------------------*/
  pdn_cntx_awaiting_bearer_alloc_p = ds_3gpp_get_pdn_cntxt_awaiting_bearer_allocation(subs_id);
  if ((pdn_cntx_awaiting_bearer_alloc_p != NULL)&&
      (!DS_3GPP_PDN_SUPPORTS_EMERGENCY_SERVICES(pdn_cntx_p))&&
      (pdn_cntx_awaiting_bearer_alloc_p !=pdn_cntx_p))
  {
    DS_EPS_SET_ESM_CAUSE(lte_info_ptr, NAS_ESM_INSUFFICIENT_RESOURCES);                 
    return DS3G_FAILURE; 
  }
    /*-----------------------------------------------------------------------
      Get a bearer by calling the alloc function.
    -----------------------------------------------------------------------*/
    bearer_cntx_p = ds_bearer_cntxt_allocate_new_bearer(subs_id);
    
    if(!ds_bearer_cntx_validate_bearer_context(bearer_cntx_p))
    {
      DS_EPS_SET_ESM_CAUSE(lte_info_ptr, NAS_ESM_INSUFFICIENT_RESOURCES);                 
      return DS3G_FAILURE;
    }

    /*----------------------------------------------------------------------
      Update the bearer information
    ---------------------------------------------------------------------*/
  if (ds_pdn_cntxt_store_bearer_context(pdn_cntx_p,(void *)bearer_cntx_p) != DS3G_SUCCESS)
    {
      DS_LTE_MSG0_HIGH("Could not store the allocated bearer");
      ds_bearer_cntxt_return_bearer_to_free_pool(bearer_cntx_p);
      DS_EPS_SET_ESM_CAUSE(lte_info_ptr, NAS_ESM_INSUFFICIENT_RESOURCES);        
      return DS3G_FAILURE;
    }

    /*-------------------------------------------------------------------------
      Invoke the flow manager call activation function to handle bearer
      activation indication
    -------------------------------------------------------------------------*/
    result = ds_flow_manager_nw_bearer_allocation_ind(
                                                  pdn_cntx_p,
                                                  bearer_cntx_p,
                                                  mode_info_ptr_i);
    if(result == DS3G_FAILURE)
    {
      DS_LTE_MSG0_LOW("Error in accepting the passed flow params");
      /*-------------------------------------------------------------------
         The first call will set the in_use to FALSE.
         The second call will clean up the bearer details.
      ---------------------------------------------------------------------*/
      
      ds_bearer_cntxt_free_bearer_inst(bearer_cntx_p);

      if(ds_pdn_cntxt_release_bearer_context(pdn_cntx_p,(void *)bearer_cntx_p) 
       != DS3G_SUCCESS)
      {
        DS_LTE_MSG0_LOW("could not release the allocated bearer");
      }
      ds_bearer_cntxt_return_bearer_to_free_pool(bearer_cntx_p);
      return DS3G_FAILURE;
    }

      /*-------------------------------------------------------------------
        Register this bearer with the PDN context. Set is_default as false.
      -------------------------------------------------------------------*/
      ds_bearer_cntxt_register_pdn_context(
                                      pdn_cntx_p,
                                      bearer_cntx_p,
                                      FALSE
                                    );


      /*---------------------------------------------------------------------
        Store the CM call id in the bearer context. not needed here
      ----------------------------------------------------------------------*/
      ds_bearer_cntxt_store_call_id(bearer_cntx_p, call_id);

      ret_val = ps_phys_link_up_cmd(&bearer_cntx_p->phys_link,
                           &ds_errno, NULL);

      if (ret_val == 0)
      {
        DS_LTE_MSG0_ERROR(" Bringing up phys link when already up Inst:");
      }
      else if ( ds_errno != DS_EWOULDBLOCK)
      {
        DS_LTE_MSG0_LOW(" Unsupported errno value returned");
        ds_bearer_cntxt_free_bearer_inst(bearer_cntx_p);
        if(ds_pdn_cntxt_release_bearer_context(pdn_cntx_p,(void *)bearer_cntx_p) 
       != DS3G_SUCCESS)
        {
          DS_LTE_MSG0_LOW("could not release the allocated bearer");
        }
        ds_bearer_cntxt_return_bearer_to_free_pool(bearer_cntx_p);
    DS_EPS_SET_ESM_CAUSE(lte_info_ptr, NAS_ESM_ACTIVATION_REJECTED);        
        return DS3G_FAILURE;
      }



      // Increment the number of active bearer contexts in the PDN
      pdn_cntx_p->ds_pdn_context_dyn_p->num_active_bearer_context++;

      /*-------------------------------------------------------------------------
       Fill in compression parameters.
      -------------------------------------------------------------------------*/
      ASSERT(cm_act_res_p != NULL);

      cm_act_res_p->h_comp = ds_pdn_cntxt_conv_header_comp_from_pdp_t_to_sys_t(
                                      &pdn_cntx_p->ds_pdn_context_dyn_p->
                                      pdp_profile.context.h_comp);
      cm_act_res_p->d_comp = ds_pdn_cntxt_conv_data_comp_from_pdp_t_to_sys_t(
                                      &pdn_cntx_p->ds_pdn_context_dyn_p->
                                      pdp_profile.context.d_comp);

      return DS3G_SUCCESS;

}
/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_BEARER_ACTIVATE_IND

DESCRIPTION
  This function accepts or rejects the the EPS bearer activate request.

PARAMETERS
  Call_id:          CM assigned Call ID.
  mode_info_ptr_i:  Mode specific information
  subs_id:          Subscription Id

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static boolean ds_eps_pdn_cntxt_bearer_activate_ind
(
  cm_call_id_type                  call_id,
  const cm_call_mode_info_s_type   *mode_info_ptr_i,
  cm_act_bearer_rsp_s_type         *cm_act_res_p,
  sys_modem_as_id_e_type           subs_id
)
{
  const cm_call_mode_info_s_type     *mode_info_p = mode_info_ptr_i;
  ds_pdn_context_s                   *pdn_cntx_p = NULL;
  ds_bearer_context_s                *bearer_cntx_p = NULL;
  boolean                             result = DS3G_SUCCESS;
  ds_umts_pdp_profile_type           *profile_ptr = NULL;
  cm_lte_call_info_s_type            *lte_info_ptr = NULL;
  ds_3gpp_iface_s                    *ds_iface_v4_p = NULL;
  ds_3gpp_iface_s                    *ds_iface_v6_p = NULL;
  ps_iface_type                      *other_ps_iface_p = NULL;
  ds_apn_ip_support_type_e           ip_support = DS_IPV4_ONLY;
  ds_bearer_flow_manager_s           *bflow_manager_p = NULL;
  ds_flow_manager_s                  *flow_manager_p = NULL;
  ds_eps_flow_manager_s              *eps_flow_manager_p = NULL;
  ds_umts_pdp_addr_type              ds_3gpp_pdp_addr;
  const protocol_cfg_options_T       *protocol_config_options_p;
  byte                               decoded_apn[DS_UMTS_MAX_APN_STRING_LEN];
  byte                               apn_network_identifier[DS_UMTS_MAX_APN_STRING_LEN];

  void                               *sm_ptr;
  ps_iface_net_down_reason_type      ps_down_reason = 
                                     PS_NET_DOWN_REASON_NOT_SPECIFIED;
  uint8                              resolved_apn_index = 
                                     DS_3GPP_PDN_LIMIT_TBL_INVALID_ENTRY;
  uint8                              index = DS_3GPP_PDN_LIMIT_TBL_INVALID_ENTRY;
  ds_eps_attach_sm_s                 *attach_sm_ptr = NULL;
  ds_3gpp_internal_cause_code_enum_type icause_code;
  ds_dsd_apm_ind_pay_load            ind_payload;
  ds_flow_manager_s                  *flow_manager_ptr;
  boolean                            decode_apn_result = FALSE;
  ps_sys_null_resolved_apn_info_type resolved_apn;
  int16                              ps_errno = -1;
  ds3geventmgr_filter_type           filter_info;

#ifdef FEATURE_DATA_REL11
  void                            *pdn_throt_sm_ptr = NULL;
  uint8                            max_active_bearer_context = 0;
#endif 
/* FEATURE_DATA_REL11 */
  uint32                             rat_mask = DS_3GPP_THROT_RAT_MASK_GLOBAL;
                                    /* RATs on which throttling needs to
                                       be unblocked */
  ds_3gpp_throt_rat_e_type           rat_type =  DS_3GPP_THROT_RAT_GLOBAL;
                                    /* RAT on which throttling needs to
                                       be performed */
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  memset(&ind_payload, 0, sizeof(ds_dsd_apm_ind_pay_load));

  icause_code = DS_3GPP_INTERNAL_CC_INVALID;
  if ( mode_info_p == NULL )
  {
    DATA_ERR_FATAL("mode_info_p=NULL in pdnCntxBearerActivatedInd");
    return DS3G_FAILURE;
  }

  /*-------------------------------------------------------------------------
    get the LTE info
  -------------------------------------------------------------------------*/
  lte_info_ptr =(cm_lte_call_info_s_type *)&(mode_info_ptr_i->info.lte_call);

  if (ds_3gpp_nv_manager_get_enable_pdn_throt_per_rat(subs_id))
  {
    rat_type = DS_3GPP_THROT_RAT_LTE;
    rat_mask |= DS_3GPP_THROT_RAT_MASK_LTE;
  }

  /*-------------------------------------------------------------------------
    Get the bearer context and the PDN context based on whether this is a
    UE init call or a n/w init call
  -------------------------------------------------------------------------*/
  bearer_cntx_p = ds_bearer_cntxt_get_bearer_from_call_id(call_id);

  if(ds_bearer_cntx_validate_bearer_context(bearer_cntx_p))
  {
    /*-------------------------------------------------------------------------
      We already have a bearer allocated for this call. Hence this is a UE init
      call (could be default or QOS)
    -------------------------------------------------------------------------*/
    pdn_cntx_p = (ds_pdn_context_s*)bearer_cntx_p->ds_bearer_context_dyn_p->
      pdn_context_ptr;
    
    if(!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
    {
      ds_bearer_cntxt_set_bearer_state(bearer_cntx_p,
                                     DS_BEARER_CONTEXT_STATE_GOING_DOWN);
      return DS3G_FAILURE;
    }

    /*--------------------------------------------------------------------------
      Get the throttling state macine and reset it. NULL checking need not be
      performed here as there is no dereferencing of the opaque handle in this
      function
      Call this function with argument FALSE meaning we need not create a sm
      if it does not already exists. Here we are interested in only retrieving
      the SM for reset
     --------------------------------------------------------------------------*/
    sm_ptr = ds_3gpp_throt_sm_get_throttling_sm(FALSE, subs_id);

    ds_3gpp_throt_sm_reset(sm_ptr, subs_id);

  /*------------------------------------------------------------------------ 
    Set apn_param_chg_teardown to FALSE
    ------------------------------------------------------------------------*/
    pdn_cntx_p->ds_pdn_context_dyn_p->apn_param_chg_teardown = FALSE;

    attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(subs_id);
    if(attach_sm_ptr == NULL)
    {
      DS_LTE_MSG1_LOW("Invalid Attach SM ptr for Subs Id (CM) %d",subs_id);
      ds_bearer_cntxt_set_bearer_state(bearer_cntx_p,
                                     DS_BEARER_CONTEXT_STATE_GOING_DOWN);
      return DS3G_FAILURE;
    }
    attach_sm_ptr->is_gw_originated = FALSE;

    /*----------------------------------------------------------------------- 
      Set the emergency bearer flag if the activate bearer indication is
      received for Emergency PDN connection
      -----------------------------------------------------------------------*/
    if (DS_3GPP_PDN_SUPPORTS_EMERGENCY_SERVICES(pdn_cntx_p) &&
        cm_act_res_p != NULL)
    {
      cm_act_res_p->is_emergency_bearer = TRUE;      
    }
    /*-------------------------------------------------------------------------
      get the pointer to the profile in the PDN context.
    -------------------------------------------------------------------------*/
    profile_ptr = &(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile);

    /*-------------------------------------------------------------------------
      Ensure that the PDN state is correct. If the PDN state is in GOING_DOWN,
      then we have to reject the bearer activation.
      This is a case of a race between the Abort PDN connectivity handling and
      the handling of Activate Bearer Ind. In such a case, we will reject the
      bearer activation and not send out an abort. As a result of rejecting
      bearer activation, we will get a CALL_END from CM during which we clean up
      our resources.
    -------------------------------------------------------------------------*/
    if(pdn_cntx_p->ds_pdn_context_dyn_p->state == DS_PDN_CONTEXT_STATE_GOING_DOWN)
    {
      DS_LTE_MSG0_HIGH("Got Activate Bearer Indication while PDN going down - Rejecting");

      ds_bearer_cntxt_set_bearer_state(bearer_cntx_p,
                                     DS_BEARER_CONTEXT_STATE_GOING_DOWN);
      return DS3G_FAILURE;

    } /* If PDN context is in going down */
    if(bearer_cntx_p->ds_bearer_context_dyn_p->is_default == TRUE)
    {
      flow_manager_ptr = ds_flow_manager_find_flow_manager(pdn_cntx_p);
      if(ds_flow_manager_validate_flow_manager(flow_manager_ptr))
      {
      /** Primary set to MS only by default **/
         DS_3GPP_MSG0_HIGH("BCM_info primary to UE only");
         flow_manager_ptr->ds_flow_manager_dyn_p->bcm_info = DS_3GPP_BCM_UE_ONLY;
      }
    }

  } /* UE initiated call */
  else if (lte_info_ptr->lbi == ESM_INVALID_BEARER_ID)
  {
    /*-------------------------------------------------------------------------
      This means that it is a default bearer activation and no bearer context
      has been allocated. This is not possible since we are going with the
      unified approach of PDN connectivity for Attach and Non Attach cases
    -------------------------------------------------------------------------*/
    DS_LTE_MSG0_HIGH("Bearer context non allocated while default bearer setup");
    return DS3G_FAILURE;
  }

  /*-------------------------------------------------------------------------
   Verify if this is a dedicated bearer Activation
  -------------------------------------------------------------------------*/
  if(lte_info_ptr->lbi != ESM_INVALID_BEARER_ID)
  {
    DS_LTE_MSG2_HIGH("Receieved Dedicated bearer Activ Ind:lbi=%d :bearer=%d",
                     lte_info_ptr->lbi, lte_info_ptr->eps_bearer_id);

    return ds_eps_pdn_cntxt_handle_dedicated_bearer_activation(
      call_id,
      mode_info_ptr_i,
      cm_act_res_p,
      lte_info_ptr,
      bearer_cntx_p,
      subs_id
    );
  }

  /*----------------------------------------------------------------------
    Compare and copy the PDN address
  ----------------------------------------------------------------------*/
  if (lte_info_ptr->pdn_addr.valid != TRUE)
  {
    DS_LTE_MSG0_ERROR(" PDN address is Invalid, valid flag not set");
    result = DS3G_FAILURE;
    lte_info_ptr->esm_cause.valid = TRUE;
    lte_info_ptr->esm_cause.esm_cause = NAS_ESM_INVALID_MANDATORY_INFORMATION;
    return result;
  }

    /*----------------------------------------------------------------------
    We assume the IP support type of this APN to be what we requested,
    this info will be adjusted based on ESM cause code if it is returned
  ----------------------------------------------------------------------*/
  if (DS_3GPP_PDN_SUPPORTS_EMERGENCY_SERVICES(pdn_cntx_p))
  {
    if (pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type == DS_UMTS_PDP_IPV4V6)
    {
      ip_support = DS_IPV4V6;
    }
    else if (pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type == DS_UMTS_PDP_IPV4)
    {
      ip_support = DS_IPV4_ONLY;
    }
    else if (pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type == DS_UMTS_PDP_IPV6)
    {
      ip_support = DS_IPV6_ONLY;
    }
    else 
    {
      ip_support = DS_SINGLE_BEARER;
    }    
  }
  else if(ds_pdn_cntxt_get_ip_support_info_for_pdn(pdn_cntx_p,&ip_support) !=
                                                                  DS3G_SUCCESS)
  {
    DS_LTE_MSG1_ERROR("Could not get IP Support info. PDN: 0x%x",
                      pdn_cntx_p);
    result = DS3G_FAILURE;
    lte_info_ptr->esm_cause.valid = TRUE;
    lte_info_ptr->esm_cause.esm_cause = NAS_ESM_INVALID_MANDATORY_INFORMATION;
    return result;
  }

  DS_LTE_MSG2_HIGH("Profile pdp_type: %d,initializing ip_support to:%d",
                   pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type,ip_support);

  /*----------------------------------------------------------------------
    Now compare the PDP type stored in the profile with the ESM cause that
    is returned in the Activate Default Bearer Context Request message.
    If there is any mismatch in the PDP type requested and returned, we
    have to reject the call.

    If we requested for Dual IP bearer and NW returns IPV4, or V6 or single
    IP bearer only, this is also handled here.
  ----------------------------------------------------------------------*/

  /*----------------------------------------------------------------------
    If we requested for Dual IP bearer and NW returns IPV4/V6 only
    without any cause then if redial allow NV is set ,ip support gets updated
    and  ds_3gpp_pdn_dissociate function will clean up companion Iface
    (based on NV )
  ---------------------------------------------------------------------------*/
  if((ip_support == DS_IPV4V6) &&
     (lte_info_ptr->pdn_addr.pdn_type_val != NAS_ESM_IPV4V6) &&
     (lte_info_ptr->esm_cause.valid != TRUE))
  {

    ds_eps_pdn_cntxt_update_ip_type_for_v4v6_with_invalid_esm_cause(&ip_support,
                                           lte_info_ptr->pdn_addr.pdn_type_val,
                                           subs_id);
    if(ds_3gpp_throt_sm_is_cc_sp_throttling_enabled(subs_id) != TRUE)
    {		
      ds_eps_pdn_cntxt_update_param_for_new_ip_type(ip_support,pdn_cntx_p,&ind_payload);
    }	

    switch (ip_support)
    {
      case DS_IPV4_ONLY:
      case DS_IPV4_SINGLE_BEARER:
        other_ps_iface_p = DSPDNCNTXT_GET_V6_PS_IFACE_PTR(pdn_cntx_p);
        break;

      case DS_IPV6_ONLY:
      case DS_IPV6_SINGLE_BEARER:
        other_ps_iface_p = DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_cntx_p);
        break;

      default:
        DS_LTE_MSG1_ERROR("Invalid ip_support: %d for invalid ESM cause",
                           ip_support);
        break;
    }

    if (PS_IFACE_IS_VALID(other_ps_iface_p))
    {
     ds_pdn_cntxt_dissociate_iface(pdn_cntx_p, ip_support);
    }
    else
    {
      DS_3GPP_MSG0_HIGH("other_ps_iface is not valid, not dissociating");
    }
    
    DS_LTE_MSG1_ERROR("Esm cause not set for IPV4V6 call,hence update IP support"
                      " type to %d",ip_support);

  }

  if(lte_info_ptr->esm_cause.valid == TRUE)
  {
    DS_LTE_MSG1_HIGH("Processing esm_cause: %d",
                     lte_info_ptr->esm_cause.esm_cause);
    /*------------------------------------------------------------------------------- 
      To populate the ps_down_reason, This would be used if regular throttling
      is performed.
    ---------------------------------------------------------------------------------*/
    (void)ds_eps_bearer_cntxt_map_cause_codes(CALL_END_ESM_CAUSE_TO_PS_IFACE_CAUSE_CODES,
      &ps_down_reason,(const void*)mode_info_ptr_i);
#ifdef FEATURE_DATA_REL11
    if( ds_3gpp_nv_manager_get_nv_lte_rel_version() >= LTE_3GPP_REL11 )
    {
      if(lte_info_ptr->esm_cause.esm_cause == NAS_ESM_MAX_PDP_CONTEXT_REACHED)
      {
        max_active_bearer_context = ds_3gpp_pdn_get_current_active_context(subs_id);
        DS_LTE_MSG1_HIGH("Maximum simultaneous PDP count %d",max_active_bearer_context);
        ds_3gpp_pdn_set_max_simul_active_pdp_context(max_active_bearer_context, subs_id);
        return DS3G_FAILURE;
      }
      if(lte_info_ptr->esm_cause.esm_cause == 
                                 NAS_ESM_APN_NOT_SUPPORTED_IN_PLMN_RAT_COMBINATION)
      {
       /*---------------------------------------------------------------------
        if the network returns a cause (#66) permanently throttle that apn 
        The apn is unblocked only on sim removal and power reboot procedures
       ----------------------------------------------------------------------*/

         pdn_throt_sm_ptr = ds_3gpp_pdn_throt_sm_get_throttle_sm(
                         pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn,
                         FALSE,
                         TRUE,
                         DS_3GPP_THROTTLE_TYPE_NOT_SPECIFIED,
                         subs_id);
         ds_3gpp_pdn_throt_set_failure_cause_code(pdn_throt_sm_ptr, 
                                             (void*)PS_NET_DOWN_REASON_UNSUPPORTED_APN_IN_CURRENT_PLMN,
                                             DS_UMTS_PDP_IPV4V6);
         ds_3gpp_pdn_throt_handle_perm_conn_failure(pdn_throt_sm_ptr,
		 	                            (void *)ps_down_reason,
                                                    DS_UMTS_PDP_IPV4V6, 
                                                    subs_id,
                                                    pdn_cntx_p);
         ds_3gppi_throt_sm_set_current_sys_mode(pdn_throt_sm_ptr,
                                                DS_UMTS_PDP_IPV4V6,
                                                SYS_SYS_MODE_LTE);
         return DS3G_FAILURE;
      }
    } /* release 11 */
#endif /* FEATURE_DATA_REL11 */
    if((lte_info_ptr->esm_cause.esm_cause != NAS_ESM_PDN_TYPE_IPV4_ONLY_ALLOWED)
       && (lte_info_ptr->esm_cause.esm_cause != NAS_ESM_PDN_TYPE_IPV6_ONLY_ALLOWED)
       && (lte_info_ptr->esm_cause.esm_cause != NAS_ESM_SINGLE_ADR_BEARERS_ONLY_ALLOWED))
    {
      DS_LTE_MSG1_ERROR("ds_eps_pdn_cntxt_bearer_activate_ind: Invalid ESM cause %d",
                        lte_info_ptr->esm_cause.esm_cause);
      result = DS3G_FAILURE;
      lte_info_ptr->esm_cause.valid = TRUE;
      lte_info_ptr->esm_cause.esm_cause = NAS_ESM_ACTIVATION_REJECTED;
    }
    else switch(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type)
    {
      case DS_UMTS_PDP_IPV4:
        if(lte_info_ptr->esm_cause.esm_cause == \
           NAS_ESM_PDN_TYPE_IPV6_ONLY_ALLOWED)
        {
          DS_LTE_MSG0_HIGH("Received ESM cause IPV6 only while profile req is V4");
          ip_support = DS_IPV6_ONLY;
          result = DS3G_FAILURE;
          lte_info_ptr->esm_cause.valid = TRUE;
          lte_info_ptr->esm_cause.esm_cause = NAS_ESM_ACTIVATION_REJECTED;

          DS_3GPP_APM_SET_INVALID_V4_IPADDR(ind_payload, PS_NET_DOWN_REASON_IP_V6_ONLY_ALLOWED); 

        }
        else if(lte_info_ptr->esm_cause.esm_cause == \
                  NAS_ESM_SINGLE_ADR_BEARERS_ONLY_ALLOWED)
        {
          DS_LTE_MSG0_HIGH("Handling Single addr bearer only while profile req is V4");
          if(lte_info_ptr->pdn_addr.pdn_type_val == NAS_ESM_IPV4)
          {
            ip_support = DS_IPV4_SINGLE_BEARER;
          }
          else if (lte_info_ptr->pdn_addr.pdn_type_val == NAS_ESM_IPV6)
          {
            DS_LTE_MSG0_ERROR("Received V6 addr only while profile req is V4");
            ip_support = DS_IPV6_SINGLE_BEARER;
            result = DS3G_FAILURE;
            lte_info_ptr->esm_cause.valid = TRUE;
            lte_info_ptr->esm_cause.esm_cause = NAS_ESM_ACTIVATION_REJECTED;

            DS_3GPP_APM_SET_INVALID_V4_IPADDR(ind_payload, PS_NET_DOWN_REASON_SINGLE_ADDR_BEARER_ONLY); 
          }
          else
          {
            DS_LTE_MSG1_HIGH("Incorrect PDN address type: %d",
                             lte_info_ptr->pdn_addr.pdn_type_val);
            result = DS3G_FAILURE;
            lte_info_ptr->esm_cause.valid = TRUE;
            lte_info_ptr->esm_cause.esm_cause = NAS_ESM_UNKNOWN_PDN_TYPE;
            break;
          }
        }
        break;
      case DS_UMTS_PDP_IPV6:
        if(lte_info_ptr->esm_cause.esm_cause == \
           NAS_ESM_PDN_TYPE_IPV4_ONLY_ALLOWED)
        {
          DS_LTE_MSG0_HIGH("Received ESM cause IPV4 only while profile req is V6");
          ip_support = DS_IPV4_ONLY;
          result = DS3G_FAILURE;
          lte_info_ptr->esm_cause.valid = TRUE;
          lte_info_ptr->esm_cause.esm_cause = NAS_ESM_ACTIVATION_REJECTED;

          DS_3GPP_APM_SET_INVALID_V6_IPADDR(ind_payload, PS_NET_DOWN_REASON_IP_V4_ONLY_ALLOWED); 

        }
        else if(lte_info_ptr->esm_cause.esm_cause == \
           NAS_ESM_SINGLE_ADR_BEARERS_ONLY_ALLOWED)
        {
          DS_LTE_MSG0_HIGH("Handling Single addr bearer only while profile req is V6");
          if(lte_info_ptr->pdn_addr.pdn_type_val == NAS_ESM_IPV4)
          {
            DS_LTE_MSG0_ERROR("Received V4 addr only while profile req is V6");
            ip_support = DS_IPV4_SINGLE_BEARER;
            result = DS3G_FAILURE;
            lte_info_ptr->esm_cause.valid = TRUE;
            lte_info_ptr->esm_cause.esm_cause = NAS_ESM_ACTIVATION_REJECTED;
            
            DS_3GPP_APM_SET_INVALID_V6_IPADDR(ind_payload, PS_NET_DOWN_REASON_SINGLE_ADDR_BEARER_ONLY); 
          }
          else if (lte_info_ptr->pdn_addr.pdn_type_val == NAS_ESM_IPV6)
          {
            ip_support = DS_IPV6_SINGLE_BEARER;
          }
          else
          {
            DS_LTE_MSG1_HIGH("Incorrect PDN address type: %d",lte_info_ptr->pdn_addr.pdn_type_val);
            result = DS3G_FAILURE;
            lte_info_ptr->esm_cause.valid = TRUE;
            lte_info_ptr->esm_cause.esm_cause = NAS_ESM_UNKNOWN_PDN_TYPE;
            break;
          }
        }
        break;
      case DS_UMTS_PDP_IPV4V6:
        if(lte_info_ptr->esm_cause.esm_cause == \
           NAS_ESM_PDN_TYPE_IPV4_ONLY_ALLOWED)
        {
          DS_LTE_MSG0_HIGH("Received ESM cause IPV4 only while profile req is V4V6");
          ip_support = DS_IPV4_ONLY;
          other_ps_iface_p = DSPDNCNTXT_GET_V6_PS_IFACE_PTR(pdn_cntx_p);
          /*---------------------------------------------------------------------- 
            Treat this as if the network failed a V6 connection request.
          -----------------------------------------------------------------------*/
         if(ds_3gpp_throt_sm_is_cc_sp_throttling_enabled(subs_id) != TRUE)
         {
            ds_3gpp_pdn_throt_perform_reg_throttling
              (NULL, pdn_cntx_p, (void *)ps_down_reason, DS_UMTS_PDP_IPV6, rat_type);
          }        

          DS_3GPP_APM_SET_INVALID_V6_IPADDR(ind_payload, PS_NET_DOWN_REASON_IP_V4_ONLY_ALLOWED);

        }
        else if(lte_info_ptr->esm_cause.esm_cause == \
           NAS_ESM_PDN_TYPE_IPV6_ONLY_ALLOWED)
        {
          DS_LTE_MSG0_HIGH("Received ESM cause IPV6 only while profile req is V4V6");
          ip_support = DS_IPV6_ONLY;
          other_ps_iface_p = DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_cntx_p);
          /*----------------------------------------------------------------------
            Treat this as if the network failed a V4 connection request.
          -----------------------------------------------------------------------*/
         if(ds_3gpp_throt_sm_is_cc_sp_throttling_enabled(subs_id) != TRUE)
         {
            ds_3gpp_pdn_throt_perform_reg_throttling
              (NULL, pdn_cntx_p, (void *)ps_down_reason, DS_UMTS_PDP_IPV4, 
               rat_type);
          }

          DS_3GPP_APM_SET_INVALID_V4_IPADDR(ind_payload, PS_NET_DOWN_REASON_IP_V6_ONLY_ALLOWED);             
          
        }
        else if(lte_info_ptr->esm_cause.esm_cause == \
           NAS_ESM_SINGLE_ADR_BEARERS_ONLY_ALLOWED)
        {
          DS_LTE_MSG0_HIGH("Received ESM cause Single addr bearer only while profile req is V4V6");
          if(lte_info_ptr->pdn_addr.pdn_type_val == NAS_ESM_IPV4)
          {
            ip_support = DS_IPV4_SINGLE_BEARER;
            DS_3GPP_APM_SET_INVALID_V6_IPADDR(ind_payload, PS_NET_DOWN_REASON_SINGLE_ADDR_BEARER_ONLY);
            other_ps_iface_p = DSPDNCNTXT_GET_V6_PS_IFACE_PTR(pdn_cntx_p);
          }
          else if (lte_info_ptr->pdn_addr.pdn_type_val == NAS_ESM_IPV6)
          {
            ip_support = DS_IPV6_SINGLE_BEARER;
            DS_3GPP_APM_SET_INVALID_V4_IPADDR(ind_payload, PS_NET_DOWN_REASON_SINGLE_ADDR_BEARER_ONLY);
            other_ps_iface_p = DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_cntx_p);
          }
          else
          {
            DS_LTE_MSG1_HIGH("Incorrect PDN address type: %d",
                             lte_info_ptr->pdn_addr.pdn_type_val);
            result = DS3G_FAILURE;
            lte_info_ptr->esm_cause.valid = TRUE;
            lte_info_ptr->esm_cause.esm_cause = NAS_ESM_UNKNOWN_PDN_TYPE;
            break;
          }
        }
        
        if (PS_IFACE_IS_VALID(other_ps_iface_p))
        {
          ds_pdn_cntxt_dissociate_iface(pdn_cntx_p, ip_support);
        }
        else
        {
          DS_LTE_MSG0_HIGH("other_ps_iface is not valid, not dissociating");	
        }
        break;
      default:
        DS_LTE_MSG0_HIGH("Unknown PDP type.");
          result = DS3G_FAILURE;
          lte_info_ptr->esm_cause.valid = TRUE;
          lte_info_ptr->esm_cause.esm_cause = NAS_ESM_UNKNOWN_PDN_TYPE;
    }
  }

  if ( TRUE == ds_pdn_cntxt_is_default(pdn_cntx_p) &&
         ind_payload.ind_field_mask != 0 )
  {           
    DS_3GPP_APM_SET_PROFILE_ID(ind_payload, (uint16)pdn_cntx_p->
                               ds_pdn_context_dyn_p->pdp_profile_num);  
    ind_payload.subs_id = subs_id; 
    (void)ds_dsd_apm_ind(DS_DSD_APM_IP_ADDRESS_IND, &ind_payload);
  }


  if(result == DS3G_FAILURE)
  {
    DS_LTE_MSG0_HIGH("Cannot proceed with bearer activation");
    return result;
  }

  if(
     (ds_pdn_cntxt_is_ue_attached(subs_id) == TRUE) &&
     (ds_pdn_cntxt_is_default(pdn_cntx_p) == FALSE &&
      pdn_cntx_p->ds_pdn_context_dyn_p->keep_alive_pdn == FALSE)
    )
  {
    /*--------------------------------------------------------------------
      This is some special handling that has to be done in a case where
      we are already attached and we are working with a non-def PDN.
      If we are not attached, we have to accept any IP support that the
      network returns for a particular APN - could be default APN during
      regular/handover attach, could also be a non-default APN during HO
      attach.

      Note: The new addition added is that even if the UE is attached, we
      accept any IP type given for the default connection
    --------------------------------------------------------------------*/

    /*--------------------------------------------------------------------
      Now that we have determined the IP support returned by the network,
      we need to make sure that this is something that we need. If n/w
      returns an IP type that is not the one that the app requested for
      then we have to reject bearer activation and request a new PDN
      connection with the app requested IP type only.
    --------------------------------------------------------------------*/
    ds_iface_v4_p = \
        pdn_cntx_p->ds_pdn_context_dyn_p->
      ds_3gpp_iface_tbl[DS_3GPP_PDN_CONTEXT_IPV4_IFACE];

    ds_iface_v6_p = \
        pdn_cntx_p->ds_pdn_context_dyn_p->
      ds_3gpp_iface_tbl[DS_3GPP_PDN_CONTEXT_IPV6_IFACE];

    /*------------------------------------------------------------------------
      Re-initialize result to TRUE. This is because we are going to check a
      few more cases.
    ------------------------------------------------------------------------*/
    result = DS3G_SUCCESS;

    switch(ip_support)
    {
      case DS_IPV4_ONLY:
      case DS_IPV4_SINGLE_BEARER:
        if(PS_IFACE_IS_IN_USE(&(ds_iface_v4_p->ps_iface)) != TRUE)
        {
          /*------------------------------------------------------------------
            Reject bearer activation since IP V6 pipe cannot be obtained
            If a V6 pipe were needed, the request would have been made while
            dissociating. It is safe to reject this bearer activation
          ------------------------------------------------------------------*/
          lte_info_ptr->esm_cause.valid = TRUE;
          lte_info_ptr->esm_cause.esm_cause = NAS_ESM_ACTIVATION_REJECTED;
          result = DS3G_FAILURE;
        }
        break;

      case DS_IPV6_ONLY:
      case DS_IPV6_SINGLE_BEARER:
        if(PS_IFACE_IS_IN_USE(&(ds_iface_v6_p->ps_iface)) != TRUE)
        {
          /*------------------------------------------------------------------
            Reject bearer activation since IP V4 pipe cannot be obtained
            If a V4 pipe were needed, the request would have been made while
            dissociating. It is safe to reject this bearer activation
          ------------------------------------------------------------------*/
          lte_info_ptr->esm_cause.valid = TRUE;
          lte_info_ptr->esm_cause.esm_cause = NAS_ESM_ACTIVATION_REJECTED;
          result = DS3G_FAILURE;
        }
        break;

      default:
        DS_LTE_MSG0_HIGH("Ignoring IP support IPv4V6");
        break;
    }

    if(result == DS3G_FAILURE)
    {
      DS_LTE_MSG0_HIGH("Rejecting bearer activation since other IP type was given");
      return result;
    }
  } // If not attach case


  /*----------------------------------------------------------------------
    Verify the resolved apn name is valid according to LTE specification and 
    decode the apn name network identifier and store
  ----------------------------------------------------------------------*/

  if ((decode_apn_result = ds_eps_pdn_cntx_validate_apn_name_and_decode(
                               pdn_cntx_p,lte_info_ptr,decoded_apn,
                               ds_3gpp_nv_manager_get_disable_apn_matching(subs_id))) == FALSE) 
  {
    DS_LTE_MSG0_ERROR("apn name validation failed and decoding.");
    result = DS3G_FAILURE;
    return result;
  }

  DATA_LTE_MSG_SPRINTF_2(MSG_LEGACY_HIGH,
        "APN Name in Prof is :%s , Resolved APN name: %s", apn_network_identifier, decoded_apn);

  if(ds_3gpp_pdn_limit_is_enabled(subs_id))
  {
    index = ds_3gpp_pdn_limit_tbl_find_entry
             (pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn,
              subs_id);
  }


    /*--------------------------------------------------------------------------
      The PDN cache contains NULL APN. Store the resolved APN name in the APN
      table.

      Ensure that we decode the source string so that we break down the FQDN
      to the labels of interest.

      Copy this formatted string into the APN table
    --------------------------------------------------------------------------*/

    DATA_LTE_MSG_SPRINTF_1(MSG_LEGACY_HIGH,
                             "APN Name in Prof is NULL: , Resolved APN name: %s", decoded_apn);

    if(ds_pdn_cntxt_update_resolved_apn_name(pdn_cntx_p,
                                            decoded_apn))
    {
      /*----------------------------------------------------------------------- 
        Indicate to PS Framework about the updated resolved APN
      -------------------------------------------------------------------------*/
      if ( (strlen((char*)pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn) == 0)
           && (strlen((char *)decoded_apn) > 0) )
      {
        memset(&filter_info, 0, sizeof(ds3geventmgr_filter_type));
        filter_info.ps_subs_id = (ps_sys_subscription_enum_type)
                                     ds3gsubsmgr_subs_id_cm_to_ds(subs_id);
        filter_info.tech = PS_SYS_TECH_3GPP;

        resolved_apn.apn_length = strlen((char*)decoded_apn);
        strlcpy(resolved_apn.apn_name,(char *)decoded_apn,DS_UMTS_MAX_APN_STRING_LEN+1);

        DS_3GPP_MSG0_HIGH("Resolved APN ev to PS");
        if(ps_sys_conf_set_ex(PS_SYS_TECH_3GPP,
                              PS_SYS_CONF_NULL_RESOLVED_APN,
                              filter_info.ps_subs_id,
                              (void *)&resolved_apn,&ps_errno) != 0)
        {
          DS_3GPP_MSG1_ERROR("Set PS_SYS_CONF_NULL_RESOLVED_APN failed.Err_no:%d"
                             ,ps_errno);
        }

        if(ds3geventmgr_set_event_info(DS3GEVENTMGR_NULL_RESOLVED_APN_EV,
                                       &resolved_apn, &filter_info)== FALSE)
        {
          DS_3GPP_MSG0_ERROR("Unable to provide Resolved APN info to internal"
                             " clients");
        }
      }

    }
    else
    {
      DS_LTE_MSG0_ERROR("Error updating resolved name in APN table");
    }
     /*-------------------------------------------------------------------------
       Check whether there is already an entry in PDN Limit TBL 
       corresponding to resolved APN Name.
       If there is we just increment PDN Connection Cntr 
       corresponding to that entry. 
       If there is no such entry then we update NULL APN to Resolved APN Name
       and update PDN Connection Cntr
      -------------------------------------------------------------------------*/
      
      if(ds_3gpp_pdn_limit_is_enabled(subs_id) &&
         ds_pdn_cntxt_is_ue_attached(subs_id)  &&
         pdn_cntx_p->ds_pdn_context_dyn_p->handover_attach_flag == FALSE)
      {
        if ((resolved_apn_index = 
               ds_3gpp_pdn_limit_tbl_find_entry(decoded_apn, subs_id)) !=
            DS_3GPP_PDN_LIMIT_TBL_INVALID_ENTRY)
        {
          index = resolved_apn_index;
        }
        else
        {
          ds_3gpp_pdn_limit_tbl_update_apn_name(index, subs_id, 
                                                  (char*)decoded_apn);
        }
      }

  /*--------------------------------------------------------------------- 
    Increment the PDN Connection Counter as the call came up successfully.
    But don't take consideration if it's emergency call
  -----------------------------------------------------------------------*/

  if(ds_3gpp_pdn_limit_is_enabled(subs_id) &&
     ds_pdn_cntxt_is_ue_attached(subs_id)  &&
     pdn_cntx_p->ds_pdn_context_dyn_p->handover_attach_flag == FALSE &&
     bearer_cntx_p->ds_bearer_context_dyn_p->is_default == TRUE )
  {
    if(index != DS_3GPP_PDN_LIMIT_TBL_INVALID_ENTRY &&
       DS_3GPP_PDN_SUPPORTS_EMERGENCY_SERVICES(pdn_cntx_p) == FALSE)
    {
      ds_3gpp_pdn_limit_increment_pdn_conn_cntr(index, subs_id);
    }
  }

  /*-------------------------------------------------------------------------
    Validate & Store IP address provided by the NW
  -------------------------------------------------------------------------*/
  DS_LTE_MSG1_HIGH("Processing granted pdn addr, type: %d",
                   lte_info_ptr->pdn_addr.pdn_type_val);

  if(lte_info_ptr->pdn_addr.pdn_type_val == NAS_ESM_IPV4)
  {
    /*---------------------------------------------------------------------
      Make sure that the ip support requested was IPV4. It could be IPV4
      only or Dual IP bearer. In case of a dual IP bearer request, we will
      enter here if the network returns a single IP bearer.
    ---------------------------------------------------------------------*/
    if(ip_support != DS_IPV4_ONLY &&
       ip_support != DS_IPV4_SINGLE_BEARER)
    {
      DS_LTE_MSG2_ERROR("IPV4 ret when req was diff. Req: %d, Ret: %d. Rej call",
                        pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type, 
                        ip_support);
      return DS3G_FAILURE;
    }

    /*---------------------------------------------------------------------
      Determine the DS Iface from the PDN context
    ----------------------------------------------------------------------*/
    ds_iface_v4_p =
      (pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[DS_3GPP_PDN_CONTEXT_IPV4_IFACE]);

    ds_3gpp_pdp_addr.ip_vsn = DS_IP_V4;
    memscpy(&ds_3gpp_pdp_addr.pdp_addr.pdp_addr_ipv4,
	     sizeof(uint32),
             lte_info_ptr->pdn_addr.address,
             sizeof(uint32));

    if(ds_3gpp_pdp_addr.pdp_addr.pdp_addr_ipv4 == 0)
    {
      /*---------------------------------------------------------------------
        NW sending 0 address. Check to make sure that profile setting allows
        DHCP to be used.
      ----------------------------------------------------------------------*/
      DS_LTE_MSG0_HIGH("NULL V4 IP address provided by NW!");
      if (profile_ptr->context.ipv4_addr_alloc != DS_UMTS_PDP_IPV4_ADDR_ALLOC_DHCPV4)
      {
        DS_LTE_MSG0_ERROR("NULL V4 IP address but DHCPV4 is not supported!");

        /* For the default PDN; inform APM if no V4 address is obtained. */
        if ( TRUE == (ds_pdn_cntxt_is_default(pdn_cntx_p)))
        {
          memset(&ind_payload, 0, sizeof(ds_dsd_apm_ind_pay_load));
          DS_3GPP_APM_SET_INVALID_V4_IPADDR(ind_payload, PS_NET_DOWN_REASON_NOT_SPECIFIED);   
          DS_3GPP_APM_SET_PROFILE_ID(ind_payload, (uint16)pdn_cntx_p->
                                     ds_pdn_context_dyn_p->pdp_profile_num);  
          ind_payload.subs_id =  subs_id;  
          (void)ds_dsd_apm_ind(DS_DSD_APM_IP_ADDRESS_IND, &ind_payload);
        }
                                          
        lte_info_ptr->esm_cause.valid = TRUE;
        lte_info_ptr->esm_cause.esm_cause = NAS_ESM_INVALID_MANDATORY_INFORMATION;
        return DS3G_FAILURE;
      }
    }
    /*---------------------------------------------------------------------
      V4 address is valid, clearing throttle state for v4
    ----------------------------------------------------------------------*/
    ds_3gpp_pdn_throt_clear_throttle_state(pdn_cntx_p->ds_pdn_context_dyn_p->
                                           pdp_profile.context.apn,
                                           DS_UMTS_PDP_IPV4,
                                           subs_id,
                                           rat_mask);

  }
  else if(lte_info_ptr->pdn_addr.pdn_type_val == NAS_ESM_IPV6)
  {
    /*---------------------------------------------------------------------
      Make sure that the ip support requested was IPV6. It could be IPV6
      only or Dual IP bearer. In case of a dual IP bearer request, we will
      enter here if the network returns a single IP bearer.
    ---------------------------------------------------------------------*/
    if(ip_support != DS_IPV6_ONLY &&
       ip_support != DS_IPV6_SINGLE_BEARER)
    {
      DS_LTE_MSG2_ERROR("IPV6 ret when req was diff. Req: %d, Ret: %d. Rej call",
                pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type, 
                        ip_support);
      return DS3G_FAILURE;
    }

    /*---------------------------------------------------------------------
      Get the DS Iface based from PDN context
    ----------------------------------------------------------------------*/
    ds_iface_v6_p =
      (pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
       [DS_3GPP_PDN_CONTEXT_IPV6_IFACE]);

    /*---------------------------------------------------------------------
      IID is the last 64 bits of the IP address. Hence it is copied into
      the lower 64 bits of the PDP addr field.
      The IPV6 IID is present in octets 0-7 of the field "address" inside
      the structure pdn_address_T
    ---------------------------------------------------------------------*/
    ds_3gpp_pdp_addr.ip_vsn = DS_IP_V6;
    memscpy(&(ds_3gpp_pdp_addr.pdp_addr.pdp_addr_ipv6.in6_u.\
             u6_addr64[DS_3GPP_IPV6_IID_OFFSET]), sizeof(uint64),
             lte_info_ptr->pdn_addr.address, sizeof(uint64));

    if(ds_3gpp_pdp_addr.pdp_addr.pdp_addr_ipv6.in6_u.\
       u6_addr64[DS_3GPP_IPV6_IID_OFFSET] == 0)
    {
      /*---------------------------------------------------------------------
        No DHCP support, so reject the bearer request.
      ----------------------------------------------------------------------*/
      DS_LTE_MSG0_ERROR(" NULL V6 IID address provided by NW!");

      /* For the default PDN; inform APM if no V6 address is obtained. */
      if ( TRUE == ds_pdn_cntxt_is_default(pdn_cntx_p))
      {
        memset(&ind_payload, 0, sizeof(ds_dsd_apm_ind_pay_load));
        DS_3GPP_APM_SET_INVALID_V6_IPADDR(ind_payload, 
                                          PS_NET_DOWN_REASON_NOT_SPECIFIED); 
        DS_3GPP_APM_SET_PROFILE_ID(ind_payload, (uint16)pdn_cntx_p->
                                   ds_pdn_context_dyn_p->pdp_profile_num);      
        ind_payload.subs_id = subs_id; 
        (void)ds_dsd_apm_ind(DS_DSD_APM_IP_ADDRESS_IND, &ind_payload);
      }
      lte_info_ptr->esm_cause.valid = TRUE;
      lte_info_ptr->esm_cause.esm_cause = NAS_ESM_INVALID_MANDATORY_INFORMATION;
      return DS3G_FAILURE;
    }
  }
  else if(lte_info_ptr->pdn_addr.pdn_type_val == NAS_ESM_IPV4V6)
  {
    /*----------------------------------------------------------------------
      In the event which UE profile req V4 or V6 but NW returns both V4 V6
      address, we will bring up as per the profile req
    ----------------------------------------------------------------------*/
    if(ip_support != DS_IPV4V6)
    {
      DS_LTE_MSG1_ERROR("Wrong profile config: IPV4V6 ret when profile req was: %d",
                         pdn_cntx_p->ds_pdn_context_dyn_p->
                        pdp_profile.context.pdp_type);

      if(ip_support == DS_IPV4_ONLY)
      {
        ds_3gpp_pdp_addr.ip_vsn = DS_IP_V4;
      }
      else if(ip_support == DS_IPV6_ONLY)
      {
        ds_3gpp_pdp_addr.ip_vsn = DS_IP_V6;
      }
      else
      {
        DS_LTE_MSG2_ERROR("IPV4V6 ret when req was diff. Req: %d, Ret: %d. Rej call",
                          pdn_cntx_p->ds_pdn_context_dyn_p->
                          pdp_profile.context.pdp_type, ip_support);
        return DS3G_FAILURE;
      }
    }
      else
    {
      ds_3gpp_pdp_addr.ip_vsn = DS_IP_V4V6;
    }

    if((ip_support == DS_IPV4_ONLY)||(ip_support == DS_IPV4V6))
    {
      /*---------------------------------------------------------------------
        Get the DS Iface based from PDN context
      ----------------------------------------------------------------------*/
      ds_iface_v4_p = (pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                       [DS_3GPP_PDN_CONTEXT_IPV4_IFACE]);

      /*---------------------------------------------------------------------
        Now store the V4 Address in the profile.
        The IPV4 address is present in the octets 8-11 of the field "address"
        Ref 9.9.4.9
      ---------------------------------------------------------------------*/
      memscpy(&ds_3gpp_pdp_addr.pdp_addr.pdp_addr_ipv4, sizeof(uint32),
              &(lte_info_ptr->pdn_addr.address[PDN_ADDRESS_IPV4V6_V4_OFFSET]),
              sizeof(uint32));

      if (ds_3gpp_pdp_addr.pdp_addr.pdp_addr_ipv4 == 0)
      {
        /*----------------------------------------------------------------------
          NW sending 0 address. Check to make sure that profile setting allows
          DHCP to be used.
        ----------------------------------------------------------------------*/
        DS_LTE_MSG0_HIGH(" NULL V4 IP address provided by NW!");

        if (profile_ptr->context.ipv4_addr_alloc != DS_UMTS_PDP_IPV4_ADDR_ALLOC_DHCPV4)
        {
          DS_LTE_MSG0_ERROR("NULL V4 IP address but DHCPV4 is not supported!");

          /* For the default PDN; inform APM if no V4 address is obtained. */
          if ( TRUE == ds_pdn_cntxt_is_default(pdn_cntx_p))
          {
            memset(&ind_payload, 0, sizeof(ds_dsd_apm_ind_pay_load));
            ind_payload.subs_id = subs_id;
            DS_3GPP_APM_SET_INVALID_V4_IPADDR(ind_payload, 
                                              PS_NET_DOWN_REASON_NOT_SPECIFIED);     
            DS_3GPP_APM_SET_PROFILE_ID(ind_payload, (uint16)pdn_cntx_p
                                       ->ds_pdn_context_dyn_p->pdp_profile_num);  
            (void)ds_dsd_apm_ind(DS_DSD_APM_IP_ADDRESS_IND, &ind_payload);
          }

          lte_info_ptr->esm_cause.valid = TRUE;
          lte_info_ptr->esm_cause.esm_cause = NAS_ESM_INVALID_MANDATORY_INFORMATION;
          return DS3G_FAILURE;
        }
      }
    /*---------------------------------------------------------------------
      V4 address is valid, clearing throttle state for v4
    ----------------------------------------------------------------------*/
      ds_3gpp_pdn_throt_clear_throttle_state(pdn_cntx_p->ds_pdn_context_dyn_p
                                             ->pdp_profile.context.apn,
                                             DS_UMTS_PDP_IPV4,
                                             subs_id,
                                             rat_mask);

    }//V4 addr decoding

    if((ip_support == DS_IPV6_ONLY)||(ip_support == DS_IPV4V6))
    {
      /*---------------------------------------------------------------------
        Get the DS Iface based from PDN context
      ----------------------------------------------------------------------*/
      ds_iface_v6_p = (pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
                       [DS_3GPP_PDN_CONTEXT_IPV6_IFACE]);

      /*---------------------------------------------------------------------
        Now store the V6 IID.
        IID is the last 64 bits of the IP address. Hence it is copied into
        the lower 64 bits of the PDP addr field in the profile.
        The IPV6 IID is present in octets 0-7 of the field "address" inside
        the structure pdn_address_T

        Ref 9.9.4.9
    ---------------------------------------------------------------------*/
      memscpy(&(ds_3gpp_pdp_addr.pdp_addr.pdp_addr_ipv6.in6_u.\
               u6_addr64[DS_3GPP_IPV6_IID_OFFSET]),sizeof(uint64),
               lte_info_ptr->pdn_addr.address, sizeof(uint64));

      if(ds_3gpp_pdp_addr.pdp_addr.pdp_addr_ipv6.in6_u.\
          u6_addr64[DS_3GPP_IPV6_IID_OFFSET] == 0)
      {
        /*---------------------------------------------------------------------
          No DHCP support, so reject the bearer request.
        ----------------------------------------------------------------------*/
        DS_LTE_MSG0_ERROR(" NULL V6 IID address provided by NW!");

        /* For the default PDN; inform APM if no V4 address is obtained. */
        if ( TRUE == ds_pdn_cntxt_is_default(pdn_cntx_p))
        {
          memset(&ind_payload, 0, sizeof(ds_dsd_apm_ind_pay_load));
          ind_payload.subs_id = subs_id;
          DS_3GPP_APM_SET_INVALID_V6_IPADDR(ind_payload, 
                                            PS_NET_DOWN_REASON_NOT_SPECIFIED); 
          DS_3GPP_APM_SET_PROFILE_ID(ind_payload, (uint16)pdn_cntx_p->
                                     ds_pdn_context_dyn_p->pdp_profile_num);      
          (void)ds_dsd_apm_ind(DS_DSD_APM_IP_ADDRESS_IND, &ind_payload);
        }

        lte_info_ptr->esm_cause.valid = TRUE;
        lte_info_ptr->esm_cause.esm_cause = NAS_ESM_INVALID_MANDATORY_INFORMATION;
        return DS3G_FAILURE;
      }

    }//V6 addr decoding
  }
  else
  {
    DS_LTE_MSG0_ERROR(" PDN address type is Invalid");
    lte_info_ptr->esm_cause.valid = TRUE;
    lte_info_ptr->esm_cause.esm_cause = NAS_ESM_UNKNOWN_PDN_TYPE;
    return DS3G_FAILURE;
  }

  /*-------------------------------------------------------------------------
    Update APN table with APN name and IP support
  -------------------------------------------------------------------------*/
  DATA_3GPP_MSG_SPRINTF_3(MSG_LEGACY_HIGH,
                   "Update APN table: ip_support:%d for pdn 0x%x apn:%s",
                   ip_support,pdn_cntx_p,
                   profile_ptr->context.apn);

  if (!DS_3GPP_PDN_SUPPORTS_EMERGENCY_SERVICES(pdn_cntx_p))
  {
  if (ds_pdn_cntxt_update_apn_table(profile_ptr->context.apn,
                             ip_support,
                             (void*)pdn_cntx_p) != TRUE)
  {
    DS_LTE_MSG0_ERROR("Unable to update APN table, cannot set up the bearer");
    lte_info_ptr->esm_cause.valid = TRUE;
    lte_info_ptr->esm_cause.esm_cause = NAS_ESM_INSUFFICIENT_RESOURCES;
    return DS3G_FAILURE;
  }
  }

  /*----------------------------------------------------------------------
    Update pdp group id provided by NAS
  ----------------------------------------------------------------------*/
  pdn_cntx_p->ds_pdn_context_dyn_p->pdp_group_id = lte_info_ptr->pdp_group_id;
  DS_LTE_MSG1_HIGH("Storing pdp group id: %d.",lte_info_ptr->pdp_group_id);

  /*----------------------------------------------------------------------
    If sdf qos info is passed in default bearer activation, store it in
    the bearer flow manager
  ----------------------------------------------------------------------*/
  if (lte_info_ptr->sdf_qos.valid == TRUE)
  {
    qos_spec_type app_qos;

    DS_LTE_MSG0_HIGH("Storing sdf qos info for default bearer.");
    bflow_manager_p=ds_bearer_flow_manager_find_flow_manager(bearer_cntx_p);

    if(bflow_manager_p == NULL)
    {
      DATA_ERR_FATAL("Bearer associated with a bearer flow manager");
      lte_info_ptr->esm_cause.valid = TRUE;
      lte_info_ptr->esm_cause.esm_cause =NAS_ESM_INSUFFICIENT_RESOURCES;
      return DS3G_FAILURE;
    }

    //Convert and Store the data rate for later use.
    memset(&app_qos, 0, sizeof(qos_spec_type));
    if ( ds_eps_bearer_flow_manager_convert_nw_data_rate_to_app(
                                                    bflow_manager_p,
                                                    (void *)mode_info_ptr_i,
                                                    &app_qos,
                                                     &icause_code) != DS3G_SUCCESS)
    {
      if(ds_eps_flow_manager_convert_cause_code(mode_info_ptr_i,&icause_code)
                                                               ==FALSE)
      {
        DS_LTE_MSG0_ERROR("Cause code conversion failed");
      }
      return DS3G_FAILURE;
    }

  }/* sdf_qos.valid */

  /*----------------------------------------------------------------------
    If APN AMBR is passed in default bearer activation, store it in
    the flow manager
  ----------------------------------------------------------------------*/
  if (lte_info_ptr->apn_ambr.valid == TRUE)
  {
    DS_LTE_MSG0_HIGH("Storing apn ambr for default bearer.");
    flow_manager_p=ds_flow_manager_find_flow_manager(pdn_cntx_p);
    if(!ds_flow_manager_validate_flow_manager(flow_manager_p))
    {
      lte_info_ptr->esm_cause.valid = TRUE;
      lte_info_ptr->esm_cause.esm_cause =NAS_ESM_INSUFFICIENT_RESOURCES;
      return DS3G_FAILURE;
    }

    /*----------------------------------------------------------------------
       Store the APN AMBR in Mode specific context
    -----------------------------------------------------------------------*/
    eps_flow_manager_p =
     (ds_eps_flow_manager_s *)(flow_manager_p->ds_flow_manager_dyn_p->
                               vobj_data_ptr_tbl[DS_3GPP_EPS_VOBJ]);
    if(!ds_eps_flow_manager_validate_flow_manager(eps_flow_manager_p))
    {
      DS_LTE_MSG0_ERROR("eps_bearer_context_p is NULL");
      lte_info_ptr->esm_cause.valid = TRUE;
      lte_info_ptr->esm_cause.esm_cause =NAS_ESM_INSUFFICIENT_RESOURCES;
      return DS3G_FAILURE;
    }
    memscpy((void *)&(eps_flow_manager_p->eps_flow_manager_dyn_p->eps_pdn_ambr),
	    sizeof(apn_ambr_T),
           (void *)&(lte_info_ptr->apn_ambr), sizeof(apn_ambr_T));

  }/* apn_ambr */

  /*----------------------------------------------------------------------
    Retrieve the protocol config options from CM struct mode_info_p
  ----------------------------------------------------------------------*/
  protocol_config_options_p = &(lte_info_ptr->config_options);

  /*----------------------------------------------------------------------
    Configure the PDP IP Proto stack
  ----------------------------------------------------------------------*/
  result = ds_pdn_cntxt_setup_pdp_ip_proto_stack(pdn_cntx_p,
                                                 &ds_3gpp_pdp_addr,
                                                 protocol_config_options_p,
                                                 NULL);

  if(result != DS3G_FAILURE)
  {
    /*-------------------------------------------------------------------------
     Fill in compression parameters.
    -------------------------------------------------------------------------*/
    profile_ptr = &(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile);
    ASSERT(cm_act_res_p != NULL);
    cm_act_res_p->h_comp = ds_pdn_cntxt_conv_header_comp_from_pdp_t_to_sys_t(
                                             &profile_ptr->context.h_comp);
    cm_act_res_p->d_comp = ds_pdn_cntxt_conv_data_comp_from_pdp_t_to_sys_t(
                                             &profile_ptr->context.d_comp);

   /*-------------------------------------------------------------------------
   If APN is throttled, clear the throttling 
   -------------------------------------------------------------------------*/
    if(ds_3gpp_throt_sm_is_cc_sp_throttling_enabled(subs_id) == TRUE)
    {
      if(decode_apn_result == FALSE)
      {
        (void)strlcpy((char *)decoded_apn,
          (char *)pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn,
           DS_UMTS_MAX_APN_STRING_LEN+1);
      }
      ds_eps_pdn_clear_throttle_state_for_apn_on_current_plmn(decoded_apn, subs_id);
    }
  }
  return result;

} /* dsEpspdnCntx_bearerActivateInd*/

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_GET_ORIG_PARAMS

DESCRIPTION
This function is used to fill up the orig params.

PARAMETERS
  pdn_cntx_p       - Pointer to the PDN context
  mm_orig_params_p - Pointer to the orig params structure
  call_info        - Pointer to the call info structure

DEPENDENCIES
  None.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
LOCAL boolean ds_eps_pdn_cntxt_get_orig_params
(
  ds_pdn_context_s                 *pdn_cntx_p,
  ds_3gpp_orig_params_s            *mm_orig_params_p,
  const ds_3gpp_pdn_call_info_type *call_info
)
{
  uint16  sdf_id = 0x0;
  int     pdn_inst;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  
  if(!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
  {
    return DS3G_FAILURE;
  }

  pdn_inst = ds_pdn_cntxt_get_pdn_context_instance(pdn_cntx_p);

  if(pdn_inst == -1)
  {
    DS_LTE_MSG1_HIGH("Cannot generate SDF ID. PDN context: %x not found in table",
                     pdn_cntx_p);
    return DS3G_FAILURE;
  }
  /*-------------------------------------------------------------------------
    Generate the SDF ID
  -------------------------------------------------------------------------*/
  sdf_id |= (uint16)(pdn_inst << 8);

  /*-------------------------------------------------------------------------
    Fill up the SDF ID and the request type.
  -------------------------------------------------------------------------*/
  (mm_orig_params_p->orig_params_u.lte_ps_orig_params_ptr)->sdf_id = sdf_id;

  if (DS_3GPP_PDN_SUPPORTS_EMERGENCY_SERVICES(pdn_cntx_p))
  {
    (mm_orig_params_p->orig_params_u.lte_ps_orig_params_ptr)->request_type =
                                                   ESM_EMERGENCY;
  } 
  else if(pdn_cntx_p->ds_pdn_context_dyn_p->handover_attach_flag == FALSE)
  {
    (mm_orig_params_p->orig_params_u.lte_ps_orig_params_ptr)->request_type =
                                                   ESM_INITIAL_REQUEST;
  }
  else
  {
    (mm_orig_params_p->orig_params_u.lte_ps_orig_params_ptr)->request_type =
                                                   ESM_HANDOVER;
  }

  DS_LTE_MSG1_HIGH("Setting request type to %d", 
                   (mm_orig_params_p->orig_params_u.lte_ps_orig_params_ptr)->request_type);
  /*-------------------------------------------------------------------------
    Fill up the pdn_connection_data_T by invoking the corresponding function
  -------------------------------------------------------------------------*/
  return ds_eps_pdn_cntxt_fillOrigParams(pdn_cntx_p,
         &((mm_orig_params_p->orig_params_u.lte_ps_orig_params_ptr)->pdn_data),
                                         call_info);

} /* ds_eps_pdn_cntxt_get_orig_params */

/*===========================================================================
FUNCTION DS_EPS_ATTACH_SM_IS_UE_ATTACHED

DESCRIPTION
  Queries the EPS attach SM whether the UE is attached or not.

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  TRUE if UE is attached in LTE mode
  FALSE otherwise

SIDE EFFECTS
  None.

===========================================================================*/
boolean ds_eps_attach_sm_is_ue_attached
(
  sys_modem_as_id_e_type    subs_id
)
{
  return ds_eps_attach_sm_get_state(subs_id) == DS_EPS_ATTACHED ;
}
/*===========================================================================
FUNCTION DS_EPS_ATTACH_SM_GET_STATE

DESCRIPTION
  Returns current state for attach SM.

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
ds_eps_attach_state_e ds_eps_attach_sm_get_state
(
  sys_modem_as_id_e_type  subs_id
)
{

  ds_eps_attach_sm_s *attach_sm_ptr = NULL;
  attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(subs_id);
  if(attach_sm_ptr == NULL)
  {
    DS_3GPP_MSG1_LOW("Invalid Attach SM ptr for Subs Id (CM) %d",subs_id);
    return DS_EPS_ATTACH_STATE_INVALID;
   }
  /*--------------------------------------------------------------------------
    Returns current state for attach SM.
  --------------------------------------------------------------------------*/
  DS_LTE_MSG2_HIGH("Attach SM. Current State: %d on Subs Id (CM) %d", 
                   attach_sm_ptr->attach_state,subs_id);

  return attach_sm_ptr->attach_state;

} /* ds_eps_attach_sm_get_state */
/*===========================================================================
FUNCTION DS_EPS_GET_COST_OF_MODEM_POWER

DESCRIPTION
  This function gets the cost of Modem power for from the lower layers

PARAMETERS
   argval_ptr - Arg val ptr to update the cost of modem power
   *ps_errno  - PS Error if the cost of modem power cannot be obtained

DEPENDENCIES
  None.

RETURN VALUE
  0  - If Cost of modem power is obtained successfully
  -1 - Otherwise
SIDE EFFECTS
  None.
===========================================================================*/
int16 ds_eps_get_cost_of_modem_power
(
  void*                    argval_ptr,
  int16                   *ps_errno
)
{
  lte_ml1_ul_stats_s                 ml1_ul_stats;  
  int16                              ret_val             = -1;
  ps_sys_modem_power_cost_enum_type *cost_modem_pwr_p    = NULL;
  /*- - - - - - - - - - - - - - - - - - - - - - -  - - - - - - - - - - - - */
  /*------------------------------------------------------------------------- 
    Validate Arguments
    -------------------------------------------------------------------------*/
  if(ps_errno == NULL)
  {
    DS_3GPP_MSG0_HIGH("ps_errno is NULL");
    return ret_val;
  }

  if(argval_ptr == NULL)
  {
    DS_3GPP_MSG0_HIGH("Invalid args to get cost of mdm power");
    *ps_errno = DS_EFAULT;
    return ret_val;
  }
  cost_modem_pwr_p = (ps_sys_modem_power_cost_enum_type *)argval_ptr;
  /*------------------------------------------------------------------------- 
    Query LTE ML1 to get modem power cost
    -------------------------------------------------------------------------*/
  if (lte_ml1_request_ul_stats(&ml1_ul_stats) == FALSE)
  {
    *cost_modem_pwr_p = DS_SYS_MODEM_POWER_COST_UNKNOWN;
  }
  else
  {
    switch (ml1_ul_stats.tx_pwr_cost)
    {
      case LTE_ML1_TX_PWR_COST_LOW:
        *cost_modem_pwr_p = DS_SYS_MODEM_POWER_COST_LOW;
        break;
      case LTE_ML1_TX_PWR_COST_MEDIUM:
        *cost_modem_pwr_p = DS_SYS_MODEM_POWER_COST_MEDIUM;
        break;
      case LTE_ML1_TX_PWR_COST_HIGH:
        *cost_modem_pwr_p = DS_SYS_MODEM_POWER_COST_HIGH;
        break;
      default:
        *cost_modem_pwr_p = DS_SYS_MODEM_POWER_COST_UNKNOWN;
        break;
    }
  }
  DS_3GPP_MSG1_HIGH("LTE ML1 reports mdm power cost %d",*cost_modem_pwr_p);
  ret_val = 0;
  *ps_errno = DS_ENOERR;
  return ret_val;
}
/*===========================================================================
FUNCTION DS_EPS_ATTACH_SM_SET_STATE

DESCRIPTION
  Returns current state for attach SM.

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void ds_eps_attach_sm_set_state
(
  ds_eps_attach_state_e   attach_state,
  sys_modem_as_id_e_type  subs_id
)
{
  ds_eps_attach_sm_s *attach_sm_ptr = NULL;

  attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(subs_id);
  if(attach_sm_ptr == NULL)
  {
    DS_LTE_MSG1_LOW("Invalid Attach SM ptr for Subs Id (CM) %d",subs_id);
    return;
  }
  /*--------------------------------------------------------------------------
    Sets the current state for attach SM.
  --------------------------------------------------------------------------*/

  DS_LTE_MSG3_HIGH("Attach SM. Old State: %d, New State: %d on sub id %d",
                    attach_sm_ptr->attach_state, 
                    attach_state, 
                    subs_id );

  attach_sm_ptr->attach_state = attach_state;

} /* ds_eps_attach_sm_get_state */
/*===========================================================================
FUNCTION DS_EPS_REPORT_UL_THROUGHPUT_QUALITY

DESCRIPTION
  This function queries LTE lower layer functions to get throughput quality

PARAMETERS
   sys_modem_as_id_e_type           - Subscription ID
   ds_3gpp_throughput_quality_s     - Pointer where the throughput Quality
                                      is filled
DEPENDENCIES
  None.

RETURN VALUE  
  TRUE   - If throughput quality is obtained from lower layer successfully
  FALSE  - otherwise

SIDE EFFECTS  
  None
===========================================================================*/
boolean ds_eps_report_ul_throughput_quality
(
  sys_modem_as_id_e_type           cm_subs_id,
  ds_3gpp_throughput_quality_s    *ul_throughput_quality
)
{
  boolean                   ret_val             = FALSE;
  uint32                    allowed_rate        = 0;
  lte_ml1_ul_stats_s        throughput_quality;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  /*------------------------------------------------------------------------- 
    Validate Argument
    -------------------------------------------------------------------------*/
  if(ul_throughput_quality == NULL)
  {
    DS_3GPP_MSG0_ERROR("Invalid arguments to report LTE throughput quality");
    return ret_val;
  }

  /*------------------------------------------------------------------------- 
    Get the allowed throughput from LTE Lower layers
    -------------------------------------------------------------------------*/
  allowed_rate = lte_mac_qos_get_allowed_tput();
  DS_3GPP_MSG1_HIGH("LTE ML1 reports Allowed t'put %u Bps", allowed_rate);
  /*------------------------------------------------------------------------- 
    LTE ML1 reports Allowed throughput in Bytes per sec. Convert it into kbps
    -------------------------------------------------------------------------*/
  ul_throughput_quality->allowed_ul_rate = DSUTIL_BYTES_TO_KBITS(allowed_rate);

  if (lte_ml1_request_ul_stats(&throughput_quality) == FALSE)
  {
    ul_throughput_quality->ul_throughput_quality = DS_SYS_HIGHER_THROUGHPUT_UNKNOWN;
    
    DS_3GPP_MSG0_HIGH("t'put quality from ML1 not available");
   }
   else
   {
     if (throughput_quality.plus_flag == TRUE)
     {
       ul_throughput_quality->ul_throughput_quality = DS_SYS_HIGHER_THROUGHPUT_POSSIBLE;
     }
     else
     {  
       ul_throughput_quality->ul_throughput_quality = DS_SYS_HIGHER_THROUGHPUT_NOT_POSSIBLE;
     }
     DS_3GPP_MSG1_HIGH("LTE ML1 reports T'put quality %d",
                       ul_throughput_quality->ul_throughput_quality);
   }
   ret_val = TRUE;
   return ret_val;
}/* ds_eps_report_ul_throughput_quality*/

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_RESET_ATTACH_APN_IND_HDLR

DESCRIPTION
  This function is used to notify APM to reset Attach APN to Class 1 APN
  when NAS gives this cback on T3402 Timer Expiry

PARAMETERS
  msgrtype  - UMID of the message sent
  dsmsg_ptr - Pointer to the payload

DEPENDENCIES
  None.

RETURN VALUE
  TRUE  - if the message header is correct and we can handle the message
  FALSE - otherwise

  Note: We will not return FALSE for errors in the message payload

SIDE EFFECTS
  None.
===========================================================================*/
LOCAL boolean ds_eps_pdn_cntxt_reset_attach_apn_ind_hdlr
(
  msgr_umid_type             msgrtype,
  const msgr_hdr_struct_type *dsmsg_ptr
)
{
  boolean                  ret_val = FALSE; //ret FALSE if msg id does not match
  emm_plmn_change_ind_type *payload_ptr = NULL;
  ds_dsd_apm_ind_pay_load  dsd_apm_pay_load;
  sys_modem_as_id_e_type   subs_id = SYS_MODEM_AS_ID_NONE;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(msgrtype == NAS_EMM_RESET_APN_SWITCH_IND && dsmsg_ptr != NULL)
  {
    payload_ptr = (emm_plmn_change_ind_type*)dsmsg_ptr;
    subs_id = INST_ID_TO_SYS_AS_ID(payload_ptr->msg_hdr.inst_id); 
    if (!ds3gsubsmgr_is_subs_id_valid(subs_id))
    {
      return FALSE;
    }

    memset(&dsd_apm_pay_load, 0, sizeof(ds_dsd_apm_ind_pay_load));
    
    dsd_apm_pay_load.subs_id = subs_id;
    ds_dsd_apm_ind(DS_DSD_APM_RESET_ATTACH_APN_IND, &dsd_apm_pay_load);
    ret_val = TRUE;
  }

  else
  {
    DS_LTE_MSG2_LOW("Error in incoming message. Msg id: %d, Msg_ptr 0x%x",
                       msgrtype,dsmsg_ptr);
  }
  return ret_val;
} /* ds_eps_pdn_cntx_reset_attach_apn_ind_hdlr */

/*===========================================================================
FUNCTION DS_EPS_ATTACH_SM_INIT

DESCRIPTION
  Initialize LTE ATTACH procedure state machine.

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
static void ds_eps_attach_sm_init(void)
{
  uint8 i=0;
  ds_eps_attach_sm_s *attach_sm_ptr = NULL;
  /*--------------------------------------------------------------------------
    Initialize LTE ATTACH procedure state machine
  --------------------------------------------------------------------------*/
  for (i=0;i < DS3GSUBSMGR_SUBS_ID_MAX ;i++)
  {
    attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(i);
    if(attach_sm_ptr == NULL)
    {
      DS_LTE_MSG1_LOW("Invalid Attach SM ptr for sub id %d",i);
      return;
    }
    ds_eps_pdn_cntx_reset_attach_sm_params(i);
    attach_sm_ptr->cached_seq_num = 0;
    attach_sm_ptr->cached_paging_response = FALSE;

  }
  return;
} /* ds_eps_pdn_cntxt_attach_sm_init */

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_INIT

DESCRIPTION
Configure the EPS specific PDN function table

PARAMETERS
  eps_pdn_context_ftbl_p:Pointer to EPS PDN function table.

DEPENDENCIES
  None.

RETURN VALUE

SIDE EFFECTS
  None.

===========================================================================*/
void ds_eps_pdn_cntxt_init( void )
{
  ds_pdn_context_vftbl_s   *eps_pdn_context_ftbl_p;
  ds3gsubsmgr_subs_id_e_type  ds3g_subs_id = DS3GSUBSMGR_SUBS_ID_INVALID;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  eps_pdn_context_ftbl_p = &(ds_pdn_context_ftbl[DS_3GPPI_SYS_MODE_LTE]);
  memset(
      (void*)eps_pdn_context_ftbl_p,
      0x0,
      (sizeof(ds_pdn_context_vftbl_s) )
      );

  for(ds3g_subs_id = DS3GSUBSMGR_SUBS_ID_MIN; ds3g_subs_id < DS3GSUBSMGR_SUBS_ID_MAX;
      ds3g_subs_id++)
  {
    ds_eps_lte_active_scell[ds3g_subs_id] = 0;
  }

  ds_eps_dl_tput_estimation_init();

  DS_PDN_CTXT_VF_REG(SYS_SYS_MODE_LTE, getOrigParams, \
                        ds_eps_pdn_cntxt_get_orig_params);

  DS_PDN_CTXT_VF_REG(SYS_SYS_MODE_LTE, bearerActivateInd, \
                        ds_eps_pdn_cntxt_bearer_activate_ind);

  DS_PDN_CTXT_VF_REG(SYS_SYS_MODE_LTE, resume_ind,
                        ds_eps_pdn_cntxt_resume_ind_hdlr);

  DS_PDN_CTXT_VF_REG(SYS_SYS_MODE_LTE, report_ul_throughput_quality,\
                        ds_eps_report_ul_throughput_quality);

  DS_PDN_CTXT_VF_REG(SYS_SYS_MODE_LTE, cost_of_modem_power,\
                        ds_eps_get_cost_of_modem_power);
  
  /*--------------------------------------------------------------------------
    Register for the L2 Ack of Attach complete message. It is only after this
    point that EPC module gets notified that attach was successful
  --------------------------------------------------------------------------*/
  dsmsgrrcv_reg_hdlr(NAS_EMM_ATTACH_COMPLETE_IND,
               (dsmsgrcv_msg_hdlr_f)ds_eps_pdn_cntx_attach_complete_ind_hdlr);


  /*--------------------------------------------------------------------------
    Now register with DS Message Router to receive the NAS message for PLMN
    change notification
  --------------------------------------------------------------------------*/
  dsmsgrrcv_reg_hdlr(NAS_EMM_IND_PLMN_CHANGE,
                      (dsmsgrcv_msg_hdlr_f)ds_eps_pdn_cntx_plmn_id_chg_hdlr);

  /*--------------------------------------------------------------------------
    Register with DS Message Router to receive the NAS message for T3402 
    change notification
  --------------------------------------------------------------------------*/
  dsmsgrrcv_reg_hdlr(NAS_EMM_T3402_CHANGED_IND,
               (dsmsgrcv_msg_hdlr_f)ds_eps_pdn_cntx_t3402_changed_ind_hdlr);

  /*--------------------------------------------------------------------------
    Register with DS Message Router to receive the NAS message for T3420 
    change notification
  --------------------------------------------------------------------------*/
  dsmsgrrcv_reg_hdlr(NAS_EMM_DEACT_NON_EMC_BEARER_IND,
               (dsmsgrcv_msg_hdlr_f)ds_eps_pdn_cntxt_deact_non_emc_bearer_ind_hdlr);

  /*--------------------------------------------------------------------------
    Register with DS Message Router to receive the NAS message for resetting
    Attach APN
  --------------------------------------------------------------------------*/
  dsmsgrrcv_reg_hdlr(NAS_EMM_RESET_APN_SWITCH_IND,
               (dsmsgrcv_msg_hdlr_f)ds_eps_pdn_cntxt_reset_attach_apn_ind_hdlr);

  /*--------------------------------------------------------------------------
    Register with DS Message Router to receive the LTE ML1 message for DL TPUT 
    estimation indication notification
  --------------------------------------------------------------------------*/
  dsmsgrrcv_reg_hdlr(LTE_CPHY_DL_TPUT_ESTM_REPORT_IND,
               (dsmsgrcv_msg_hdlr_f)ds_eps_lte_cphy_dl_throughput_estm_ind_hdlr);

  /*--------------------------------------------------------------------------
    Register with DS Message Router to receive the LTE ML1 message for modem
    power statistics 
  --------------------------------------------------------------------------*/
  dsmsgrrcv_reg_hdlr(LTE_CPHY_TX_POWER_REPORT_INFO_CNF,
               (dsmsgrcv_msg_hdlr_f)ds_eps_stats_modem_power_info_cnf_hdlr);


  /*--------------------------------------------------------------------------
    Register with DS Message Router to receive the LTE ML1 message for DL TPUT 
    response notification for request
  --------------------------------------------------------------------------*/
  dsmsgrrcv_reg_hdlr(LTE_CPHY_DL_TPUT_ESTM_REPORT_RSP,
               (dsmsgrcv_msg_hdlr_f)ds_eps_lte_cphy_dl_throughput_report_rsp_hdlr);

  /*--------------------------------------------------------------------------
    Register with DS Message Router to receive the LTE ML1 messages
    indicating the state of p and s cells for carrier aggregation
  --------------------------------------------------------------------------*/
  dsmsgrrcv_reg_hdlr(LTE_CPHY_CA_EVENT_IND,
                     (dsmsgrcv_msg_hdlr_f)ds_eps_pdn_cntxt_cphy_ca_event_hdlr);

  /*--------------------------------------------------------------------------
    Initialize LTE ATTACH procedure state machine
  --------------------------------------------------------------------------*/
  ds_eps_attach_sm_init();


  return;

} /* ds_eps_pdn_cntxt_init*/

/*===========================================================================
FUNCTION  DSLTEPS_LTE_GET_DEFAULT_V4_IFACE_PTR

DESCRIPTION
  This function returns the DEFAULT LTE v4 PS IFace ptr. 
  This is used for the test framework.

PARAMETERS
  subs_id: Subscription id

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
ps_iface_type *ds_eps_pdn_cntxt_get_default_v4_iface_ptr
(
  sys_modem_as_id_e_type subs_id
)
{
  ds_3gpp_iface_s  *ds_v4_iface_p=NULL;
  ds_pdn_context_s *pdn_cntx_p;
  ps_iface_type    *iface_ptr = NULL;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  pdn_cntx_p = ds_3gpp_pdn_cntxt_get_def_pdn(subs_id);

  if(ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
  {
    ds_v4_iface_p = pdn_cntx_p->ds_pdn_context_dyn_p->
      ds_3gpp_iface_tbl[DS_3GPP_PDN_CONTEXT_IPV4_IFACE];

    if(ds_v4_iface_p != NULL)
    {
      iface_ptr = &(ds_v4_iface_p->ps_iface);    
    }
  }

  return iface_ptr;
} /*ds_eps_pdn_cntxt_get_default_v4_iface_ptr */

/*===========================================================================
FUNCTION  DSLTEPS_LTE_GET_DEFAULT_V6_IFACE_PTR

DESCRIPTION
  This function returns the default LTE v6 PS IFace ptr.
  This is used for the test framework.

PARAMETERS
  subs_id: Subscription id

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
ps_iface_type *ds_eps_pdn_cntxt_get_default_v6_iface_ptr
(
  sys_modem_as_id_e_type subs_id
)
{
  ds_3gpp_iface_s  *ds_v6_iface_p=NULL;
  ds_pdn_context_s *pdn_cntx_p;
  ps_iface_type    *iface_ptr = NULL;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  
  pdn_cntx_p = ds_3gpp_pdn_cntxt_get_def_pdn(subs_id);

  if(ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
  {
    ds_v6_iface_p = pdn_cntx_p->ds_pdn_context_dyn_p->
      ds_3gpp_iface_tbl[DS_3GPP_PDN_CONTEXT_IPV6_IFACE];

    if(ds_v6_iface_p != NULL)
    {
      iface_ptr = &(ds_v6_iface_p->ps_iface);    
    }
  }

  return iface_ptr;
} /*ds_eps_pdn_cntxt_get_default_v6_iface_ptr */

/*===========================================================================
FUNCTION  DSLTEPS_LTE_GET_V4_IFACE_PTR_FROM_EPS_BEARER_ID

DESCRIPTION
  This function returns the LTE v4 PS IFace ptr corresponding to the EPS
  Bearer ID. This is used for the test framework.

PARAMETERS
  subs_id: Subscription Id

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
ps_iface_type *ds_eps_pdn_cntxt_get_v4_iface_ptr_from_eps_bearer_id
(
  eps_bearer_id_T        eps_bearer,
  sys_modem_as_id_e_type subs_id
)
{
  ds_3gpp_iface_s          *ds_v4_iface_p=NULL;
  int                       i = 0;
  ds_pdn_context_s         *pdn_cntx_p = NULL;
  ps_iface_type            *iface_ptr = NULL;
  ds_bearer_context_s      *bearer_context_p = NULL;
  /*------------------------------------------------------------------------*/

  for (i=0;i<DS_3GPP_MAX_BEARER_CONTEXT;i++)
  {
    bearer_context_p = ds_bearer_cntxt_get_instance_ptr(i);

    if ((ds_bearer_cntx_validate_bearer_subscription_internal (bearer_context_p, subs_id)) &&
        (ds_eps_bearer_cntxt_validate_bearer_cntxt(&eps_bearer_context_tbl[i])) &&
        (eps_bearer_context_tbl[i].ds_eps_bearer_context_dyn_p->eps_bearer_id == eps_bearer)) 
    {
      pdn_cntx_p = (ds_pdn_context_s *)
                     bearer_context_p->ds_bearer_context_dyn_p->pdn_context_ptr;        
      break;
    }
  }

  if(ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
  {
    ds_v4_iface_p = pdn_cntx_p->ds_pdn_context_dyn_p->
       ds_3gpp_iface_tbl[DS_3GPP_PDN_CONTEXT_IPV4_IFACE];
  
    if(ds_v4_iface_p != NULL)
    {
      iface_ptr = &(ds_v4_iface_p->ps_iface);
    }   
  }

  return iface_ptr;
} /*ds_eps_pdn_cntxt_iface_ptr_from_eps_bearer_id */

/*===========================================================================
FUNCTION  DSLTEPS_LTE_GET_V6_IFACE_PTR_FROM_EPS_BEARER_ID

DESCRIPTION
  This function returns the LTE v6 PS IFace ptr corresponding to the EPS
  Bearer ID. This is used for the test framework.

PARAMETERS
  subs_id: Subscription Id

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
ps_iface_type *ds_eps_pdn_cntxt_get_v6_iface_ptr_from_eps_bearer_id
(
  eps_bearer_id_T        eps_bearer,
  sys_modem_as_id_e_type subs_id
)
{
  ds_3gpp_iface_s          *ds_v6_iface_p=NULL;
  int                       i = 0;
  ds_pdn_context_s         *pdn_cntx_p = NULL;
  ps_iface_type            *iface_ptr = NULL;
  ds_bearer_context_s      *bearer_context_p = NULL;
  /*------------------------------------------------------------------------*/

  for (i=0;i<DS_3GPP_MAX_BEARER_CONTEXT;i++)
  {
    bearer_context_p = ds_bearer_cntxt_get_instance_ptr(i);

    if ((ds_bearer_cntx_validate_bearer_subscription_internal (bearer_context_p, subs_id)) &&
        (ds_eps_bearer_cntxt_validate_bearer_cntxt(&eps_bearer_context_tbl[i])) &&
        (eps_bearer_context_tbl[i].ds_eps_bearer_context_dyn_p->eps_bearer_id == eps_bearer)) 
    {
      pdn_cntx_p = (ds_pdn_context_s *)
                     bearer_context_p->ds_bearer_context_dyn_p->pdn_context_ptr;        
      break;
    }
  }

  if(ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
  {
    ds_v6_iface_p = pdn_cntx_p->ds_pdn_context_dyn_p->
       ds_3gpp_iface_tbl[DS_3GPP_PDN_CONTEXT_IPV6_IFACE];
  
    if(ds_v6_iface_p != NULL)
    {
      iface_ptr = &(ds_v6_iface_p->ps_iface);
    }   
  }

  return iface_ptr;
} /*ds_eps_pdn_cntxt_iface_ptr_from_eps_bearer_id */


/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_PHYSLINKPTRFROMEPSBEARERID

DESCRIPTION
  This function returns the LTE PS PHYS Link ptr corresponding to the EPS
  Bearer ID. This is used for the test framework.

PARAMETERS
  subs_id: Subscription Id

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
ps_phys_link_type *ds_eps_bearer_cntxt_phys_link_ptr_from_eps_bearer_id
(
  eps_bearer_id_T        eps_bearer,
  sys_modem_as_id_e_type subs_id
)
{
  int                      index =0;
  ds_eps_bearer_context_s *eps_bearer_context_p = NULL;
  ds_bearer_context_s     *bearer_context_p = NULL;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  for(index=0; index < DS_3GPP_MAX_BEARER_CONTEXT; index++)
  {
    bearer_context_p = ds_bearer_cntxt_get_instance_ptr(index);

    if(ds_bearer_cntx_validate_bearer_subscription_internal(bearer_context_p, subs_id))
    {
      eps_bearer_context_p = (ds_eps_bearer_context_s *)
        DS_BEARER_CTXT_VOBJ(bearer_context_p, SYS_SYS_MODE_LTE);

      if((ds_eps_bearer_cntxt_validate_bearer_cntxt(eps_bearer_context_p)) &&
          (eps_bearer_context_p->ds_eps_bearer_context_dyn_p->eps_bearer_id 
           == eps_bearer))
      {
        return(&(bearer_context_p->phys_link));
      } /* bearer_id matches*/
    }  /* if valid index */
  } /* for index */
  return(NULL);
} /* ds_eps_bearer_cntxt_phys_link_ptr_from_eps_bearer_id */

/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_SYS_CHANGE_HANDLER

DESCRIPTION
  This function is responsible for the teardown of the context when the mode
  changes to 3GPP2

  Note that this function deals with tearing down only the default contexts
  However if the non default bearers have to be torn down as well, this
  section has to be revisited

  This function handles two different cases:
  1. EPC mode handler available - In this case, this tears down a PDN context
     that may have Ifaces in out_of_use state. This is because such contexts
     are not transferred on handover and will have to be deleted by LTE MH
     locally.
  2. EPC mode handler unavailable - In this case, this function just tears
     down all PDN contexts.

PARAMETERS
  new_mode - New mode we are in
  old_mode - Old mode we were in

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void ds_eps_pdn_cntxt_sys_change_handler
(
  sys_sys_mode_e_type           new_mode,
  sys_sys_mode_e_type           old_mode,
  sys_modem_as_id_e_type        subs_id
)
{
  sys_sys_mode_e_type cntxt_transfer_target_rat = SYS_SYS_MODE_NO_SRV;
/*----------------------------------------------------------------------------*/
  if(new_mode == SYS_SYS_MODE_LTE)
  {
    /*----------------------------------------------------------------------
      This is one of the three modes that we will be interested in
      Update the ds_3gpp_sys_mode
    ----------------------------------------------------------------------*/
    ds3gpp_update_network_mode(new_mode, subs_id);

    /* Check whether U.E. is in LTE Full Service and whether Context Transfer
       Indication has been processed. If both conditions are met, it implies 
       that we just finished W to L Connected-mode handover (PS HO) */
    if (ds3g_get_current_srv_status_ex(subs_id) == SYS_SRV_STATUS_SRV &&
        ds_eps_attach_sm_get_state(subs_id) == DS_EPS_PROCESSED_CNTXT_TXFR_IND)
    {
      /*----------------------------------------------------------------------------
        Set the Attach complete flag to TRUE. Otherwise, we will never be able to
        bring up any context other than the one that was transferred
       ----------------------------------------------------------------------------*/
      ds3gpp_set_is_attach_complete_flag(TRUE, subs_id);

      ds_eps_attach_sm_handle_attach_complete_ind(DS_DSD_3GPP_IRAT_ATTACH,
                                                  subs_id);
    
      /*----------------------------------------------------------------------------
        Check if the config item to bring up the default PDN is set. If yes,
      ----------------------------------------------------------------------------*/
      if(ds_3gpp_nv_manager_get_always_connect_def_pdn_flag(subs_id) == TRUE)
      {
        /*----------------------------------------------------------------------
          Call the function that does operations to bring up the PDN connection
          using the attach profile.
    
          Ignore the return value of the function call.
        ----------------------------------------------------------------------*/
        DS_LTE_MSG1_HIGH("Full Service in LTE - Bringing up def PDN conn "
                         "if needed on Subs Id (CM) %d",subs_id);
    
        if (FALSE == ds_eps_pdn_cntxt_is_attach_pdn_up(subs_id))
        {
          (void)ds_eps_pdn_cntxt_bring_up_attach_pdn(subs_id);
        }
        else
        {
          DS_LTE_MSG0_HIGH("Attach PDN is UP, not bringing up again");
        }
      }
    }
  }

  cntxt_transfer_target_rat = 
    ds_3gpp_get_target_rat_from_cntxt_transfer_info(subs_id);

  if(ds3g_get_current_srv_status_ex(subs_id) == SYS_SRV_STATUS_SRV)
  {
    if (cntxt_transfer_target_rat == new_mode &&
        ds_3gpp_get_cntxt_transfer_ind_is_recvd(subs_id) == TRUE)
    {
      DS_LTE_MSG1_MED("Context transfer info match the target rat %d"
                       ,cntxt_transfer_target_rat);
      if((new_mode == SYS_SYS_MODE_GSM ||
          new_mode == SYS_SYS_MODE_WCDMA
#ifdef FEATURE_TDSCDMA
            ||
          new_mode == SYS_SYS_MODE_TDS
#endif /* FEATURE_TDSCDMA */
          ))
      { 

        if(ds_eps_attach_sm_get_state(subs_id) != DS_EPS_ATTACH_STATE_NULL ||
           ds_eps_attach_sm_get_state(subs_id) != DS_EPS_ATTACH_STATE_INVALID )
        {
          DS_LTE_MSG1_HIGH("Resetting attach SM to NULL State"
                            " on Subs Id (CM) %d",subs_id);
          ds_eps_pdn_cntx_reset_attach_sm_params(subs_id);
        }
      
        /*------------------------------------------------------------------- 
         We are no longer attached, Hence also reset nw overridden ip 
         In the global throttling case do not reset the table as throttling 
         should be carried forward if it attaches to same PLMN again, Also
         do not reset for REL 11+
         --------------------------------------------------------------------*/

        if((!ds_3gpp_nv_manager_get_global_throttling(subs_id)) && 
            !ds_3gppi_is_rel_11_supported())
        {
           ds_3gpp_network_override_hdlr_reset(subs_id);
        }
      }

      ds_3gpp_set_cntxt_transfer_info(SYS_SYS_MODE_NO_SRV,FALSE, subs_id);
    }
    else
    {
      DS_LTE_MSG1_LOW("Context transfer info does not match the target rat %d",
                      cntxt_transfer_target_rat);
    }
  }

  /*-------------------------------------------------------------------------
    Teardown always ON context only if the new_mode is 3GPP2.
    In case of UMTS as new_mode, resume_handler in UMTS takes care of
    tearing down always ON context.
    -----------------------------------------------------------------------*/
  if ( (new_mode != SYS_SYS_MODE_LTE) &&
       (new_mode != SYS_SYS_MODE_GSM) && 
       (new_mode != SYS_SYS_MODE_WCDMA) &&
       (new_mode != SYS_SYS_MODE_NO_SRV) &&
#ifdef FEATURE_TDSCDMA
       (new_mode != SYS_SYS_MODE_TDS) &&
#endif /*FEATURE_TDSCDMA*/
       (ds3g_bsr_is_in_progress(subs_id) == FALSE) )
  {
    ds_3gpp_pdn_cntxt_tear_down(subs_id);
  }

  if (new_mode == SYS_SYS_MODE_LTE || old_mode == SYS_SYS_MODE_LTE)
  {
     ds_eps_update_downlink_throughput_status_and_timers(subs_id);
  }
} /* ds_eps_pdn_cntxt_sys_change_handler */


#if 0
/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_PREF_SYS_CHG_HDLR
***** commenting out this function, since it is not being used in 3GPP mode 
handler. Also function ds3g_dsd_if_allow_handoff() being used in this function 
is being moved outside DSD to 3GPP2 mode handler, since only 3GPP2 mode handler 
uses it. Changes reviewed with vsheth *****

DESCRIPTION
  This function is responsible for the teardown of the context when the
  preferred system changes, as indication from DSD

PARAMETERS
  sys_sys_mode_e_type old_pref_sys: New preferred system we are in
  sys_sys_mode_e_type new_pref_sys: Old preferred system we are in

DEPENDENCIES
  presence of cne-dsd api's

RETURN VALUE
  None.

SIDE EFFECTS
  None.
===========================================================================*/
void ds_eps_pdn_cntxt_pref_sys_chg_hdlr
(
  sys_sys_mode_e_type old_pref_sys,
  sys_sys_mode_e_type new_pref_sys
)
{
  int                     pdn_inst;
  ds_pdn_context_s        *pdn_cntx_p;
  boolean                 retval;
  ds_bearer_context_s*    bearer_context_p;

  DS_LTE_MSG2_MED("ds_eps_pdn_cntxt_pref_sys_chg_hdlr: old sys %d, new sys: %d",
                   old_pref_sys, new_pref_sys);

  /*-----------------------------------------------------------------------
    Check if handoff is allowed between old pref sys and new pref sys.
    If handoff is not allowed and new mode is not LTE then
    tear down.
  -----------------------------------------------------------------------*/
  if( !(ds3g_dsd_if_allow_handoff(old_pref_sys, new_pref_sys)) &&
       (new_pref_sys != SYS_SYS_MODE_LTE) )
  {
    DS_LTE_MSG0_MED("ds_eps_pdn_cntxt_pref_sys_chg_hdlr: Will TEAR DOWN LTE iface");

    /*-----------------------------------------------------------------------
    Loop over all PDN contexts to find out which ones we have to tear
    -----------------------------------------------------------------------*/
    for(pdn_inst = 0; pdn_inst < DS_3GPP_MAX_PDN_CONTEXT; pdn_inst++)
    {
      pdn_cntx_p = &ds_pdn_context_tbl[pdn_inst];

      /*---------------------------------------------------------------------
      If the PDN context is in DOWN state, continue with the next one
      ---------------------------------------------------------------------*/
      if((!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p)) ||
         pdn_cntx_p->ds_pdn_context_dyn_p->state == DS_PDN_CONTEXT_STATE_DOWN ||
         pdn_cntx_p->ds_pdn_context_dyn_p->state == DS_PDN_CONTEXT_STATE_GOING_DOWN)
      {
        continue;
      }
      /*---------------------------------------------------------------------
      Get the bearer context pointer as we will need this to tear down, if
      we have to
      ---------------------------------------------------------------------*/
      bearer_context_p = (ds_bearer_context_s*)
                          pdn_cntx_p->ds_pdn_context_dyn_p->def_bearer_context_ptr;

      if ((bearer_context_p == NULL) ||
          (!ds_bearer_cntx_validate_bearer_context(bearer_context_p)))
      {
        DS_LTE_MSG0_ERROR("Bearer context passed is Invalid");
        continue;
      }

        //ds_bearer_cntxt_phys_link_down_cmd_hdlr(
        //                    (uint32)(bearer_context_p->client_data_ptr));

        retval = ds_eps_bearer_cntxt_tear_down_pdn_connection(
                                                    bearer_context_p,NULL);

      if(retval != DS3G_SUCCESS)
      {
        ds_pdn_cntxt_unbind_default_flows(pdn_cntx_p);
        ps_phys_link_gone_ind(&(bearer_context_p->
                                phys_link));

        ps_phys_link_enable_flow(&(bearer_context_p->
                                   phys_link),
                                 DS_FLOW_UMTS_MASK);

        /*---------------------------------------------------------------
          Do a local clean up since there was an error in tearing down
          the call.
        ---------------------------------------------------------------*/
        ds_bearer_cntxt_free_bearer_inst(bearer_context_p);

        /*---------------------------------------------------------------
          Post bearer down ind so that we can clean up the PDN context.
        ---------------------------------------------------------------*/
        if(bearer_context_p->ds_bearer_context_dyn_p->pdn_context_cb_tbl_ptr
           ->bearer_down_ind_cb != NULL)
        {
          ds_3gpp_down_reason_t net_down_reason;
          net_down_reason.reason.ps_iface_down_reason = 
            PS_NET_DOWN_REASON_INTERNAL_CALL_ENDED;
          net_down_reason.reason_T = DS_3GPP_PS_IFACE_NET_DOWN_REASON_T;
          bearer_context_p->ds_bearer_context_dyn_p->pdn_context_cb_tbl_ptr
            ->bearer_down_ind_cb(
                          bearer_context_p->ds_bearer_context_dyn_p
                          ->pdn_context_ptr,\
                          bearer_context_p,
                          net_down_reason,
                          FALSE);
        }/* Post bearer down indication with call_was_connected as False*/

      }/* Tear down request returned failure */

    } /* loop over all PDN contexts*/
  }
  return;
}
#endif

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_MOVE_BEARER_FROM_PEND_REDIAL_TO_DOWN_IF_NEEDED

DESCRIPTION
   Make a few validations and make a decision, if the bearer and PDN
   should continue to remain in PENDING_REDIAL mode or move it to GOING_DOWN
   Basically if the validation fails, a redial on the same PDN is not
   possible and hence move the state to GOING DOWN.
 
PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void ds_eps_pdn_cntxt_move_bearer_from_pending_redial_to_down_if_needed
(
   ds_bearer_context_s *bearer_context_p
)
{
  ds_umts_pdp_profile_type        *pdp_profile_ptr = NULL;
  uint16                           profile_num = 0;
  ds_pdn_context_s                *pdn_context_p = NULL;
  ds_umts_pdp_type_enum_type       old_pdp_type = DS_UMTS_PDP_IPV4; 
  ds_umts_pdp_type_enum_type       new_pdp_type = DS_UMTS_PDP_IPV4;
  char                            *old_apn = NULL;
  char                            *new_apn = NULL;
  boolean                          has_apn_changed = FALSE;
  boolean                          set_bearer_going_down = FALSE;
  ds_network_overrridden_ip_type_e override_ip = PDP_UNDEFINED;
  uint8                            pdn_index = 0;
  boolean                          result = FALSE;
  ps_iface_type                   *v4_iface_p = NULL;
  ps_iface_type                   *v6_iface_p = NULL;
  uint8                            pdn_limit_index = 0;
  sys_modem_as_id_e_type           subs_id  = SYS_MODEM_AS_ID_NONE;
  ds3g_apn_name_type              *apn_name = NULL;
  ds_pkt_sys_mode_e_type           pref_mode = DS_PKT_SYS_MODE_NONE;
  ds_apn_ip_support_type_e         ip_support = DS_IP_TYPE_INVALID;
  byte                            *resolved_apn  = NULL;
  dssnet6i_state_type              dssnet_state = DSSNET6I_MAX_STATE;
  ds_3gpp_iface_s                 *ds_v6_iface_p = NULL;
  ds_pdn_context_s                *temp_pdn_context_ptr = NULL;
  boolean                          reset_gateway_iid = TRUE;
  sys_sys_mode_e_type              current_network_mode = SYS_SYS_MODE_NONE;
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if (!ds_bearer_cntx_validate_bearer_context(bearer_context_p))
  {
    return;
  }

  pdn_context_p = bearer_context_p->ds_bearer_context_dyn_p->pdn_context_ptr;

  if(!ds_3gpp_pdn_cntxt_get_subs_id_from_pdn(pdn_context_p, &subs_id))
  {
    DS_LTE_MSG0_ERROR ("Subs Id extraction from PDN context failed");
    return;
  }

  current_network_mode = ds3gpp_get_current_network_mode(subs_id);

  if (current_network_mode != SYS_SYS_MODE_LTE)
  {
    DS_LTE_MSG1_ERROR("Current Network Mode is not LTE: %d"
                      "No need to redial for apn_param_chg",
                       current_network_mode);
    bearer_context_p->ds_bearer_context_dyn_p->down_reason =
                 PS_NET_DOWN_REASON_APN_PRM_CHG;
    set_bearer_going_down = TRUE;
    goto exit_func;
  }  

  pdp_profile_ptr = (ds_umts_pdp_profile_type*) 
                     modem_mem_alloc(sizeof(ds_umts_pdp_profile_type),
                     MODEM_MEM_CLIENT_DATA);

  /*------------------------------------------------------------------------- 
    Allocate and Initialize memory before filling in the report
  -------------------------------------------------------------------------*/
  if(pdp_profile_ptr == NULL)
  {
    DS_3GPP_MSG0_LOW("Mem Alloc to pdp_profile_ptr failed");
    return;
  }
  memset(pdp_profile_ptr, 0, sizeof(ds_umts_pdp_profile_type));

  profile_num = (uint16)pdn_context_p->ds_pdn_context_dyn_p->pdp_profile_num;


  old_pdp_type = pdn_context_p->ds_pdn_context_dyn_p->
                                               pdp_profile.context.pdp_type;

  old_apn = (char *)pdn_context_p->ds_pdn_context_dyn_p->
                                               pdp_profile.context.apn;

  /*------------------------------------------------------------------------ 
   Get the profile data corresponding 
   ------------------------------------------------------------------------*/
   result = ds_umts_get_pdp_profile_all_data_per_subs(profile_num,
                                           dsumts_subs_mgr_get_subs_id(subs_id), 
                                           pdp_profile_ptr);

   if((!pdp_profile_ptr->context.valid_flg) || ( result != DS_UMTS_PDP_SUCCESS ))
   {
     DS_3GPP_MSG1_ERROR("Error in retrieving definition for prof number:%d",
                        profile_num);
     goto exit_func;
   }

   new_pdp_type = pdp_profile_ptr->context.pdp_type;

   new_apn =  (char *)pdp_profile_ptr->context.apn;

   /*--------------------------------------------------------------------- 
     Check if profile's apn and pdn context's apn have changed. If they
     have changed, set a boolean to TRUE, This is needed for apn override
     checks.
     ---------------------------------------------------------------------*/

   if((strncasecmp((char*)old_apn,(char*)new_apn,
                         DS_UMTS_MAX_APN_STRING_LEN+1)!= 0))
   {
     DS_LTE_MSG0_HIGH("APN has changed");
     has_apn_changed = TRUE;
   }
   /*---------------------------------------------------------------------- 
     Old pdp type - represents the previous IP type of the PDN connection
     which was torn down
    
     PDP profile's IP type - New changed IP type.
    
    Old IP type                 ----- Changed IP type  -- PDP disconnect
     IPV4                             IPV6/IPV4V6                 NA
     IPv6                             IPV4/IPV4V6                 NA
     ----------------------------------------------------------------------*/
   DS_LTE_MSG2_HIGH("PDN redial:Old PDP type:%d, New PDP type:%d",
                     old_pdp_type,
                     new_pdp_type);
   switch(old_pdp_type)
   {
     case DS_UMTS_PDP_IPV4:
       if(new_pdp_type != DS_UMTS_PDP_IPV4)
         {
           set_bearer_going_down = TRUE;
           bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
             PS_NET_DOWN_REASON_APN_PRM_CHG;
           goto exit_func;
         }
         reset_gateway_iid = FALSE;
         break;

     case DS_UMTS_PDP_IPV6:
        if(new_pdp_type != DS_UMTS_PDP_IPV6)
        {
          bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
             PS_NET_DOWN_REASON_APN_PRM_CHG;
          set_bearer_going_down = TRUE;
          goto exit_func;
        }
         break;

    /*------------------------------------------------------------------------
     This piece of the code is to handle these situations
     Prev IP type = IPv4v6
     New IP type = IPv4
     If the companion iface(ipv6) is in use, we do not want to redial but simply
     tear down the call.
     If the comp iface is not in use update the apn tbl to the new ip type.
     This will ensure that the other iface type call will not be brought up
     in routing. The unused iface will be cleaned up 
    -------------------------------------------------------------------------*/
     case DS_UMTS_PDP_IPV4V6:
       if(new_pdp_type == DS_UMTS_PDP_IPV4)
       {
         v4_iface_p = DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_context_p);

         if((v4_iface_p == NULL) || (!PS_IFACE_IS_IN_USE(v4_iface_p)))
         {
           DS_LTE_MSG1_ERROR("Iface ptr:0x%x is NULL or "
                              "iface is not in use",v4_iface_p);
           bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
             PS_NET_DOWN_REASON_APN_PRM_CHG;
           set_bearer_going_down = TRUE;
           goto exit_func;
         }

         ip_support = DS_IPV4_ONLY;
         reset_gateway_iid = FALSE;

         v6_iface_p = DSPDNCNTXT_GET_V6_PS_IFACE_PTR(pdn_context_p);

         if (v6_iface_p == NULL)
         {
             DS_LTE_MSG1_ERROR("Iface ptr:0x%x is NULL or "
                               "iface is not in use",v6_iface_p);
             bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
               PS_NET_DOWN_REASON_APN_PRM_CHG;
             set_bearer_going_down = TRUE;
             goto exit_func;
         }

         /*--------------------------------------------------------------------
            Fetch the ds_iface ptr
         ----------------------------------------------------------------------*/
         ds_v6_iface_p  = (ds_3gpp_iface_s *)(v6_iface_p->client_data_ptr); 

         /*------------------------------------------------------------------------ 
           Here do not dissociate V6 because it needs to be gracefully torn down
           by V6 SM.
         --------------------------------------------------------------------------*/
         dssnet_state = dssnet6_get_instance_state(&(ds_v6_iface_p->dssnet6_sm_cb));

         if((dssnet_state ==  DSSNET6I_WAITING_FOR_NET_UP_STATE) ||
            (dssnet_state ==  DSSNET6I_LINK_RESYNC_STATE)        ||
            (dssnet_state ==  DSSNET6I_NET_UP_STATE))       
         {
           if(dssnet_stop(v6_iface_p,&(ds_v6_iface_p->dssnet6_sm_cb)) == 0)
           {
             DS_3GPP_MSG0_HIGH("dssnet_stop successful");
           }
         }
         else
         {
           /*--------------------------------------------------------------------    
            Send a Link down event to DSSNET6 SM. Link Down event transitions 
            SM to closed state. In closed state SM sends iface down indication.
           --------------------------------------------------------------------*/    
           DS_3GPP_MSG1_HIGH("Posting DSSNET6_LINK_DOWN_EV on 0x%x",
                              v6_iface_p);

           if (dssnet6_sm_post_event(&(ds_v6_iface_p->dssnet6_sm_cb), 
                                     DSSNET6_LINK_DOWN_EV,
                                     NULL) != 0)
           {
             DS_3GPP_MSG1_LOW("Error posting event to dssnet6",v6_iface_p);
           }
         }
       }
       else if (new_pdp_type == DS_UMTS_PDP_IPV6)
       {
         v4_iface_p = DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_context_p);
         v6_iface_p = DSPDNCNTXT_GET_V6_PS_IFACE_PTR(pdn_context_p);

         if ((v6_iface_p == NULL) || (!PS_IFACE_IS_IN_USE(v6_iface_p)))
         {
           DS_LTE_MSG1_ERROR("Iface ptr:0x%x is NULL or "
                              "iface is not in use",v6_iface_p);
           bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
             PS_NET_DOWN_REASON_APN_PRM_CHG;
           set_bearer_going_down = TRUE;
           goto exit_func;
         }

         ip_support = DS_IPV6_ONLY;

         ds_bearer_cntx_deregister_dpm_iface(pdn_context_p, 
                      DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_context_p));

         /* Do this only if v4_iface_p is valid, if the current PDN context is
            V6_ONLY, then v4_iface wouldn't be valid */
         if (PS_IFACE_IS_VALID(v4_iface_p))
         {
           ds_pdn_cntxt_dissociate_iface(pdn_context_p,ip_support);
	 }

         (void)ds_pdn_cntxt_update_apn_table(pdn_context_p->ds_pdn_context_dyn_p
                  ->pdp_profile.context.apn,ip_support,pdn_context_p); 
       }

      default:
          break;

     }

     /*------------------------------------------------------------------------ 
       Check for network override IP
     ------------------------------------------------------------------------*/
     if(has_apn_changed)
     {
       override_ip = ds_3gpp_network_override_hdlr_get_overridden_ip
                       ((byte *)new_apn, subs_id);
     }
     else
     {
       override_ip = ds_3gpp_network_override_hdlr_get_overridden_ip
                       ((byte *)old_apn, subs_id);
     }

     /*------------------------------------------------------------------------ 
       Overridden IP type and PDP IP changed should be the same.
       ------------------------------------------------------------------------*/
     DS_LTE_MSG2_HIGH("Network override IP in place:Overridden IP:%d, "
             "new PDP IP:%d",override_ip,new_pdp_type);

     if(override_ip != PDP_UNDEFINED)
     {
       switch(override_ip)
       {
         case PDP_IPV4:
           if(new_pdp_type != DS_UMTS_PDP_IPV4)
           {
             set_bearer_going_down = TRUE;
             bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
             PS_NET_DOWN_REASON_APN_PRM_CHG;
             goto exit_func;
           }
           reset_gateway_iid = FALSE;
           break;

         case PDP_IPV6:
           if(new_pdp_type != DS_UMTS_PDP_IPV6)
           {
             bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
             PS_NET_DOWN_REASON_APN_PRM_CHG;
             set_bearer_going_down = TRUE;
             goto exit_func;
           }
           break;

         default:
           break;
       }
     }

     /*--------------------------------------------------------------------- 
       If apn_disable flag is set move the bearer context to DOWN
     ----------------------------------------------------------------------*/
     if (pdp_profile_ptr->apn_disable_flag)
     {
       DS_3GPP_MSG0_ERROR("APN disable flag is set");
       bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
             PS_NET_DOWN_REASON_APN_PRM_CHG;
       set_bearer_going_down = TRUE;
       goto exit_func;
     }

     /*---------------------------------------------------------------------- 
      If APN bearer is not  DS_UMTS_PDP_PROFILE_APN_BEARER_FLAG_L tear down
      the call because it is an incompatible bearer
      ----------------------------------------------------------------------*/
     if((pdp_profile_ptr->apn_bearer  & DS_UMTS_PDP_PROFILE_APN_BEARER_FLAG_L) == 0)
     {
       DS_LTE_MSG1_ERROR("APN bearer is incompatible:0x%x",
                          pdp_profile_ptr->apn_bearer);
       bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
             PS_NET_DOWN_REASON_APN_PRM_CHG;
       set_bearer_going_down = TRUE;
       goto exit_func;
     }

     /*---------------------------------------------------------------------- 
       If apn name has changed, check if there exists another PDN UP with the
       same APN name. If it does then the bearer will have to be brought
       down.
       Also check if the changed apn is throttled.
      
       Use the new PDP type because we will anyways be reoriginating a
       new PDN context with the new PDP type.
     ------------------------------------------------------------------------*/
     if (has_apn_changed)
     {
       switch(new_pdp_type)
       {
         case DS_UMTS_PDP_IPV4:
           if(pdn_context_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
               [DS_3GPP_PDN_CONTEXT_IPV4_IFACE] != NULL)
           {
             v4_iface_p = DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_context_p);
             if(ds_3gpp_pdn_cntxt_is_apn_throttled(pdn_context_p,v4_iface_p))
             {
               DS_LTE_MSG0_ERROR("Changed APN for V4 IPtype is throttled");
               bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
                 PS_NET_DOWN_REASON_APN_PRM_CHG;
               set_bearer_going_down = TRUE;
               goto exit_func;
             }
           }
           reset_gateway_iid = FALSE;
           break;

         case DS_UMTS_PDP_IPV6:
           if(pdn_context_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
               [DS_3GPP_PDN_CONTEXT_IPV6_IFACE] != NULL)
           {
             v6_iface_p = DSPDNCNTXT_GET_V6_PS_IFACE_PTR(pdn_context_p);
             if(ds_3gpp_pdn_cntxt_is_apn_throttled(pdn_context_p,v6_iface_p))
             {
               DS_LTE_MSG0_ERROR("Changed APN for V6 IP type is throttled");
               bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
                 PS_NET_DOWN_REASON_APN_PRM_CHG;
               set_bearer_going_down = TRUE;
               goto exit_func;
             }
           }
           break;

         case DS_UMTS_PDP_IPV4V6:
           if((pdn_context_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
              [DS_3GPP_PDN_CONTEXT_IPV4_IFACE] != NULL) &&
              (pdn_context_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
               [DS_3GPP_PDN_CONTEXT_IPV6_IFACE] != NULL))
           {
             v4_iface_p = DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_context_p);
             v6_iface_p = DSPDNCNTXT_GET_V6_PS_IFACE_PTR(pdn_context_p);
             if(ds_3gpp_pdn_cntxt_is_apn_throttled(pdn_context_p,v6_iface_p) ||
                ds_3gpp_pdn_cntxt_is_apn_throttled(pdn_context_p,v4_iface_p))
             {
               DS_LTE_MSG0_ERROR("Changed APN for either V4V6 IP type is throttled");
               bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
                 PS_NET_DOWN_REASON_APN_PRM_CHG;
               set_bearer_going_down = TRUE;
               goto exit_func;
             }
           }
           break;

         default:
            break;

       }

       /*------------------------------------------------------------------------ 
         In case there were 2 PDN's to the same APN because of networking
         returning a single bearer..In this case
         PDN1 --> IPV4 single bearer --> apn1
         PDN2 --> IPV6 single bearer --> apn1
        
         Now PDN 1 will be torn down and a redial will happen on PDN 2.
        ------------------------------------------------------------------------*/
       for (pdn_index = 0;pdn_index < DS_3GPP_MAX_PDN_CONTEXT;pdn_index++)
       {
         temp_pdn_context_ptr = &ds_pdn_context_tbl[pdn_index];

         if(!ds_3gpp_pdn_cntx_validate_pdn_context(temp_pdn_context_ptr))
         {
           continue;
         }
         /*---------------------------------------------------------- 
           Ignore the existing PDN context
           ----------------------------------------------------------*/
         if (pdn_index == pdn_context_p->ds_pdn_context_dyn_p->index)
         {
           continue;
         }

         (void)ds_pdn_cntxt_get_resolved_apn_name(temp_pdn_context_ptr,
                                                  &(resolved_apn));

         if((strncasecmp((char*)new_apn,(char*)temp_pdn_context_ptr->
             ds_pdn_context_dyn_p->pdp_profile.context.apn, 
             DS_UMTS_MAX_APN_STRING_LEN+1) == 0)||
           ((resolved_apn != NULL) && (strncasecmp((char*)new_apn,
           (char*)resolved_apn,DS_UMTS_MAX_APN_STRING_LEN+1)== 0)))
         {
           /*-------------------------------------------------------------------- 
             APN match has occured, Check if PDN is up
             ---------------------------------------------------------------------*/
           if (temp_pdn_context_ptr->ds_pdn_context_dyn_p->state == 
               DS_PDN_CONTEXT_STATE_UP)
           {
             DS_3GPP_MSG1_ERROR("PDN_Index:%d has the new changed apn and "
                                "is UP,""No redial",temp_pdn_context_ptr->
                                ds_pdn_context_dyn_p->index);
             bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
                 PS_NET_DOWN_REASON_APN_PRM_CHG;
             set_bearer_going_down = TRUE;
             goto exit_func;
           }
         }
       }

       /*---------------------------------------------------------------------------- 
         Currently commented out, If needed the below feature can be enabled for
         apn param changed
         ----------------------------------------------------------------------------*/
       /*
       if (ds_3gpp_is_apn_name_present_in_other_profiles(profile_num, (byte *)new_apn))
       {
         bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
                 PS_NET_DOWN_REASON_APN_PRM_CHG;
         set_bearer_going_down = TRUE;
         goto exit_func;
       } 
       */ 

       /*----------------------------------------------------------------------- 
         If apn has changed, clear the PDN limit timer
        -----------------------------------------------------------------------*/
       if((pdn_limit_index = ds_3gpp_pdn_limit_tbl_find_entry((byte*)new_apn,
           subs_id)) != DS_3GPP_PDN_LIMIT_TBL_INVALID_ENTRY)
       {
         ds_3gpp_pdn_limit_reset_pdn_conn_cntr(pdn_limit_index, subs_id);
         ds_3gpp_pdn_limit_clr_pdn_conn_tmr(pdn_limit_index, subs_id);
       }
       /*----------------------------------------------------------------------- 
         If apn has changed we need to check if its Preferred RAT is LTE in case
         the PDN is Keep Alive PDN
        -----------------------------------------------------------------------*/
       #ifdef FEATURE_DATA_WLAN_MAPCON
       if (pdn_context_p->ds_pdn_context_dyn_p->keep_alive_pdn == TRUE)
       {
         apn_name = (ds3g_apn_name_type *)modem_mem_alloc
                    (sizeof(ds3g_apn_name_type),MODEM_MEM_CLIENT_DATA);

         if (apn_name == NULL)
         {
            DS_LTE_MSG0_LOW ("Memory allocation failed");
            set_bearer_going_down = TRUE;
            goto exit_func;
         }

         strlcpy (apn_name->apn_string, (char *)new_apn,
                  DS_UMTS_MAX_APN_STRING_LEN+1);

         apn_name->apn_string_len = strlen (apn_name->apn_string);

         if (apn_name->apn_string_len == 0)
         {
           DS_LTE_MSG0_HIGH ("Keep Alive PDN does not support NULL APN, tearing "
                             "it down");
           bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
                 PS_NET_DOWN_REASON_APN_PRM_CHG;
           set_bearer_going_down = TRUE;
           goto exit_func;
         }

         pref_mode = ds3g_get_apn_pref_pkt_mode_ex(apn_name, subs_id);

         if (pref_mode != DS_PKT_SYS_MODE_LTE)
         {
           DS_LTE_MSG0_ERROR ("Preferred Packet Mode is not LTE for KAMGR:"
                              " Tearing it down");
           bearer_context_p->ds_bearer_context_dyn_p->down_reason = 
                 PS_NET_DOWN_REASON_APN_PRM_CHG;
           set_bearer_going_down = TRUE;
           goto exit_func;
         }
       }
       #endif /*FEATURE_DATA_WLAN_MAPCON*/
       /*------------------------------------------------------------------------ 
         If this part of code is hit then bearer state will be left in PENDING
         REDIAL, now update the apn tbl.
         This will be donw in two steps if apn_chg occured
         1. Delete the old apn tbl entry
         2. Add the new apn tbl entry
         -----------------------------------------------------------------------*/
       if(ds_pdn_cntxt_remove_entry_in_apn_table(pdn_context_p))
       {

         switch (new_pdp_type)
         {
           case DS_UMTS_PDP_IPV4:
            ip_support = DS_IPV4_SINGLE_BEARER;
            break;

           case DS_UMTS_PDP_IPV6:
            ip_support = DS_IPV6_SINGLE_BEARER;
            break;
           
           case DS_UMTS_PDP_IPV4V6:
            ip_support = DS_IPV4V6;
            break;

           default:
             break;
         }

         DS_3GPP_MSG1_HIGH("New apn tbl addition:IP_TYPE%d",ip_support);
         (void)ds_apn_table_add_pdn((byte *)new_apn,ip_support,
                                    pdn_context_p);
         
       }
       else
       {
         DS_3GPP_MSG0_ERROR("APN tbl entry deletion failure");
       }
     }

     /*-------------------------------------------------------------------------- 
       If set_bearer_down is set, Set both the PDN and the bearer to GOING DOWN
       state
       --------------------------------------------------------------------------*/
     exit_func:
       if (set_bearer_going_down)
       {
         DS_LTE_MSG0_HIGH("Setting bearer and PDN to going down state");
         bearer_context_p->ds_bearer_context_dyn_p->state = 
           DS_BEARER_CONTEXT_STATE_GOING_DOWN;
         pdn_context_p->ds_pdn_context_dyn_p->state =
           DS_PDN_CONTEXT_STATE_GOING_DOWN;
         pdn_context_p->ds_pdn_context_dyn_p->apn_param_chg_teardown = FALSE;
       }
       if (apn_name != NULL)
       {
         modem_mem_free((void *)apn_name, MODEM_MEM_CLIENT_DATA);
       }

  if(pdn_context_p->ds_pdn_context_dyn_p->apn_param_chg_teardown)
  {
    if(reset_gateway_iid == TRUE)
    {
     v6_iface_p = DSPDNCNTXT_GET_V6_PS_IFACE_PTR(pdn_context_p);

      if((v6_iface_p != NULL) &&
        (PS_IFACE_IS_IN_USE(v6_iface_p) == TRUE))
      {
       DS_3GPP_MSG0_MED("Reseting the Gateway IID of primary IPv6 addr");
       PS_IFACE_SET_IPV6_GATEWAY_IID(v6_iface_p, 0);
      }
    }
  } 

  if (pdp_profile_ptr != NULL) 
  {
    modem_mem_free(pdp_profile_ptr, MODEM_MEM_CLIENT_DATA_CRIT);
  }
       return;
}
/*===========================================================================
FUNCTION DS_EPS_HANDLE_APN_PARAM_CHG_REDIAL

DESCRIPTION
 Fetch the apn parameters from profile and send out a pdn connectivity request.
 
PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void ds_eps_handle_apn_param_chg_redial
(
   ds_pdn_context_s *pdn_context_p,
   ds_bearer_context_s *bearer_context_p
)
{
  boolean result = FALSE;
  sys_modem_as_id_e_type           subs_id  = SYS_MODEM_AS_ID_NONE;

 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (!ds_bearer_cntx_validate_bearer_context(bearer_context_p))
  {
    return;
  }

  if(!ds_3gpp_pdn_cntxt_get_subs_id_from_pdn(pdn_context_p,&subs_id))
  {
    return;
  }

 /*------------------------------------------------------------------------- 
    Populate the PDN context with the modified APN parameters and move the
    state to COMING_UP
  -------------------------------------------------------------------------*/

  result = ds_umts_get_pdp_profile_all_data_per_subs((uint16)pdn_context_p->
           ds_pdn_context_dyn_p->pdp_profile_num,
           dsumts_subs_mgr_get_subs_id(subs_id), 
           &pdn_context_p->ds_pdn_context_dyn_p->pdp_profile);

  if((!pdn_context_p->ds_pdn_context_dyn_p->pdp_profile.
      context.valid_flg)|| ( result != DS_UMTS_PDP_SUCCESS ))
  {

    DS_3GPP_MSG1_ERROR("Error in retrieving definition for prof number:%d",
                       pdn_context_p->ds_pdn_context_dyn_p->pdp_profile_num);
    return;
  }

  pdn_context_p->ds_pdn_context_dyn_p->state = DS_PDN_CONTEXT_STATE_COMING_UP;

  (void)ds_eps_bearer_cntxt_redial_hdlr((ds_bearer_context_s*)
       (pdn_context_p->ds_pdn_context_dyn_p->def_bearer_context_ptr));

}

/*===========================================================================
FUNCTION DS_EPS_ATTACH_SM_HANDLE_LAST_BEARER_DEACT

DESCRIPTION
  If there are any pending calls, then GET_PDN_CONN_IND is cached and its
  processing is delayed till all pending calls are ended.

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void ds_eps_attach_sm_handle_last_bearer_deact
(
  sys_modem_as_id_e_type    subs_id
)
{

   ds_eps_attach_sm_s  *attach_sm_ptr = NULL;
   ds3g_eps_attach_sm_info_type   attach_info;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(subs_id);
  if(attach_sm_ptr == NULL)
  {
    DS_LTE_MSG1_LOW("Invalid Attach SM ptr for Subs Id (CM) %d",subs_id);
    return;
  }

    //Can be posted internal DS cmd queue
    /*----------------------------------------------------------------------- 
      Here the attac_sm state is changed to DS_EPS_PROCESS_GET_PDN_CONN_IND
      to handle get_pdn_conn_ind_hdlr
    ------------------------------------------------------------------------*/
    DS_3GPP_MSG1_HIGH("No pending bearers, Processing GET_PDN_CONN_IND "
                      "Setting Attach SM state to "
                      "DS_EPS_PROCESS_GET_PDN_CONN_IND on Subs Id (CM) %d",subs_id);
    ds_eps_attach_sm_set_state(DS_EPS_REDIAL_GET_PDN_CONN_IND,subs_id);
    attach_info.responding_to_page = attach_sm_ptr->cached_paging_response;
    attach_info.seq_num = attach_sm_ptr->cached_seq_num;
    ds3gpp_eps_get_pdn_conn_ind_hdlr(&attach_info,
                                     subs_id );

  return;
} /* ds_eps_attach_sm_handle_last_bearer_deact */

/*===========================================================================
FUNCTION DS_EPS_ATTACH_SM_HANDLE_ATTACH_COMPLETE_IND

DESCRIPTION
  Update ATTACH SM state to attach_complete

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
LOCAL void ds_eps_attach_sm_handle_attach_complete_ind
(
  ds_dsd_attach_complete_type attach_type,
  sys_modem_as_id_e_type      subs_id
)
{
  ds_dsd_apm_ind_pay_load     apm_pay_load;
  ds_dsd_ext_error_code       apm_error_code = DS_DSD_APM_UNSEPCIFIED;
  /*-----------------------------------------------------------------------*/

  memset(&apm_pay_load, 0, sizeof(ds_dsd_apm_ind_pay_load));

   /* If only the emergency PDN is up/coming_up; 
      we are Attached only for emergency calls. */
  if (TRUE == ds_3gpp_pdn_context_emergency_pdn_is_up(TRUE, subs_id) &&
     (FALSE == dsPdnContext_is_any_other_normal_pdn_up(NULL, subs_id)))
  {
    DS_LTE_MSG1_HIGH("ATTACH SM state EPS_EMERGENCY_ATTACHED"
                     " on Subs Id (CM)",subs_id);
    ds_eps_attach_sm_set_state(DS_EPS_EMERGENCY_ATTACHED,subs_id);
    return;
  }
  else 
  {
    DS_LTE_MSG1_HIGH("ATTACH SM state EPS_ATTACHED on Subs Id (CM) %d",subs_id);
    ds_eps_attach_sm_set_state(DS_EPS_ATTACHED,subs_id);
    /* cleaning up pending calls if any */
     ds_bearer_cntxt_clr_pending_calls((void*)&subs_id);
  }
 
  ds3gdsdif_notify_dsd_lte_attach_event(subs_id,
                                        DS_DSD_CLIENT_RADIO_EMMATTACHCOMPLETED_EV,
  	                                attach_type,
                                        PS_IFACE_3GPP_LTE);

  /*---------------------------------------------------------------------
    Notify APM module for LTE EMM ATTACH COMPLETED
  ---------------------------------------------------------------------*/
  apm_pay_load.ind_field_mask = DS_DSD_IND_ATTACH_TYPE_MASK;
  apm_pay_load.attach_type = attach_type;
  apm_pay_load.subs_id = subs_id;
  apm_error_code = ds_dsd_apm_ind(DS_DSD_APM_ATTACH_COMPLETE_IND,&apm_pay_load);
  DS_LTE_MSG1_MED("Posted Attach Complete to APM, error code: %d",apm_error_code);
  
  ds_3gpp_pdn_throt_advertise_blocked_apns_current_plmn(subs_id);


/* Register with PS DPM for bearer error callback after LTE Attach complete*/
   ps_dpm_err_ind_cback_reg( ds_3gpp_get_bearer_err_threshhold_cnt(),
                            ds_3gpp_bearer_cntxt_dpm_bearer_err_cb);


  return;
} /* ds_eps_attach_sm_handle_attach_complete_ind */

/*===========================================================================
FUNCTION DS_EPS_ATTACH_SM_HANDLE_GET_PDN_CONN_IND

DESCRIPTION
  If there are any pending calls, then GET_PDN_CONN_IND is cached and its
  processing is delayed till all pending calls are ended.

PARAMETERS
  attach_info.

DEPENDENCIES
  None.

RETURN VALUE
  Returns True if GET_PDN_CONN_IND is cached

SIDE EFFECTS
  None.

===========================================================================*/
static boolean ds_eps_attach_sm_handle_get_pdn_conn_ind
(
  ds3g_eps_attach_sm_info_type     *attach_info_ptr,
  sys_modem_as_id_e_type            subs_id
)
{
  boolean                    any_active_bearers = FALSE;
  ds_pdn_context_s          *pdn_cntx_p=NULL;
  ds_eps_attach_sm_s        *attach_sm_ptr = NULL;
  boolean                    any_hanging_context = FALSE;
  uint16                     attach_profile_id = 0;
  ds_umts_pdp_profile_type   prof_context;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  if (attach_info_ptr == NULL)
  {
    DS_LTE_MSG0_ERROR("attach info p is NULL");
    return FALSE;
  }

  /*--------------------------------------------------------------------------
    Request deactivation if any bearers are in COMING_UP state.
    3 Cases being handled here
   
    1. A bearer in coming up state which is default PDN's bearer and we
       receive PDN CONN IND
   
    Here we end that call and put the PDN and Bearer in Pending Redial
    Since we had a hanging bearer (COMING_UP or GOING_STATE)
    Now we need to cache the PDN Connectivity Request 
   
    Once the call end is received for hanging bearer we will perform a silent
    redial. The second check is not needed since it checks for Active bearers
   
    2. A bearer is in UP state and we receive a PDN CONN IND
   
    Here we see there is no hanging bearer but there is an active bearer so
    we still cache the PDN Conn request and once that call ends we will process
    this cached request
   
    3. Bearer is in PEND_REDIAL state and we receive a PDN CONN IND
   
    In this we dont need to cache the PDN CONN IND since it is not a hanging or
    active bearer so we go ahead and process the request right away.
   
    Note: Even if we get PDN CONN IND when a non-default PDN's bearer is being
    brought up or UP we will cache this request. This will just delay the
    processing of PDN CONN IND
   
    Check if a PDN is in going down state, This is needed because a bearer
    could be in DOWN STATE but the PDN may not be in DOWN state.
  --------------------------------------------------------------------------*/
 
  if(ds_eps_bearer_cntxt_req_deact_for_pending_bearers(subs_id) ||
     ds_3gpp_pdn_cntxt_is_any_pdn_going_down(subs_id))
  {
    any_hanging_context = TRUE;
  }


  if(any_hanging_context == FALSE)
  {
    any_active_bearers = ds_eps_bearer_cntxt_is_any_bearer_not_down(subs_id);

  }

  if (any_active_bearers || any_hanging_context)
  {

    DS_LTE_MSG2_HIGH("Found active bearer:%d  hanging bearer:%d, caching PDN_CONN_REQ",
                     any_hanging_context,
                     any_active_bearers);
    /*--------------------------------------------------------------------------
      If Def bearer for the attach/default PDN is in PEND_REDIAL state then
      change the PDN state to REDIAL as well.
    --------------------------------------------------------------------------*/
    pdn_cntx_p = ds_3gpp_pdn_cntxt_get_def_pdn(subs_id);
    attach_profile_id = ds_eps_get_attach_prof(subs_id);

    /*-------------------------------------------------------------------------
    Currently, only default PDNs can be put to PENDING_REDIAL
    -------------------------------------------------------------------------*/
    if(ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
    {
      if(ds_bearer_cntx_validate_bearer_context(pdn_cntx_p->ds_pdn_context_dyn_p
                                                ->def_bearer_context_ptr) &&
       (((ds_bearer_context_s*)pdn_cntx_p->ds_pdn_context_dyn_p->
         def_bearer_context_ptr)->ds_bearer_context_dyn_p->state ==
                                         DS_BEARER_CONTEXT_STATE_PEND_REDIAL))
      {
        DS_LTE_MSG0_HIGH("Default bearer/Default PDN Pending REDIAL");
        pdn_cntx_p->ds_pdn_context_dyn_p->state = DS_PDN_CONTEXT_STATE_PEND_REDIAL;
        attach_profile_id = (uint16)pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile_num;
      }
      else
      {
        /* This is the code-path for GOING_DOWN bearers for which attach would be retried
           after the PDN is freed similar to non-default PDN hanging bearers */
        DS_LTE_MSG1_HIGH("Default pdn bearer isn't in PEND_REDIAL: 0x%x",pdn_cntx_p);
      }
    }
    else
    {
      DS_LTE_MSG0_HIGH("Not a Default PDN context;Not Redialing");
    }

    attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(subs_id);
    if(attach_sm_ptr == NULL)
    {
      DS_LTE_MSG1_LOW("Invalid Attach SM ptr for Subs Id (CM) %d",subs_id);
      ASSERT(0);
      return FALSE;
    }
    /*--------------------------------------------------------------------------
      Update the ATTACH state
    --------------------------------------------------------------------------*/
    ds_eps_attach_sm_set_state(DS_EPS_CACHED_GET_PDN_CONN_IND,subs_id);
    attach_sm_ptr->cached_seq_num = attach_info_ptr->seq_num;
    attach_sm_ptr->cached_paging_response = attach_info_ptr->responding_to_page;
    DS_LTE_MSG0_HIGH("atleast one pending call,delaying GET_PDN_CONN_IND"
                     " processing");

    /*--------------------------------------------------------------------------- 
      Setting target rat when Attach Request is cached so that DSD wouldn't
      advertise non-LTE sys_mode before MH processes the attach request
    ---------------------------------------------------------------------------*/
    if(FALSE == ds3gmgr_send_trat_ind(SYS_SYS_MODE_LTE,
                                      attach_profile_id,
                                      &prof_context,
                                      subs_id))
    {
      return FALSE;
    }

    DS_LTE_MSG3_HIGH("Setting target rat while attach is cached, attach_profile: %d,"
		     "Subs Id (CM): %d, cached_seq_num: %d",
                            attach_profile_id,
                     subs_id,
                     attach_sm_ptr->cached_seq_num);


    return TRUE;
  }
  return FALSE;
} /* ds_eps_attach_sm_handle_get_pdn_conn_ind */

/*===========================================================================
FUNCTION  ds_eps_pdn_cntxt_get_attach_pdn

DESCRIPTION
This function gets the attach PDN from the APN table if it exists.

PARAMETERS
  pdn_cntx_p : OUT - Double Pointer to PDN context if there is one already
                     present in APN table.

DEPENDENCIES
  None.

RETURN VALUE
 TRUE: Success
 FALSE: Failure
SIDE EFFECTS
  None.

===========================================================================*/
static boolean ds_eps_pdn_cntxt_get_attach_pdn
(
  ds_pdn_context_s        **pdn_cntx_p,
  sys_modem_as_id_e_type    subs_id
)
{
  uint16                       attach_profile_num;
  ds_umts_pdp_context_type     attach_profile_context;
  ds_umts_pdp_profile_status_etype status =  DS_UMTS_PDP_FAIL;
  ds_apn_ip_support_type_e    attach_ip_support;
  ds_pdn_context_s              *v4_pdn_p=NULL,*v6_pdn_p=NULL;
  /*----------------------------------------------------------------------*/

  *pdn_cntx_p = ds_3gpp_pdn_cntxt_get_def_pdn(subs_id);

  if(*pdn_cntx_p != NULL)
  {
    DS_LTE_MSG1_HIGH("ds_eps_pdn_cntxt_get_attach_pdn. There is already "
                     "a default PDN 0x%x", pdn_cntx_p);
    return DS3G_SUCCESS;
  }

  attach_profile_num = ds_eps_get_attach_prof(subs_id);

  status = ds_umts_get_pdp_profile_context_info_per_subs( attach_profile_num,
                                                   dsumts_subs_mgr_get_subs_id(subs_id),
                                                   &attach_profile_context );

  if ( status != DS_UMTS_PDP_SUCCESS )
  {
    DS_LTE_MSG0_LOW("Unable to get profile context.");
    return DS3G_FAILURE;
  }

  /*--------------------------------------------------------------------------
  Check if there is an entry in APN table for attach APN
  This is to handle the case where an APN entry has a PDN context 
  allocated but the default flag was not set(No iface_up processed yet). 
  ------------------------------------------------------------------------*/
  if (ds_pdn_cntxt_get_apn_ip_support_info(attach_profile_context.apn,
                                           &attach_ip_support,
                                           subs_id) == TRUE)
  {
    /*-------------------------------------------------------------------------
    Below fns must return TRUE always since we entered here by finding an
    entry in APN table.
    -------------------------------------------------------------------------*/
    if ( FALSE == ds_pdn_cntxt_get_v4_pdn_context(attach_profile_context.apn,
                                                  &v4_pdn_p, subs_id) ||
         FALSE == ds_pdn_cntxt_get_v6_pdn_context(attach_profile_context.apn,
                                                  &v6_pdn_p, subs_id))
    {
      ASSERT(0);
      return DS3G_FAILURE;
    }

    /*-----------------------------------------------------------------------
    Now check if the IP type in attach profile and APN table matches.
    ----------------------------------------------------------------------*/
    DATA_3GPP_MSG_SPRINTF_1(MSG_LEGACY_HIGH,"Attach APN: %s is present in APN table",
                     attach_profile_context.apn);

    DS_LTE_MSG2_HIGH("IP type in APN Table: %d, IP Type in Attach Profile: %d",
                     attach_ip_support, attach_profile_context.pdp_type);

    switch (attach_ip_support)
    {
    case DS_IPV4_ONLY:
        if( attach_profile_context.pdp_type == DS_UMTS_PDP_IPV4 ||
            attach_profile_context.pdp_type == DS_UMTS_PDP_IP ||
            attach_profile_context.pdp_type == DS_UMTS_PDP_IPV4V6)
        {
          *pdn_cntx_p =  v4_pdn_p;
        }
        else
        {
          DS_LTE_MSG0_LOW("IP type mismatch between attach profile and "
                          "attach PDN in APN table.");
        }
        break;

    case DS_IPV6_ONLY:
        if( attach_profile_context.pdp_type == DS_UMTS_PDP_IPV6 ||
            attach_profile_context.pdp_type == DS_UMTS_PDP_IPV4V6)
        {
          *pdn_cntx_p =  v6_pdn_p;
        }
        else
        {
          DS_LTE_MSG0_LOW("IP type mismatch between attach profile and "
                          "attach PDN in APN table.");
        }
        break;

    case DS_IPV4V6:
        if( attach_profile_context.pdp_type != DS_UMTS_PDP_IPV4V6 )
        {
          /* This means, there is already an entry in APN table for this
          APN, but the IP types do not match strictly. This is a
          configuration issue. But still, to define a behavior in this case,
          we go with whatever we already have in APN table.
          */
          DS_LTE_MSG0_LOW("Error. Profiles are configured"
                           "with same APN but one is single IP and "
                           "other is Dual IP");
        }
        *pdn_cntx_p =  v4_pdn_p;
        break;

    case DS_SINGLE_BEARER:
        /*---------------------------------------------------------------------
        Note: If the attach profile is configured as V4V6, and the APN table
        already has different V4 and V6 PDNs for this APN(SB case), then there
        is a possibility of pdn_cntx_p overwrite in the logic below.
        Configuring profiles this way is erroneous in the first place, hence our
        implementation assumes this behavior. As long as we any pick one PDN
        we are fine.
        ----------------------------------------------------------------------*/
        if(v4_pdn_p != NULL)
        {
          //This is V4 Single bearer case. So if the profile is of type
          //V4V6 or V4 only, this PDN can be used as default.
          if( attach_profile_context.pdp_type == DS_UMTS_PDP_IPV4V6 ||
              attach_profile_context.pdp_type == DS_UMTS_PDP_IPV4 ||
              attach_profile_context.pdp_type == DS_UMTS_PDP_IP)
          {
            *pdn_cntx_p = v4_pdn_p;
          }
        }
        if (v6_pdn_p != NULL)
        {
          //This is V6 Single bearer case. So if the profile is of type
          //V4V6 or V6 only, this PDN can be used as default.
          if( attach_profile_context.pdp_type == DS_UMTS_PDP_IPV4V6 ||
              attach_profile_context.pdp_type == DS_UMTS_PDP_IPV6 )
          {
            *pdn_cntx_p = v6_pdn_p;
          }
        }
        break;

    default:
        ASSERT(0);
        break;
    } //switch

    /*-------------------------------------------------------------------------
    If we got a valid PDN out of our comparison in the switch above, then
    we can set that as default here
    -------------------------------------------------------------------------*/
    if(ds_3gpp_pdn_cntx_validate_pdn_context(*pdn_cntx_p))
    {
      (*pdn_cntx_p)->ds_pdn_context_dyn_p->is_default = TRUE;
    }
    else
    {
      DS_LTE_MSG0_ERROR("Cant get PDN eventhough APN is present in APN table");
    }
  }//APN present in APN table
  else
  {//There is no entry in APN table.
    *pdn_cntx_p = NULL;
  }
  return DS3G_SUCCESS;
}

/*===========================================================================
FUNCTION  ds_eps_pdn_cntxt_configure_ps_iface

DESCRIPTION
  This function configures the necessary parameters in PS Iface before 
  attempting to bring up the iface.

PARAMETERS
  pdn_cntx_p  : PDN context pointer
  addr_family : IP Address Family   

DEPENDENCIES
  None.

RETURN VALUE
 TRUE: Success
 FALSE: Failure

SIDE EFFECTS
  None.

===========================================================================*/
boolean ds_eps_pdn_cntxt_configure_ps_iface
(
  ds_pdn_context_s*         pdn_cntx_p,
  ip_addr_enum_type         addr_family,
  sys_modem_as_id_e_type    subs_id

)
{
  ps_iface_type                  *ps_iface_p = NULL;
  boolean                         ret_val = FALSE;
  ps_sys_subscription_enum_type   ps_subs_id;
  /*-----------------------------------------------------------------*/

  ps_subs_id = (ps_sys_subscription_enum_type) 
                 ds3gsubsmgr_subs_id_cm_to_ds(subs_id);

  switch (addr_family)
  {
    case IFACE_IPV4_ADDR_FAMILY:
    {
      ps_iface_p = DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_cntx_p);
      break;
    }

    case IFACE_IPV6_ADDR_FAMILY:
    {
      ps_iface_p = DSPDNCNTXT_GET_V6_PS_IFACE_PTR(pdn_cntx_p);
      break;
    }

    default:
      break;
  }

  if (ps_iface_p != NULL)
  {
    if (ps_iface_set_addr_family(ps_iface_p, addr_family) != 0)
    {
      DS_LTE_MSG1_ERROR("Could not set addr family to %d", addr_family);
    }
    else
    {
      PS_IFACE_SET_SUBS_ID(ps_iface_p, ps_subs_id);
      ret_val = TRUE;
    }
  }

  return ret_val;
} /* ds_eps_pdn_cntxt_configure_ps_iface */

/*===========================================================================
FUNCTION  ds_eps_pdn_cntxt_allocate_pdn_and_bringup_ifaces

DESCRIPTION
  This functions allocates a new PDN context and new DS ifaces and brings up
  the ifaces.

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  DS3G_SUCCESS - if all operations went fine
  DS3G_FAILURE - on error

SIDE EFFECTS
  None.

===========================================================================*/
boolean ds_eps_pdn_cntxt_allocate_pdn_and_bringup_ifaces
(
  uint16                    profile_no,
  ps_iface_type           **iface,
  ds_umts_pdp_profile_type *prof_context,
  sys_modem_as_id_e_type    subs_id
)
{
  boolean                   return_value     = DS3G_SUCCESS;
  int                       ret_val          = 0;
  int16                     ps_error;
  ds_apn_ip_support_type_e  ip_support;
  ds_pdn_context_s*         pdn_cntx_p       = NULL;
  ds_3gpp_iface_s          *ds_iface_v4_p, *ds_iface_v6_p;
  ds_dsd_apm_ind_pay_load   ind_payload;
  ds_eps_attach_sm_s       *attach_sm_ptr    = NULL;
  ds_eps_attach_fb_type     attach_fb_ip_support = DS_EPS_ATTACH_FB_IP_TYPE_MIN;
  uint8                     index = 0;
  boolean ds_3gpp_pdp_profile_process_status = FALSE;

  if (!ds3gsubsmgr_is_subs_id_valid(subs_id))
  {
    return_value = DS3G_FAILURE;
    goto exit_function;
  }
  /*---------------------------------------------------------------------------
   Allocate a new PDN context
  ---------------------------------------------------------------------------*/
  pdn_cntx_p = ds_pdn_cntxt_allocate_new_pdn_context(subs_id);

  if(!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
  {
    return_value = DS3G_FAILURE;
    goto exit_function;
  }

  /*----------------------------------------------------------------------
  Set this PDN as default, since it was never done before
  -----------------------------------------------------------------------*/
  if(iface == NULL)
  {
    pdn_cntx_p->ds_pdn_context_dyn_p->is_default = TRUE;
  }
  else
  {
    pdn_cntx_p->ds_pdn_context_dyn_p->keep_alive_pdn = TRUE;
  }

  pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile_num = profile_no;
  ds_3gpp_pdp_profile_process_status = ds_pdn_cntxt_process_pdp_profile_info(
                              pdn_cntx_p,
                              pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile_num,
                              &ip_support, prof_context);
  pdn_cntx_p->ds_pdn_context_dyn_p->profile_is_valid = 
     ds_3gpp_pdp_profile_process_status;

  if(ds_3gpp_pdp_profile_process_status == FALSE)
  {
    DS_LTE_MSG0_ERROR("pdp_profile can't be processed");
    return_value = DS3G_FAILURE;
    goto exit_function;
  }

  /*------------------------------------------------------------------------- 
    Notify APM regarding ATTACH PDP Type only for attach PDN
  -------------------------------------------------------------------------*/
  if( pdn_cntx_p->ds_pdn_context_dyn_p->is_default )
  {
    memset(&ind_payload, 0, sizeof(ds_dsd_apm_ind_pay_load));
    ind_payload.subs_id = subs_id;
    ind_payload.attach_pdp_type
      = (ds_profile_3gpp_pdp_type_enum_type)
          pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type;
    (void)ds_dsd_apm_ind(DS_DSD_APM_ATTACH_PDP_TYPE_IND, &ind_payload);
  }

  /*-------------------------------------------------------------------------
      Check if there was a previous attach attempt, that failed. This may
      be a retry attach request attempt
    -------------------------------------------------------------------------*/
  if(ds_eps_get_lte_attach_dual_ip_fb_status(subs_id) == TRUE)
  {
    attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(subs_id);
    if ((attach_sm_ptr != NULL) &&
        (attach_sm_ptr->prev_attach_status.is_attach_fail == TRUE)
       )
    {
      DS_LTE_MSG1_HIGH("Previous attach attempt failed with cause 0x%x",
                         attach_sm_ptr->prev_attach_status.down_reason);

      if ((ip_support  == DS_IPV4V6)&&
          (attach_sm_ptr->prev_attach_status.down_reason    ==
                                              PS_NET_DOWN_REASON_UNKNOWN_PDP)
         )
      {
        /*--------------------------------------------------------------- 
          The previous attach attempt failed with ESM cause #28. So we
          cannot set PDN IP Type to IPV4V6. Set the PDN Ip type to
          IPV4 (or) IPV6 only depending on the NV setting. If NV setting
          is not configured, current behaviour default to PDN IP type
          IPV4.
          ---------------------------------------------------------------*/
        attach_fb_ip_support = ds_eps_get_lte_attach_dual_ip_fb_ip_type(subs_id);

        if (attach_fb_ip_support == DS_EPS_ATTACH_FB_IP_TYPE_IPV6)
        {
          pdn_cntx_p->ds_pdn_context_dyn_p->
                      pdp_profile.context.pdp_type = DS_UMTS_PDP_IPV6;
          ip_support = DS_IPV6_SINGLE_BEARER;
        }
        else
        {
          pdn_cntx_p->ds_pdn_context_dyn_p->
                      pdp_profile.context.pdp_type = DS_UMTS_PDP_IPV4;
          ip_support = DS_IPV4_SINGLE_BEARER;
        }
      }
    }
  }

  switch(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type)
  {
    case DS_UMTS_PDP_IPV4:
      ds_iface_v4_p = ds_pdn_cntxt_allocate_ds_iface();
      if(ds_iface_v4_p == NULL)
      {
        DS_LTE_MSG0_ERROR("Cant allocate V4 DS iface");
        return_value = DS3G_FAILURE;
        goto exit_function;
      }
      ds_iface_v4_p->client_data_ptr = pdn_cntx_p;
      pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
        [DS_3GPP_PDN_CONTEXT_IPV4_IFACE] = ds_iface_v4_p;
      ds_iface_v4_p->post_proc_done_flag = TRUE;

      if(ds3g_is_ipv6_enabled() == TRUE)
      {
        ds_3gpp_pdn_context_v6_sm_update(ds_iface_v4_p,subs_id);
      }

      if (ds_eps_pdn_cntxt_configure_ps_iface
            (pdn_cntx_p, IFACE_IPV4_ADDR_FAMILY, subs_id))
      {
        ret_val = ps_iface_active_bring_up_cmd
                    (DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_cntx_p), &ps_error, NULL);
      }
      else
      {
        ret_val = 0;
        ps_error = DS_EOPNOTSUPP;
        ASSERT(0);
      }

      #ifdef FEATURE_DATA_WLAN_MAPCON
        if(iface != NULL)
        {
          *iface = DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_cntx_p);
        }
      #endif /*FEATURE_DATA_WLAN_MAPCON*/
      break;

    case DS_UMTS_PDP_IPV6:
      if(ds3g_is_ipv6_enabled() == TRUE)
      {
        ds_iface_v6_p = ds_pdn_cntxt_allocate_ds_iface();
        if(ds_iface_v6_p == NULL)
        {
          DS_LTE_MSG0_ERROR("Cant allocate V6 DS iface");
          return_value = DS3G_FAILURE;
          goto exit_function;
        }
        ds_iface_v6_p->client_data_ptr = pdn_cntx_p;
        pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[DS_3GPP_PDN_CONTEXT_IPV6_IFACE] =
                                                     ds_iface_v6_p;
        ds_iface_v6_p->post_proc_done_flag = TRUE;

        ds_3gpp_pdn_context_v6_sm_update(ds_iface_v6_p,subs_id);

        if (ds_eps_pdn_cntxt_configure_ps_iface
              (pdn_cntx_p, IFACE_IPV6_ADDR_FAMILY, subs_id))
        {
          ret_val = ps_iface_active_bring_up_cmd
                      (DSPDNCNTXT_GET_V6_PS_IFACE_PTR(pdn_cntx_p), &ps_error, NULL);
        }
        else
        {
          ret_val = 0;
          ps_error = DS_EOPNOTSUPP;
          ASSERT(0);
        }

        #ifdef FEATURE_DATA_WLAN_MAPCON
          if(iface != NULL)
          {
            *iface = DSPDNCNTXT_GET_V6_PS_IFACE_PTR(pdn_cntx_p);
          }
        #endif /*FEATURE_DATA_WLAN_MAPCON*/
      }
      else
      {
        DS_LTE_MSG0_ERROR("Cannot initiate Attach with V6 prof."
                          " V6 NV not enabled");
        ret_val = 0;
        ps_error = DS_EOPNOTSUPP;
      }
      break;

    case DS_UMTS_PDP_IPV4V6:
      ds_iface_v4_p = ds_pdn_cntxt_allocate_ds_iface();

      if(ds_iface_v4_p == NULL)
      {
        DS_LTE_MSG0_ERROR("Could not allocate V4 iface");
        return_value = DS3G_FAILURE;
        goto exit_function;
      }

      ds_iface_v4_p->client_data_ptr = pdn_cntx_p;
      pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[DS_3GPP_PDN_CONTEXT_IPV4_IFACE] =
                                                           ds_iface_v4_p;
      ds_iface_v4_p->post_proc_done_flag = TRUE;

      if(ds3g_is_ipv6_enabled() == TRUE)
      {
        ds_3gpp_pdn_context_v6_sm_update(ds_iface_v4_p,subs_id);
      }

      if (ds_eps_pdn_cntxt_configure_ps_iface
            (pdn_cntx_p, IFACE_IPV4_ADDR_FAMILY, subs_id) == FALSE)
      {
        ret_val = 0;
        ps_error = DS_EOPNOTSUPP;
        ASSERT(0);
      }

      else
      {
        if(ds3g_is_ipv6_enabled() == TRUE)
        {
          ds_iface_v6_p = ds_pdn_cntxt_allocate_ds_iface();
          /* If V6 iface alloc fails then fallback to V4 single bearer */
          if(ds_iface_v6_p == NULL)
          {
            DATA_ERR_FATAL("Could not set addr family to V6");
          }
          else
          {
            ds_iface_v6_p->client_data_ptr = pdn_cntx_p;

            pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl[DS_3GPP_PDN_CONTEXT_IPV6_IFACE] =
                                                         ds_iface_v6_p;

            ds_iface_v6_p->post_proc_done_flag = TRUE;

            ds_3gpp_pdn_context_v6_sm_update(ds_iface_v6_p,subs_id);

            if (ds_eps_pdn_cntxt_configure_ps_iface
                  (pdn_cntx_p, IFACE_IPV6_ADDR_FAMILY, subs_id))
            {
              ret_val = ps_iface_active_bring_up_cmd(
                DSPDNCNTXT_GET_V6_PS_IFACE_PTR(pdn_cntx_p), &ps_error, NULL);
            }
            else
            {
              ret_val = 0;
              ps_error = DS_EOPNOTSUPP;
              ASSERT(0);
            }
          }

        }
        else
        {
          DS_LTE_MSG0_ERROR("Attach with V4V6 prof V6 NV not enabled");
          ret_val = -1;
          ps_error = DS_EWOULDBLOCK;

          /*-----------------------------------------------------------------
            Update the APN table to V4 Single Bearer since V6 NV item is OFF
            Also indicate to APM about the unavailability of IPV6 address
          -----------------------------------------------------------------*/
          ip_support = DS_IPV4_SINGLE_BEARER;
          if(iface == NULL)
          {
            memset(&ind_payload, 0, sizeof(ds_dsd_apm_ind_pay_load));
            DS_3GPP_APM_SET_INVALID_V6_IPADDR(ind_payload, 
                                            PS_NET_DOWN_REASON_NOT_SPECIFIED); 
            DS_3GPP_APM_SET_PROFILE_ID(ind_payload, (uint16)pdn_cntx_p->
                                     ds_pdn_context_dyn_p->pdp_profile_num);      
            ind_payload.subs_id = subs_id; 
           (void)ds_dsd_apm_ind(DS_DSD_APM_IP_ADDRESS_IND, &ind_payload);
          }
        }
      }

      if(ret_val != 0 && ps_error== DS_EWOULDBLOCK)
      {
        ret_val = ps_iface_active_bring_up_cmd(
        DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_cntx_p), &ps_error, NULL);
        #ifdef FEATURE_DATA_WLAN_MAPCON
          if(iface != NULL)
          {
            *iface = DSPDNCNTXT_GET_V4_PS_IFACE_PTR(pdn_cntx_p);
          }
        #endif /*FEATURE_DATA_WLAN_MAPCON*/
      }

      break;

    default:
      DS_LTE_MSG0_HIGH("Unknown PDP type. Cannot Initiate Attach process");
      /*----------------------------------------------------------------------
        Write some values into ret_val and ps_error so that we can avoid Lint
        errors. Also values are written such that we will enter the error
        checking below.
      ----------------------------------------------------------------------*/
      ret_val = 0;
      ps_error = DS_EOPNOTSUPP;
      break;
  } /* switch */

  if(ret_val != 0 && ps_error!= DS_EWOULDBLOCK)
  {
    ASSERT(0);
  }

  if(ret_val == 0 && ps_error == DS_EOPNOTSUPP)
  {
    DS_LTE_MSG2_ERROR("Iface Bring Up error. ret_val: %d, err code:%d",
                      ret_val, ps_error);
    return_value = DS3G_FAILURE;
    goto exit_function;
  }

  /*--------------------------------------------------------------------------
      Update the APN table so that we have some info in the table while the call
      is initated.
  --------------------------------------------------------------------------*/
  if(ds_apn_table_add_pdn(pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn,
                                  ip_support,
                                  pdn_cntx_p) != DS3G_SUCCESS)
  {
    DS_LTE_MSG2_ERROR("Error updating APN table. Pdn: 0x%x, IP support:%d",
                      pdn_cntx_p,ip_support);
    return_value = DS3G_FAILURE;
    goto exit_function;
  }

exit_function:
  if((ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p)
      && return_value == DS3G_FAILURE))
  {
    DS_LTE_MSG1_ERROR("Iface bring up failed. Remove the PDN entry from the " 
                      "APN table and free the PDN 0x%x",
                      pdn_cntx_p);

    /*-----------------------------------------------------------------------
      Remove the entry from the APN table
    -----------------------------------------------------------------------*/
    if(ds_pdn_cntxt_remove_entry_in_apn_table(pdn_cntx_p) == FALSE)
    {
      DS_3GPP_MSG0_ERROR("Invalid PDN Passed to remove apn table");
    }

#ifdef FEATURE_DATA_LTE
    /* Find an entry in the PDN Limit Table. If an entry is found,
       validate if the entry can be cleared at this point. If yes,
       clear the entry */
    if((index = ds_3gpp_pdn_limit_tbl_find_entry
         ((byte*)pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn,
           subs_id)) != DS_3GPP_PDN_LIMIT_TBL_INVALID_ENTRY)
    {
      ds_3gpp_pdn_limit_tbl_remove_entry(index, subs_id);
    }
#endif /*FEATURE_DATA_LTE*/

    ds_pdn_cntxt_freeInstance(pdn_cntx_p);
  }

  return return_value;
}
/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_BRING_UP_ATTACH_PDN

DESCRIPTION
  This function is responsible for the initiation of sending out PDN conn
  request during attach process. This function accesses the PDP registry,
  caches info in the PDN context, binds Ifaces and PDNs appropriately and
  calls iface active bring up.

  This function is called from 3GPP HDLR for EMM attach or from Resume handler
  to bring up the connection to default PDN

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  DS_EPS_BRINGUP_ATTACH_PDN_FAIL - if the attach APN is disabled
  DS_EPS_BRINGUP_ATTACH_PDN_PEND_REDIAL - if all operatins went
                      fine in Pending Redial handling
  DS_EPS_BRINGUP_ATTACH_PDN_SUCCESS - if all operations went fine
                      when it is not Pending Redial handling

SIDE EFFECTS
  None.

===========================================================================*/
LOCAL ds_eps_bringup_attach_pdn_result_e ds_eps_pdn_cntxt_bring_up_attach_pdn
(
  sys_modem_as_id_e_type    subs_id
)
{
  ds_pdn_context_s                      *pdn_cntx_p=NULL;
  int16                                  ps_error;
  ds_eps_bringup_attach_pdn_result_e     return_value = 
                                           DS_EPS_BRINGUP_ATTACH_PDN_SUCCESS;
  int                                    index;
  boolean                                apn_disable_flag = FALSE;
  uint16                                 profiles_list
                                           [DS_3GPP_CFG_PROFILES_MAX + 1];
  int                                    num_profiles;
  ds_eps_attach_sm_s                    *attach_sm_ptr = NULL;
  uint16                                 profile;
  uint16                                 attach_profile_id = 0;
  sys_modem_as_id_e_type                 pdn_cntxt_subs_id = SYS_MODEM_AS_ID_NONE;
  ds_dsd_apm_ind_pay_load                ind_payload = {0};
  ps_sys_event_3gpp_lte_attach_init_type attach_event_info;
  boolean                                attach_init = FALSE;
  ds_umts_pdp_profile_type               prof_context;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*------------------------------------------------------------------------------
    Inform APM that we are starting attach. This has to be called before
    querying APM for the attach APN.
  ------------------------------------------------------------------------------*/
  if (!ds3gsubsmgr_is_subs_id_valid(subs_id))
  {
    ds_eps_pdn_cntx_reset_attach_sm_params(subs_id);
    return DS_EPS_BRINGUP_ATTACH_PDN_FAIL;
  }
  ind_payload.subs_id = subs_id;

  /*-----------------------------------------------------------------------
    Ensure that MH posts ATTACH_INIT_IND to APM only if this is a fresh 
    attach and not just because attach PDN is being brought up while there 
    is another active PDN.
  -----------------------------------------------------------------------*/
  memset(&prof_context, 0, sizeof(ds_umts_pdp_profile_type));
  
  if (FALSE == dsPdnContext_is_any_other_normal_pdn_up(NULL, subs_id))
  {
    attach_init = TRUE;
    (void)ds_dsd_apm_ind(DS_DSD_APM_ATTACH_INIT_IND,&ind_payload); 
  
    /*----------------------------------------------------------------------
      Initiation of attach. Set Target_Rat to LTE
    ----------------------------------------------------------------------*/
    attach_profile_id = ds_eps_get_attach_prof(subs_id);
    DS_LTE_MSG0_HIGH("Attach initiation. Set Target_Rat to LTE");

    if(FALSE == ds3gmgr_send_trat_ind(SYS_SYS_MODE_LTE, 
                                      attach_profile_id, &prof_context,
                                      subs_id))
    {
      ds_3gpp_pdn_cntxt_block_plmn(subs_id);
      ds_eps_pdn_cntx_reset_attach_sm_params(subs_id);
      return DS_EPS_BRINGUP_ATTACH_PDN_FAIL;
    }
  }
  else
  {
    attach_profile_id = ds_eps_get_attach_prof(subs_id);
    
    if (DS_UMTS_PDP_SUCCESS != ds_umts_get_pdp_profile_all_data_per_subs(
	                                            attach_profile_id, 
												dsumts_subs_mgr_get_subs_id(subs_id), 
												&prof_context))
    {
      DS_LTE_MSG1_ERROR("Invalid attach_profile_id: %d", attach_profile_id);
      return DS_EPS_BRINGUP_ATTACH_PDN_FAIL;
    }
  
    DS_LTE_MSG1_HIGH("Not fresh attach, bringing up attach PDN after IRAT"
                     " Attach profile_id: %d", attach_profile_id);
  }

  PS_ENTER_CRIT_SECTION(&global_ps_crit_section);

  /*-------------------------------------------------------------------------
    Check min APN list and if any APN is diabled,call the CM API to disable
    LTE altogether
  -------------------------------------------------------------------------*/
  if(ds_3gpp_cfg_get_subsid(DS_3GPP_CFG_PROFILE_LIST,
                    (unsigned char *) &profiles_list[0],
                    (sizeof(uint16) * DS_3GPP_CFG_PROFILES_MAX),
                     subs_id) == -1)
  {
      DS_LTE_MSG0_ERROR("Cannot read EFS Config item DS_3GPP_CFG_PROFILE_LIST");
  }
  else
  {
    num_profiles = profiles_list[0];
    if((num_profiles < 0) || (num_profiles >=  DS_3GPP_CFG_PROFILES_MAX))
    {
      DS_LTE_MSG0_ERROR("Invalid Profile List, not checking apn disable flag");
    }
    else
    {
      for(index = 1; index <= num_profiles; index++)
      {
         profile = profiles_list[index];
         if (ds_3gpp_profile_cache_get_cache_index(profile, 
                                dsumts_subs_mgr_get_subs_id(subs_id)) == -1)
         {
           continue;
         }
         if(ds_umts_get_pdp_profile_apn_disable_flag_per_subs(profile,
                                                dsumts_subs_mgr_get_subs_id(subs_id),
                                                &apn_disable_flag) !=
                                                           DS_UMTS_PDP_SUCCESS)
         {
           DS_LTE_MSG0_ERROR("Cannot read APN disable flag in"
                             "Attach profile");
            continue;
         }

         if(apn_disable_flag == TRUE)
         {
           /*------------------------------------------------------------------
             Disable the option of attaching to LTE network
           ------------------------------------------------------------------*/
           DS_LTE_MSG1_HIGH("Disabling LTE srv during init - APN (%d)"
                            "is disabled", profile);
           ds3g_msh_disable_lte_selection_ex(subs_id);
           return_value = DS_EPS_BRINGUP_ATTACH_PDN_FAIL;
           goto exit_function;
        }
      }
    }
  }

  /*-----------------------------------------------------------------------
                         START FRESH ATTACH
  ------------------------------------------------------------------------*/
  /*-------------------------------------------------------------------------
   Check if we already have a PDN configured with attach profile in APN table.
   This can happen if the app tries to bring up a call before we do attach
   processing.
  -------------------------------------------------------------------------*/
  if (ds_eps_pdn_cntxt_get_attach_pdn(&pdn_cntx_p,subs_id) == DS3G_FAILURE)
  {
    DS_LTE_MSG1_HIGH("Error while getting Attach PDN on Subs Id (CM) %d",
                     subs_id);
    return_value = DS_EPS_BRINGUP_ATTACH_PDN_FAIL;
    goto exit_function;
  }

  if((pdn_cntx_p != NULL) &&
     (pdn_cntx_p->ds_pdn_context_dyn_p != NULL) &&
     (pdn_cntx_p->ds_pdn_context_dyn_p->cookie == PDN_CNTXT_VALID_COOKIE) )
  {

    if(ds_3gpp_pdn_cntxt_get_subs_id_from_pdn(pdn_cntx_p,&pdn_cntxt_subs_id))
    {
      if (pdn_cntxt_subs_id != subs_id)
      {
        DS_LTE_MSG2_ERROR("Error using Attach sub id %d and pdn cntxt sub id %d for Attach"
                         ,subs_id,pdn_cntxt_subs_id);
        return_value = DS_EPS_BRINGUP_ATTACH_PDN_FAIL;
        goto exit_function;
      }
    }
    else
    {
      return_value = DS_EPS_BRINGUP_ATTACH_PDN_FAIL;
      goto exit_function;
    }
  /*-------------------------------------------------------------------------
    Check the state of the PDN context - If the PDN context is in up state,
    return without any further operation
  -------------------------------------------------------------------------*/
    if((pdn_cntx_p->ds_pdn_context_dyn_p->state != DS_PDN_CONTEXT_STATE_DOWN) &&
       (pdn_cntx_p->ds_pdn_context_dyn_p->state != DS_PDN_CONTEXT_STATE_PEND_REDIAL)  )
    {
      DS_LTE_MSG1_HIGH("Default PDN not in DOWN / redial state %d- Ignore Bring up",
                       pdn_cntx_p->ds_pdn_context_dyn_p->state);
      PS_LEAVE_CRIT_SECTION(&global_ps_crit_section);
      return DS_EPS_BRINGUP_ATTACH_PDN_FAIL;
    }

  /*----------------------------------------------------------------------------
   If the PDN Context is in pending redial state, we ignore the LTE Attach Profile
   and continue to use the profile which was used to bring up the UMTS call
   ----------------------------------------------------------------------------*/
    if(pdn_cntx_p->ds_pdn_context_dyn_p->state == DS_PDN_CONTEXT_STATE_PEND_REDIAL)
    {
      attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(subs_id);
      if(attach_sm_ptr == NULL)
      {
        DS_LTE_MSG1_LOW("Invalid Attach SM ptr for sub id %d",subs_id);
        PS_LEAVE_CRIT_SECTION(&global_ps_crit_section);
        return DS_EPS_BRINGUP_ATTACH_PDN_FAIL;
      }
      
      if (ds_eps_pdn_cntxt_is_silent_redial_allowed(pdn_cntx_p))
      {
	  ds_dsd_apm_unset_ip_rule_required(subs_id);
          DS_LTE_MSG0_HIGH("Redialing PDN conn as part of Attach process, "
                       "Continuing to use the profile which was used to "
                       "bringup UMTS call");
      /*-------------------------------------------------------------------------
        Sys_mode may not have been updated to LTE hence calling mode specific
        handler instead of the generic one.
        ds_bearer_cntxt_redial(
        (ds_bearer_context_s*)(pdn_cntx_p->def_bearer_context_ptr));
        Setting is_gw_originated here since the code path is common for all IRAT
        scenarios.
      -------------------------------------------------------------------------*/
      attach_sm_ptr->is_gw_originated = TRUE;
      pdn_cntx_p->ds_pdn_context_dyn_p->state = DS_PDN_CONTEXT_STATE_COMING_UP;

      /*-------------------------------------------------------------------------
        Notify APM regarding ATTACH PDP Type
      -------------------------------------------------------------------------*/
      memset(&ind_payload, 0, sizeof(ds_dsd_apm_ind_pay_load));
      ind_payload.subs_id = subs_id;
      ind_payload.attach_pdp_type
        = (ds_profile_3gpp_pdp_type_enum_type)
            pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type;
      (void)ds_dsd_apm_ind(DS_DSD_APM_ATTACH_PDP_TYPE_IND, &ind_payload);

      (void)ds_eps_bearer_cntxt_redial_hdlr(
        (ds_bearer_context_s*)(pdn_cntx_p->ds_pdn_context_dyn_p
                               ->def_bearer_context_ptr));
      PS_LEAVE_CRIT_SECTION(&global_ps_crit_section);
      return DS_EPS_BRINGUP_ATTACH_PDN_PEND_REDIAL;
    }
      else
      {
        /*--------------------------------------------------------------------------
          If redial is not allowed, we need cleanup the PDN which is in 
          PEND_REDIAL state and cache the current Attach sequence number. 
          After PDN cleanup, cached attach would be processed.

          The handling in this case is for Scenario 1:
          1. PDP Context is originated on W/G/TD on attach profile in Roam PLMN.
          2. Netowrk redirected UE to LTE.
          3. NAS/CM ended the call with internal reason: GWL_IRAT.
          4. As pdn_context is default bearer and PDN are set to PEND_EDIAL.
          5. LTE Attach is initiated in Home PLMN. So pdp_type doesn't match.          
        --------------------------------------------------------------------------*/
        ds_eps_attach_sm_set_state(DS_EPS_CACHED_GET_PDN_CONN_IND,subs_id);
        attach_sm_ptr->cached_seq_num = attach_sm_ptr->seq_num;
        attach_sm_ptr->seq_num = 0;
        DS_LTE_MSG0_HIGH("atleast one pending call,delaying GET_PDN_CONN_IND"
                         " processing");
	ds_bearer_cntx_local_cleanup(pdn_cntx_p->ds_pdn_context_dyn_p->def_bearer_context_ptr);
      }
    }

    DS_LTE_MSG0_HIGH("Default PDN exists but in DOWN state. ");
  } /* pdn_cntx_p != NULL */

  else
  {
    if(TRUE == ds_eps_pdn_cntxt_allocate_pdn_and_bringup_ifaces(
                                                   attach_profile_id,
                                                   NULL,
                                                   &prof_context,
                                                   subs_id))
    {
      if (attach_init == TRUE)
      {
        /*-------------------------------------------------------------------------
        Send PS_SYS_LTE_ATTACH_INIT_EV. The payload is the attach
        profile. 
        -------------------------------------------------------------------------*/
        attach_event_info.attach_profile = attach_profile_id;
  
        (void)ps_sys_event_ind_ex(
                                   PS_SYS_TECH_3GPP,
                                   PS_SYS_EVENT_3GPP_LTE_ATTACH_INIT,
                                   (ps_sys_subscription_enum_type)
                                     ds3gsubsmgr_subs_id_cm_to_ds(subs_id),
                                   (void*)&attach_event_info,
                                  &ps_error
                                 );
        DS_LTE_MSG0_HIGH("Sent PS_SYS_EVENT_3GPP_LTE_ATTACH_INIT ");
        return_value = DS_EPS_BRINGUP_ATTACH_PDN_SUCCESS;
      }
    }
    else
    {  
      return_value = DS_EPS_BRINGUP_ATTACH_PDN_FAIL;
    }
  }

  /*Before exiting the function we need to reset the Attach SM*/


exit_function:
  PS_LEAVE_CRIT_SECTION(&global_ps_crit_section);

  /*--------------------------------------------------------------------------
    Move the attach SM to NUL State if return value is FAILURE
  --------------------------------------------------------------------------*/
  if(return_value == DS_EPS_BRINGUP_ATTACH_PDN_FAIL)
  {
    DS_LTE_MSG1_HIGH("Resetting attach SM to NULL State for Subs Id (CM) %d",
                     subs_id);
    ds_eps_pdn_cntx_reset_attach_sm_params(subs_id);
  }
  return return_value;
} /* ds_eps_pdn_cntxt_bring_up_attach_pdn */


/*===========================================================================
FUNCTION      DS_EPS_PDN_CNTXT_GET_LTE_ATTACH_PARAMS

DESCRIPTION
  Updates the Attach profile APN and PDP type info when an IOCTL query
  is received if ota_attach_performed is TRUE.
  Returns Failure if
  1. Input parameters are invalid.
  2. Default PDN context is not UP.

PARAMETERS
  ioctl_name[in]  -      Operation name
  arg_val_ptr[in] -  Pointer to operation specific argument
  ps_errno [out]    -    Specifies type of error in case of error.
                             DS_EFAULT if parameter is invalid
                             DS_EINVAL if operation is invalid
                             DS_NOMEMORY if memory allocation fails

DEPENDENCIES
  None.

RETURN VALUE
  0  - Success
 -1 - Failure

SIDE EFFECTS
  None.
===========================================================================*/
int ds_eps_pdn_cntxt_get_lte_attach_params
(
  void                    *arg_val_ptr,
  sys_modem_as_id_e_type   subs_id,
  int16                   *ps_errno
)
{
  ds_pdn_context_s                               *pdn_cntx_p = NULL;
  ps_sys_ioctl_3gpp_lte_attach_pdn_params_type   *apn_info = NULL;
  byte                                           *apn_ptr = NULL;
  ds_umts_pdp_type_enum_type                      pdp_support_type =
                                                      DS_UMTS_PDP_MAX;
  ds_eps_attach_sm_s                             *attach_sm_ptr = NULL;
  /*-------------------------------------------------------------------------*/

  if ((arg_val_ptr == NULL) || (ps_errno == NULL))
  {
    if(ps_errno != NULL)
    {
      *ps_errno = DS_EFAULT;
    }
    DS_LTE_MSG0_ERROR("Null Pointer passed");
    return -1;
  }

  apn_info = (ps_sys_ioctl_3gpp_lte_attach_pdn_params_type *)arg_val_ptr;

  /*-----------------------------------------------------------------
    Populate the default PDN context's apn into arg_val_ptr
    If the length of the default PDN context's apn is 0 then check
    for the resolved apn from the apn table. If the resolved apn is
    also unavailable return NULL string.
  -------------------------------------------------------------------*/
  ds3gpp_enter_global_crit_section();

  pdn_cntx_p = ds_3gpp_pdn_cntxt_get_def_pdn(subs_id);

  if (!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p))
  {
    ds3gpp_leave_global_crit_section();
    *ps_errno = DS_EINVAL;
    return -1;
  }
    /*------------------------------------------------------------
      If LTE attach is not successful return FAILURE
    -------------------------------------------------------------*/
  if((pdn_cntx_p->ds_pdn_context_dyn_p->state != DS_PDN_CONTEXT_STATE_UP))
  {
    ds3gpp_leave_global_crit_section();
    DS_LTE_MSG0_ERROR("LTE Attach not complete,PDN not in up state");
    *ps_errno = DS_EINVAL;
    return -1;
  }

  if(ds_pdn_cntxt_get_resolved_apn_name(pdn_cntx_p,&(apn_ptr)) == TRUE)
  {
    (void)strlcpy((char *)apn_info->apn_string,(char *)apn_ptr,
            DS_UMTS_MAX_APN_STRING_LEN+1);
  }
  else if(strlen((char *)pdn_cntx_p->ds_pdn_context_dyn_p->pdp_profile.context.apn) != 0)
  {
    (void)strlcpy((char *)apn_info->apn_string,(char *)pdn_cntx_p
            ->ds_pdn_context_dyn_p->pdp_profile.context.apn,
            DS_UMTS_MAX_APN_STRING_LEN+1);
  }
  else
  {
     /*--------------------------------------------------------------------- 
       This is the case when both APN/Resolved APN are NULL.
     -----------------------------------------------------------------------*/
     memset(apn_info->apn_string,0,DS_UMTS_MAX_APN_STRING_LEN+1);
     DS_LTE_MSG0_HIGH("APN/Resolved APN unavailable in the APN table");
  }

 /*-----------------------------------------------------------------------
    Determine the IP type and populate the apn string length
  ------------------------------------------------------------------------*/
  pdp_support_type = ds_pdn_cntxt_get_pdn_context_ip_support(pdn_cntx_p);

  ds3gpp_leave_global_crit_section();
 
  attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(subs_id);
  if(attach_sm_ptr == NULL)
  {
    DS_LTE_MSG1_LOW("Invalid Attach SM ptr for Subs Id (CM) %d",subs_id);
   *ps_errno = DS_EINVAL;
    return -1;
  }

  switch(pdp_support_type)
  {
    case  DS_UMTS_PDP_IPV4:
      apn_info->ip_type = PS_SYS_IOCTL_IP_SUPPORT_TYPE_IPV4;
      break;
    case  DS_UMTS_PDP_IPV6:
      apn_info->ip_type = PS_SYS_IOCTL_IP_SUPPORT_TYPE_IPV6;
      break;
    case  DS_UMTS_PDP_IPV4V6:
      apn_info->ip_type = PS_SYS_IOCTL_IP_SUPPORT_TYPE_IPV4IPV6;
      break;
    default:
       DS_LTE_MSG0_ERROR("IP type is not valid");
      *ps_errno = DS_EINVAL;
      return -1;
  }

  apn_info->apn_string_len = strlen((char *)apn_info->apn_string);
  apn_info->ota_attach_performed = attach_sm_ptr->ota_attach_performed;

  *ps_errno = 0; /* No error */
  return 0;
} /*ds_eps_pdn_cntxt_get_attach_apn_info */

/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_GET_PDN_CONN_IND_HDLR

DESCRIPTION
  This function is responsible for the initiation of sending out PDN conn
  request during EMM attach process. This internally calls another function,
  ds_eps_pdn_cntxt_bring_up_attach_pdn to get the job done

PARAMETERS
 attach_info_p

DEPENDENCIES
  None.

RETURN VALUE
  DS3G_SUCCESS - if all operations went fine
  DS3G_FAILURE - if the attach APN is disabled

SIDE EFFECTS
  None.

===========================================================================*/
boolean ds_eps_pdn_cntxt_get_pdn_conn_ind_hdlr
(
  ds3g_eps_attach_sm_info_type     *attach_info_ptr,
  sys_modem_as_id_e_type  subs_id
)
{
  ds_eps_attach_sm_s                 *attach_sm_ptr       = NULL;
  sys_sys_mode_e_type                 network_mode        = SYS_SYS_MODE_NONE;
  ds_eps_bringup_attach_pdn_result_e  bringup_attach_pdn_status 
                                              = DS_EPS_BRINGUP_ATTACH_PDN_FAIL;
  ds_dsd_apm_ind_pay_load             ind_payload;
  ds_eps_attach_state_e               attach_state   = DS_EPS_ATTACH_STATE_INVALID;
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  


  attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(subs_id);
  if((attach_sm_ptr == NULL) || (attach_info_ptr == NULL))
  {
    DS_3GPP_MSG1_LOW("Invalid Attach SM ptr for Subs Id (CM) %d",subs_id);
    return DS3G_FAILURE;
  }

  /*--------------------------------------------------------------------------- 
  On receiving a fresh attach request, Clear the APN  reject throttling flag
  ---------------------------------------------------------------------------*/
  if(ds_3gpp_pdn_throt_set_apn_reject_pdn_blocked(FALSE,subs_id))
  {
    DS_LTE_MSG3_MED("Clearing the APN REJECT throttle flag",0,0,0);
    ds_3gpp_pdn_throt_apn_reject_clr_timer(subs_id);
  }

  /*--------------------------------------------------------------------------- 
    Check the state of attach_sm, If
    * It is DS_EPS_PROCESSING_GET_PDN_CONN_IND or
      DS_EPS_CACHED_GET_PDN_CONN_IND, then we are currently processing a
      previous attach request.
    * If it is DS_EPS_ATTACHED (or) DS_EPS_PROCESSED_CNTXT_TXFR_IND, we are
      currently cleaning up the old attach PDN while, this new attach request
      is received
      In above such cases save the cached seq num.
   
    However when a fresh attach request is serviced the attach state must be
    DS_EPS_PROCESS_GET_PDN_CONN_IND or NULL.
  -----------------------------------------------------------------------------*/
  attach_state = ds_eps_attach_sm_get_state(subs_id);
  if((attach_state  == DS_EPS_PROCESSING_GET_PDN_CONN_IND) ||
     (attach_state  == DS_EPS_CACHED_GET_PDN_CONN_IND)     ||
     (attach_state  == DS_EPS_ATTACHED)                    ||
     (attach_state  == DS_EPS_PROCESSED_CNTXT_TXFR_IND))
  {
    DS_LTE_MSG2_HIGH("Dup Attach request rx'ed (or) prev attach clean up in"
                     "progress.Cache current seq_num:%d on sub id %d",
                     attach_info_ptr->seq_num,
                     subs_id);
    attach_sm_ptr->cached_seq_num = attach_info_ptr->seq_num;
    attach_sm_ptr->cached_paging_response = attach_info_ptr->responding_to_page;
    return DS3G_FAILURE;
  }

  /*----------------------------------------------------------------------------
    Set the seq_num in the attach_sm, Reset the cached_seq_num. This will be the
    seq num that would be processed.Set the is_attach_complete flag to FALSE.
    This is needed if the device is detached and is reattaching.
  ----------------------------------------------------------------------------*/

  ds3gpp_set_is_attach_complete_flag(FALSE, subs_id);

  /*----------------------------------------------------------------------
    If there are any pending calls, then GET_PDN_CONN_IND is cached and its
  processing is delayed till all pending calls are ended.
  ----------------------------------------------------------------------*/
  if(ds_eps_attach_sm_handle_get_pdn_conn_ind(attach_info_ptr,subs_id))
  {
    return DS3G_FAILURE;
  }

  /*--------------------------------------------------------------------------
    Move the attach SM to Processing GET_PDN_CONN ind as an attach req will
    go out shortly. If we decide not to perform attach, we will reset the SM
    to NULL
  --------------------------------------------------------------------------*/

  DS_LTE_MSG0_HIGH("Setting attach SM to PROCESS_GET_PDN_CONN_IND State");
  attach_sm_ptr->seq_num = attach_info_ptr->seq_num;
  attach_sm_ptr->cached_seq_num = 0;
  attach_sm_ptr->cached_paging_response = FALSE;
  attach_sm_ptr->responding_to_page = attach_info_ptr->responding_to_page;
  ds_eps_attach_sm_set_state(DS_EPS_PROCESSING_GET_PDN_CONN_IND,subs_id);
  
  bringup_attach_pdn_status = ds_eps_pdn_cntxt_bring_up_attach_pdn(subs_id);

  if(bringup_attach_pdn_status == DS_EPS_BRINGUP_ATTACH_PDN_FAIL)
  {
    /*----------------------------------------------------------------------
      Attach init failed. Reset Target_Rat
    ----------------------------------------------------------------------*/
    DS_LTE_MSG0_HIGH("GET_PDN_CONN_IND_HDLR - Failed to bring up attach PDN, "
                     "Attach initiation fail. Reset Target_Rat");
    ds3gmgr_send_trat_ind(SYS_SYS_MODE_NONE,0,NULL,subs_id);
    memset(&ind_payload, 0, sizeof(ds_dsd_apm_ind_pay_load));
    ind_payload.subs_id = subs_id;
    ds_dsd_apm_ind(DS_DSD_APM_ATTACH_REJECT_IND, &ind_payload);

    network_mode = ds3g_get_current_network_mode_ex(subs_id);

    if ( DS_3GPP_IS_3GPP_CURRENT_MODE(network_mode))
    {
      DS_LTE_MSG1_HIGH("Resetting DS3GPP internal mode after Attach Failure to %d",
                        network_mode);
      ds3gpp_update_network_mode(network_mode, subs_id);
    }
  }

  if(bringup_attach_pdn_status == DS_EPS_BRINGUP_ATTACH_PDN_SUCCESS)
  {
    return DS3G_SUCCESS;
  }
  else
  {  
    return DS3G_FAILURE;
  }

} /* ds_eps_pdn_cntxt_get_pdn_conn_ind_hdlr */

#ifdef FEATURE_EPC_HANDOFF
/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_REG_EMM_ATTACH_HDLR

DESCRIPTION
  This function is used to register the EMM Attach handler with the LTE
  Mode Handler. This API is called by EPC Mode Handler. Whenever an attach
  indication is received in the LTE mode, we check if the EPC mode handler
  has registered with LTE MH. If it has, the attach handler provided by EPC
  MH is invoked.

PARAMETERS
  emm_attach_hdlr_f - Pointer to the EMM attach handler provided by EPC MH

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
void ds_eps_pdn_cntxt_reg_emm_attach_hdlr
(
  ds_3gpp_if_emm_attach_hdlr_f_type emm_attach_hdlr_f
)
{
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

  /*------------------------------------------------------------------------
    Store the pointer to the Attach handler provided by the EPC mode handler
  ------------------------------------------------------------------------*/
  ds_eps_pdn_cntxt_emm_attach_hdlr_f = emm_attach_hdlr_f;

} /* ds_eps_pdn_cntxt_reg_emm_attach_hdlr */

#endif /* FEATURE_EPC_HANDOFF */
/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_T3402_CHANGED_IND_HDLR

DESCRIPTION
  This function is used to handle the message from NAS. This message is sent
  whenever there is a change in T3402 timer value

  Here we validate the message ID and we copy the timer value in the payload of the
  message to the container maintained in DS

PARAMETERS
  msgr_type  - UMID of the message sent
  dsmsg_ptr - Pointer to the payload

DEPENDENCIES
  None.

RETURN VALUE
  TRUE  - if the message header is correct 
  FALSE - otherwise  

SIDE EFFECTS
  None.
===========================================================================*/ 
LOCAL boolean ds_eps_pdn_cntx_t3402_changed_ind_hdlr
(
  msgr_umid_type             msgr_type,
  const msgr_hdr_struct_type *dsmsg_ptr
)
{
  emm_t3402_changed_ind_s_type *msg_ptr;
  sys_modem_as_id_e_type        subs_id = SYS_MODEM_AS_ID_NONE;
  ds_dsd_apm_ind_pay_load       ind_payload;
/* - - - - - - - - - - - - - -  - - - - - - - - - - - - - - - - - - - - - - - */

  if((msgr_type != NAS_EMM_T3402_CHANGED_IND) 
     || (dsmsg_ptr == NULL))
  {
    DS_LTE_MSG1_ERROR("ds_3gpp_t3402_changed_ind_hdlr: Invalid message %d",
                      msgr_type);
    return FALSE;
  }

  msg_ptr= (emm_t3402_changed_ind_s_type *) dsmsg_ptr;
  subs_id = INST_ID_TO_SYS_AS_ID(msg_ptr->msg_hdr.inst_id);
  memset (&ind_payload, 0, sizeof(ds_dsd_apm_ind_pay_load));
  ind_payload.t3402_timer_val = msg_ptr->t3402_value;
  ind_payload.subs_id = subs_id;

  DS_LTE_MSG2_HIGH("ds_3gpp_t3402_changed_ind_hdlr: Received T3402 from NAS: %d "
                    " on sub id %d",msg_ptr->t3402_value,subs_id);
  ds_eps_pdn_cntxt_set_t3402_timer_val(msg_ptr->t3402_value);

  ds_dsd_apm_ind (DS_DSD_APM_T3402_CHG_IND,&ind_payload);
  return TRUE;
}

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_VALIDATE_APN_NAME_AND_DECODE

DESCRIPTION
  This function is used to validate resolved apn name return by network according to LTE spc
  also match with apn name in the profile


PARAMETERS
  pdn_cntx_ptr  - PDN Context variable
  lte_info_ptr - cm call info ptr
  decoded_apn - to store decoded apn

DEPENDENCIES
  None.

RETURN VALUE
  TRUE  - if apn parameter is valid and accepted  
  FALSE - otherwise  

SIDE EFFECTS
  None.
===========================================================================*/ 

LOCAL boolean ds_eps_pdn_cntx_validate_apn_name_and_decode
(
   ds_pdn_context_s               *pdn_cntx_ptr,
   cm_lte_call_info_s_type        *lte_info_ptr,
   byte                           *decoded_apn,
   boolean                         disable_apn_matching

)
{
  if (!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_ptr))
  {
    return FALSE;
  }

  if(lte_info_ptr == NULL)
  {
    DS_LTE_MSG0_ERROR("lte_info_ptr is NULL");
    return FALSE;
  }

  if (lte_info_ptr->apn_name.valid != TRUE)
  {
    DS_LTE_MSG0_ERROR(" APN, valid flag not set");
    lte_info_ptr->esm_cause.valid = TRUE;
    lte_info_ptr->esm_cause.esm_cause = NAS_ESM_INVALID_MANDATORY_INFORMATION;
    return FALSE;
  }

  if(lte_info_ptr->apn_name.apn_addr_len > DS_UMTS_MAX_APN_STRING_LEN)
  {
    DS_LTE_MSG1_ERROR("APN, Insufficinet space to store incoming APN,Length",
                       lte_info_ptr->apn_name.apn_addr_len);
    lte_info_ptr->esm_cause.valid = TRUE;
    lte_info_ptr->esm_cause.esm_cause = NAS_ESM_UNKNOWN_MISSING_APN;
    return FALSE;
  }


  /*---------------------------------------------------------------------------- 
    Try to decode apn name in a strict manner and if it fails and if
    disable apn matching NV is turned on try to decode the apn in a
    non strict manner
   ----------------------------------------------------------------------------*/
  if(ds3g_decode_apn_name(lte_info_ptr->apn_name.address,
                                    (uint32)lte_info_ptr->apn_name.apn_addr_len,
                                            decoded_apn) == FALSE)
  {
    if(!disable_apn_matching)
    {
      DS_LTE_MSG0_ERROR("Decoding of apn name failed and disable_apn_matching"
                        " is not set");
      lte_info_ptr->esm_cause.valid = TRUE;
      lte_info_ptr->esm_cause.esm_cause = NAS_ESM_INVALID_MANDATORY_INFORMATION;
      return FALSE;
    }
    else
    {
      if(ds3g_decode_apn_name_non_strict(lte_info_ptr->apn_name.address,
                                      (uint32)lte_info_ptr->apn_name.apn_addr_len,
                                      decoded_apn) == FALSE)
      {
        DS_LTE_MSG0_ERROR("Decoding of apn name failed and disable_apn_matching "
                          "is set");
        lte_info_ptr->esm_cause.valid = TRUE;
        lte_info_ptr->esm_cause.esm_cause = NAS_ESM_INVALID_MANDATORY_INFORMATION;
        return FALSE;
      }
    }
  }
  return TRUE;
}

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_PLMN_ID_CHG_HDLR

DESCRIPTION
  This function is used to handle the message from NAS. This message is sent
  whenever there is a change in PLMN

  Here we validate the message ID and we copy the PLMN in the payload of the
  message to the container maintained in DS

PARAMETERS
  msgrtype  - UMID of the message sent
  dsmsg_ptr - Pointer to the payload

DEPENDENCIES
  None.

RETURN VALUE
  TRUE  - if the message header is correct and we can handle the message
  FALSE - otherwise

  Note: We will not return FALSE for errors in the message payload

SIDE EFFECTS
  None.
===========================================================================*/
LOCAL boolean ds_eps_pdn_cntx_plmn_id_chg_hdlr
(
  msgr_umid_type             msgrtype,
  const msgr_hdr_struct_type *dsmsg_ptr
)
{
  boolean                  ret_val = FALSE; //ret FALSE if msg id does not match
  emm_plmn_change_ind_type *payload_ptr = NULL;
  sys_plmn_id_s_type       zero_plmn_id;
  ds_dsd_apm_ind_pay_load  dsd_apm_pay_load;
  sys_modem_as_id_e_type   subs_id = SYS_MODEM_AS_ID_NONE;
  sys_plmn_id_s_type       current_plmn_id;
  
  /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if(msgrtype == NAS_EMM_IND_PLMN_CHANGE && dsmsg_ptr!= NULL)
  {
    payload_ptr = (emm_plmn_change_ind_type*)dsmsg_ptr;
    subs_id = INST_ID_TO_SYS_AS_ID(payload_ptr->msg_hdr.inst_id); 
    if (!ds3gsubsmgr_is_subs_id_valid(subs_id))
    {
      return FALSE;
    }
    /*--------------------------------------------------------------------------
      Memset the Zero PLMN Id to 0
    --------------------------------------------------------------------------*/
    memset((void*)&zero_plmn_id, 0, sizeof(sys_plmn_id_s_type));

    if(memcmp((void*)&(payload_ptr->plmn),
              (void*)&(zero_plmn_id),
              sizeof(sys_plmn_id_s_type)) != 0)
    {
      ds_3gpp_pdn_cntx_get_current_lte_plmn(&current_plmn_id, subs_id);

      if(memcmp((void*)&(payload_ptr->plmn),
              (void*)&(current_plmn_id),
              sizeof(sys_plmn_id_s_type)) != 0)
      {
        ds_3gpp_pdn_cntx_set_current_plmn_ex(&(payload_ptr->plmn), subs_id);
        DS_LTE_MSG0_MED("Updated the current PLMN. Send current PLMN to APM module");
      }

      ds_3gpp_roaming_inform_new_plmn_info(subs_id, payload_ptr->plmn);

      ds_3gpp_pdn_throt_advertise_blocked_apns_with_plmn (subs_id, payload_ptr->plmn);

      ds_3gpp_pdn_cntxt_disable_lte_if_attach_profile_unavailable(subs_id);

      memset(&dsd_apm_pay_load, 0, sizeof(ds_dsd_apm_ind_pay_load));
      dsd_apm_pay_load.ind_field_mask = DS_DSD_IND_PLMN_FIELD_MASK;
      memscpy(&(dsd_apm_pay_load.plmn_id),
	      sizeof( sys_plmn_id_s_type ),
              &(payload_ptr->plmn),
              sizeof(sys_plmn_id_s_type));
      dsd_apm_pay_load.subs_id = subs_id; 
      ds_dsd_apm_ind(DS_DSD_APM_PLMN_CHANGED_IND,&(dsd_apm_pay_load));
    }
    ret_val = TRUE;
  }

  else
  {
    DS_LTE_MSG2_LOW("Error in incoming message. Msg id: %d, Msg_ptr 0x%x",
                       msgrtype,dsmsg_ptr);
  }
  return ret_val;
} /* ds_eps_pdn_cntx_plmn_id_chg_hdlr */

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_RESET_ATTACH_APN_IND_HDLR

DESCRIPTION
  This function is used to notify APM to reset Attach APN to Class 1 APN
  on successful PLMN blk cback from CM

PARAMETERS
  client_data_ptr: Current active PS subs

DEPENDENCIES
  None.

RETURN VALUE
  None
 
SIDE EFFECTS
  None.
===========================================================================*/
void ds_eps_pdn_cntxt_sys_sel_pref_no_err_cmd_hdlr
(
  void                           *client_data_ptr
)
{
  ds_dsd_apm_ind_pay_load         dsd_apm_pay_load;
  sys_modem_as_id_e_type          subs_id = SYS_MODEM_AS_ID_NONE;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  subs_id = (sys_modem_as_id_e_type)client_data_ptr;
  if (!ds3gsubsmgr_is_subs_id_valid(subs_id))
  {
    return;
  }

  memset(&dsd_apm_pay_load, 0, sizeof(ds_dsd_apm_ind_pay_load));

  dsd_apm_pay_load.subs_id = subs_id;
  ds_dsd_apm_ind(DS_DSD_APM_RESET_ATTACH_APN_IND, &dsd_apm_pay_load);
}

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_ATTACH_COMPLETE_IND_HDLR

DESCRIPTION
  This function is used to handle the message from NAS. This message is sent
  when NAS gets the L2 ack for attach complete message. This is the message
  that marks the completion of attach procedure.

  Clients that are interested in the completion of attach (EPC for instance)
  will be notified at this point.

  Note: This message has no payload.

PARAMETERS
  msgrtype  - UMID of the message sent
  dsmsg_ptr - Pointer to the payload

DEPENDENCIES
  None.

RETURN VALUE
  TRUE  - if the message header is correct and we can handle the message
  FALSE - otherwise

  Note: We will not return FALSE for errors in the message payload

SIDE EFFECTS
  None.
===========================================================================*/
LOCAL boolean ds_eps_pdn_cntx_attach_complete_ind_hdlr
(
  msgr_umid_type              msgrtype,
  const msgr_hdr_struct_type *dsmsg_ptr
)
{
  boolean                                     ret_val = FALSE;
  sys_modem_as_id_e_type                      subs_id  = SYS_MODEM_AS_ID_NONE;
  ds_eps_attach_sm_s                          *attach_sm_ptr = NULL;
  emm_attach_complete_ind_type                *payload_ptr = NULL;
#ifdef FEATURE_EPC_HANDOFF
  ps_iface_type                               *v4_iface = NULL; 
  ps_iface_type                               *v6_iface = NULL;
  ps_sys_event_3gpp_lte_attach_complete_type  attach_comp_info;
  int16                                       event_ret_val = -1;
  int16                                       ps_errno;
  ds_apn_ip_support_type_e                    ip_support = DS_IP_TYPE_INVALID;
  ds_pdn_context_s                            *pdn_cntx_p = NULL;
#endif /*FEATURE_EPC_HANDOFF*/
  /*--------------------------------------------------------------------------*/

  if(msgrtype == NAS_EMM_ATTACH_COMPLETE_IND)
  {    

   if (dsmsg_ptr == NULL)
   {
     DS_LTE_MSG0_LOW("Invalid ds msgr ptr");
     return FALSE;
   }

   payload_ptr = (emm_attach_complete_ind_type*)dsmsg_ptr;
   subs_id = INST_ID_TO_SYS_AS_ID(payload_ptr->msg_hdr.inst_id);


#ifdef FEATURE_EPC_HANDOFF
    pdn_cntx_p = ds_3gpp_pdn_cntxt_get_def_pdn(subs_id);

   /**        
    If the UE is emergency Attached; is UE attaches for the sole purpose
    of making an emergency call; there will no default pdn context and 
    PS_SYS_EVENT_3GPP_LTE_ATTACH_COMPLETE might not sent. However 
    PS_SYS_EVENT_3GPP_LTE_ATTACH_COMPLETE is not currently being 
    used by anyone. If that changes and this event has to be sent 
    for Emergency Attach also; this section will have to be 
    revisited. 
    **/ 
   
   if(ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntx_p) == TRUE)
   {
             
    v4_iface =
          &(pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
            [DS_3GPP_PDN_CONTEXT_IPV4_IFACE]->ps_iface);

    v6_iface =
          &(pdn_cntx_p->ds_pdn_context_dyn_p->ds_3gpp_iface_tbl
            [DS_3GPP_PDN_CONTEXT_IPV6_IFACE]->ps_iface);

    attach_comp_info.v4_iface_ptr = v4_iface;
    attach_comp_info.v6_iface_ptr = v6_iface;

    /*------------------------------------------------------------------------
    For single bearer scenarios, we only send the supported iface to EPC
    -------------------------------------------------------------------------*/
    if(ds_pdn_cntxt_get_ip_support_info_for_pdn(pdn_cntx_p,&ip_support) !=
                                                                  DS3G_SUCCESS)
    {
      DS_LTE_MSG1_ERROR("Could not get IP Support info. PDN: 0x%x",
                        pdn_cntx_p);
      ASSERT(0);
    }

    if( ip_support == DS_IPV4_ONLY || ip_support == DS_IPV4_SINGLE_BEARER )
    {
      attach_comp_info.v6_iface_ptr = NULL;
    }
    else if( ip_support == DS_IPV6_ONLY || ip_support == DS_IPV6_SINGLE_BEARER )
    {
      attach_comp_info.v4_iface_ptr = NULL;
    }

    /*----------------------------------------------------------------------------
    Send attach complete event to EPC followed by a system status change.
    ----------------------------------------------------------------------------*/
    event_ret_val = ps_sys_event_ind_ex(
                                         PS_SYS_TECH_3GPP,
                                         PS_SYS_EVENT_3GPP_LTE_ATTACH_COMPLETE,
                                         (ps_sys_subscription_enum_type)
                                           ds3gsubsmgr_subs_id_cm_to_ds(subs_id),
                                         (void*)&attach_comp_info,
                                         &ps_errno
                                       );
    if(event_ret_val != 0)
    {
      DS_LTE_MSG0_ERROR("Fail to post PS_SYS_EVENT_3GPP_LTE_ATTACH_COMPLETE");
    }
    }     

#endif /*FEATURE_EPC_HANDOFF*/

    attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(subs_id);
    if(attach_sm_ptr == NULL)
    {
      DS_LTE_MSG1_LOW("Invalid Attach SM ptr for Subs Id (CM) %d",subs_id);
      return FALSE;
    }
    DS_LTE_MSG0_LOW("Setting Attach complete flag: TRUE");

    /*--------------------------------------------------------------------------- 
      Set ota_attach_performed flag to TRUE
    ----------------------------------------------------------------------------*/
    attach_sm_ptr->ota_attach_performed = TRUE;
    attach_sm_ptr->cached_seq_num = 0;
    attach_sm_ptr->cached_paging_response = FALSE;
    attach_sm_ptr->seq_num = 0;
    attach_sm_ptr->responding_to_page = FALSE;
    attach_sm_ptr->is_gw_originated = FALSE;
    memset((void*)&attach_sm_ptr->prev_attach_status,
           0,
           sizeof(ds_eps_prev_attach_status_type));

    ds3gpp_set_is_attach_complete_flag(TRUE, subs_id);
    ds_eps_attach_sm_handle_attach_complete_ind(DS_DSD_NORMAL_ATTACH,subs_id);

    /*----------------------------------------------------------------------
      We have reached steady state - LTE Full Service - reset Target_RAT
    ----------------------------------------------------------------------*/
    DS_LTE_MSG0_HIGH("Attach complete. Reset Target_Rat");
    ds3gmgr_send_trat_ind(SYS_SYS_MODE_NONE,0,NULL,subs_id);

    ret_val = TRUE;
  }
  else
  {
    DS_LTE_MSG1_LOW("Invalid message from LTE NAS: %d", msgrtype);
  }

  return ret_val;
} /* ds_eps_pdn_cntx_attach_complete_ind_hdlr */

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_HANDLE_CNTXT_TRANSFER_IND

DESCRIPTION
  This function is used to invoke any LTE specific operations on
  receiving context-transfer indication.

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None

=============================================================================*/
void ds_eps_pdn_cntxt_handle_cntxt_txfr_ind
(
  sys_modem_as_id_e_type    subs_id
)
{
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if((ds_eps_attach_sm_get_state(subs_id) == DS_EPS_CACHED_GET_PDN_CONN_IND) || 
     (ds_eps_pdn_cntx_is_pdn_conn_req_pending(subs_id) ))
  {
    DS_LTE_MSG0_HIGH("in ds_eps_pdn_cntxt_handle_cntxt_txfr_ind"
                     " GET_PDN_CONN_IND for LTE Attach is cached");
    return;
  }

  if (DS_EPS_ATTACH_STATE_NULL == ds_eps_attach_sm_get_state(subs_id))
  {
    DS_LTE_MSG0_HIGH("Posting EPS CNTXT TRANSFER ev to DSD");
    ds3gdsdif_notify_dsd_lte_attach_event(subs_id,
                                          DS_DSD_CLIENT_RADIO_EPS_CONTEXT_TX_EV,
    	                                  (ds_dsd_attach_complete_type)0,
                                          PS_IFACE_3GPP_LTE);

    ds_eps_attach_sm_set_state(DS_EPS_PROCESSED_CNTXT_TXFR_IND,subs_id);
  }
}

/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_RESUME_IND_HDLR

DESCRIPTION
  This function is used to perform the actions needed at the PDN context
  level when resume indication is received.

PARAMETERS
  subs_id: Subscription Id

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
LOCAL void ds_eps_pdn_cntxt_resume_ind_hdlr
(
  sys_modem_as_id_e_type subs_id
)
{ 
  /*----------------------------------------------------------------------------
   Process the resume ind only in the PROCESSED_CNTXT_TRANSFER state of 
   Attach SM. If the attach SM is in PROCESSED_CNTXT_TRANSFER state, and we 
   get a resume in LTE, it is indicative of an IRAT.
	
   If the attach SM is in any other state, manipulating data structures here
   will cause issues in the resetting of target_rat field maintained in dsmgr
   module.
   ----------------------------------------------------------------------------*/
	
   if(ds_eps_attach_sm_get_state(subs_id) == DS_EPS_PROCESSED_CNTXT_TXFR_IND)
   {
     /*----------------------------------------------------------------------------
 	Set the Attach complete flag to TRUE. Otherwise, we will never be able to
	bring up any context other than the one that was transferred
      ----------------------------------------------------------------------------*/
     ds3gpp_set_is_attach_complete_flag(TRUE, subs_id);
     ds_eps_attach_sm_handle_attach_complete_ind(DS_DSD_3GPP_IRAT_ATTACH, subs_id);

     /*----------------------------------------------------------------------------
      Check if the config item to bring up the default PDN while resuming on LTE
      is set. If yes,
      ----------------------------------------------------------------------------*/
     if(ds_3gpp_nv_manager_get_always_connect_def_pdn_flag(subs_id) == TRUE)
     {
       /*----------------------------------------------------------------------
         Call the function that does operations to bring up the PDN connection
         using the attach profile.
         Ignore the return value of the function call.
       ----------------------------------------------------------------------*/
      	DS_LTE_MSG0_HIGH("Resume Ind - Bringing up def PDN conn if needed");
	
       (void)ds_eps_pdn_cntxt_bring_up_attach_pdn(subs_id);
     }
   }/* If attach SM is in NULL State*/
   else
   {
     DS_LTE_MSG0_HIGH("Resume Ind - attach SM isn't in PROCESSED_CNTXT_TRANSFER state - ignore");
   }

} /* ds_eps_pdn_cntxt_resume_ind_hdlr */
/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_RESET_ATTACH_SM_PARAMS

DESCRIPTION
  This function is used to reset the attch state machine parameters

PARAMETERS 
  None
 
DEPENDENCIES
  None.

RETURN VALUE
  None
 
SIDE EFFECTS
  None.
===========================================================================*/
void ds_eps_pdn_cntx_reset_attach_sm_params
(
  sys_modem_as_id_e_type subs_id
)
{
   ds_eps_attach_sm_s *attach_sm_ptr = NULL;
   ds3geventmgr_filter_type           filter_info;
   ps_sys_null_resolved_apn_info_type resolved_apn;
  ds_dsd_ext_error_code               apm_error_code = DS_DSD_APM_UNSEPCIFIED;
  ds_dsd_apm_ind_pay_load             apm_pay_load;

  /*-----------------------------------------------------------------------*/

  /*--------------------------------------------------------------------------
    Clear LTE ATTACH procedure state machine
  --------------------------------------------------------------------------*/
  attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(subs_id);
  if(attach_sm_ptr == NULL)
  {
    DS_LTE_MSG1_LOW("Invalid Attach SM ptr for Subs Id (CM) %d",subs_id);
    return;
  }

  if (ds_eps_attach_sm_get_state(subs_id) != DS_EPS_ATTACH_STATE_NULL)
  {
    ds3gdsdif_notify_dsd_lte_attach_event(subs_id,
                                          DS_DSD_CLIENT_RADIO_EMMDETACHCOMPLETED_EV,
		                          (ds_dsd_attach_complete_type)0,
                                          PS_IFACE_3GPP_LTE);

    apm_pay_load.subs_id = subs_id;
    apm_pay_load.ind_field_mask = 0;

    apm_error_code = ds_dsd_apm_ind(DS_DSD_APM_DETACH_IND,&apm_pay_load);
    DS_LTE_MSG1_MED("Posted Detach Indication to DSD and APM, "
                    "Err code: %d", apm_error_code);
  }

  ds_eps_attach_sm_set_state(DS_EPS_ATTACH_STATE_NULL,subs_id);
  attach_sm_ptr->ota_attach_performed = FALSE;
  attach_sm_ptr->seq_num = 0;
  attach_sm_ptr->is_gw_originated = FALSE;
  attach_sm_ptr->responding_to_page = FALSE;
  memset((void*)&attach_sm_ptr->prev_attach_status,
         0,
         sizeof(ds_eps_prev_attach_status_type));

  memset((void*)&resolved_apn,0,sizeof(ps_sys_null_resolved_apn_info_type));

  filter_info.ps_subs_id =  (ps_sys_subscription_enum_type) 
                                        ds3gsubsmgr_subs_id_cm_to_ds(subs_id);

  filter_info.tech = PS_SYS_TECH_3GPP;

  /*--------------------------------------------------------------------------------- 
    Reset the resolved apn here since the system is no longer on LTE
   ---------------------------------------------------------------------------------*/
  if(ds3geventmgr_set_event_info(DS3GEVENTMGR_NULL_RESOLVED_APN_EV,
                                 &resolved_apn, &filter_info)== FALSE)
  {
    DS_3GPP_MSG0_ERROR("Unable to provide Resolved APN info to internal"
                       " clients");
  }

  ds_3gpp_pdn_throt_advertise_blocked_apns_current_plmn(subs_id);

#ifdef FEATURE_EMERGENCY_PDN
  ds_3gpp_pdn_cntxt_set_emergency_auth_fail(FALSE);
#endif /*FEATURE_EMERGENCY_PDN*/

  /* Deregister for bearer error indication callback with PS DPM when moved out of LTE */
  ps_dpm_err_ind_cback_dereg();

  return;
}/*ds_eps_pdn_cntx_reset_attach_sm_params*/

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_IS_PDN_CONN_REQ_PENDING

DESCRIPTION
  This function is used to check if a PDN CONN request to be sent to NAS
  is pending 

PARAMETERS 
  None
 
DEPENDENCIES
  None.

RETURN VALUE
  True  - If cached seq_num is > 0
  False - If cached seq number is 0
 
SIDE EFFECTS
  None.
===========================================================================*/
boolean ds_eps_pdn_cntx_is_pdn_conn_req_pending
(
  sys_modem_as_id_e_type subs_id
)
{
  boolean ret_val = FALSE;
  ds_eps_attach_sm_s *attach_sm_ptr = NULL;
/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  attach_sm_ptr = ds_eps_get_attach_sm_per_sub_id(subs_id);
  if(attach_sm_ptr == NULL)
  {
    DS_LTE_MSG1_LOW("Invalid Attach SM ptr for Subs Id (CM) %d",subs_id);
    return FALSE;
  }
  if (attach_sm_ptr->cached_seq_num > 0)
  {
    DS_LTE_MSG2_HIGH("PDN_CONN_REQ is pending, cached_seq_num:%d "
                     "on Subs Id (CM) %d", attach_sm_ptr->cached_seq_num,
                     subs_id);
    ret_val = TRUE;
  }

  return ret_val;

}

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_IS_ATTACH_PDN_UP

DESCRIPTION
  This function is used to check if attach PDN is UP.

PARAMETERS 
  None
 
DEPENDENCIES
  None.

RETURN VALUE
  True  - If attach PDN is UP.
  False - If attach PDN is not UP.
 
SIDE EFFECTS
  None.
===========================================================================*/
LOCAL boolean ds_eps_pdn_cntxt_is_attach_pdn_up
(
  sys_modem_as_id_e_type    subs_id
)
{
  uint16                       attach_profile_num;
  ds_umts_pdp_context_type     attach_profile_context;
  ds_umts_pdp_profile_status_etype status =  DS_UMTS_PDP_FAIL;
  ds_apn_ip_support_type_e    attach_ip_support;
  ds_pdn_context_s              *v4_pdn_p=NULL,*v6_pdn_p=NULL;
  boolean                       ret_val = FALSE;

  attach_profile_num = ds_eps_get_attach_prof(subs_id);

  status = ds_umts_get_pdp_profile_context_info_per_subs( attach_profile_num,
                                               dsumts_subs_mgr_get_subs_id(subs_id), 
                                                 &attach_profile_context );

  if ( status != DS_UMTS_PDP_SUCCESS )
  {
    DS_LTE_MSG0_ERROR("Unable to get attach profile context");
    return ret_val;
  }

  /*--------------------------------------------------------------------------
    Check if there is an entry in APN table for attach APN.
  ------------------------------------------------------------------------*/
  if (ds_pdn_cntxt_get_apn_ip_support_info(attach_profile_context.apn,
                                           &attach_ip_support,
                                           subs_id) == TRUE)
  {
    /*-------------------------------------------------------------------------
      Below fns must return TRUE always since we entered here by finding an
      entry in APN table.
    -------------------------------------------------------------------------*/
    if ( (ds_pdn_cntxt_get_v4_pdn_context(attach_profile_context.apn, &v4_pdn_p, subs_id)) ||
         (ds_pdn_cntxt_get_v6_pdn_context(attach_profile_context.apn, &v6_pdn_p, subs_id)) )
    {
      DATA_3GPP_MSG_SPRINTF_3(MSG_LEGACY_HIGH, "Attach APN: %s is present in APN table, "
                       "IP type in APN Table: %d, IP Type in Attach Profile: %d",
                       attach_profile_context.apn,
                       attach_ip_support, attach_profile_context.pdp_type);
      ret_val = TRUE;
    }
    else
    {
      DATA_3GPP_MSG_SPRINTF_1(MSG_LEGACY_ERROR, "Attach APN: %s is present in APN table"
	  	              "but no v4 or v6 pdn ptr is present",
                              attach_profile_context.apn);
      ret_val = FALSE;
    }
  }
  else
  {
    DATA_3GPP_MSG_SPRINTF_1(MSG_LEGACY_HIGH, "Attach APN: %s is not present in APN table",
                            attach_profile_context.apn);
    ret_val = FALSE;
  }

  return ret_val;
}

/*===========================================================================
FUNCTION DS_EPS_GET_DEFAULT_SOCKET_PROFILE

DESCRIPTION
  This function is used to retrieve the default socket profile from pdp
  registry

PARAMETERS 
  subs_id: data sub id
 
DEPENDENCIES
  None.

RETURN VALUE
  uint16 : default socket profile id
 
SIDE EFFECTS
  None.
===========================================================================*/

uint16 ds_eps_get_default_socket_profile 
(
  sys_modem_as_id_e_type    subs_id
)
{

  ds_umts_pdp_profile_status_etype    profile_status = DS_UMTS_PDP_SUCCESS;
  byte                                def_sock_prof = DS_EPS_DEF_PROF;
  byte                                prof_apn_name[DS_UMTS_MAX_APN_STRING_LEN+1];
  uint16                              attach_prof = DS_EPS_DEF_PROF;

/*-------------------------------------------------------------------------------*/
  DS_LTE_MSG0_LOW("ds_eps_get_default_socket_profile():Entered");

  profile_status = ds_umts_get_pdp_profile_num_for_sock_calls_per_subs(
                      dsumts_subs_mgr_get_subs_id(subs_id),
                      &def_sock_prof);
  if (DS_UMTS_PDP_SUCCESS == profile_status)
  {
    memset(prof_apn_name, 0, DS_UMTS_MAX_APN_STRING_LEN+1);
    profile_status = ds_umts_get_pdp_profile_context_info_apn_per_subs(
                                                 (uint16)def_sock_prof,
                                                 dsumts_subs_mgr_get_subs_id(subs_id),
                                                  prof_apn_name,
                                                  DS_UMTS_MAX_APN_STRING_LEN);
    if (DS_UMTS_PDP_SUCCESS == profile_status)
    {
      if( FALSE == ds_3gpp_pdn_throt_is_apn_throttled(prof_apn_name,
                                                      DS_3GPP_PDP_TYPE_IP_ANY, 
                                                      subs_id) )
      {
        attach_prof = def_sock_prof;
        DS_LTE_MSG1_LOW("Using default socket profile: %d",
                                def_sock_prof);
      }
      else
      {
        DS_LTE_MSG1_LOW("Default socket profile: %d has APN blocked, "
                          "No APN to attach", def_sock_prof);
        attach_prof = DS_EPS_INVALID_PROF;
      }
    }
    else
    {
      DS_LTE_MSG1_LOW("Can't find APN for Default socket profile: %d"
                        "No APN to attach", def_sock_prof);
      attach_prof = DS_EPS_INVALID_PROF;
    }
  }
  else
  {
    DS_LTE_MSG0_LOW("Can't find default socket profile, "
                      "No APN to attach");
    attach_prof = DS_EPS_INVALID_PROF;
  }

  DS_LTE_MSG1_HIGH("Attach profile: %d", attach_prof);
  return attach_prof;
} /* ds_eps_get_default_socket_profile */


/*===========================================================================
FUNCTION ds_eps_get_attach_sm_per_sub_id

DESCRIPTION
  This function sets the value of NV 70334 REMOVE_UNUSED_PDN .
  This function is only used in Test framework and should not be used to set
  anywhere else other than test cases.
PARAMETERS 
  None
 
DEPENDENCIES
  None.

RETURN VALUE
  None
 
SIDE EFFECTS
  None.
===========================================================================*/
ds_eps_attach_sm_s* ds_eps_get_attach_sm_per_sub_id
(
  sys_modem_as_id_e_type  subs_id
)
{
  /*  Validate subscription ID */
  if (!ds3gsubsmgr_is_subs_id_valid(subs_id))
  {
    return NULL;
  }

  return &(ds_eps_attach_sm[subs_id]);
}

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_UPDATE_IP_TYPE_FOR_V4V6_WITH_INVALID_ESM_CAUSE

DESCRIPTION
  This function is used to handle cases where esm cause code valid flag is
  set to 0. The IP support and redial mechanism is updated based on the global
  variable ds_3gpp_allow_redial .

PARAMETERS 
  IP support   : APN type for the PDN being brought up
  Pdn_type_val : Network returns PDP_TYPE
 
DEPENDENCIES
  None.

RETURN VALUE
  None
 
SIDE EFFECTS
  None.
===========================================================================*/
void ds_eps_pdn_cntxt_update_ip_type_for_v4v6_with_invalid_esm_cause
(
  ds_apn_ip_support_type_e  *ip_support,
  pdn_type_T                 pdn_type_val,
  sys_modem_as_id_e_type     subs_id
)
{
  boolean is_redial_allowed = FALSE;
/*--------------------------------------------------------------------------*/
  if (!ds3gsubsmgr_is_subs_id_valid(subs_id))
  {
    DS_3GPP_MSG1_ERROR("Invalid subs ID %d",subs_id);    
  }


  if(ip_support == NULL)
  {
    DS_LTE_MSG0_ERROR("NULL ptr being passing for ip support");
    return;
  }
  is_redial_allowed = ds_3gpp_nv_manager_get_is_no_cause_code_redial_set(subs_id);

  if(pdn_type_val == NAS_ESM_IPV4)
  {
    if (is_redial_allowed )
    {
      *ip_support = DS_IPV4_SINGLE_BEARER;
    }
    else
    {
      *ip_support = DS_IPV4_ONLY;
    }
  }
  else if (pdn_type_val == NAS_ESM_IPV6)
  {
    if (is_redial_allowed)
    {
      *ip_support = DS_IPV6_SINGLE_BEARER;
    }
    else
    {
      *ip_support = DS_IPV6_ONLY;
    }
  }
  else
  {
    DS_LTE_MSG0_LOW("Invalid combination , error Network sends IPV4V6 "
                     "with cause code after IPV4V6 is requested ");
  }

    DS_LTE_MSG2_HIGH("Received invalid cause code for v4v6, is redial allowed %d, "
                   "IP type updated from IPV4V6 to %d ",
                   is_redial_allowed, *ip_support);
}/*ds_eps_pdn_cntxt_update_ip_type_for_v4v6_with_invalid_esm_cause*/

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_UPDATE_PARAM_FOR_NEW_IP_TYPE

DESCRIPTION
  This function is used to update the APM cause code based on the ip support
  provided

PARAMETERS 
  ind_payload  : APM Payload to be filled
  IP support   : APN type for the PDN being brought up
  Pdn_type_val : Network returns PDP_TYPE
 
DEPENDENCIES
  None.

RETURN VALUE
  None
 
SIDE EFFECTS
  None.
===========================================================================*/
void ds_eps_pdn_cntxt_update_param_for_new_ip_type
(
  ds_apn_ip_support_type_e     ip_support,
  ds_pdn_context_s            *pdn_cntxt_p,
  ds_dsd_apm_ind_pay_load     *ind_payload
)
{
  sys_modem_as_id_e_type           subs_id = SYS_MODEM_AS_ID_NONE;
  ds_3gpp_throt_rat_e_type         rat_type = DS_3GPP_THROT_RAT_GLOBAL;
                                    /* RAT on which throttling needs to
                                       be performed */
/*-------------------------------------------------------------------------*/

  if(!ds_3gpp_pdn_cntxt_get_subs_id_from_pdn(pdn_cntxt_p, &subs_id)||
     (ind_payload == NULL))
  {
    DS_LTE_MSG2_ERROR(" Pass in NULL Pdn Cntxt pointer 0x%x ,ind_payload ptr"
                      " 0x%x ",pdn_cntxt_p,ind_payload);
    return ;
  }

  if (ds_3gpp_nv_manager_get_enable_pdn_throt_per_rat(subs_id))
  {
    rat_type = DS_3GPP_THROT_RAT_LTE;
  }

  switch(ip_support) 
  {
    case DS_IPV4_ONLY:
    {
      DS_3GPP_APM_SET_INVALID_V6_IPADDR((*ind_payload),
                                        PS_NET_DOWN_REASON_IP_V4_ONLY_ALLOWED);
      ds_3gpp_pdn_throt_perform_reg_throttling
        (NULL, pdn_cntxt_p, (void *)PS_NET_DOWN_REASON_IP_V4_ONLY_ALLOWED, 
         DS_UMTS_PDP_IPV6, rat_type);
    }
      break;
    case DS_IPV4_SINGLE_BEARER:
    {
      DS_3GPP_APM_SET_INVALID_V6_IPADDR((*ind_payload),
                                    PS_NET_DOWN_REASON_SINGLE_ADDR_BEARER_ONLY);
    }
      break;
    case DS_IPV6_ONLY:
    {
      DS_3GPP_APM_SET_INVALID_V4_IPADDR((*ind_payload),
                                        PS_NET_DOWN_REASON_IP_V6_ONLY_ALLOWED);
      ds_3gpp_pdn_throt_perform_reg_throttling(NULL, pdn_cntxt_p, 
               (void *)PS_NET_DOWN_REASON_IP_V6_ONLY_ALLOWED, 
                DS_UMTS_PDP_IPV6, rat_type);
    }
      break;
    case DS_IPV6_SINGLE_BEARER:
    {
      DS_3GPP_APM_SET_INVALID_V4_IPADDR((*ind_payload),
                                    PS_NET_DOWN_REASON_SINGLE_ADDR_BEARER_ONLY);
    }
      break;
    default:
      DS_LTE_MSG0_ERROR("Invalid combination , error Network sends IPV4V6 "
                        "with cause code after IPV4V6 is requested ");
      break;
  }

}/* ds_eps_pdn_cntxt_update_apm_cause_code */
/*===========================================================================
FUNCTION DS_EPS_APN_PARAM_CHANGE_BEARER_TEARDOWN

DESCRIPTION
  This function tears down the bearer and puts the bearer and PDN context
  in an appropriate state

PARAMETERS 
  bearer_cntxt_p
 
DEPENDENCIES
  None.

RETURN VALUE
  void 
 
SIDE EFFECTS
  None.
===========================================================================*/
static void ds_eps_apn_param_change_bearer_teardown
(
   ds_bearer_context_s *bearer_context_p
)
{
   boolean retVal = FALSE;
   ds_3gpp_pdn_call_info_type mode_sp_info;
   ds_3gpp_down_reason_t  net_down_reason;
   ds_pdn_context_s *pdn_context_p = NULL;
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
   if (!ds_bearer_cntx_validate_bearer_context(bearer_context_p))
   {
     return;
   }

   retVal = ds_bearer_cntxt_prepare_for_teardown(&mode_sp_info,bearer_context_p);

   if (!retVal)
   {
     DS_LTE_MSG1_ERROR("ds_bearer_cntxt_prepare_for_teardown returned:%d",retVal);
     return;
   }

   /*------------------------------------------------------------------------ 
     Disable the flow and this will ensure that no data retries will be made
     in the whole process of disconnecting and reconnecting the PDN.
     Flow will be enabled when a bearer is reestablished.
   -------------------------------------------------------------------------*/
   ps_phys_link_disable_flow(&(bearer_context_p->phys_link),DS_FLOW_UMTS_MASK);
   /*-------------------------------------------------------------------------- 
     Send out a PDN disconnect only on the default bearer, The dedicated
     bearers will be torn down with this anyways.
     ------------------------------------------------------------------------*/

   if (bearer_context_p->ds_bearer_context_dyn_p->is_default)
   {
     if(ds_bearer_cntxt_tear_down_call(bearer_context_p,&mode_sp_info,NULL)
         == DS3G_FAILURE )
     {
      /*-----------------------------------------------------------------------
       The call has already ended. Do local cleanup
      -----------------------------------------------------------------------*/
       DS_3GPP_MSG1_HIGH("Call already ended Bearer Inst:%d",\
          (uint32)bearer_context_p->ds_bearer_context_dyn_p->client_data_ptr);

       ds_pdn_cntxt_unbind_default_flows(bearer_context_p->ds_bearer_context_dyn_p
                                        ->pdn_context_ptr);

      /*---------------------------------------------------------------------
        Disable signal if this is the last phys link. 
        Each enqueue func_ptr needs to be reset when bearer inst is freed.
        This needs to be done to avoid race conditions when phys_link_gone is
        posted and flow gets enabled on the phys_link leading to each_enq_f
        called when the bearer is getting freed..
       ---------------------------------------------------------------------*/
       ds_bearer_cntxt_free_bearer_inst(bearer_context_p);
       ps_disable_sig(bearer_context_p->rx_sig);
       ps_phys_link_enable_flow(&(bearer_context_p->phys_link),DS_FLOW_UMTS_MASK);
       ps_phys_link_gone_ind(&(bearer_context_p->phys_link));

       if(bearer_context_p->ds_bearer_context_dyn_p->pdn_context_cb_tbl_ptr
           ->bearer_down_ind_cb != NULL)
       {
         net_down_reason.reason.ps_iface_down_reason = PS_NET_DOWN_REASON_NOT_SPECIFIED;

         net_down_reason.reason_T = DS_3GPP_PS_IFACE_NET_DOWN_REASON_T;

         bearer_context_p->ds_bearer_context_dyn_p->pdn_context_cb_tbl_ptr
              ->bearer_down_ind_cb(
                      bearer_context_p->ds_bearer_context_dyn_p->pdn_context_ptr,
                      bearer_context_p,net_down_reason,FALSE);
       }/* Post bearer down indication with call_was_connected as False*/
     }
     else
     {
       /*----------------------------------------------------------------------------- 
         Get the associated PDN context, Only if it is not the last standing PDN context
         on LTE, Move the default bearer and corresponding PDN context to PENDING REDIAL
         -----------------------------------------------------------------------------*/
       pdn_context_p = bearer_context_p->ds_bearer_context_dyn_p->pdn_context_ptr;

       if (!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_context_p))
       {
         return;
       }

        /*---------------------------------------------------------------------------- 
        Check if there is any other normal PDN active but of a different profile
        number. This is to take care of the scenario where there are two PDN's to the
        same profile but of different PDP types.
       ------------------------------------------------------------------------------*/

       retVal = dsPdnContext_is_any_other_normal_pdn_diff_profile_num_active
                (pdn_context_p);

       if (retVal)
       {
         ds_3gpp_pdn_cntxt_prepare_iface_state_and_timers_for_redial
           (bearer_context_p);

         bearer_context_p->ds_bearer_context_dyn_p->state = 
           DS_BEARER_CONTEXT_STATE_PEND_REDIAL;

         pdn_context_p->ds_pdn_context_dyn_p->state =  DS_PDN_CONTEXT_STATE_PEND_REDIAL;

         DS_LTE_MSG2_HIGH("Bearer context:0x%x in pending redial state, "
         "Putting pdn context:0x%x in pending redial state",bearer_context_p,pdn_context_p);
       }
     }
   }
   return;
}
/*===========================================================================
FUNCTION DS_EPS_APN_PARAM_CHANGE_CMD_HDLR

DESCRIPTION
  This function sends out a pdn disconnect request and reconnects with
  the new changed parameters.

PARAMETERS 
  uint8 prof_num
 
DEPENDENCIES
  None.

RETURN VALUE
  void 
 
SIDE EFFECTS
  None.
===========================================================================*/
void ds_eps_apn_param_change_cmd_hdlr
(
   uint16                prof_num
)
{
  ds_pdn_context_s      *pdn_cntxt_p = NULL;
  ds_bearer_context_s   *bearer_cntxt_p = NULL;
  uint8                  pdn_index = 0;
  uint8                  bearer_index = 0;
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  /*-------------------------------------------------------------------- 
    For every PDN context that is valid, check if it is the pdn context
    associated with the profile number, If it is then we need to teardown
    the bearers associated with the PDN context
   
    If APN param change for a particular PDN is set, don't process the
    command.
    --------------------------------------------------------------------*/
  for (pdn_index = 0;pdn_index < DS_3GPP_MAX_PDN_CONTEXT; 
        pdn_index++)
  {
    pdn_cntxt_p = &ds_pdn_context_tbl[pdn_index];

    if(!ds_3gpp_pdn_cntx_validate_pdn_context(pdn_cntxt_p))
    {
      continue;
    }

    if (pdn_cntxt_p->ds_pdn_context_dyn_p->apn_param_chg_teardown)
    {
      DS_LTE_MSG1_HIGH ("APN Parameter change already in Progress; "
                        "Value is: $d" ,pdn_cntxt_p->ds_pdn_context_dyn_p->
                        apn_param_chg_teardown);
      continue;
    }

    if(DS_3GPP_PDN_SUPPORTS_EMERGENCY_SERVICES(pdn_cntxt_p))
    {
      DS_LTE_MSG0_HIGH("Emergency PDN, Ignore apn_param_chg");
      continue;
    }

    /*-------------------------------------------------------------------- 
      Only if the profile number matches and if the corresponding pdn
      context is in UP state, process the APN param change cmd request.
      -------------------------------------------------------------------*/
    if ((pdn_cntxt_p->ds_pdn_context_dyn_p->pdp_profile_num == prof_num) &&
        (pdn_cntxt_p->ds_pdn_context_dyn_p->state == DS_PDN_CONTEXT_STATE_UP))
    {
      DS_LTE_MSG1_HIGH("PDN context with profile number:%d found",prof_num);

      pdn_cntxt_p->ds_pdn_context_dyn_p->apn_param_chg_teardown = TRUE;
      /*----------------------------------------------------------------------------- 
        Tear down all the bearers associated with the PDN context.
        -----------------------------------------------------------------------------*/
      for (bearer_index=0;bearer_index < DS_3GPP_MAX_BEARER_CONTEXT_PER_PDN_CONTEXT;
            bearer_index++)
      {
        bearer_cntxt_p = pdn_cntxt_p->ds_pdn_context_dyn_p->
          bearer_context_ptr_tbl[bearer_index];

        if (!ds_bearer_cntx_validate_bearer_context(bearer_cntxt_p))
        {
          continue;
        }

        ds_eps_apn_param_change_bearer_teardown(bearer_cntxt_p);
      }
    }
  }
  return;
}

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_RESET_TARGET_RAT

DESCRIPTION
  This function resets target rat after attach failure and updates 3GPP network
  mode to current preferred mode.
PARAMETERS 
  pdn_cntxt_p
 
DEPENDENCIES
  None.

RETURN VALUE
  None
 
SIDE EFFECTS
  None.
===========================================================================*/
void ds_eps_pdn_cntxt_reset_target_rat
(
  ds_pdn_context_s  *pdn_cntxt_p
)
{
  sys_modem_as_id_e_type  subs_id = SYS_MODEM_AS_ID_NONE;
  sys_sys_mode_e_type 	  network_mode;

  if (!ds_3gpp_pdn_cntxt_get_subs_id_from_pdn(pdn_cntxt_p, &subs_id))
  {
    return;
  }

  /*----------------------------------------------------------------------
    Resetting target rat.
  ----------------------------------------------------------------------*/
  DS_LTE_MSG0_HIGH("Resetting Target Rat after Attach Failure");
  ds3gmgr_send_trat_ind(SYS_SYS_MODE_NONE,0,NULL,subs_id);

  network_mode = ds_3gpp_get_apn_current_mode(pdn_cntxt_p);

  if ( DS_3GPP_IS_3GPP_CURRENT_MODE(network_mode))
  {
    DS_LTE_MSG1_HIGH("Resetting DS3GPP internal mode after Attach Failure to %d",
                      network_mode);
    ds3gpp_update_network_mode(network_mode, subs_id);
  }
}/* ds_eps_pdn_cntxt_reset_target_rat */

#ifdef FEATURE_EMERGENCY_PDN
/*===========================================================================
FUNCTION DS_EPS_PDN_CNTX_DEACT_NON_EMC_BEARER_IND_HDLR

DESCRIPTION
  This function is used to handle the message from NAS. This message is sent
  whenever T3420 timer expires

  Here we validate the message ID and we update ds_eps_emergency_auth_fail
  
PARAMETERS
  msgr_type - UMID of the message sent
  dsmsg_ptr - Pointer to the payload

DEPENDENCIES
  None.

RETURN VALUE
  None

SIDE EFFECTS
  None.
===========================================================================*/ 
void ds_eps_pdn_cntxt_deact_non_emc_bearer_ind_hdlr
(
  msgr_umid_type              msgr_type,
  const msgr_hdr_struct_type *dsmsg_ptr
)
{
  ds_pdn_context_s                    *emerg_pdn_cntx_p = NULL;
  /* - - - - - - - - - - - - - -  - - - - - - - - - - - - - - - - - - - - - - - */

  if((msgr_type != NAS_EMM_DEACT_NON_EMC_BEARER_IND) ||
     (dsmsg_ptr == NULL))
  {
    DS_LTE_MSG2_ERROR("ds_eps_pdn_cntxt_deact_non_emc_bearer_ind_hdlr: Invalid "
                      "message %d or dsmsg_ptr %d",
                      msgr_type,
                      dsmsg_ptr);
    return;
  }

  emerg_pdn_cntx_p = ds_3gpp_get_emerg_pdn_cntxt();

  if(ds_3gpp_pdn_cntx_validate_pdn_context(emerg_pdn_cntx_p))
  {
    DS_LTE_MSG0_HIGH("Received T3420 from NAS");
    ds_3gpp_pdn_cntxt_set_emergency_auth_fail(TRUE); 
    ds_3gpp_pdn_cntxt_set_pending_teardown_flag();
    ds_3gpp_pdn_cntxt_check_and_teardown_non_emergency_pdns(); 
  }
  else
  {
    DS_LTE_MSG0_HIGH("Ignore T3420 indication, no emergency call available");
  }
  return;
}/*ds_eps_pdn_cntxt_deact_non_emc_bearer_ind_hdlr*/
#endif /*FEATURE_EMERGENCY_PDN*/

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_CPHY_CA_EVENT_HDLR

DESCRIPTION
  This function is used to handle the LTE_CPHY_CA_EVENT_IND message from LTE
  ML1. MH will cache the p and s cell info for carrier aggregation.

PARAMETERS
  msgr_type  - UMID of the message sent
  dsmsg_ptr - Pointer to the payload

DEPENDENCIES
  None.

RETURN VALUE
  TRUE  - if the message header is correct 
  FALSE - otherwise  

SIDE EFFECTS
  None.
===========================================================================*/ 
static boolean ds_eps_pdn_cntxt_cphy_ca_event_hdlr
(
  msgr_umid_type             msgr_type,
  const msgr_hdr_struct_type *dsmsg_ptr
)
{
  lte_cphy_ca_event_ind_s  *ds_lte_cphy_ca_event_ptr = NULL;
  sys_modem_as_id_e_type    subs_id = SYS_MODEM_AS_ID_NONE;
  ds3gsubsmgr_subs_id_e_type ds3g_subs_id = DS3GSUBSMGR_SUBS_ID_INVALID;
  uint32                     prev_scell_active = 0;
  boolean                    lte_ca_dl_available = FALSE;
  boolean                    lte_ca_ul_available = FALSE;
  boolean                    notify_dsd = FALSE;
  ds_eps_ca_display_threshold_s  *ca_disp_thresh_p = NULL;
  uint8                           ue_cat = 0;
  uint32                          aggr_dl_bw = 0;
  boolean                         ca_available = FALSE;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  if((msgr_type != LTE_CPHY_CA_EVENT_IND) || (dsmsg_ptr == NULL))
  {
    DS_LTE_MSG2_ERROR("ds_eps_cphy_ca_event_hdlr: Invalid "
                      "message %d or dsmsg_ptr %d",
                      msgr_type, dsmsg_ptr);
    return FALSE;
  }

  ds_lte_cphy_ca_event_ptr = (lte_cphy_ca_event_ind_s*)dsmsg_ptr;

  /*------------------------------------------------------------------- 
     ML1 currently only sends this message on DDS.
     Added support to update to DDS if subs_id is not matching
  -------------------------------------------------------------------*/
  subs_id = INST_ID_TO_SYS_AS_ID(ds_lte_cphy_ca_event_ptr->msgr_hdr.inst_id);

  /*------------------------------------------------------------------- 
     TODO: Remove this override for L+L inplementatation. Currently,
     inst_id will always be set to 0
  -------------------------------------------------------------------*/
    subs_id = ds3g_get_ps_subs_id();

  if (!ds3gsubsmgr_is_subs_id_valid(subs_id))
  {
    return FALSE;
  }

  ds3g_subs_id = ds3gsubsmgr_subs_id_cm_to_ds3g(subs_id);

/*-------------------------------------------------------------------------
    Get the LTE_CA_Display_Threshold configuration
  -------------------------------------------------------------------------*/
  ca_disp_thresh_p = ds_3gpp_nv_manager_get_lte_ca_display_threshold(subs_id);

  if (ca_disp_thresh_p == NULL )
  {
    DS_LTE_MSG0_ERROR("NULL LTE CA display threshold pointer");
    return FALSE;
  }

  DS_LTE_MSG4_HIGH("Threshold Values: ue_category:%d aggr_dl_bw:%d aggr_ul_bw:%d notif_mechanism:%d",
                   ca_disp_thresh_p->ue_category,
                   ca_disp_thresh_p->aggr_dl_bw,
                   ca_disp_thresh_p->aggr_ul_bw,
                   ca_disp_thresh_p->notif_mechanism);

  /*-------------------------------------------------------------------------
    Based on Threshold notification mechanism determine if CA available
  -------------------------------------------------------------------------*/
  switch ( ds_lte_cphy_ca_event_ptr->scell_info.scell_state )
  {
    case LTE_CPHY_SCELL_STATE_DECONFIGURED:
      ca_available = FALSE;
      break;

    case LTE_CPHY_SCELL_STATE_CONFIGURED_ACTIVATED:
      ca_available = TRUE;
      break;

    case LTE_CPHY_SCELL_STATE_CONFIGURED_DEACTIVATED:
      if(ca_disp_thresh_p->notif_mechanism ==
         DS_EPS_CA_NOTIFY_CA_SCELL_ACTIVATED)
      {
        ca_available = FALSE;
      }
      else
      {
        ca_available = TRUE;
      }
      break;

    default:
      DS_LTE_MSG1_MED("Unhandled scell state received: %d", 
                       ds_lte_cphy_ca_event_ptr->scell_info.scell_state);
      break;
  }

  do
  {
    /*---------------------------------------------------------------------
      Check UE category threshold
    ---------------------------------------------------------------------*/
    ue_cat = ds_eps_bearer_cntxt_get_ue_cat(subs_id);
    if( ue_cat < ca_disp_thresh_p->ue_category )
    {
      DS_LTE_MSG2_MED(" UE categoty:%d < Threshold UE category. "
                        "Notifying CA unavailable to DSD",
                        ue_cat, ca_disp_thresh_p->ue_category);
      ca_available = FALSE;
      break;
    }

    /*---------------------------------------------------------------------
      Check Aggregated DL Bandwidth threshold
    ---------------------------------------------------------------------*/
    aggr_dl_bw
      = ( ds_eps_pdn_cntxt_get_lte_bandwidth(
                       ds_lte_cphy_ca_event_ptr->pcell_info.dl_bandwidth) +
          ds_eps_pdn_cntxt_get_lte_bandwidth(
                       ds_lte_cphy_ca_event_ptr->scell_info.dl_bandwidth) )/1000;
    if( aggr_dl_bw < ca_disp_thresh_p->aggr_dl_bw )
    {
      DS_LTE_MSG2_MED(" Aggr DL BW:%d < Threshold Aggr DL BW. "
                        "Notifying CA unavailable to DSD",
                        aggr_dl_bw, ca_disp_thresh_p->aggr_dl_bw);
      ca_available = FALSE;
      break;
    }
  }while(0);

  if( ca_available )
  {
      prev_scell_active = ds_eps_lte_active_scell[ds3g_subs_id];
      ds_eps_lte_active_scell[ds3g_subs_id] = TRUE;

      /* Notify DSD of LTE CA acquired only in first instance of scell active */
      if (prev_scell_active == FALSE)
      {
        lte_ca_dl_available = TRUE;

        notify_dsd = TRUE;
      }
  }
  else
  {
      prev_scell_active = 
        ds_eps_lte_active_scell[ds3g_subs_id];
      ds_eps_lte_active_scell[ds3g_subs_id] = FALSE;;

      /* Notify DSD of scell lost if all scell are deactivated */
      if (prev_scell_active == TRUE)
      {
        lte_ca_dl_available = FALSE;

        notify_dsd = TRUE;
      }
  }

  DS_LTE_MSG3_HIGH("Processing LTE_CPHY_CA_EVENT_IND on subs id (CM) %d. "
                   "Scell state: %d. Active scell: %d",
                   subs_id, 
                   ds_lte_cphy_ca_event_ptr->scell_info.scell_state,
                   ds_eps_lte_active_scell[ds3g_subs_id]);

  if (notify_dsd == TRUE)
  {
    DS_LTE_MSG3_HIGH("Notify DSD of LTE CA availability on subs id %d (CM). "
                     "DL: %d UL: %d",
                     subs_id,
                     lte_ca_dl_available,
                     lte_ca_ul_available);
    ds3gdsdif_notify_dsd_lte_ca_chg_event(subs_id,
                                          lte_ca_dl_available,
                                          lte_ca_ul_available);
  }

  return TRUE;
} /* ds_eps_pdn_cntxt_cphy_ca_event_hdlr */

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_GET_ACTIVE_SCELL

DESCRIPTION
  This function returns if sceel is active on a given subscription
  for carrier aggregation

PARAMETERS 
  subs_id - subscription to retrieve scells

DEPENDENCIES
  None.

RETURN VALUE
  Number of active scells.  

SIDE EFFECTS
  None.
===========================================================================*/ 
uint8 ds_eps_pdn_cntxt_get_active_scell
(
  sys_modem_as_id_e_type subs_id
)
{
  ds3gsubsmgr_subs_id_e_type ds3g_subs_id = DS3GSUBSMGR_SUBS_ID_INVALID;
  boolean                     active_scell = FALSE;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  
  if (!ds3gsubsmgr_is_subs_id_valid(subs_id))
  {
    DS_LTE_MSG1_ERROR("Invalid Subs id(CM) %d",subs_id);
    return FALSE;
  }

  ds3g_subs_id = ds3gsubsmgr_subs_id_cm_to_ds3g(subs_id);

  active_scell = ds_eps_lte_active_scell[ds3g_subs_id];

  return active_scell;

} /* ds_eps_pdn_cntxt_get_active_scell */

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_GET_LTE_BANDWIDTH

DESCRIPTION
  This function return LTE bandwidth in KHz from Number of Resource Bearers

PARAMETERS
  None.

DEPENDENCIES
  None.

RETURN VALUE
  Bandwidth in KHz

SIDE EFFECTS
  None.
===========================================================================*/ 
uint32 ds_eps_pdn_cntxt_get_lte_bandwidth
(
  lte_bandwidth_e lte_bw_nrb
)
{
  uint32  lte_bandwidth = 0;
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  switch( lte_bw_nrb )
  {
    case LTE_BW_NRB_6:
      lte_bandwidth = 1400;
      break;
    case LTE_BW_NRB_15:
      lte_bandwidth = 3000;
      break;
    case LTE_BW_NRB_25:
      lte_bandwidth = 5000;
      break;
    case LTE_BW_NRB_50:
      lte_bandwidth = 10000;
      break;
    case LTE_BW_NRB_75:
      lte_bandwidth = 15000;
      break;
    case LTE_BW_NRB_100:
      lte_bandwidth = 20000;
      break;
    default:
      break;
  }
  return lte_bandwidth;
} /* ds_eps_pdn_cntxt_get_lte_bandwidth */

/*===========================================================================
FUNCTION  DS_EPS_PDN_CNTXT_GET_RESOLVED_APN_PER_ATTACH_SM

DESCRIPTION
  This function gets the resolved apn stored in attach sm.
  The function returns TRUE only if it is NON NULL resolved apn

PARAMETERS
  resolved_apn_ptr
  subs_id
 
DEPENDENCIES
  None.

RETURN VALUE 
 
SIDE EFFECTS
  None.

===========================================================================*/
boolean ds_eps_pdn_cntxt_get_resolved_apn_per_attach_sm
(
   byte                    *resolved_apn_ptr,
   sys_modem_as_id_e_type   subs_id
)
{
  boolean                                 ret_val = FALSE;
  ds3geventmgr_filter_type                filter_info;
  ps_sys_null_resolved_apn_info_type      resolved_apn_info;
 /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
  if (resolved_apn_ptr == NULL)
  {
    DS_LTE_MSG0_ERROR("Input ptr is NULL");
    return ret_val;
  }

  if (!ds3gsubsmgr_is_subs_id_valid(subs_id))
  {
    DS_LTE_MSG1_ERROR("Invalid Subs Id (CM) %d",subs_id);
    return ret_val;
  }

  filter_info.ps_subs_id =  (ps_sys_subscription_enum_type) 
                                        ds3gsubsmgr_subs_id_cm_to_ds(subs_id);
  filter_info.tech = PS_SYS_TECH_3GPP;

  /*------------------------------------------------------------------------- 
    Acquire the critical section because this resolved apn can be accessed
    in other contexts (Routing)
  --------------------------------------------------------------------------*/
  ds3gpp_enter_global_crit_section();

  if(ds3geventmgr_get_conf_info(DS3GEVENTMGR_NULL_RESOLVED_APN_EV,
                                (void*) &resolved_apn_info,
                                &filter_info))
  {
    if (resolved_apn_info.apn_length != 0)
    {
      (void)strlcpy((char*)resolved_apn_ptr,
                     resolved_apn_info.apn_name,
                     DS_UMTS_MAX_APN_STRING_LEN+1);
    

      ret_val = TRUE;
    }
  }

  ds3gpp_leave_global_crit_section();

  return ret_val;
}/*ds_eps_pdn_cntxt_get_resolved_apn_per_attach_sm*/

/*===========================================================================
FUNCTION DS_EPS_PDN_CNTXT_IS_SILENT_REDIAL_ALLOWED

DESCRIPTION
  This function determines whether we can allow silent redial based on 
  pdp_type_to_use.

PARAMETERS
  pdn_cntxt_ptr.

DEPENDENCIES
  None.

RETURN VALUE
  boolean

SIDE EFFECTS
  None.
===========================================================================*/
boolean ds_eps_pdn_cntxt_is_silent_redial_allowed
(
  ds_pdn_context_s *pdn_cntxt_ptr
)
{
  boolean                  status = FALSE;
  sys_modem_as_id_e_type   subs_id = SYS_MODEM_AS_ID_NONE;
  ds_apn_ip_support_type_e ip_support;
  ds_pdn_context_s         temp_pdn_cntxt = {NULL};
  ds_umts_pdp_profile_type prof_context;
  boolean                  redial_allowed = FALSE;
  boolean                  v4_iface_in_use = FALSE, v6_iface_in_use = FALSE;

  if(!ds_3gpp_pdn_cntxt_get_subs_id_from_pdn(pdn_cntxt_ptr,&subs_id))
  {
    DS_LTE_MSG1_ERROR("PDN context could not fetch valid sub id:%d",
                       subs_id);
    return redial_allowed;
  }

  do
  {
     temp_pdn_cntxt.ds_pdn_context_dyn_p = (ds_pdn_context_dyn_s *)
    	                                     modem_mem_alloc(
    	                                            sizeof(ds_pdn_context_dyn_s),   
    	                                            MODEM_MEM_CLIENT_DATA);
  
    if (NULL == (temp_pdn_cntxt.ds_pdn_context_dyn_p))
    {
      DS_LTE_MSG0_ERROR("Memory allocation failure, fail silent redial");
      break;
    }
  
    memset((temp_pdn_cntxt.ds_pdn_context_dyn_p), 0, sizeof(ds_pdn_context_dyn_s));
  
    memscpy((temp_pdn_cntxt.ds_pdn_context_dyn_p), sizeof(ds_pdn_context_dyn_s),
    	      (pdn_cntxt_ptr->ds_pdn_context_dyn_p), sizeof(ds_pdn_context_dyn_s));
  
    memset(&prof_context, 0, sizeof(ds_umts_pdp_profile_type));
    status = ds_umts_get_pdp_profile_all_data_per_subs(
    	            pdn_cntxt_ptr->ds_pdn_context_dyn_p->pdp_profile_num,
                                  dsumts_subs_mgr_get_subs_id(subs_id),
                                                        &prof_context);
  
    if (DS_UMTS_PDP_SUCCESS != status)
    {
      DS_LTE_MSG1_ERROR("Invalid Profile: %d in PDN Context",
                         pdn_cntxt_ptr->ds_pdn_context_dyn_p->pdp_profile_num);
      break;
    }
    
    status = ds_pdn_cntxt_process_pdp_profile_info(&temp_pdn_cntxt,
                                                   temp_pdn_cntxt.ds_pdn_context_dyn_p->pdp_profile_num,
                                                   &ip_support,
                                                   &prof_context);
   
    temp_pdn_cntxt.ds_pdn_context_dyn_p->profile_is_valid = status;
   
    if(status == FALSE)
    {
      DS_LTE_MSG0_ERROR("pdp_profile can't be processed");
      break;
    }

    /*-------------------------------------------------------------------------
      Silent Redial will be allowed only when the iface_in_use ip_type or 
      application requested ip_type matches that of the pdp_type_to_use after 
      determining pdp_type_to_use in roam/home scenarios.

      Allowing silent redial for mismatched IP type is not correct as the 
      philosophy behind  silent redial is to make the application transparent 
      of IRAT happening on modem. But, in case of pdp_type mismatch call needs 
      to be ended and thus redial shouldn't be performed.
    -------------------------------------------------------------------------*/

    if(temp_pdn_cntxt.ds_pdn_context_dyn_p->pdp_profile.context.pdp_type == 
       pdn_cntxt_ptr->ds_pdn_context_dyn_p->pdp_profile.context.pdp_type)
        {
          redial_allowed = TRUE;
        break;
    }
  }while(0);

  if (NULL != (temp_pdn_cntxt.ds_pdn_context_dyn_p))
  {
    DS_LTE_MSG4_HIGH("PDP type to use: %d, v4_iface in _use: %d v6_iface_in_use: %d"
		     " Redial_allowed: %d",
		      temp_pdn_cntxt.ds_pdn_context_dyn_p->pdp_profile.context.pdp_type,
                      v4_iface_in_use, v6_iface_in_use,
                      redial_allowed);

    modem_mem_free((temp_pdn_cntxt.ds_pdn_context_dyn_p), MODEM_MEM_CLIENT_DATA);
  }

  return redial_allowed;

}/* ds_eps_pdn_cntxt_is_silent_redial_allowed */

#endif /* FEATURE_DATA_LTE */
/*===========================================================================
 

 
=============================================================================

                                UNIT TEST

===========================================================================*/

