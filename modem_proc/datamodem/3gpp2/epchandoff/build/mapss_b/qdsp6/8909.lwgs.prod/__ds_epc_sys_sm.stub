/*!
  @file
  __ds_epc_sys_sm.stub

  @brief
  This module contains the entry, exit, and transition functions
  necessary to implement the following state machines:

  @detail
  epc_sys_sm ( 1 instance/s )


  OPTIONAL further detailed description of state machines
  - DELETE this section if unused.

*/

/*===========================================================================

  Copyright (c) 2017 Qualcomm Technologies Incorporated.
  All Rights Reserved
  Qualcomm Confidential and Proprietary

  Export of this technology or software is regulated by the U.S. Government.
  Diversion contrary to U.S. law prohibited.

  All ideas, data and information contained in or disclosed by
  this document are confidential and proprietary information of
  Qualcomm Technologies Incorporated and all rights therein are expressly reserved.
  By accepting this material the recipient agrees that this material
  and the information contained therein are held in confidence and in
  trust and will not be used, copied, reproduced in whole or in part,
  nor its contents revealed in any manner to others without the express
  written permission of Qualcomm Technologies Incorporated.

===========================================================================*/


/*===========================================================================

                        EDIT HISTORY FOR MODULE

This section contains comments describing changes made to the module.
Notice that changes are listed in reverse chronological order.

$Header: $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
===========================================================================*/

/*===========================================================================

                           INCLUDE FILES

===========================================================================*/

/* Include STM external API */
#include <stm2.h>

//! @todo Include necessary files here


/*===========================================================================

         STM COMPILER GENERATED PROTOTYPES AND DATA STRUCTURES

===========================================================================*/

/* Include STM compiler generated internal data structure file */
#include "__ds_epc_sys_sm_int.h"

/*===========================================================================

                         LOCAL VARIABLES

===========================================================================*/


/*! @brief Structure for state-machine per-instance local variables
*/
typedef struct
{
  int   internal_var;  /*!< My internal variable */
  void *internal_ptr;  /*!< My internal pointer */
  //! @todo SM per-instance variables go here
} __ds_epc_sys_sm_type;


/*! @brief Variables internal to module __ds_epc_sys_sm.stub
*/
STATIC __ds_epc_sys_sm_type __ds_epc_sys_sm;



/*===========================================================================

                 STATE MACHINE: epc_sys_sm

===========================================================================*/

/*===========================================================================

  STATE MACHINE ENTRY FUNCTION:  epc_sys_sm_init

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_sys_sm

    @detail
    Called upon activation of this state machine, with optional
    user-passed payload pointer parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_init
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_init() */


/*===========================================================================

  STATE MACHINE EXIT FUNCTION:  epc_sys_sm_cleanup

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_sys_sm

    @detail
    Called upon deactivation of this state machine, with optional
    user-passed payload pointer parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_cleanup
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_cleanup() */


/*===========================================================================

     (State Machine: epc_sys_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_SSM_STATE_INIT

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_sys_sm_enter_init

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_sys_sm,
    state EPC_SSM_STATE_INIT

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_enter_init
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_enter_init() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_sys_sm_exit_init

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_sys_sm,
    state EPC_SSM_STATE_INIT

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_exit_init
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_exit_init() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_attach_init_in_init

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_INIT,
    upon receiving input EPC_SSM_LTE_ATTACH_INIT_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_ATTACH_INIT_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_attach_init_in_init
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_attach_init_in_init() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_in_init

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_INIT,
    upon receiving input EPC_SSM_LTE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_in_init
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_in_init() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_ehrpd_in_init

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_INIT,
    upon receiving input EPC_SSM_EHRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_EHRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_ehrpd_in_init
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_ehrpd_in_init() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_hrpd_in_init

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_INIT,
    upon receiving input EPC_SSM_HRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_HRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_hrpd_in_init
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_hrpd_in_init() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_1x_in_init

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_INIT,
    upon receiving input EPC_SSM_1X_EV

    @detail
    Called upon receipt of input EPC_SSM_1X_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_1x_in_init
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_1x_in_init() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_enable_in_init

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_INIT,
    upon receiving input EPC_SSM_LTE_TUNNELING_ENABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_ENABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_enable_in_init
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_enable_in_init() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_disable_in_init

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_INIT,
    upon receiving input EPC_SSM_LTE_TUNNELING_DISABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_DISABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_disable_in_init
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_disable_in_init() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_other_in_init

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_INIT,
    upon receiving input EPC_SSM_OTHER_EV

    @detail
    Called upon receipt of input EPC_SSM_OTHER_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_other_in_init
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_other_in_init() */


/*===========================================================================

     (State Machine: epc_sys_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_SSM_STATE_LTE_ATTACHING

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_sys_sm_enter_lte_attaching

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_ATTACHING

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_enter_lte_attaching
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_enter_lte_attaching() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_sys_sm_exit_lte_attaching

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_ATTACHING

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_exit_lte_attaching
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_exit_lte_attaching() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_attach_init_in_lte_attaching

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_ATTACHING,
    upon receiving input EPC_SSM_LTE_ATTACH_INIT_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_ATTACH_INIT_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_attach_init_in_lte_attaching
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_attach_init_in_lte_attaching() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_in_lte_attaching

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_ATTACHING,
    upon receiving input EPC_SSM_LTE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_in_lte_attaching
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_in_lte_attaching() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_ehrpd_in_lte_attaching

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_ATTACHING,
    upon receiving input EPC_SSM_EHRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_EHRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_ehrpd_in_lte_attaching
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_ehrpd_in_lte_attaching() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_hrpd_in_lte_attaching

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_ATTACHING,
    upon receiving input EPC_SSM_HRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_HRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_hrpd_in_lte_attaching
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_hrpd_in_lte_attaching() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_1x_in_lte_attaching

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_ATTACHING,
    upon receiving input EPC_SSM_1X_EV

    @detail
    Called upon receipt of input EPC_SSM_1X_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_1x_in_lte_attaching
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_1x_in_lte_attaching() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_enable_in_lte_attaching

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_ATTACHING,
    upon receiving input EPC_SSM_LTE_TUNNELING_ENABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_ENABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_enable_in_lte_attaching
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_enable_in_lte_attaching() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_disable_in_lte_attaching

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_ATTACHING,
    upon receiving input EPC_SSM_LTE_TUNNELING_DISABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_DISABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_disable_in_lte_attaching
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_disable_in_lte_attaching() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_other_in_lte_attaching

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_ATTACHING,
    upon receiving input EPC_SSM_OTHER_EV

    @detail
    Called upon receipt of input EPC_SSM_OTHER_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_other_in_lte_attaching
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_other_in_lte_attaching() */


/*===========================================================================

     (State Machine: epc_sys_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_SSM_STATE_LTE

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_sys_sm_enter_lte

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_enter_lte
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_enter_lte() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_sys_sm_exit_lte

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_exit_lte
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_exit_lte() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_attach_init_in_lte

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE,
    upon receiving input EPC_SSM_LTE_ATTACH_INIT_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_ATTACH_INIT_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_attach_init_in_lte
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_attach_init_in_lte() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_in_lte

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE,
    upon receiving input EPC_SSM_LTE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_in_lte
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_in_lte() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_ehrpd_in_lte

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE,
    upon receiving input EPC_SSM_EHRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_EHRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_ehrpd_in_lte
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_ehrpd_in_lte() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_hrpd_in_lte

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE,
    upon receiving input EPC_SSM_HRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_HRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_hrpd_in_lte
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_hrpd_in_lte() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_1x_in_lte

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE,
    upon receiving input EPC_SSM_1X_EV

    @detail
    Called upon receipt of input EPC_SSM_1X_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_1x_in_lte
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_1x_in_lte() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_enable_in_lte

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE,
    upon receiving input EPC_SSM_LTE_TUNNELING_ENABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_ENABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_enable_in_lte
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_enable_in_lte() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_disable_in_lte

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE,
    upon receiving input EPC_SSM_LTE_TUNNELING_DISABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_DISABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_disable_in_lte
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_disable_in_lte() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_other_in_lte

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE,
    upon receiving input EPC_SSM_OTHER_EV

    @detail
    Called upon receipt of input EPC_SSM_OTHER_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_other_in_lte
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_other_in_lte() */


/*===========================================================================

     (State Machine: epc_sys_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_SSM_STATE_1X

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_sys_sm_enter_1x

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_sys_sm,
    state EPC_SSM_STATE_1X

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_enter_1x
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_enter_1x() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_sys_sm_exit_1x

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_sys_sm,
    state EPC_SSM_STATE_1X

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_exit_1x
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_exit_1x() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_attach_init_in_1x

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_1X,
    upon receiving input EPC_SSM_LTE_ATTACH_INIT_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_ATTACH_INIT_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_attach_init_in_1x
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_attach_init_in_1x() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_in_1x

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_1X,
    upon receiving input EPC_SSM_LTE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_in_1x
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_in_1x() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_ehrpd_in_1x

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_1X,
    upon receiving input EPC_SSM_EHRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_EHRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_ehrpd_in_1x
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_ehrpd_in_1x() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_hrpd_in_1x

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_1X,
    upon receiving input EPC_SSM_HRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_HRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_hrpd_in_1x
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_hrpd_in_1x() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_1x_in_1x

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_1X,
    upon receiving input EPC_SSM_1X_EV

    @detail
    Called upon receipt of input EPC_SSM_1X_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_1x_in_1x
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_1x_in_1x() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_enable_in_1x

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_1X,
    upon receiving input EPC_SSM_LTE_TUNNELING_ENABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_ENABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_enable_in_1x
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_enable_in_1x() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_disable_in_1x

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_1X,
    upon receiving input EPC_SSM_LTE_TUNNELING_DISABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_DISABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_disable_in_1x
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_disable_in_1x() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_other_in_1x

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_1X,
    upon receiving input EPC_SSM_OTHER_EV

    @detail
    Called upon receipt of input EPC_SSM_OTHER_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_other_in_1x
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_other_in_1x() */


/*===========================================================================

     (State Machine: epc_sys_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_SSM_STATE_HRPD

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_sys_sm_enter_hrpd

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_sys_sm,
    state EPC_SSM_STATE_HRPD

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_enter_hrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_enter_hrpd() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_sys_sm_exit_hrpd

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_sys_sm,
    state EPC_SSM_STATE_HRPD

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_exit_hrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_exit_hrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_attach_init_in_hrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_HRPD,
    upon receiving input EPC_SSM_LTE_ATTACH_INIT_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_ATTACH_INIT_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_attach_init_in_hrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_attach_init_in_hrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_in_hrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_HRPD,
    upon receiving input EPC_SSM_LTE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_in_hrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_in_hrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_ehrpd_in_hrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_HRPD,
    upon receiving input EPC_SSM_EHRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_EHRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_ehrpd_in_hrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_ehrpd_in_hrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_hrpd_in_hrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_HRPD,
    upon receiving input EPC_SSM_HRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_HRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_hrpd_in_hrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_hrpd_in_hrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_1x_in_hrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_HRPD,
    upon receiving input EPC_SSM_1X_EV

    @detail
    Called upon receipt of input EPC_SSM_1X_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_1x_in_hrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_1x_in_hrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_enable_in_hrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_HRPD,
    upon receiving input EPC_SSM_LTE_TUNNELING_ENABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_ENABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_enable_in_hrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_enable_in_hrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_disable_in_hrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_HRPD,
    upon receiving input EPC_SSM_LTE_TUNNELING_DISABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_DISABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_disable_in_hrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_disable_in_hrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_other_in_hrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_HRPD,
    upon receiving input EPC_SSM_OTHER_EV

    @detail
    Called upon receipt of input EPC_SSM_OTHER_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_other_in_hrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_other_in_hrpd() */


/*===========================================================================

     (State Machine: epc_sys_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_SSM_STATE_EHRPD

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_sys_sm_enter_ehrpd

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_sys_sm,
    state EPC_SSM_STATE_EHRPD

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_enter_ehrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_enter_ehrpd() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_sys_sm_exit_ehrpd

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_sys_sm,
    state EPC_SSM_STATE_EHRPD

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_exit_ehrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_exit_ehrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_attach_init_in_ehrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_EHRPD,
    upon receiving input EPC_SSM_LTE_ATTACH_INIT_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_ATTACH_INIT_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_attach_init_in_ehrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_attach_init_in_ehrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_in_ehrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_EHRPD,
    upon receiving input EPC_SSM_LTE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_in_ehrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_in_ehrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_ehrpd_in_ehrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_EHRPD,
    upon receiving input EPC_SSM_EHRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_EHRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_ehrpd_in_ehrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_ehrpd_in_ehrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_hrpd_in_ehrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_EHRPD,
    upon receiving input EPC_SSM_HRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_HRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_hrpd_in_ehrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_hrpd_in_ehrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_1x_in_ehrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_EHRPD,
    upon receiving input EPC_SSM_1X_EV

    @detail
    Called upon receipt of input EPC_SSM_1X_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_1x_in_ehrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_1x_in_ehrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_enable_in_ehrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_EHRPD,
    upon receiving input EPC_SSM_LTE_TUNNELING_ENABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_ENABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_enable_in_ehrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_enable_in_ehrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_disable_in_ehrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_EHRPD,
    upon receiving input EPC_SSM_LTE_TUNNELING_DISABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_DISABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_disable_in_ehrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_disable_in_ehrpd() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_other_in_ehrpd

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_EHRPD,
    upon receiving input EPC_SSM_OTHER_EV

    @detail
    Called upon receipt of input EPC_SSM_OTHER_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_other_in_ehrpd
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_other_in_ehrpd() */


/*===========================================================================

     (State Machine: epc_sys_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_SSM_STATE_LTE_TUNNELING

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_sys_sm_enter_lte_tunneling

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_TUNNELING

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_enter_lte_tunneling
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_enter_lte_tunneling() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_sys_sm_exit_lte_tunneling

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_TUNNELING

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_exit_lte_tunneling
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_exit_lte_tunneling() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_attach_init_in_lte_tunneling

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_TUNNELING,
    upon receiving input EPC_SSM_LTE_ATTACH_INIT_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_ATTACH_INIT_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_attach_init_in_lte_tunneling
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_attach_init_in_lte_tunneling() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_in_lte_tunneling

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_TUNNELING,
    upon receiving input EPC_SSM_LTE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_in_lte_tunneling
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_in_lte_tunneling() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_ehrpd_in_lte_tunneling

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_TUNNELING,
    upon receiving input EPC_SSM_EHRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_EHRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_ehrpd_in_lte_tunneling
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_ehrpd_in_lte_tunneling() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_hrpd_in_lte_tunneling

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_TUNNELING,
    upon receiving input EPC_SSM_HRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_HRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_hrpd_in_lte_tunneling
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_hrpd_in_lte_tunneling() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_1x_in_lte_tunneling

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_TUNNELING,
    upon receiving input EPC_SSM_1X_EV

    @detail
    Called upon receipt of input EPC_SSM_1X_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_1x_in_lte_tunneling
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_1x_in_lte_tunneling() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_enable_in_lte_tunneling

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_TUNNELING,
    upon receiving input EPC_SSM_LTE_TUNNELING_ENABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_ENABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_enable_in_lte_tunneling
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_enable_in_lte_tunneling() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_disable_in_lte_tunneling

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_TUNNELING,
    upon receiving input EPC_SSM_LTE_TUNNELING_DISABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_DISABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_disable_in_lte_tunneling
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_disable_in_lte_tunneling() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_other_in_lte_tunneling

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_LTE_TUNNELING,
    upon receiving input EPC_SSM_OTHER_EV

    @detail
    Called upon receipt of input EPC_SSM_OTHER_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_other_in_lte_tunneling
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_other_in_lte_tunneling() */


/*===========================================================================

     (State Machine: epc_sys_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_SSM_STATE_OTHER

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_sys_sm_enter_other

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_sys_sm,
    state EPC_SSM_STATE_OTHER

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_enter_other
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_enter_other() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_sys_sm_exit_other

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_sys_sm,
    state EPC_SSM_STATE_OTHER

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_sys_sm_exit_other
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_sys_sm_exit_other() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_attach_init_in_other

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_OTHER,
    upon receiving input EPC_SSM_LTE_ATTACH_INIT_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_ATTACH_INIT_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_attach_init_in_other
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_attach_init_in_other() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_in_other

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_OTHER,
    upon receiving input EPC_SSM_LTE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_in_other
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_in_other() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_ehrpd_in_other

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_OTHER,
    upon receiving input EPC_SSM_EHRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_EHRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_ehrpd_in_other
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_ehrpd_in_other() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_hrpd_in_other

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_OTHER,
    upon receiving input EPC_SSM_HRPD_EV

    @detail
    Called upon receipt of input EPC_SSM_HRPD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_hrpd_in_other
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_hrpd_in_other() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_1x_in_other

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_OTHER,
    upon receiving input EPC_SSM_1X_EV

    @detail
    Called upon receipt of input EPC_SSM_1X_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_1x_in_other
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_1x_in_other() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_enable_in_other

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_OTHER,
    upon receiving input EPC_SSM_LTE_TUNNELING_ENABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_ENABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_enable_in_other
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_enable_in_other() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_lte_tunneling_disable_in_other

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_OTHER,
    upon receiving input EPC_SSM_LTE_TUNNELING_DISABLE_EV

    @detail
    Called upon receipt of input EPC_SSM_LTE_TUNNELING_DISABLE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_lte_tunneling_disable_in_other
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_lte_tunneling_disable_in_other() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_sys_sm_proc_other_in_other

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_sys_sm,
    state EPC_SSM_STATE_OTHER,
    upon receiving input EPC_SSM_OTHER_EV

    @detail
    Called upon receipt of input EPC_SSM_OTHER_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_sys_sm_proc_other_in_other
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_sys_sm_proc_other_in_other() */




