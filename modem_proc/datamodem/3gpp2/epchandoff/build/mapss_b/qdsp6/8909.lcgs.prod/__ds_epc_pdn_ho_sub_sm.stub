/*!
  @file
  __ds_epc_pdn_ho_sub_sm.stub

  @brief
  This module contains the entry, exit, and transition functions
  necessary to implement the following state machines:

  @detail
  epc_pdn_ho_sub_sm ( 16 instance/s )


  OPTIONAL further detailed description of state machines
  - DELETE this section if unused.

*/

/*===========================================================================

  Copyright (c) 2017 Qualcomm Technologies Incorporated.
  All Rights Reserved
  Qualcomm Confidential and Proprietary

  Export of this technology or software is regulated by the U.S. Government.
  Diversion contrary to U.S. law prohibited.

  All ideas, data and information contained in or disclosed by
  this document are confidential and proprietary information of
  Qualcomm Technologies Incorporated and all rights therein are expressly reserved.
  By accepting this material the recipient agrees that this material
  and the information contained therein are held in confidence and in
  trust and will not be used, copied, reproduced in whole or in part,
  nor its contents revealed in any manner to others without the express
  written permission of Qualcomm Technologies Incorporated.

===========================================================================*/


/*===========================================================================

                        EDIT HISTORY FOR MODULE

This section contains comments describing changes made to the module.
Notice that changes are listed in reverse chronological order.

$Header: $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
===========================================================================*/

/*===========================================================================

                           INCLUDE FILES

===========================================================================*/

/* Include STM external API */
#include <stm2.h>

//! @todo Include necessary files here


/*===========================================================================

         STM COMPILER GENERATED PROTOTYPES AND DATA STRUCTURES

===========================================================================*/

/* Include STM compiler generated internal data structure file */
#include "__ds_epc_pdn_ho_sub_sm_int.h"

/*===========================================================================

                         LOCAL VARIABLES

===========================================================================*/


/*! @brief Structure for state-machine per-instance local variables
*/
typedef struct
{
  int   internal_var;  /*!< My internal variable */
  void *internal_ptr;  /*!< My internal pointer */
  //! @todo SM per-instance variables go here
} __ds_epc_pdn_ho_sub_sm_instance_type;

/*! @brief All variables internal to module __ds_epc_pdn_ho_sub_sm.stub
*/
typedef struct
{
  /*! My array of per-instance internal variables. */
  __ds_epc_pdn_ho_sub_sm_instance_type instance[ 16 ];
  //! @todo Other non-per-SM-instance vars go here
} __ds_epc_pdn_ho_sub_sm_type;

/*! @brief Variables internal to module __ds_epc_pdn_ho_sub_sm.stub
*/
STATIC __ds_epc_pdn_ho_sub_sm_type __ds_epc_pdn_ho_sub_sm;



/*===========================================================================

                 STATE MACHINE: epc_pdn_ho_sub_sm

===========================================================================*/

/*===========================================================================

  STATE MACHINE ENTRY FUNCTION:  epc_pdn_ho_sub_sm_init

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_pdn_ho_sub_sm

    @detail
    Called upon activation of this state machine, with optional
    user-passed payload pointer parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_init
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_init() */


/*===========================================================================

  STATE MACHINE EXIT FUNCTION:  epc_pdn_ho_sub_sm_cleanup

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_pdn_ho_sub_sm

    @detail
    Called upon deactivation of this state machine, with optional
    user-passed payload pointer parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_cleanup
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_cleanup() */


/*===========================================================================

     (State Machine: epc_pdn_ho_sub_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_PDN_HO_STATE_IDLE

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_pdn_ho_sub_sm_enter_idle

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_enter_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_enter_idle() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_pdn_ho_sub_sm_exit_idle

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_exit_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_exit_idle() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_in_idle

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE,
    upon receiving input EPC_PDN_HO_SM_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_in_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_in_idle() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_switch_ho_in_idle

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE,
    upon receiving input EPC_PDN_HO_SM_SWITCH_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SWITCH_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_switch_ho_in_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_switch_ho_in_idle() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_prereg_in_idle

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE,
    upon receiving input EPC_PDN_HO_SM_PREREG_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_PREREG_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_prereg_in_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_prereg_in_idle() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_idle

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE,
    upon receiving input EPC_PDN_HO_SM_SRAT_RCVRD_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SRAT_RCVRD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_idle() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_idle

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_idle() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_idle

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_idle() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_up_in_idle

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE,
    upon receiving input EPC_PDN_HO_IF_TRAT_UP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_UP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_up_in_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_up_in_idle() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_down_in_idle

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE,
    upon receiving input EPC_PDN_HO_IF_TRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_down_in_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_down_in_idle() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_srat_down_in_idle

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE,
    upon receiving input EPC_PDN_HO_IF_SRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_SRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_srat_down_in_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_srat_down_in_idle() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_idle

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE,
    upon receiving input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_idle() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_comp_trat_down_in_idle

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE,
    upon receiving input EPC_PDN_HO_IF_COMP_TRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_COMP_TRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_comp_trat_down_in_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_comp_trat_down_in_idle() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_comp_trat_up_in_idle

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_IDLE,
    upon receiving input EPC_PDN_HO_IF_COMP_TRAT_UP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_COMP_TRAT_UP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_comp_trat_up_in_idle
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_comp_trat_up_in_idle() */


/*===========================================================================

     (State Machine: epc_pdn_ho_sub_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_PDN_HO_STATE_HO_STARTED

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_pdn_ho_sub_sm_enter_ho_started

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_enter_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_enter_ho_started() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_pdn_ho_sub_sm_exit_ho_started

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_exit_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_exit_ho_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_in_ho_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED,
    upon receiving input EPC_PDN_HO_SM_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_in_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_in_ho_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_switch_ho_in_ho_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED,
    upon receiving input EPC_PDN_HO_SM_SWITCH_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SWITCH_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_switch_ho_in_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_switch_ho_in_ho_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_prereg_in_ho_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED,
    upon receiving input EPC_PDN_HO_SM_PREREG_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_PREREG_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_prereg_in_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_prereg_in_ho_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_ho_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED,
    upon receiving input EPC_PDN_HO_SM_SRAT_RCVRD_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SRAT_RCVRD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_ho_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_ho_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_ho_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_ho_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_ho_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_up_in_ho_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED,
    upon receiving input EPC_PDN_HO_IF_TRAT_UP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_UP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_up_in_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_up_in_ho_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_down_in_ho_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED,
    upon receiving input EPC_PDN_HO_IF_TRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_down_in_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_down_in_ho_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_srat_down_in_ho_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED,
    upon receiving input EPC_PDN_HO_IF_SRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_SRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_srat_down_in_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_srat_down_in_ho_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_ho_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED,
    upon receiving input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_ho_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_comp_trat_down_in_ho_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED,
    upon receiving input EPC_PDN_HO_IF_COMP_TRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_COMP_TRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_comp_trat_down_in_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_comp_trat_down_in_ho_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_comp_trat_up_in_ho_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_STARTED,
    upon receiving input EPC_PDN_HO_IF_COMP_TRAT_UP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_COMP_TRAT_UP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_comp_trat_up_in_ho_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_comp_trat_up_in_ho_started() */


/*===========================================================================

     (State Machine: epc_pdn_ho_sub_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_pdn_ho_sub_sm_enter_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_enter_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_enter_ho_trat_going_down() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_pdn_ho_sub_sm_exit_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_exit_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_exit_ho_trat_going_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_in_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN,
    upon receiving input EPC_PDN_HO_SM_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_in_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_in_ho_trat_going_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_switch_ho_in_trat_going_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN,
    upon receiving input EPC_PDN_HO_SM_SWITCH_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SWITCH_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_switch_ho_in_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_switch_ho_in_trat_going_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_prereg_in_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN,
    upon receiving input EPC_PDN_HO_SM_PREREG_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_PREREG_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_prereg_in_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_prereg_in_ho_trat_going_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN,
    upon receiving input EPC_PDN_HO_SM_SRAT_RCVRD_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SRAT_RCVRD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_ho_trat_going_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_ho_trat_going_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_ho_trat_going_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_up_in_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN,
    upon receiving input EPC_PDN_HO_IF_TRAT_UP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_UP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_up_in_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_up_in_ho_trat_going_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_down_in_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN,
    upon receiving input EPC_PDN_HO_IF_TRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_down_in_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_down_in_ho_trat_going_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_srat_down_in_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN,
    upon receiving input EPC_PDN_HO_IF_SRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_SRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_srat_down_in_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_srat_down_in_ho_trat_going_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN,
    upon receiving input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_ho_trat_going_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_comp_trat_down_in_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN,
    upon receiving input EPC_PDN_HO_IF_COMP_TRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_COMP_TRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_comp_trat_down_in_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_comp_trat_down_in_ho_trat_going_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_comp_trat_up_in_ho_trat_going_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_HO_TRAT_GOING_DOWN,
    upon receiving input EPC_PDN_HO_IF_COMP_TRAT_UP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_COMP_TRAT_UP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_comp_trat_up_in_ho_trat_going_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_comp_trat_up_in_ho_trat_going_down() */


/*===========================================================================

     (State Machine: epc_pdn_ho_sub_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_PDN_HO_STATE_PREREG_STARTED

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_pdn_ho_sub_sm_enter_prereg_started

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_STARTED

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_enter_prereg_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_enter_prereg_started() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_pdn_ho_sub_sm_exit_prereg_started

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_STARTED

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_exit_prereg_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_exit_prereg_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_in_prereg_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_STARTED,
    upon receiving input EPC_PDN_HO_SM_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_in_prereg_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_in_prereg_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_switch_ho_in_prereg_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_STARTED,
    upon receiving input EPC_PDN_HO_SM_SWITCH_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SWITCH_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_switch_ho_in_prereg_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_switch_ho_in_prereg_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_prereg_in_prereg_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_STARTED,
    upon receiving input EPC_PDN_HO_SM_PREREG_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_PREREG_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_prereg_in_prereg_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_prereg_in_prereg_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_prereg_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_STARTED,
    upon receiving input EPC_PDN_HO_SM_SRAT_RCVRD_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SRAT_RCVRD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_prereg_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_prereg_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_prereg_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_STARTED,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_prereg_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_prereg_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_prereg_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_STARTED,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_prereg_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_prereg_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_up_in_prereg_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_STARTED,
    upon receiving input EPC_PDN_HO_IF_TRAT_UP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_UP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_up_in_prereg_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_up_in_prereg_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_down_in_prereg_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_STARTED,
    upon receiving input EPC_PDN_HO_IF_TRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_down_in_prereg_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_down_in_prereg_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_srat_down_in_prereg_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_STARTED,
    upon receiving input EPC_PDN_HO_IF_SRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_SRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_srat_down_in_prereg_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_srat_down_in_prereg_started() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_prereg_started

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_STARTED,
    upon receiving input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_prereg_started
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_prereg_started() */


/*===========================================================================

     (State Machine: epc_pdn_ho_sub_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_PDN_HO_STATE_PREREG_COMPLETED

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_pdn_ho_sub_sm_enter_prereg_completed

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_COMPLETED

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_enter_prereg_completed
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_enter_prereg_completed() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_pdn_ho_sub_sm_exit_prereg_completed

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_COMPLETED

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_exit_prereg_completed
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_exit_prereg_completed() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_in_prereg_completed

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_COMPLETED,
    upon receiving input EPC_PDN_HO_SM_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_in_prereg_completed
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_in_prereg_completed() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_switch_ho_in_prereg_completed

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_COMPLETED,
    upon receiving input EPC_PDN_HO_SM_SWITCH_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SWITCH_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_switch_ho_in_prereg_completed
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_switch_ho_in_prereg_completed() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_prereg_in_prereg_completed

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_COMPLETED,
    upon receiving input EPC_PDN_HO_SM_PREREG_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_PREREG_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_prereg_in_prereg_completed
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_prereg_in_prereg_completed() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_prereg_completed

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_COMPLETED,
    upon receiving input EPC_PDN_HO_SM_SRAT_RCVRD_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SRAT_RCVRD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_prereg_completed
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_prereg_completed() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_prereg_completed

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_COMPLETED,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_prereg_completed
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_prereg_completed() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_prereg_completed

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_COMPLETED,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_prereg_completed
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_prereg_completed() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_up_in_prereg_completed

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_COMPLETED,
    upon receiving input EPC_PDN_HO_IF_TRAT_UP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_UP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_up_in_prereg_completed
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_up_in_prereg_completed() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_down_in_prereg_completed

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_COMPLETED,
    upon receiving input EPC_PDN_HO_IF_TRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_down_in_prereg_completed
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_down_in_prereg_completed() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_srat_down_in_prereg_completed

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_COMPLETED,
    upon receiving input EPC_PDN_HO_IF_SRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_SRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_srat_down_in_prereg_completed
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_srat_down_in_prereg_completed() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_prereg_completed

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_COMPLETED,
    upon receiving input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_prereg_completed
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_prereg_completed() */


/*===========================================================================

     (State Machine: epc_pdn_ho_sub_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_pdn_ho_sub_sm_enter_prereg_ho_waiting_rsp

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_enter_prereg_ho_waiting_rsp
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_enter_prereg_ho_waiting_rsp() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_pdn_ho_sub_sm_exit_prereg_ho_waiting_rsp

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_exit_prereg_ho_waiting_rsp
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_exit_prereg_ho_waiting_rsp() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_in_prereg_ho_waiting_rsp

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP,
    upon receiving input EPC_PDN_HO_SM_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_in_prereg_ho_waiting_rsp
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_in_prereg_ho_waiting_rsp() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_switch_ho_in_ho_waiting_rsp

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP,
    upon receiving input EPC_PDN_HO_SM_SWITCH_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SWITCH_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_switch_ho_in_ho_waiting_rsp
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_switch_ho_in_ho_waiting_rsp() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_prereg_in_prereg_ho_waiting_rsp

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP,
    upon receiving input EPC_PDN_HO_SM_PREREG_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_PREREG_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_prereg_in_prereg_ho_waiting_rsp
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_prereg_in_prereg_ho_waiting_rsp() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_prereg_ho_waiting_rsp

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP,
    upon receiving input EPC_PDN_HO_SM_SRAT_RCVRD_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SRAT_RCVRD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_prereg_ho_waiting_rsp
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_prereg_ho_waiting_rsp() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_prereg_ho_waiting_rsp

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_prereg_ho_waiting_rsp
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_prereg_ho_waiting_rsp() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_prereg_ho_waiting_rsp

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_prereg_ho_waiting_rsp
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_prereg_ho_waiting_rsp() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_up_in_prereg_ho_waiting_rsp

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP,
    upon receiving input EPC_PDN_HO_IF_TRAT_UP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_UP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_up_in_prereg_ho_waiting_rsp
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_up_in_prereg_ho_waiting_rsp() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_down_in_prereg_ho_waiting_rsp

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP,
    upon receiving input EPC_PDN_HO_IF_TRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_down_in_prereg_ho_waiting_rsp
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_down_in_prereg_ho_waiting_rsp() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_srat_down_in_prereg_ho_waiting_rsp

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP,
    upon receiving input EPC_PDN_HO_IF_SRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_SRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_srat_down_in_prereg_ho_waiting_rsp
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_srat_down_in_prereg_ho_waiting_rsp() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_prereg_ho_waiting_rsp

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_PREREG_HO_WAITING_RSP,
    upon receiving input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_prereg_ho_waiting_rsp
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_prereg_ho_waiting_rsp() */


/*===========================================================================

     (State Machine: epc_pdn_ho_sub_sm)
     STATE ENTRY/EXIT/TRANSITION FUNCTIONS: EPC_PDN_HO_STATE_SRAT_DOWN

===========================================================================*/

/*===========================================================================

  STATE ENTRY FUNCTION:  epc_pdn_ho_sub_sm_enter_srat_down

===========================================================================*/
/*!
    @brief
    Entry function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_SRAT_DOWN

    @detail
    Called upon entry into this state of the state machine, with optional
    user-passed payload pointer parameter.  The prior state of the state
    machine is also passed as the prev_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_enter_srat_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         prev_state,  /*!< Previous state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( prev_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_enter_srat_down() */


/*===========================================================================

  STATE EXIT FUNCTION:  epc_pdn_ho_sub_sm_exit_srat_down

===========================================================================*/
/*!
    @brief
    Exit function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_SRAT_DOWN

    @detail
    Called upon exit of this state of the state machine, with optional
    user-passed payload pointer parameter.  The impending state of the state
    machine is also passed as the next_state parameter.

    @return
    None

*/
/*=========================================================================*/
void epc_pdn_ho_sub_sm_exit_srat_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  stm_state_t         next_state,  /*!< Next state */
  void                *payload     /*!< Payload pointer */
)
{

  //! @todo Variable declarations go here

  STM_UNUSED( payload );
  STM_UNUSED( next_state );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

} /* epc_pdn_ho_sub_sm_exit_srat_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_in_srat_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_SRAT_DOWN,
    upon receiving input EPC_PDN_HO_SM_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_in_srat_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_in_srat_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_switch_ho_in_srat_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_SRAT_DOWN,
    upon receiving input EPC_PDN_HO_SM_SWITCH_HO_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SWITCH_HO_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_switch_ho_in_srat_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_switch_ho_in_srat_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_prereg_in_srat_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_SRAT_DOWN,
    upon receiving input EPC_PDN_HO_SM_PREREG_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_PREREG_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_prereg_in_srat_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_prereg_in_srat_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_srat_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_SRAT_DOWN,
    upon receiving input EPC_PDN_HO_SM_SRAT_RCVRD_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_SRAT_RCVRD_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_srat_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_srat_rcvrd_in_srat_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_srat_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_SRAT_DOWN,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_SUCCESS_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_srat_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_success_in_srat_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_srat_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_SRAT_DOWN,
    upon receiving input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_SM_HO_RSP_FAILURE_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_srat_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_ho_rsp_failure_in_srat_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_up_in_srat_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_SRAT_DOWN,
    upon receiving input EPC_PDN_HO_IF_TRAT_UP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_UP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_up_in_srat_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_up_in_srat_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_trat_down_in_srat_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_SRAT_DOWN,
    upon receiving input EPC_PDN_HO_IF_TRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_TRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_trat_down_in_srat_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_trat_down_in_srat_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_if_srat_down_in_srat_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_SRAT_DOWN,
    upon receiving input EPC_PDN_HO_IF_SRAT_DOWN_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_IF_SRAT_DOWN_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_if_srat_down_in_srat_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_if_srat_down_in_srat_down() */


/*===========================================================================

  TRANSITION FUNCTION:  epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_srat_down

===========================================================================*/
/*!
    @brief
    Transition function for state machine epc_pdn_ho_sub_sm,
    state EPC_PDN_HO_STATE_SRAT_DOWN,
    upon receiving input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV

    @detail
    Called upon receipt of input EPC_PDN_HO_TMR_SRAT_TMR_EXP_EV, with optional
    user-passed payload pointer.

    @return
    Returns the next state that the state machine should transition to
    upon receipt of the input.  This state must be a valid state for this
    state machine.

*/
/*=========================================================================*/
stm_state_t epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_srat_down
(
  stm_state_machine_t *sm,         /*!< State Machine instance pointer */
  void                *payload     /*!< Payload pointer */
)
{
  stm_state_t next_state = STM_SAME_STATE; /* Default 'next' state */

  //! @todo Additional variable declarations go here

  STM_UNUSED( payload );

  /*-----------------------------------------------------------------------*/

  /* Ensure that the state machine instance pointer passed is valid */
  STM_NULL_CHECK( sm );

  /*-----------------------------------------------------------------------*/

  //! @todo Code goes here

  return( next_state );

} /* epc_pdn_ho_sub_sm_proc_tmr_srat_tmr_exp_in_srat_down() */




