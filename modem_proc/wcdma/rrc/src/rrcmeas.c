/*===========================================================================
      R R C   M E A S U R E M E N T S

DESCRIPTION

  This module supports Measurement Control and Measurement Reporting
  for the RRC layer. At present, it supports the following features
  for in Idle mode and DCH state
  1. Read SIB 11 and tell L1 to setup intra-freq meas
  based on them. Tell MAC to do traffic volume meas
  2. Sends Meas Report to UTRAN in DCH state.
  3. Appends intra-freq meas report on RACH (i.e RRC Connection
  message)
  4. Supports Measurement Control Message received from UTRAN
  5. Supports Measurement Control Failure message



EXTERNALIZED FUNCTIONS


INITIALIZATION AND SEQUENCING REQUIREMENTS

  RRC Task must have been started. All RRC command queues must
  have been initialized. All RRC signals must have been cleared
  at task startup.


Copyright (c) 2002-2003, 2005-2009 Qualcomm Technologies, Inc.  All Rights Reserved.
QUALCOMM Proprietary.  Export of this technology or software is regulated
by the U.S. Government. Diversion contrary to U.S. law prohibited.

===========================================================================*/


/*===========================================================================

       EDIT HISTORY FOR MODULE

 This section contains comments describing changes made to the module.
 Notice that changes are listed in reverse chronological order.

$PVCSPath:  L:/src/asw/MSM5200/RRC/vcs/rrcmeas.c_v   1.41   19 Jul 2002 12:24:56   vkhanna  $
$Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/wcdma/rrc/src/rrcmeas.c#1 $    $DateTime: 2016/12/13 08:00:12 $ $Author: mplcsds1 $

when       who   what, where, why
11/10/16   sr      FR 38167: Changes to restrict the code to REL9 and above
--------   ---   ----------------------------------------------------------
07/05/16   sn      Changes for LTE U feature
10/28/16   sr      FR 38167: Cell Reselection from WCDMA to LTE B66 Support
05/09/16   vi      Made changes to fix qsh meas control parameters issue
06/10/16   sp      Made changes to convert ota metric msg_id to enum
06/10/16   ad      Made changes to log important parms from OTAs
06/10/16   sp      Made changes for Mav debug snapshot
06/08/16   vs      f3 density reduction changes
01/12/16   sn      Changes for FR30881
05/12/16   vs      Adding log packet for measurement related logging
05/11/16   vs      Changes to cleanup unnecessary f3s
02/23/16   vs      Chanegs to handle duplicate intraFreqCellID in measurement control message
12/03/15   vi      Made changes to avoid sending fach meas ind to WL1 in multisim mode
12/02/15   vi     Made changes to interpret QMI given value as scaling factor instead of DRX length coefficient
10/30/15   vi     Added individual NV control on M2M features
10/15/15   vi      Changes to skip idle mode measurment on QMI request
10/07/15   vi      Changes for force DRX based on QMI request 
08/24/15   sas     Made Changes to implement 3Gpp CR3382 related to multiple PLMNs list in SIB18.
03/09/15   bc    Made changes to control WTOL MFBI using LTE MFBI NV.
07/01/15   sp      Made changes to save procedure substates for LTE commands and to skip logging frequent internal commands
03/26/15   sa    Fixing the compilation error for CRM MOB
03/23/15   vi      Made changes to ignore state change indication  from IDLE to connecting to MEAS when csfb call is not going on.
02/24/15   sr      Made changes to set meas substate to idle for CSFB calls in CCM
01/21/15   sa      Made changes for QTF with CRM
11/27/14   sr      NV control for FR23776
11/10/14   sp      Made changes to save procedure substates in crash debug info
11/13/14   vi    Made changes to fix KW errors
11/11/14   vi    Made changes to not to change reporting mode when NW uses rel-9 and pre-rel9 MCM for DC-HSUPA
10/17/14   sr      CSFB call optimization changes
10/15/14   vg    Made chnages to convert Big heap variables to Globals to benefit from  qzip compression gain
09/26/14   bc    Made changes to correct compilation errors.
08/27/14   vi    Made changes to avoid equal priority for IRAT cases
08/04/14   vi    Fixed KW errors
08/04/14   vi    Made changes to avoid compiler warnings
07/26/14   vi    Made changes to include pre-redirection info in rrc connection request when all the SIB 19 earfcns are Deprioritized
07/11/14   vi    Made changes to convert earfcn type from uint16 to unti32
07/07/14   bc    Made changes to compare absolute frequencies of UARFCNs in SIB11 and SIB19
                 while filling the meas freq list to be sent to L1.
07/08/14   vi     Made changes to add NV control on meas id extn feature.
06/30/14   vi    Made changes to fill t-reselection IEs present in SIB-19 and send in absolute priority request to Wl1.
06/24/14   vi     Made changes to disable measurement id extn feature due to lack of IOT
06/17/14   bc      Made changes to check if no of elements in mfbi list are greater 
                   than the element we are trying to access.
06/10/14   vi    Made changes to keep DCHSUPA code under FEATURE_WCDMA_DC_HSUPA flag
06/09/14   vi    Made changes to access correct index while processing forbidden cell list present in SIB 11
06/03/14   vi    Made changes to set additonal measured results present flag only when additional measured results are appended. 
05/28/14   vi    Made changes to support Rel-10 periodic measurements on secondary frequency
05/28/14   vi    Made changes to append PSC remove list whenever cascading of cell needs to be done.
05/14/14   ymu   Feature name FEATURE_WCDMA_DC_HSUPA_FRAME replacement with FEATURE_WCDMA_DC_HSUPA 
05/14/14   vi    Fixed KW error.
05/06/14   geg   Use safer versions of memcpy() and memmove()
04/25/14   vi    Made changes to handle LTE deprioritization request in W-RRC
04/07/14   vi    Made changes to not to clear IRAT cell info while FACH->DCH transition 
04/02/14   vg      Made changes to Systematically log all the internal and external primitive handled in RRC and corresponding top level action.
03/10/14   bc    Made changes to access MFBI list only if LTE supports MFBI.
03/25/14   sr    Made changes to send meas action properly when MCM setup is received for a already existing meas id
03/25/14   db    Corrected validation checks in rrcmeas_process_mcm_r8/r9/r10
02/18/14   bc    Made changes to create and expose wcdma_mfbi_is_supported outside of RRC
02/06/14   sr    Made changes to not to send earfcn in SIB19 to LTE if it is not supported by UE and MFBI IE is not given
03/13/14   sr    Made changes to send meas action properly when MCM setup is received for a already existing meas id
03/11/14   vi      Replaced feature FEATURE_PLI_NMR_UTRAN with FEATURE_WCDMA
03/11/14   vi     Made changes to disable IRAT and IFREQ measurements in different states based on the NV rrc_disable_meas_nv
01/27/14   sr    Added NV control for MFBI support
01/28/14   vi    Fixed KW errors.
01/22/14   vi    Made changes to handle dch to pch state change indication if OC is not set.
01/20/14   sr    Made changes to revert dynamic memroy allocation for GPS measurements
01/07/14   vi    Modified code to configure MAC with TVM when 
                 new cell indication is posted to meas and rrccu_substate is wait for CU confirm
01/06/14   sr    Made changes to send MCF cause as "Unsupported measurement" if GSM RAT is not supported
01/03/14   sr    Added code changes for MFBI support
12/30/13   bc      Made changes to optimize REL 10 Spec CRs code
12/27/13   sr    Made changes to indicate meas action properly for secondary frequency when reporting criteria is set as NO REPORTING
12/06/13   vi    Made changes to send cell_fach_meas_ind while configuring GSM and UTRA priorities too
12/03/13   mn      Moved all declarations to top of the code.
12/03/13   sr    Made changes to initialize reporting mode for secondary frequency for periodic reporting
11/19/13   sr    Made changes to initiliaze meas id list
11/18/13   vi    Added changes to support for NMR UTRAN test spec changes
11/18/13   bc    Checked in REL 10 spec crs changes
11/07/13   sr    Made changes to not send MCF if reporting criteria for secondary frequency is missing
                 without including the primary
11/05/13   vi    Corrected MACRO for dedicated priority response
10/28/13   vi    Fixed KW errors
10/15/13   sr    Made changes to fix compilation errors
10/09/13   vi    Made changes to send dummy measurement report if additional measurements are configured with it
09/24/13   vi    Added changes for FE-FACH
09/19/13   vi    Made changes to allocate memory for cell measured results in case of sending report to GSTK
09/19/13   vi    Made changes to correctly find the arfcn in range given in gsm priority list
09/16/13   mp      Added code for REL10 signalling under feature FEATURE_WCDMA_REL10
09/13/13   vi    Added code to support DC-HSUPA measurement (Event triggered)
08/26/13   vi    Added check for RR command before assigning cmd_ptr contents
08/14/13   vg    Made changes to implement a new diag event EVENT_WCDMA_RRC_FAILURE
07/22/13   vi    Corrected the check for min meas id.
07/08/13   sn      Changes for LTE CSG feature
06/24/13   sr    Added code changes to manage More than 16 EUTRA Freqs in Pre-R11 WCDMA
06/23/13   sr    Changes to fix stack overflow with GANSS strcutures
06/07/13   vi    Replaced ALLOC_ASN1ARRAY1 with ALLOC_ASN1ARRAY2
06/05/13   vi    Fixed Compilation error for bolt
06/05/13   vi    Initialized gps_meas structure to 0 before sending to GPS
05/28/13   sr    Added code for measurement identity extension
04/25/13   sg    Added code for REL9 under FEATURE_WCDMA_REL9
03/22/13   mp    Removed tmc.h include file
01/19/13   sr    Made changes to send dummy measurement report if additional measurements are configured with it
01/03/13   ad    Made changes to reduce the redundant F3s
12/20/12   sr    Made changes to not send MCF when validation check fails for duplicate remove list
12/11/12   sr    Made changes to inherit all of the maximum possible ARFCNs during inter RAT reselections.
12/07/12   sn    CSG feature changes
11/29/12   sn    Backed out changes to send hcs_used as FALSE to L1 if SIB19 has valid priority info.
11/29/12   mp    Made chagnes to ignore meas reports for PSC lock under NV
11/12/12   gv    Fixed compiler warning
10/23/12   pm    Made changes to assign pointer to NULL after de-allocation
10/16/12   sr    Made changes to disable W2L measurements both in idle and connected mode through NV item
10/14/12   gv    Added code to support exchange of AS ID between WRRC and GRR commands
10/03/12   sr    Added changes to not delete the dedicated priorities when moving between ePLMNs
08/31/12   rd    Transfer dedicated priority parameters to/from WCDMA and GERAN
                 during IRAT procedure
07/24/12   geg   Upmerge WCDMA.MPSS.1.0 to WCDMA.MPSS.2.0
05/30/12   vg    fixed some more compilation error
05/30/12   vg    fixed a compilation error.
24/05/11   rd    Made changes to add gaurd check for modespecific tag in cell selectioninfo
04/26/12   vg    added code to set the error cause in MCF. this MCF was triggered 
                 because MEAS_REQ was  trashed by LLC in DSDS scenario.
03/08/12   as    Fixed compilation warnings
04/23/12   sn    Mainline feature FEATURE_DONT_INDICATE_STOP_HS_IN_DCH
03/15/12   pm    Fixed KW issue
03/14/12   vg    made changes to correctly fill num_cell_forbidded in the reporting criteria event list structure.
03/13/12   mp    added code to save, stop and resume TVM in state transition 
                 DCH->PCH->FACH/DCH.
07/01/11   kp    Added code to update hsdpa_hsupa_ind in connected mode
02/29/12   sks   Made changes to use RSRQ parameters from SIB19 only if LTE is Rel9.
01/23/12   sn    Changes for E-UTRA detection
12/21/11   md    Fixed compilation error
12/20/11   vg    added code to pass RSRQ based reselection criteria info to L1.
12/16/11   gv    Replaced QSR_MSG_HIGH with MSG_HIGH
12/13/11   mn    Made changes to ignore meas failure form L1
12/12/11   gv    Added code to support free floating of tasks
12/09/11   ad    Added code to log WCDMA_RRC_PROTOCOL_ERRORS packet
11/18/11   mn    Made changes to disable reselection to LTE after attach reject from network
                 with cause 14.
11/08/11   gv    Merged changes to send MEAS_REQ 1 and 2 to WL1 as part of SIB 19 removal handling.
09/02/11   vg    added code in RRC to not to send MCF if IE cellsForIntraFreqMeasList has cell_id
                 which doesnt exist in rrc cell list db
08/26/11   rl    Fixed the KW error
08/12/11   vg    added code to set the qualmin,rxlevmin deafault values from serving cell
                 SIB3/4 if SIB19 doesnt utra cells doesnt have these values
07/18/11   rl    Merged with VU_MODEM_WCDMA_RRC.01.102.00
07/05/11   vg    added code to fix r8 MCM gps type handling issue. 
08/29/11   sks   Made changes to not send EUTRA priority-cell list to L1.
06/21/11   rl    Merged with VU_MODEM_WCDMA_RRC.01.100.50
06/16/11   sks   Fixed compilation error when FEATURE_WCDMA_ABSOLUTE_PRIORITY is not defined.
06/15/11   vg    Made changes to send hcs_used as FALSE to L1 if SIB19 has valid priority info.
06/09/11   vg    fixed a bug in mac_ack handling.
06/13/11   vg    changes to not reject MCM with additional meas entry which has the same 
                 meas type as the primary measurement.
05/23/11   sks   Made changes to not prune LTE-TDD neighbours when sending neighbour list to WL1.
05/20/11   rl    Fixed few more coding bugs
05/20/11   rl    Fixed the coding bug
05/17/11   rl    Fixed coding review comments
05/16/11   vg    fixed some coding bugs. 
05/06/11   sks   Made changes to access Rel5 pointer only if its not NULL.
05/03/11   rl    Fixed the lint error
04/27/11   vg    made changes to fix SIB19 GSM priority list population issue.
04/27/11   vg    made changes to fix SIB19 utra priority list population issue.
04/26/11   rl    Support for transition from TMC heap to Modem Heap in WCDMA.
04/26/11   rl    Fixed the compilation error
04/25/11   vg    made changes to handle R3 MCM-relese of type EUTRA.
04/25/11   rl    Fixed the KW error
04/18/11   vg    made changes to fix rrcmeas_fill_intra_freq_event_criteria list
                 processing issue on receivng MCM.
04/14/11   sks   Made changes to not send EUTRA freq list to L1 when UE is camped
                 for limited service.
03/31/11   rl    Added the conditional check to ignore doing reset of the 
                 element if the memory is not allocated.
03/17/11   sks   Made changes to ignore LTE-TDD cells, when sending measurement req to L1.
03/14/11   rl    Merged with VU_MODEM_WCDMA_RRC.01.93.50
03/06/11   vg    added code to handle l1 meas report of type L1_INTER_SYS_EUTRA
03/09/11   rl    Fixed the asn1 array memory allocation issue found 
                 during testing
02/10/11   rl    Merged with VU_MODEM_WCDMA_RRC.01.90.51
02/08/11   rl    Fixed the compilation warnings
02/07/11   rl    Merged with VU_MODEM_WCDMA_RRC.01.90.50
01/27/11   rm    Added code to support WCDMA to LTE events
01/28/11   rl    Merged with VU_MODEM_WCDMA_RRC.01.89.57
01/23/11   sk    Fixed one missing line in prev checkin
01/23/11   sk    Fixed compilation error when deferred sib and reduced command feature
                 are defined together.
01/18/11   rm    Made changes to ignore TVM reports when OC is set for PCH and UE 
                 is not waiting for L2 ACK
01/12/11   ad    Added changes for RRC SW decoupling
01/04/11   rl    Merged with VU_MODEM_WCDMA_RRC.01.87.50
12/13/10   rm    Made changes to check for mandatory IEs from IntraFreq MCM setup
12/31/10   rl    Merged with VU_MODEM_WCDMA_RRC.01.86.50
12/07/10   ss    Fixed compilation error
11/09/10   rl    Merged with VU_MODEM_WCDMA_RRC.01.84.50
11/02/10   rm    Fixed lint error
11/02/10   rm    Added code to support W2L measurements in DCH state
10/29/10   su    Made changes to remove WCDMA_TASKLOCK() usage from RRC code base.
10/20/10   rm    Added code to not configure WL1 with unsupported EUTRA frequency
10/11/10   ss    ASN.1 migration to ASN1 9.3.0
10/11/10   ss    Upgraded SIB11Bis code to ASN 8.a and added code to init sibs lookup table 
                 after initialization of rrc_nv_rel_indicator.
09/27/10   rm    Made changes to configure WL1 with SIB19 Absol Pri on UMI clearing dedicated
                 priorities.
11/03/10   rl       Fixed compiler warnings
10/30/10   rl    Objective systems migration changes check in 
                 on code base VU_MODEM_WCDMA_RRC.01.80.00
09/09/10   rm    Made changes to hold dedicated priorities during OOS
09/07/10   rm    Made changes to parse blacklisted cell list from SIB19 correctly
09/01/10   rm    Fixed lint errors
08/30/10   sks   Fixed KW error.
08/25/10   sks   Fixed KW errors.
08/11/10   rm    Made changes to handle SIB19 change, to send absolute priority
                 and LTE neighbor info to L1 during DCH->FACH and FACH->PCH transitions
07/24/10   kp    Bug fix in rrcmeas_process_state_change_ind_in_dch_state
                 for cell fach to pass correct sib type(SIB11) for getting SIB ptr.  
07/19/10   rm    When freeing dynamic ptrs, made changes to not error fatal 
                 if the ptrs are NULL
07/15/10   rm    Made changes to correctly populate dedicated priorities from OTA 
07/12/10   rm    Added Debug F3s for IRAT dedicated priorities
07/09/10   rm    Fixed compiler warnings
07/08/10   rm    Changed usage of MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL to 
                 MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT
07/05/10   rm    Fixed compiler warnings
07/02/10   rm    Added F3s for Absolute priority IE's parsing
06/29/10   rm    Added code to support LTE<->WCDMA Inter RAT
06/29/10   rm    Made changes for ZI memory optimization
05/20/10   rm    Made changes to return FALSE from rrcmeas_get_cell_plmn_info
                 when UE is not camped
05/03/10   rm    Made changes to not send MCM failure for MCM which is releasing a
                 nonexistent measurement
04/07/10   gkg   ASN.1 migration to 8.a.0
03/12/10   dm    Added code for supporting Deferred SIB reading feature.
03/12/10   rm    Added code to support FEATURE_DUAL_SIM
02/18/10   dm    Made changes to not process state change indication if ordered_config_ptr 
                 or current_config_ptr is NULL.
01/27/10   rm      Made changes to not process InterFreq/InterRAT measurements when feature
                   FEATURE_WCDMA_INTER_FREQ_NOT_SUPPORTED is defined
12/17/09   rm      Fixed compilation warning when FEATURE_DONT_INDICATE_STOP_HS_IN_DCH is defined
11/12/09   rm      Added code to send the correct failure cause in MCM failure to N/W if MAC
                   rejects the MCM command, when FEATURE MEAS TRID ENHNC is defined
11/05/09   rm      Made changes to ignore the removal of cell id which is not present at UE and
                   continue processing the MCM 
10/26/09   rm      Fixed Klockwork errors
10/07/09   gkg     Changes for REL8 under FEATURE_WCDMA_REL8
09/11/09   ps    Made changes for reducing the internal RRC command size 
                 under FEATURE_RRC_REDUCE_CMD_SIZE
09/14/09   ss    Fixed lint warnings generated by Static Analysis tool
07/20/09   rm    Added code to not call sys_eplmn_list_equivalent_plmn when n/w sel mode is
                 LIMITED
07/14/09   rm    Added code to provide LAC info along with plmn_cell_info to GPS
06/29/09   rm    Added code to send MCM failure with cause rrc_unsupportedMeasurement_chosen to N/W
                 when L1 fails MCM with cause UNSUPPORTED_MEASUREMENT
05/11/09   rm    Made changes to send cell capability info whenever RRC sends 
                 a MM cmd.
05/08/09   ss    Updated Copyright Information
02/16/09   rm    Made changes to set process_interfreq_interrat_meas_rel7 to TRUE
01/19/08   ps    Made changes for ASn1 migration 25.331v7.9  
                 i.e.May 2008 version  (2008-05) 
12/29/08   rm    Added support for 3G<->GAN Handover
11/21/08   rm    Made changes to unblock confguring L1 with Inter Frequency and Internal measurements.
                 Changes are under FEATURE_WCDMA_REL7
11/10/08   rm    Made changes to process Rel7 measurement control messages for 
                 InterRAT, Traffic, Quality and Internal measurements
16/10/08   rm      Made changes to process internal measurements from MCM at RRC
                   and blocked sending meas req to L1, Changes are for FEATURE_WCDMA_REL7
10/13/08   rm      Merged changes for FEATURE MEAS TRID ENHNC for Rel7
10/08/08   rm      Made changes to skip sending InterFreq and Inter RAT measurements configured by SIB11, SIB12 and MCM to L1
                   Changes are under FEATURE_WCDMA_REL7
09/12/08   ps      Added code for REl7 under FEATURE_WCDMA_REL7
09/04/08   cnp     Replaced intlock/free with wcdma_intlock/free.
           cnp     Replaced tasklock/free with wcdma_tasklock/free.
           cnp     Replaced intlock/free_sav with wcdma_intlock/free_sav.
09/04/08   rm    Made changes to not send MCM failure for MCM which is releasing a 
                 nonexistent measurement
07/16/08   rm    Enhanced the handling of transaction id received in MCM message so that
                 UE accepts the MCM's with same transaction id and in case of failure UE
                 sends MCM failure for a transaction id only if it is latest among the same
                 transactions ids
06/30/08   ns    Made the necessary changes to enable the functionality of the feature 
                 FEATURE NETWORK SHARING only when the GCF NV is set
06/11/08   rm    Fixed Lint Errors
06/09/08   rm    Made changes to send only maximum pending reports in FACH state
                 while sending TVM report
03/27/08   da    Made change to call TASK_FREE() immediatly after 
				 l1_get_utran_nmr_info() returns.
03/14/08   ps    Made changes under FEATURE_DONT_INDICATE_STOP_HS_IN_DCH, to
                 stop inidcating that HS is unsupported once in Cell DCH to 
                 UI. 
03/10/08   rm    Added support for SIB11bis. Code changes are under feature flag 
                 FEATURE SIB11BIS SUPPORT  
02/07/07   da    Added support for FEATURE_PLI_NMR_UTRAN
12/27/07   rm    Added a MSG_HIGH when ignoring the measurement indication form L1
                 in FACH state
10/23/07   pk      Added support for network sharing feature.Changes are under feature flag 
                   FEATURE NETWORK SHARING.
10/22/07   rm    Made Changes to Indicate L1 to Save Inter Frequency measurements
                 during DCH to PCH Transition
10/08/07    da   Added change to accept\reject configurations that enable HSUPA
                 and CM based on HSUPA_CM NV item setting.
09/07/07   vm    Added support for feature FEATURE_RRC_CALLOC
08/31/07   rm    Calling the function srchmeas_set_inter_freq_measdb_status_during_state_transition
                 with the modified prototype
07/17/07   rm/vg Added support for FEATURE_WCDMA_INTER_FREQ_RACH_REPORTING feature.
07/13/07   da    Added support for HSPA call status indication.
06/26/07   rm    Added code to clear the inter frequency cell list when 
                 cell selection or reselection happens in Cell PCH or
                 URA PCH State
05/25/07   vg      added support for FEATURE_CGPS and FEATURE_CGPS_UMTS_CP_WCDMA.
05/16/07   vg    added EVENT 1J support under FEATURE WCDMA HSUPA feature flag.
04/20/07   da    Made changes needed to update ASN.1 version to R6 sept R6 2006
03/19/07   vg    Added support for feature FEATURE_WCDMA_CNT_C_SFN_DIFF.
03/13/07   vg    set cm_status_incl to false to avoid the L1 CM validation
                 checking if it in internal meas release.
02/26/07   sm    Added code to reject EUL+CM configuration for early R6 UEs
02/13/07   sgk   Added function call rrcllc_update_cm_params while saving 
                 L1 measurements on DCH->FACH transition. 
02/05/07   sgk   Moved rrcmeas_rach_report_ptr null check to the begining of 
                 the function to avoid possible dereference of null pointer. 
02/02/07   vm    Stability Opt: Removed freeing of already allocated memory
                 before hitting EF. This is to get the "correct" snapshot
                 of the heap instead of a "stale" one.  
12/21/06   sgk   made changes to reject empty event list only for setup in 
                 intra frequency measurements. 
11/30/06   sm    Modified code to generalize HSDPA cell indicator code to support
                 E-DCH cell indicator
11/02/06   vg    removed FEATURE_WCDMA_PATHLOSS feature flag
10/31/06   sgk   removed the inclusion of l1m.h in rrcmeas.c 
10/09/06   vg    made changes for MCM modify additinal meas handling
10/04/06   vg    Fixed MCF transection id problem which was causing ASN1 failure.
09/27/06   sgk   Fixed 7200 compiler warnings.  
09/25/06   kp    Added support for sib_change_ind interface change
09/11/06   sgk   Added rel6 measurement support and code optimization across
                 releases. 
09/05/06   vg    modified code for MCF error cause if additinal meas is not configured
08/29/06   sm/da Made changes required for R6 ASN.1 migration.  Also merged
                 FEATURE_WCDMA_REL6 and FEATURE WCDMA HSUPA.
08/28/06   vg    added code for R5 IE "IRAT cell info ind" support under feature 
                 FEATURE IRAT CELL INFO IND
08/22/06   sgk   Added code to save the inter frequency measurements in
                 addition to the intra frequency measurements on transition 
                 from DCH to FACH. Modifed the function name from 
                 rrcmeas_save_intra_freq_meas to
                 rrcmeas_save_intra_inter_freq_meas.  
08/16/06   vg    removed wrong initialisation comment of mcm_own flag.
08/16/06   vg    added MCF failure cause according to spec.
07/31/06   sgk   Added change to initialize the SIB12 present flag prior to
                 idle reselection.
                 Added change to process SIB 11 TVM information if present
                 on IDLE->DCH and IDLE->FACH transition when SIB12 is present
                 but does not have the TVM information.
07/26/06   vg    changed Additinal meas handling for CR97229.
07/07/06   sgk   Used function calls l1m_state_is_fach() and l1m_is_connected()
                 to check for L1 states DCH and FACH instead of the L1 enum
                 values L1M_FACH and L1M_DCH.
06/15/06   vk    Declared external variable hsdpa_hsupa_ind that stores the
                 global status of HSDPA availability in a cell. On cell
                 re-selection as well as state transition, update the global
                 hsdpa indication status of the cell and send a cmd to MM
                 when HSDPA Capability of the cell changes
06/15/06   sgk   Corrected initialization of meas_can_be_reported parameter
                 in the measurement id list.
06/07/06   vg    revert back the SIB_CHANGE_IND changes in PCH and FACH
06/05/06   sgk   Made changes to include rel5 non HSDPA functionality under
                 FEATURE REL5 while retaining the HSDPA specifc processing
                 under FEATURE HSDPA.
05/22/06   vg    added code for saving meas if configured by MCM on SIB_CHANGE_IND
                 in FACH and PCH state.put extra check to ignore SIB_CHANGE_IND
                 if FACH->DCH in progress.
05/11/06   sgk   Added code to support lsm PCH reporting.
                 Added new cmds to indicate to lsm to change their reporting
                 interval to 64s on entry to PCH and to restore the original
                 interval on transition from PCH to FACH.
05/10/06   vg    fixed lint error
05/09/06   vg    removed compilation warning
05/02/06   vg    Added single to dual mode changes.
04/28/06   sgk   Added code fix error in rel 5 extensions check in rel 5
                 MCM modify.
04/20/06   vk    Changed the type of global variable hsdpa_cm_enabled from
                 boolean to uint8
04/18/06   vk    Used global variable hsdpa_cm_enabled value to determine if
                 network is trying to activate CM when HSDPA is already ACTIVE
04/18/06   da    Modified code to support migration to Mar-06 Rel-5 ASN1 +
                 R6 Hacks
04/07/06   sgk   Added code to use the value from useCIO from the event 1d
                 extensions when cio included is set to true.
                 Fixed lint errors.
03/22/06   sgk   Added code to check if SIB12 and SIB18 are absent and there
                 is no inter rat info in SIB11 and if so not send the meas
                 req to L1 for intra freq and inter rat on IDLE->DCH
                 transition.
03/15/06   vg    fixed lint warnings
03/10/06   sgk   Added code to send the cell param req to L1 on FACH->PCH and
                 PCH->FACH if the sib4 extensions for qhyst and t reselection
                 is present.
02/28/06  da/sm  Modified code to support migration to Dec-05 Rel-6 ASN1
02/07/05    sgk  Added check if rcr is active to ignore the report before
                 sending the traffic volume measurement report in FACH.
01/25/06   bd    Lint clean-up
12/02/05   sgk   Added extra checks to validate if there are cell measured
                 results present before including them in the report.
11/28/05   vg  added extra check for additional measurement id present in RRC
         meas DB for all type of primary measurement.
11/15/05   sgk   Initialised meas_id to INVALID_MEAS_ID in function
                 rrcmeas_set_additional_meas_in_db.
11/14/05   sgk   Added rrc_nv_rel_indicator check before validating delta rscp
                 in the report.
11/10/05   sgk   Added rrc_nv_rel_indicator check before adding the extensions
                 for measured results.
                 Added rrc_nv_rel_indicator check before adding the extensions
                 for the measurement report.
                 Added check for rrc_nv_rel_indicator to be equal to
                 RRC_NV_REL_INDICATOR_REL5 before processing the rel 5 ies.
                 Code changes to satisfy lint.
10/27/05   sgk   Corrected issue in adding additional intra freq results when
                 rel5 is turned on.
10/21/05   sgk   Added rel5 support for the processing of delta rscp, delta
                 qhcs and delta qrxlevmin. Delta rscp is used in the evaluation
                 of events 1e and 1f.
10/04/05   vk    1. When transition to FACH is triggered by a RL Failure or by
                 Reconfiguration Msg that does not specify the new Cell Info
                 or by UE camping on its own in CELL_FACH, then use a single
                 meas command to indicate to L1 to delete all InterFreq/IntraFreq
                 measurements
                 2. Added pos_meas_failure variable to check if Pos Meas failure
                 is because of OTDOA/Cell Id. If yes, then send measurement
                 control failure message with cause as "incomplete configuration"
09/14/05   vk    Featurized the last change under FEATURE HSDPA
09/14/05   vk    Do not store the Transaction Table for AGPS Rel 99 Meas
                 Control Message
09/06/05   sgk   Added change to honor periodic report from L1 with no cell
                 measured results.
09/02/05   sgk   Modifed the error cause of the MCM failure from unsupported
                 measurement to invalid configuration when a MCM modify is
                 given for a measurement that has not been setup.
08/26/05   sgk   Added code to cover scenario where the remove cell list IE
                 of sib12 is absent when building the composite list from
                 Sib11 and Sib12.
08/25/05   vk    Featurized the code for rejecting CM Activation when HSDPA is already
                 active under FEATURE_RRC_ENABLE_CM_HSDPA
08/19/05   sgk   Corrected the qhcs calculation for ecn0.
08/15/05   sgk   Added code to check if the PLMN from SIB18 is the selected
                 PLMN, and if so allow the cell for reselection, instead of
                 calling the nas function to check if it belongs to the
                 equivalent list.
08/12/05   vk    Re-Added check to reject CM activation if HSDPA is
                 already ACTIVE
08/05/05   sgk   Added code to exclude the monitored cell results from the rach
                 report if requested by the calling procedure by explicitly setting
                 the flag exclude_monitored_cell_results when calling func
                 rrcmeas_append_meas_rpt_on_rach()
09/01/05   vk    Removed the check to reject the Measurement Control Message
                 if the message tries to activate Compressed Mode and HSDPA
                 is Active. The check is not required now as the complete
                 support for Compressed Mode with HSDPA is now ready and
                 would be activated in mainline builds
08/21/05   vk    Changed some MSG_HIGH to MSG_MED as during HSDPA testing, lot
                 of F3 messages are getting dropped. This is part of the
                 overall effort to reduce un-necessary F3 messages
08/19/05   sgk   Added support for event 1b and event 1d non critical
                 extensions in sib 11 and 12.
07/13/05   sgk   Added rel5 non critical extensions for rel 99 MCM ie the
                 transaction identifier extension and the extensions for
                 event 1b and 1d.
07/08/05   sgk   Featurized declaration of rrc_meas_params_struct_type with
                 feature FEATURE_MMGPS in function
                 rrcmeas_check_meas_id_used_for_different_meas_type.
07/08/05   sgk   Added new function rrcmeas_check_meas_id_used_for_different_meas_type
                 that checks if there is already another measurement with
                 the same measurement id as the new measurement but of a
                 different type and if so sends a release to l1 for the
                 earlier measurement.
07/07/05   vk    Corrected the use of Measurement type for Release 5 Intra Freq
                 Meas Control Message
07/05/05   sgk   Made changes to pick up Fach measurement occasion from SIB11
                 if not present in SIB12.
06/30/05   vk    On getting the new Measurement Control Message for Release 5
                 intra freq measurements, made sure that the accepted transaction
                 table is updated only once for Intra Freq Measurements and L1 gets
                 configured from cummulative Rel 5 transaction identifier
06/27/05   sgk   Added basic rel 5 measurement ctrl msg support.
06/23/05   sgk   Mapped default QHCS values based on RCSP and ECN0.
                 Fixed lint errors.
06/07/05   sgk   Rolled back the check to turn off sib18 if the selected
                 PLMN at rrc is not the same as the one in NAS. SIB18 will
                 be applied even in this case, to block cells for reselection
                 based on the NAS equivalent PLMN list.
06/03/05   vk    If FEATURE HSDPA is defined, then set cio and event triggering
                 condition for Event 1D to FALSE. Also used INTRA_FREQ instead
                 of L1_MEAS
06/01/05   vk    Put code to initialize transaction identifier to 0 while
                 sending measurement control failure under FEATURE HSDPA
05/20/05   vk    Added the fix of setting the tr identifier extension in
                 Meas Ctrl Failure Message under FEATURE HSDPA
05/18/05   vk    Merged the fix to use the Release 5 Transaction Id only
                 if the Transaction Identifier extension is not present in
                 Release 5 message
05/03/05   vk    Add code to process Release 5 Traffic Volume Meas Ctrl Msg.
                 Reject CM Activation if HSDPA is active
05/09/05   sgk   Added rel 5 fixes for choice rrc_hcs_used_chosen.
05/04/05   sgk   Added hcs_used flag in the l1 state transition params
                 structure.
                 Added code to limit the max nuber of monitored cells in
                 measured results on RACH to 1 when appended to a CCCH message.
04/25/05   sgk   Made changes in function rrcmeas_append_meas_rpt_on_rach to
                 exclude the active cell information in the monittored set.
                 Also modified the fucntion to look at the rach rpt critieria
                 stored in RRC instead of the value from L1.
04/22/05   sgk   Added hcs_used flag initialization in the clear sib11 to FALSE.
04/21/05   sgk   Added additional check to verifiy if the number of additional
                 measured results is 0 and not append the results in this
                 case.
04/21/05   sgk   Added HCS related fixes.
04/20/05   sgk   Added support for RRC_EQ_PLMN_LIST_CHANGE_IND handling in
                 FACH and PCH states.
                 Added blocking of SIB18 processing when the registerd PLMN
                 != selected PLMN.
04/15/05   sgk   Added ASN1 Rel 5 support for HCS.
04/07/05   sgk   Added HCS support.
04/06/05   sgk   Removed sending of Failure in SIB11 if measurement substate
                 is dch to support reprocessing of SIB11 on IDLE->DCH
                 transition.
04/05/05   vk    Added code to indicate to LSM if L2 ACK has been received
                 for A-GPS Report under FEATURE_AAGPS_MR_RRC_NOTIFICATION_REQUIRED
04/01/05   sgk   Added Code to block SIB18 processing in true limited service.
                 Added SIB Change indication support for SIB 18.
                 Added reprocessing of SIB11 with connected mode SIB18 list
                 on IDLE->DCH and IDLE->FACH.
03/30/05   vk    While processing the compressed mode status information, stamp
                 the sdu time to indicate to L1 the time at which SDU was rcvd
                 under FEATURE_DETECT_MISSED_ACT_TIME
03/28/05   sgk   Added change to measurement optimization to depend on RLC
                 NACKs to decrement the pending measurment report counter.
                 Added function to initialize the transaction id list in
                 initial state and on transition to IDLE.
03/18/05   vk    Merged HSDPA code in Mainline from RRC_MSM6275 branch under FEATURE HSDPA.
                 Contains partial support for Intra Freq Rel 5 MCM
03/15/05   sgk   Added measurement optimization to restrict max pending ack
                 mode measurement rpts to 12.
03/09/05   sgk   Added RRC ASN1 Release 5 support for Qulaity measurements.
                 Lint fixes.
03/07/05   sgk   Added SIB18 support for idle and connected mode intra freq
                 measurements.
03/04/05   sgk   Added Quality measurement Support.
03/02/05   ttl   Support RRC ASN1 Release 5.
02/17/05   sgk   Modified fix for appending rrc_UE_RX_TX_ReportEntryList
02/17/05   sgk   Added dual mode enabled check before processing MCM for
                 inter rat measurements and sent a MCM failure if dual
                 mode is not supported.
02/16/05   vk    Included l1m.h
02/15/05   vk    While appending RACH results, check if L1M state is FACH
02/14/05   vk    Before appending additional measured results, check if the
                 L1M state is DCH
01/27/05   sgk   Added appending of the rrc_UE_RX_TX_ReportEntryList if
                 present to the internal measurement results in function
                 rrcmeas_append_internal_meas_results.
01/12/05   sgk   Added initialization of inter rat and inter freq cell list
                 in functions rrcmeas_process_initial_state and
                 rrcmeas_process_cell_fach_state on receiving
                 RRC_CELL_SELECTED_MEAS_REQ.
                 Added updation of intra frequency measurement identity list
                 in the case where the Intra freq meas info was not present
                 in SIB12 but present in SIB 11.
01/10/05   sgk   Modified function rrcmeas_append_meas_rpt_on_rach to take
                 procedure id as the second parameter, made additional checks
                 in the procedure to return RRCMEAS_RACH_FAILURE to block
                 rach reporting if oc_status is OC_SET_FOR_CELL_DCH or
                 rrc_ccm_get_curr_camping_status function returns
                 RRC_NOT_CAMPED_ON.
12/14/04   sgk   Added fix to return sib11_rach_rpt_crit instead of
                 sib12_rach_rpt_crit in pch and fach if sib12 not present
                 in function rrcmeas_check_for_rach_reporting.
12/11/04   sgk   Made intra_freq_sib12_new_cell_list a global variable to fix
                 stack over flow problem.
12/08/04   sgk   Fixed compiler warnings.
12/02/04   sgk   Lint fixes for SIB12 support.
                 Added check for rrcmeas_current_substate != RRCMEAS_IDLE
                 before using sib12 for rach reporting in function
                 rrcmeas_get_rach_rpt_quantity.
11/23/04   vk    Ignore cell selected meas req in idle substate if G->W HO
                 is in progress
11/23/04   sgk   Added initial SIB12 Intra frequency support.
11/18/04   vk    Removed variable local_cells_for_meas & code associated with
                 it as it is no longer required. Featurized internal meas use
                 with FEATURE_CM_FOR_INTER_FREQUENCY_MEASUREMENTS.
                 Also removed the additional meas check for event triggered Internal Meas
10/28/04   vk    Ignore sending Meas Req to L1 if HO to UTRAN is in progress
10/15/04   vk    Process MCM that indicates that validity of measurement is
                 different from the state in which it is received by indicating
                 to LSM to not start the measurements. RRC then indicates to LSM
                 later when the measurement is valid to resume the measurement
09/28/04   sgk   Added check for measurement identity, if value is < 1 or >16
                 send MCF in function rrcmeas_read_mcm_measurements.
09/24/04   vk    Added change to indicate to L1 the new measurement parameters
                 based on the changed SIB11
09/16/04   sgk   Corrected range check for primaryCPICH_TX_Power to include
                 boundary values -10 and 50 as valid, in
                 function rrcmeas_path_loss_check.
09/08/04   vk    Removed looking at measurement quantity value while encoding
                 additional intra freq measurement report as it is no longer set by L1
09/02/04   vk    Invoked DCH->FACH handler and FACH->DCH handler on DCH<->FACH
                 transitions
08/30/04   sgk   Removed parameter meas_type_setup_incl from function
                 rrcmeas_process_pos_mcm to fix lint error 'unreferenced',
                 corected it in the location where the function was being
                 called
                 Returned returned RRCMEAS_FAIL instead of return in function
                 'rrcmeas_fill_common_mcm_intra_f_info' to fix lint error
                 function should return a value.
08/25/04   vk    Used inter freq global variable to always send inter freq
                 cells to L1 on DCH->FACH transition
08/19/04   vk    Fixed merge problem for the last checkin
08/17/04   vk    Cahnged feature name from FEATURE_PATH_LOSS to FEATURE_WCDMA_PATHLOSS
08/16/04   vk    Added code to support path loss measurements under FEATURE_PATH_LOSS
08/09/04   vk    Set FACH Meas Occassion Info also in another boolean variable
                 for state transition command
08/02/04   vk    In rrcmeas_process_pos_mcm fn, added the check to find if the
                 command is a RELEASE, so that MCM released is processed successfully
07/26/04   vk    Made changes as per March 04 ASN1
07/16/04   vk    Do not pass neighbour cells to L1 when SIB11 changes either in
                 sub state Idle, FACH or PCH of the measurements procedure
07/15/04   vk    Ignore Meas Report if RCR is active
07/08/04   vk    If transaction identitifer for MCM is not stored in accepted
                 transaction table because of no space available, then return
                 so that incorrect Meas Ctrl Failure is not sent
07/02/04   vk    Ignore Meas Ctrl Msg for Intra Freq/Inter Freq/Inter RAT
                 UE Internal Meas when DCH-->FACH/PCH trans is in progress
06/30/04   vk    Corrected setting of measurement identity in Measurement
                 identity variable
06/25/04   vk    Send GSM neighbours to L1 even if FACH meas Info is absent
                 on DCH->FACH trans
06/21/04   vk    Invoke rrcllc_initialize_cm_parms() to initialize
                 compressed mode params in transition config and invoked it
                 on new cell ind in CELL_FACH/PCH and also when CM patterns need
                 to be deleted when DCH->FACH/PCH trans take place
06/10/04   vk    Changed name of fn rrcmeas_get_cell_id_plmn_info to
                 rrcmeas_get_cell_plmn_info
06/07/04   vk    Added feature def FEATURE_MMGPS to rrcmeas_set_cell_plmn_info
                 and other fns as cell id fn and structure were moved to rrclsmif.h
06/04/04   vk    Defined new global structure plmn_cell_info that stores the cell
                 id, plmn id, psc and freq for LSM. Also implemented new fn
                 rrcmeas_set_cell_plmn_info to set cell and plmn info on getting new cell
                 indication. Removed the check if network tries to do setup more than
                 one positioning meas and allow LSM to do this
06/02/04   vk    By default, initialized measurement validity in measurement identity
                 variable to NOT_PRESENT instead of CELL_DCH. Modified code to process
                 measurement validity. Now if validity is not specified in MCM,
                 RRC deletes the measurement on state trans to FACH  or PCH
05/17/04   vk    Registered for SIB11/12 change notification in CELL_FACH. Also
                 invoked the fn rrctvm_process_sib_change_notification() to process
                 changed SIB 11/12
05/12/04   vk    Used global structure l1_fach_inter_freq_parms instead of a
                 local structure under FEATURE INTER FREQUENCY CELL_FACH RE SELECTION
05/12/04   vk    Support to send Inter Freq cell list to L1 in CELL_FACH state of RRC
                 under FEATURE INTER FREQUENCY CELL FACH RE SELECTION
04/21/04   vk    Implemented new fn rrcmeas_get_rach_rpt_quantity to get RACH quantity
04/20/04   vk    Added SIB4 support
04/13/04   vk    Used the correct value to compare if the validation of
                 intra freq meas report failed
04/06/04   vk    Merged the optimzation done to ignore the duplicate Meas
                 Ctrl Msg from Cheetah to Saber
03/26/04   vk    Consider new cell ind in CELL_DCH state to be transition
                 to PCH state if ordered config variable indicates that
                 DCH->PCH transition is in progress. Also merged the
                 inter rat fix done for CELL_FACH state for PCH state
                 Implemented rrcmeas_get_fach_meas_info() info to get FACH Meas
                 Info from SIB11. Also removed some LINT errors
03/11/04   ttl   Defined inter_rat_meas_to_be_deleted_from_addtl_db[] for
                 compiling fix.
02/26/04   vk    Removed redundant case statement from rrcmeas_read_sib11
02/06/04   vk    Added CELL_PCH support under FEATURE_CELLPCH_URAPCH
02/03/04   vk    Cleared Internal Meas variable on transition from CELL_DCH
02/02/04   vk    Added A-GPS support under FEATURE_MMGPS
01/21/04   vk    Added checking of meas identity from UE Internal Meas DB
                 when a MCM with a modify and no type is sent
01/12/04   vk    While processing additional Meas, now parse Inter freq
                 cells list ptr instead of the static cell list for a particular
                 freq
12/19/03   vk    After doing DCH->FACH transition, send a state transition cmd
                 for configuring inter rat cell list instead of sending a meas
                 request from SIB11
12/18/03   vk    Corrected appending of more than one additional measurements to
                 a measurement report. Lock the task before calling l1 fn to
                 append measurements
12/16/03   bu    Added GSM Quadband support.
12/10/03   vk    Added code to support INTER RAT cell reselection in CELL_FACH under
                 FEATURE INTER RAT CELL FACH RE SELECTION.
12/03/03   vk    Before appending inter freq measurements, make sure if inter freq additional
                 measured results are available. This covers a condition when L1
                 indicates to RRC that additional measured results are available
                 but within that it indicates that inter freq results are unavailable.
                 Also, added change to ignore sending Intra Freq/Inter Freq/Inter RAT/
                 UE Internal measurement report when DCH->FACH transition is in progress
11/18/03   vk    Removed the process of doing a cell update when RLC indicates
                 that transmission for Measurement Report/Meas Ctrl Failure
                 failed
11/13/03   vk    Removed SIB12 criteria for RACH reporting in CELL_FACH
11/07/03   vk    Implemented function rrcmeas_check_mcm_for_setup_modify_additional(..)
                 that deletes Additional Measurements in case the
                 same primary measurement is specified with setup. Also added check
                 to send Meas Ctrl Failure in case no of Additional Measurements for
                 a particular measurement is more than the maximum allowed
11/06/03   vk    Added support for UE Internal Meas and Inter Freq
                 Measurements under FEATURE_CM_FOR_INTER_FREQUENCY_MEASUREMENTS
10/08/03   vk    Added support for Inter Freq Measurements. Cell reselection part is
                 featurized under FEATURE_CM_FOR_INTER_FREQUENCY_MEASUREMENTS
08/12/03   vk    Set active set measured values in monitored set only
                 when reporting on RACH is configured to a value that is
                 other than the serving cell. Remove the code which sets active
                 set measured values in monitored set irrespective of the no
                 of the cells specified
08/05/03   vk    While sending Event Triggered Measurement Report, set both RSCP
                 and Ec/Io measured value if present
07/23/03   vk    Added support to read intra freq cells in case HCS is set to TRUE
06/17/03   vk    While processing the periodic measured results, corrected
                 the initialisation of a local variable so that un-necessary
                 messages that may confuse the user are not printed
06/13/03   vk    Fixed an error in last check in
06/13/03   vk    Moved the code to check if the L1 has deleted the measurement
                 inside the periodic measurement report handling
06/03/03   vk    Ignored Measurement Control Message for Intra Freq,
                 Inter Freq and Inter RAT Measurements in CELL_FACH
                 state. Initiate Cell Update in case of L2 Ack Failure
                 for Measurement Report or Measurement Control Failure Message
05/31/03   vk    Deleted additional measurement from additional
                 measurement database when primary Inter-RAT measurement
                 is deleted in case of DCH-->FACH transitions. Removed
                 intra freq meas from additional meas database when
                 last periodic measurement report is sent
05/30/03   vk    Fixed error in validation of Additional Measurements
05/29/03   vk    Added code for Implementing Additional Measurements for
                 Intra Freq Measurements. Removed FEATURE_2D_2F_MEAS.
04/24/03   bu    Removed usage of FEATURE_L1_ACT_TIME. Activation time will be
                 initialized in the l1_cmd_hdr_type.
04/24/03   vk    Changed a Message High to Message Low while validating meas report
04/14/03   vk    Removed reference to inter_freq_meas_info_incl
03/28/03   vk    Implemented directed cell measurements in case of DCH-->FACH transition
03/27/03   vk    Made modifications to reflect the interface change between RRC
                 and L1 for Measurement Report
02/25/03   vk    Reinitialized intra-freq measurements when UTRAN directs
                 UE to move on a particular cell on DCH-->FACH transition
                 and UE selects that cell
02/25/03   ram   Even if SIB11 indicates that SIB12 is present, it is not gauranteed
                 to be present in the cell. Hence if SIB12 is not present in the
                 SIB database we should assume it was not present in the cell and use
                 SIB11 instead. Changed the code to reflect this.
02/14/03   vk    Merged the fix relating to reinitialization of intra freq cell
                 list before updating L1 with new cells bec of cell reselection
02/14/03   vk    Fixed most of Lint Errors
02/05/03   sk    March2002Rel specific changes
                  Changed  rrc_withinMonitoredAndOrActiveSetNonUsedFreq_chosen
                  to  rrc_withinMonitoredAndOrVirtualActiveSetNonUsedFreq_chosen
                  Changed withinMonitoredAndOrActiveSetNonUsedFreq
                   withinMonitoredAndOrVirtualActiveSetNonUsedFreq
                  Changed  rrc_withinActSetOrVirtualActSet_chosen
                  to rrc_withinActSetOrVirtualActSet_InterRATcells_chosen
                  Changed   withinActSetOrVirtualActSet
                  to withinActSetOrVirtualActSet_InterRATcells
                  Changed  rrc_withinActSetAndOrMonitoredUsedFreqOrMonitoredNonUsedFreq_chosen
                  to rrc_withinActSetAndOrMonitoredUsedFreqOrVirtualActSetAndOrMonitoredNonUsedFreq_chosen
                  Changed withinActSetAndOrMonitoredUsedFreqOrMonitoredNonUsedFreq
                  to  withinActSetAndOrMonitoredUsedFreqOrVirtualActSetAndOrMonitoredNonUsedFreq
                  Changed rrc_conditionalInformationElementError
                  to  rrc_informationElementMissing
01/21/03   vk    Changed the name of feature FEATURE_INTRA_INTER_FREQ_MEAS to
                 FEATURE_2D_2F_MEAS
01/14/03   vk    Merged changes related to initialization of compressed mode
                 information after moving from connected to idle mode
12/20/02   vk    Initializes cell reselection values to default values
                 if not present in SIB11. Also, cel_resel_info_incl flag now
                 is always set to TRUE
12/18/02   vk    Added code to add ECIO or RSCP in addition to the primary
                 measurement quantity in the measurement report
12/16/02   vk    Initialized CELL_INFO_LIST when new Inter RAT cell is selected
12/10/02   bu    Assign appropriate default values for Qqualmin, Qrxlevmin,
                 maxAllowedUL_TX_Power, Qoffset1 and Qoffset2 in case
                 rrc_CellInfoSI_ECN0_cellSelectionReselectionInfo_present is
                 not present in SIB11.
12/06/02   vk    Set additional_meas_incl to false on going from connected mode
                 to idle mode
12/05/02   vk    Added an additional flag to check if additional measurement
                 has been set before appending Inter-RAT measurement report
                 to Intra-Freq Measurement Report
12/03/02   vk    Added code to handle Measurement Control Message for Inter-Freq
                 events 2d and 2f only and also handle measurement identity
                 variable for inter-freq measurements under feature
                 FEATURE_INTRA_INTER_FREQ_MEAS
11/19/02   bu    When Qqualmin and Qrxlevmin are not present in SIB 11/12, read
                 the values from SIB 3 for the serving cell. When Max UL Tx Power
                 for neighbor is not present, read the values from SIB 3 for
                 serving cell.
11/15/02   bu    Support for L1-RRC interface changes. Use
                 l1_cell_sel_resel_info_struct_type in l1_cell_info_struct_type.
11/12/02   xfg   Added FEATURE_CM_MEASUREMENT around function
                 rrcmeas_append_inter_rat_results(..) to avoid a compilation error
11/07/02   vk    Added function rrcmeas_append_inter_rat_results(..) to append
                 an Inter-RAT Measurement as an additional measurement to an
                 Intra-Freq Measurement Report
11/06/02   rj    Memory allocation to embedded buffers is done through
                 mem_malloc instead of rrc_malloc because L1 uses mem_free
                 to deallocate.
10/31/02   vk    Corrected the default initialisation of QRXLEVMIN
10/30/02   vk    Added more debug statements for DCH<-->FACH transitions
10/29/02   vk    Merged Inter-RAT Measurements code from branch irat_gap to mainline.
                 Removed feature define FEATURE_DCH_FACH_MEAS. Defined function
                 rrcmeas_process_delete_meas_id(..) to delete meas to be deleted
                 due to compressed mode run time error. Added code to process
                 Inter-RAT Measurements on cell reselection in idle and cell_fach
                 state
10/24/02   rj    Updated to use rrc_malloc and rrc_free to use dual heaps
                 in place of mem_malloc and mem_free to avoid memory
                 fragmentation
10/15/02   vk    Fixed merge problems. Fn rrcmeas_validate_intra_freq_report(..)
                 was deleted earlier while merging.
10/11/02   vk    When SIB12 does not contain Traffic Volume System Information,
                 changed MSG_ERR to MSG_LOW that indicated invalid SIB12
10/11/02   vk    Removed the checking of order of cells received as part of
                 CELL_INFO_LIST in SIB11/12 or Measurement Control Message
10/09/02   vk    Merged code from branch in main line to handle intra-freq
                 measuremenmts and traffic volume measurements on DCH<-->FACH
                 transitions under feature FEATURE_DCH_FACH_MEAS
10/08/02   vk    Added code to handle Measurement Identity List
09/23/01   vk    Removed initialization of Traffic Volume Measurements from
                 rrcmeas_clear_sib11(...).
09/19/01   vk    Added code for DCH-->FACH transitions under FEATURE_DCH_FACH_MEAS
07/24/02   vk    Modified function rrcmeas_read_sib11 to make processing
                 of SIB11 to be common for idle and connected mode
07/19/02   vk    Added code to process cell reselection in CELL_FACH state for
                 intra-freq measurements. Moved the initialization of all
                 SIB variables to rrcmeas_clear_sib11(..)
07/18/02   vk    Removed additional measurement processing from Measurement
                 Report due to change of specs and also due to removal of
                 additional measurement interface from measurement report.
                 Removed fns rrcmeas_append_additional_meas_to_meas_rpt(..)
                 and rrcmeas_process_intra_freq_meas_additional_results(..)
07/17/02   vk    During Soft Handoff Testing, RRC rejected the duplicate
                 Measurement Control Message with the same Transaction Identifier
                 but never printed that. Added a MSG_HIGH to show that condition
07/16/02   vk    Unregistered for L2 ack while sending intra-freq measurement
                 report. The procedure waits for L2 ack only for traffic
                 volume measurements only in CELL_FACH state
07/09/02   vk    Added code to process Traffic Volume Measurement Control and
                 Traffic Volume Measurement Report in CELL_FACH state of RRC
06/14/02   vk    Made changes to accept the confirmation from MAC for a
                 Measurement Command directly from dispatcher
06/06/02   vk    Merged changes from an earlier branch while processing
                 cell order list received in a Measurement Control Message
05/17/02   vk    Added functions rrcmeas_retrieve_meas_owner to determine if
                 measurement belongs to L1 or MAC. Also added the Traffic
                 volume Measurements Code at various places under the
                 feature FEATURE TRAFFIC VOLUME MEAS
05/13/02   vk    Enabled RACH Measurements Reporting
04/21/02   vk    Changed some MSG_HIGH's to MSG_LOW's while sending Meas Report
03/15/02   vk    Fixed the scenario when UE incorrectly sends measurement ctrl
                 failure message to UTRAN on getting a request to modify measurement
03/13/02   vk    Added support for new bool added to indicate if meas object is
                 present. Also corrected the initialisation of measurement identity
03/13/02   bu    Featurized the changes related to Activation Time in
                 rrcmeas_send_l1_cmd().
03/06/02   vk    As per convention, made customer.h as the first included file
03/05/02   vk    Included header file customer.h and removed file custsurf.h
02/14/01   vk    Implemented cells for measurement IE in a Measurement Ctrl
                 Message. Added Code review comments
01/28/02   vk    Added validation of sfn-sfn observed time difference
01/25/02   vk    Implemented Measurement identity variable
01/25/02   vk    Implemented the scenario when Meas Report is still sent when
                 event results and no Measured results for each cell
01/25/02   vk    Removed processing of redundant rpt_mode variable in a
                 Measurement Control Message
01/24/02   vk    Implemented functions rrcmeas_update_intra_freq_cell_list_mcm,
                 rrcmeas_check_cell_order_mcm, rrcmeas_check_cell_order_rscp,
                 rrcmeas_check_cell_order_ecn0, rrcmeas_remove_cellid,
                 rrcmeas_update_intra_freq_cell_list, rrcmeas_find_psc. These
                 functions support the cell info list obtained from SIB11 and
                 also from Measurement Control Message. Intra-freq cell id's are
                 now stored in intra_freq_cell_list which provide the mapping
                 of intra freq cell id and the corresponding scrambling code.
                 Implemented more Measurement control failure scenarios.
01/14/02   vk    Implemented the function convert_meas_value
01/11/02   vk    Changed some Message lows to Message Highs. Removed var
                 rrcmeas_last_substate as it is not required anymore.
12/17/01   rj    Added validation for the path loss to avoid ASN.1 encoding
                 failure.
12/10/01   vk    Added Initialisation of connected mode information
12/07/01   vk    Added MSG_HIGH's to ease debugging while sending meas report
12/06/01   vk    Fixed the initialisation of cell sync bit mask in meas report
12/06/01   xfg   Added the changes related to the change of the ASN1 for
                 June specs conversion
12/06/01   vk    Added type of cells when sending meas request to Layer 1
12/03/01   vk    No of reports in event 1C was getting initialised incorrectly.
                 Initialised it correctly
11/30/01   vk    Added an ERROR message if UTRAN does not specify intra-freq
                 cell id in a meas ctrl message.
11/16/01   vk    Added REMOVE_ALL_INTRA_FREQ_CELLS preprocessor to enable L1
                 to delete all cells in the neighbour list after soft handover
                 is done
11/08/01   vk    Added code to support measurement control message and measurement
                 failure message in DCH state. Also added code to support
                 additional measurements.
09/26/01   vk    Initialised added cells while building intra-freq cell info list
                 from SIB12.
09/24/01   vk    While sending meas report to UTRAN, now it is checked that RLC
                 logical channel ID is available before filling in meas report
                 values from L1. This makes sure that no memory cleanup is required.
09/18/01   vk    Added code to check if values of RSCP and ECNO are -ve so that
                 meas report would not be sent in case L1 sends wrong values
                 This takes care that ASN1 encoding would not fail as meas report
                 payload would not be built
09/14/01   vk    Updated reporting amount and reporting interval for periodical
                 reporting in fn rrcmeas_fill_dch_state_info. Removed function
                 rrcmeas_fill_intra_freq_event_criteria and added function
                 rrcmeas_set_intra_freq_event_id to make sure that only
                 one event is sent in meas report as per l1 interface. Updated
                 function rrcmeas_send_meas_report_to_utran to take care of the new
                 L1 interface. Also updated fn rrcmeas_appen_meas_rpt_on_rach to
                 make sure that monitored cell list is initialized properly.
                 Also removed global pointers head_scrambling_code_list_ptr
                 and temp_scrmabling_code_list_ptr
08/31/01   vk    Updated the state transition of measurement
                 procedure. Also, added functionality to append
                 intra-freq meas report on RACH messages. Updated
                 to support SIB11 and SIB12 completely
07/31/01   vk    Implemented/Defined sib 11/12 processing functions
12/19/00   ram   Created file.

===========================================================================*/


/* ==========================================================================
** Includes and Variable Definitions
** ========================================================================*/

/* -----------------------------------------------------------------------
** Include Files
** ----------------------------------------------------------------------- */

#include "wcdma_variation.h"
#include "customer.h"
#include "comdef.h"
#include "rrcmeas.h"
#include "rrcmeasi.h"
#include "rrcsibdb.h"
#include "msg.h"
#include "rrccmd_v.h"
#include "l1task_v.h"
#include "rrclcm.h"
#include "rrcsend.h"
#include "uecomdef.h"
#include "rrcscmgr.h"
#include "rrcllc.h"
#include "rrcllcoc.h"
#include "rrcccm.h"
#include "rrcintif.h"
#include "rrcnv.h"

#include "rrcrcr.h"
#include "rrcmcm.h"
#ifdef FEATURE_WCDMA
#include "gstk_exp.h"
#include "rrcmcm.h"
#include "rrcasn1util.h"
#endif
#include "rrccspi.h"
#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
#include <lte_rrc_ext_api.h>
#endif
#include "rrcasn1util.h"
#include "rrcrbcommon.h"
#include "rrclogging.h"
#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO
#include "geran_grr_api.h"
#include "sys.h"
#endif

#ifdef FEATURE_WCDMA_FREE_FLOATING_TASK
#include "rrcfreefloating.h"
#endif
#include "rrcdata_v.h"
#include "rrclog.h"


/* -----------------------------------------------------------------------
** Constant / Define Declarations
** ----------------------------------------------------------------------- */
#define INVALID_CELL_COUNT 1000
#define DEBUG_MSG 1
/* -----------------------------------------------------------------------
** Type Declarations
** ----------------------------------------------------------------------- */


/* -----------------------------------------------------------------------
** Global Constant Data Declarations
** ----------------------------------------------------------------------- */



/* -----------------------------------------------------------------------
** Local Object Definition
** ----------------------------------------------------------------------- */
#define MIN_MEAS_ID_EXTN   16

#define MAX_EUTRA_FREQUENCIES 10

/*We are having different priorities to avoid equal priority for IRAT cases.
  We might have this case when dedicate priorities are valid and dedicated priroty doesnt contain
  serving cell priority in this case serving cell priority will be set to -1, Now if we received Deprio
  request from LTE then eutra priority will be also set to -1 which is not allowed as per spec*/

#define LOWEST_ABS_PRIORITY -1

/* Prirority lower than lowest priority*/
#define LOWEST_DEPRIO_PRIORITY  -2

#ifdef FEATURE_QSH_EVENT_METRIC
extern rrc_qsh_ul_failure_ota_param_s failure_ota;
extern boolean rrc_qsh_dl_committed;
#endif


/*-------------------------------------------------------------------
STRUCTURE: l1_meas_sib_parm_struct_type
Stores the SIB parameters from SIB 11.
--------------------------------------------------------------------*/
l1_meas_sib_parm_struct_type     *rrcmeas_sib11 = NULL;
l1_meas_sib_parm_struct_type     *rrcmeas_sib12 = NULL;
l1_inter_freq_cell_list_struct_type *rrcmeas_inter_freq_sib11 = NULL;
l1_inter_freq_cell_list_struct_type *rrcmeas_inter_freq_sib12 = NULL;
l1_meas_trans_type               *state_transition_meas = NULL;

/* Boolean that indicates measurement id extension is supported or not */
boolean rrc_meas_id_extn_support = FALSE;

/*-------------------------------------------------------------------
STRUCTURE: cell_info_list_struct_type
Stores the intra freq cell info list [CELL_INFO_LIST variable]
--------------------------------------------------------------------*/

LOCAL intra_freq_cell_list_struct_type  intra_freq_cell_list[MAX_NUM_CARR][L1_MAX_CELL_MEAS];
intra_freq_cell_list_struct_type  intra_freq_cell_list_temp[MAX_NUM_CARR][L1_MAX_CELL_MEAS];


/*-------------------------------------------------------------------
STRUCTURE: meas_id_list_struct_type
Stores the intra freq meas id list [MEASUREMENT_IDENTITY variable]
This list is updated only on receiving MCM message
--------------------------------------------------------------------*/
LOCAL intra_freq_meas_id_list_struct_type  intra_freq_meas_id_list[MAX_INTRA_FREQ_MEAS];
LOCAL intra_freq_meas_id_list_struct_type  tmp_intra_freq_meas_id_list[MAX_INTRA_FREQ_MEAS];
/* Declared to store new intra freq cell list that is being built */
LOCAL l1_intra_freq_cell_list_struct_type intra_freq_sib12_new_cell_list;

/*------------------------------------------------------------------------
* Indicates if RACH report would be appended to RACH message
* Initialized in rrcmeas_init_procedure fn
--------------------------------------------------------------------------*/
LOCAL rach_report_crit_e_type sib11_rach_report_crit;

LOCAL rach_report_crit_e_type sib12_rach_report_crit;


/*-------------------------------------------------------------------
ENUM: rrcmeas_current_substate
Stores substate of RRC Measurement procedure
--------------------------------------------------------------------*/
rrcmeas_substate_e_type rrcmeas_current_substate;

/*-------------------------------------------------------------------
ENUM: sib12_present
Indicates if SIB12 params have been saved from SIB11
--------------------------------------------------------------------*/
sib12_present_e_type sib12_present;


/* -----------------------------------------------------------------------
** Global Data Declarations
** ----------------------------------------------------------------------- */

/* Stores transaction Id on receiving from Meas Ctrl Message. Once RRC processes
 * Meas Ctrl Msg fully, this value is set to 0 again */
LOCAL uint32 trans_id = INVALID_TRANSACTION_ID;

/* Accepted transaction Table  */
rrcmeas_accepted_transaction_list rrcmeas_accepted_transaction_table[MAXIMUM_TRANSACTIONS];

/* Array first stores the original cell list in this variable so that in case
 UTRAN messes up, we copy back the original cell list back to
 intra_freq_cell_list from intra_freq_cell_list_temp before sending
 measurement control failure message */

 /* Moved this array declaration to above */
#if defined (FEATURE_CGPS)
/* Stores the cell id, plm id, psc, freq everytime a new cell is selected */
rrcmeas_plmn_cell_info_struct_type plmn_cell_info;
#endif

/* For storing Inter Freq list that gets passed to L1 in FACH */
l1_inter_freq_cell_list_struct_type l1_fach_inter_freq_parms;

/* Every time SCR code is changed in Idle or Fach state, the old one is updated in this var */
uint16 last_scr_code = INVALID_PSC;

/* this counter tracks the pending measurement reports in the rlc queue */
uint8 rrcmeas_pending_rpt = 0;

/* Global HSDPA HSUPA Indicator */
extern sys_hs_ind_e_type hsdpa_hsupa_ind;

#ifdef FEATURE_EUTRA_DETECT
boolean is_sib19_eutradetect_present = FALSE;
#endif

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY_FACH
/*FE_FACH Support NV*/
extern uint8 rrc_fe_fach_support_nv;

#endif

#ifdef LTE_BAND_NUM
  sys_lte_band_mask_e_type rrcueci_sib19_band_mask;
#else
  sys_band_mask_type rrcueci_sib19_band_mask = 0;
#endif

#ifdef FEATURE_WCDMA_RRC_HEAP_TO_BSS
l1_meas_sib_parm_struct_type          rrcmeas_sib11_glob_var;
l1_meas_sib_parm_struct_type          rrcmeas_sib12_glob_var;
l1_inter_freq_cell_list_struct_type   rrcmeas_inter_freq_sib11_glob_var;
l1_inter_freq_cell_list_struct_type   rrcmeas_inter_freq_sib12_glob_var;
l1_meas_trans_type                    state_transition_meas_glob_var;
#endif /*FEATURE_WCDMA_RRC_HEAP_TO_BSS*/


/* -----------------------------------------------------------------------
** Forward Declarations
** ----------------------------------------------------------------------- */

/* TVM Meas Id List */
extern tvm_meas_id_list_struct_type     tvm_meas_id_list[MAX_TRAFFIC_VOLUME_MEASUREMENTS];

/* Traffic Volume SIB Params */
extern mac_ul_traffic_meas_config_type  mac_sib_params;


#ifdef FEATURE_AAGPS_MR_RRC_NOTIFICATION_REQUIRED
/* A-GPS L2 ack params */
extern rrc_gps_l2_ack_struct_type gps_l2_ack_params;
#endif

extern inter_rat_meas_id_list_struct_type inter_rat_meas_id_list[MAX_INTER_RAT_MEAS];

extern inter_freq_meas_id_list_struct_type inter_freq_meas_id_list[MAX_INTER_FREQ_MEAS];

extern ueim_meas_id_list_struct_type ueim_meas_id_list[MAX_INTERNAL_MEAS];

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
extern pos_meas_id_list_struct_type pos_meas_id_list[MAX_POS_MEAS];
boolean pos_meas_failure = FALSE;
#endif


extern quality_meas_id_list_struct_type quality_meas_id_list[MAX_QUALITY_MEAS];

/* HSDPA + CM is enabled by default */
extern uint8 hsdpa_cm_enabled;

#define CARR_IDX 0 

#ifdef FEATURE_WCDMA_INTER_FREQ_NOT_SUPPORTED
/*Boolean added to track if interfrequency and interrat measurements are to be processed or not*/
/*Used the same variable to block sending UE internal measurements to L1*/
boolean process_interfreq_interrat_meas_rel7 = FALSE;

/*Boolean to track if inter frequency measurements are allowed or not
Inter freq measurements are allowed if process_interfreq is TRUE 
(Even in case process_interfreq_interrat_meas_rel7 is FALSE)

Use the same variable to unblock UE internal measurements also
*/
boolean process_interfreq_uei_meas_rel7 = FALSE;

#else

/*Boolean added to track if interfrequency and interrat measurements are to be processed or not*/
/*Used the same variable to block sending UE internal measurements to L1*/
boolean process_interfreq_interrat_meas_rel7 = TRUE;

/*Boolean to track if inter frequency measurements are allowed or not
Inter freq measurements are allowed if process_interfreq is TRUE 
(Even in case process_interfreq_interrat_meas_rel7 is FALSE)

Use the same variable to unblock UE internal measurements also
*/
boolean process_interfreq_uei_meas_rel7 = TRUE;
#endif /*FEATURE_WCDMA_INTER_FREQ_NOT_SUPPORTED*/

boolean is_dch_to_pch_new_cell_ind_processed = TRUE;
#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
rrc_dedicated_priority_info_type rrc_dedicated_priority_info;

#define RRCMEAS_GET_T322_FROM_OTA(t322) \
    ((t322 == rrc_T_322_m5) ? 5 :\
      ((t322 == rrc_T_322_m10) ? 10 :\
        ((t322 == rrc_T_322_m20) ? 20: \
          ((t322 == rrc_T_322_m30) ? 30: \
            ((t322 == rrc_T_322_m60) ? 60 : \
              ((t322 == rrc_T_322_m120) ? 120 : \
                  (t322 == rrc_T_322_m180) ? 180 : 0 \
              )\
            )\
          )\
        )\
      )\
    )


extern inter_rat_cell_list_struct_type  inter_rat_cell_list[L1_MAX_CELL_MEAS];
extern inter_freq_cell_list_struct_type inter_freq_cell_list[L1_MAX_CELL_MEAS];

#endif

#ifdef FEATURE_LTE_TO_WCDMA
rrc_deprio_db_type rrc_deprioritization_db;
boolean rrc_handle_deprio_req_pending;
#endif

#ifdef FEATURE_WCDMA
/*-------------------------------------------------------------------
This macro translates the NMR report type from GSTK defined
values to L1 defined enum values.
--------------------------------------------------------------------*/
#define RRCMEAS_XLATE_NMR_TYPE(rrc_nmr_type)             \
  (((rrc_nmr_type) == GSTK_NMR_INTRA_FREQ_MEAS) ? L1_RRC_UTRAN_NMR_INTRA_FREQ :  \
     (((rrc_nmr_type) == GSTK_NMR_INTER_FREQ_MEAS) ?  L1_RRC_UTRAN_NMR_INTER_FREQ : L1_RRC_UTRAN_NMR_IRAT))

/*-------------------------------------------------------------------*/
void rrcmeas_handle_utran_nmr_info_req(rrc_cmd_type* cmd_ptr);
#endif /* FEATURE_WCDMA */

boolean discard_EUTRA_info_from_SIB19 = FALSE;
boolean dch_to_pch_in_progress = FALSE;

extern   rrc_meas_params_struct_type temp_gps;

#ifdef FEATURE_WCDMA_MULTI_FREQ_BAND_INDICATOR
extern boolean rrc_mfbi_support_nv;
#endif


#define CHECK_RPT_CRIT_NOT_PRESENT(freq_type)  \
     (meas_id_idx == MAX_INTRA_FREQ_MEAS) ||\
     (intra_freq_meas_id_list[meas_id_idx].rpt_crit[freq_type] == NOT_AVAILABLE) ||\
     (l1_mcm->meas_cmd == L1_MEAS_SETUP)

/* =======================================================================
**                            Function Definitions
** ======================================================================= */

/*===========================================================================

FUNCTION     RRCMEAS_INIT_PROCEDURE

DESCRIPTION

 Initialization function which is called on initialization
 of RRC task. This task registers for state change indication
 manager and also initializes stored variables. Also sets the
 sub state of the measurement state machine to RRCMEAS_INITIAL


DEPENDENCIES

 None.

RETURN VALUE

 None.

SIDE EFFECTS

 None

===========================================================================*/
void rrcmeas_init_procedure
(
void
)
{

  MSG_LOW("Initialising RRC Measurement procedure", 0,0,0);
  /* Initialize the current substate */
  rrcmeas_current_substate = RRCMEAS_INITIAL;

  /* Initialize SIB11 structure elements to FALSE */
  rrcmeas_clear_sib11();

  rrcmeas_initialize_meas_id_list();

  rrcmeas_initialize_cell_list();

  rrctvm_initialize();

  rrctvm_initialize_measurement_identity();

  sib12_present = SIB12_ABSENT;
  rrcmeas_pending_rpt = 0;

  rrcmeas_initialize_transaction_id_list();
  /* Register for state change notification -
  We want to be notified when the state changes
  from CELL_DCH to state disconnected and from state
  connecting to CELL_DCH state. */


  rrcscmgr_register_for_scn( RRC_PROCEDURE_MCMR, /* Procedure name */
    RRC_STATE_CELL_DCH, /* From State */
    RRC_STATE_DISCONNECTED  /* To State */
    );

  rrcscmgr_register_for_scn( RRC_PROCEDURE_MCMR, /* Procedure name */
    RRC_STATE_WILDCARD, /* From State */
    RRC_STATE_CELL_DCH  /* To State */
    );
  rrcscmgr_register_for_scn( RRC_PROCEDURE_MCMR, /* Procedure name */
    RRC_STATE_WILDCARD,/* From State */
    RRC_STATE_CELL_FACH /* To State */
    );

  rrcscmgr_register_for_scn( RRC_PROCEDURE_MCMR, /* Procedure name */
    RRC_STATE_CELL_FACH, /* From State */
    RRC_STATE_DISCONNECTED  /* To State */
    );

#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
  rrcscmgr_register_for_scn( RRC_PROCEDURE_MCMR, /* Procedure name */
      RRC_STATE_DISCONNECTED, /* From State */
      RRC_STATE_CONNECTING  /* To State */
      );
#endif

  /* Register with the SIB procedure for SIB change notification */
  rrcsib_register_for_sib_change_notification
    (
    RRC_PROCEDURE_MCMR,
    rrc_SIB11
    );
  /* Register with the SIB procedure for SIB change notification */
  rrcsib_register_for_sib_change_notification
    (
    RRC_PROCEDURE_MCMR,
    rrc_SIB12
    );
  /* Register with the SIB procedure for SIB change notification */
rrcsib_register_for_sib_change_notification
    (
    RRC_PROCEDURE_MCMR,
    rrc_SIB11bis
    );
   /* Register with the SIB procedure for SIB change notification */
  rrcsib_register_for_sib_change_notification
    (
    RRC_PROCEDURE_MCMR,
    rrc_SIB18
    );

#ifdef FEATURE_WCDMA_TO_LTE
   /* Register with the SIB procedure for SIB change notification */
  rrcsib_register_for_sib_change_notification
    (
    RRC_PROCEDURE_MCMR,
    rrc_SIB19
    );
#endif

  rrcscmgr_register_for_scn( RRC_PROCEDURE_MCMR, /* Procedure name */
    RRC_STATE_WILDCARD, /* From State */
    RRC_STATE_CELL_PCH  /* To State */
    );

  rrcscmgr_register_for_scn( RRC_PROCEDURE_MCMR, /* Procedure name */
    RRC_STATE_WILDCARD, /* From State */
    RRC_STATE_URA_PCH  /* To State */
    );

  rrcscmgr_register_for_scn( RRC_PROCEDURE_MCMR, /* Procedure name */
    RRC_STATE_CELL_PCH, /* From State */
    RRC_STATE_DISCONNECTED  /* To State */
    );

  rrcscmgr_register_for_scn( RRC_PROCEDURE_MCMR, /* Procedure name */
    RRC_STATE_URA_PCH, /* From State */
    RRC_STATE_DISCONNECTED  /* To State */
    );


  /* Initialize Inter-RAT CELL_INFO_LIST */
  rrcirat_initialize_cell_list();

  rrcirat_initialize_meas_id_list();

  rrcifreq_initialize_meas_id_list();


  /* Initialize Inter Freq Cell List */
  rrcifreq_initialize_cell_list();

  rrcifreq_initialize_meas_id_list();

  rrcueim_initialize_meas_id_list();

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  rrcmeas_initialize_pos_meas_id_list();
#endif

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
rrcmeas_invalidate_dedicated_priority_info();
/*memset Deprio DB*/
 memset(&rrc_deprioritization_db,0,sizeof(rrc_deprioritization_db));
#endif

}

/*===========================================================================

FUNCTION     RRCMEAS_PROCESS_QMI_MTC_CFG_REQ

DESCRIPTION

This function take care of processing MTC_CFG request from QMI and sending M2M_CMD_IND to WL1.


DEPENDENCIES

 None.

RETURN VALUE

 None.

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_process_qmi_mtc_cfg_req(rrc_cmd_type *cmd_ptr)
{
  if((WCDMA_RRC_M2M_FEATURES(RRC_M2M_IDLE_DRX)) || (WCDMA_RRC_M2M_FEATURES(RRC_M2M_SKIP_IDLE_MEAS)))
  {
     /* local cmd var to send to L1 */
     l1_ext_cmd_type  *req_cmd_ptr;
     wcdma_rrc_qmi_mtc_cfg_cnf_type qmi_cfg_rsp;
     WRRC_MSG0_HIGH("Received QMI_MTC_CFG_REQ");
     /* Get a L1 command buffer */
     req_cmd_ptr = l1_get_cmd_buf();
     req_cmd_ptr->cmd_hdr.cmd_id = CPHY_M2M_ENABLE_IND;
     if((WCDMA_RRC_M2M_FEATURES(RRC_M2M_IDLE_DRX)))
     {
       req_cmd_ptr->cmd.m2m.scaling_factor_valid = cmd_ptr->cmd.wcdma_rrc_qmi_cmd.cmd.wcdma_rrc_qmi_mtc_cfg_req.drx_scaling_factor_valid;
       if(req_cmd_ptr->cmd.m2m.scaling_factor_valid == TRUE)
       {
         req_cmd_ptr->cmd.m2m.scaling_factor= cmd_ptr->cmd.wcdma_rrc_qmi_cmd.cmd.wcdma_rrc_qmi_mtc_cfg_req.drx_scaling_factor;
       }
       WRRC_MSG2_HIGH("scaling_factor_valid : %d, scaling_factor : %d, ",req_cmd_ptr->cmd.m2m.scaling_factor_valid,
                 req_cmd_ptr->cmd.m2m.scaling_factor);
     }
     if((WCDMA_RRC_M2M_FEATURES(RRC_M2M_SKIP_IDLE_MEAS)))
     {
       req_cmd_ptr->cmd.m2m.skip_meas_info_valid = cmd_ptr->cmd.wcdma_rrc_qmi_cmd.cmd.wcdma_rrc_qmi_mtc_cfg_req.skip_idle_srch_meas_valid;
       req_cmd_ptr->cmd.m2m.skip_meas_info = cmd_ptr->cmd.wcdma_rrc_qmi_cmd.cmd.wcdma_rrc_qmi_mtc_cfg_req.skip_idle_srch_meas;
    
       WRRC_MSG2_HIGH("skip_meas_valid : %d, skip_meas : %d",req_cmd_ptr->cmd.m2m.skip_meas_info_valid,req_cmd_ptr->cmd.m2m.skip_meas_info);
     }
     rrc_send_l1_cmd(req_cmd_ptr);
  
    /*Send confirmation to QMI*/
  
     qmi_cfg_rsp.status = SUCCESS;
  
     msgr_init_hdr(&qmi_cfg_rsp.msg_hdr,MSGR_WCDMA_RRC,WCDMA_RRC_QMI_MTC_CFG_RSP);
     msgr_send(&qmi_cfg_rsp.msg_hdr, sizeof(wcdma_rrc_qmi_mtc_cfg_cnf_type));
  }
  else
  {
    wcdma_rrc_qmi_mtc_cfg_cnf_type qmi_cfg_rsp;
    WRRC_MSG0_HIGH("Received QMI_MTC_CFG_REQ, NV#73778  is not set for M2M features, send failure to QMI");
    /*Send confirmation to QMI*/
  
     qmi_cfg_rsp.status = FAILURE;
  
     msgr_init_hdr(&qmi_cfg_rsp.msg_hdr,MSGR_WCDMA_RRC,WCDMA_RRC_QMI_MTC_CFG_RSP);
     msgr_send(&qmi_cfg_rsp.msg_hdr, sizeof(wcdma_rrc_qmi_mtc_cfg_cnf_type));
  }

}


/*===========================================================================

FUNCTION     RRCMEAS_PROCEDURE_EVENT_HANDLER

DESCRIPTION

 This is the main function handling external events received by the
 RRC Measurement procedure. This function is called by the
 dispatcher whenever an event is received for this module. This
 function checks the current RRC Meas substate and calls the event handler for
 that state.

DEPENDENCIES

 None.

RETURN VALUE

 None.

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_procedure_event_handler
(
rrc_cmd_type*  cmd_ptr
)
{


#ifdef FEATURE_GAN_3G
  #error code not present
#endif
#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO
  rrc_rr_cmd_type *rr_cmd;
#endif

#ifdef FEATURE_LTE_TO_WCDMA
uint8 cnt;
#endif
rrc_crash_debug_log_proc_substates(RRC_PROCEDURE_MCMR,rrcmeas_current_substate,cmd_ptr);
WRRC_MSG1_HIGH_OPT("function rrcmeas_procedure_event_handler is called in rrcmeas_current_substate = rrcmeas_substate_e_type_value%d", rrcmeas_current_substate);

#ifdef FEATURE_WCDMA
  if (cmd_ptr->cmd_hdr.cmd_id == RRC_GSTK_UTRAN_NMR_INFO_REQ)
  {
    rrcmeas_handle_utran_nmr_info_req(cmd_ptr);
    return;
  }
#endif  

/*lint -e408*/
#ifdef FEATURE_GAN_3G
  #error code not present
#endif
#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO
if (((uint32)cmd_ptr->cmd_hdr.cmd_id & RRC_RR_CMD_ID_BASE) == RRC_RR_CMD_ID_BASE)
  {

rr_cmd = ((rrc_rr_cmd_type *)cmd_ptr);

switch(rr_cmd->cmd_hdr.cmd_id)
     {
       case RR_DEDICATED_PRIORITIES_RSP:
         WRRC_MSG0_HIGH("WTOG: RR_DEDICATED_PRIORITIES_RSP received from GSM");
      if(!rr_cmd->cmd.dedicated_priorities_rsp.dedicated_pri_valid)
         {
           rrcmeas_invalidate_dedicated_priority_info();
           rrc_dedicated_priority_info.dedicated_priority_info_crit_sec = FALSE;
         }
         else
         {
           rrcmeas_update_dedicated_priority_info_from_irat_req(&rr_cmd->cmd.dedicated_priorities_rsp.dedicated_pri_info,
                   mmumts_convert_nas_plmn_id_to_rrc_plmn_id(rr_cmd->cmd.dedicated_priorities_rsp.plmn));
         }
        break;
      case RRC_DEDICATED_PRIORITIES_REQ:
         WRRC_MSG0_HIGH("WTOG: RRC_DEDICATED_PRIORITIES_REQ received from GSM");
         rrcmeas_handle_gsm_get_dedicated_pri_req(rr_cmd);
         break;
      case RRC_CLEAR_DEDICATED_PRIORITIES_IND:
          WRRC_MSG0_HIGH("WTOG: RRC_CLEAR_DEDICATED_PRIORITIES_IND received from GSM");
          rrcmeas_invalidate_dedicated_priority_info();
          rrcmeas_handle_clear_dedicated_pri_ind();
        break;
      default:
        break;
  }
 }
#endif

/*lint +e408*/

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_DED_PRI_CHANGE_IND)
  {
    rrc_dedicated_priority_info.dedicated_priority_info_crit_sec = FALSE;
    if(rrcmeas_current_substate != RRCMEAS_CELL_DCH)
    {
      /*Call the function that uses the dedicated priority info and SIB19 info to send meas_req to L1*/
      rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
    }
    return;
  }
  else if(cmd_ptr->cmd_hdr.cmd_id == RRC_DED_PRI_VALDITY_TIMER_EXPIRED_IND)
  {
    if(rrctmr_get_remaining_time(RRCTMR_DED_PRI_VALIDITY_TIMER) !=0) 
    /*rrc_dedicated_priority_info.dedicated_priority_info_crit_sec will help too, trying other option too */
    {
      /*
        Processing the UMI and DED PRI info not yet updated, Timer expiry indication posted to internal cmd (REX posts this cmd)
        DED PRI infomartion updated and timer T322 is started.
      */
      WRRC_MSG0_HIGH("ABSOL_PRI:UMI with T322 received, ignore the validity timer expired indication");
    }
    else if(rrc_dedicated_priority_info.is_valid && rrc_dedicated_priority_info.dedicated_priority_info_crit_sec)
    {
      /*
        Processing the UMI and DED PRI info not yet updated, Timer expiry indication posted to internal cmd (REX posts this cmd)
        DED PRI infomartion updated and timer T322 is not started as not given in OTA
      */
      WRRC_MSG0_HIGH("ABSOL_PRI:UMI without T322 received, ignore the validity timer expired indication");
    }
    else
    {
      /*Clear the dedicated priroities, use the same procedure call as ded pri clear ind*/
      rrcmeas_invalidate_dedicated_priority_info();
      rrcmeas_handle_clear_dedicated_pri_ind();
      if(rrcmeas_current_substate != RRCMEAS_CELL_DCH)
      {
        /*Call the function that uses the dedicated priority info and SIB19 info to send meas_req to L1*/
        rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
      }
    }
    return;
  }
#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
  else if(RRC_LTE_RRC_CMD == cmd_ptr->cmd_hdr.cmd_id)
  {
    switch(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id)
    {
      case WCDMA_RRC_LTE_GET_DEDICATED_PRI_REQ:
        WRRC_MSG0_HIGH("WTOL: WCDMA_RRC_LTE_GET_DEDICATED_PRI_REQ received from LTE");
        rrcmeas_handle_get_dedicated_pri_req(cmd_ptr);
        break;
      case WCDMA_RRC_LTE_CLEAR_DEDICATED_PRI_IND:
        WRRC_MSG0_HIGH("WTOL: WCDMA_RRC_LTE_CLEAR_DEDICATED_PRI_IND received from LTE");
        rrcmeas_invalidate_dedicated_priority_info();
        rrcmeas_handle_clear_dedicated_pri_ind();
        break;
      case LTE_RRC_GET_DEDICATED_PRI_RSP:
        WRRC_MSG0_HIGH("WTOL: LTE_RRC_GET_DEDICATED_PRI_RSP received from LTE");
        if((!cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_get_dedicated_pri_rsp.dedicated_priorities_valid) ||
            (rrc_csp_int_data.last_mm_primitive != RRC_CSP_SRVC_REQ_RCVD) )
        {
          rrcmeas_invalidate_dedicated_priority_info();
          rrc_dedicated_priority_info.dedicated_priority_info_crit_sec = FALSE;
        }
        else
        {
          rrcmeas_update_dedicated_priority_info_from_irat_req
          (
            &cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_get_dedicated_pri_rsp.dedicated_priority_info,
            mmumts_convert_nas_plmn_id_to_rrc_plmn_id(
              cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.lte_rrc_get_dedicated_pri_rsp.plmn)
          );
        }
        break;
        case WCDMA_RRC_LTE_DEPRI_FREQ_REQ:
 
          MSG_5(MSG_SSID_DIAG, MSG_LEGACY_HIGH,
            "LTOW: DEPRI_FREQ_REQ rxd from LTE: deprio_all_freq %d, num_depri_freq %d, deprio_db_valid %d, RRC state %d, camped sts %d ",
            cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.wcdma_rrc_lte_depri_freq_req.depri_all_freq,
            cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.wcdma_rrc_lte_depri_freq_req.num_depri_freq,
            rrc_deprioritization_db.is_deprio_db_valid,
            rrc_get_state(),
            rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP));

          if((cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.wcdma_rrc_lte_depri_freq_req.depri_all_freq == FALSE)
               &&(cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.wcdma_rrc_lte_depri_freq_req.num_depri_freq == 0))
          {
            WRRC_MSG0_HIGH("LTOW: De-Prioritization Timer has expired.");
            /*T325 timer has expired.. Clear De-prioritization db*/
            memset(&rrc_deprioritization_db,0,sizeof(rrc_deprioritization_db));

            /* Check for the state to handle this timer expiration*/
            if(WTOW_SEARCH_RESUME == rrc_csp_bplmn_srch_in_progress())
            {
              /*BPLMN search is going on wait till we send GO_TO_SLEEP_IND to Wl1*/
              rrc_handle_deprio_req_pending = TRUE;
            }
            else if((rrc_get_state() == RRC_STATE_CELL_DCH) || 
                    (RRC_NOT_CAMPED_ON == rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_CSP)))
            {
              WRRC_MSG0_HIGH("LTOW: RRC state is DCH or UE is not camped. Dont configure priority info to Wl1");
              /*Dont do anything here since L1 cannot handle mes req here.
                When UE move to  idle/pch/fach we will any way configure SIB 19 info*/
            }
            else
            {
              /*Configure SIB 19 to wl1*/
              rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
            }
          }
          else
          {
            if(!rrc_deprioritization_db.is_deprio_db_valid)
            {
               /*We either received fresh De-prioritization request or New De-prioritization request after T325 timer expiry */
               WRRC_MSG0_HIGH("Rcvd new De-prioritization request.. Store in DB");
            }
            else
            {
              /*We received De-prioritization request when T325 timer is still running. We should replace the existing earfcn with new*/
              WRRC_MSG0_HIGH("Rcvd De-prioritization request while T325 is still running.. Replace exisiting DB");
   
              /*Initialize de-prioritization db*/
              memset(&rrc_deprioritization_db,0,sizeof(rrc_deprioritization_db));
              // Init deprio db in init.task
            }

            rrc_deprioritization_db.depri_all_freq = cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.wcdma_rrc_lte_depri_freq_req.depri_all_freq;
            rrc_deprioritization_db.num_depri_freq = cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.wcdma_rrc_lte_depri_freq_req.num_depri_freq;

            for(cnt=0;cnt<rrc_deprioritization_db.num_depri_freq;cnt++)
            {
               WRRC_MSG1_HIGH("Adding earfcn %d in deprio DB",cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.wcdma_rrc_lte_depri_freq_req.depri_freqs[cnt]);
               rrc_deprioritization_db.depri_freqs[cnt] = cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.wcdma_rrc_lte_depri_freq_req.depri_freqs[cnt];
            }
            rrc_deprioritization_db.is_deprio_db_valid= TRUE;
          }
        break;

      default :
        break;
    }
    return;
  }
#endif
#endif

  switch ( rrcmeas_current_substate )
  {
  case RRCMEAS_INITIAL:
    rrcmeas_process_initial_state(cmd_ptr);
    break;

  case RRCMEAS_IDLE:
    rrcmeas_process_idle_state(cmd_ptr);
    break;

  case RRCMEAS_CELL_FACH:
    rrcmeas_process_cell_fach_state(cmd_ptr);
    break;

  case RRCMEAS_CELL_DCH:
    rrcmeas_process_cell_dch_state(cmd_ptr);
    break;

  case RRCMEAS_PCH:
    rrcmeas_process_pch_state(cmd_ptr);
    break;

  default:
    WRRC_MSG1_ERROR("Invalid RRC State: %d", rrcmeas_current_substate);
    break;

  }
  return;
}


/*===========================================================================

FUNCTION     RRCMEAS_PROCESS_INITIAL_STATE

DESCRIPTION

 Processes RRC_CELL_SELECTED_MEAS_REQ received in
 RRCMEAS_INITIAL state of RRC Measurements procedure.
 RRC_CELL_SELECTED_MEAS_REQ from cell selection procedure
 would come in this state which would cause RRC Measurement
 to transition from RRCMEAS INITIAL state to RRCMEAS IDLE
 state and give indication to L1 to start meas based on SIB11.

DEPENDENCIES

 None.

RETURN VALUE

 None.

SIDE EFFECTS

 None

===========================================================================*/
void rrcmeas_process_initial_state
(
rrc_cmd_type*  cmd_ptr
)
{

  
#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
  uint8  l1_deferred_meas_from_sib_action = 0;
#endif

  l1_meas_ctrl_enum_type meas_choice;

  rrc_scr_code_type psc = 0;

  /* Boolean that indicates that Meas Req needs to be sent to L1 */
  boolean meas_req_incl = FALSE;

  rrcmeas_pending_rpt = 0;

  /* Initialize the CELL_INFO_LIST, MEAS_ID_LIST for all meas */
  rrcmeas_clear_sib11();

  rrcmeas_initialize_meas_id_list();

  rrcmeas_initialize_cell_list();

  rrctvm_initialize();

  rrctvm_initialize_measurement_identity();

  rrcmeas_initialize_transaction_id_list();

  rrcirat_initialize_cell_list();
  
  rrcifreq_initialize_cell_list();


  rrcqm_initialize_meas_id_list();

  switch ( cmd_ptr->cmd_hdr.cmd_id )
  {
  case RRC_CELL_SELECTED_MEAS_REQ:

  /* This req would be posted by RRC_CSP on selecting a new cell
    * and would indicate to RRC Measurements to indicate L1 to start meas*/

    /* Change current state to idle */
    rrcmeas_current_substate = RRCMEAS_IDLE;

    psc = rrc_ccm_get_curr_camped_psc();

    MSG_HIGH("IntraF:Old SCR %d, New SCR %d, Initial, gtow_active %d", last_scr_code,psc,cmd_ptr->cmd.cell_selected_meas_req.gtow_ho_active);

    last_scr_code = psc;
#if defined (FEATURE_CGPS)
    /* Set Cell/PLMN info for LSM */
    rrcmeas_set_cell_plmn_info();
#ifdef FEATURE_AAGPS_MR_RRC_NOTIFICATION_REQUIRED
    rrcgps_initialize_l2_ack_params();
#endif
#endif

    if (cmd_ptr->cmd.cell_selected_meas_req.gtow_ho_active == TRUE)
    {
      return;
    }

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
    if(rrcsib_is_sib11_11bis_12_read_deferred(DEFERRED_SIB11))
    {
      l1_deferred_meas_from_sib_action = CLEAR_CELL_INFO_LIST;
      l1_deferred_meas_from_sib_action |= CLEAR_MEAS_IDENTITY;
      rrcmeas_send_deferred_meas_req(l1_deferred_meas_from_sib_action);
      break;
    }
    else
#endif

    if ( rrcmeas_read_sib11() == FAILURE )
    {

      WRRC_MSG0_HIGH("IntraF:SIB 11 not used");
      rrcmeas_clear_sib11();

      rrcmeas_initialize_meas_id_list();

      rrcmeas_initialize_cell_list();

    }
    else
    {
      /* Set meas_req to TRUE */
      meas_req_incl = TRUE;
    }


    /* Even if SIB11 for intra-freq meas is not good, we would read SIB11 for inter-RAT */
    if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
    {
      WRRC_MSG0_HIGH("IntraF:Inter-RAT SIB11 ignored");
      rrcirat_initialize_cell_list();
    }
    else
    {
      /* Set meas_req to TRUE */
      meas_req_incl = TRUE;
    }

    if (meas_req_incl == TRUE)
    {
      /* L1 needs to be given Measurement Parameters */
      rrcmeas_send_l1_cmd(rrcmeas_sib11, NULL, NULL, L1_SIB_PARMS);
    }

    if (rrcifreq_read_sib11(rrcmeas_inter_freq_sib11) == FAILURE)
    {
      WRRC_MSG0_HIGH("IntraF:Inter Freq SIB11 ignored");
      rrcifreq_initialize_cell_list();
    }
    else
    {
      meas_choice = L1_INTER_FREQ_SIB_PARMS;
      rrcifreq_send_l1_cmd(&meas_choice, rrcmeas_inter_freq_sib11);
      WRRC_MSG0_MED("IntraF:IFreq:Cell List sent");
    }

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
    rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif

    break;

  default:

    WRRC_MSG1_HIGH("Command %x not possible in initial state", cmd_ptr->cmd_hdr.cmd_id);

    break;

  } /* End of switch */

  return;
} /* End of function */


/*===========================================================================

FUNCTION     RRCMEAS_PROCESS_IDLE_STATE

DESCRIPTION

 Processes all the messages received in RRCMEAS_IDLE state
 of RRC Measurements procedure.

DEPENDENCIES

 None.

RETURN VALUE

 None.

SIDE EFFECTS

 None.

===========================================================================*/

void rrcmeas_process_idle_state
(
rrc_cmd_type *cmd_ptr
)
{

  
#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
  uint8  l1_deferred_meas_from_sib_action = 0;
#endif

  l1_meas_ctrl_enum_type meas_choice;

  /* Boolean to check if Meas Req needs to be sent to L1 */
  boolean meas_req_incl = FALSE;

  rrc_scr_code_type psc;

  rrcmeas_pending_rpt = 0;

  rrcmeas_initialize_transaction_id_list();

  switch ( cmd_ptr->cmd_hdr.cmd_id )
  {
  case RRC_CPHY_MEASUREMENT_IND:
    WRRC_MSG0_HIGH("IntraF:Ignoring Measurement report in Idle state");
    break;

  case RRC_STATE_CHANGE_IND:
    rrcmeas_process_state_change_ind_in_idle_state(cmd_ptr);
    break;

  case RRC_CELL_SELECTED_MEAS_REQ:

    psc = rrc_ccm_get_curr_camped_psc();

    MSG_HIGH("IntraF:Old SCR %d, New SCR %d, gtow ho active %d, Idle", last_scr_code,psc,cmd_ptr->cmd.cell_selected_meas_req.gtow_ho_active);
    last_scr_code = psc;

#if defined (FEATURE_CGPS)
    /* Set Cell/PLMN info for LSM */
    rrcmeas_set_cell_plmn_info();
#ifdef FEATURE_AAGPS_MR_RRC_NOTIFICATION_REQUIRED
    rrcgps_initialize_l2_ack_params();
#endif
#endif

    if (cmd_ptr->cmd.cell_selected_meas_req.gtow_ho_active == TRUE)
    {
      return;
    }

    sib12_present = SIB12_ABSENT;

    rrcmeas_process_cell_selected_meas_req_for_idle_state();
    break;

  case RRC_SIB_CHANGE_IND:
#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
    if(cmd_ptr->cmd.sib_change_ind.sib_change_mask == SIB_19_BIT)
    {
      WRRC_MSG0_HIGH("ABSOL_PRI: Only SIB19 changed, send new priority and LTE neighbor info");
      rrcmeas_configure_l1_with_priority_info_eutra_cell_list();

      /* If SIB19 got removed, send MEAS_REQ 1/2 for WL1 to clear EUTRA list. */
      if(rrc_sibdb_return_sib_for_srv_cell(rrc_SIB19) != NULL)
      {
      return;
    }
    }
#endif

    WRRC_MSG0_HIGH("IntraF:SIB 11 got changed");

    /* First clear the SIB info */
    rrcmeas_clear_sib11();

    rrcmeas_initialize_meas_id_list();

    rrcmeas_initialize_cell_list();

    /* Now Read a new Inter-RAT Cell Info List */
#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
    if(rrcsib_is_sib11_11bis_12_read_deferred(DEFERRED_SIB11))
    {
      
      /* Initialize INTER-RAT CELL INFO LIST */
      rrcirat_initialize_cell_list();
      /* Initialize Inter-RAT Meas Id List */
      rrcirat_initialize_meas_id_list();

      rrcifreq_initialize_cell_list();

      l1_deferred_meas_from_sib_action = CLEAR_CELL_INFO_LIST;
      rrcmeas_send_deferred_meas_req(l1_deferred_meas_from_sib_action);
      break;
    }
    else
#endif
    if ( rrcmeas_read_sib11() == FAILURE )
    {
      WRRC_MSG0_HIGH("IntraF:SIB 11 values ignored.");
      rrcmeas_clear_sib11();

      rrcmeas_initialize_meas_id_list();

      rrcmeas_initialize_cell_list();

    }
    else
    {
      meas_req_incl = TRUE;
    }

    /* Even if SIB11 for intra-freq meas is not good, we would read SIB11 for inter-RAT */

    /* Initialize INTER-RAT CELL INFO LIST */
    rrcirat_initialize_cell_list();

    /* Initialize Inter-RAT Meas Id List */
    rrcirat_initialize_meas_id_list();

    /* Read Inter-RAT SIB11 */

    if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
    {
      WRRC_MSG0_HIGH("IntraF:Inter-RAT SIB11 ignored");
      rrcirat_initialize_cell_list();
    }
    else
    {
      meas_req_incl = TRUE;
    }

    if (meas_req_incl == TRUE)
    {
      /* SIB 11 has been successfully read*/
      rrcmeas_send_l1_cmd(rrcmeas_sib11, NULL, NULL, L1_SIB_PARMS);
    }

    meas_choice = L1_INTER_FREQ_SIB_PARMS;

    if (rrcifreq_read_sib11(rrcmeas_inter_freq_sib11) == FAILURE)
    {
      WRRC_MSG0_HIGH("IntraF:IFreq Cell List ignored");
      rrcifreq_initialize_cell_list();
    }
    else
    {
      rrcifreq_send_l1_cmd(&meas_choice, rrcmeas_inter_freq_sib11);
      WRRC_MSG0_HIGH("IntraF:IFreq Cell List sent");
    }

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
    rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif

    break;

  case RRC_MODE_STATUS_IND:
    WRRC_MSG0_HIGH("Single to dual mode in Idle state");

    /* First clear the SIB info */
    rrcmeas_clear_sib11();

    rrcmeas_initialize_meas_id_list();

    rrcmeas_initialize_cell_list();

    /* Now Read a new Inter-RAT Cell Info List */
#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
    if(rrcsib_is_sib11_11bis_12_read_deferred(DEFERRED_SIB11))
    {
      /* Initialize INTER-RAT CELL INFO LIST */
      rrcirat_initialize_cell_list();
      /* Initialize Inter-RAT Meas Id List */
      rrcirat_initialize_meas_id_list();
      l1_deferred_meas_from_sib_action = CLEAR_CELL_INFO_LIST;
      rrcmeas_send_deferred_meas_req(l1_deferred_meas_from_sib_action);
      break;
    }
    else
#endif

    if ( rrcmeas_read_sib11() == FAILURE )
    {
      WRRC_MSG0_HIGH("IntraF:SIB 11 values ignored.");
      rrcmeas_clear_sib11();

      rrcmeas_initialize_meas_id_list();

      rrcmeas_initialize_cell_list();

    }
    else
    {
      meas_req_incl = TRUE;
    }

    /* Even if SIB11 for intra-freq meas is not good, we would read SIB11 for inter-RAT */

    /* Initialize INTER-RAT CELL INFO LIST */
    rrcirat_initialize_cell_list();

    /* Initialize Inter-RAT Meas Id List */
    rrcirat_initialize_meas_id_list();

    /* Read Inter-RAT SIB11 */

    if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
    {
      WRRC_MSG0_HIGH("IntraF:Inter-RAT SIB11 ignored");
      rrcirat_initialize_cell_list();
    }
    else
    {
      meas_req_incl = TRUE;
    }

    if (meas_req_incl == TRUE)
    {
      /* SIB 11 has been successfully read*/
      rrcmeas_send_l1_cmd(rrcmeas_sib11, NULL, NULL, L1_SIB_PARMS);
    }

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
    rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif

    break;

  case RRC_EQ_PLMN_LIST_CHANGE_IND:
    WRRC_MSG0_HIGH("Ignoring RRC_EQ_PLMN_LIST_CHANGE_IND in IDLE");
    break;
  default:
    /* No other events expected in this substate */
    MSG_MED("Ignoring %x in substate %d",
      cmd_ptr->cmd_hdr.cmd_id, rrcmeas_current_substate, 0);
    break;

  } /* End of switch */

  return;
}

/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_CELL_DCH_STATE

DESCRIPTION

 Processes all events that are dispatched to RRC Measurement
 Establishment procedure in RRCMEAS DCH state.

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_process_cell_dch_state
(
rrc_cmd_type *cmd_ptr
)
{
  rrcllc_oc_set_status_e_type oc_status;

  if(state_transition_meas !=NULL)
  {
    state_transition_meas->hcs_used = FALSE;
  }

  switch ( cmd_ptr->cmd_hdr.cmd_id )
  {

  case RRC_CPHY_MEASUREMENT_IND:

    rrcmeas_process_cphy_meas_ind_in_dch_state(cmd_ptr);

    break;



    /* Check for this cmd if it is a DCH-->PCH transition */
  case RRC_CELL_SELECTED_MEAS_REQ:

   if(state_transition_meas == NULL)
   {
     ERR_FATAL("state_transition_meas ptr is NULL", 0,0,0);
   }
    /* Check if DCH->PCH is in progress */
   oc_status = rrcllc_get_ordered_config_status();

   /*get the UTRAN DRX cycle length coef only if the OC is
   set for Cell_PCH or URA_PCH state transition */
   if((oc_status == OC_SET_FOR_DCH_CELL_PCH_TRANS) ||
      (oc_status == OC_SET_FOR_DCH_URA_PCH_TRANS))
   {
     rrcmeas_handle_dch_to_pch_state_change();
     is_dch_to_pch_new_cell_ind_processed = TRUE;
   } /* End of if for DCH->PCH trans in progress */
   else
   {
     is_dch_to_pch_new_cell_ind_processed = FALSE;
     WRRC_MSG0_HIGH("Ignore new cell ind, DCH");
   }
   break;

  case RRC_STATE_CHANGE_IND:

    rrcmeas_process_state_change_ind_in_dch_state(cmd_ptr);

    break;

  case  RRC_DOWNLINK_SDU_IND:

    WRRC_MSG0_HIGH("MCM rcvd");

    rrcmeas_process_meas_ctrl_msg(cmd_ptr);

    break;

  case RRC_DOWNLINK_L2ACK_IND:

    rrcmeas_process_downlink_l2_ack(cmd_ptr);

    break;


  case RRC_LLC_CMD_CNF:
    if (cmd_ptr->cmd.rrc_llc_cnf.ll_cnf == RRC_LL_CPHY_MEAS_CTRL_CNF)
    {
      rrcmeas_process_l1_ack(cmd_ptr);
    }
    else
    {
      WRRC_MSG0_ERROR("Unknown cmd received from LLC");
    }

    break;


  case RRC_CMAC_MEAS_CTRL_CNF:
    {
      WRRC_MSG0_HIGH("Meas Cnf from MAC received");
      rrcmeas_process_mac_ack(cmd_ptr);
      break;
    }

  case RRC_CMAC_UL_TRAFFIC_IND:
    {
      rrc_proc_e_type rrc_proc_id;
      rrcllc_oc_process_state_e_type process_state;
      rrcllc_oc_set_status_e_type oc_set_status = rrcllc_get_ordered_config_state_and_proc(&rrc_proc_id, &process_state);

      WRRC_MSG1_HIGH("TrafficVolume Report %d received",cmd_ptr->cmd.cmac_ul_traffic_ind.meas_id);
      if((OC_SET_FOR_DCH_CELL_PCH_TRANS == oc_set_status) ||
         (OC_SET_FOR_DCH_URA_PCH_TRANS == oc_set_status))
      {
        WRRC_MSG0_HIGH("OC set for DCH->PCH");
        /*If proc is not waiting for L2, then proc has started processing the DCH->PCH, ignore the TVM report*/
        if(!(rrcrb_proc_waiting_for_l2_ack(rrc_proc_id)))
        {
          WRRC_MSG0_HIGH("Proc is not waiting for L2 ACK, ignore the measurement report");
          return;
        }
      }

      /* Max 12 pending rpts allowed in rlc queue */
      if((cmd_ptr->cmd.cmac_ul_traffic_ind.report_transfer_mode == ACK_MODE)
        && (rrcmeas_pending_rpt > (uint8) MAX_PEND_MEAS_RPT))
      {
        WRRC_MSG1_HIGH("Ignoring tvm rpt, pending rpts %d > 12",rrcmeas_pending_rpt);
        return;
      }
#ifdef FEATURE_WCDMA_DEBUG_ATTEMPT_FULL_SRCH
      if(TRUE == rrc_enable_psc_lock_nv)
      {
        WRRC_MSG0_HIGH("Ignoring tvm rpt as psc lock nv is Enabled");
        return;
      }
#endif
      rrctvm_send_traffic_vol_meas_report(cmd_ptr);
      break;
    }


  case RRC_DELETE_MEAS_REQ:
    {
      WRRC_MSG1_HIGH("Receieved C.Mode Delete Meas = %d",cmd_ptr->cmd.cm_ind.meas_id);
      rrcmeas_process_delete_meas_id(&cmd_ptr->cmd.cm_ind.meas_id);
      break;
    }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  case RRC_MEASUREMENT_IND:
    {
      WRRC_MSG0_HIGH("POS: A-GPS Meas Rpt received");
      /* Max 12 pending rpts allowed in rlc queue */
      if((cmd_ptr->cmd.meas_rpt_ind.meas_rpt->tranfer_mode == (uint8)MODE_ACKNOWLEDGED)
        && (rrcmeas_pending_rpt > (uint8) MAX_PEND_MEAS_RPT))
      {
        WRRC_MSG1_HIGH("Ignoring A-GPS rpt, pending rpts %d > 12",rrcmeas_pending_rpt);
        return;
      }
#ifdef FEATURE_WCDMA_DEBUG_ATTEMPT_FULL_SRCH
      if(TRUE == rrc_enable_psc_lock_nv)
      {
        WRRC_MSG0_HIGH("Ignoring A-GPS rpt, as psc lock nv is Enabled");
        return;
      }
#endif

      rrcgps_send_meas_report(cmd_ptr);
      break;
    }
#endif
    /* To add other command here as they are defined */

  case RRC_EQ_PLMN_LIST_CHANGE_IND:
    WRRC_MSG0_HIGH("Ignoring RRC_EQ_PLMN_LIST_CHANGE_IND in DCH");
    break;

  case RRC_MODE_STATUS_IND:
      WRRC_MSG0_HIGH("DUAL:No processing by Meas is DCH state.");
      break;

  default:

    /* No other events expected in this substate */

    MSG_MED("Ignoring %x in substate %d",
      cmd_ptr->cmd_hdr.cmd_id, rrcmeas_current_substate, 0);

    break;

  } /* End of switch */

  return;

}


/*===========================================================================

FUNCTION     RRCMEAS_PROCESS_CELL_FACH_STATE

DESCRIPTION

 Processes all the messages received in RRCMEAS FACH state
 of RRC Measurements procedure.

DEPENDENCIES

 None.

RETURN VALUE

 None.

SIDE EFFECTS

 None

===========================================================================*/
void rrcmeas_process_cell_fach_state
(
rrc_cmd_type *cmd_ptr
)
{
  rrc_SysInfoType12 *sib12_ptr = NULL;

/*added for checking FACH->DCH transition*/
  rrcllc_oc_set_status_e_type oc_status;

  l1_inter_freq_cell_list_struct_type *inter_freq_parms = rrc_malloc(sizeof(l1_inter_freq_cell_list_struct_type));
  l1_meas_ctrl_enum_type meas_choice;



  boolean meas_req_incl = FALSE;


  switch ( cmd_ptr->cmd_hdr.cmd_id )
  {
  case RRC_CPHY_MEASUREMENT_IND:
    WRRC_MSG0_HIGH("Ignore L1 Meas Report in state FACH");
    /* Only send traffic vol meas report */
    break;

  case RRC_STATE_CHANGE_IND:
    rrcmeas_process_state_change_ind_in_fach_state(cmd_ptr);
    break;

  case RRC_CELL_SELECTED_MEAS_REQ:
    rrcmeas_handle_cell_sel_meas_req_in_fach();
    break;

  case RRC_SIB_CHANGE_IND:
  case RRC_EQ_PLMN_LIST_CHANGE_IND:
    if(cmd_ptr->cmd_hdr.cmd_id == RRC_SIB_CHANGE_IND)
    {
      WRRC_MSG0_HIGH("SIBs changed in CELL_FACH");
#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
      if(cmd_ptr->cmd.sib_change_ind.sib_change_mask == SIB_19_BIT)
      {
        WRRC_MSG0_HIGH("ABSOL_PRI: Only SIB19 changed, send new priority and LTE neighbor info");
        rrcmeas_configure_l1_with_priority_info_eutra_cell_list();

        /* If SIB19 got removed, send MEAS_REQ 1/2 for WL1 to clear EUTRA list. */        
        if(rrc_sibdb_return_sib_for_srv_cell(rrc_SIB19) != NULL)
        {
           rrc_free(inter_freq_parms);
        return;
      }
      }
#endif
      /* Process TVM */
      rrctvm_process_sib_change_notification(cmd_ptr->cmd.sib_change_ind.sib_change_mask);
    }
    else
    {
      WRRC_MSG0_HIGH("Processing Eq PLMN chng in FACH");
    }

    /* First clear the SIB info */
    rrcmeas_clear_sib11();

    rrcmeas_initialize_meas_id_list();

    rrcmeas_initialize_cell_list();

    /* save the meas id variable in a tmp location */
     WCDMA_MEMCPY(tmp_intra_freq_meas_id_list, 
                  MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                  intra_freq_meas_id_list, 
                  MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

    if ( rrcmeas_read_sib11() == FAILURE )
    {
      WRRC_MSG0_HIGH("Intra-Freq SIB 11 ignored");
      rrcmeas_clear_sib11();

      rrcmeas_initialize_meas_id_list();

      rrcmeas_initialize_cell_list();

    }
    else
    {
      meas_req_incl = TRUE;
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          WRRC_MSG0_HIGH("Undo changes to Meas id varible from SIB11");
          WCDMA_MEMCPY(intra_freq_meas_id_list, 
                       MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                       tmp_intra_freq_meas_id_list, 
                       MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

          /* Everything is O.K. Read SIB12 */
          rrcmeas_read_sib12(sib12_ptr, rrcmeas_sib12);
        }
      } /* Else of SIB12 present */
    }

    /* Read Inter-RAT SIB11 */
    if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
    {
      WRRC_MSG0_HIGH("Inter-RAT SIB11 ignored");
      rrcirat_initialize_cell_list();
    }
    else
    {
      meas_req_incl = TRUE;
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          /* Everything is O.K. Read SIB12 */
          if(rrcirat_read_sib12(sib12_ptr, rrcmeas_sib12) == FAILURE)
          {
            WRRC_MSG0_HIGH("Inter-RAT SIB12 ignored");
            rrcirat_initialize_cell_list();
          }
        }
      } /* Else of SIB12 present */
    }

    if (meas_req_incl == TRUE)
    {
      if((sib12_present == SIB12_PRESENT) && (sib12_ptr != NULL))
      {
        /* SIB 12 has been successfully read */
        WRRC_MSG0_HIGH("Send SIB 12 Meas Req to L1");
        rrcmeas_send_l1_cmd(rrcmeas_sib12, NULL, NULL, L1_SIB_PARMS);
      }
      else
      {
        /* SIB 11 has been successfully read*/
        WRRC_MSG0_HIGH("Send SIB 11 Meas Req to L1");
        rrcmeas_send_l1_cmd(rrcmeas_sib11, NULL, NULL, L1_SIB_PARMS);
      }
    }

    if (rrcifreq_read_sib11(inter_freq_parms) == FAILURE)
    {
      WRRC_MSG0_HIGH("IFreq:Cell List ignored SIB11");
      rrcifreq_initialize_cell_list();
    }
    if(((rrc_SysInfoType11*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11)) != NULL)
    {
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          /* Everything is O.K. Read SIB12 */
          if(rrcifreq_read_sib12(sib12_ptr, inter_freq_parms, rrcmeas_inter_freq_sib12) == FAILURE)
          {
            WRRC_MSG0_HIGH("IFreq:Cell List ignored from SIB12");
            rrcifreq_initialize_cell_list();
          }
          else
          {
             meas_choice = L1_INTER_FREQ_SIB_PARMS;
             rrcifreq_send_l1_cmd(&meas_choice, rrcmeas_inter_freq_sib12);
             WRRC_MSG0_HIGH("IFreq:Cell List sent SIB12");
          }
        }
      } /* Else of SIB12 present */

      if((sib12_present == SIB12_ABSENT) && (inter_freq_parms->num_cell_add != 0))
      {
        meas_choice = L1_INTER_FREQ_SIB_PARMS;
        rrcifreq_send_l1_cmd(&meas_choice, inter_freq_parms);
        WRRC_MSG0_HIGH("IFreq:Cell List sent SIB11");
      }
    }

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
    rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif


    break;

  case RRC_DOWNLINK_L2ACK_IND:

    rrcmeas_process_downlink_l2_ack(cmd_ptr);

    break;

  case RRC_CMAC_UL_TRAFFIC_IND:

    WRRC_MSG0_HIGH("TrafficVolume Report received");
    {
      rrc_proc_e_type rrc_proc_id;
      rrcllc_oc_process_state_e_type process_state;
      rrcllc_oc_set_status_e_type oc_set_status = rrcllc_get_ordered_config_state_and_proc(&rrc_proc_id, &process_state);
      if((OC_SET_FOR_FACH_CELL_PCH_TRANS == oc_set_status) ||
         (OC_SET_FOR_FACH_URA_PCH_TRANS == oc_set_status))
      {
        WRRC_MSG0_HIGH("OC set for FACH->PCH");
        /*If proc is not waiting for L2, then proc has started processing the FACH->PCH, ignore the TVM report*/
        if(!(rrcrb_proc_waiting_for_l2_ack(rrc_proc_id)))
        {
          WRRC_MSG0_HIGH("Proc is not waiting for L2 ACK, ignore the measurement report");
          rrc_free(inter_freq_parms);
          return;
        }
      }
    }

    /* Max 12 pending rpts allowed in rlc queue */
    if((cmd_ptr->cmd.cmac_ul_traffic_ind.report_transfer_mode == ACK_MODE)
      && (rrcmeas_pending_rpt > (uint8) MAX_PEND_MEAS_RPT))
    {
      WRRC_MSG1_HIGH("Ignoring tvm rpt, pending rpts %d > 12",rrcmeas_pending_rpt);
      rrc_free(inter_freq_parms);
      return;
    }
#ifdef FEATURE_WCDMA_DEBUG_ATTEMPT_FULL_SRCH
    if(TRUE == rrc_enable_psc_lock_nv)
    {
      WRRC_MSG0_HIGH("Ignoring tvm rpt as psc lock nv is Enabled");
      rrc_free(inter_freq_parms);
      return;
    }
#endif

    if(rrcrcr_is_proc_active() == FALSE)
    {
      rrctvm_send_traffic_vol_meas_report(cmd_ptr);
    }
    else
    {
      WRRC_MSG0_HIGH("TrafficVolume Report ignored rcr active");
    }
    break;


  case  RRC_DOWNLINK_SDU_IND:

    WRRC_MSG0_MED("MCM received");

    rrcmeas_process_meas_ctrl_msg(cmd_ptr);

    break;

  case RRC_CMAC_MEAS_CTRL_CNF:

    WRRC_MSG0_HIGH("Meas Cnf from MAC received");
    rrcmeas_process_mac_ack(cmd_ptr);
    break;


#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  case RRC_MEASUREMENT_IND:

        WRRC_MSG0_HIGH("POS: FACH:A-GPS Meas Rpt received");
        rrcgps_send_meas_report(cmd_ptr);
        break;


#endif

  case RRC_MODE_STATUS_IND:
      /* Check if FACH->DCH */
      oc_status = rrcllc_get_ordered_config_status();

      if(!(oc_status == OC_SET_FOR_CELL_DCH))
      {

        WRRC_MSG0_HIGH("DUAL:Dual Mode Change Rcvd from MCM in FACH");

        /* First clear the SIB info */
        rrcmeas_clear_sib11();

        rrcmeas_initialize_meas_id_list();

        rrcmeas_initialize_cell_list();

        /* save the meas id variable in a tmp location */
        WCDMA_MEMCPY(tmp_intra_freq_meas_id_list, 
                     MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                     intra_freq_meas_id_list, 
                     MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

        if ( rrcmeas_read_sib11() == FAILURE )
        {
          WRRC_MSG0_HIGH("DUAL:Intra-Freq SIB 11 ignored");
          rrcmeas_clear_sib11();

          rrcmeas_initialize_meas_id_list();

          rrcmeas_initialize_cell_list();

        }
        else
        {
          meas_req_incl = TRUE;
          /* check for SIB 12 and use it if present */
          if ( sib12_present == SIB12_ABSENT )
          {
            MSG_LOW("DUAL:SIB12 not present", 0,0,0);
          }
          else
          {
            WRRC_MSG0_HIGH("DUAL:SIB12 present, processing SIB12");

            if((sib12_ptr = (rrc_SysInfoType12*)
              rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
            {
              WRRC_MSG0_HIGH("DUAL:SIB 12 empty.");
            }
            else
            {
              WRRC_MSG0_HIGH("DUAL:Undo changes to Meas id varible from SIB11");
              WCDMA_MEMCPY(intra_freq_meas_id_list, 
                           MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                           tmp_intra_freq_meas_id_list, 
                           MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

             /* Everything is O.K. Read SIB12 */
              rrcmeas_read_sib12(sib12_ptr, rrcmeas_sib12);
            }
          } /* Else of SIB12 present */
        }

        /* Read Inter-RAT SIB11 */
        if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
        {
          WRRC_MSG0_HIGH("DUAL:Inter-RAT SIB11 ignored");
          rrcirat_initialize_cell_list();
        }
        else
        {
          meas_req_incl = TRUE;
          /* check for SIB 12 and use it if present */
          if ( sib12_present == SIB12_ABSENT )
          {
            MSG_LOW("DUAL:SIB12 not present", 0,0,0);
          }
          else
          {
            WRRC_MSG0_HIGH("DUAL:SIB12 present, processing SIB12");

            if((sib12_ptr = (rrc_SysInfoType12*)
              rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
            {
              WRRC_MSG0_HIGH("DUAL:SIB 12 empty.");
            }
            else
            {
              /* Everything is O.K. Read SIB12 */
              if(rrcirat_read_sib12(sib12_ptr, rrcmeas_sib12) == FAILURE)
              {
                WRRC_MSG0_HIGH("DUAL:Inter-RAT SIB12 ignored");
                rrcirat_initialize_cell_list();
              }
            }
          } /* Else of SIB12 present */
        }

        if (meas_req_incl == TRUE)
        {
          if((sib12_present == SIB12_PRESENT) && (sib12_ptr != NULL))
          {
            /* SIB 12 has been successfully read */
            WRRC_MSG0_HIGH("DUAL:Send SIB 12 Meas Req to L1");
            rrcmeas_send_l1_cmd(rrcmeas_sib12, NULL, NULL, L1_SIB_PARMS);
          }
          else
          {
            /* SIB 11 has been successfully read*/
            WRRC_MSG0_HIGH("DUAL:Send SIB 11 Meas Req to L1");
            rrcmeas_send_l1_cmd(rrcmeas_sib11, NULL, NULL, L1_SIB_PARMS);
          }
        }
      }
      else
      {
        WRRC_MSG0_HIGH("DUAL:Measurement will dump it if FACH->DCH is going on");
      }

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
    rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif

    break;


    /* To add other command here as they are defined */
  default:

    /* No other events expected in this substate */
    MSG_MED("Ignoring %x in substate %d",
      cmd_ptr->cmd_hdr.cmd_id, rrcmeas_current_substate, 0);

    break;

   } /* End of switch */
   rrc_free(inter_freq_parms);
   return;
}  /*lint +esym(550,sib11_ptr) */

/*===========================================================================

FUNCTION   rrcmeas_handle_cell_sel_meas_req_in_fach

DESCRIPTION 

  Handles cell sel meas req / new cell ind in cell FACH state
 
DEPENDENCIES

  None

RETURN VALUE

  None. 

SIDE EFFECTS

  None

===========================================================================*/

void rrcmeas_handle_cell_sel_meas_req_in_fach( void )
{
    rrc_scr_code_type psc;
    uint8 count = 0;

  boolean meas_req_incl = FALSE;
  
  rrc_SysInfoType12 *sib12_ptr = NULL;
  

  
  l1_inter_freq_cell_list_struct_type *inter_freq_parms = rrc_malloc(sizeof(l1_inter_freq_cell_list_struct_type));
  l1_meas_ctrl_enum_type meas_choice;
  WRRC_MSG2_HIGH("new cell ind, CELL_FACH. Old SCR %d, New SCR %d, FACH",last_scr_code,rrc_ccm_get_curr_camped_psc());

  psc = rrc_ccm_get_curr_camped_psc();

  last_scr_code = psc;
#if defined (FEATURE_CGPS)
  /* Set Cell/PLMN info for LSM */
   rrcmeas_set_cell_plmn_info();
#endif


  /* Trash CM params from TOC config */
  rrcllc_initialize_cm_parms();

  /* First clear the SIB info */
  rrcmeas_clear_sib11();

  sib12_present = SIB12_ABSENT;

  /* Clear all Meas */
  rrcmeas_initialize_meas_id_list();

  rrcmeas_initialize_cell_list();

  /* Save Meas which are owned by MCM */

  MSG_LOW("Check if MCM owns a TVM",0,0,0);

  /* The fn update tvm_meas_id_list and sends cmd to MAC.
   In case of failure, it does the initialisation */
   rrctvm_process_tvm_on_cell_reselection();

   /* save the meas id variable in a tmp location */
   WCDMA_MEMCPY(tmp_intra_freq_meas_id_list, 
                MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                intra_freq_meas_id_list, 
                MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

   if ( rrcmeas_read_sib11() == FAILURE )
   {
      WRRC_MSG0_HIGH("Intra-Freq SIB 11 ignored");
      rrcmeas_clear_sib11();

      rrcmeas_initialize_meas_id_list();

      rrcmeas_initialize_cell_list();

   }
   else
   {
      meas_req_incl = TRUE;
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

         if((sib12_ptr = (rrc_SysInfoType12*)
            rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
         {
          WRRC_MSG0_HIGH("SIB 12 empty.");
         }
         else
         {
          WRRC_MSG0_HIGH("Undo changes to Meas id varible from SIB11");
             WCDMA_MEMCPY(intra_freq_meas_id_list, 
                          MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                          tmp_intra_freq_meas_id_list, 
                          MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));
             /* Everything is O.K. Read SIB12 */
             rrcmeas_read_sib12(sib12_ptr, rrcmeas_sib12);
         }
      } /* Else of SIB12 present */
   }

    rrcirat_initialize_cell_list();

    /* Read Inter-RAT SIB11 */
    if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
    {
        WRRC_MSG0_HIGH("Inter-RAT SIB11 ignored");
       rrcirat_initialize_cell_list();
    }
    else
    {
        meas_req_incl = TRUE;
        /* check for SIB 12 and use it if present */
        if ( sib12_present == SIB12_ABSENT )
        {
            MSG_LOW("SIB12 not present", 0,0,0);
        }
        else
        {
           WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

           if((sib12_ptr = (rrc_SysInfoType12*)
            rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
           {
              WRRC_MSG0_HIGH("SIB 12 empty.");
           }
           else
           {
               /* Everything is O.K. Read SIB12 */
               if(rrcirat_read_sib12(sib12_ptr, rrcmeas_sib12) == FAILURE)
               {
                   WRRC_MSG0_HIGH("Inter-RAT SIB12 ignored");
                   rrcirat_initialize_cell_list();
               }
           }
        } /* Else of SIB12 present */
     }

     if (meas_req_incl == TRUE)
     {
          if((sib12_present == SIB12_PRESENT) && (sib12_ptr != NULL))
          {
             /* SIB 12 has been successfully read*/
             WRRC_MSG0_HIGH("Send SIB 12 Meas Req to L1");
             rrcmeas_send_l1_cmd(rrcmeas_sib12, NULL, NULL, L1_SIB_PARMS);
          }
          else
          {
              /* SIB 11 has been successfully read*/
              WRRC_MSG0_HIGH("Send SIB 11 Meas Req to L1");
              rrcmeas_send_l1_cmd(rrcmeas_sib11, NULL, NULL, L1_SIB_PARMS);
          }
      }

      /* As per specs, delete all inter Freq Meas/patterns on Cell Reselection in CELL_FACH */

      /* Call fn in rrcllcoc.c to update transition config. Declare fn in rrcllc.h */
      /* Just Initialize the compressed mode gap patterns info */

      for (count = 0; count < MAX_INTER_FREQ_MEAS; count++)
      {
          if (inter_freq_meas_id_list[count].meas_id != INVALID_MEAS_ID)
          {
             /* Tell L1 too to delete the meas */
             state_transition_meas->meas_action = L1_MEAS_DELETE;

             state_transition_meas->meas_id = inter_freq_meas_id_list[count].meas_id;

             state_transition_meas->meas_type = L1_INTER_FREQ;

             WRRC_MSG1_HIGH("IFreq:Tell L1 to delete %d meas", state_transition_meas->meas_id);

             rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);
          }
      }

      rrcifreq_initialize_cell_list();

      if (rrcifreq_read_sib11(inter_freq_parms) == FAILURE)
      {
         WRRC_MSG0_HIGH("IFreq:Cell List ignored from SIB11");
          rrcifreq_initialize_cell_list();
      }

      if(((rrc_SysInfoType11*) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11)) != NULL)
      {
           if ( sib12_present == SIB12_ABSENT )
           {
              MSG_LOW("SIB12 not present", 0,0,0);
           }
           else
           {
              WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

              if((sib12_ptr = (rrc_SysInfoType12*)
                rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
              {
                  WRRC_MSG0_HIGH("SIB 12 empty.");
              }
              else
              {
                  /* Everything is O.K. Read SIB12 */
                  if(rrcifreq_read_sib12(sib12_ptr, inter_freq_parms, rrcmeas_inter_freq_sib12) == FAILURE)
                  {
                       WRRC_MSG0_HIGH("IFreq:Cell List ignored from SIB12");
                      rrcifreq_initialize_cell_list();
                  }
                  else
                  {
                      meas_choice = L1_INTER_FREQ_SIB_PARMS;
                      rrcifreq_send_l1_cmd(&meas_choice, rrcmeas_inter_freq_sib12);
                      WRRC_MSG0_HIGH("IFreq:Cell List sent SIB12");
                  }
               }
          } /* Else of SIB12 present */

          if((sib12_present == SIB12_ABSENT) && (inter_freq_parms->num_cell_add != 0))
          {
              meas_choice = L1_INTER_FREQ_SIB_PARMS;
              rrcifreq_send_l1_cmd(&meas_choice, inter_freq_parms);
              WRRC_MSG0_HIGH("IFreq:Cell List sent SIB11");
          }
    }

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
  rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif
rrc_free(inter_freq_parms);
}


/*===========================================================================

FUNCTION    RRCMEAS_PROCESS_PCH_STATE

DESCRIPTION

 Processes all the messages received in RRCMEAS PCH state
 of RRC Measurements procedure.

DEPENDENCIES

  None.

RETURN VALUE

  None.

SIDE EFFECTS

  None

===========================================================================*/

void rrcmeas_process_pch_state
(
rrc_cmd_type *cmd_ptr
)
{
/*lint -esym(550,sib11_ptr) */

  l1_inter_freq_cell_list_struct_type *inter_freq_parms= rrc_malloc(sizeof(l1_inter_freq_cell_list_struct_type));
  rrc_SysInfoType12 *sib12_ptr = NULL;
  l1_meas_ctrl_enum_type meas_choice;

  uint8 count = 0;

  mac_ul_traffic_meas_config_type traffic_vol_params;

  boolean meas_req_incl = FALSE;

  rrc_scr_code_type psc;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  uint8 cnt = 0;
 rrc_meas_params_struct_type *pos_cmd ;
  pos_cmd = &temp_gps;
  memset(pos_cmd,0,sizeof(rrc_meas_params_struct_type));

  pos_cmd->params_type = (uint8) RRC_STATE_CHANGE_PARMS;

#endif

  switch ( cmd_ptr->cmd_hdr.cmd_id )
  {

  case RRC_CPHY_MEASUREMENT_IND:

    WRRC_MSG0_HIGH("Ignore L1 Meas Report in state PCH");

    break;



#if defined (FEATURE_CGPS_UMTS_CP_WCDMA) 
#if defined FEATURE_LSM_PCH_REPORTING
#error code not present
#endif   /* FEATURE_LSM_PCH_REPORTING */
#endif  /* FEATURE_MMGSP || FEATURE_CGPS_UMTS_CP_WCDMA */


  case RRC_STATE_CHANGE_IND:


    if (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CELL_FACH)
    {
      WRRC_MSG1_HIGH("%d PCH->FACH ind",cmd_ptr->cmd.state_change_ind.previous_state);
      rrcmeas_current_substate = RRCMEAS_CELL_FACH;

      psc = rrc_ccm_get_curr_camped_psc();

      WRRC_MSG2_HIGH("Old SCR %d, New SCR %d, DCH", last_scr_code,psc);

      last_scr_code = psc;
      if(rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
      {
        rrc_csp_send_cell_param_req_for_pch_fach();
      }
#if defined (FEATURE_CGPS)
      /* Set Cell/PLMN info for LSM */
      rrcmeas_set_cell_plmn_info();
#ifdef FEATURE_LSM_PCH_REPORTING
      #error code not present
#endif
#endif
      /* MAC should resume reporting. No explicit cmd reqd */
    }
    else if (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_DISCONNECTED)
    {
      WRRC_MSG1_HIGH("%d PCH->Idle state(4/5:CELL_PCH)", cmd_ptr->cmd.state_change_ind.previous_state);
      /* reset pending rpt counter on state change from dch */
      rrcmeas_pending_rpt = 0;
      rrcmeas_current_substate = RRCMEAS_IDLE;

      trans_id = INVALID_TRANSACTION_ID;

      /* Trash SIB11 values */
      rrcmeas_clear_sib11();

      rrcmeas_initialize_meas_id_list();

      rrcmeas_initialize_cell_list();

      rrcmeas_initialize_transaction_id_list();

      sib12_present = SIB12_ABSENT;

      if(ordered_config_ptr != NULL)
      {
        memset(ordered_config_ptr->tgp_seq_info, 0, sizeof(ordered_config_ptr->tgp_seq_info));
      }
      if(current_config_ptr != NULL)
      {
        memset(current_config_ptr->tgp_seq_info, 0, sizeof(current_config_ptr->tgp_seq_info));
      }

      rrcirat_initialize_cell_list();

      rrcirat_initialize_meas_id_list();


      rrcifreq_initialize_meas_id_list();


      rrcifreq_initialize_cell_list();


      /* Send cmd to MAC to delete Meas */
      traffic_vol_params.meas_cmd = MAC_TRAFFIC_MEAS_DELETE_ALL;

      traffic_vol_params.config_conf_ind = FALSE;

      rrctvm_send_mac_cmd(&traffic_vol_params);

      rrctvm_initialize();

      rrctvm_initialize_measurement_identity();

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
            for ( count = 0; count < MAX_POS_MEAS; count++ )
            {
                /* Set all positions to vacant and make PSC as invalid */
                if (pos_meas_id_list[count].meas_id != INVALID_MEAS_ID)
                {
                    /* Cmd type */
                    pos_cmd->u.trans_params.trans_cmd_type = (uint8) RRC_MEAS_DELETE;

                    /* Meas Id */
                    pos_cmd->u.trans_params.meas_id = pos_meas_id_list[count].meas_id;

                    WRRC_MSG1_HIGH("Indicate LSM to delete %d Meas", pos_cmd->u.trans_params.meas_id);

                    rrcgps_send_lsm_cmd(pos_cmd);

                    pos_meas_id_list[count].meas_id = INVALID_MEAS_ID;

                    pos_meas_id_list[count].meas_validity = NOT_PRESENT;

                    pos_meas_id_list[count].rpt_crit = NOT_AVAILABLE;

                    /* Also initialize additional meas */
                    for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
                        pos_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
                }
            }

#endif


      break;
    }
    else
    {
      WRRC_MSG1_ERROR("Incorrect state trans. New state %d", cmd_ptr->cmd.state_change_ind.new_state);
      break;
    }


    break;

  case RRC_CMAC_UL_TRAFFIC_IND:
    WRRC_MSG0_HIGH("Ignore MAC Meas Report in state PCH");

    break;

  case RRC_CELL_SELECTED_MEAS_REQ:
    WRRC_MSG2_HIGH("new cell ind, PCH state. Old SCR %d, New SCR %d, DCH",last_scr_code,rrc_ccm_get_curr_camped_psc());

    psc = rrc_ccm_get_curr_camped_psc();

    last_scr_code = psc;
#if defined (FEATURE_CGPS)
    /* Set Cell/PLMN info for LSM */
    rrcmeas_set_cell_plmn_info();
#endif

    /* Trash CM params from TOC config */
    rrcllc_initialize_cm_parms();

    /* First clear the SIB info */
    rrcmeas_clear_sib11();

    sib12_present = SIB12_ABSENT;

    rrcmeas_initialize_meas_id_list();

    rrcmeas_initialize_cell_list();

    /* Save Meas which are owned by MCM */

    WRRC_MSG0_HIGH("Check if MCM owns a TVM");

    /* The fn update tvm_meas_id_list and sends cmd to MAC.
    In case of failure, it does the initialisation */
    rrctvm_process_tvm_on_cell_reselection();

    /* save the meas id variable in a tmp location */
    WCDMA_MEMCPY(tmp_intra_freq_meas_id_list, 
                 MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                 intra_freq_meas_id_list, 
                 MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));


    if ( rrcmeas_read_sib11() == FAILURE )
    {
      WRRC_MSG0_HIGH("Intra-Freq SIB 11 ignored");
      rrcmeas_clear_sib11();

      rrcmeas_initialize_meas_id_list();

      rrcmeas_initialize_cell_list();

    }
    else
    {
      meas_req_incl = TRUE;
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          WRRC_MSG0_HIGH("Undo changes to Meas id varible from SIB11");
          WCDMA_MEMCPY(intra_freq_meas_id_list, 
                       MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                       tmp_intra_freq_meas_id_list, 
                       MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

          /* Everything is O.K. Read SIB12 */
          rrcmeas_read_sib12(sib12_ptr, rrcmeas_sib12);
        }
      } /* Else of SIB12 present */
    }

    /* Read Inter-RAT SIB11 */
    if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
    {
      WRRC_MSG0_HIGH("Inter-RAT SIB11 ignored");
      rrcirat_initialize_cell_list();
    }
    else
    {
      meas_req_incl = TRUE;
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          /* Everything is O.K. Read SIB12 */
          if(rrcirat_read_sib12(sib12_ptr, rrcmeas_sib12) == FAILURE)
          {
            WRRC_MSG0_HIGH("Inter-RAT SIB12 ignored");
            rrcirat_initialize_cell_list();
          }
        }
      } /* Else of SIB12 present */
    }

    if (meas_req_incl == TRUE)
    {
      if((sib12_present == SIB12_PRESENT) && (sib12_ptr != NULL))
      {
        /* SIB 12 has been successfully read*/
        WRRC_MSG0_HIGH("Send SIB 12 Meas Req to L1");
        rrcmeas_send_l1_cmd(rrcmeas_sib12, NULL, NULL, L1_SIB_PARMS);
      }
      else
      {
        /* SIB 11 has been successfully read*/
        WRRC_MSG0_HIGH("Send SIB 11 Meas Req to L1");
        rrcmeas_send_l1_cmd(rrcmeas_sib11, NULL, NULL, L1_SIB_PARMS);
      }
    }

    /* As per specs, delete all inter Freq Meas/patterns on Cell Reselection in CELL/URA PCH */

    for (count = 0; count < MAX_INTER_FREQ_MEAS; count++)
    {
      if (inter_freq_meas_id_list[count].meas_id != INVALID_MEAS_ID)
      {
        /* Tell L1 too to delete the meas */
        state_transition_meas->meas_action = L1_MEAS_DELETE;

        state_transition_meas->meas_id = inter_freq_meas_id_list[count].meas_id;

        state_transition_meas->meas_type = L1_INTER_FREQ;

        WRRC_MSG1_HIGH("IFreq:Tell L1 to delete %d meas", state_transition_meas->meas_id);

        rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);
      }
    }

    rrcifreq_initialize_cell_list();
    if (rrcifreq_read_sib11(inter_freq_parms) == FAILURE)
    {
      WRRC_MSG0_HIGH("IFreq:Cell List ignored SIB11");
      rrcifreq_initialize_cell_list();
    }
    if(((rrc_SysInfoType11*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11)) != NULL)
    {
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          /* Everything is O.K. Read SIB12 */
          if(rrcifreq_read_sib12(sib12_ptr, inter_freq_parms, rrcmeas_inter_freq_sib12) == FAILURE)
          {
            WRRC_MSG0_HIGH("IFreq:Cell List ignored from SIB12");
            rrcifreq_initialize_cell_list();
          }
          else
          {
             meas_choice = L1_INTER_FREQ_SIB_PARMS;
             rrcifreq_send_l1_cmd(&meas_choice, rrcmeas_inter_freq_sib12);
             WRRC_MSG0_HIGH("IFreq:Cell List sent SIB12");
          }
        }
      } /* Else of SIB12 present */

      if((sib12_present == SIB12_ABSENT) && (inter_freq_parms->num_cell_add != 0))
      {
        meas_choice = L1_INTER_FREQ_SIB_PARMS;
        rrcifreq_send_l1_cmd(&meas_choice, inter_freq_parms);
        WRRC_MSG0_HIGH("IFreq:Cell List sent SIB11");
      }
    }

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
    rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif

    break;
  case RRC_SIB_CHANGE_IND:
  case RRC_EQ_PLMN_LIST_CHANGE_IND:
    if(cmd_ptr->cmd_hdr.cmd_id == RRC_SIB_CHANGE_IND)
    {
      WRRC_MSG0_HIGH("SIBs changed in in PCH");
#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
      if(cmd_ptr->cmd.sib_change_ind.sib_change_mask == SIB_19_BIT)
      {
        WRRC_MSG0_HIGH("ABSOL_PRI: Only SIB19 changed, send new priority and LTE neighbor info");
        rrcmeas_configure_l1_with_priority_info_eutra_cell_list();

        /* If SIB19 got removed, send MEAS_REQ 1/2 for WL1 to clear EUTRA list. */        
        if(rrc_sibdb_return_sib_for_srv_cell(rrc_SIB19) != NULL)
        {
          rrc_free(inter_freq_parms);
        return;
      }
      }
#endif
      /* Process TVM */
      rrctvm_process_sib_change_notification(cmd_ptr->cmd.sib_change_ind.sib_change_mask);
    }
    else
    {
      WRRC_MSG0_HIGH("Processing Eq PLMN chng in PCH");
    }
    /* First clear the SIB info */
    rrcmeas_clear_sib11();

    rrcmeas_initialize_meas_id_list();
    rrcmeas_initialize_cell_list();

    /* save the meas id variable in a tmp location */
    WCDMA_MEMCPY(tmp_intra_freq_meas_id_list, 
                 MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                 intra_freq_meas_id_list, 
                 MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

    if ( rrcmeas_read_sib11() == FAILURE )
    {
      WRRC_MSG0_HIGH("Intra-Freq SIB 11 ignored");
      rrcmeas_clear_sib11();

      rrcmeas_initialize_meas_id_list();

      rrcmeas_initialize_cell_list();

    }
    else
    {
      meas_req_incl = TRUE;
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          WRRC_MSG0_HIGH("Undo changes to Meas id varible from SIB11");
          WCDMA_MEMCPY(intra_freq_meas_id_list, 
                       MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                       tmp_intra_freq_meas_id_list, 
                       MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

          /* Everything is O.K. Read SIB12 */
          rrcmeas_read_sib12(sib12_ptr, rrcmeas_sib12);
        }
      } /* Else of SIB12 present */
    }

    /* Read Inter-RAT SIB11 */
    if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
    {
      WRRC_MSG0_HIGH("Inter-RAT SIB11 ignored");
      rrcirat_initialize_cell_list();
    }
    else
    {
      meas_req_incl = TRUE;
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          /* Everything is O.K. Read SIB12 */
          if(rrcirat_read_sib12(sib12_ptr, rrcmeas_sib12) == FAILURE)
          {
            WRRC_MSG0_HIGH("Inter-RAT SIB12 ignored");
            rrcirat_initialize_cell_list();
          }
        }
      } /* Else of SIB12 present */
    }

    if (meas_req_incl == TRUE)
    {
      if((sib12_present == SIB12_PRESENT) && (sib12_ptr != NULL))
      {
        /* SIB 12 has been successfully read*/
        WRRC_MSG0_HIGH("Send SIB 12 Meas Req to L1");
        rrcmeas_send_l1_cmd(rrcmeas_sib12, NULL, NULL, L1_SIB_PARMS);
      }
      else
      {
        /* SIB 11 has been successfully read*/
        WRRC_MSG0_HIGH("Send SIB 12 Meas Req to L1");
        rrcmeas_send_l1_cmd(rrcmeas_sib11, NULL, NULL, L1_SIB_PARMS);
      }
    }

    if (rrcifreq_read_sib11(inter_freq_parms) == FAILURE)
    {
      WRRC_MSG0_HIGH("IFreq:Cell List ignored SIB11");
      rrcifreq_initialize_cell_list();
    }
    if(((rrc_SysInfoType11*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11)) != NULL)
    {
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          /* Everything is O.K. Read SIB12 */
          if(rrcifreq_read_sib12(sib12_ptr, inter_freq_parms, rrcmeas_inter_freq_sib12) == FAILURE)
          {
            WRRC_MSG0_HIGH("IFreq:Cell List ignored from SIB12");
            rrcifreq_initialize_cell_list();
          }
          else
          {
             meas_choice = L1_INTER_FREQ_SIB_PARMS;
             rrcifreq_send_l1_cmd(&meas_choice, rrcmeas_inter_freq_sib12);
             WRRC_MSG0_HIGH("IFreq:Cell List sent SIB12");
          }
        }
      } /* Else of SIB12 present */

      if((sib12_present == SIB12_ABSENT) && (inter_freq_parms->num_cell_add != 0))
      {
        meas_choice = L1_INTER_FREQ_SIB_PARMS;
        rrcifreq_send_l1_cmd(&meas_choice, inter_freq_parms);
        WRRC_MSG0_HIGH("IFreq:Cell List sent SIB11");
      }
    }

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
    rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif
    break;

  case RRC_MODE_STATUS_IND:

      WRRC_MSG0_HIGH("DUAL:Dual Mode Change Rcvd from MCM in PCH");

  /* First clear the SIB info */
      rrcmeas_clear_sib11();

      rrcmeas_initialize_meas_id_list();

      rrcmeas_initialize_cell_list();

    /* save the meas id variable in a tmp location */
      WCDMA_MEMCPY(tmp_intra_freq_meas_id_list, 
                   MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                   intra_freq_meas_id_list, 
                   MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

      if ( rrcmeas_read_sib11() == FAILURE )
      {
        WRRC_MSG0_HIGH("DUAL:Intra-Freq SIB 11 ignored");
        rrcmeas_clear_sib11();

        rrcmeas_initialize_meas_id_list();

        rrcmeas_initialize_cell_list();

      }
      else
      {
        meas_req_incl = TRUE;

        /* check for SIB 12 and use it if present */
        if ( sib12_present == SIB12_ABSENT )
        {
          MSG_LOW("DUAL:SIB12 not present", 0,0,0);
        }
        else
        {
          if((sib12_ptr = (rrc_SysInfoType12*)
            rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
          {
            WRRC_MSG0_HIGH("DUAL:SIB 12 empty.");
          }
          else
          {
            MSG_LOW("DUAL:Undo changes to Meas id varible from SIB11",0,0,0);
            WCDMA_MEMCPY(intra_freq_meas_id_list,
                         MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type), 
                         tmp_intra_freq_meas_id_list, 
                         MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

          /* Everything is O.K. Read SIB12 */
            rrcmeas_read_sib12(sib12_ptr, rrcmeas_sib12);
          }
        } /* Else of SIB12 present */
      }

    /* Read Inter-RAT SIB11 */
      if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
      {
        WRRC_MSG0_HIGH("DUAL:Inter-RAT SIB11 ignored");
        rrcirat_initialize_cell_list();
      }
      else
      {
        meas_req_incl = TRUE;
        /* check for SIB 12 and use it if present */
        if ( sib12_present == SIB12_ABSENT )
        {
          MSG_LOW("DUAL:SIB12 not present", 0,0,0);
        }
        else
        {
          MSG_LOW("DUAL:SIB12 present, processing SIB12",0,0,0);

          if((sib12_ptr = (rrc_SysInfoType12*)
            rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
          {
            WRRC_MSG0_HIGH("SIB 12 empty.");
          }
          else
          {
            /* Everything is O.K. Read SIB12 */
            if(rrcirat_read_sib12(sib12_ptr, rrcmeas_sib12) == FAILURE)
            {
              WRRC_MSG0_HIGH("DUAL:Inter-RAT SIB12 ignored");
              rrcirat_initialize_cell_list();
            }
          }
        } /* Else of SIB12 present */
      }

      if (meas_req_incl == TRUE)
      {
        if((sib12_present == SIB12_PRESENT) && (sib12_ptr != NULL))
        {
          /* SIB 12 has been successfully read */
          MSG_LOW("DUAL:Send SIB 12 Meas Req to L1",0,0,0);
          rrcmeas_send_l1_cmd(rrcmeas_sib12, NULL, NULL, L1_SIB_PARMS);
        }
        else
        {
          /* SIB 11 has been successfully read*/
          MSG_LOW("DUAL:Send SIB 11 Meas Req to L1",0,0,0);
          rrcmeas_send_l1_cmd(rrcmeas_sib11, NULL, NULL, L1_SIB_PARMS);
        }
      }

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
    rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif

    break;

    /* To add other command here as they are defined */

  default:
    /* No other events expected in this substate */
    MSG_MED("Ignoring %x in substate %d",
      cmd_ptr->cmd_hdr.cmd_id, rrcmeas_current_substate, 0);
    break;

  } /* End of switch */

rrc_free(inter_freq_parms);

} /*lint +esym(550,sib11_ptr) */

/*===========================================================================

FUNCTION rrcmeas_read_sib11

DESCRIPTION

 Reads SIB11 from the current active serving cell for all the measurements.
 If SIB11 information is incorrect, meas setup command  is not send to L1/MAC
 and UE does not do any measurements. At present only intra-freq meas supported

DEPENDENCIES

 SIB must have been stored by the SIB procedure

RETURN VALUE

 Success if SIB11 has been correctly read
 Failure if SIB11 has not been correctly read

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_read_sib11
(
void
)
{
  rrc_SysInfoType11 *sib11_ptr = NULL; /* Declared to store the value of SIB 11*/
  rrc_SysInfoType12 *sib12_ptr = NULL; /* Declared to store the value of SIB 12*/
  rrc_SysInfoType18 *sib18_ptr = NULL; /* Declared to store the value of SIB 18*/
  rrc_PLMNsOfIntraFreqCellsList *tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = NULL;
  rrc_MultiplePLMNsOfIntraFreqCellsList *tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr = NULL;
  rrc_plmn_identity_type tmp_plmn_identity;
  rrc_plmn_identity_type selected_plmn_identity;
  rrc_int_cell_id_type  tmp_cell_id;
  boolean sib18_present = FALSE;
  rrc_SysInfoType11_v590ext_IEs *sib11_rel5_ext_ptr = NULL;
  rrc_SysInfoType11_v590ext_IEs_newIntraFrequencyCellInfoList_v590ext * rel5_ext_ptr = NULL;

  /* Allocate a pointer for ease in readability */
  rrc_IntraFreqMeasurementSysInfo_RSCP  *intra_freq_meas_rscp_ptr = NULL;
  rrc_IntraFreqMeasurementSysInfo_ECN0  *intra_freq_meas_ecn0_ptr = NULL;
  uint32 idx=0;
  /* Allocate pointer to read intra freq cell list */
  rrc_NewIntraFreqCellSI_List_RSCP   *rscp_intra_freq_cell_list_ptr = NULL;
  rrc_NewIntraFreqCellSI_List_ECN0   *ecn0_intra_freq_cell_list_ptr = NULL;

  uint16   cell_count = 0;

  uint32 cell_position = 0;


  rrc_FACH_MeasurementOccasionInfo_inter_RAT_meas_ind * local_sib_inter_rat_ptr = NULL;

  uint16 prev_cell_count = 0;
  tmp_plmn_identity.mcc[0] =  tmp_plmn_identity.mcc[1] = tmp_plmn_identity.mcc[2] = 0;
  tmp_plmn_identity.num_mnc_digits = 0;
  tmp_plmn_identity.mnc[0] =  tmp_plmn_identity.mnc[1] = 0;
   /* SIB18 */
  if((sib18_ptr = (rrc_SysInfoType18*)  rrc_sibdb_return_sib_for_srv_cell
    (rrc_SIB18)) != NULL)
  {
  
    if(((rrcmeas_current_substate == RRCMEAS_CELL_DCH)
      || (rrcmeas_current_substate == RRCMEAS_PCH)
      || (rrcmeas_current_substate == RRCMEAS_CELL_FACH)))
    {
      /*
       1>if System Information Block type 11bis is scheduled on BCH:
       2>the PLMN lists to be considered are the ones included, when present, in the IE "Connected mode PLMN identities for SIB 11bis"; 
       2>otherwise,
                 the UE shall use, in place of any missing list, when present, the corresponding one in the IE "Idle mode PLMN identities for SIB11bis";
       2>otherwise,
                 the UE shall use, in place of any missing list, when present, the corresponding one in the IE "Connected mode PLMN identities"; 
       2>otherwise, 
                 the UE shall use, in place of any missing list, the corresponding one in the IE "Idle mode PLMN identities";
       
       1> else
       2>the PLMN lists to be considered are the ones included, when present, in the IE "Connected mode PLMN identities"; 
       2>otherwise,
                 the UE shall use, in place of any missing list, the corresponding one in the IE "Idle mode PLMN identities";
      */
      if((rrc_sibdb_is_sib11bis_present_in_srv_cell()) &&
        (RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
          (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext,
          connectedModePLMNIdentitiesSIB11bis)) &&
          (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.connectedModePLMNIdentitiesSIB11bis,
            plmnsOfIntraFreqCellsList)) &&
          (sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.connectedModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.
            connectedModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11bis:SIB11 processing SIB18 Conn Intra Freq from bis extension ");
        sib18_present = TRUE;
      }
      else if((rrc_sibdb_is_sib11bis_present_in_srv_cell()) &&
        (RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
          (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext,
          idleModePLMNIdentitiesSIB11bis)) &&
          (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.idleModePLMNIdentitiesSIB11bis,
            plmnsOfIntraFreqCellsList)) &&
          (sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.idleModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.
            idleModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11bis:SIB11 processing SIB18 idle Intra Freq from bis extension ");
        sib18_present = TRUE;
      }
      else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions,v860NonCriticalExtensions))&&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext,connectedModePLMNIdentities)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.connectedModePLMNIdentities,multipleplmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.connectedModePLMNIdentities.multipleplmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.connectedModePLMNIdentities.multipleplmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11 processing SIB18 Conn Multiple PLMNs Intra Freq");
        sib18_present = TRUE;
      }
      else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,connectedModePLMNIdentities)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->connectedModePLMNIdentities,plmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->connectedModePLMNIdentities.plmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->connectedModePLMNIdentities.plmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11 processing SIB18 Conn Intra Freq");
        sib18_present = TRUE;
      }
      else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions,v860NonCriticalExtensions))&&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext,idleModePLMNIdentities)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities,multipleplmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities.multipleplmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities.multipleplmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11 processing SIB18 Idle Multiple PLMNs Intra Freq");
        sib18_present = TRUE;
      }
      else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,idleModePLMNIdentities)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->idleModePLMNIdentities,plmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->idleModePLMNIdentities.plmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->idleModePLMNIdentities.plmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11 processing SIB18 Idle Intra Freq");
        sib18_present = TRUE;
      }
    }
    else
    {
   
      /*
       If SIB11bis is present and SIB18 bis extenstions are present, use SIB18 bis extension
       If SIB11bis is present and SIb18 bis extensions are absent, use SIB18
       If SIB11bis is absent, use SIB18
      */
      if((rrc_sibdb_is_sib11bis_present_in_srv_cell()) &&
        (RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext,idleModePLMNIdentitiesSIB11bis)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.idleModePLMNIdentitiesSIB11bis,
          plmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.idleModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.
            idleModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11bis:SIB11 processing SIB18 Idle Intra Freq from bis extension ");
        sib18_present = TRUE;
      }
      else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions,v860NonCriticalExtensions))&&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext,idleModePLMNIdentities)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities,multipleplmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities.multipleplmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities.multipleplmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11 processing SIB18 Idle Multiple PLMNs Intra Freq");
        sib18_present = TRUE;
      }
      else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,idleModePLMNIdentities))
        &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->idleModePLMNIdentities,plmnsOfIntraFreqCellsList))
        &&
        (sib18_ptr->idleModePLMNIdentities.plmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->idleModePLMNIdentities.plmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11 processing SIB18 Idle Intra Freq ");
        sib18_present = TRUE;
      }
    }
  }
  if(rrc_ccm_get_serv_plmn_cellid(&tmp_cell_id, &selected_plmn_identity) == RRC_CELL_LOSS_NO_NEW_CELL)
  {
    sib18_present = FALSE;
  }
  else
  {
    WCDMA_MEMCPY(&tmp_plmn_identity, 
                 sizeof(rrc_plmn_identity_type),
                 &selected_plmn_identity, 
                 sizeof(rrc_plmn_identity_type));
  }

  if(rrccsp_is_ue_in_true_limited_service() == TRUE)
  {
    sib18_present = FALSE;
    WRRC_MSG0_HIGH("UE in limited service ignoring SIB18");
  }


  /* Got to read SIB acc to the current state of RRC Measurement Procedure */
  switch (rrcmeas_current_substate)
  {
  case RRCMEAS_IDLE:
  case RRCMEAS_CELL_FACH:
  case RRCMEAS_PCH:
  case RRCMEAS_CELL_DCH:
    sib11_ptr = (rrc_SysInfoType11*)  rrc_sibdb_return_sib_for_srv_cell
      (rrc_SIB11);
    sib12_ptr = (rrc_SysInfoType12*)  rrc_sibdb_return_sib_for_srv_cell
      (rrc_SIB12);

    /* Check if the value received is O.K. */

    if ( sib11_ptr == NULL )
    {
      WRRC_MSG0_ERROR("SIB 11 from SIB DB is NULL");

      return FAILURE;
    }
    else
    {
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
      {
        /* Check for REL 5 extension ptr */
        if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib11_ptr,rrc_SysInfoType11,v4b0NonCriticalExtensions)) &&
          (RRC_MSG_COMMON_BITMASK_IE(sib11_ptr->v4b0NonCriticalExtensions,
          rrc_SysInfoType11_v4b0NonCriticalExtensions,v590NonCriticalExtension)))
        {
          sib11_rel5_ext_ptr = &(sib11_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType11_v590ext);
          if(RRC_MSG_COMMON_BITMASK_IE_PTR(sib11_rel5_ext_ptr,rrc_SysInfoType11_v590ext_IEs,newIntraFrequencyCellInfoList_v590ext))
          {
            rel5_ext_ptr = &sib11_rel5_ext_ptr->newIntraFrequencyCellInfoList_v590ext;
          }
        }
      }
      /* Read SIB 11 parameters */
      /* Check if the FACH Measurement Occassion Info if present */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib11_ptr,rrc_SysInfoType11,fach_MeasurementOccasionInfo))
      {
        rrcmeas_sib11->fach_meas_incl = TRUE;

        /* Initialize the following value to Default values */
        rrcmeas_sib11->fach.k_ind = FALSE;
        rrcmeas_sib11->fach.inter_f_ind = FALSE;
        rrcmeas_sib11->fach.num_inter_sys = 0;

        /* Check if fACH_meas_occasion_coeff present */
        if (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib11_ptr->fach_MeasurementOccasionInfo,fACH_meas_occasion_coeff))
        {
          /* Set the flag */
          rrcmeas_sib11->fach.k_ind = TRUE;
          rrcmeas_sib11->fach.k =
            sib11_ptr->fach_MeasurementOccasionInfo.fACH_meas_occasion_coeff;
        }

        /* Check if Inter Freq indicator present */
        if (sib11_ptr->fach_MeasurementOccasionInfo.inter_freq_FDD_meas_ind == TRUE)
        {
          rrcmeas_sib11->fach.inter_f_ind = TRUE;
        }

        /* Check if Inter RAT indicator present */
        local_sib_inter_rat_ptr = &sib11_ptr->fach_MeasurementOccasionInfo.inter_RAT_meas_ind;
        idx =0;
        while (local_sib_inter_rat_ptr->n > idx)
        {
          if (local_sib_inter_rat_ptr->elem[idx] == rrc_RAT_Type_gsm)
          {
            rrcmeas_sib11->fach.num_inter_sys = 1;
            rrcmeas_sib11->fach.inter_sys[0] = L1_GSM_SYSTEM;
            break;
          }
          idx++;
        }

      }
      /* Check if SIB12 present */
      if ( (sib11_ptr->sib12indicator == TRUE) && (sib12_ptr != NULL) )
      {
        WRRC_MSG0_HIGH("SIB 12 present");
        sib12_present = SIB12_PRESENT;
      }

      WRRC_MSG1_HIGH("HCS value is %d [1 - Not used; 2 - Used]",sib11_ptr->measurementControlSysInfo.use_of_HCS.t);

      /* Check if HCS is in use. */
      if (RRC_CHECK_COMMON_MSG_TYPE(sib11_ptr->measurementControlSysInfo.use_of_HCS,
        rrc_MeasurementControlSysInfo_use_of_HCS_hcs_used ))
      {
        if (rrcmeas_fill_hcs_info(&sib11_ptr->measurementControlSysInfo, sib11_rel5_ext_ptr) == SUCCESS)
        {
          rrcmeas_sib11->hcs_used = TRUE;
        }
        else
        {
          return FAILURE;
        }
      }
      else
      { /* HCS is NOT in use */
        /* Set HCS flag to FALSE */
        rrcmeas_sib11->hcs_used = FALSE;

        if ( sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->cellSelectQualityMeasure.t ==
          T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_cpich_RSCP )
        {
          /* Store first the cell selection and reselection quality parameter */
          rrcmeas_sib11->cell_sel_resel_quan_type =  L1_RSCP;

          /* The Cell Select Quality Measure is RSCP */
          if (!(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
            cellSelectQualityMeasure.u.cpich_RSCP->m.intraFreqMeasurementSysInfoPresent))
          {
            /* Optional param Intra freq meas sys RSCP info is absent */
            /* No need to initialize intra_freq_meas_info_incl as it is already set to FALSE */
            /* At present no other measurement besides intra-freq are being supported by L1 */

            WRRC_MSG0_HIGH("Intra freq meas sys info absent");
            if(rrcmeas_read_sib11bis(sib18_present,tmp_rrc_PLMNsOfIntraFreqCellsList_ptr, tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr)== FAILURE)
            {
              WRRC_MSG0_HIGH("SIB11bis: Intra Frequency in SIB11bis Ignored");
              rrcmeas_sib11->intra_f.cell_list.num_cell_add = 0;
              rrcmeas_sib11->intra_f.cell_list_incl = FALSE;
              rrcmeas_sib11->intra_freq_meas_info_incl = FALSE;
            }
            return SUCCESS;

          }
          else
          {
            /* Intra freq meas sys info is present */
            rrcmeas_sib11->intra_freq_meas_info_incl = TRUE;

            /* Associate a local pointer for readability */
            intra_freq_meas_rscp_ptr =
              &sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
               cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo;

            /* Measurement ID is present */
            rrcmeas_sib11->intra_f.meas_id =
              (uint16) intra_freq_meas_rscp_ptr->intraFreqMeasurementID;

            /* Get the FDD Intra freq meas quantity if present */
            if ((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
              rrc_IntraFreqMeasurementSysInfo_HCS_RSCP,intraFreqMeasQuantity))
              &&
              (RRC_CHECK_COMMON_MSG_TYPE(intra_freq_meas_rscp_ptr->intraFreqMeasQuantity.modeSpecificInfo,
              rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd)))
            {

              /* Intra freq meas quantity for FDD mode is present */
              rrcmeas_sib11->intra_f.meas_quan_incl = TRUE;

              /* So read the value of meas quantity and filter coefficient */

              rrcmeas_sib11->intra_f.meas_quan.quan_type =  RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
                intra_freq_meas_rscp_ptr->intraFreqMeasQuantity.modeSpecificInfo.u.fdd->
                intraFreqMeasQuantity_FDD);

  
              WRRC_MSG1_HIGH("pathloss:SIB11 M.Quan e/r/p:0/1/2 =%d", rrcmeas_sib11->intra_f.meas_quan.quan_type);
              /* Get the Filter Coefficient */
              /* Check if rrc_IntraFreqMeasQuantity_filterCoefficient_present */
              /* If not, fill in a default value */

        
              
             rrcmeas_sib11->intra_f.meas_quan.filter_coef = (uint16)
             RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(
             intra_freq_meas_rscp_ptr->intraFreqMeasQuantity.filterCoefficient);
              
            

            } /* End of if for rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd */

            /* Check intra-freq cell info present */
            if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
              rrc_IntraFreqMeasurementSysInfo_HCS_RSCP,intraFreqCellInfoSI_List))
            {
              /* Intra freq cell info list is present */
              rrcmeas_sib11->intra_f.cell_list_incl = TRUE;

              /* Intra freq Cell Info list is present */
              /* Always ignore the number of removed cells in System Info 11. */
              /* Process the new cell list */
              cell_count = 0;
              rscp_intra_freq_cell_list_ptr =
                &intra_freq_meas_rscp_ptr->intraFreqCellInfoSI_List.
                newIntraFreqCellList;

              /* Intra freq cell info list is present */
              rrcmeas_sib11->intra_f.cell_list_incl = TRUE;
              idx=0;
              while ( (rscp_intra_freq_cell_list_ptr->n > idx) &&
                (cell_count < L1_MAX_CELL_MEAS) )
              {
              /* Pointer to next cell is Non-NULL and cell count
                * hasn't exceeded the max. L1 can handle */

                if ( rscp_intra_freq_cell_list_ptr->elem[idx].cellInfo.
                  modeSpecificInfo.t ==
                  T_rrc_CellInfoSI_RSCP_modeSpecificInfo_tdd)
                {
                  /* Nothing doing with a TDD cell. Shun it ! */
                  idx++;

                  continue;
                }
                /* Set default values for the HCS neighboring cell info if it is first cell
                * else use the info from the previous cell */
                rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio = 0;
                rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs = 115;
                rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time = 0;


                if (rrcmeas_fill_rscp_cell_info(&rscp_intra_freq_cell_list_ptr->elem[idx].
                  cellInfo, &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
                  cell_info
                  ,((rel5_ext_ptr != NULL) ? ((rel5_ext_ptr->n > idx) ? (&rel5_ext_ptr->elem[idx]) : NULL) : NULL)
) == FAILURE)
                {
                  idx++;
                  continue;
                }

                /* Check if intra-freq cell ID is present */
                if (RRC_MSG_LIST_BITMASK_IE(rscp_intra_freq_cell_list_ptr,
                  rrc_NewIntraFreqCellSI_HCS_RSCP,intraFreqCellID))
                {
                  cell_position = rscp_intra_freq_cell_list_ptr->elem[idx].intraFreqCellID;
                  /* Set psc from rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
                  cell_info.pri_scr_code in the intra freq cell list at position given by
                  rscp_intra_freq_cell_list_ptr->value.intraFreqCellID. Call
                  rrcmeas_update_intra_freq_cell_list to do that */

                } /* End of if of intra-freq cell id present */

                else
                {
                  cell_position = AVAILABLE_CELL_POSITION;
                  /* Set psc from rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
                  cell_info.pri_scr_code in the first vacant position in intra freq cell list */

                } /* End of else of intra-freq cell id not present */


                if ( rrcmeas_update_intra_freq_cell_list(
                  &cell_position,
                  &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
                  cell_info.pri_scr_code) == RRCMEAS_SUCCESS)
                {
                  /* PSC sucessfully stored in the cell info list variable */
                  /* Now store psc in the sib11 in add cell for layer1 to use psc */
                  rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].psc =
                    rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
                    cell_info.pri_scr_code;

                  rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
                    measure_in_idle_pch_fach = TRUE;
                  if(sib18_present)
                  {
                    rrcmeas_process_sib18_filtering(
                       tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
                       tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
                       &tmp_plmn_identity,
                       cell_count,
                       &(rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach),
                       (cell_count > 0)?rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count -1].measure_in_idle_pch_fach: TRUE);
                  }
                  else
                  {
                    /* Add code to set flag meas_pch_fach_idle to TRUE for the cell */
                    WRRC_MSG1_MED("psc %d measured in IDLE,FACH,PCH,DCH",rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].psc);
                  }
                  /* Increment cell count as add cell successfully stored */
                  cell_count ++;
                }  /* End of if of rrcmeas_update_intra_freq_cell_list */


                idx++;


                if ( (cell_count == L1_MAX_CELL_MEAS) &&
                  (rscp_intra_freq_cell_list_ptr->n > idx) )
                {
                /* If there are more new cells than can be accomodated in L1
                Cmd, print a message and hope L1 will change their capability
                sometime. Just pass the number that L1 can handle.
                  */
                  MSG_LOW("All Intra freq cells not included",0,0,0);
                  break;
                }

              } /* while((rscp_intra_freq_cell_list_ptr != NULL) */
              /* Set number of added cells */
              rrcmeas_sib11->intra_f.cell_list.num_cell_add = cell_count;

            } /* Intra freq cell info list is present */

            /* Fill in Intra freq reporting quantity for RACH reporting */
            if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
              rrc_IntraFreqMeasurementSysInfo_RSCP,intraFreqReportingQuantityForRACH))
            {
              /* Intra freq reporting quantity for RACH reporting is present */
              /* Fill in the FDD reporting quantity if present */
              if (RRC_CHECK_COMMON_MSG_TYPE(intra_freq_meas_rscp_ptr->intraFreqReportingQuantityForRACH.
                modeSpecificInfo,
                rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd) )
              {
                rrcmeas_sib11->intra_f.rach_rpt_quan_incl = TRUE;

                /* Fill in SFN SFN TM delta ReportType:1/2/None */
                rrcmeas_sib11->intra_f.rach_rpt_quan.rach_sfn_tm_delta =
                  RRCMEAS_RET_INTRA_FREQ_SFN_DELTA(
                  intra_freq_meas_rscp_ptr->intraFreqReportingQuantityForRACH.sfn_SFN_OTD_Type);

                /* Fill in rach reporting quantity RSCP/ECNO..*/
                rrcmeas_sib11->intra_f.rach_rpt_quan.rach_rpt_quan =
                  RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(
                  intra_freq_meas_rscp_ptr->intraFreqReportingQuantityForRACH.
                  modeSpecificInfo.u.fdd->intraFreqRepQuantityRACH_FDD);

              }  /* End of if of RACH_modeSpecificInfo_fdd */
            } /* End of if of intraFreqReportingQuantityForRACH_present */

            /* Check if max number of reported cells on RACH */
            /* If present then only set rach reporting to TRUE */

            if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
              rrc_IntraFreqMeasurementSysInfo_RSCP,maxReportedCellsOnRACH))
            {
              MSG_LOW("Max no of reporting cells present",0,0,0);

              /* Max reported cells on RACH is present */
              rrcmeas_sib11->intra_f.rach_rpt_max_incl = TRUE;

              /* Fill max no of reported cells */
              rrcmeas_sib11->intra_f.rach_rpt_max =
                RRCMEAS_RET_RACH_REPORTED_CELLS(
                intra_freq_meas_rscp_ptr->maxReportedCellsOnRACH);

              /* Modify RACH reporting criteria if maxReportedCellsOnRACH present */

              if ( intra_freq_meas_rscp_ptr->maxReportedCellsOnRACH !=
                rrc_MaxReportedCellsOnRACH_noReport )
              {
                /* Set reporting criteria for RACH to no report */
                sib11_rach_report_crit = APPEND_RRC_MEAS_RACH_REPORT;
              }

            } /* End of if of RSCP_maxReportedCellsOnRACH_present */

            /* Now check if the Reporting info in state Cell_DCH is present */
            if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
              rrc_IntraFreqMeasurementSysInfo_RSCP,reportingInfoForCellDCH))
            {
              /* Initialize RLC reporting mode criteria */
              rrcmeas_sib11->intra_f.dch_rpt_info.rpt_trans_mode =
                RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
                intra_freq_meas_rscp_ptr->reportingInfoForCellDCH.measurementReportingMode.
                measurementReportTransferMode);

              /* To fill in the DCH info, call function */
              if ( rrcmeas_fill_dch_state_info(
                & intra_freq_meas_rscp_ptr->reportingInfoForCellDCH,
                & rrcmeas_sib11->intra_f.dch_rpt_info, sib11_rel5_ext_ptr, NULL) == SUCCESS )
              {

                rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl = TRUE;
              }

            } /* if of Reporting info in state DCH present */
            prev_cell_count = rrcmeas_sib11->intra_f.cell_list.num_cell_add;
            if(rrcmeas_read_sib11bis(sib18_present,tmp_rrc_PLMNsOfIntraFreqCellsList_ptr, tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr)== FAILURE)
            {
              WRRC_MSG0_HIGH("SIB11bis: Intra Frequency in SIB11bis Ignored");
              rrcmeas_sib11->intra_f.cell_list.num_cell_add = prev_cell_count ;
            }
          } /* Intra freq meas sys info is present */

        } /* Cell select reselect quality measure is RSCP */

        else if ( sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->cellSelectQualityMeasure.t ==
          T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_cpich_Ec_N0 )
        {
          /* Cell Selection Quality Measure is EcN0 */

          /* Store first the cell selection and reselction quality parameter */
          rrcmeas_sib11->cell_sel_resel_quan_type =  L1_EC_NO;

          WRRC_MSG0_HIGH("Meas Quan L1_EC_NO");

          /* Check if Intra freq meas system info is present */
          if (!(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
            cellSelectQualityMeasure.u.cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent
            ))
          {
            /* At present return as no other measurements are being supported by L1 */
            WRRC_MSG0_HIGH("Intra freq sys info absent.");
            if(rrcmeas_read_sib11bis(sib18_present,tmp_rrc_PLMNsOfIntraFreqCellsList_ptr, tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr)== FAILURE)
            {
              WRRC_MSG0_HIGH("SIB11bis: Intra Frequency in SIB11bis Ignored");
              rrcmeas_sib11->intra_f.cell_list.num_cell_add = 0;
              rrcmeas_sib11->intra_f.cell_list_incl = FALSE;
              rrcmeas_sib11->intra_freq_meas_info_incl = FALSE;
            }

            return SUCCESS;
          }
          else
          {
            /* Intra freq meas sys info is present */
            rrcmeas_sib11->intra_freq_meas_info_incl     = TRUE;

            /* Associate a local pointer for readability */
            intra_freq_meas_ecn0_ptr =
              &sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
              cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo;

         
              /* Measurement ID present */
              rrcmeas_sib11->intra_f.meas_id =
                (uint16) intra_freq_meas_ecn0_ptr->intraFreqMeasurementID;

            /* Get the FDD Intra freq meas quantity if present */
            if ((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
              rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,intraFreqMeasQuantity))
              &&
              (RRC_CHECK_COMMON_MSG_TYPE(intra_freq_meas_ecn0_ptr->intraFreqMeasQuantity.modeSpecificInfo,
              rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd)))
            {

              /* Intra freq meas quantity for FDD mode is present */
              rrcmeas_sib11->intra_f.meas_quan_incl = TRUE;

              /* Intra freq meas quantity for FDD mode is present */
              rrcmeas_sib11->intra_f.meas_quan.quan_type =
                RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
                intra_freq_meas_ecn0_ptr->intraFreqMeasQuantity.
                modeSpecificInfo.u.fdd->intraFreqMeasQuantity_FDD);

              /* Get the Filter Coefficient */
              /* Check if rrc_IntraFreqMeasQuantity_filterCoefficient_present */
              /* If not, fill in a default value */
 
             rrcmeas_sib11->intra_f.meas_quan.filter_coef = (uint16)
               RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(
               intra_freq_meas_ecn0_ptr->intraFreqMeasQuantity.
               filterCoefficient);
              

            }  /* End of if for rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd */

            if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
                rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,intraFreqCellInfoSI_List))
            {
              idx =0;
              /*  Process the new cell list */
              cell_count = 0;
              ecn0_intra_freq_cell_list_ptr =
                &intra_freq_meas_ecn0_ptr->intraFreqCellInfoSI_List.
                newIntraFreqCellList;

              /* Intra freq cell info list is present */
              rrcmeas_sib11->intra_f.cell_list_incl = TRUE;              
              while ( (ecn0_intra_freq_cell_list_ptr->n > idx) &&
                (cell_count < L1_MAX_CELL_MEAS) )
              {
              /* Pointer to next cell is Non-NULL and cell count
                * hasn't exceeded the max. L1 can handle */

                if ( ecn0_intra_freq_cell_list_ptr->elem[idx].
                  cellInfo.modeSpecificInfo.t ==
                  T_rrc_CellInfoSI_ECN0_modeSpecificInfo_tdd)
                {

                  /* Nothing doing with a TDD cell. Shun it ! */
                  idx++;
                  continue;
                }

                rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio = 0;
                rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs = 24 * 2;
                rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time = 0;

                if ( rrcmeas_fill_ecn0_cell_info(&ecn0_intra_freq_cell_list_ptr->elem[idx].
                  cellInfo, &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
                  cell_info
                , ((rel5_ext_ptr != NULL) ? ((rel5_ext_ptr->n > idx) ? (&rel5_ext_ptr->elem[idx]) : NULL) : NULL)
                ) == FAILURE )
                {
                  WRRC_MSG0_HIGH("Incorrect cell info sent in SIB. Ignore");
                  idx++;
                  continue;
                  /* So do not increment the count */
                }
                /* Fill in the cell ID if present */
                if (RRC_MSG_LIST_BITMASK_IE(ecn0_intra_freq_cell_list_ptr,
                  rrc_NewIntraFreqCellSI_HCS_ECN0,intraFreqCellID))
                {
                  cell_position = ecn0_intra_freq_cell_list_ptr->elem[idx].intraFreqCellID;
                  /* Set psc from rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
                  cell_info.pri_scr_code in the intra freq cell list at position given by
                  ecn0_intra_freq_cell_list_ptr->value.intraFreqCellID. Call
                  rrcmeas_update_intra_freq_cell_list to do that */

                }
                else
                {
                  cell_position = AVAILABLE_CELL_POSITION;
                  /* Set psc from rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
                  cell_info.pri_scr_code in the first vacant position in intra freq cell list */
                }

                if ( rrcmeas_update_intra_freq_cell_list(
                  &cell_position,
                  &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
                  cell_info.pri_scr_code) == RRCMEAS_SUCCESS)
                {
                  /* PSC sucessfully stored in the cell info list variable */
                  /* Now store psc in the sib11 in add cell for layer1 to use psc */
                  rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].psc =
                    rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
                    cell_info.pri_scr_code;

                  /* Increment cell count as add cell successfully stored */
                  rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
                    measure_in_idle_pch_fach = TRUE;
                  
                  
                  if(sib18_present)
                  {
                    rrcmeas_process_sib18_filtering(
                       tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
                       tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
                       &tmp_plmn_identity,
                       cell_count,
                       &(rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach),
                       (cell_count > 0)?rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count -1].measure_in_idle_pch_fach: TRUE);
                  }
                  cell_count ++;
                }  /* End of if of rrcmeas_update_intra_freq_cell_list */

                idx++;
                if ( (cell_count == L1_MAX_CELL_MEAS) &&
                  (ecn0_intra_freq_cell_list_ptr->n > idx) )
                {
                /* If there are more new cells than can be accomodated in L1 Cmd,
                * print a message and hope L1 will change their capability
                * sometime. Just pass the number that L1 can handle.
                  */

                  WRRC_MSG0_HIGH("All Intra freq cells not included");
                  break;
                }

              } /* while((ecn0_intra_freq_cell_list_ptr != NULL) */

              /* Set number of added cells */
              rrcmeas_sib11->intra_f.cell_list.num_cell_add = cell_count;

            } /*  Intra freq cell info list is present */

            /* Fill in Intra freq reporting quantity for RACH reporting */
            if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
              rrc_IntraFreqMeasurementSysInfo_ECN0,intraFreqReportingQuantityForRACH))
            {
              /* Fill in the FDD reporting quantity if present */
              if (RRC_CHECK_COMMON_MSG_TYPE(intra_freq_meas_ecn0_ptr->
                intraFreqReportingQuantityForRACH.modeSpecificInfo,
                rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd ))
              {

                rrcmeas_sib11->intra_f.rach_rpt_quan_incl = TRUE;

                /* Fill in SFN SFN TM delta */
                rrcmeas_sib11->intra_f.rach_rpt_quan.rach_sfn_tm_delta =
                  RRCMEAS_RET_INTRA_FREQ_SFN_DELTA(
                  intra_freq_meas_ecn0_ptr->intraFreqReportingQuantityForRACH.sfn_SFN_OTD_Type);

                /* Fill in rach reporting quantity RSCP/ECNO..*/
                rrcmeas_sib11->intra_f.rach_rpt_quan.rach_rpt_quan =
                  RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(
                  intra_freq_meas_ecn0_ptr->intraFreqReportingQuantityForRACH.
                  modeSpecificInfo.u.fdd->intraFreqRepQuantityRACH_FDD);

              }  /* End of if of RACH_modeSpecificInfo_fdd */

            } /* End of if of intraFreqReportingQuantityForRACH_present */

            /* Check  max number of reported cells on RACH */
            if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
              rrc_IntraFreqMeasurementSysInfo_ECN0,maxReportedCellsOnRACH))
            {
              MSG_LOW("Max no of reporting cells present", 0,0,0);

              /* Max reported cells on RACH is present */
              rrcmeas_sib11->intra_f.rach_rpt_max_incl = TRUE;

              /* Fill max no of reported cells */
              rrcmeas_sib11->intra_f.rach_rpt_max =
                RRCMEAS_RET_RACH_REPORTED_CELLS(
                intra_freq_meas_ecn0_ptr->maxReportedCellsOnRACH);

              /* Modify RACH reporting criteria if maxReportedCellsOnRACH present */
              if ( intra_freq_meas_ecn0_ptr->maxReportedCellsOnRACH !=
                rrc_MaxReportedCellsOnRACH_noReport )
              {
                /* Set reporting criteria for RACH to no report */
                sib11_rach_report_crit = APPEND_RRC_MEAS_RACH_REPORT;
              }

            } /* End of if of RSCP_maxReportedCellsOnRACH_present */


            /* Now check if the Reporting info in state Cell_DCH is present */
            if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
              rrc_IntraFreqMeasurementSysInfo_ECN0,reportingInfoForCellDCH))
            {
              /* Set Meas transfer mode criteria */
              rrcmeas_sib11->intra_f.dch_rpt_info.rpt_trans_mode =
                RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
                intra_freq_meas_ecn0_ptr->reportingInfoForCellDCH.measurementReportingMode.
                measurementReportTransferMode);


              /* To fill in the DCH info, call a function */
              if ( rrcmeas_fill_dch_state_info(& intra_freq_meas_ecn0_ptr->reportingInfoForCellDCH,
                & rrcmeas_sib11->intra_f.dch_rpt_info, sib11_rel5_ext_ptr, NULL) == SUCCESS )
              {
                rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl = TRUE;
              }

            } /* if of Reporting info in state DCH present*/
            prev_cell_count = rrcmeas_sib11->intra_f.cell_list.num_cell_add;
            if(rrcmeas_read_sib11bis(sib18_present,tmp_rrc_PLMNsOfIntraFreqCellsList_ptr, tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr)== FAILURE)
            {
              WRRC_MSG0_HIGH("SIB11bis: Intra Frequency in SIB11bis Ignored");
              rrcmeas_sib11->intra_f.cell_list.num_cell_add = prev_cell_count ;
            }
          } /* Intra freq meas sys info is present */

        } /*  Cell select reselect quality measure is EcIo */
        else
        {
          MSG_LOW("Cell Select Quality Measure incorrect",0,0,0);
        }

      } /* HCS is NOT in use */

      /* Set Measurement in RRC Intra Freq DB */
      rrcmeas_set_intra_freq_meas_identity(&rrcmeas_sib11->intra_f);

      return SUCCESS;
    }  /* End of else */

  default:
    WRRC_MSG1_ERROR("RRC Meas State not defined %d", rrcmeas_current_substate);
    return FAILURE;
  } /* End of switch */
}

/*===========================================================================

FUNCTION    RRCMEAS_CLEAR_SIB12

DESCRIPTION

 Initialises SIB12 stored variable, sib12_rach_report_crit
DEPENDENCIES

 None.

RETURN VALUE

 void

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_clear_sib12
(
l1_meas_sib_parm_struct_type *rrcmeas_sib12_ptr
)
{
  rrcmeas_sib12_ptr->fach_meas_incl = FALSE;
  rrcmeas_sib12_ptr->hcs_used = FALSE;
  rrcmeas_sib12_ptr->cell_sel_resel_quan_type = L1_MEAS_NONE;
  rrcmeas_sib12_ptr->intra_freq_meas_info_incl = FALSE;
  rrcmeas_sib12_ptr->intra_f.meas_quan.filter_coef = 0;
  rrcmeas_sib12_ptr->intra_f.meas_quan.quan_type = L1_MEAS_NONE;
  rrcmeas_sib12_ptr->intra_f.cell_list_incl = FALSE;
  rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_rmv = 0;
  rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add = 0;
  rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_meas = 0;
  rrcmeas_sib12_ptr->intra_f.cell_list.cells_for_meas_incl = FALSE;
  rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl = FALSE;
  rrcmeas_sib12_ptr->intra_f.meas_quan_incl = FALSE;
  rrcmeas_sib12_ptr->intra_f.rach_rpt_max_incl = FALSE;
  rrcmeas_sib12_ptr->intra_f.rach_rpt_max = L1_RACH_RPT_NONE;
  rrcmeas_sib12_ptr->intra_f.rach_rpt_quan_incl = FALSE;
    rrcmeas_sib12_ptr->intra_f.rach_rpt_max = L1_RACH_RPT_0;

  rrcmeas_sib12_ptr->inter_sys_meas_info_incl = FALSE;
  rrcmeas_sib12_ptr->inter_s.num_cell_rmv = 0;
  rrcmeas_sib12_ptr->inter_s.num_cell_add = 0;
  rrcmeas_sib12_ptr->intra_f.dch_rpt_info.rpt_trans_mode =
    ACKNOWLEDGED_MODE;

  sib12_rach_report_crit = NO_RRC_MEAS_RACH_REPORT;

}

/*===========================================================================

FUNCTION rrcmeas_read_sib12

DESCRIPTION

 Caller must check the sib12_present before calling this fn.
 This function processes SIB12 IEs and build the information
 to be sent down to L1 and updates the cell info list for
 intra frequency measurements.

DEPENDENCIES

 SIB12 must have been received by the camping cell.

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void  rrcmeas_read_sib12
(
rrc_SysInfoType12 *sib12_ptr,
l1_meas_sib_parm_struct_type* rrcmeas_sib12_ptr
)
{
  /* Allocate a pointer for ease in readability */
  rrc_IntraFreqMeasurementSysInfo_RSCP  *intra_freq_meas_rscp_ptr = NULL;
  rrc_IntraFreqMeasurementSysInfo_ECN0  *intra_freq_meas_ecn0_ptr = NULL;

  rrc_IntraFreqMeasurementSysInfo_HCS_RSCP  *intra_freq_meas_hcs_rscp_ptr = NULL;
  rrc_IntraFreqMeasurementSysInfo_HCS_ECN0  *intra_freq_meas_hcs_ecn0_ptr = NULL;

  rrc_NewIntraFreqCellSI_List_RSCP   *rscp_intra_freq_cell_list_ptr = NULL;
  rrc_NewIntraFreqCellSI_List_ECN0   *ecn0_intra_freq_cell_list_ptr = NULL;

  rrc_NewIntraFreqCellSI_List_HCS_RSCP *rscp_hcs_intra_freq_cell_list_ptr = NULL;
  rrc_NewIntraFreqCellSI_List_HCS_ECN0 *ecn0_hcs_intra_freq_cell_list_ptr = NULL;
  /* temporary Intra freq cell list */
  intra_freq_cell_list_struct_type  tmp_intra_freq_cell_list[L1_MAX_CELL_MEAS];

  /* Counts the cells */
  uint16   cell_count = 0;
  uint32 cell_position = 0;
  uint32 count = 0;
  uint16 sib11_cell_count = 0;
 uint32 idx=0;

  rrc_SysInfoType18 *sib18_ptr = NULL; /* Declared to store the value of SIB 18*/
  rrc_PLMNsOfIntraFreqCellsList *tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = NULL;
  rrc_MultiplePLMNsOfIntraFreqCellsList *tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr = NULL;
  rrc_plmn_identity_type tmp_plmn_identity;
  rrc_plmn_identity_type selected_plmn_identity;
  rrc_int_cell_id_type  tmp_cell_id;
  boolean sib18_present = FALSE;

  rrc_SysInfoType12_v590ext_IEs *sib12_rel5_ext_ptr = NULL;
  rrc_SysInfoType12_v590ext_IEs_newIntraFrequencyCellInfoList_v590ext * rel5_ext_ptr = NULL;
  rrcmeas_clear_sib12(rrcmeas_sib12_ptr);
  tmp_plmn_identity.mcc[0] =  tmp_plmn_identity.mcc[1] = tmp_plmn_identity.mcc[2] = 0;
  tmp_plmn_identity.num_mnc_digits = 0;
  tmp_plmn_identity.mnc[0] =  tmp_plmn_identity.mnc[1] = 0;

  if((sib18_ptr = (rrc_SysInfoType18*)  rrc_sibdb_return_sib_for_srv_cell
    (rrc_SIB18)) != NULL)
  {
      /*
       1>if System Information Block type 11bis is scheduled on BCH:
       2>the PLMN lists to be considered are the ones included, when present, in the IE "Connected mode PLMN identities for SIB 11bis"; 
       2>otherwise,
                 the UE shall use, in place of any missing list, when present, the corresponding one in the IE "Idle mode PLMN identities for SIB11bis";
       2>otherwise,
                 the UE shall use, in place of any missing list, when present, the corresponding one in the IE "Connected mode PLMN identities"; 
       2>otherwise, 
                 the UE shall use, in place of any missing list, the corresponding one in the IE "Idle mode PLMN identities";
       
       1> else
       2>the PLMN lists to be considered are the ones included, when present, in the IE "Connected mode PLMN identities"; 
       2>otherwise,
                 the UE shall use, in place of any missing list, the corresponding one in the IE "Idle mode PLMN identities";
      */
    if((rrc_sibdb_is_sib11bis_present_in_srv_cell()) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
      (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext,
       connectedModePLMNIdentitiesSIB11bis)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.connectedModePLMNIdentitiesSIB11bis,
          plmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.connectedModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList.n != 0))
    {
      tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.
          connectedModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList;
      WRRC_MSG0_HIGH("SIB11bis:SIB12 processing SIB18 Conn Intra Freq from bis extension ");
      sib18_present = TRUE;
    }
    else if((rrc_sibdb_is_sib11bis_present_in_srv_cell()) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext,
        idleModePLMNIdentitiesSIB11bis)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.idleModePLMNIdentitiesSIB11bis,
        plmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.idleModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList.n != 0))
    {
      tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.
          idleModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList;
      WRRC_MSG0_HIGH("SIB11bis:SIB12 processing SIB18 idle Intra Freq from bis extension ");
      sib18_present = TRUE;
    }
      else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions,v860NonCriticalExtensions))&&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext,connectedModePLMNIdentities)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.connectedModePLMNIdentities,multipleplmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.connectedModePLMNIdentities.multipleplmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.connectedModePLMNIdentities.multipleplmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB12 processing SIB18 Conn Multiple PLMNs Intra Freq");
      sib18_present = TRUE;
    }
    else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,connectedModePLMNIdentities)) &&
      (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->connectedModePLMNIdentities,plmnsOfIntraFreqCellsList)) &&
      (sib18_ptr->connectedModePLMNIdentities.plmnsOfIntraFreqCellsList.n != 0))
    {
      tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->connectedModePLMNIdentities.plmnsOfIntraFreqCellsList;
      WRRC_MSG0_HIGH("SIB12 processing SIB18 Conn Intra Freq");
      sib18_present = TRUE;
    }
      else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions,v860NonCriticalExtensions))&&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext,idleModePLMNIdentities)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities,multipleplmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities.multipleplmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities.multipleplmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB12 processing SIB18 Idle Multiple PLMNs Intra Freq");
      sib18_present = TRUE;
    }
    else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,idleModePLMNIdentities)) &&
      (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->idleModePLMNIdentities,
      plmnsOfIntraFreqCellsList)) &&
      (sib18_ptr->idleModePLMNIdentities.plmnsOfIntraFreqCellsList.n != 0))
    {
      tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->idleModePLMNIdentities.plmnsOfIntraFreqCellsList;
      WRRC_MSG0_HIGH("SIB12 processing SIB18 Idle Intra Freq");
      sib18_present = TRUE;
    }
  }

  if(rrc_ccm_get_serv_plmn_cellid(&tmp_cell_id, &selected_plmn_identity) == RRC_CELL_LOSS_NO_NEW_CELL)
  {
    sib18_present = FALSE;
  }
  else
  {
    WCDMA_MEMCPY(&tmp_plmn_identity, 
                 sizeof(rrc_plmn_identity_type),
                 &selected_plmn_identity, 
                 sizeof(rrc_plmn_identity_type));
  }

  if(rrccsp_is_ue_in_true_limited_service() == TRUE)
  {
    sib18_present = FALSE;
    WRRC_MSG0_HIGH("UE in limited service ignoring SIB18");
  }


  /* Save the Intra freq cell list in a tmp loc as it is needed for the building the composite
  * cell ino list to be sent down to L1 */

  for(count = 0; count < L1_MAX_CELL_MEAS; count++)
  {
    WCDMA_MEMCPY(&tmp_intra_freq_cell_list[count], 
                 sizeof(intra_freq_cell_list_struct_type),
                 &intra_freq_cell_list[PRI_FREQ][count],
                 sizeof(intra_freq_cell_list_struct_type));
  }

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
  {
    /* Check for REL 5 extension ptr */
    if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib12_ptr,rrc_SysInfoType12,v4b0NonCriticalExtensions)) &&
      (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib12_ptr->v4b0NonCriticalExtensions, v590NonCriticalExtension)))
    {
      sib12_rel5_ext_ptr = &(sib12_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
        sysInfoType12_v590ext);
      if(RRC_MSG_COMMON_BITMASK_IE_PTR(sib12_rel5_ext_ptr,
        rrc_SysInfoType12_v590ext_IEs,newIntraFrequencyCellInfoList_v590ext))
      {
        rel5_ext_ptr = &sib12_rel5_ext_ptr->newIntraFrequencyCellInfoList_v590ext;
      }
    }
  }

  /* Check if the FACH Measurement Occassion Info if present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib12_ptr,rrc_SysInfoType12,fach_MeasurementOccasionInfo))
  {
    rrcmeas_sib12_ptr->fach_meas_incl = TRUE;

    /* Initialize the following value to Default values */
    rrcmeas_sib12_ptr->fach.k_ind = FALSE;
    rrcmeas_sib12_ptr->fach.inter_f_ind = FALSE;
    rrcmeas_sib12_ptr->fach.num_inter_sys = 0;

    /* Check if fACH_meas_occasion_coeff present */
    if (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib12_ptr->fach_MeasurementOccasionInfo,
        fACH_meas_occasion_coeff))
    {
      /* Set the flag */
      rrcmeas_sib12_ptr->fach.k_ind = TRUE;
      rrcmeas_sib12_ptr->fach.k =
        sib12_ptr->fach_MeasurementOccasionInfo.fACH_meas_occasion_coeff;
    }

    /* Check if Inter Freq indicator present */
    if (sib12_ptr->fach_MeasurementOccasionInfo.inter_freq_FDD_meas_ind == TRUE)
    {
      rrcmeas_sib12_ptr->fach.inter_f_ind = TRUE;
    }

    /* Check if Inter RAT indicator present */
    idx=0;
    while (sib12_ptr->fach_MeasurementOccasionInfo.inter_RAT_meas_ind.n > idx)
    {
      if (sib12_ptr->fach_MeasurementOccasionInfo.inter_RAT_meas_ind.elem[idx] == rrc_RAT_Type_gsm)
      {
        rrcmeas_sib12_ptr->fach.num_inter_sys = 1;
        rrcmeas_sib12_ptr->fach.inter_sys[0] = L1_GSM_SYSTEM;
        break;
      }
      idx++;
    }
  }
  else if(rrcmeas_sib11->fach_meas_incl == TRUE)
  {
    rrcmeas_sib12_ptr->fach_meas_incl = TRUE;

    /* Initialize the following value to Default values */
    rrcmeas_sib12_ptr->fach.k_ind = rrcmeas_sib11->fach.k_ind;
    rrcmeas_sib12_ptr->fach.inter_f_ind = rrcmeas_sib11->fach.inter_f_ind;
    rrcmeas_sib12_ptr->fach.k =  rrcmeas_sib11->fach.k;
    rrcmeas_sib12_ptr->fach.num_inter_sys = rrcmeas_sib11->fach.num_inter_sys;
    rrcmeas_sib12_ptr->fach.inter_sys[0] = rrcmeas_sib11->fach.inter_sys[0];
  }
  /* Check if HCS is in use. */
  if ( RRC_CHECK_COMMON_MSG_TYPE(sib12_ptr->measurementControlSysInfo.use_of_HCS,
    rrc_MeasurementControlSysInfo_use_of_HCS_hcs_used ))
  {
    /* Set HCS flag to TRUE */
    rrcmeas_sib12_ptr->hcs_used = TRUE;
    WRRC_MSG0_HIGH("HCS supported for SIB12 processing");
    /* process HCS*/
/* Check cell select quality measure */
    if ( sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
      cellSelectQualityMeasure.t ==
      T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_1_cpich_RSCP )
    {
      /* The Cell Select Quality Measure is RSCP */
      rrcmeas_sib12_ptr->cell_sel_resel_quan_type =  L1_RSCP;

      if (!(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
        cellSelectQualityMeasure.u.cpich_RSCP->m.intraFreqMeasurementSysInfoPresent))
      {
        /* At present return as no other measurements are being supported by L1 */
        WRRC_MSG0_HIGH("SIB12:Intra freq sys info absent check if present in SIB11.");
        if(rrcmeas_sib11->intra_freq_meas_info_incl == TRUE)
        {
          /* Copy the intra frequency measurement system information from SIB 11 to SIB 12 */
          WRRC_MSG0_HIGH("Copying the intra freq meas info from SIB11");
          rrcmeas_sib12_ptr->intra_freq_meas_info_incl = TRUE;

          WCDMA_MEMCPY(&rrcmeas_sib12_ptr->intra_f, 
                       sizeof(l1_intra_freq_sib_struct_type),
                       &rrcmeas_sib11->intra_f,
                       sizeof(l1_intra_freq_sib_struct_type));
          sib12_rach_report_crit = sib11_rach_report_crit;
          rrcmeas_set_intra_freq_meas_identity(&rrcmeas_sib12_ptr->intra_f);
        }
        return;
      }
      else
      {
        /* Intra freq meas sys info is present */
        rrcmeas_sib12_ptr->intra_freq_meas_info_incl = TRUE;

        /* Associate a local pointer for readability */
        intra_freq_meas_hcs_rscp_ptr =
          &sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
          cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo;

    
          /* Measurement ID is present */
          rrcmeas_sib12_ptr->intra_f.meas_id =
            (uint16) intra_freq_meas_hcs_rscp_ptr->intraFreqMeasurementID;
        

        WRRC_MSG1_HIGH("Intra freq meas id in SIB12 is %d",
          rrcmeas_sib12_ptr->intra_f.meas_id);

        /* Get the FDD Intra freq meas quantity if present */

        if ((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_hcs_rscp_ptr,
          rrc_IntraFreqMeasurementSysInfo_HCS_RSCP,intraFreqMeasQuantity))
          &&
          (RRC_CHECK_COMMON_MSG_TYPE(intra_freq_meas_hcs_rscp_ptr->intraFreqMeasQuantity.modeSpecificInfo,
          rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd) ))
        {

          /* Intra freq meas quantity for FDD mode is present */
          rrcmeas_sib12_ptr->intra_f.meas_quan_incl = TRUE;

          /* Read the value of meas quantity */
          rrcmeas_sib12_ptr->intra_f.meas_quan.quan_type =
            RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
            intra_freq_meas_hcs_rscp_ptr->intraFreqMeasQuantity.modeSpecificInfo.u.fdd->
            intraFreqMeasQuantity_FDD);
          /* Get the Filter Coefficient if present*/

        
          rrcmeas_sib12_ptr->intra_f.meas_quan.filter_coef = (uint16)
              RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(
              intra_freq_meas_hcs_rscp_ptr->intraFreqMeasQuantity.
              filterCoefficient);
          
        } /* End of if for FDD Intra freq meas quantity present */
        else
        {
          /* Intra freq meas quantity for FDD mode is not present */
          /* Check if present in SIB11 */
          /* If Intra FDD Freq meas quantity is absent in SIB11 too, set it to NONE in L1 cmd */

          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.meas_quan_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            rrcmeas_sib12_ptr->intra_f.meas_quan_incl = rrcmeas_sib11->intra_f.meas_quan_incl;
            rrcmeas_sib12_ptr->intra_f.meas_quan = rrcmeas_sib11->intra_f.meas_quan;
            rrcmeas_sib12_ptr->intra_f.meas_quan.filter_coef =
              rrcmeas_sib11->intra_f.meas_quan.filter_coef;
          }

        } /* End of else */

        if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_hcs_rscp_ptr,
          rrc_IntraFreqMeasurementSysInfo_HCS_RSCP,intraFreqCellInfoSI_List))
        {
          /* Intra freq cell info list is present */
          rrcmeas_sib12_ptr->intra_f.cell_list_incl = TRUE;

          /* Check if removed cell list present */
          if(RRC_MSG_COMMON_BITMASK_IE_TYPE2(intra_freq_meas_hcs_rscp_ptr->intraFreqCellInfoSI_List, removedIntraFreqCellList))
          {
            /* Call fn to fill cells to be removed */
            if ( rrcmeas_process_removed_intra_freq_cells(
              & intra_freq_meas_hcs_rscp_ptr->intraFreqCellInfoSI_List.removedIntraFreqCellList,
              & rrcmeas_sib12_ptr->intra_f.cell_list) == FAILURE )
            {
              WRRC_MSG0_HIGH("No cell removed from SIB12");
            }
          } /* End of if of removedIntraFreqCellList_present */

          /*  Process the new cell list */
          cell_count = 0;

          rscp_hcs_intra_freq_cell_list_ptr =
            &intra_freq_meas_hcs_rscp_ptr->intraFreqCellInfoSI_List.
            newIntraFreqCellList;
          idx=0;
          while ( (rscp_hcs_intra_freq_cell_list_ptr->n > idx) &&
            (cell_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is Non-NULL and cell count
            * hasn't exceeded the max. L1 can handle */

            if ( rscp_hcs_intra_freq_cell_list_ptr->elem[idx].cellInfo.
              modeSpecificInfo.t ==
              T_rrc_CellInfoSI_HCS_RSCP_modeSpecificInfo_tdd)
            {
              /* Ignore TDD Cell move to next cell in cell list */

              idx++;

              continue;
            }

            /* Set default values for the HCS neighboring cell info if it is first cell
            * else use the info from the previous cell */
            if(cell_count == 0)
            {
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio = 0;
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs = 115;
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time = 0;
            }
            else
            {
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio =
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.hcs_prio;
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs =
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.q_hcs;
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time =
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.penalty_time;

              if(rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.penalty_time
                != 0)
              {
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.tmp_offset1 =
                  rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.tmp_offset1;
              }
            }
            /* Call a function to fill the cell info */
            if (rrcmeas_fill_hcs_rscp_cell_info(&rscp_hcs_intra_freq_cell_list_ptr->elem[idx].cellInfo,
              &rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info,
             ((rel5_ext_ptr != NULL) ? ((rel5_ext_ptr->n > idx) ? (&rel5_ext_ptr->elem[idx]) : NULL) : NULL)) == FAILURE )
            {

              WRRC_MSG0_HIGH("Ignoring this cell as incorrect cell info");
              idx++;
              
              continue;
            }
            /* Fill in the cell ID if present */
            if (RRC_MSG_LIST_BITMASK_IE(rscp_hcs_intra_freq_cell_list_ptr,
              rrc_NewIntraFreqCellSI_HCS_RSCP,intraFreqCellID))
            {

              cell_position = rscp_hcs_intra_freq_cell_list_ptr->elem[idx].intraFreqCellID;
            }
            else
            {
              cell_position = AVAILABLE_CELL_POSITION;
            }

            if ( rrcmeas_update_intra_freq_cell_list(
              &cell_position,
              &rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].
              cell_info.pri_scr_code) == RRCMEAS_SUCCESS)
            {
              /* PSC sucessfully stored in the cell info list variable */
              /* Now store psc in the sib12 in add cell for layer1 to use psc */
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].psc =
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].
                cell_info.pri_scr_code;
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach = TRUE;
              /* Increment cell count as add cell successfully stored */
              cell_count ++;
            }  /* End of if of rrcmeas_update_intra_freq_cell_list */
            else
            {
              /* TBD  In Phase 2 */
              WRRC_MSG0_ERROR("CELL_INFO_LIST out of sync");
              break;

            }
            idx++;

            if ( (cell_count == L1_MAX_CELL_MEAS) &&
              (rscp_hcs_intra_freq_cell_list_ptr->n > idx) )
            {
              WRRC_MSG0_HIGH("Cannot include all Intra freq cells");
              break;
            }
          } /* while((rscp_hcs_intra_freq_cell_list_ptr != NULL) */

          /* Initialize cell count */
          rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add = cell_count;

          /* At this point all the cells from SIB12 have been read */

          /* Remove SIB12 removed cells them from SIB11 & add new cells given in
          * SIB12 to SIB11 list */

          /* Check if the following is present in SIB11 */

          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.cell_list_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.cell_list.num_cell_add != 0) )
          {
            if(!(intra_freq_meas_hcs_rscp_ptr->intraFreqCellInfoSI_List.m.removedIntraFreqCellListPresent))
            {
              intra_freq_meas_hcs_rscp_ptr->intraFreqCellInfoSI_List.removedIntraFreqCellList.t =
                T_rrc_RemovedIntraFreqCellList_removeNoIntraFreqCells;
            }
            rrcmeas_build_sib12_intra_freq_list_from_sib11(
              &intra_freq_meas_hcs_rscp_ptr->intraFreqCellInfoSI_List.removedIntraFreqCellList,
              &rrcmeas_sib11->intra_f.cell_list,
              &rrcmeas_sib12_ptr->intra_f.cell_list, tmp_intra_freq_cell_list);

          } /* End of if */
          for(cell_count = 0; cell_count < rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add; cell_count++)
          {
            if(sib18_present == TRUE)
            {
              rrcmeas_process_sib18_filtering(
                 tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
                 tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
                 &tmp_plmn_identity,
                 cell_count,
                 &(rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach),
                 (cell_count > 0)?rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count -1].measure_in_idle_pch_fach: TRUE);
            }
            else
            {
              /* Add code to set flag meas_pch_fach_idle to TRUE for the cell */
              WRRC_MSG1_MED("psc %d measured in IDLE,FACH,PCH,DCH",rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].psc);
            }
          }
        } /* Intra freq cell info list is present */
        else
        {
          if(rrcmeas_sib11->intra_f.cell_list_incl == TRUE)
          {
            WRRC_MSG0_HIGH("copying the cell info list from SIB11->SIB12");
            rrcmeas_sib12_ptr->intra_f.cell_list_incl = TRUE;
            for(sib11_cell_count = 0; sib11_cell_count < rrcmeas_sib11->intra_f.cell_list.num_cell_add; sib11_cell_count++)
            {
              WCDMA_MEMCPY(&rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[sib11_cell_count],
                           sizeof(rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[0]),
                           &rrcmeas_sib11->intra_f.cell_list.add_cell[sib11_cell_count],
                           sizeof(rrcmeas_sib11->intra_f.cell_list.add_cell[0]));
            }
            rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add
              =  rrcmeas_sib11->intra_f.cell_list.num_cell_add;
          }
        }

        /* Fill in Intra freq reporting quantity for RACH reporting */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_hcs_rscp_ptr,
          rrc_IntraFreqMeasurementSysInfo_HCS_RSCP,intraFreqReportingQuantityForRACH))
        {
          /* Intra freq reporting quantity for RACH reporting is present */
          if (RRC_CHECK_COMMON_MSG_TYPE( intra_freq_meas_hcs_rscp_ptr->intraFreqReportingQuantityForRACH.modeSpecificInfo,
            rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd ))
          {
            /* Intra freq reporting quantity for RACH present */
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan_incl = TRUE;

            /* Fill in SFN SFN TM delta */
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan.rach_sfn_tm_delta =
              RRCMEAS_RET_INTRA_FREQ_SFN_DELTA(
              intra_freq_meas_hcs_rscp_ptr->intraFreqReportingQuantityForRACH.sfn_SFN_OTD_Type);

            /* Fill in the rach reporting quantity */
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan.rach_rpt_quan =
              RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(
              intra_freq_meas_hcs_rscp_ptr->intraFreqReportingQuantityForRACH.
              modeSpecificInfo.u.fdd->intraFreqRepQuantityRACH_FDD);
          }  /* End of if of RACH_modeSpecificInfo_fdd */
        } /* Intra-freq reporting quantity present */
        else
        {
          /* Intra freq reporting quantity for RACH absent in SIB 12 */
          /* Check if present in SIB11 */
          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.rach_rpt_quan_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            WRRC_MSG0_HIGH("Intra freq rpt qty not in SIB12 picked from SIB11");
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan_incl = rrcmeas_sib11->intra_f.meas_quan_incl;
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan = rrcmeas_sib11->intra_f.rach_rpt_quan;
          } /* End of if */
        }  /* End of else of Intra-freq reporting quantity present*/

        /* Fill in max number of reported cells on RACH */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_hcs_rscp_ptr,
          rrc_IntraFreqMeasurementSysInfo_HCS_RSCP,maxReportedCellsOnRACH))
        {
          /* Max reported cells on RACH is present */
          rrcmeas_sib12_ptr->intra_f.rach_rpt_max_incl = TRUE;

          /* Set max no of reported cells */
          rrcmeas_sib12_ptr->intra_f.rach_rpt_max =
            RRCMEAS_RET_RACH_REPORTED_CELLS(
            intra_freq_meas_hcs_rscp_ptr->maxReportedCellsOnRACH);

          if ( intra_freq_meas_hcs_rscp_ptr->maxReportedCellsOnRACH !=
            rrc_MaxReportedCellsOnRACH_noReport )
          {
            /* Set reporting criteria for RACH to no report */
            sib12_rach_report_crit = APPEND_RRC_MEAS_RACH_REPORT;
          }
        } /* End of if of maxReportedCellsOnRACH_present */
        else
        {
          /*  Max reported cells on RACH is absent */
          /* Check if present in SIB11 */
          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.rach_rpt_max_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            WRRC_MSG0_HIGH("Intra freq: Max reported cells on RACH not in SIB12 picked from SIB11");
            rrcmeas_sib12_ptr->intra_f.rach_rpt_max_incl = rrcmeas_sib11->intra_f.rach_rpt_max_incl;
            rrcmeas_sib12_ptr->intra_f.rach_rpt_max = rrcmeas_sib11->intra_f.rach_rpt_max;

            /* Set SIB12 RACH report criteria */
            sib12_rach_report_crit = sib11_rach_report_crit;
          } /* End of if */
        } /* End of else of maxReportedCellsOnRACH_present */

        /* Initialize DCH info present to FALSE */
        rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl = FALSE;

        /* Now check if the Reporting info in state Cell_DCH is present */
        if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_hcs_rscp_ptr,
          rrc_IntraFreqMeasurementSysInfo_HCS_RSCP,reportingInfoForCellDCH))
        {
          /* Set report transfer mode */
          rrcmeas_sib12_ptr->intra_f.dch_rpt_info.rpt_trans_mode =
            RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
            intra_freq_meas_hcs_rscp_ptr->reportingInfoForCellDCH.
            measurementReportingMode.measurementReportTransferMode);

          /* To fill in the DCH info, call the following function */
          if (rrcmeas_fill_dch_state_info(
            &intra_freq_meas_hcs_rscp_ptr->reportingInfoForCellDCH,
            &rrcmeas_sib12_ptr->intra_f.dch_rpt_info, NULL, sib12_rel5_ext_ptr) == SUCCESS)
          {
            rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl = TRUE;
          }
        } /* if of Reporting info in state DCH present*/
        else
        {
          /* Check if present in SIB11 */
          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            WRRC_MSG0_HIGH("Intra freq: Reporting info in DCH not in SIB12 picked from SIB11");
            rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl =
              rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl;
            rrcmeas_sib12_ptr->intra_f.dch_rpt_info = rrcmeas_sib11->intra_f.dch_rpt_info;
          } /* End of if */
        } /* End of else */
      } /* Intra freq meas sys info is present */
    } /* Cell select reselect quality measure is RSCP */
    else if ( sib12_ptr->measurementControlSysInfo.use_of_HCS.u.
      hcs_used->cellSelectQualityMeasure.t ==
      T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_1_cpich_Ec_N0 )
    {
      /* The Cell Select Quality Measure is ECNO */
      rrcmeas_sib12_ptr->cell_sel_resel_quan_type =  L1_EC_NO;

      /* Check if Intra freq meas system info is present */
      if (!(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
        cellSelectQualityMeasure.u.cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent))
      {
        /* Copy the intra frequency measurement system information from SIB 11 to SIB 12 if present */
        if(rrcmeas_sib11->intra_freq_meas_info_incl == TRUE)
        {
          /* Copy the intra frequency measurement system information from SIB 11 to SIB 12 */
          WRRC_MSG0_HIGH("Copying the intra freq meas info from SIB11");
          rrcmeas_sib12_ptr->intra_freq_meas_info_incl = TRUE;
          WCDMA_MEMCPY(&rrcmeas_sib12_ptr->intra_f, 
                       sizeof(l1_intra_freq_sib_struct_type),
                       &rrcmeas_sib11->intra_f,
                       sizeof( l1_intra_freq_sib_struct_type));
          sib12_rach_report_crit = sib11_rach_report_crit;
          rrcmeas_set_intra_freq_meas_identity(&rrcmeas_sib12_ptr->intra_f);
        }
        return;
      }
      else
      {
        /* Intra freq meas sys info is present */
        rrcmeas_sib12_ptr->intra_freq_meas_info_incl = TRUE;

        /* Associate a local pointer for readability */
        intra_freq_meas_hcs_ecn0_ptr =
          &sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
          cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo;

    
          /* Measurement ID present */
          rrcmeas_sib12_ptr->intra_f.meas_id =
            (uint16)intra_freq_meas_hcs_ecn0_ptr->intraFreqMeasurementID;
        

        /* Get the FDD Intra freq meas quantity if present */
        if((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_hcs_ecn0_ptr,
          rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,intraFreqMeasQuantity))
          &&
          (RRC_CHECK_COMMON_MSG_TYPE(intra_freq_meas_hcs_ecn0_ptr->intraFreqMeasQuantity.modeSpecificInfo,
          rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd) ))
        {
          /* Intra freq meas quantity for FDD mode is present */
          rrcmeas_sib12_ptr->intra_f.meas_quan_incl = TRUE;

          /* Read value of meas quantity */
          rrcmeas_sib12_ptr->intra_f.meas_quan.quan_type =
            RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
            intra_freq_meas_hcs_ecn0_ptr->intraFreqMeasQuantity.modeSpecificInfo.u.
            fdd->intraFreqMeasQuantity_FDD);

          /* Get the Filter Coefficient if present*/


            rrcmeas_sib12_ptr->intra_f.meas_quan.filter_coef = (uint16)
              RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(
              intra_freq_meas_hcs_ecn0_ptr->intraFreqMeasQuantity.filterCoefficient);
          
        } /* End of if for FDD Intra freq meas quantity present */
        else
        {
          /* Intra freq meas quantity for FDD mode is not present */
          /* Check if present in SIB11 */
          /* If Intra FDD Freq meas quantity is absent, set it to NONE in L1 cmd */

          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.meas_quan_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            rrcmeas_sib12_ptr->intra_f.meas_quan_incl = rrcmeas_sib11->intra_f.meas_quan_incl;
            rrcmeas_sib12_ptr->intra_f.meas_quan = rrcmeas_sib11->intra_f.meas_quan;
            rrcmeas_sib12_ptr->intra_f.meas_quan.filter_coef = rrcmeas_sib11->intra_f.meas_quan.filter_coef;
          }
          else
          {  /* ASSIGN DEFAULT VALUES */
            rrcmeas_sib12_ptr->intra_f.meas_quan_incl = FALSE;
            rrcmeas_sib12_ptr->intra_f.meas_quan.quan_type = L1_MEAS_NONE;
            rrcmeas_sib12_ptr->intra_f.meas_quan.filter_coef = 0;
          }
        }

        if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_hcs_ecn0_ptr,
          rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,intraFreqCellInfoSI_List))
        {
          /* Intra freq cell info list is present */
          rrcmeas_sib12_ptr->intra_f.cell_list_incl = TRUE;

          /* Check if removed cell list present */
          if(RRC_MSG_COMMON_BITMASK_IE_TYPE2(intra_freq_meas_hcs_ecn0_ptr->intraFreqCellInfoSI_List, removedIntraFreqCellList))
          {
            /* Call fn to fill cells to be removed */
            if ( rrcmeas_process_removed_intra_freq_cells(
              & intra_freq_meas_hcs_ecn0_ptr->intraFreqCellInfoSI_List.removedIntraFreqCellList,
              & rrcmeas_sib12_ptr->intra_f.cell_list) == FAILURE )
            {
              MSG_LOW("Unable to remove cell from SIB12",0,0,0);
            }
          } /* End of if of removedIntraFreqCellList) */

          /* Process the new cell list */
          cell_count = 0;
          ecn0_hcs_intra_freq_cell_list_ptr =
            &intra_freq_meas_hcs_ecn0_ptr->intraFreqCellInfoSI_List.newIntraFreqCellList;
          idx=0;
          while ( (ecn0_hcs_intra_freq_cell_list_ptr->n > idx) &&
            (cell_count < L1_MAX_CELL_MEAS) )
          {
          /* Pointer to next cell is Non-NULL and cell count
            * hasn't exceeded the max. L1 can handle */
            if ( ecn0_hcs_intra_freq_cell_list_ptr->elem[idx].
              cellInfo.modeSpecificInfo.t ==
              T_rrc_CellInfoSI_HCS_ECN0_modeSpecificInfo_tdd)
            {
              /* Nothing doing with a TDD cell. Shun it ! */

              idx++;
              continue;
            }
            /* Set default values for the HCS neighboring cell info if it is first cell
            * else use the info from the previous cell */
            if(cell_count == 0)
            {
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio = 0;
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs = 24 * 2;
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time = 0;
            }
            else
            {
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio =
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.hcs_prio;
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs =
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.q_hcs;
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time =
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.penalty_time;

              if(rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.penalty_time
                != 0)
              {
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.tmp_offset1 =
                  rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.tmp_offset1;
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.tmp_offset2 =
                  rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.tmp_offset2;
              }
            }
            /* Call a function to fill the cell info */
            if (rrcmeas_fill_hcs_ecn0_cell_info(&ecn0_hcs_intra_freq_cell_list_ptr->elem[idx].cellInfo,
              &rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info,
              ((rel5_ext_ptr != NULL) ? ((rel5_ext_ptr->n > idx) ? (&rel5_ext_ptr->elem[idx]) : NULL) : NULL)) == FAILURE )
            {
              WRRC_MSG0_HIGH("Ignoring cell info");
              idx++;
              continue;
            }


            /* Fill in the cell ID if present */
            if(RRC_MSG_LIST_BITMASK_IE(ecn0_hcs_intra_freq_cell_list_ptr,
              rrc_NewIntraFreqCellSI_HCS_ECN0,intraFreqCellID))
            {
              cell_position = ecn0_hcs_intra_freq_cell_list_ptr->elem[idx].intraFreqCellID;
            }
            else
            {
              cell_position = AVAILABLE_CELL_POSITION;
            }

            if(rrcmeas_update_intra_freq_cell_list(
              &cell_position,
              &rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].
              cell_info.pri_scr_code) == RRCMEAS_SUCCESS)
            {
              /* PSC sucessfully stored in the cell info list variable */
              /* Now store psc in the sib12 in add cell for layer1 to use psc */
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].psc =
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].
                cell_info.pri_scr_code;
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach = TRUE;
              /* Increment cell count as add cell successfully stored */
              cell_count ++;
            }  /* End of if of rrcmeas_update_intra_freq_cell_list */

            idx++;
            if ( (cell_count == L1_MAX_CELL_MEAS) &&
              (ecn0_hcs_intra_freq_cell_list_ptr->n > idx) )
            {
              WRRC_MSG0_HIGH("Cannot include all Intra freq cells");
              break;
            }
          } /* while((ecn0_hcs_intra_freq_cell_list_ptr != NULL) */

          /* Initialize cell count */
          rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add = cell_count;

          /* At this point all the cells from SIB12 have been read */

          /* Remove SIB12 removed cells from SIB11 & add new cells given in
          * SIB12 to SIB11 list */

          /* Check if the following is present in SIB11 */

          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.cell_list_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.cell_list.num_cell_add != 0) )
          {

            if(!(RRC_MSG_COMMON_BITMASK_IE_TYPE2(intra_freq_meas_hcs_ecn0_ptr->intraFreqCellInfoSI_List, removedIntraFreqCellList)))
            {
              RRC_SET_COMMON_MSG_TYPE2(intra_freq_meas_hcs_ecn0_ptr->intraFreqCellInfoSI_List.removedIntraFreqCellList,
                rrc_RemovedIntraFreqCellList,removeNoIntraFreqCells);
            }
            rrcmeas_build_sib12_intra_freq_list_from_sib11(
              &intra_freq_meas_hcs_ecn0_ptr->intraFreqCellInfoSI_List.removedIntraFreqCellList,
              &rrcmeas_sib11->intra_f.cell_list,
              &rrcmeas_sib12_ptr->intra_f.cell_list, tmp_intra_freq_cell_list);
          } /* End of if */

          for(cell_count = 0; cell_count < rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add; cell_count++)
          {
            if(sib18_present == TRUE)
            {
              rrcmeas_process_sib18_filtering(
                 tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
                 tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
                 &tmp_plmn_identity,
                 cell_count,
                 &(rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach),
                 (cell_count > 0)?rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count -1].measure_in_idle_pch_fach: TRUE);
            }
            else
            {
              /* Add code to set flag meas_pch_fach_idle to TRUE for the cell */
              WRRC_MSG1_MED("psc %d measured in IDLE,FACH,PCH,DCH",rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].psc);
            }
          }

        } /* Intra freq cell info list is present */
        else
        {
          if(rrcmeas_sib11->intra_f.cell_list_incl == TRUE)
          {
            WRRC_MSG0_HIGH("copying the cell info list from SIB11->SIB12");
            rrcmeas_sib12_ptr->intra_f.cell_list_incl = TRUE;
            for(sib11_cell_count = 0; sib11_cell_count < rrcmeas_sib11->intra_f.cell_list.num_cell_add; sib11_cell_count++)
            {
              WCDMA_MEMCPY(&rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[sib11_cell_count],
                           sizeof (rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[0]),
                           &rrcmeas_sib11->intra_f.cell_list.add_cell[sib11_cell_count],
                           sizeof (rrcmeas_sib11->intra_f.cell_list.add_cell[0]));
            }
            rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add
              =  rrcmeas_sib11->intra_f.cell_list.num_cell_add;
          }
        }
        /* Fill in Intra freq reporting quantity for RACH reporting */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_hcs_ecn0_ptr,
          rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,intraFreqReportingQuantityForRACH))
        {
          /* Fill in the FDD reporting quantity if present */
          if (RRC_CHECK_COMMON_MSG_TYPE( intra_freq_meas_hcs_ecn0_ptr->
            intraFreqReportingQuantityForRACH.modeSpecificInfo,
            rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd) )
          {
            /* Intra freq reporting quantity for RACH present */
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan_incl = TRUE;

            /* Fill in SFN SFN TM delta */
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan.rach_sfn_tm_delta =
              RRCMEAS_RET_INTRA_FREQ_SFN_DELTA(
              intra_freq_meas_hcs_ecn0_ptr->intraFreqReportingQuantityForRACH.sfn_SFN_OTD_Type);


            /* Fill in the rach reporting quantity */
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan.rach_rpt_quan =
              RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(
              intra_freq_meas_hcs_ecn0_ptr->intraFreqReportingQuantityForRACH.
              modeSpecificInfo.u.fdd->intraFreqRepQuantityRACH_FDD);

          } /* End of if of RACH_modeSpecificInfo_fdd */
        }  /* Intra-freq reporting quantity present */
        else
        {
          /* Intra freq reporting quantity for RACH absent in SIB 12 */
          /* Check if present in SIB11 */

          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.rach_rpt_quan_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            WRRC_MSG0_HIGH("Intra freq: rpt qty not in SIB12 picked from SIB11");
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan_incl =
              rrcmeas_sib11->intra_f.meas_quan_incl;
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan =
              rrcmeas_sib11->intra_f.rach_rpt_quan;
          } /* End of if */
        }  /* End of else of Intra-freq reporting quantity present*/

        /* Fill in max number of reported cells on RACH */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_hcs_ecn0_ptr,
          rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,maxReportedCellsOnRACH))
        {
          /* Max reported cells on RACH present */
          rrcmeas_sib12_ptr->intra_f.rach_rpt_max_incl  = TRUE;

          /* Set max no of reported cells */
          rrcmeas_sib12_ptr->intra_f.rach_rpt_max =
            RRCMEAS_RET_RACH_REPORTED_CELLS(
            intra_freq_meas_hcs_ecn0_ptr->maxReportedCellsOnRACH);

          if ( intra_freq_meas_hcs_ecn0_ptr->maxReportedCellsOnRACH !=
            rrc_MaxReportedCellsOnRACH_noReport )
          {
            /* Set reporting criteria for RACH to no report */
            sib12_rach_report_crit = APPEND_RRC_MEAS_RACH_REPORT;
          }
        } /* End of if of maxReportedCellsOnRACH_present */
        else
        {
          /*  Max reported cells on RACH is absent */
          /* Check if present in SIB11 */
          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.rach_rpt_max_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            WRRC_MSG0_HIGH("Intra freq: Max reported cells on RACH not in SIB12 picked from SIB11");
            rrcmeas_sib12_ptr->intra_f.rach_rpt_max_incl =
              rrcmeas_sib11->intra_f.rach_rpt_max_incl;

            rrcmeas_sib12_ptr->intra_f.rach_rpt_max =
              rrcmeas_sib11->intra_f.rach_rpt_max;

            /* Copy SIB11 RACH report criteria */
            sib12_rach_report_crit = sib11_rach_report_crit;
          } /* End of if */
        } /* End of else of maxReportedCellsOnRACH_present*/

        /* Initialize DCH info present to FALSE */
        rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl = FALSE;

        /* Now check if the Reporting info in state Cell_DCH is present */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_hcs_ecn0_ptr,
          rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,reportingInfoForCellDCH))
        {
          rrcmeas_sib12_ptr->intra_f.dch_rpt_info.rpt_trans_mode =
            RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
            intra_freq_meas_hcs_ecn0_ptr->reportingInfoForCellDCH.
            measurementReportingMode.measurementReportTransferMode);

          /* To fill in the DCH info, call the following function */
          if ( rrcmeas_fill_dch_state_info(
            &intra_freq_meas_hcs_ecn0_ptr->reportingInfoForCellDCH,
            & rrcmeas_sib12_ptr->intra_f.dch_rpt_info, NULL, sib12_rel5_ext_ptr) == SUCCESS )
          {
            rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl = TRUE;
          }
        } /* if of Reporting info in state DCH present*/
        else
        {
          /* Check if present in SIB11 */
          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            WRRC_MSG0_HIGH("Intra freq: Reporting info in DCH not in SIB12 picked from SIB11");
            rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl =
              rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl;

            rrcmeas_sib12_ptr->intra_f.dch_rpt_info =
              rrcmeas_sib11->intra_f.dch_rpt_info;
          } /* End of if */
        } /* End of else */
      } /* Intra freq meas sys info is present */
    } /* Cell select reselect quality measure is EcIo */
    else
    {
      WRRC_MSG0_HIGH("SIB12 Cell Select measure != ECN0/RSCP.");
      /* This SIB12 does not indicate anything useful */
      return;
    }
    /* end process hcs */
  }
  else
  { /* HCS is NOT in use */

    /* Check cell select quality measure */
    if ( sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
      cellSelectQualityMeasure.t ==
      T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_cpich_RSCP )
    {

      /* The Cell Select Quality Measure is RSCP */
      rrcmeas_sib12_ptr->cell_sel_resel_quan_type =  L1_RSCP;

      if (!(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
        cellSelectQualityMeasure.u.cpich_RSCP->m.intraFreqMeasurementSysInfoPresent
        ))
      {
        /* At present return as no other measurements are being supported by L1 */
        WRRC_MSG0_HIGH("SIB12:Intra freq sys info absent check if present in SIB11.");
        if(rrcmeas_sib11->intra_freq_meas_info_incl == TRUE)
        {
          /* Copy the intra frequency measurement system information from SIB 11 to SIB 12 */
          WRRC_MSG0_HIGH("Copying the intra freq meas info from SIB11");
          rrcmeas_sib12_ptr->intra_freq_meas_info_incl = TRUE;

          WCDMA_MEMCPY(&rrcmeas_sib12_ptr->intra_f,
                       sizeof(l1_intra_freq_sib_struct_type),
                       &rrcmeas_sib11->intra_f,
                       sizeof(l1_intra_freq_sib_struct_type));
          sib12_rach_report_crit = sib11_rach_report_crit;
          rrcmeas_set_intra_freq_meas_identity(&rrcmeas_sib12_ptr->intra_f);
        }
        return;
      }
      else
      {
        /* Intra freq meas sys info is present */
        rrcmeas_sib12_ptr->intra_freq_meas_info_incl = TRUE;

        /* Associate a local pointer for readability */
        intra_freq_meas_rscp_ptr =
          &sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo;

       
          /* Measurement ID is present */
          rrcmeas_sib12_ptr->intra_f.meas_id =
            (uint16) intra_freq_meas_rscp_ptr->intraFreqMeasurementID;
       

        WRRC_MSG1_HIGH("Intra freq meas id in SIB12 is %d",
          rrcmeas_sib12_ptr->intra_f.meas_id);

        /* Get the FDD Intra freq meas quantity if present */

        if ((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
          rrc_IntraFreqMeasurementSysInfo_RSCP,intraFreqMeasQuantity))
          &&
          (RRC_CHECK_COMMON_MSG_TYPE(intra_freq_meas_rscp_ptr->intraFreqMeasQuantity.modeSpecificInfo,
          rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd) ))
        {

          /* Intra freq meas quantity for FDD mode is present */
          rrcmeas_sib12_ptr->intra_f.meas_quan_incl = TRUE;

          /* Read the value of meas quantity */
          rrcmeas_sib12_ptr->intra_f.meas_quan.quan_type =
            RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
            intra_freq_meas_rscp_ptr->intraFreqMeasQuantity.modeSpecificInfo.u.fdd->
            intraFreqMeasQuantity_FDD);

            /* Get the Filter Coefficient if present*/

          
            rrcmeas_sib12_ptr->intra_f.meas_quan.filter_coef = (uint16)
              RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(
              intra_freq_meas_rscp_ptr->intraFreqMeasQuantity.
              filterCoefficient);
          
        } /* End of if for FDD Intra freq meas quantity present */
        else
        {
          /* Intra freq meas quantity for FDD mode is not present */
          /* Check if present in SIB11 */
          /* If Intra FDD Freq meas quantity is absent in SIB11 too, set it to NONE in L1 cmd */

          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.meas_quan_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            rrcmeas_sib12_ptr->intra_f.meas_quan_incl = rrcmeas_sib11->intra_f.meas_quan_incl;
            rrcmeas_sib12_ptr->intra_f.meas_quan = rrcmeas_sib11->intra_f.meas_quan;
            rrcmeas_sib12_ptr->intra_f.meas_quan.filter_coef =
              rrcmeas_sib11->intra_f.meas_quan.filter_coef;
          }

        } /* End of else */

        if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
          rrc_IntraFreqMeasurementSysInfo_RSCP,intraFreqCellInfoSI_List))
        {
          /* Intra freq cell info list is present */
          rrcmeas_sib12_ptr->intra_f.cell_list_incl = TRUE;

          /* Check if removed cell list present */
          if(RRC_MSG_COMMON_BITMASK_IE_TYPE2(intra_freq_meas_rscp_ptr->intraFreqCellInfoSI_List, removedIntraFreqCellList) )
          {
            /* Call fn to fill cells to be removed */
            if ( rrcmeas_process_removed_intra_freq_cells(
              & intra_freq_meas_rscp_ptr->intraFreqCellInfoSI_List.removedIntraFreqCellList,
              & rrcmeas_sib12_ptr->intra_f.cell_list) == FAILURE )
            {
              WRRC_MSG0_HIGH("No cell removed from SIB12");
            }
          } /* End of if of removedIntraFreqCellList_present */

          /*  Process the new cell list */
          cell_count = 0;
          idx=0;

          rscp_intra_freq_cell_list_ptr =
            &intra_freq_meas_rscp_ptr->intraFreqCellInfoSI_List.
            newIntraFreqCellList;

          while ( (rscp_intra_freq_cell_list_ptr->n > idx) &&
            (cell_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is Non-NULL and cell count
            * hasn't exceeded the max. L1 can handle */

            if ( rscp_intra_freq_cell_list_ptr->elem[idx].cellInfo.
              modeSpecificInfo.t ==
              T_rrc_CellInfo_modeSpecificInfo_tdd)
            {
              /* Ignore TDD Cell move to next cell in cell list */

              idx++;
              continue;
            }

            /* Call a function to fill the cell info */
            if (rrcmeas_fill_rscp_cell_info(&rscp_intra_freq_cell_list_ptr->elem[idx].cellInfo,
              &rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info,
              ((rel5_ext_ptr != NULL) ? ((rel5_ext_ptr->n > idx) ? (&rel5_ext_ptr->elem[idx]) : NULL) : NULL)) == FAILURE )
            {

              WRRC_MSG0_HIGH("Ignoring this cell as incorrect cell info");
             idx++;
              continue;
            }

            /* Fill in the cell ID if present */
            if (RRC_MSG_LIST_BITMASK_IE(rscp_intra_freq_cell_list_ptr,
              rrc_NewIntraFreqCellSI_RSCP,intraFreqCellID))
            {

              cell_position = rscp_intra_freq_cell_list_ptr->elem[idx].intraFreqCellID;
            }
            else
            {
              cell_position = AVAILABLE_CELL_POSITION;
            }

            if ( rrcmeas_update_intra_freq_cell_list(
              &cell_position,
              &rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].
              cell_info.pri_scr_code) == RRCMEAS_SUCCESS)
            {
              /* PSC sucessfully stored in the cell info list variable */
              /* Now store psc in the sib12 in add cell for layer1 to use psc */
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].psc =
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].
                cell_info.pri_scr_code;

                  rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].
                    measure_in_idle_pch_fach = TRUE;

              /* Increment cell count as add cell successfully stored */
              cell_count ++;
            }  /* End of if of rrcmeas_update_intra_freq_cell_list */
            else
            {
              /* TBD  In Phase 2 */
              WRRC_MSG0_ERROR("CELL_INFO_LIST out of sync");
              break;

            }
            idx++;

            if ( (cell_count == L1_MAX_CELL_MEAS) &&
              (rscp_intra_freq_cell_list_ptr->n > idx) )
            {
              WRRC_MSG0_HIGH("Cannot include all Intra freq cells");
              break;
            }
          } /* while((rscp_intra_freq_cell_list_ptr != NULL) */

          /* Initialize cell count */
          rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add = cell_count;

          /* At this point all the cells from SIB12 have been read */

          /* Remove SIB12 removed cells them from SIB11 & add new cells given in
          * SIB12 to SIB11 list */

          /* Check if the following is present in SIB11 */

          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.cell_list_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.cell_list.num_cell_add != 0) )
          {
            if(!(RRC_MSG_COMMON_BITMASK_IE_TYPE2(intra_freq_meas_rscp_ptr->intraFreqCellInfoSI_List, removedIntraFreqCellList)))
            {
              RRC_SET_COMMON_MSG_TYPE2(intra_freq_meas_rscp_ptr->intraFreqCellInfoSI_List.removedIntraFreqCellList,
                rrc_RemovedIntraFreqCellList,removeNoIntraFreqCells);
            }
            rrcmeas_build_sib12_intra_freq_list_from_sib11(
              &intra_freq_meas_rscp_ptr->intraFreqCellInfoSI_List.removedIntraFreqCellList,
              &rrcmeas_sib11->intra_f.cell_list,
              &rrcmeas_sib12_ptr->intra_f.cell_list, tmp_intra_freq_cell_list);

          } /* End of if */

          for(cell_count = 0; cell_count < rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add; cell_count++)
          {
            if(sib18_present == TRUE)
            {
              rrcmeas_process_sib18_filtering(
                 tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
                 tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
                 &tmp_plmn_identity,
                 cell_count,
                 &(rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach),
                 (cell_count > 0)?rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count -1].measure_in_idle_pch_fach: TRUE);
            }
            else
            {
              /* Add code to set flag meas_pch_fach_idle to TRUE for the cell */
              WRRC_MSG1_MED("psc %d measured in IDLE,FACH,PCH,DCH",rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].psc);
            }
          }
        } /* Intra freq cell info list is present */
        else
        {
          if(rrcmeas_sib11->intra_f.cell_list_incl == TRUE)
          {
            WRRC_MSG0_HIGH("copying the cell info list from SIB11->SIB12");
            rrcmeas_sib12_ptr->intra_f.cell_list_incl = TRUE;
            for(sib11_cell_count = 0; sib11_cell_count < rrcmeas_sib11->intra_f.cell_list.num_cell_add; sib11_cell_count++)
            {
              WCDMA_MEMCPY(&rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[sib11_cell_count],
                           sizeof(rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[0]),
                           &rrcmeas_sib11->intra_f.cell_list.add_cell[sib11_cell_count],
                           sizeof(rrcmeas_sib11->intra_f.cell_list.add_cell[0]));
            }
            rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add
              =  rrcmeas_sib11->intra_f.cell_list.num_cell_add;
          }
        }




        /* Fill in Intra freq reporting quantity for RACH reporting */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
          rrc_IntraFreqMeasurementSysInfo_RSCP,intraFreqReportingQuantityForRACH))
        {
          /* Intra freq reporting quantity for RACH reporting is present */
          if ( RRC_CHECK_COMMON_MSG_TYPE(intra_freq_meas_rscp_ptr->intraFreqReportingQuantityForRACH.modeSpecificInfo,
            rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd ))
          {
            /* Intra freq reporting quantity for RACH present */
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan_incl = TRUE;

            /* Fill in SFN SFN TM delta */
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan.rach_sfn_tm_delta =
              RRCMEAS_RET_INTRA_FREQ_SFN_DELTA(
              intra_freq_meas_rscp_ptr->intraFreqReportingQuantityForRACH.sfn_SFN_OTD_Type);

            /* Fill in the rach reporting quantity */
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan.rach_rpt_quan =
              RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(
              intra_freq_meas_rscp_ptr->intraFreqReportingQuantityForRACH.
              modeSpecificInfo.u.fdd->intraFreqRepQuantityRACH_FDD);
          }  /* End of if of RACH_modeSpecificInfo_fdd */
        } /* Intra-freq reporting quantity present */
        else
        {
          /* Intra freq reporting quantity for RACH absent in SIB 12 */
          /* Check if present in SIB11 */
          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.rach_rpt_quan_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            WRRC_MSG0_HIGH("Intra freq rpt qty not in SIB12 picked from SIB11");
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan_incl = rrcmeas_sib11->intra_f.meas_quan_incl;
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan = rrcmeas_sib11->intra_f.rach_rpt_quan;
          } /* End of if */
        }  /* End of else of Intra-freq reporting quantity present*/

        /* Fill in max number of reported cells on RACH */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
          rrc_IntraFreqMeasurementSysInfo_RSCP,maxReportedCellsOnRACH))
        {
          /* Max reported cells on RACH is present */
          rrcmeas_sib12_ptr->intra_f.rach_rpt_max_incl = TRUE;

          /* Set max no of reported cells */
          rrcmeas_sib12_ptr->intra_f.rach_rpt_max =
            RRCMEAS_RET_RACH_REPORTED_CELLS(
            intra_freq_meas_rscp_ptr->maxReportedCellsOnRACH);

          if ( intra_freq_meas_rscp_ptr->maxReportedCellsOnRACH !=
            rrc_MaxReportedCellsOnRACH_noReport )
          {
            /* Set reporting criteria for RACH to no report */
            sib12_rach_report_crit = APPEND_RRC_MEAS_RACH_REPORT;
          }
        } /* End of if of maxReportedCellsOnRACH_present */
        else
        {
          /*  Max reported cells on RACH is absent */
          /* Check if present in SIB11 */
          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.rach_rpt_max_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            WRRC_MSG0_HIGH("Intra freq: Max reported cells on RACH not in SIB12 picked from SIB11");
            rrcmeas_sib12_ptr->intra_f.rach_rpt_max_incl = rrcmeas_sib11->intra_f.rach_rpt_max_incl;
            rrcmeas_sib12_ptr->intra_f.rach_rpt_max = rrcmeas_sib11->intra_f.rach_rpt_max;

            /* Set SIB12 RACH report criteria */
            sib12_rach_report_crit = sib11_rach_report_crit;
          } /* End of if */
        } /* End of else of maxReportedCellsOnRACH_present */

        /* Initialize DCH info present to FALSE */
        rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl = FALSE;

        /* Now check if the Reporting info in state Cell_DCH is present */
        if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
          rrc_IntraFreqMeasurementSysInfo_RSCP,reportingInfoForCellDCH))
        {
          /* Set report transfer mode */
          rrcmeas_sib12_ptr->intra_f.dch_rpt_info.rpt_trans_mode =
            RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
            intra_freq_meas_rscp_ptr->reportingInfoForCellDCH.
            measurementReportingMode.measurementReportTransferMode);

          /* To fill in the DCH info, call the following function */
          if (rrcmeas_fill_dch_state_info(
            &intra_freq_meas_rscp_ptr->reportingInfoForCellDCH,
            &rrcmeas_sib12_ptr->intra_f.dch_rpt_info, NULL, sib12_rel5_ext_ptr) == SUCCESS)
          {
            rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl = TRUE;
          }
        } /* if of Reporting info in state DCH present*/
        else
        {
          /* Check if present in SIB11 */
          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            WRRC_MSG0_HIGH("Intra freq: Reporting info in DCH not in SIB12 picked from SIB11");
            rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl =
              rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl;
            rrcmeas_sib12_ptr->intra_f.dch_rpt_info = rrcmeas_sib11->intra_f.dch_rpt_info;
          } /* End of if */
        } /* End of else */
      } /* Intra freq meas sys info is present */
    } /* Cell select reselect quality measure is RSCP */
    else if ( sib12_ptr->measurementControlSysInfo.use_of_HCS.u.
      hcs_not_used->cellSelectQualityMeasure.t ==
      T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_cpich_Ec_N0 )
    {
      /* The Cell Select Quality Measure is ECNO */
      rrcmeas_sib12_ptr->cell_sel_resel_quan_type =  L1_EC_NO;

      /* Check if Intra freq meas system info is present */
      if (!(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
        cellSelectQualityMeasure.u.cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent))
      {
        /* Copy the intra frequency measurement system information from SIB 11 to SIB 12 if present */
        if(rrcmeas_sib11->intra_freq_meas_info_incl == TRUE)
        {
          /* Copy the intra frequency measurement system information from SIB 11 to SIB 12 */
          WRRC_MSG0_HIGH("Copying the intra freq meas info from SIB11");
          rrcmeas_sib12_ptr->intra_freq_meas_info_incl = TRUE;
          WCDMA_MEMCPY(&rrcmeas_sib12_ptr->intra_f, 
                       sizeof(l1_intra_freq_sib_struct_type),
                       &rrcmeas_sib11->intra_f,
                       sizeof(l1_intra_freq_sib_struct_type));
          sib12_rach_report_crit = sib11_rach_report_crit;
          rrcmeas_set_intra_freq_meas_identity(&rrcmeas_sib12_ptr->intra_f);
        }
        return;
      }
      else
      {
        /* Intra freq meas sys info is present */
        rrcmeas_sib12_ptr->intra_freq_meas_info_incl     = TRUE;

        /* Associate a local pointer for readability */
        intra_freq_meas_ecn0_ptr =
          &sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo;

     
          /* Measurement ID present */
          rrcmeas_sib12_ptr->intra_f.meas_id =
            (uint16)intra_freq_meas_ecn0_ptr->intraFreqMeasurementID;
        

        /* Get the FDD Intra freq meas quantity if present */
        if((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
          rrc_IntraFreqMeasurementSysInfo_ECN0,intraFreqMeasQuantity))
          &&
          (RRC_CHECK_COMMON_MSG_TYPE(intra_freq_meas_ecn0_ptr->intraFreqMeasQuantity.modeSpecificInfo,
          rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd) ))
        {
          /* Intra freq meas quantity for FDD mode is present */
          rrcmeas_sib12_ptr->intra_f.meas_quan_incl = TRUE;

          /* Read value of meas quantity */
          rrcmeas_sib12_ptr->intra_f.meas_quan.quan_type =
            RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
            intra_freq_meas_ecn0_ptr->intraFreqMeasQuantity.modeSpecificInfo.u.
            fdd->intraFreqMeasQuantity_FDD);

          /* Get the Filter Coefficient if present*/

            rrcmeas_sib12_ptr->intra_f.meas_quan.filter_coef = (uint16)
              RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(
              intra_freq_meas_ecn0_ptr->intraFreqMeasQuantity.filterCoefficient);
          
        } /* End of if for FDD Intra freq meas quantity present */
        else
        {
          /* Intra freq meas quantity for FDD mode is not present */
          /* Check if present in SIB11 */
          /* If Intra FDD Freq meas quantity is absent, set it to NONE in L1 cmd */

          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.meas_quan_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            rrcmeas_sib12_ptr->intra_f.meas_quan_incl = rrcmeas_sib11->intra_f.meas_quan_incl;
            rrcmeas_sib12_ptr->intra_f.meas_quan = rrcmeas_sib11->intra_f.meas_quan;
            rrcmeas_sib12_ptr->intra_f.meas_quan.filter_coef = rrcmeas_sib11->intra_f.meas_quan.filter_coef;
          }
          else
          {  /* ASSIGN DEFAULT VALUES */
            rrcmeas_sib12_ptr->intra_f.meas_quan_incl = FALSE;
            rrcmeas_sib12_ptr->intra_f.meas_quan.quan_type = L1_MEAS_NONE;
            rrcmeas_sib12_ptr->intra_f.meas_quan.filter_coef = 0;
          }
        }

        if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
          rrc_IntraFreqMeasurementSysInfo_ECN0,intraFreqCellInfoSI_List))
        {
          /* Intra freq cell info list is present */
          rrcmeas_sib12_ptr->intra_f.cell_list_incl = TRUE;

          /* Check if removed cell list present */
          if(RRC_MSG_COMMON_BITMASK_IE(intra_freq_meas_ecn0_ptr->intraFreqCellInfoSI_List,
            rrc_IntraFreqCellInfoSI_List_ECN0,removedIntraFreqCellList) )
          {
            /* Call fn to fill cells to be removed */
            if ( rrcmeas_process_removed_intra_freq_cells(
              & intra_freq_meas_ecn0_ptr->intraFreqCellInfoSI_List.removedIntraFreqCellList,
              & rrcmeas_sib12_ptr->intra_f.cell_list) == FAILURE )
            {
              MSG_LOW("Unable to remove cell from SIB12",0,0,0);
            }
          } /* End of if of removedIntraFreqCellList_present */

          /* Process the new cell list */
          cell_count = 0;
          ecn0_intra_freq_cell_list_ptr =
            &intra_freq_meas_ecn0_ptr->intraFreqCellInfoSI_List.newIntraFreqCellList;
          idx=0;
          while ( (ecn0_intra_freq_cell_list_ptr->n > idx) &&
            (cell_count < L1_MAX_CELL_MEAS) )
          {
          /* Pointer to next cell is Non-NULL and cell count
            * hasn't exceeded the max. L1 can handle */
            if ( ecn0_intra_freq_cell_list_ptr->elem[idx].
              cellInfo.modeSpecificInfo.t ==
              T_rrc_CellInfo_modeSpecificInfo_tdd)
            {
              /* Nothing doing with a TDD cell. Shun it ! */

              idx++;
              continue;
            }

            /* Call a function to fill the cell info */

            if (rrcmeas_fill_ecn0_cell_info(&ecn0_intra_freq_cell_list_ptr->elem[idx].cellInfo,
              &rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].cell_info,
              ((rel5_ext_ptr != NULL) ? ((rel5_ext_ptr->n > idx) ? (&rel5_ext_ptr->elem[idx]) : NULL) : NULL)) == FAILURE )
            {
              WRRC_MSG0_HIGH("Ignoring cell info");
              idx++;
              continue;
            }


            /* Fill in the cell ID if present */
            if(RRC_MSG_LIST_BITMASK_IE(ecn0_intra_freq_cell_list_ptr,
              rrc_NewIntraFreqCellSI_ECN0,intraFreqCellID))
            {
              cell_position = ecn0_intra_freq_cell_list_ptr->elem[idx].intraFreqCellID;
            }
            else
            {
              cell_position = AVAILABLE_CELL_POSITION;
            }

            if(rrcmeas_update_intra_freq_cell_list(
              &cell_position,
              &rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].
              cell_info.pri_scr_code) == RRCMEAS_SUCCESS)
            {
              /* PSC sucessfully stored in the cell info list variable */
              /* Now store psc in the sib12 in add cell for layer1 to use psc */
              rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].psc =
                rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].
                cell_info.pri_scr_code;

                  rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].
                    measure_in_idle_pch_fach = TRUE;
              /* Increment cell count as add cell successfully stored */
              cell_count ++;
            }  /* End of if of rrcmeas_update_intra_freq_cell_list */

            idx++;
            if ( (cell_count == L1_MAX_CELL_MEAS) &&
              (ecn0_intra_freq_cell_list_ptr->n > idx) )
            {
              WRRC_MSG0_HIGH("Cannot include all Intra freq cells");
              break;
            }
          } /* while((ecn0_intra_freq_cell_list_ptr != NULL) */

          /* Initialize cell count */
          rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add = cell_count;

          /* At this point all the cells from SIB12 have been read */

          /* Remove SIB12 removed cells from SIB11 & add new cells given in
          * SIB12 to SIB11 list */

            /* Check if the following is present in SIB11 */

            if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
              (rrcmeas_sib11->intra_f.cell_list_incl == TRUE) &&
              (rrcmeas_sib11->intra_f.cell_list.num_cell_add != 0) )
            {

              if(!(RRC_MSG_COMMON_BITMASK_IE(intra_freq_meas_ecn0_ptr->intraFreqCellInfoSI_List,
                rrc_IntraFreqCellInfoSI_List_ECN0,removedIntraFreqCellList)))
              {
                RRC_SET_COMMON_MSG_TYPE2(intra_freq_meas_ecn0_ptr->intraFreqCellInfoSI_List.removedIntraFreqCellList,
                  rrc_RemovedIntraFreqCellList,removeNoIntraFreqCells);
              }
              rrcmeas_build_sib12_intra_freq_list_from_sib11(
                &intra_freq_meas_ecn0_ptr->intraFreqCellInfoSI_List.removedIntraFreqCellList,
                &rrcmeas_sib11->intra_f.cell_list,
                &rrcmeas_sib12_ptr->intra_f.cell_list, tmp_intra_freq_cell_list);

            } /* End of if */

            for(cell_count = 0; cell_count < rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add; cell_count++)
            {
              if(sib18_present == TRUE)
              {
                rrcmeas_process_sib18_filtering(
                   tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
                   tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
                   &tmp_plmn_identity,
                   cell_count,
                   &(rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach),
                   (cell_count > 0)?rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count -1].measure_in_idle_pch_fach: TRUE);
              }
              else
              {
                /* Add code to set flag meas_pch_fach_idle to TRUE for the cell */
                WRRC_MSG1_MED("psc %d measured in IDLE,FACH,PCH,DCH",rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[cell_count].psc);
              }
            }
        } /* Intra freq cell info list is present */
        else
        {
          if(rrcmeas_sib11->intra_f.cell_list_incl == TRUE)
          {
            WRRC_MSG0_HIGH("copying the cell info list from SIB11->SIB12");
            rrcmeas_sib12_ptr->intra_f.cell_list_incl = TRUE;
            for(sib11_cell_count = 0; sib11_cell_count < rrcmeas_sib11->intra_f.cell_list.num_cell_add; sib11_cell_count++)
            {
              WCDMA_MEMCPY(&rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[sib11_cell_count],
                           sizeof(rrcmeas_sib12_ptr->intra_f.cell_list.add_cell[0]),
                           &rrcmeas_sib11->intra_f.cell_list.add_cell[sib11_cell_count],
                           sizeof(rrcmeas_sib11->intra_f.cell_list.add_cell[0]));
            }
            rrcmeas_sib12_ptr->intra_f.cell_list.num_cell_add
              =  rrcmeas_sib11->intra_f.cell_list.num_cell_add;
          }
        }
        /* Fill in Intra freq reporting quantity for RACH reporting */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
          rrc_IntraFreqMeasurementSysInfo_ECN0,intraFreqReportingQuantityForRACH))
        {
          /* Fill in the FDD reporting quantity if present */
          if (RRC_CHECK_COMMON_MSG_TYPE( intra_freq_meas_ecn0_ptr->
            intraFreqReportingQuantityForRACH.modeSpecificInfo,
            rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd) )
          {
            /* Intra freq reporting quantity for RACH present */
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan_incl = TRUE;

            /* Fill in SFN SFN TM delta */
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan.rach_sfn_tm_delta =
              RRCMEAS_RET_INTRA_FREQ_SFN_DELTA(
              intra_freq_meas_ecn0_ptr->intraFreqReportingQuantityForRACH.sfn_SFN_OTD_Type);


            /* Fill in the rach reporting quantity */
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan.rach_rpt_quan =
              RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(
              intra_freq_meas_ecn0_ptr->intraFreqReportingQuantityForRACH.
              modeSpecificInfo.u.fdd->intraFreqRepQuantityRACH_FDD);

          } /* End of if of RACH_modeSpecificInfo_fdd */
        }  /* Intra-freq reporting quantity present */
        else
        {
          /* Intra freq reporting quantity for RACH absent in SIB 12 */
          /* Check if present in SIB11 */

          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.rach_rpt_quan_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            WRRC_MSG0_HIGH("Intra freq: rpt qty not in SIB12 picked from SIB11");
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan_incl =
              rrcmeas_sib11->intra_f.meas_quan_incl;
            rrcmeas_sib12_ptr->intra_f.rach_rpt_quan =
              rrcmeas_sib11->intra_f.rach_rpt_quan;
          } /* End of if */
        }  /* End of else of Intra-freq reporting quantity present*/

        /* Fill in max number of reported cells on RACH */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
          rrc_IntraFreqMeasurementSysInfo_ECN0,maxReportedCellsOnRACH))
        {
          /* Max reported cells on RACH present */
          rrcmeas_sib12_ptr->intra_f.rach_rpt_max_incl  = TRUE;

          /* Set max no of reported cells */
          rrcmeas_sib12_ptr->intra_f.rach_rpt_max =
            RRCMEAS_RET_RACH_REPORTED_CELLS(
            intra_freq_meas_ecn0_ptr->maxReportedCellsOnRACH);

          if ( intra_freq_meas_ecn0_ptr->maxReportedCellsOnRACH !=
            rrc_MaxReportedCellsOnRACH_noReport )
          {
            /* Set reporting criteria for RACH to no report */
            sib12_rach_report_crit = APPEND_RRC_MEAS_RACH_REPORT;
          }
        } /* End of if of maxReportedCellsOnRACH_present */
        else
        {
          /*  Max reported cells on RACH is absent */
          /* Check if present in SIB11 */
          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.rach_rpt_max_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            WRRC_MSG0_HIGH("Intra freq: Max reported cells on RACH not in SIB12 picked from SIB11");
            rrcmeas_sib12_ptr->intra_f.rach_rpt_max_incl =
              rrcmeas_sib11->intra_f.rach_rpt_max_incl;

            rrcmeas_sib12_ptr->intra_f.rach_rpt_max =
              rrcmeas_sib11->intra_f.rach_rpt_max;

            /* Copy SIB11 RACH report criteria */
            sib12_rach_report_crit = sib11_rach_report_crit;
          } /* End of if */
        } /* End of else of maxReportedCellsOnRACH_present*/

        /* Initialize DCH info present to FALSE */
        rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl = FALSE;

        /* Now check if the Reporting info in state Cell_DCH is present */
        if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
          rrc_IntraFreqMeasurementSysInfo_ECN0,reportingInfoForCellDCH))
        {
          rrcmeas_sib12_ptr->intra_f.dch_rpt_info.rpt_trans_mode =
            RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
            intra_freq_meas_ecn0_ptr->reportingInfoForCellDCH.
            measurementReportingMode.measurementReportTransferMode);

          /* To fill in the DCH info, call the following function */
          if ( rrcmeas_fill_dch_state_info(
            &intra_freq_meas_ecn0_ptr->reportingInfoForCellDCH,
            & rrcmeas_sib12_ptr->intra_f.dch_rpt_info, NULL, sib12_rel5_ext_ptr) == SUCCESS )
          {
            rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl = TRUE;
          }
        } /* if of Reporting info in state DCH present*/
        else
        {
          /* Check if present in SIB11 */
          if ( (rrcmeas_sib11->intra_freq_meas_info_incl == TRUE) &&
            (rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl == TRUE) )
          {
            /* Store meas quantity from SIB11 */
            WRRC_MSG0_HIGH("Intra freq: Reporting info in DCH not in SIB12 picked from SIB11");
            rrcmeas_sib12_ptr->intra_f.intra_f_dch_rpt_info_incl =
              rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl;

            rrcmeas_sib12_ptr->intra_f.dch_rpt_info =
              rrcmeas_sib11->intra_f.dch_rpt_info;
          } /* End of if */
        } /* End of else */
      } /* Intra freq meas sys info is present */
    } /* Cell select reselect quality measure is EcIo */
    else
    {
      WRRC_MSG0_HIGH("SIB12 Cell Select measure != ECN0/RSCP.");
      /* This SIB12 does not indicate anything useful */
      return;
    }
  }  /* HCS is NOT in use */

  /* Set Measurement in RRC Intra Freq DB */
  rrcmeas_set_intra_freq_meas_identity(&rrcmeas_sib12_ptr->intra_f);
  return;
}

/*===========================================================================

FUNCTION          RRCMEAS_FIND_MEAS_TYPE_FOR_L1

DESCRIPTION

 This function finds if the additional measurement is configured 
 for this measurement type

DEPENDENCIES

 None.

RETURN VALUE

 MEAS_TYPE.

SIDE EFFECTS

 None.

===========================================================================*/
l1_meas_type_enum_type rrcmeas_find_meas_type_for_l1
(
 uint16* additional_meas_id_ptr
)
{
  uint8 count = 0;
  /* Check in UE Internal Meas */
  for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
  {
    if (ueim_meas_id_list[count].meas_id == *additional_meas_id_ptr)
    {
      WRRC_MSG1_HIGH("Addt.Meas %d is UE Internal",*additional_meas_id_ptr);
      return L1_UE_INTERNAL;
    }

  }
  /* Check in Intra Freq Meas */
  for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
  {
    if (intra_freq_meas_id_list[count].meas_id == *additional_meas_id_ptr)
    {
      WRRC_MSG1_HIGH("Addt.Meas %d is Intra-Freq",*additional_meas_id_ptr);
      return L1_INTRA_FREQ;
    }
  }

  /* Check in Intra RAT Meas */
  for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
  {
    if (inter_rat_meas_id_list[count].meas_id == *additional_meas_id_ptr)
    {
      WRRC_MSG1_HIGH("Addt.Meas %d is Inter-RAT",*additional_meas_id_ptr);
      return L1_INTER_SYS;
    }
    
  }
  /* Check in Traffic Volume Meas */
  for (count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++)
  {
    if (tvm_meas_id_list[count].meas_id == *additional_meas_id_ptr)
    {
      WRRC_MSG1_HIGH("Addt.Meas %d is TrafficVolume",*additional_meas_id_ptr);
      return L1_TRAF_VOL;
    }
  }


  /* Check in Intra Freq Meas */
  for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
  {
    if (inter_freq_meas_id_list[count].meas_id == *additional_meas_id_ptr)
    {
      WRRC_MSG1_HIGH("IFreq:Addt.Meas %d is Inter-Freq",*additional_meas_id_ptr);
      return L1_INTER_FREQ;
    }
    
  }

  /* Check in Quality Meas */
  for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
  {
    if (quality_meas_id_list[count].meas_id == *additional_meas_id_ptr)
    {
      WRRC_MSG1_HIGH("Addt.Meas %d is Quality",*additional_meas_id_ptr);
      return L1_QUALITY;
    }
  }

  WRRC_MSG1_ERROR("Not Found. AddtMeas %d & its type",*additional_meas_id_ptr);
  return L1_MEAS_TYPE_INVALID;

}


/*===========================================================================

FUNCTION          RRCMEAS_SEND_L1_CMD

DESCRIPTION

 This function sends measurement requests to L1.
 Since all L1 cmds go via LLC, the LLC command
 RRC_LLC_CMD_REQ actaully encapsules the real L1
 command. This is the LLC command funneling mechanism.
 It frees allocated command and embedded buffers when failure
 is detected before sending the command.

DEPENDENCIES

 None.

RETURN VALUE

 None.

SIDE EFFECTS

 None.

===========================================================================*/

void rrcmeas_send_l1_cmd
(
l1_meas_sib_parm_struct_type* rrcmeas_sib_ptr,
l1_meas_ctrl_parm_struct_type* rrcmeas_mcm_ptr,
l1_meas_trans_type* rrcmeas_trans_ptr,
l1_meas_ctrl_enum_type  meas_choice
)
{
  /* Ptr which carries info about the command */
  rrc_cmd_type        *rrc_meas_out_cmd_ptr = NULL;
  uint8 cnt=0;
  l1_req_cmd * llc_cmd_l1_req = NULL;
  uint8 i=0;
#ifdef FEATURE_QSH_EVENT_METRIC
  rrc_log_rrc_mcm_ota mcm_params;
  uint8 event_cnt = 0;

#endif
  if(meas_choice == L1_MEAS_CTRL_PARMS)
  {
     if(((rrcmeas_mcm_ptr->meas_object.meas_type == L1_INTER_FREQ)
          &&(rrc_disable_meas_nv & RRC_DISABLE_WTOW_CM_MEAS))

        || ((rrcmeas_mcm_ptr->meas_object.meas_type == L1_INTER_SYS)
             &&(rrc_disable_meas_nv & RRC_DISABLE_WTOG_CM_MEAS))

        || ((rrcmeas_mcm_ptr->meas_object.meas_type == L1_INTER_SYS_EUTRA)
             &&(rrc_disable_meas_nv & RRC_DISABLE_WTOL_CM_MEAS))
        )
     {
        WRRC_MSG1_HIGH("Skip IRAT/IFREQ meas..Disable IRAT/IFREQ NV %d ",rrc_disable_meas_nv);
        return;
     }
  }

    /* Now allocate memory */
    rrc_meas_out_cmd_ptr = rrc_get_int_cmd_buf();
    RRC_GET_POINTER_L1_REQ_VALUE(rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.l1_req,llc_cmd_l1_req);

    /* Initialize the LLC command header first */

    rrc_meas_out_cmd_ptr->cmd_hdr.cmd_id= RRC_LLC_CMD_REQ;
    rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.procedure = RRC_PROCEDURE_MCMR;

    rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.cmd_dest = LAYER1_PHY;

    /* Now fill the L1 cmd header */
    rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id = CPHY_MEASUREMENT_REQ;

    /* act_time_type */
    rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.l1_cmd.act_time_type =
      L1_ACTIVATION_TIME_NONE;

    /* Now allocate memory to the pointer inside the command */
    llc_cmd_l1_req->meas.meas_ptr =
      (l1_meas_parm_type *)rrc_malloc_interlayer_cmd(sizeof(l1_meas_parm_type));

#ifdef FEATURE_WCDMA_INTER_FREQ_RACH_REPORTING
    #error code not present
#endif
    /* Now fill the values inside the ptr */
    if ( meas_choice == L1_SIB_PARMS)
    {
      llc_cmd_l1_req->meas.meas_ptr->u.sib =
      *rrcmeas_sib_ptr;
      WRRC_MSG1_MED(" %d-Intrafreq cells will be sent to L1",rrcmeas_sib_ptr->intra_f.cell_list.num_cell_add);

    }
    else if (meas_choice == L1_MEAS_CTRL_PARMS)
    {
      llc_cmd_l1_req->meas.meas_ptr->u.ctrl =
      *rrcmeas_mcm_ptr;
#ifdef FEATURE_QSH_EVENT_METRIC
        memset(&mcm_params,0,sizeof(rrc_log_rrc_mcm_ota));  		
        mcm_params.meas_id = llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_id;
        mcm_params.meas_type = llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.meas_type;

        if(mcm_params.meas_type == L1_INTRA_FREQ)
        {
          mcm_params.meas_rpt_type = llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.intra_f.rpt_mode[0];
          if((mcm_params.meas_rpt_type == L1_EVENT_TRIGGER_RPT) && (llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.intra_f.rpt_crit[0].num_event))
          {
            for(event_cnt; event_cnt < llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.intra_f.rpt_crit[0].num_event; event_cnt++)
            {
              mcm_params.meas_event_id_bmask |= (1 << llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.intra_f.rpt_crit[0].evt[event_cnt].evt_id);;
            }
          }
        }
        else if(mcm_params.meas_type == L1_INTER_FREQ)
        {
          mcm_params.meas_rpt_type = llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.inter_f.rpt_mode;
          if((mcm_params.meas_rpt_type == L1_EVENT_TRIGGER_RPT) && (llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.inter_f.u.inter_rpt_crit.num_event))
          {
            for(event_cnt; event_cnt < llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.inter_f.u.inter_rpt_crit.num_event; event_cnt++)
            {
              mcm_params.meas_event_id_bmask |= (1<<llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.inter_f.u.inter_rpt_crit.evt[event_cnt].evt_id);;
            }
          }
        }
        else if(mcm_params.meas_type == L1_INTER_SYS)
        {
          mcm_params.meas_rpt_type = llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.inter_s.rpt_criteria.rpt_mode;
          if((mcm_params.meas_rpt_type == L1_EVENT_TRIGGER_RPT) && (llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.inter_s.rpt_criteria.u.evt_rpt_crit.num_event))
          {
            for(event_cnt; event_cnt < llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.inter_s.rpt_criteria.u.evt_rpt_crit.num_event; event_cnt++)
            {
              mcm_params.meas_event_id_bmask |= (1<<llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.inter_s.rpt_criteria.u.evt_rpt_crit.evt[event_cnt].evt_id);;
            }
          }
        }
        else if(mcm_params.meas_type == L1_INTER_SYS_EUTRA)
        {
          mcm_params.meas_rpt_type = llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.inter_s_eutra.rpt_criteria.rpt_mode;
          if((mcm_params.meas_rpt_type == L1_EVENT_TRIGGER_RPT) && (llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.inter_s_eutra.rpt_criteria.u.evt_rpt_crit.num_event))
          {
            for(event_cnt; event_cnt < llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.inter_s_eutra.rpt_criteria.u.evt_rpt_crit.num_event; event_cnt++)
            {
              mcm_params.meas_event_id_bmask |= (1<<llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.inter_s_eutra.rpt_criteria.u.evt_rpt_crit.evt[event_cnt].evt_id);;
            }
          }
        }
        else if(mcm_params.meas_type == L1_QUALITY)
        {
          mcm_params.meas_rpt_type = llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_object.u.qual.rpt_mode;
        }
        rrc_qsh_log_meas_ctrl_params(&mcm_params);
#endif
       if(llc_cmd_l1_req->meas.meas_ptr->u.ctrl.num_add_meas != 0)
       {
         cnt=0;
         if(rrcmeas_find_meas_type_for_l1(&llc_cmd_l1_req->meas.meas_ptr->u.ctrl.meas_id) == L1_QUALITY)
         {
           while((llc_cmd_l1_req->meas.meas_ptr->u.ctrl.num_add_meas  > cnt) && (cnt < MAX_ADDITIONAL_MEAS))
           {
             llc_cmd_l1_req->meas.meas_ptr->u.ctrl.addl_meas_type[cnt] = rrcmeas_find_meas_type_for_l1(&llc_cmd_l1_req->meas.meas_ptr->u.ctrl.add_meas[cnt]);

             WRRC_MSG2_HIGH("ADDITIONAL MEAS ID %d  TYPE %d SENT TO L1 ",llc_cmd_l1_req->meas.meas_ptr->u.ctrl.add_meas[cnt]
              ,llc_cmd_l1_req->meas.meas_ptr->u.ctrl.addl_meas_type[cnt]);
             cnt++;
          }
        }
      }
    }
    else
    {
      llc_cmd_l1_req->meas.meas_ptr->u.trans_meas =
      *rrcmeas_trans_ptr;
#ifdef FEATURE_WCDMA_INTER_FREQ_RACH_REPORTING
      #error code not present
#endif /*FEATURE_WCDMA_INTER_FREQ_RACH_REPORTING*/
    }
  /* Fill in param t */
    llc_cmd_l1_req->meas.meas_ptr->parm_type =
      meas_choice;
  rrc_log_meas_info(rrcmeas_sib_ptr,rrcmeas_mcm_ptr,rrcmeas_trans_ptr,meas_choice,NULL);
  /* Send the Internal RRC Command - LLC should directly handle it */
  rrc_put_int_cmd( rrc_meas_out_cmd_ptr );
  WRRC_MSG1_HIGH("Sending Meas Req to L1, meas choice : %d",meas_choice);
}

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
/*===========================================================================

FUNCTION          RRCMEAS_SEND_DEFERRED_MEAS_REQ

DESCRIPTION

 This function sends CPHY_MEASUREMENT_REQ to L1 with parm type as
 L1_DEFERRED_MEASUREMENT_FROM_SIB. This parm type is chosen when 
 SIB11 hasn't been read. Depending on the state transition, meas identity 
 and cell info list are to be cleared. Also, meas quan should be chosen appropriately
 depending on whether SIB3 has been read or not.
 
 Since all L1 cmds go via LLC, the LLC command
 RRC_LLC_CMD_REQ actaully encapsules the real L1
 command. This is the LLC command funneling mechanism.
 It frees allocated command and embedded buffers when failure
 is detected before sending the command.

DEPENDENCIES

 None.

RETURN VALUE

 None.

SIDE EFFECTS

 None.

===========================================================================*/

void rrcmeas_send_deferred_meas_req
(
  uint8  l1_deferred_meas_from_sib_action
)
{
  /* Ptr which carries info about the command */
  rrc_cmd_type        *rrc_meas_out_cmd_ptr = NULL;

  l1_req_cmd * llc_cmd_l1_req = NULL;

  /* Now allocate memory */
  rrc_meas_out_cmd_ptr = rrc_get_int_cmd_buf();
  RRC_GET_POINTER_L1_REQ_VALUE(rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.l1_req,llc_cmd_l1_req);

  /* Initialize the LLC command header first */

  rrc_meas_out_cmd_ptr->cmd_hdr.cmd_id= RRC_LLC_CMD_REQ;
  rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.procedure = RRC_PROCEDURE_MCMR;

  rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.cmd_dest = LAYER1_PHY;

  /* Now fill the L1 cmd header */
  rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id = CPHY_MEASUREMENT_REQ;

  /* act_time_type */
  rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.l1_cmd.act_time_type =
    L1_ACTIVATION_TIME_NONE;

  /* Now allocate memory to the pointer inside the command */
  llc_cmd_l1_req->meas.meas_ptr =
        (l1_meas_parm_type *)rrc_malloc_interlayer_cmd(sizeof(l1_meas_parm_type));
#ifdef FEATURE_WCDMA_INTER_FREQ_RACH_REPORTING
  #error code not present
#endif

  llc_cmd_l1_req->meas.meas_ptr->u.deferred_meas_from_sib.meas_quan = 
    rrc_sibdb_return_intra_freq_meas_quan_for_deferred_sib();

  llc_cmd_l1_req->meas.meas_ptr->u.deferred_meas_from_sib.l1_deferred_meas_from_sib_action =
    l1_deferred_meas_from_sib_action;

  /* Fill in param choice */
  llc_cmd_l1_req->meas.meas_ptr->parm_type =
    L1_DEFERRED_MEASUREMENT_FROM_SIB;

  /* Send the Internal RRC Command - LLC should directly handle it */
  rrc_put_int_cmd( rrc_meas_out_cmd_ptr );
}
#endif

/*===========================================================================

FUNCTION          RRCMEAS_FIND_MEAS_ID_IDX

DESCRIPTION

 This function finds measurement ID index and return the same.

DEPENDENCIES

 None.

RETURN VALUE
 UINT8


SIDE EFFECTS

 None.

===========================================================================*/

uint8 rrcmeas_find_meas_id_idx(uint8 meas_id)
{
  uint8 count = 0;
  uint8 ret_val = MAX_INTRA_FREQ_MEAS;
  
      for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
      {
        if (intra_freq_meas_id_list[count].meas_id == meas_id)
        {
          WRRC_MSG2_HIGH("Finding meas id idx =  %d, meas id = %d ", count,meas_id);
          ret_val = count;
          break;  
        }
      }
    return  ret_val; 
}

/*===========================================================================

FUNCTION          RRCMEAS_FIND_LEGACY_MEAS_ID

DESCRIPTION

 This function finds the legacy measurement identity
 to be filled in measurement report when extended measurements 
 are supported corresponding to the extended measurement identity

DEPENDENCIES

 None.

RETURN VALUE
 UINT8


SIDE EFFECTS

 None.

===========================================================================*/
uint8 rrcmeas_find_legacy_meas_id(uint8 meas_type, uint8 meas_id)
{
  uint8 count = 0;
  uint8 ret_val = INVALID_MEAS_ID;
  rrcmeas_layer_e_type meas_type_log = NOT_EXIST;
  
  switch(meas_type)
  {
    case INTRA_FREQ:

      for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
      {
        if (intra_freq_meas_id_list[count].meas_id == meas_id)
        {
          meas_type_log = INTRA_FREQ;        
          ret_val = intra_freq_meas_id_list[count].meas_id_legacy;
          break;
        }
      }
    break;

    case INTER_FREQ:

      /* Check in Intra Freq Meas */
      for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
      {
        if (inter_freq_meas_id_list[count].meas_id == meas_id)
        {
          meas_type_log = INTER_FREQ;                
          ret_val =  inter_freq_meas_id_list[count].meas_id_legacy;
          break;
        }
      }
    break;

    case INTER_SYS:

      /* Check in Intra Freq Meas */
      for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
      {
        if (inter_rat_meas_id_list[count].meas_id == meas_id)
        {
          meas_type_log = INTER_SYS;                
          ret_val = inter_rat_meas_id_list[count].meas_id_legacy;
          break;
        }
      }
    break;
    
    case INTERNAL_MEAS:

      /* Check in Intra Freq Meas */
      for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
      {
        if (ueim_meas_id_list[count].meas_id == meas_id)
        {
          meas_type_log = INTERNAL_MEAS;                
          ret_val = ueim_meas_id_list[count].meas_id_legacy;
          break;
        }
      }
    break;

    case MAC_MEAS:

      /* Check in Intra Freq Meas */
      for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
      {
        if (tvm_meas_id_list[count].meas_id == meas_id)
        {
          meas_type_log = MAC_MEAS;                
          ret_val =  tvm_meas_id_list[count].meas_id_legacy;
          break;
        }
      }
    break;

    case QUALITY_MEAS:

      /* Check in Intra Freq Meas */
      for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
      {
        if (quality_meas_id_list[count].meas_id == meas_id)
        {
          meas_type_log = QUALITY_MEAS;                
          ret_val = quality_meas_id_list[count].meas_id_legacy;
          break;
        }
      }
    break;

#ifdef FEATURE_CGPS_UMTS_CP_WCDMA
    case POSITION_MEAS:
    	
      /* Check in Intra Freq Meas */
      for ( count = 0; count < MAX_POS_MEAS; count++ )
      {
        if (pos_meas_id_list[count].meas_id == meas_id)
        {
          meas_type_log = POSITION_MEAS;                
           ret_val = pos_meas_id_list[count].meas_id_legacy;
           break;
        }
      }
    break;
#endif

    default:
      MSG_LOW("Unknown Meas. Shouldn't happen",0,0,0);
  }

  MSG_HIGH("Found legacy meas id  =  %d, idx = %d, meas type %d ",ret_val, count, meas_type_log);
  return ret_val;
}


/*===========================================================================

FUNCTION          RRCMEAS_FILL_MEAS_ID

DESCRIPTION

 This function fills the measurement identity depending on whether the extended
 measurements are supported or not

DEPENDENCIES

 None.

RETURN VALUE
 None


SIDE EFFECTS

 None.

===========================================================================*/
void rrcmeas_fill_meas_id
(
  rrc_MeasurementReport *meas_rpt_ptr,
  uint16 meas_id,
  uint8 meas_type
)  
{
  uint8 meas_id_val = 0;
  rrc_MeasurementReport_v590NonCriticalExtensions *mrm_v590 = NULL;
  rrc_MeasurementReport_v770NonCriticalExtensions *mrm_v770 = NULL;

  /* First store the meas id */
  if((rrc_meas_id_extn_support) && (meas_id > MIN_MEAS_ID_EXTN ) &&
     (meas_id != INVALID_MEAS_ID))
  {
    /* Filling the legacy meas id is very important else ASN encoding will fail 
       Though extended meas id is the actual meas id, here legacy IE is filled
       with the value received in MCM for the same legacy IE */
    meas_id_val = rrcmeas_find_legacy_meas_id(meas_type, meas_id);
      
    if(meas_id_val!= INVALID_MEAS_ID)
    {
      meas_rpt_ptr->measurementIdentity = meas_id_val;
    }

    meas_rpt_ptr->m.v390nonCriticalExtensionsPresent  = 1;

    meas_rpt_ptr->v390nonCriticalExtensions.m.laterNonCriticalExtensionsPresent = 1;

    meas_rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.m.
      v4b0NonCriticalExtensionsPresent = 1;
      
    meas_rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.
      v4b0NonCriticalExtensions.m.v590NonCriticalExtensionsPresent = 1;

    mrm_v590 = &meas_rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.
      v4b0NonCriticalExtensions.v590NonCriticalExtensions;

    mrm_v590->m.v5b0NonCriticalExtensionsPresent = 1;
    mrm_v590->v5b0NonCriticalExtensions.m.v690NonCriticalExtensionsPresent = 1;
    mrm_v590->v5b0NonCriticalExtensions.v690NonCriticalExtensions.m.v770NonCriticalExtensionsPresent =1;
    mrm_v770= &mrm_v590->v5b0NonCriticalExtensions.v690NonCriticalExtensions.v770NonCriticalExtensions;
    mrm_v770->m.v860NonCriticalExtensionsPresent = 1;
    mrm_v770->v860NonCriticalExtensions.m.v920NonCriticalExtensionsPresent = 1;
    mrm_v770->v860NonCriticalExtensions.v920NonCriticalExtensions.m.v970NonCriticalExtensionsPresent = 1;
    mrm_v770->v860NonCriticalExtensions.v920NonCriticalExtensions.v970NonCriticalExtensions.
      measurementReport_v970ext_IE.m.measurementIdentityPresent = 1;
    mrm_v770->v860NonCriticalExtensions.v920NonCriticalExtensions.v970NonCriticalExtensions.
      measurementReport_v970ext_IE.measurementIdentity = (rrc_MeasurementIdentityExt) meas_id;
  }
  else
  {
    meas_rpt_ptr->measurementIdentity =
     (rrc_MeasurementIdentity)meas_id;
  }
  WRRC_MSG2_HIGH("Legacy Meas ID : %d, Extd Meas ID",meas_rpt_ptr->measurementIdentity,meas_id);
}


/*===========================================================================

FUNCTION          RRCMEAS_APPEND_PRIMARY_MEAS_RESULTS

DESCRIPTION

 This function appends measured results for primary frequency 
 when included by L1 in CPHY_MEASUREMENT_IND.
 
DEPENDENCIES

 None.

RETURN VALUE

 None.

SIDE EFFECTS

 None.

===========================================================================*/
void  rrcmeas_append_primary_meas_results
  (rrc_UL_DCCH_Message *msg_ptr,
   l1_meas_rpt_struct_type *l1_meas_report_ptr)

{
  uint16 cell_number = 0;

  /* Struct ptr declared to store values of intra-freq next ptr */
  rrc_IntraFreqMeasuredResultsList* intra_freq_measured_results_list_ptr = NULL;
  rrc_IntraFrequencyMeasuredResultsList_v590ext *intra_freq_meas_res_ext_ptr = NULL;

  if(rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
  {
    msg_ptr->message.u.measurementReport.m.v390nonCriticalExtensionsPresent =1;

    msg_ptr->message.u.measurementReport.v390nonCriticalExtensions.m.laterNonCriticalExtensionsPresent =1;
    msg_ptr->message.u.measurementReport.v390nonCriticalExtensions.laterNonCriticalExtensions.m.
      v4b0NonCriticalExtensionsPresent =1;

    msg_ptr->message.u.measurementReport.v390nonCriticalExtensions.laterNonCriticalExtensions.
      v4b0NonCriticalExtensions.m.v590NonCriticalExtensionsPresent =1;

    msg_ptr->message.u.measurementReport.v390nonCriticalExtensions.laterNonCriticalExtensions.
      v4b0NonCriticalExtensions.v590NonCriticalExtensions.measurementReport_v590ext.m.
      measuredResults_v590extPresent =1;

    RRC_SET_COMMON_MSG_TYPE2(msg_ptr->message.u.measurementReport.v390nonCriticalExtensions.laterNonCriticalExtensions.
      v4b0NonCriticalExtensions.v590NonCriticalExtensions.measurementReport_v590ext.
      measuredResults_v590ext,rrc_MeasuredResults_v590ext,intraFrequencyMeasuredResultsList);

    intra_freq_meas_res_ext_ptr = rtxMemAllocTypeZ(&enc_ctxt,rrc_IntraFrequencyMeasuredResultsList_v590ext);
    if ( intra_freq_meas_res_ext_ptr == NULL )
    {
      ERR_FATAL("Failed to allocate memory",0,0,0);
    }

    if( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].num_cells < L1_MAX_CELL_MEAS)
    {
      intra_freq_meas_res_ext_ptr->n =  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].num_cells;
    }
    else
    {
      intra_freq_meas_res_ext_ptr->n = L1_MAX_CELL_MEAS;
    } 

    ALLOC_ASN1ARRAY2(&enc_ctxt,intra_freq_meas_res_ext_ptr,
      rrc_DeltaRSCPPerCell);
  
    RRC_RESET_MSG_IE_PRESENT(intra_freq_meas_res_ext_ptr->elem[0]);
    msg_ptr->message.u.measurementReport.v390nonCriticalExtensions.laterNonCriticalExtensions.
      v4b0NonCriticalExtensions.v590NonCriticalExtensions.measurementReport_v590ext.
      measuredResults_v590ext.u.intraFrequencyMeasuredResultsList = intra_freq_meas_res_ext_ptr;
  }
  /* Store bit mask to indicate measured results present */
  RRC_MSG_COMMON_SET_BITMASK_IE(msg_ptr->message.u.measurementReport,
  rrc_MeasurementReport,measuredResults);


  /* Set measured results present */
  RRC_SET_COMMON_MSG_TYPE(msg_ptr->message.u.measurementReport.measuredResults,
  rrc_MeasuredResults_intraFreqMeasuredResultsList);

  MSG_LOW("No of cells sent by L1 is %d",  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].num_cells,0,0);

  /* Allocate memory for intra-freq result structure */

  intra_freq_measured_results_list_ptr =
  rtxMemAllocTypeZ(&enc_ctxt,rrc_IntraFreqMeasuredResultsList);

  if ( intra_freq_measured_results_list_ptr == NULL )
  {
    ERR_FATAL("Failed to allocate memory",0,0,0);
  }

  if( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].num_cells < L1_MAX_CELL_MEAS)
  {
    intra_freq_measured_results_list_ptr->n =  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].num_cells;
  }
  else
  {
    intra_freq_measured_results_list_ptr->n = L1_MAX_CELL_MEAS;
  }

  ALLOC_ASN1ARRAY2(&enc_ctxt,intra_freq_measured_results_list_ptr,
    rrc_CellMeasuredResults);

  /* Update the linked list head ptr */
  msg_ptr->message.u.measurementReport.measuredResults.u.
    intraFreqMeasuredResultsList = intra_freq_measured_results_list_ptr;

  /* Set bit mask */
  RRC_RESET_MSG_IE_PRESENT(intra_freq_measured_results_list_ptr->elem[0]);

  /* Read all the cell measured results in a for loop.
  * Also set the scrambling code list for event results in the loop*/
  for ( cell_number = 0; (cell_number <  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].num_cells) && ( cell_number < L1_MAX_CELL_MEAS );
  cell_number++ )
  {
    RRC_RESET_MSG_IE_PRESENT(intra_freq_measured_results_list_ptr->elem[cell_number]);
    if(intra_freq_meas_res_ext_ptr != NULL)
    {
      RRC_RESET_MSG_IE_PRESENT(intra_freq_meas_res_ext_ptr->elem[cell_number]);
    }
    if ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].sfn_rpt_ind == L1_NO_REPORT)
    {
      MSG_LOW("SFN SFN observed time diff not set", 0,0,0);
    }
    else
    {
      /* Set bit mask to sfn_sfn present */
      intra_freq_measured_results_list_ptr->elem[cell_number].m.dummyPresent=1;

      /* Store sfn-sfn type indicator */

      if (  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].sfn_rpt_ind == L1_REPORT_TYPE_1)
      {
        intra_freq_measured_results_list_ptr->elem[cell_number].dummy.t =  T_rrc_SFN_SFN_ObsTimeDifference_type1;

        MSG_LOW("Report type 1 selected", 0,0,0);
        /* Type 1 report */
        if ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].sfn_sfn_tm_diff <=
          SFN_SFN_TYPE1_MAX_VALUE)
        {
          intra_freq_measured_results_list_ptr->elem[cell_number].dummy.u.type1 =
          l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].sfn_sfn_tm_diff;
        }
        else
        {
          WRRC_MSG1_ERROR("Incorrect SFN-SFN type1 value %d",
          l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].sfn_sfn_tm_diff);

          intra_freq_measured_results_list_ptr->elem[cell_number].dummy.u.type1 =
            SFN_SFN_TYPE1_MIN_VALUE;
        }

      }
      else
      {
        MSG_LOW("Report type 2 selected", 0,0,0);
        intra_freq_measured_results_list_ptr->elem[cell_number].dummy.t =  T_rrc_SFN_SFN_ObsTimeDifference_type2;
        /* Type 2 report */

        if ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].sfn_sfn_tm_diff <=
             SFN_SFN_TYPE2_MAX_VALUE)
        {
          intra_freq_measured_results_list_ptr->elem[cell_number].dummy.u.type2 =
           (uint16) l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].sfn_sfn_tm_diff;
        }
        else
        {
          WRRC_MSG1_ERROR("Incorrect SFN-SFN type2 value %d",
            l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].sfn_sfn_tm_diff);

          intra_freq_measured_results_list_ptr->elem[cell_number].dummy.u.type2 =
            SFN_SFN_TYPE2_MIN_VALUE;
         }
      }

    } /* End of else of L1_NO_REPORT */

    /* Check if cell sync info present */

    if (  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].cell_sync_info_incl == TRUE )
    {
      /* Set cell sync info present to rrc_cellSynchronisationInfo_present */
         intra_freq_measured_results_list_ptr->elem[cell_number].m.cellSynchronisationInfoPresent=1;

       /* Store t Mode info to fdd*/
       intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
         modeSpecificInfo.t = T_rrc_CellSynchronisationInfo_modeSpecificInfo_fdd;

       intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
         modeSpecificInfo.u.fdd = rtxMemAllocTypeZ(&enc_ctxt,rrc_CellSynchronisationInfo_fdd);

       if(intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
          modeSpecificInfo.u.fdd == NULL)
       {
         ERR_FATAL("Failed to allocate memory",0,0,0);
       }
       /* Check TM value */
       if ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].cell_sync_info.tm <= TM_MAX)
       {
         intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
           modeSpecificInfo.u.fdd->tm =
          (uint16) l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].cell_sync_info.tm;
       }
       else
       {
         WRRC_MSG1_ERROR("Tm value %d not in range",
           l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].cell_sync_info.tm);

         intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
           modeSpecificInfo.u.fdd->tm = TM_MIN;
       }

       /* Set bit mask indicating rrc_CountC_SFN_Frame_difference present */
       intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
         modeSpecificInfo.u.fdd->m.countC_SFN_Frame_differencePresent=1;

       /* Check OFF value */
       if ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].cell_sync_info.off <= OFF_MAX)
       {
         /* Set off value */
         intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.off =
          (uint8) l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].cell_sync_info.off;
       }
       else
       {
         WRRC_MSG1_ERROR("OFF value %d not in range",
           l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].cell_sync_info.off);
           l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].cell_sync_info.off = OFF_MIN;
       }

#ifdef FEATURE_WCDMA_CNT_C_SFN_DIFF
       if( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].cell_sync_info.count_c_sfn_diff_incl)
       {
         WRRC_MSG1_HIGH("CNT_C_SFN value from L1 : %d",
           l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].cell_sync_info.count_c_sfn_high);

         intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
           modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.countC_SFN_High = 
           l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].cell_sync_info.count_c_sfn_high;
       }
       else
       {
         intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
           modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.countC_SFN_High = 0;
       }
#else
       /* Set countC_SFN_High to 0 till the time RLC implements RLC transparent
        * Mode count-C */
       intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
         modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.countC_SFN_High = 0;
#endif

    } /* End of if of rrc_cellSynchronisationInfo_present */
    
    /* Set in the FDD mode for rrc_CellMeasuredResults_modeSpecificInfo */
    intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.t =
      T_rrc_CellMeasuredResults_modeSpecificInfo_fdd;

    intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd 
      = rtxMemAllocTypeZ(&enc_ctxt,rrc_CellMeasuredResults_fdd);

    if(intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd == NULL)
    {
      ERR_FATAL("Failed to allocate memory",0,0,0);
    }

    /* Set primary scrambling code */
    intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->
      primaryCPICH_Info.primaryScramblingCode =
      l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].pri_scr_code;
   
    MSG_LOW("Primary scrambling code is %d",  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].pri_scr_code,0,0);
   
    RRC_RESET_MSG_IE_PRESENT_PTR(intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd);


    /* Check if RSCP included */
    if ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].rscp_included == TRUE)
    {
      if ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].rscp_val <= RSCP_MAX_VALUE)
      {
        intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->cpich_RSCP =
          (uint8) l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].rscp_val;
    
        /* Set bit mask */
        intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.cpich_RSCPPresent =1;
        if((intra_freq_meas_res_ext_ptr != NULL) &&
           ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].delta_rscp_included == TRUE))
        {
          intra_freq_meas_res_ext_ptr->elem[cell_number].m.deltaRSCPPresent=1;
          intra_freq_meas_res_ext_ptr->elem[cell_number].deltaRSCP =
            (rrc_DeltaRSCP)  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].delta_rscp;
        }
      }
    }

    /* Check if EcNo included */
    if ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].ec_no_included == TRUE)
    {
      if ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].ec_no_val <= ECN0_MAX_VALUE)
      {
        intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->cpich_Ec_N0 =
          (uint8) l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].ec_no_val;
    
        /* Set bit mask */
        intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.
          cpich_Ec_N0Present=1;
      }
    
    }
   if (  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].pathloss_included == TRUE )
   {
   
     /* Check Value. If incorrect, then print ERROR message. Set value to 0 */
     if ( ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].pathloss_val >= PATH_LOSS_MIN_VALUE) &&
          ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].pathloss_val <= PATH_LOSS_MAX_VALUE) )
     {
       intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->pathloss =
         (uint8) l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_number].pathloss_val;
       /* Set bit mask */
       intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.pathlossPresent=1;
     }
   
   }
  }
}

#ifdef FEATURE_WCDMA_DC_HSUPA
/*===========================================================================

FUNCTION          RRCMEAS_APPEND_SECONDARY_MEAS_RESULTS

DESCRIPTION

 This function appends measured results for secondary frequency 
 when included by L1 in CPHY_MEASUREMENT_IND.
 
DEPENDENCIES

 None.

RETURN VALUE

 None.

SIDE EFFECTS

 None.

===========================================================================*/
void rrcmeas_append_secondary_meas_results
  (rrc_UL_DCCH_Message *msg_ptr,
   l1_meas_rpt_struct_type *l1_meas_report_ptr)
{
  /* Used as a counter to store cell number counted */
  uint16 cell_number = 0;
  rrc_IntraFrequencyMeasuredResultsListOnSecULFreq* intra_freq_meas_res_sec_freq_ptr = NULL;
  
  rrc_MeasurementReport *rrc_mr_ptr = NULL;
  rrc_MeasurementReport_v5b0NonCriticalExtensions *rrc_mr_v590_ptr = NULL;
  
  rrc_MeasuredResultsOnSecUlFreq *sec_meas_res_ptr = NULL;
  rrc_MeasurementReport_v860NonCriticalExtensions *rrc_mr_v860_ptr = NULL;
  
  
  rrc_mr_ptr = &msg_ptr->message.u.measurementReport;

  rrc_mr_ptr->m.v390nonCriticalExtensionsPresent =1;

  rrc_mr_ptr->v390nonCriticalExtensions.m.laterNonCriticalExtensionsPresent =1;

  rrc_mr_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.m.
    v4b0NonCriticalExtensionsPresent =1;

  rrc_mr_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.
     v4b0NonCriticalExtensions.m.v590NonCriticalExtensionsPresent =1;

  rrc_mr_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.
     v4b0NonCriticalExtensions.v590NonCriticalExtensions.m.v5b0NonCriticalExtensionsPresent = 1;

  rrc_mr_v590_ptr = &rrc_mr_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.v590NonCriticalExtensions.v5b0NonCriticalExtensions;

  rrc_mr_v590_ptr->m.v690NonCriticalExtensionsPresent = 1;

  rrc_mr_v590_ptr->v690NonCriticalExtensions.m.v770NonCriticalExtensionsPresent = 1;

  rrc_mr_v590_ptr->v690NonCriticalExtensions.v770NonCriticalExtensions.m.v860NonCriticalExtensionsPresent = 1;

  rrc_mr_v860_ptr = &rrc_mr_v590_ptr->v690NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions;

  rrc_mr_v860_ptr->m.v920NonCriticalExtensionsPresent = 1;

  rrc_mr_v860_ptr->v920NonCriticalExtensions.measurementReport_v920ext.m.measuredResultsOnSecUlFreqPresent = 1;

  sec_meas_res_ptr = &rrc_mr_v860_ptr->v920NonCriticalExtensions.measurementReport_v920ext.measuredResultsOnSecUlFreq;
  
  intra_freq_meas_res_sec_freq_ptr = &sec_meas_res_ptr->intraFreqMeasuredResultsList;
  
  MSG_LOW("No of cells sent by L1 is %d", l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].num_cells,0,0);
  
  if(l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].num_cells < L1_MAX_CELL_MEAS)
  {
    intra_freq_meas_res_sec_freq_ptr->n = l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].num_cells;
  }
  else
  {
    intra_freq_meas_res_sec_freq_ptr->n = L1_MAX_CELL_MEAS;
  }
        
  ALLOC_ASN1ARRAY2(&enc_ctxt,intra_freq_meas_res_sec_freq_ptr,
    rrc_CellMeasuredResults_r9);
  
  /* Read all the cell measured results in a for loop.
   * Also set the scrambling code list for event results in the loop*/
  for ( cell_number = 0; (cell_number < l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].num_cells) && ( cell_number < L1_MAX_CELL_MEAS );
    cell_number++ )
  {
    /* Check if cell sync info present */
    
    if ( l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].cell_sync_info_incl == TRUE )
    {
     /* Set cell sync info present to rrc_cellSynchronisationInfo_present */
     intra_freq_meas_res_sec_freq_ptr->elem[cell_number].m.cellSynchronisationInfoPresent=1;
    
     /* Store t Mode info to fdd*/
     intra_freq_meas_res_sec_freq_ptr->elem[cell_number].cellSynchronisationInfo.
       modeSpecificInfo.t =  T_rrc_CellSynchronisationInfo_modeSpecificInfo_fdd;
    
     intra_freq_meas_res_sec_freq_ptr->elem[cell_number].cellSynchronisationInfo.
       modeSpecificInfo.u.fdd = rtxMemAllocTypeZ(&enc_ctxt,rrc_CellSynchronisationInfo_fdd);
    
     if(intra_freq_meas_res_sec_freq_ptr->elem[cell_number].cellSynchronisationInfo.
       modeSpecificInfo.u.fdd == NULL)
     {
       ERR_FATAL("Failed to allocate memory",0,0,0);
     }
     /* Check TM value */
     if (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].cell_sync_info.tm <= TM_MAX)
     {
       intra_freq_meas_res_sec_freq_ptr->elem[cell_number].cellSynchronisationInfo.
         modeSpecificInfo.u.fdd->tm = 
           (uint16)l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].cell_sync_info.tm;
     }
     else
     {
       WRRC_MSG1_ERROR("Tm value %d not in range",
       l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].cell_sync_info.tm);
    
       intra_freq_meas_res_sec_freq_ptr->elem[cell_number].cellSynchronisationInfo.
         modeSpecificInfo.u.fdd->tm = TM_MIN;
     }
        
    /* Set bit mask indicating rrc_CountC_SFN_Frame_difference present */
    intra_freq_meas_res_sec_freq_ptr->elem[cell_number].cellSynchronisationInfo.
     modeSpecificInfo.u.fdd->m.countC_SFN_Frame_differencePresent=1;
    
    /* Check OFF value */
    if (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].cell_sync_info.off <= OFF_MAX)
    {
    /* Set off value */
     intra_freq_meas_res_sec_freq_ptr->elem[cell_number].cellSynchronisationInfo.
       modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.off =
       (uint8)l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].cell_sync_info.off;
    }
    else
    {
    WRRC_MSG1_ERROR("OFF value %d not in range",
    l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].cell_sync_info.off);
      l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].cell_sync_info.off = OFF_MIN;
    }
  
  #ifdef FEATURE_WCDMA_CNT_C_SFN_DIFF
      if(l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].cell_sync_info.count_c_sfn_diff_incl)
      {
        WRRC_MSG1_HIGH("CNT_C_SFN value from L1 : %d",
          l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].cell_sync_info.count_c_sfn_high);
          intra_freq_meas_res_sec_freq_ptr->elem[cell_number].cellSynchronisationInfo.
          modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.countC_SFN_High = 
          l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].cell_sync_info.count_c_sfn_high;
      }
      else
      {
        intra_freq_meas_res_sec_freq_ptr->elem[cell_number].cellSynchronisationInfo.
          modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.countC_SFN_High = 0;
      }
  #else
      /* Set countC_SFN_High to 0 till the time RLC implements RLC transparent
      * Mode count-C */
      intra_freq_meas_res_sec_freq_ptr->elem[cell_number].cellSynchronisationInfo.
        modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.countC_SFN_High = 0;
  #endif
    } /* End of if of rrc_cellSynchronisationInfo_present */
        
    /* Set in the FDD mode for rrc_CellMeasuredResults_modeSpecificInfo */
    intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.t =
      T_rrc_CellMeasuredResults_modeSpecificInfo_fdd;
  
    intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.u.fdd 
      = rtxMemAllocTypeZ(&enc_ctxt,rrc_CellMeasuredResults_r9_fdd);
  
   if(intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.u.fdd == NULL)
   {
     ERR_FATAL("Failed to allocate memory",0,0,0);
   }
            
   /* Set primary scrambling code */
   intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.u.fdd->
      primaryCPICH_Info.primaryScramblingCode =
      l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].pri_scr_code;
  
    MSG_LOW("Primary scrambling code is %d", l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].pri_scr_code,0,0);
  
   /* Check if RSCP included */
   if (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].rscp_included == TRUE)
   {
     if (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].rscp_val <= RSCP_MAX_VALUE)
     {
       intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.u.fdd->cpich_RSCP =
         (rrc_CPICH_RSCP)l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].rscp_val;
  
      /* Set bit mask */
      intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.cpich_RSCPPresent =1;
      if((intra_freq_meas_res_sec_freq_ptr != NULL) &&
         (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].delta_rscp_included == TRUE))
      {
        intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.deltaRSCPPerCellPresent=1;
        intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.u.fdd->deltaRSCPPerCell.m.deltaRSCPPresent = 1;
        intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.u.fdd->deltaRSCPPerCell.deltaRSCP = 
           (rrc_DeltaRSCP) l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].delta_rscp;
          }
        }
        
        }
        
        /* Check if EcNo included */
        if (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].ec_no_included == TRUE)
        {
        if (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].ec_no_val <= ECN0_MAX_VALUE)
        {
          intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.u.fdd->cpich_Ec_N0 =
            (rrc_CPICH_Ec_N0)l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].ec_no_val;
        
          /* Set bit mask */
          intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.
          cpich_Ec_N0Present=1;
        }
        
        }
        if ( l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].pathloss_included == TRUE )
        {
        
        /* Check Value. If incorrect, then print ERROR message. Set value to 0 */
        if ( (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].pathloss_val >= PATH_LOSS_MIN_VALUE) &&
          (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].pathloss_val <= PATH_LOSS_MAX_VALUE) )
        {
          /* Set bit mask */
          intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.pathlossPresent=1;
          intra_freq_meas_res_sec_freq_ptr->elem[cell_number].modeSpecificInfo.u.fdd->pathloss =
            (rrc_Pathloss)l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_number].pathloss_val;
        }
        
      }
        /* End of else */
        /* One cell completely filled here */
    } /* End of for loop */
  }
#endif

/*===========================================================================

FUNCTION     RRCMEAS_SEND_INTRA_FREQ_MEAS_REPORT_TO_UTRAN

DESCRIPTION

 Converts the intra-freq measurement report received
 From L1 into the measurement report structure format
 expected by UTRAN and sends measurement report to UTRAN

DEPENDENCIES

 None.

RETURN VALUE

 void

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_send_intra_freq_meas_report_to_utran
(
l1_meas_rpt_struct_type* l1_meas_report_ptr
)
{
  /* Stores meas report */
  rrc_UL_DCCH_Message* msg_ptr = NULL;

  /* Declared to store primary scrambling code list */
  rrc_CellMeasurementEventResults_fdd * scrambling_code_list_ptr = NULL;
#ifdef FEATURE_WCDMA_DC_HSUPA
  rrc_CellMeasurementEventResultsOnSecUlFreq_fdd *sec_freq_psc_ptr = NULL;
#endif

  /* Used as a counter to store primary scr code in event list */
  uint16 psc_number = 0;

  /* Stores status of send chain */
  rrcsend_status_e_type status;

  /* To delete meas */
  uint8  cell_count = 0;

  /* t is used as a parameter in fn rrcmeas_process_intra_periodic_freq_meas_results
  * to indicate t is either periodic intra-freq meas (t=1) or
  * intra-freq additional meas (t=2). */
  /* uint16 t; */

  /* RLC ack or unack mode */
  uecomdef_logch_mode_e_type logical_channel_mode;

  /* Logical Channel Id */
  rlc_lc_id_type ul_lc_id;

  /* Radio bearer mode */
  rrc_RB_Identity rb_mode;

  /* L2 ack status */
  rrcsend_l2ack_status_e_type l2_ack_status;

#ifdef FEATURE_WCDMA_DC_HSUPA
  rrc_EventResultsOnSecUlFreq *sec_event_res_ptr = NULL;

  rrc_MeasurementReport *rrc_mr_ptr = NULL;
  rrc_MeasurementReport_v5b0NonCriticalExtensions *rrc_mr_v590_ptr = NULL;

  rrc_MeasurementReport_v860NonCriticalExtensions *rrc_mr_v860_ptr = NULL;
  rrc_MeasurementReport_v920ext_IEs *rrc_mr_v920_ptr = NULL;
#endif

#ifdef FEATURE_QSH_EVENT_METRIC
  rrc_log_rrc_mrm_ota mrm_params;
  memset(&mrm_params,0,sizeof(rrc_log_rrc_mrm_ota));  

  mrm_params.meas_id = l1_meas_report_ptr->meas_id;
  mrm_params.meas_type = L1_INTRA_FREQ;
  mrm_params.meas_rpt_type = l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].rpt_crit;
  if(mrm_params.meas_rpt_type == L1_EVENT_TRIGGER_RPT)
  {
    mrm_params.event_id = l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].evt_id;
  }		
  mrm_params.num_cells_rpt = l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].num_cells_for_evt;
  rrc_qsh_log_meas_rpt_params(&mrm_params);
#endif

  /* No need to register for L2_ACK for intra-freq Meas Reports. Done only for Traffic Vol */

  if (rrcmeas_validate_intra_freq_report(l1_meas_report_ptr) ==  RRCMEAS_FAIL)
  {
    WRRC_MSG0_ERROR("Ignored Intra-Freq Meas Rpt");
    return;
  }

  if ( l1_meas_report_ptr->meas_transfer_mode == ACKNOWLEDGED_MODE )
  {
    logical_channel_mode = UE_MODE_ACKNOWLEDGED_DATA;
    rb_mode = DCCH_AM_RADIO_BEARER_ID;
    l2_ack_status = RRCSEND_L2ACK_REQUIRED;
  }
  else
  {
    logical_channel_mode = UE_MODE_UNACKNOWLEDGED;
    rb_mode = DCCH_UM_RADIO_BEARER_ID;
    l2_ack_status = RRCSEND_L2ACK_NOT_REQUIRED;
  }

  ul_lc_id = rrclcm_check_ul_rlc_lc_id ( UE_LOGCHAN_DCCH, rb_mode,
    logical_channel_mode);

  if ( ul_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND )
  {
    WRRC_MSG0_ERROR("RLC Logical channel not found");
    return;
  }

  /* Allocate a buffer for an uplink DCCH Message. This buffer
  * should be released by SEND_CHAIN using OSS compiler functions */

  msg_ptr = (rrc_UL_DCCH_Message *) rrc_malloc (sizeof(struct rrc_UL_DCCH_Message));

  /* Store meas report chosen */
  msg_ptr->message.t = T_rrc_UL_DCCH_MessageType_measurementReport;

  /* First store the meas id */
  rrcmeas_fill_meas_id(&msg_ptr->message.u.measurementReport,l1_meas_report_ptr->meas_id, INTRA_FREQ);

  /* Initialize Meas Report bit mask */
  RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.measurementReport);

  /* At this point check, if report sent from L1 is event triggered or periodic.*/

  if ((  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].rpt_crit == L1_NO_CHANGE ) 
#ifdef FEATURE_WCDMA_DC_HSUPA
      && (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].rpt_crit == L1_NO_CHANGE)
#endif
     )
  {
    rrc_free(msg_ptr );
    return;
  }
  else if (  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].rpt_crit == L1_PERIODIC_RPT )
  {
    if ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell_meas_result_incl == FALSE)
    {
      MSG_LOW("L1 sent no measured cells results",0,0,0);
    }
    else if ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].num_cells == 0)
    {
      MSG_LOW("L1 sent 0 cells",0,0,0);
    }
    else
    {
      /* Store bit mask to indicate measured results present */
      RRC_MSG_COMMON_SET_BITMASK_IE(msg_ptr->message.u.measurementReport,
      rrc_MeasurementReport,measuredResults);

      /* Set measured results present */
      RRC_SET_COMMON_MSG_TYPE(msg_ptr->message.u.measurementReport.measuredResults,
      rrc_MeasuredResults_intraFreqMeasuredResultsList);
      /* Append intra-freq periodic meas report */
      rrcmeas_append_intra_freq_periodic_meas_results(& l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ],
        &msg_ptr->message.u.measurementReport,
        &msg_ptr->message.u.measurementReport.measuredResults.u.intraFreqMeasuredResultsList, FALSE);

      /* Now check if this is the last report. Meas Id needs to be deleted if true */
    if(l1_meas_report_ptr->last_periodic_report == TRUE)
      {

        uint8 meas_id_idx = rrcmeas_find_meas_id_idx(l1_meas_report_ptr->meas_id);
        if(meas_id_idx < MAX_INTRA_FREQ_MEAS)
        {
#ifdef FEATURE_WCDMA_DC_HSUPA
          if(intra_freq_meas_id_list[meas_id_idx].rpt_crit[SEC_FREQ] == NOT_AVAILABLE)
#endif
          {

            WRRC_MSG0_HIGH("Last periodic rpt rcvd for Pri freq. Only Primary was configured. deleting meas"); 
            WRRC_MSG1_HIGH("Delete Meas and addtl meas for meas id : %d",l1_meas_report_ptr->meas_id);
            rrcmeas_delete_meas(&l1_meas_report_ptr->meas_id);
            rrcmeas_delete_addtl_meas(&l1_meas_report_ptr->meas_id);

          }
#ifdef FEATURE_WCDMA_DC_HSUPA
          else
          {
             WRRC_MSG0_HIGH("Last Periodic rpt for pri freq rcvd, Sec is also configured, rpt_crit for Pri changed to NA");
             intra_freq_meas_id_list[meas_id_idx].rpt_crit[PRI_FREQ] = NOT_AVAILABLE;
          }
#endif
        }
      }
    }
  }
  else /* It is event reporting */
  {
    /* Processing MEAS_IND from L1 for primary frequency */
    if(l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].rpt_crit == L1_NO_CHANGE)
    {
      MSG_LOW("L1: Event Report for primary freq not sent",0,0,0);    
    }
    else if(l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].rpt_crit == L1_EVENT_TRIGGER_RPT)/* It is event reporting */
    {
    /* Set bit mask that event results present */
    RRC_MSG_COMMON_SET_BITMASK_IE(msg_ptr->message.u.measurementReport,
    rrc_MeasurementReport,eventResults);

    /* Set intra-freq event results present */
    RRC_SET_COMMON_MSG_TYPE2(msg_ptr->message.u.measurementReport.eventResults,
      rrc_EventResults,intraFreqEventResults);

    msg_ptr->message.u.measurementReport.eventResults.u.intraFreqEventResults=
        rtxMemAllocTypeZ(&enc_ctxt,rrc_IntraFreqEventResults);

    /* Set rrc_CellMeasurementEventResults to fdd */
    RRC_SET_COMMON_MSG_TYPE(msg_ptr->message.u.measurementReport.eventResults.u.intraFreqEventResults->
    cellMeasurementEventResults,rrc_CellMeasurementEventResults_fdd);

    /* Store first event id */
      if ( rrcmeas_set_intra_freq_event_id( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].evt_id,
      &(msg_ptr->message.u.measurementReport.eventResults.u.intraFreqEventResults->eventID)) == FAILURE )
    {
      rrc_free(msg_ptr );
      return;
    }

    /* Now fill in the event results */
    /* Allocate memory for event result structure that contains only scrambling code */
    scrambling_code_list_ptr =
       rtxMemAllocTypeZ(&enc_ctxt,rrc_CellMeasurementEventResults_fdd);

    /* Update the event linked list head ptr that contains only scrambling code */
    msg_ptr->message.u.measurementReport.eventResults.u.intraFreqEventResults->
      cellMeasurementEventResults.u.fdd = scrambling_code_list_ptr;
      scrambling_code_list_ptr->n =   l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].num_cells_for_evt;
    ALLOC_ASN1ARRAY2(&enc_ctxt,scrambling_code_list_ptr,rrc_PrimaryCPICH_Info);

    /* Filling event results */
      for ( psc_number = 0; psc_number <  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].num_cells_for_evt;
    psc_number++ )
    {
      /* Set scrambling code in scrambling code event list */
      scrambling_code_list_ptr->elem[psc_number].primaryScramblingCode =
           l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell_psc[psc_number];
    } /* End of for psc_number. Event list filled */

      if ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell_meas_result_incl == TRUE)
    {
         l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell_meas_result_incl = FALSE;
        for(cell_count = 0; cell_count <  l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].num_cells; cell_count++)
      {
          if(( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_count].ec_no_included == TRUE)
            || ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_count].rscp_included == TRUE)
            || ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_count].pathloss_included == TRUE)
            || ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_count].cell_sync_info_incl == TRUE)
            || ( l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell[cell_count].sfn_rpt_ind != L1_NO_REPORT))
        {
             l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell_meas_result_incl = TRUE;
          break;
        }
      }
    }
        
      if (l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell_meas_result_incl == FALSE)
      {
        MSG_LOW("Report has no primary cell measured results",0,0,0);
      }
      else /* Append Measured Cell Results */
        {
        rrcmeas_append_primary_meas_results(msg_ptr, l1_meas_report_ptr);
      }

#ifdef FEATURE_WCDMA_DC_HSUPA
      if (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell_meas_result_incl == FALSE)
      {
        MSG_LOW("Report has no secondary cell measured results",0,0,0);
      }
      else /* Append Measured Cell Results */
        {
        rrcmeas_append_secondary_meas_results(msg_ptr, l1_meas_report_ptr);
        }
#endif
        }
    }

#ifdef FEATURE_WCDMA_DC_HSUPA
      /* Processing MEAS_IND from L1 for secondary frequency */
      if(l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].rpt_crit == L1_NO_CHANGE)
      {
        MSG_LOW("L1: Event Report for Secondary freq not sent",0,0,0);    
      }
      else if(l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].rpt_crit == L1_EVENT_TRIGGER_RPT)/* It is event reporting */
      {
        rrc_mr_ptr = &msg_ptr->message.u.measurementReport;

        rrc_mr_ptr->m.v390nonCriticalExtensionsPresent =1;

        rrc_mr_ptr->v390nonCriticalExtensions.m.laterNonCriticalExtensionsPresent =1;

        rrc_mr_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.m.
          v4b0NonCriticalExtensionsPresent =1;

        rrc_mr_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.
          v4b0NonCriticalExtensions.m.v590NonCriticalExtensionsPresent =1;

        rrc_mr_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.
          v4b0NonCriticalExtensions.v590NonCriticalExtensions.m.v5b0NonCriticalExtensionsPresent = 1;

        rrc_mr_v590_ptr = &rrc_mr_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.v590NonCriticalExtensions.v5b0NonCriticalExtensions;

        rrc_mr_v590_ptr->m.v690NonCriticalExtensionsPresent = 1;

        rrc_mr_v590_ptr->v690NonCriticalExtensions.m.v770NonCriticalExtensionsPresent = 1;

        rrc_mr_v590_ptr->v690NonCriticalExtensions.v770NonCriticalExtensions.m.v860NonCriticalExtensionsPresent = 1;

        rrc_mr_v860_ptr = &rrc_mr_v590_ptr->v690NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions;

        rrc_mr_v860_ptr->m.v920NonCriticalExtensionsPresent = 1;

         rrc_mr_v860_ptr->v920NonCriticalExtensions.measurementReport_v920ext.
           m.eventResultsOnSecUlFreqPresent = 1;

         sec_event_res_ptr = &rrc_mr_v860_ptr->v920NonCriticalExtensions.measurementReport_v920ext.eventResultsOnSecUlFreq;

        /* Store first event id */
        //TBD : Validity check for Event report from L1             
        if ( rrcmeas_set_intra_freq_event_id(l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].evt_id,
            &(sec_event_res_ptr->intraFreqEventResults.eventID)) == FAILURE )
        {
          rrc_free(msg_ptr );
          return;
        }

        if((l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].evt_id == rrc_EventIDIntraFreq_e1d) ||
           (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].evt_id == rrc_EventIDIntraFreq_e1j))
        {
          WRRC_MSG1_ERROR("Invalid event reported for secondary frequency %d",
                 l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].evt_id);
          rrc_free(msg_ptr );
          return;
        }
        else
        {
          /* Now fill in the event results */

          /* Allocate memory for event result structure that contains only scrambling code */
          sec_freq_psc_ptr =
            rtxMemAllocTypeZ(&enc_ctxt,rrc_CellMeasurementEventResultsOnSecUlFreq_fdd);

            sec_event_res_ptr->intraFreqEventResults.cellMeasurementEventResultsOnSecUlFreq.t = T_rrc_CellMeasurementEventResultsOnSecUlFreq_fdd;

          /* Update the event linked list head ptr that contains only scrambling code */
          sec_event_res_ptr->intraFreqEventResults.cellMeasurementEventResultsOnSecUlFreq.
            u.fdd = sec_freq_psc_ptr;

          sec_freq_psc_ptr->n =  l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].num_cells_for_evt;

          ALLOC_ASN1ARRAY2(&enc_ctxt,sec_freq_psc_ptr,rrc_PrimaryCPICH_Info);

          /* Filling event results */
          for ( psc_number = 0; psc_number < l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].num_cells_for_evt;
            psc_number++ )
          {
            /* Set scrambling code in scrambling code event list */
            sec_freq_psc_ptr->elem[psc_number].primaryScramblingCode =
             l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell_psc[psc_number];

          } /* End of for psc_number. Event list filled */

          if (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell_meas_result_incl == TRUE)
        {
            l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell_meas_result_incl = FALSE;
            for(cell_count = 0; cell_count < l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].num_cells; cell_count++)
          {
              if((l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_count].ec_no_included == TRUE)
                 || (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_count].rscp_included == TRUE)
                 || (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_count].pathloss_included == TRUE)
                 || (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_count].cell_sync_info_incl == TRUE)
                 || (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell[cell_count].sfn_rpt_ind != L1_NO_REPORT))
            {
                l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell_meas_result_incl = TRUE;
                break;
            }
          }
        }

        if (l1_meas_report_ptr->u.intra_f_rpt[PRI_FREQ].cell_meas_result_incl == FALSE)
        {
          MSG_LOW("Report has no primary cell measured results",0,0,0);
        }
        else /* Append Measured Cell Results */
        {
          rrcmeas_append_primary_meas_results(msg_ptr, l1_meas_report_ptr);
        }

        if (l1_meas_report_ptr->u.intra_f_rpt[SEC_FREQ].cell_meas_result_incl == FALSE)
        {
          MSG_LOW("Report has no secondary cell measured results",0,0,0);
        }
        else /* Append Measured Cell Results */
        {
          rrcmeas_append_secondary_meas_results(msg_ptr, l1_meas_report_ptr);
        }
        /* End of else */
      } /* End of else of EVENT REPORTING */
   }
#ifdef FEATURE_WCDMA_REL10
   #error code not present
#endif
#endif



  /* Append Additional Measured Results if available */

  /* Addtl Meas List must be initialized */
  msg_ptr->message.u.measurementReport.additionalMeasuredResults.n = 0;

  /* Check if additional measurements can be sent only when corresponding meas is reported */
  rrcmeas_process_additional_measured_results(
    &l1_meas_report_ptr->meas_id, INTRA_FREQ, &msg_ptr->message.u.measurementReport);

/* Not enabled since L1 doesn't support periodic meas now 
  rrcmeas_process_additional_measured_results_sec_freq(
   &l1_meas_report_ptr->meas_id, INTRA_FREQ, &msg_ptr->message.u.measurementReport);
*/

  /* This places SDU into RLC watermark queue */
  status =  rrcsend_send_ul_sdu(RRC_PROCEDURE_MCMR, (void *) msg_ptr,
    ul_lc_id, l2_ack_status);

  if ( status != RRCSEND_SUCCESS )
  {
    WRRC_MSG0_ERROR("Send chain failed to send Measurement Report");
  }
  else
  {
    if(l1_meas_report_ptr->meas_transfer_mode == ACKNOWLEDGED_MODE)
    {
      rrcmeas_pending_rpt++;
      if(rrcmeas_pending_rpt >= 5)
      {
        WRRC_MSG1_HIGH("pending meas rpt = %d",rrcmeas_pending_rpt);
      }
    }
  }

  return;

}  /* End of function */



/*===========================================================================

FUNCTION RRCMEAS_APPEND_MEAS_RPT_ON_RACH

DESCRIPTION

 Appends the measured results to RACH messages if
 requested by the UTRAN. First, it checks if the
 meas report can be appended to the measge. If true,
 then it invokes a l1_process_immediate_meas_req to get
 intra-freq meas reports from L1.

DEPENDENCIES

 RACH reporting must have been activated by UTRAN in sib11 or sib12

RETURN VALUE

 RRCMEAS_RACH_FAILURE if RACH report not appended
 RRCMEAS_RACH_SUCCESSFUL if RACH report appended


SIDE EFFECTS

 None

===========================================================================*/

rrcmeas_rpt_stat_e_type rrcmeas_append_meas_rpt_on_rach
(
rrc_MeasuredResultsOnRACH* rrcmeas_rach_report_ptr,  /* Pointer to rrc_MeasuredResultsOnRACH */
rrc_proc_e_type proc_id,
boolean exclude_monitored_cell_results
)
{
  /* Stores RACH meas report from L1 */
  l1_immediate_meas_type l1_rach_report;

  l1_meas_quan_enum_type rach_rpt_crit;
  /* Stores Monitored/Neighbour cells */
  rrc_MonitoredCellRACH_List* rrcmeas_monitored_cells_ptr = NULL;

  /* Used as counters to store monitored cell number counted */
  uint16 monitored_cell_number = 0;

  rach_report_crit_e_type rach_rpt = rrcmeas_check_for_rach_reporting();

  uecomdef_status_e_type rach_rpt_qty = rrcmeas_get_rach_rpt_quantity(&rach_rpt_crit);

  /* Check if NULL pointer passed */
  if ( rrcmeas_rach_report_ptr == NULL )
  {
    return RRCMEAS_RACH_FAILURE;
  }
  
  /* Set bit mask to monitored cells present  */
  RRC_RESET_MSG_IE_PRESENT_PTR(rrcmeas_rach_report_ptr);

  MSG_HIGH("RACH rpt requested by procedure id %d, rach_rpt %d, rach_rpt_qty %d", (uint32)proc_id,rach_rpt,rach_rpt_qty);

  if (!l1m_state_is_fach())
  {
    return RRCMEAS_RACH_FAILURE;
  }

  /* Check criteria for RACH report */
  if ( rach_rpt ==  NO_RRC_MEAS_RACH_REPORT )
  {
    return RRCMEAS_RACH_FAILURE;
  }

  /* Get RACH Meas Rpt Criteria */
  if (rach_rpt_qty == FAILURE)
  {
    return RRCMEAS_RACH_FAILURE;
  }
  
#ifndef FEATURE_WCDMA_FREE_FLOATING_TASK
  WCDMA_RRC_TASK_LOCK();
  /* Call L1 fn to get ARCH meas report */
  l1_process_immediate_meas_req(&l1_rach_report, rach_rpt_crit);
  WCDMA_RRC_TASK_FREE();
#else
  rrcff_l1_process_immediate_meas_req(&l1_rach_report, rach_rpt_crit);
#endif

  /* Convert RACH report to ASN format */
  if ( rach_rpt_crit == L1_MEAS_NONE)
  {
    WRRC_MSG0_HIGH("RACH Report not available");
    return(RRCMEAS_RACH_FAILURE);
  }

  /* Set the mode to FDD for current cell*/
  rrcmeas_rach_report_ptr->currentCell.modeSpecificInfo.t =
  T_rrc_MeasuredResultsOnRACH_modeSpecificInfo_fdd;

  rrcmeas_rach_report_ptr->currentCell.modeSpecificInfo.u.fdd = 
    rtxMemAllocTypeZ(&enc_ctxt,rrc_MeasuredResultsOnRACH_fdd);

  /* Set Meas Quan type */
  if (rach_rpt_crit == L1_EC_NO)
  {
    RRC_SET_COMMON_MSG_TYPE2(rrcmeas_rach_report_ptr->currentCell.modeSpecificInfo.u.fdd->measurementQuantity,
      rrc_MeasuredResultsOnRACH,measurementQuantity_cpich_Ec_N0);

    if (l1_rach_report.aset_meas_val <= ECN0_MAX_VALUE)
    {
      rrcmeas_rach_report_ptr->currentCell.modeSpecificInfo.u.fdd->
        measurementQuantity.u.cpich_Ec_N0 = (uint8)l1_rach_report.aset_meas_val;
    }
    else
    {
      WRRC_MSG1_ERROR("Incorrect ECN0 value %d received",l1_rach_report.aset_meas_val);
      /* Set the meas value */
      rrcmeas_rach_report_ptr->currentCell.modeSpecificInfo.u.fdd->
        measurementQuantity.u.cpich_Ec_N0 = ECN0_MIN_VALUE;
    }
  }
  else if (rach_rpt_crit == L1_RSCP)
  {
    RRC_SET_COMMON_MSG_TYPE2(rrcmeas_rach_report_ptr->currentCell.modeSpecificInfo.u.fdd->
      measurementQuantity,rrc_MeasuredResultsOnRACH,measurementQuantity_cpich_RSCP);

    if (l1_rach_report.aset_meas_val <= RSCP_MAX_VALUE)
    {
      rrcmeas_rach_report_ptr->currentCell.modeSpecificInfo.u.fdd->
        measurementQuantity.u.cpich_RSCP = (uint8)l1_rach_report.aset_meas_val;

    }
    else
    {
      WRRC_MSG1_ERROR("Incorrect RSCP value %d received",l1_rach_report.aset_meas_val);

      /* Set the meas value */
      rrcmeas_rach_report_ptr->currentCell.modeSpecificInfo.u.fdd->
        measurementQuantity.u.cpich_RSCP = RSCP_MIN_VALUE;
    }
  }
  else /* Path Loss selected */
  {
    rrcmeas_rach_report_ptr->currentCell.modeSpecificInfo.u.fdd->
      measurementQuantity.t = T_rrc_MeasuredResultsOnRACH_measurementQuantity_pathloss;

    if ( (l1_rach_report.aset_meas_val >= PATH_LOSS_MIN_VALUE) &&
      (l1_rach_report.aset_meas_val <= PATH_LOSS_MAX_VALUE) )
    {
      rrcmeas_rach_report_ptr->currentCell.modeSpecificInfo.u.fdd->
        measurementQuantity.u.pathloss = (uint8)l1_rach_report.aset_meas_val;

    }
    else
    {
      WRRC_MSG1_ERROR("Incorrect Path Loss value %d received",l1_rach_report.aset_meas_val);

      /* Set the meas value */
      rrcmeas_rach_report_ptr->currentCell.modeSpecificInfo.u.fdd->
        measurementQuantity.u.pathloss = PATH_LOSS_MIN_VALUE;
    }
  } /* End of else of Path Loss */


  WRRC_MSG2_HIGH("Append serving cell res on RACH : num_ncells %d, exclude_monitored_rsts %d",l1_rach_report.num_ncells,exclude_monitored_cell_results);

  /* Check if no of monitored cells is equal to 0 */
  if (l1_rach_report.num_ncells == 0)
  {
    MSG_LOW("Append serving cell res on RACH",0,0,0);
    return (RRCMEAS_RACH_SUCCESSFUL);
  }
  /* Set parameter of monitored cells */

  if(exclude_monitored_cell_results == TRUE)
  {
    MSG_LOW("Append serving cell res on RACH. Excluding monitored cell res at the behest of calling procedure",0,0,0);
    return (RRCMEAS_RACH_SUCCESSFUL);
  }
  /* Set bit mask to monitored cells present  */
  RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2_PTR(rrcmeas_rach_report_ptr,monitoredCells);

  if((proc_id == RRC_PROCEDURE_CU) || (proc_id == RRC_PROCEDURE_RCE))
  {
    MSG_LOW("CCCH trx: Append utmost 1 monitored cell",0,0,0);
    l1_rach_report.num_ncells = 1;
  }
  /* Assign memory for monitored cells */
  /* But the first cell has to be current active cell */
  
  /* Assign head */
  rrcmeas_monitored_cells_ptr = &rrcmeas_rach_report_ptr->monitoredCells;
  rrcmeas_monitored_cells_ptr->n = l1_rach_report.num_ncells;
  ALLOC_ASN1ARRAY2(&enc_ctxt,rrcmeas_monitored_cells_ptr,rrc_MonitoredCellRACH_Result);
  for ( monitored_cell_number = 0; (monitored_cell_number < l1_rach_report.num_ncells)
    && (monitored_cell_number < MAX_NO_MONITORED_CELLS);
  monitored_cell_number++ )
  {
    /* The first monitored cell in the list is the active cell. skip it*/

    /* Check if this is the last element */

    

    /* Fill the values now */
    /* Set sfn_sfn observed time difference */
    if ( l1_rach_report.n_cells[monitored_cell_number].sfn_rpt == L1_NO_REPORT )
    {
      RRC_RESET_MSG_IE_PRESENT(rrcmeas_monitored_cells_ptr->elem[monitored_cell_number]);
    }
    else
    {
      /* Set sfn_SFN_ObsTimeDifference bit mask */
      rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].m.sfn_SFN_ObsTimeDifferencePresent =1;

      /* Set sfn_SFN_ObsTimeDifference to TYPE */
      rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].sfn_SFN_ObsTimeDifference.t =
        RRCMEAS_RET_INTRA_FREQ_SFN_SFN(l1_rach_report.n_cells[monitored_cell_number].sfn_rpt);

      /* Set the sfn-sfn observed diff value */
      if ( rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].sfn_SFN_ObsTimeDifference.t ==
        T_rrc_SFN_SFN_ObsTimeDifference_type1 )
      {
        if (l1_rach_report.n_cells[monitored_cell_number].sfn_sfn_diff <=
          SFN_SFN_TYPE1_MAX_VALUE)
        {
          rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].sfn_SFN_ObsTimeDifference.u.type1 =
            l1_rach_report.n_cells[monitored_cell_number].sfn_sfn_diff;
        }
        else
        {
          WRRC_MSG1_ERROR("Incorrect SFN-SFN Type1 value %d",
            l1_rach_report.n_cells[monitored_cell_number].sfn_sfn_diff);

          rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].sfn_SFN_ObsTimeDifference.u.type1 =
            SFN_SFN_TYPE1_MIN_VALUE;
        }
      }
      else
      {
        if (l1_rach_report.n_cells[monitored_cell_number].sfn_sfn_diff <=
          SFN_SFN_TYPE2_MAX_VALUE)
        {
          rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].sfn_SFN_ObsTimeDifference.u.type2 =
            (rrc_SFN_SFN_ObsTimeDifference2)l1_rach_report.n_cells[monitored_cell_number].sfn_sfn_diff;
        }
        else
        {
          WRRC_MSG1_ERROR("Incorrect SFN-SFN Type2 value %d",
            l1_rach_report.n_cells[monitored_cell_number].sfn_sfn_diff);

          rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].sfn_SFN_ObsTimeDifference.u.type2 =
            SFN_SFN_TYPE2_MIN_VALUE;
        }
      }

    }  /* End of else of l1_rach_report.n_cells[monitored_cell_number].sfn_rpt */

    /* Set fdd mode chosen for RACH monitored cell */
    rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.t =
      T_rrc_MonitoredCellRACH_Result_modeSpecificInfo_fdd;

    rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.u.fdd =
       rtxMemAllocTypeZ(&enc_ctxt,rrc_MonitoredCellRACH_Result_fdd);

    /* Set monitored scrambling code */
    rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.
      u.fdd->primaryCPICH_Info.primaryScramblingCode =
      l1_rach_report.n_cells[monitored_cell_number].scr_code;

    /* Initialize bit mask for meas quantity to 0 */

    if (rach_rpt_crit == L1_MEAS_NONE)
    {
      RRC_RESET_MSG_IE_PRESENT_PTR(rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.
        u.fdd);
    }
    else
    {
      /* Set bit mask to meas quantity present */
      rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.
        u.fdd->m.measurementQuantityPresent =1;

      /* Set Meas Quan type i.e EcN0/RSCP */
      if (rach_rpt_crit == L1_EC_NO)
      {
        /* Set meas quantity value */
        rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.
          u.fdd->measurementQuantity.t = T_rrc_MonitoredCellRACH_Result_measurementQuantity_cpich_Ec_N0;

        if (l1_rach_report.n_cells[monitored_cell_number].meas_val <= ECN0_MAX_VALUE)
        {
          /* Set the meas value */
          rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.u.fdd->
            measurementQuantity.u.cpich_Ec_N0 =
            (rrc_CPICH_Ec_N0)l1_rach_report.n_cells[monitored_cell_number].meas_val;
        }
        else
        {
          WRRC_MSG1_ERROR("Incorrect EcN0 value %d received ",rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.u.fdd->
            measurementQuantity.u.cpich_Ec_N0);

          /* Set the meas value */
          rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.u.fdd->
            measurementQuantity.u.cpich_Ec_N0 = ECN0_MIN_VALUE;
        }
      } /* End of if of L1_EC_N0 */

      else if (rach_rpt_crit == L1_RSCP) /* RSCP */
      {
        rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.
          u.fdd->measurementQuantity.t =
          T_rrc_MonitoredCellRACH_Result_measurementQuantity_cpich_RSCP;

        if (l1_rach_report.n_cells[monitored_cell_number].meas_val <= RSCP_MAX_VALUE)
        {
          /* Set the meas value */
          rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.u.fdd->
            measurementQuantity.u.cpich_RSCP =
            (rrc_CPICH_RSCP)l1_rach_report.n_cells[monitored_cell_number].meas_val;

        }
        else
        {
          WRRC_MSG1_ERROR("Incorrect RSCP value %d received",
            l1_rach_report.n_cells[monitored_cell_number].meas_val);

          /* Set the meas value */
          rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.u.fdd->
            measurementQuantity.u.cpich_RSCP = RSCP_MIN_VALUE;
        }
      }  /* End of else if RSCP */
      else /* Path Loss selected */
      {
        rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.
          u.fdd->measurementQuantity.t = T_rrc_MonitoredCellRACH_Result_measurementQuantity_pathloss;

        if ( (l1_rach_report.n_cells[monitored_cell_number].meas_val >= PATH_LOSS_MIN_VALUE) &&
          (l1_rach_report.n_cells[monitored_cell_number].meas_val <= PATH_LOSS_MAX_VALUE) )
        {
          /* Set the meas value */
          rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.u.fdd->
            measurementQuantity.u.pathloss =
            (rrc_Pathloss)l1_rach_report.n_cells[monitored_cell_number].meas_val;

        }
        else
        {
          WRRC_MSG1_ERROR("Incorrect path loss value %d received",
            l1_rach_report.n_cells[monitored_cell_number].meas_val);

          /* Set the meas value */
          rrcmeas_monitored_cells_ptr->elem[monitored_cell_number].modeSpecificInfo.u.fdd->
            measurementQuantity.u.pathloss = PATH_LOSS_MIN_VALUE;
        }
      }
    } /* End of else of measured quantity present */
  } /* End of for loop */
  return( RRCMEAS_RACH_SUCCESSFUL );
}

/*===========================================================================

FUNCTION  RRCMEAS_PROCESS_CELL_SELECTED_MEAS_REQ_FOR_IDLE_STATE

DESCRIPTION

 Processes new cell req from CSP in RRCMEAS Idle state.
 Reads new SIB parameters and sends measurement
 request to L1 based on SIB's.

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_process_cell_selected_meas_req_for_idle_state
(
void
)
{

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
  uint8  l1_deferred_meas_from_sib_action = 0;
#endif

  l1_meas_ctrl_enum_type meas_choice;

  boolean meas_req_incl = FALSE;

  /* Clean SIB11 */
  rrcmeas_clear_sib11();

  /* Reinitialize cell list */
  rrcmeas_initialize_cell_list();

  rrcirat_initialize_cell_list();


  /* Initialize Inter Freq Cell List */
  rrcifreq_initialize_cell_list();

  /* Read SIB11 for Intra-Freq Meas */
#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
  if(rrcsib_is_sib11_11bis_12_read_deferred(DEFERRED_SIB11))
  {
    sib12_present = SIB12_ABSENT;
    rrcifreq_initialize_cell_list();
    rrcmeas_initialize_meas_id_list();

    l1_deferred_meas_from_sib_action = CLEAR_CELL_INFO_LIST;
    l1_deferred_meas_from_sib_action |= CLEAR_MEAS_IDENTITY;
    rrcmeas_send_deferred_meas_req(l1_deferred_meas_from_sib_action);
    return;
  }
  else
#endif
  
  if ( rrcmeas_read_sib11() == FAILURE )
  {
    WRRC_MSG0_ERROR("Intra-Freq Meas not done");
    /* Clean SIB11 */
    rrcmeas_clear_sib11();

    rrcmeas_initialize_meas_id_list();

    rrcmeas_initialize_cell_list();

    sib12_present = SIB12_ABSENT;

  }
  else
  {
    meas_req_incl = TRUE;
  }

  /* Even if SIB11 for intra-freq meas is not good, we would read SIB11 for inter-RAT */
  if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
  {
    WRRC_MSG0_ERROR("Inter-RAT SIB11 ignored");
    rrcirat_initialize_cell_list();
  }
  else
  {
    meas_req_incl = TRUE;
  }

  if (meas_req_incl == TRUE)
  {
    WRRC_MSG0_HIGH("Sending SIB 11 Meas Req to L1");
    rrcmeas_send_l1_cmd(rrcmeas_sib11, NULL, NULL, L1_SIB_PARMS);
  }

  if (rrcifreq_read_sib11(rrcmeas_inter_freq_sib11) == FAILURE)
  {
    WRRC_MSG0_HIGH("IFreq:Cell List ignored");
    rrcifreq_initialize_cell_list();
  }
  else
  {
    meas_choice = L1_INTER_FREQ_SIB_PARMS;
    rrcifreq_send_l1_cmd(&meas_choice, rrcmeas_inter_freq_sib11);
    WRRC_MSG0_MED("IFreq:Cell List sent");
  }

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
  rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif
}



/*===========================================================================

FUNCTION    PROCESS_STATE_CHANGE_IND_IN_IDLE_STATE

DESCRIPTION

 Processes state change indication received in idle mode.

DEPENDENCIES

 None.

RETURN VALUE

 void

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_process_state_change_ind_in_idle_state
(
rrc_cmd_type* cmd_ptr
)
{
  sys_hs_ind_e_type new_hs_ind = SYS_HS_IND_NONE;

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
  uint8  l1_deferred_meas_from_sib_action = 0;
#endif

  rrc_SysInfoType11 *sib11_ptr = NULL; /* Declared to store the value of SIB 12*/

  rrc_SysInfoType12 *sib12_ptr = NULL;

  rrc_SysInfoType18 *sib18_ptr = NULL;

  l1_inter_freq_cell_list_struct_type *inter_freq_parms = NULL;

  boolean meas_req_incl = FALSE;

  rrc_scr_code_type psc;

  l1_meas_ctrl_enum_type meas_choice;

#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
  rrc_csp_acq_entry_type ccm_cell_info = rrc_ccm_get_curr_cell_info();
  /*Ignore the state change indication to connecting if we are not in csfb call and CSFB call OPT is not present*/
  if(cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CONNECTING)
  {
    if(!(WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT) && (rrc_csfb_call_status)))
    {
       return;
    }
  }
#endif

  inter_freq_parms = rrc_malloc(sizeof(l1_inter_freq_cell_list_struct_type));

  /* Trash SIB11 values */
  rrcmeas_clear_sib11();

  rrcmeas_initialize_meas_id_list();

  rrcmeas_initialize_cell_list();
      rrcirat_initialize_cell_list();

      rrcirat_initialize_meas_id_list();

      rrcifreq_initialize_meas_id_list();

      rrcifreq_initialize_cell_list();

  switch ( cmd_ptr->cmd.state_change_ind.new_state )
  {
#ifdef FEATURE_WCDMA_CSFB_CALL_OPT
    /* With this opt, since WL1 will move to PCH, meas request will not be sent 
       during cell camping. We need WL1 to perform measurements when in connecting 
       state so that cell reselections can be allowed  */
    case RRC_STATE_CONNECTING:
        WRRC_MSG0_HIGH("IDLE->Connecting state");
        if(WCDMA_RRC_IDLE_FEATURES(RRC_CSFB_CALL_TIMELINE_OPT) && (rrc_csfb_call_status))
        {
          rrc_csp_send_l1_cmd(RRC_PROCEDURE_CCM, CPHY_CELL_PARM_REQ, &ccm_cell_info);
          rrcmeas_process_cell_selected_meas_req_for_idle_state();
        }
        break;
#endif

    /* For both of these states, RRCMEAS procedure is in IDLE state */
    case RRC_STATE_CELL_DCH:

      WRRC_MSG0_HIGH("IDLE->DCH state");

      rrcmeas_current_substate = RRCMEAS_CELL_DCH;

      /* Get HS Capability Indication */
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
      {
        if (hsdpa_hsupa_ind != SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL)
        {
          hsdpa_hsupa_ind = new_hs_ind;
          WRRC_MSG1_HIGH("RRCHS:new_hs_ind =%d", new_hs_ind);
        }
      }

      /* Find out what was the last cell RRC camped on in Idle mode and what is the new
         cell in CELL_DCH */

      if (rrcmeas_check_if_scr_present_in_aset() == TRUE)
      {
          MSG_LOW("SCR found in ASET",0,0,0);
      }
      else
      {
          /* Configure which meas need not be reported till MCM received */
          rrcmeas_update_meas_after_state_trans();
      }

      sib18_ptr = (rrc_SysInfoType18*)  rrc_sibdb_return_sib_for_srv_cell
        (rrc_SIB18);

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
      if(rrcsib_is_sib11_11bis_12_read_deferred(DEFERRED_SIB11))
      {
        l1_deferred_meas_from_sib_action = CLEAR_CELL_INFO_LIST;
        l1_deferred_meas_from_sib_action |= CLEAR_MEAS_IDENTITY;
        rrcmeas_send_deferred_meas_req(l1_deferred_meas_from_sib_action);
        rrc_free(inter_freq_parms);
        return;
      }
#endif

       sib11_ptr = (rrc_SysInfoType11*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11);
      /* Check if SIB12 present */
      if ( sib12_present == SIB12_ABSENT )
      {
        /* Read from SIB11 */
        /* Get traffic volume params from SIB12 */
        if(sib11_ptr == NULL)
        {
          WRRC_MSG0_ERROR("SIB 11 empty.");
          rrc_free(inter_freq_parms);
          return;
        }

        /* Read traffic volume info from SIB12 and send meas req to MAC */
        if (rrctvm_process_sib_info(&sib11_ptr->measurementControlSysInfo)
          == TVM_SUCCESS)
        {
          rrctvm_send_mac_cmd(&mac_sib_params);
        }
        else
        {
          MSG_LOW("Tra Vol sys info invalid",0,0,0);

          rrctvm_initialize();

          rrctvm_initialize_measurement_identity();
        }
      }
      else
      {
        /* Get traffic volume params from SIB12 */
        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) ==  NULL)
        {
          WRRC_MSG0_ERROR("SIB 12 empty");
          rrc_free(inter_freq_parms);
          return;
        }

        if(RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib12_ptr->measurementControlSysInfo,
            trafficVolumeMeasSysInfo))
        {
          /* Read traffic volume info from SIB12 and send meas req to MAC */
          if (rrctvm_process_sib_info(&sib12_ptr->measurementControlSysInfo)
            == TVM_SUCCESS )
          {
            rrctvm_send_mac_cmd(&mac_sib_params);
          }
          else
          {
            MSG_LOW("Tra Vol sys info invalid",0,0,0);

            rrctvm_initialize();

            rrctvm_initialize_measurement_identity();

          }
        }
        else
        {
           if (rrctvm_process_sib_info(&sib11_ptr->measurementControlSysInfo)
             == TVM_SUCCESS)
           {
             rrctvm_send_mac_cmd(&mac_sib_params);
           }
           else
           {
             MSG_LOW("Tra Vol sys info invalid",0,0,0);

             rrctvm_initialize();

             rrctvm_initialize_measurement_identity();
           }
        }
      }

    /* save the meas id variable in a tmp location */
    WCDMA_MEMCPY(tmp_intra_freq_meas_id_list, 
                 MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                 intra_freq_meas_id_list, 
                 MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));


    if ( rrcmeas_read_sib11() == FAILURE )
    {
      WRRC_MSG0_HIGH("Intra-Freq SIB 11 ignored");
      rrcmeas_clear_sib11();

      rrcmeas_initialize_meas_id_list();

      rrcmeas_initialize_cell_list();

    }
    else
    {
      meas_req_incl = TRUE;
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        MSG_LOW("SIB12 present, processing SIB12",0,0,0);

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          MSG_LOW("Undo changes to Meas id varible from SIB11",0,0,0);
          WCDMA_MEMCPY(intra_freq_meas_id_list, 
                       MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                       tmp_intra_freq_meas_id_list, 
                       MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

          /* Everything is O.K. Read SIB12 */
          rrcmeas_read_sib12(sib12_ptr, rrcmeas_sib12);
        }
      } /* Else of SIB12 present */
    }

    /* Read Inter-RAT SIB11 */
    if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
    {
      WRRC_MSG0_HIGH("Inter-RAT SIB11 ignored");
      rrcirat_initialize_cell_list();
    }
    else
    {
      meas_req_incl = TRUE;
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        MSG_LOW("SIB12 present, processing SIB12",0,0,0);

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          /* Everything is O.K. Read SIB12 */
          if (rrcirat_read_sib12(sib12_ptr, rrcmeas_sib12) == FAILURE)
          {
             WRRC_MSG0_HIGH("Inter-RAT SIB12 ignored");
             rrcirat_initialize_cell_list();
          }
        }
      } /* Else of SIB12 present */
    }

    if (meas_req_incl == TRUE)
    {
      if((sib12_present == SIB12_PRESENT) && (sib12_ptr != NULL))
      {
        /* SIB 12 has been successfully read*/
          MSG_LOW("Send SIB 12 Meas Req to L1",0,0,0);
          rrcmeas_send_l1_cmd(rrcmeas_sib12, NULL, NULL, L1_SIB_PARMS);
      }
      else
      {
        /* SIB 11 has been successfully read*/

        if((sib18_ptr != NULL) || (rrcmeas_sib11->inter_sys_meas_info_incl == TRUE))
        {
          MSG_LOW("Send SIB 11 Meas Req to L1",0,0,0);
          rrcmeas_send_l1_cmd(rrcmeas_sib11, NULL, NULL, L1_SIB_PARMS);
        }
      }
    }
    if (rrcifreq_read_sib11(inter_freq_parms) == FAILURE)
    {
      WRRC_MSG0_HIGH("IFreq:Cell List ignored SIB11");
      rrcifreq_initialize_cell_list();
    }
    if((sib11_ptr = (rrc_SysInfoType11*)
      rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11)) != NULL)
    {
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        MSG_LOW("SIB12 present, processing SIB12",0,0,0);

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          /* Everything is O.K. Read SIB12 */
          if(rrcifreq_read_sib12(sib12_ptr, inter_freq_parms, rrcmeas_inter_freq_sib12) == FAILURE)
          {
            WRRC_MSG0_HIGH("IFreq:Cell List ignored from SIB12");
            rrcifreq_initialize_cell_list();
          }
          else
          {
            meas_choice = L1_INTER_FREQ_SIB_PARMS;
            rrcifreq_send_l1_cmd(&meas_choice, rrcmeas_inter_freq_sib12);
            WRRC_MSG0_HIGH("IFreq:Cell List sent SIB12");
          }
        }
      } /* Else of SIB12 present */

      if((sib12_present == SIB12_ABSENT) && (inter_freq_parms->num_cell_add != 0))
      {
        meas_choice = L1_INTER_FREQ_SIB_PARMS;
        rrcifreq_send_l1_cmd(&meas_choice, inter_freq_parms);
        WRRC_MSG0_HIGH("IFreq:Cell List sent SIB11");
      }
    }
#ifdef FEATURE_WCDMA_CM_LTE_SEARCH
    rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif
    break;

    case RRC_STATE_CELL_FACH:

      psc = rrc_ccm_get_curr_camped_psc();

      /* Get HS Capability Indication */
      if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
      {
        new_hs_ind = rrc_get_3g_cell_capability_indicator();
        if (new_hs_ind == hsdpa_hsupa_ind)
        {
          WRRC_MSG1_HIGH("RRCHS:New cell same HS Cap %d",hsdpa_hsupa_ind);
        }
        else
        {
          hsdpa_hsupa_ind = new_hs_ind;
          WRRC_MSG1_HIGH("RRCHS:Send new HS Cap %d", hsdpa_hsupa_ind);
          rrc_send_3g_cell_capability_information(hsdpa_hsupa_ind);
        }
      }

      WRRC_MSG2_HIGH("IDLE->FACH state...Old SCR %d, New SCR %d",last_scr_code,psc);

      rrcmeas_current_substate = RRCMEAS_CELL_FACH;

      /* Store PSC */
      last_scr_code = psc;

#if defined (FEATURE_CGPS)
      /* Set Cell/PLMN info for LSM */
      rrcmeas_set_cell_plmn_info();
#endif

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
      if(rrcsib_is_sib11_11bis_12_read_deferred(DEFERRED_SIB11))
      {
        l1_deferred_meas_from_sib_action = CLEAR_CELL_INFO_LIST;
        l1_deferred_meas_from_sib_action |= CLEAR_MEAS_IDENTITY;
        rrcmeas_send_deferred_meas_req(l1_deferred_meas_from_sib_action);
        rrc_free(inter_freq_parms);
        return;
      }
#endif
       sib11_ptr = (rrc_SysInfoType11*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11);
      /* Check if SIB12 present */
      if ( sib12_present == SIB12_ABSENT )
      {
        WRRC_MSG0_HIGH("SIB12 not present");

        /* Read from SIB11 */
        /* Get traffic volume params from SIB12 */
        if(sib11_ptr == NULL)
        {
          WRRC_MSG0_ERROR("SIB 11 empty.");
          rrc_free(inter_freq_parms);
          return;
        }
        rrctvm_initialize();

        /* Read traffic volume info from SIB12 and send meas req to MAC */
        if (rrctvm_process_sib_info(&sib11_ptr->measurementControlSysInfo)
          == TVM_SUCCESS)
        {
          MSG_LOW("Sending SIB Meas Req to MAC",0,0,0);
          rrctvm_send_mac_cmd(&mac_sib_params);
        }
        else
        {
          rrctvm_initialize();

          rrctvm_initialize_measurement_identity();
        }
      }
      else
      {
        /* Get traffic volume params from SIB12 */
        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_ERROR("SIB 12 empty.");
          rrc_free(inter_freq_parms);
          return;
        }

        if(RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib12_ptr->measurementControlSysInfo,
            trafficVolumeMeasSysInfo))
        {
          /* Read traffic volume info from SIB12 and send meas req to MAC */
          if (rrctvm_process_sib_info(&sib12_ptr->measurementControlSysInfo)
            == TVM_SUCCESS )
          {
            rrctvm_send_mac_cmd(&mac_sib_params);
          }
          else
          {
            MSG_LOW("Tra Vol sys info invalid",0,0,0);

            rrctvm_initialize();

            rrctvm_initialize_measurement_identity();

          }
        }
        else
        {
           if (rrctvm_process_sib_info(&sib11_ptr->measurementControlSysInfo)
             == TVM_SUCCESS)
           {
             rrctvm_send_mac_cmd(&mac_sib_params);
           }
           else
           {
             MSG_LOW("Tra Vol sys info invalid",0,0,0);

             rrctvm_initialize();

             rrctvm_initialize_measurement_identity();
           }
        }
      }

    /* save the meas id variable in a tmp location */
    WCDMA_MEMCPY(tmp_intra_freq_meas_id_list, 
                 MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                 intra_freq_meas_id_list, 
                 MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));


    if ( rrcmeas_read_sib11() == FAILURE )
    {
      WRRC_MSG0_HIGH("Intra-Freq SIB 11 ignored");
      rrcmeas_clear_sib11();

      rrcmeas_initialize_meas_id_list();

      rrcmeas_initialize_cell_list();

    }
    else
    {
      meas_req_incl = TRUE;
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        MSG_LOW("SIB12 present, processing SIB12",0,0,0);

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          MSG_LOW("Undo changes to Meas id varible from SIB11",0,0,0);
          WCDMA_MEMCPY(intra_freq_meas_id_list, 
                       MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                       tmp_intra_freq_meas_id_list, 
                       MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

          /* Everything is O.K. Read SIB12 */
          rrcmeas_read_sib12(sib12_ptr, rrcmeas_sib12);
        }
      } /* Else of SIB12 present */
    }

    /* Read Inter-RAT SIB11 */
    if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
    {
      WRRC_MSG0_HIGH("Inter-RAT SIB11 ignored");
      rrcirat_initialize_cell_list();
    }
    else
    {
      meas_req_incl = TRUE;
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        MSG_LOW("SIB12 present, processing SIB12",0,0,0);

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          /* Everything is O.K. Read SIB12 */
          if (rrcirat_read_sib12(sib12_ptr, rrcmeas_sib12) == FAILURE)
          {
             WRRC_MSG0_HIGH("Inter-RAT SIB12 ignored");
             rrcirat_initialize_cell_list();
          }
        }
      } /* Else of SIB12 present */
    }

    if (meas_req_incl == TRUE)
    {
      if((sib12_present == SIB12_PRESENT) && (sib12_ptr != NULL))
      {
        /* SIB 12 has been successfully read*/
          MSG_LOW("Send SIB 12 Meas Req to L1",0,0,0);
          rrcmeas_send_l1_cmd(rrcmeas_sib12, NULL, NULL, L1_SIB_PARMS);
      }
      else
      {
        /* SIB 11 has been successfully read*/
        MSG_LOW("Send SIB 11 Meas Req to L1",0,0,0);
        rrcmeas_send_l1_cmd(rrcmeas_sib11, NULL, NULL, L1_SIB_PARMS);
      }
    }
    if (rrcifreq_read_sib11(inter_freq_parms) == FAILURE)
    {
      WRRC_MSG0_HIGH("IFreq:Cell List ignored SIB11");
      rrcifreq_initialize_cell_list();
    }
    if((sib11_ptr = (rrc_SysInfoType11*)
      rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11)) != NULL)
    {
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        MSG_LOW("SIB12 present, processing SIB12",0,0,0);

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          /* Everything is O.K. Read SIB12 */
          if(rrcifreq_read_sib12(sib12_ptr, inter_freq_parms, rrcmeas_inter_freq_sib12) == FAILURE)
          {
            WRRC_MSG0_HIGH("IFreq:Cell List ignored from SIB12");
            rrcifreq_initialize_cell_list();
          }
          else
          {
            meas_choice = L1_INTER_FREQ_SIB_PARMS;
            rrcifreq_send_l1_cmd(&meas_choice, rrcmeas_inter_freq_sib12);
            WRRC_MSG0_HIGH("IFreq:Cell List sent SIB12");
          }
        }
      } /* Else of SIB12 present */

      if((sib12_present == SIB12_ABSENT) && (inter_freq_parms->num_cell_add != 0))
      {
        meas_choice = L1_INTER_FREQ_SIB_PARMS;
        rrcifreq_send_l1_cmd(&meas_choice, inter_freq_parms);
        WRRC_MSG0_HIGH("IFreq:Cell List sent SIB11");
      }
    }

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
    rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif

    break;

    default:
      MSG_MED("Transition Idle --> %d not supported",
      cmd_ptr->cmd.state_change_ind.new_state, 0,0);
     break;
  } /* End of switch */
  rrc_free(inter_freq_parms);
  return;
} /* End of function */



/*===========================================================================

FUNCTION     RRCMEAS_PROCESS_STATE_CHANGE_IND_IN_DCH_STATE

DESCRIPTION

 Processes state change indication message received in CELL_DCH
 Also changes the RRCMEAS procedure state from DCH to the
 desired state.

DEPENDENCIES

 None.

RETURN VALUE

 None.

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_process_state_change_ind_in_dch_state
(
rrc_cmd_type* cmd_ptr
)
{
  uint8 count = 0;
  uint8 cnt = 0;
  /* For sending command to MAC */
  mac_ul_traffic_meas_config_type traffic_vol_params;

  rrc_SysInfoType12 *sib12_ptr = NULL;
  rrc_SysInfoType11 *sib11_ptr = NULL;

  rrc_scr_code_type psc;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

  rrc_meas_params_struct_type *pos_cmd;
  pos_cmd = &temp_gps;
  memset(pos_cmd,0,sizeof(rrc_meas_params_struct_type));

  pos_cmd->params_type = (uint8) RRC_STATE_CHANGE_PARMS;

#endif

  rrcqm_initialize_meas_id_list();

  if(state_transition_meas != NULL)
  {
    state_transition_meas->hcs_used = FALSE;
  }

  switch ( cmd_ptr->cmd.state_change_ind.new_state )
  {
    /* For both of these states, RRCMEAS procedure is in IDLE state */

  case RRC_STATE_DISCONNECTED:

    WRRC_MSG0_HIGH("Transitioning from DCH->Idle state");
    /* reset pending rpt counter on state change from dch */
    rrcmeas_pending_rpt = 0;
    rrcmeas_current_substate = RRCMEAS_IDLE;

    rrcmeas_initialize_transaction_id_list();

    /* Trash CM params from TOC config */
    rrcllc_initialize_cm_parms();

    trans_id = INVALID_TRANSACTION_ID;

    /* Trash SIB11 values */
    rrcmeas_clear_sib11();

    rrcmeas_initialize_meas_id_list();

    rrcmeas_initialize_cell_list();

    sib12_present = SIB12_ABSENT;

    last_scr_code = INVALID_PSC;

    if(ordered_config_ptr != NULL)
    {
      memset(ordered_config_ptr->tgp_seq_info, 0, sizeof(ordered_config_ptr->tgp_seq_info));
    }
    if(current_config_ptr != NULL)
    {
      memset(current_config_ptr->tgp_seq_info, 0, sizeof(current_config_ptr->tgp_seq_info));
    }

    rrcirat_initialize_cell_list();

    rrcirat_initialize_meas_id_list();


    rrcifreq_initialize_meas_id_list();


    rrcifreq_initialize_cell_list();


    /* Send cmd to MAC to delete Meas */
    traffic_vol_params.meas_cmd = MAC_TRAFFIC_MEAS_DELETE_ALL;

    traffic_vol_params.config_conf_ind = FALSE;

    rrctvm_send_mac_cmd(&traffic_vol_params);

    rrctvm_initialize();

    rrctvm_initialize_measurement_identity();

    rrcueim_initialize_meas_id_list();

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

#ifdef FEATURE_AAGPS_MR_RRC_NOTIFICATION_REQUIRED
    rrcgps_initialize_l2_ack_params();
#endif
    for ( count = 0; count < MAX_POS_MEAS; count++ )
    {
      /* Set all positions to vacant and make PSC as invalid */
      if (pos_meas_id_list[count].meas_id != INVALID_MEAS_ID)
      {
        /* Cmd type */
        pos_cmd->u.trans_params.trans_cmd_type = (uint8) RRC_MEAS_DELETE;

        /* Meas Id */
        pos_cmd->u.trans_params.meas_id = pos_meas_id_list[count].meas_id;

        WRRC_MSG1_HIGH("Indicate LSM to delete %d Meas", pos_cmd->u.trans_params.meas_id);

        rrcgps_send_lsm_cmd(pos_cmd);

        pos_meas_id_list[count].meas_id = INVALID_MEAS_ID;

        pos_meas_id_list[count].meas_validity = NOT_PRESENT;

        pos_meas_id_list[count].rpt_crit = NOT_AVAILABLE;

        /* Also initialize additional meas */
        for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
          pos_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
      }
    }

#endif
    break;

  case RRC_STATE_CELL_FACH:

    if(state_transition_meas == NULL)
    {
      ERR_FATAL("state_transition_meas ptr is NULL", 0,0,0);
    }
    psc = rrc_ccm_get_curr_camped_psc();

    WRRC_MSG2_HIGH("Received DCH->FACH indication...Old SCR %d, New SCR %d",last_scr_code,psc);
    sib11_ptr = (rrc_SysInfoType11*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11);
    /* First change procedure state to FACH */
    rrcmeas_current_substate = RRCMEAS_CELL_FACH;

    rrcmeas_initialize_transaction_id_list();

    /* Store PSC */
    last_scr_code = psc;
#if defined (FEATURE_CGPS)
    /* Set Cell/PLMN info for LSM */
    rrcmeas_set_cell_plmn_info();

#ifdef FEATURE_AAGPS_MR_RRC_NOTIFICATION_REQUIRED
    if (gps_l2_ack_params.waiting_for_l2_ack == TRUE)
    {
      WRRC_MSG0_HIGH("AGPS:Forcefully indicate LSM about Meas Rpt. Indicate LSM about report");

      rrc_lsm_meas_report_notification(gps_l2_ack_params.meas_id,
                                     FALSE);

      rrcgps_initialize_l2_ack_params();
    }
#endif
#endif

    /* Delete the Meas for which validity is not defined */
    for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
    {
      if ((intra_freq_meas_id_list[count].meas_id != INVALID_MEAS_ID) &&
        (intra_freq_meas_id_list[count].meas_validity == NOT_PRESENT))
      {
        MSG_LOW("Delete %d IntraFreqMeas, Val unspec", intra_freq_meas_id_list[count].meas_id,0,0);

        /* Send cmd to L1 */
        state_transition_meas->meas_id = intra_freq_meas_id_list[count].meas_id;

        state_transition_meas->meas_type = L1_INTRA_FREQ;

        state_transition_meas->meas_action = L1_MEAS_DELETE;

        rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);

        /* Delete Addtl Meas if any */
        rrcmeas_delete_addtl_meas(&intra_freq_meas_id_list[count].meas_id);

        /* Delete and re-initialize all Meas Parameters */
        rrcmeas_delete_meas(&intra_freq_meas_id_list[count].meas_id);
      }
    }

    /* Check the cause of transition */
    if (rrccsp_is_state_transition_triggered_by_reconfig_msg() == TRUE)
    {
      WRRC_MSG0_HIGH("DCH->FACH triggered by Reconfig Msg");

      /* Check if UE camped on UTRAN directed cell */
      if (rrccsp_is_selected_cell_utran_directed() == TRUE)
      {
        WRRC_MSG0_HIGH("UE camped on UTRAN directed cell");

        /*-------------------------------------------------------
        Till the time measurements saved are actually resumed,
        use the function to delete the measurements */
        /* rrcmeas_config_l1_meas_on_transition_by_other_msg(); */
        /*------------------------------------------------------*/

        /* In this scenario, Measurement has to be saved
        Thus call rrcmeas_save_l1_meas to save the meas
        and send corresponding command to L1.  */

        rrcmeas_save_l1_meas();
      }
      else
      {
        WRRC_MSG0_HIGH("UE camped on its own selection");
        /* Since this scenario is the same as the scenario
        when UE transitions due to radio link failure.
        So the same functional interface is called */
        rrcmeas_config_l1_meas_on_transition_by_other_msg();
      }

    }
    else
    {
      WRRC_MSG0_HIGH("DCH->FACH not triggered by Reconfig Msg");
      /* Got to trash Intra-Freq Measurements */
      rrcmeas_config_l1_meas_on_transition_by_other_msg();
    }

    /* Reinitialize Meas Id List */
    rrcueim_initialize_meas_id_list();

    /* Configure Traffic Volume Measurements */
    rrctvm_process_dch_to_fach();

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

    WRRC_MSG0_HIGH("Process Positioning Meas on DtoF trans");
    rrcgps_process_dch_to_fach_pch();
#endif

    /* Process Inter-RAT CELL_INFO_LIST on state change */

    /* Clear Cell list and Meas Id List */
    rrcirat_initialize_cell_list();

    for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
    {
      if (inter_rat_meas_id_list[count].meas_id != INVALID_MEAS_ID)
      {
        rrcmeas_delete_addtl_meas(&inter_rat_meas_id_list[count].meas_id);
      }
    }

    /* This removes all the IRAT Primary Measurements */
    rrcirat_initialize_meas_id_list();

    /* Even if SIB11 for intra-freq meas is not good, we would read SIB11 for inter-RAT */
    if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
    {
      WRRC_MSG0_HIGH("Inter-RAT SIB11 ignored");
      rrcirat_initialize_cell_list();
    }
    else
    {
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        MSG_LOW("SIB12 present, processing SIB12",0,0,0);

        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          /* Everything is O.K. Read SIB12 */
          if(rrcirat_read_sib12(sib12_ptr, rrcmeas_sib12) == FAILURE)
          {
            WRRC_MSG0_HIGH("Inter-RAT SIB12 ignored");
            rrcirat_initialize_cell_list();
          }
        }
      } /* Else of SIB12 present */
      if((sib12_present == SIB12_PRESENT) && (sib12_ptr != NULL))
      {
        /* Set Measurement Action */
        state_transition_meas->meas_action = L1_MEAS_STOP_AND_CONFIG_CELL_LIST;

        /* Set Meas Id to 0 to indicate to L1 to not bother about this param */
        state_transition_meas->meas_id = 0;

        /* Set Meas Type */
        state_transition_meas->meas_type = L1_INTER_SYS;

        WRRC_MSG2_HIGH("State trans cmd built...SIB12 Inter RAT: Setting HCS flag to %d, FACH meas incl %d",state_transition_meas->hcs_used,rrcmeas_sib12->fach_meas_incl);

        if( RRC_CHECK_COMMON_MSG_TYPE(sib12_ptr->measurementControlSysInfo.use_of_HCS,
          rrc_MeasurementControlSysInfo_use_of_HCS_hcs_used ))
        {
          state_transition_meas->hcs_used = TRUE;
        }

        state_transition_meas->u.inter_s = rrcmeas_sib12->inter_s;

        if(rrcmeas_sib12->fach_meas_incl)
        {
          state_transition_meas->fach_meas_incl = TRUE;
          state_transition_meas->fach.inter_f_ind = rrcmeas_sib12->fach.inter_f_ind;
          state_transition_meas->fach.k = rrcmeas_sib12->fach.k;
          state_transition_meas->fach.k_ind  = rrcmeas_sib12->fach.k_ind;
          state_transition_meas->fach.num_inter_sys  = rrcmeas_sib12->fach.num_inter_sys;
          state_transition_meas->fach.inter_sys[0] = rrcmeas_sib12->fach.inter_sys[0];

          MSG_LOW("State Tran meas cmd successfully built",0,0,0);
        }
        else
        {
          state_transition_meas->fach_meas_incl = FALSE;
        }

        rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);
        WRRC_MSG0_HIGH("Sending GSM list to L1 in FACH");
      }
      else
      {
        if((sib11_ptr = (rrc_SysInfoType11*) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11)) == NULL)
        {
          break;
        }
        if (rrcmeas_get_fach_meas_info() == RRCMEAS_SUCCESS)
        {
          /* Set Measurement Action */
          state_transition_meas->meas_action = L1_MEAS_STOP_AND_CONFIG_CELL_LIST;

          /* Set Meas Id to 0 to indicate to L1 to not bother about this param */
          state_transition_meas->meas_id = 0;

          /* Set Meas Type */
          state_transition_meas->meas_type = L1_INTER_SYS;

          WRRC_MSG2_HIGH("State Tran meas cmd built...SIB11 HCS flag %d, FACH meas incl %d",state_transition_meas->hcs_used,rrcmeas_sib11->fach_meas_incl);

          if( RRC_CHECK_COMMON_MSG_TYPE(sib11_ptr->measurementControlSysInfo.use_of_HCS,
             rrc_MeasurementControlSysInfo_use_of_HCS_hcs_used ))
          {
            state_transition_meas->hcs_used = TRUE;
          }
          state_transition_meas->u.inter_s = rrcmeas_sib11->inter_s;

          if(rrcmeas_sib11->fach_meas_incl)
          {
            state_transition_meas->fach_meas_incl = TRUE;
            state_transition_meas->fach.inter_f_ind = rrcmeas_sib11->fach.inter_f_ind;
            state_transition_meas->fach.k = rrcmeas_sib11->fach.k;
            state_transition_meas->fach.k_ind  = rrcmeas_sib11->fach.k_ind;
            state_transition_meas->fach.num_inter_sys  = rrcmeas_sib11->fach.num_inter_sys;
            state_transition_meas->fach.inter_sys[0]   = rrcmeas_sib11->fach.inter_sys[0];

            MSG_LOW("State Tran meas cmd successfully built",0,0,0);
          }
          else
          {
            state_transition_meas->fach_meas_incl = FALSE;
          }

          rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);
          WRRC_MSG0_HIGH("Sending GSM list to L1 in FACH");
        }
        else
        {
          WRRC_MSG0_HIGH("FACH Meas Absent. No GSM Meas");
        }
      }
    }
#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
      rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif

    break;

    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH:

      /* As new cell indication in CELL_DCH is considered to be state change for DCH */
 
   if(!is_dch_to_pch_new_cell_ind_processed)
   {
     rrcmeas_handle_dch_to_pch_state_change();
     is_dch_to_pch_new_cell_ind_processed = TRUE;
   }/* End of if for DCH->PCH trans in progress */
   
      break;


  default:

    WRRC_MSG1_HIGH("Transition from CELL_DCH to %d not supported",
      cmd_ptr->cmd.state_change_ind.new_state);
    break;

  } /* End of switch */

} /* End of function */

/*===========================================================================

FUNCTION  rrcmeas_handle_dch_to_pch_state_change

DESCRIPTION

  Process DCH to PCH state transition.

DEPENDENCIES

  None

RETURN VALUE

  None

SIDE EFFECTS

  None

===========================================================================*/

void rrcmeas_handle_dch_to_pch_state_change()
{
   uint8 inter_rat_meas_to_be_deleted_from_addtl_db[MAX_INTER_RAT_MEAS];

   rrc_FACH_MeasurementOccasionInfo_inter_RAT_meas_ind * local_sib_inter_rat_ptr = NULL;
   uint32 idx=0;
   rrc_SysInfoType12 *sib12_ptr = NULL;
    rrc_SysInfoType11 *sib11_ptr = NULL;
   
    rrc_scr_code_type psc;
    uint8 count = 0;

   psc = rrc_ccm_get_curr_camped_psc();

   WRRC_MSG2_HIGH("IntraF: DCH->PCH in prog(5C/6U)...Old SCR %d,New SCR %d",last_scr_code,psc);
   /* First change procedure state to PCH */
   rrcmeas_current_substate = RRCMEAS_PCH;

   if(state_transition_meas == NULL)
   {
     ERR_FATAL("state_transition_meas ptr is NULL", 0,0,0);
   }

   sib11_ptr = (rrc_SysInfoType11*)
       rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11);

   last_scr_code = psc;

#if defined (FEATURE_CGPS)

   /* Set Cell/PLMN info for LSM */
    rrcmeas_set_cell_plmn_info();

#endif

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA) 

   /* For now as per the understanding with LSM, RRC will tell LSM to do similar behaviour
      as per going to FACH. To be Changed when LSM supports PCH */
#ifdef FEATURE_AAGPS_MR_RRC_NOTIFICATION_REQUIRED
    if (gps_l2_ack_params.waiting_for_l2_ack == TRUE)
    {
      WRRC_MSG0_HIGH("AGPS: Forcefully indicate LSM about L2 ack...Indicate LSM about report");

      rrc_lsm_meas_report_notification(gps_l2_ack_params.meas_id,
                                                             FALSE);
      rrcgps_initialize_l2_ack_params();
    }
#endif
     rrcgps_process_dch_to_fach_pch();

#endif /*FEATURE_CGPS_UMTS_CP_WCDMA */

    /* Delete the Meas for which validity is not defined */
    for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
    {
        if ((intra_freq_meas_id_list[count].meas_id != INVALID_MEAS_ID) &&
            (intra_freq_meas_id_list[count].meas_validity == NOT_PRESENT))
        {
           WRRC_MSG1_HIGH("Delete %d IntraFreqMeas, Val unspec", intra_freq_meas_id_list[count].meas_id);

           /* Send cmd to L1 */
           state_transition_meas->meas_id = intra_freq_meas_id_list[count].meas_id;

           state_transition_meas->meas_type = L1_INTRA_FREQ;

           state_transition_meas->meas_action = L1_MEAS_DELETE;

           rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);

           /* Delete Addtl Meas if any */
           rrcmeas_delete_addtl_meas(&intra_freq_meas_id_list[count].meas_id);

           /* Delete and re-initialize all Meas Parameters */
           rrcmeas_delete_meas(&intra_freq_meas_id_list[count].meas_id);
        }
    }

    /* Check the cause of transition */
    if (rrccsp_is_state_transition_triggered_by_reconfig_msg() == TRUE)
    {
      WRRC_MSG0_HIGH("DCH->PCH triggered by Reconfig Msg");

      /* Check if UE camped on UTRAN directed cell */
      if (rrccsp_is_selected_cell_utran_directed() == TRUE)
      {
          WRRC_MSG0_HIGH("UE camped on UTRAN directed cell");

          /* In this scenario, Measurement has to be saved
           Thus call rrcmeas_save_l1_meas to save the meas
            and send corresponding command to L1.  */
           rrcmeas_save_l1_meas();
      }
      else
      {
          WRRC_MSG0_HIGH("UE camped on its own selection");
          /* Since this scenario is the same as the scenario
             when UE transitions due to radio link failure.
             So the same functional interface is called */
           rrcmeas_config_l1_meas_on_transition_by_other_msg();
      }

     }
     else
     {
         WRRC_MSG0_HIGH("DCH->PCH not triggered by Reconfig Msg");
        /* Got to trash Intra-Freq Measurements */
         rrcmeas_config_l1_meas_on_transition_by_other_msg();

     }
     dch_to_pch_in_progress = TRUE;
     /* Configure Traffic Volume Measurements. Same as DCH->FACH */
     rrctvm_process_dch_to_fach();
     dch_to_pch_in_progress = FALSE;

     /* Process Inter-RAT CELL_INFO_LIST on state change */

     /* Clear Cell list and Meas Id List */
     rrcirat_initialize_cell_list();

     /* Copy all primary meas that needs to be deleted from addtl meas
      DB in a local variable */

       for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
       {
          inter_rat_meas_to_be_deleted_from_addtl_db[count] =
          (uint8) inter_rat_meas_id_list[count].meas_id;
       }

       for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
       {
           if (inter_rat_meas_to_be_deleted_from_addtl_db[count] != INVALID_MEAS_ID)
           {
               rrcmeas_delete_addtl_meas(&inter_rat_meas_id_list[count].meas_id);
           }
       }

       /* This removes all the IRAT Primary Measurements */
       rrcirat_initialize_meas_id_list();

       /* Even if SIB11 for intra-freq meas is not good, we would read SIB11 for inter-RAT */
        if (rrcirat_read_sib11(rrcmeas_sib11) == FAILURE)
        {
            WRRC_MSG0_HIGH("IntraF: Inter-RAT SIB11 ignored");
            rrcirat_initialize_cell_list();
        }

        else
        {
           /* check for SIB 12 and use it if present */
           if ( sib12_present == SIB12_ABSENT )
           {
               MSG_LOW("SIB12 not present", 0,0,0);
           }
           else
           {
               MSG_LOW("SIB12 present, processing SIB12",0,0,0);

               if((sib12_ptr = (rrc_SysInfoType12*)
                rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
               {
                  WRRC_MSG0_HIGH("SIB 12 empty.");
               }
               else
               {
                   /* Everything is O.K. Read SIB12 */
                   if(rrcirat_read_sib12(sib12_ptr, rrcmeas_sib12) == FAILURE)
                   {
                       WRRC_MSG0_HIGH("Inter-RAT SIB12 ignored");
                        rrcirat_initialize_cell_list();
                    }
               }
           } /* Else of SIB12 present */

           if((sib12_present == SIB12_PRESENT) && (sib12_ptr != NULL))
           {
              /* Set Measurement Action */
              state_transition_meas->meas_action = L1_MEAS_STOP_AND_CONFIG_CELL_LIST;

              /* Set Meas Id to 0 to indicate to L1 to not bother about this param */
               state_transition_meas->meas_id = 0;

              /* Set Meas Type */
              state_transition_meas->meas_type = L1_INTER_SYS;
              if(RRC_CHECK_COMMON_MSG_TYPE(sib12_ptr->measurementControlSysInfo.use_of_HCS,
                    rrc_MeasurementControlSysInfo_use_of_HCS_hcs_used))
              {
                    WRRC_MSG0_HIGH("SIB12 Inter RAT: Setting HCS flag to TRUE");
                    state_transition_meas->hcs_used = TRUE;
              }
              state_transition_meas->u.inter_s = rrcmeas_sib12->inter_s;

              state_transition_meas->fach.num_inter_sys = 1;

              if(rrcmeas_sib12->fach_meas_incl)
              {
                     state_transition_meas->fach_meas_incl = TRUE;
                     state_transition_meas->fach.inter_f_ind = rrcmeas_sib12->fach.inter_f_ind;
                     state_transition_meas->fach.k = rrcmeas_sib12->fach.k;
                     state_transition_meas->fach.k_ind  = rrcmeas_sib12->fach.k_ind;
                     state_transition_meas->fach.num_inter_sys  = rrcmeas_sib12->fach.num_inter_sys;
                     state_transition_meas->fach.inter_sys[0]   = rrcmeas_sib12->fach.inter_sys[0];
              }
              else
              {
                     state_transition_meas->fach_meas_incl = FALSE;
              }

              MSG_LOW("State Tran meas cmd successfully built",0,0,0);
          }
          else
          {
              if((sib11_ptr = (rrc_SysInfoType11*) rrc_sibdb_return_sib_for_srv_cell
                  (rrc_SIB11)) == NULL)
              {
                   WRRC_MSG0_ERROR("SIB 11 from SIB DB is NULL");
              }
              else
              {
               rrcmeas_sib11->fach_meas_incl = FALSE;
               /* Check if the FACH Measurement Occassion Info if present */
               if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib11_ptr,
                   rrc_SysInfoType11,fach_MeasurementOccasionInfo))
               {
                  rrcmeas_sib11->fach_meas_incl = TRUE;

                  /* Initialize the following value to Default values */
                  rrcmeas_sib11->fach.k_ind = FALSE;
                  rrcmeas_sib11->fach.inter_f_ind = FALSE;
                  rrcmeas_sib11->fach.num_inter_sys = 0;

                  /* Check if fACH_meas_occasion_coeff present */
                  if (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib11_ptr->fach_MeasurementOccasionInfo,
                  fACH_meas_occasion_coeff))
                  {
                     /* Set the flag */
                      rrcmeas_sib11->fach.k_ind = TRUE;
                      rrcmeas_sib11->fach.k =
                        sib11_ptr->fach_MeasurementOccasionInfo.fACH_meas_occasion_coeff;
                  }

                  /* Check if Inter Freq indicator present */
                  if (sib11_ptr->fach_MeasurementOccasionInfo.inter_freq_FDD_meas_ind == TRUE)
                  {
                       rrcmeas_sib11->fach.inter_f_ind = TRUE;
                  }

                  /* Check if Inter RAT indicator present */
                  local_sib_inter_rat_ptr = &sib11_ptr->fach_MeasurementOccasionInfo.inter_RAT_meas_ind;

                  while (local_sib_inter_rat_ptr->n > idx)
                  {
                        if (local_sib_inter_rat_ptr->elem[idx] == rrc_RAT_Type_gsm)
                        {
                            rrcmeas_sib11->fach.num_inter_sys = 1;
                            rrcmeas_sib11->fach.inter_sys[0] = L1_GSM_SYSTEM;
                             break;
                        }
                     idx++;
                  }
              }
              /* Set Measurement Action */
              state_transition_meas->meas_action = L1_MEAS_STOP_AND_CONFIG_CELL_LIST;

              /* Set Meas Id to 0 to indicate to L1 to not bother about this param */
              state_transition_meas->meas_id = 0;

              /* Set Meas Type */
              state_transition_meas->meas_type = L1_INTER_SYS;
              if(RRC_CHECK_COMMON_MSG_TYPE(sib11_ptr->measurementControlSysInfo.use_of_HCS,
                    rrc_MeasurementControlSysInfo_use_of_HCS_hcs_used))
              {
                    WRRC_MSG0_HIGH("SIB11 Inter RAT: Setting HCS flag to TRUE");
                    state_transition_meas->hcs_used = TRUE;
              }
              state_transition_meas->u.inter_s = rrcmeas_sib11->inter_s;

              state_transition_meas->fach.num_inter_sys = 1;

              if(rrcmeas_sib11->fach_meas_incl)
              {
                   state_transition_meas->fach_meas_incl = TRUE;
                   state_transition_meas->fach.inter_f_ind = rrcmeas_sib11->fach.inter_f_ind;
                   state_transition_meas->fach.k = rrcmeas_sib11->fach.k;
                   state_transition_meas->fach.k_ind  = rrcmeas_sib11->fach.k_ind;
                   state_transition_meas->fach.num_inter_sys  = rrcmeas_sib11->fach.num_inter_sys;
                   state_transition_meas->fach.inter_sys[0]   = rrcmeas_sib11->fach.inter_sys[0];
              }
              else
              {
                 state_transition_meas->fach_meas_incl = FALSE;
              }
              MSG_LOW("State Tran meas cmd successfully built",0,0,0);
           }
         }
          /* Send Command to L1 */
          rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);
         WRRC_MSG0_HIGH("IntraF:Sending GSM list L1 in PCH");
     } /* End of else */

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
     rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif
 }

/*===========================================================================

FUNCTION     RRCMEAS_PROCESS_STATE_CHANGE_IND_IN_FACH_STATE

DESCRIPTION

 Processes state change indication message received in CELL_FACH
 Also changes the RRCMEAS procedure state from FACH to the
 desired state.

DEPENDENCIES

 None.

RETURN VALUE

 None.

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_process_state_change_ind_in_fach_state
(
rrc_cmd_type* cmd_ptr
)
{
   uint8 count = 0;
   uint8 cnt = 0;
  /* For sending command to MAC */
  mac_ul_traffic_meas_config_type traffic_vol_params;

  sys_hs_ind_e_type new_hs_ind = SYS_HS_IND_NONE;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

  rrc_meas_params_struct_type *pos_cmd;
  pos_cmd = &temp_gps;
  memset(pos_cmd,0,sizeof(rrc_meas_params_struct_type));


  pos_cmd->params_type = (uint8) RRC_STATE_CHANGE_PARMS;

#endif

  switch ( cmd_ptr->cmd.state_change_ind.new_state )
  {
    /* For both of these states, RRCMEAS procedure is in IDLE state */

  case RRC_STATE_DISCONNECTED:

    WRRC_MSG0_HIGH("Transitioning from FACH->Idle state");
    /* reset pending rpt counter on state change from fach */
    rrcmeas_pending_rpt = 0;

    rrcmeas_current_substate = RRCMEAS_IDLE;

    trans_id = INVALID_TRANSACTION_ID;

    last_scr_code = INVALID_PSC;

    rrcmeas_initialize_transaction_id_list();

    /* Trash SIB11 values */
    rrcmeas_clear_sib11();

    rrcmeas_initialize_meas_id_list();

    rrcmeas_initialize_cell_list();

    rrcllc_initialize_cm_parms();

    sib12_present = SIB12_ABSENT;

    /* Send cmd to MAC to delete Meas */
    traffic_vol_params.meas_cmd = MAC_TRAFFIC_MEAS_DELETE_ALL;

    traffic_vol_params.config_conf_ind = FALSE;

    rrctvm_send_mac_cmd(&traffic_vol_params);

    /* Now initialize mac_sib_params and tvm_meas_id_list */
    rrctvm_initialize();

    rrctvm_initialize_measurement_identity();

    rrcifreq_initialize_cell_list();

    rrcifreq_initialize_meas_id_list();

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

#ifdef FEATURE_AAGPS_MR_RRC_NOTIFICATION_REQUIRED
    rrcgps_initialize_l2_ack_params();
#endif
    for ( count = 0; count < MAX_POS_MEAS; count++ )
    {
      /* Set all positions to vacant and make PSC as invalid */
      if (pos_meas_id_list[count].meas_id != INVALID_MEAS_ID)
      {
        /* Cmd type */
        pos_cmd->u.trans_params.trans_cmd_type = (uint8) RRC_MEAS_DELETE;

        /* Meas Id */
        pos_cmd->u.trans_params.meas_id = pos_meas_id_list[count].meas_id;

        WRRC_MSG1_HIGH("Indicate LSM to delete %d Meas", pos_cmd->u.trans_params.meas_id);

        rrcgps_send_lsm_cmd(pos_cmd);

        pos_meas_id_list[count].meas_id = INVALID_MEAS_ID;

        pos_meas_id_list[count].meas_validity = NOT_PRESENT;

        pos_meas_id_list[count].rpt_crit = NOT_AVAILABLE;

        /* Also initialize additional meas */
        for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
          pos_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
      }
    }

#endif

    break;


  case RRC_STATE_CELL_DCH:

    WRRC_MSG0_HIGH("Received FACH->DCH indication");

    /* Get HS Capability Indication */
    if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
    {
      if (hsdpa_hsupa_ind != SYS_HS_IND_HSDPA_HSUPA_UNSUPP_CELL)
      {
        hsdpa_hsupa_ind = new_hs_ind;
        WRRC_MSG1_HIGH("RRCHS:new_hs_ind =%d", new_hs_ind);
      }
    }

    /* Find out what was the last cell RRC camped on in FACH mode and what is the new
    cell in CELL_DCH */

    if (rrcmeas_check_if_scr_present_in_aset() == TRUE)
    {
      MSG_LOW("SCR found in ASET",0,0,0);
    }
    else
    {
      /* Configure which meas need not be reported till MCM received */
      rrcmeas_update_meas_after_state_trans();
    }

    /* Change the procedure substate */
    rrcmeas_current_substate = RRCMEAS_CELL_DCH;

    rrctvm_process_fach_to_dch();

    /* Do not initialize GSM cell list */

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

    WRRC_MSG0_HIGH("Process Positioning Meas on FtoD");
    rrcgps_process_fach_to_dch();

#endif
    break;


  case RRC_STATE_CELL_PCH:
  case RRC_STATE_URA_PCH:
  /* MAC has already been asked not to build data frame in PCH. So no
    need to disable reporting separately */
    if (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_CELL_PCH)
    {
      WRRC_MSG0_HIGH("Transitioning FACH->CELL_PCH");
    }
    else if (cmd_ptr->cmd.state_change_ind.new_state == RRC_STATE_URA_PCH)
    {
      WRRC_MSG0_HIGH("Transitioning FACH->URA_PCH");
    }
    else
    {
      WRRC_MSG1_ERROR("Incorrect state change %d new state",cmd_ptr->cmd.state_change_ind.new_state);
      /* Bail out */
      break;
    }

    /* Change the procedure substate */
    rrcmeas_current_substate = RRCMEAS_PCH;
    if(rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
    {
      rrc_csp_send_cell_param_req_for_pch_fach();
    }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
#ifdef FEATURE_LSM_PCH_REPORTING
    #error code not present
#endif /* FEATURE_LSM_PCH_REPORTING */
#endif  /* FEATURE_CGPS_UMTS_CP_WCDMA */

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
    rrcmeas_configure_l1_with_priority_info_eutra_cell_list();
#endif
    break;


  default:

    WRRC_MSG1_HIGH("Transition from CELL_FACH to %d not supported",
      cmd_ptr->cmd.state_change_ind.new_state);

  } /* End of switch */

} /* End of function */



/*===========================================================================

FUNCTION    RRCMEAS_PROCESS_CPHY_MEAS_IND_IN_DCH_STATE

DESCRIPTION

 Processes measurement indication received from L1
 in CELL_DCH state.

DEPENDENCIES

 None.

RETURN VALUE

 void

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_process_cphy_meas_ind_in_dch_state
(
rrc_cmd_type *cmd_ptr
)
{
  rrcllc_oc_set_status_e_type oc_set_state;
  uint8 cnt = 0, count = 0;

  oc_set_state = rrcllc_get_ordered_config_status();


  if (((oc_set_state == OC_SET_FOR_DCH_FACH_TRANS) ||
    (oc_set_state == OC_SET_FOR_DCH_CELL_PCH_TRANS) ||
    (oc_set_state == OC_SET_FOR_DCH_URA_PCH_TRANS)) ||
    (rrcrcr_is_proc_active() == TRUE) ||
    ((cmd_ptr->cmd.meas_ind.meas_rpt->meas_type == L1_INTER_FREQ) &&
    (cmd_ptr->cmd.meas_ind.meas_rpt->meas_transfer_mode == ACKNOWLEDGED_MODE)
    && (rrcmeas_pending_rpt > (uint8) MAX_PEND_MEAS_RPT)))
  {
    MSG_HIGH("Ordered Config Set for %d 2U/3C/4F.Ignore %d Report 1/2/3/7(U)rpt cnt %d",oc_set_state,cmd_ptr->cmd.meas_ind.meas_rpt->meas_type,rrcmeas_pending_rpt);

    /* Check if it is InterFreq Report. Release Memory */
    if (cmd_ptr->cmd.meas_ind.meas_rpt->meas_type == L1_INTER_FREQ)
    {
      /* Deallocate the cell list if any allocated by L1 */
      for (cnt = 0; (cnt < cmd_ptr->cmd.meas_ind.meas_rpt->u.inter_f_rpt.inter_freq_measurements.num_msmt_results) &&
        (cmd_ptr->cmd.meas_ind.meas_rpt->u.inter_f_rpt.meas_results_included == TRUE); cnt++)
      {
        for ( count = 0; ((count < cmd_ptr->cmd.meas_ind.meas_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].num_cells)
          && ( count < L1_MAX_CELL_MEAS)); count++ )
        {
          if (cmd_ptr->cmd.meas_ind.meas_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[count] != NULL)
          {
            rrc_free_interlayer_cmd( cmd_ptr->cmd.meas_ind.meas_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[count]);
            cmd_ptr->cmd.meas_ind.meas_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[count] = NULL;
          }
        }
      }
    }

    return;
  }

  /* Max 12 pending rpts allowed in rlc queue */
  if((cmd_ptr->cmd.meas_ind.meas_rpt->meas_transfer_mode == ACKNOWLEDGED_MODE)
    && (rrcmeas_pending_rpt > (uint8) MAX_PEND_MEAS_RPT))
  {
    WRRC_MSG2_HIGH("Ignoring meas rpt type %d pending rpt %d > 12",cmd_ptr->cmd.meas_ind.meas_rpt->meas_type,rrcmeas_pending_rpt);
    return;
  }
#ifdef FEATURE_WCDMA_DEBUG_ATTEMPT_FULL_SRCH
  if(TRUE == rrc_enable_psc_lock_nv)
  {
    WRRC_MSG1_HIGH("Ignoring meas rpt type %d as psc lock nv is Enabled",cmd_ptr->cmd.meas_ind.meas_rpt->meas_type);
    return;
  }
#endif

  switch ( cmd_ptr->cmd.meas_ind.meas_rpt->meas_type )
  {
  case L1_INTRA_FREQ:

    WRRC_MSG1_HIGH("IntraFreq Report %d received",cmd_ptr->cmd.meas_ind.meas_rpt->meas_id);

    if (rrcmeas_check_if_rpt_can_be_txted(cmd_ptr->cmd.meas_ind.meas_rpt->meas_id) == FALSE)
    {
      MSG_LOW("Ignoring Intra Freq Rpt",0,0,0);
    }
    else
    {
      rrcmeas_send_intra_freq_meas_report_to_utran(cmd_ptr->cmd.meas_ind.meas_rpt);
    }

    break;

#ifdef FEATURE_WCDMA_CM_LTE_SEARCH
  case L1_INTER_SYS_EUTRA:
#endif
  case L1_INTER_SYS:

    WRRC_MSG1_HIGH("InterRAT Report %d received",cmd_ptr->cmd.meas_ind.meas_rpt->meas_id);

    rrcirat_send_meas_report(cmd_ptr->cmd.meas_ind.meas_rpt);

    break;



  case L1_INTER_FREQ:

    WRRC_MSG1_HIGH("InterFreq Report %d received",cmd_ptr->cmd.meas_ind.meas_rpt->meas_id);

    rrcifreq_send_meas_report(cmd_ptr->cmd.meas_ind.meas_rpt);

    break;

  case L1_UE_INTERNAL:

    WRRC_MSG1_HIGH("UEInternal Meas Report %d received",cmd_ptr->cmd.meas_ind.meas_rpt->meas_id);

    rrcueim_send_meas_report(cmd_ptr->cmd.meas_ind.meas_rpt);

    break;

  case L1_QUALITY:
     WRRC_MSG1_HIGH("UE QualityMeas Report %d received",cmd_ptr->cmd.meas_ind.meas_rpt->meas_id);

    rrcqm_send_meas_report(cmd_ptr->cmd.meas_ind.meas_rpt);

    break;


  default:

    WRRC_MSG1_HIGH("Message report of type %d not supported. Ignoring",cmd_ptr->cmd.meas_ind.meas_rpt->meas_type);

    break; /* Come out of switch */
  } /* End of switch */

  return;
}


/*===========================================================================

FUNCTION    RRCMEAS_PROCESS_DOWNLINK_L2_ACK

DESCRIPTION

 Processes ack received from layer2 of the meas report transmitted to UTRAN.

DEPENDENCIES

 None.

RETURN VALUE

 void

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_process_downlink_l2_ack
(
rrc_cmd_type *cmd_ptr
)
{
#ifdef FEATURE_AAGPS_MR_RRC_NOTIFICATION_REQUIRED

  if ((gps_l2_ack_params.waiting_for_l2_ack == TRUE) &&
      (cmd_ptr->cmd.downlink_l2ack_ind.status == SUCCESS) &&
      (gps_l2_ack_params.meas_id != INVALID_MEAS_ID) &&
      (gps_l2_ack_params.mui == cmd_ptr->cmd.downlink_l2ack_ind.mui))
  {
    WRRC_MSG0_HIGH("AGPS: Network rcvd AGPS Meas Rpt Success. Indicate LSM about report");

    rrc_lsm_meas_report_notification(gps_l2_ack_params.meas_id,
                                     TRUE);

    rrcgps_initialize_l2_ack_params();
  }
  else if ((gps_l2_ack_params.waiting_for_l2_ack == TRUE) &&
           (cmd_ptr->cmd.downlink_l2ack_ind.status == FAILURE) &&
           (gps_l2_ack_params.meas_id != INVALID_MEAS_ID) &&
           (gps_l2_ack_params.mui == cmd_ptr->cmd.downlink_l2ack_ind.mui))
  {
    WRRC_MSG0_HIGH("AGPS: Meas Rpt L2 ack not rcvd. Indicate LSM about report");

    rrc_lsm_meas_report_notification(gps_l2_ack_params.meas_id,
                                     FALSE);

    rrcgps_initialize_l2_ack_params();
  }
  else
  {
    MSG_LOW("Non-AGPS scenario",0,0,0);
  }

#endif
  /* Ack received for msg sent to UTRAN */
  /* decrement the pending meas rpt counter */
  if(rrcmeas_pending_rpt > 0)
  {
    rrcmeas_pending_rpt--;
  }
  
  if(rrcmeas_pending_rpt)
  {
    WRRC_MSG1_HIGH("meas rpt counter value = %d",rrcmeas_pending_rpt);
  }
  
  if ( cmd_ptr->cmd.downlink_l2ack_ind.status == SUCCESS )
  {
    WRRC_MSG0_HIGH("Meas Rpt txion SUCCESS");

    /* Good this is what we expected. */
  }
  else
  {
    WRRC_MSG0_HIGH("Transmission failed for Meas Report or MCF msg");
  } /* Else of txion failed for message sent */
}

/*===========================================================================

FUNCTION  RRCMEAS_FILL_RSCP_CELL_INFO

DESCRIPTION

 This function fills in Cell Info for a Non-HCS cell when
 Cell Selection Reselection Quality Measure is RSCP.
 The function processes Cell Info in ASN1 format and
 translates into the L1 RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill cell info correctly
 SUCCESS: If Cell Info is filled correctly

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_fill_rscp_cell_info
(
rrc_CellInfoSI_RSCP *sib_cell_info_ptr,
l1_cell_info_struct_type* l1_cell_info_ptr
,rrc_CellSelectReselectInfo_v590ext * rel5_ext_ptr
)
{
  rrc_SysInfoType3    *sib3_ptr = NULL;

  rrc_SysInfoType4    *sib4_ptr = NULL;

  boolean sib4_present = FALSE;


  sib3_ptr = (rrc_SysInfoType3 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB3);
  if( sib3_ptr == NULL )
  {
    WRRC_MSG0_ERROR("SIB3 ptr is NULL");
    return( FAILURE );
  }

  if ( sib_cell_info_ptr == NULL )
  {
    MSG_LOW("Cell info pointer is NULL", 0, 0, 0);
    return(FAILURE);
  }

  if (((rrcmeas_current_substate == RRCMEAS_CELL_FACH) || (rrcmeas_current_substate == RRCMEAS_PCH)) &&
    ((sib3_ptr->sib4indicator == TRUE)))
  {
    sib4_ptr = (rrc_SysInfoType4 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB4);

    if (sib4_ptr == NULL)
    {
      WRRC_MSG0_ERROR("SIB4 ptr NULL.Use SIB3");
    }
    else
    {
      WRRC_MSG0_HIGH("Use default values from SIB4");
      sib4_present = TRUE;
    }
  }

  /* Fill in Cell Individual Offset */
 
  l1_cell_info_ptr->cell_offset =
    sib_cell_info_ptr->cellIndividualOffset;
 

  /* Fill in Reference Time Difference to serving cell */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib_cell_info_ptr,
    rrc_CellInfoSI_RSCP,referenceTimeDifferenceToCell) )
  {
    /* Set reference time difference included to true */
    l1_cell_info_ptr->ref_tm_diff_incl = TRUE;

    if ( sib_cell_info_ptr->referenceTimeDifferenceToCell.t ==
      T_rrc_ReferenceTimeDifferenceToCell_accuracy40 )
    {
      /* L1 expects uint 16 */
      l1_cell_info_ptr->ref_tm_diff = (uint16) (sib_cell_info_ptr->referenceTimeDifferenceToCell.u.accuracy40 * REF_TIME_DIFF_ACCURACY_40);

      l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_40_CHIPS;
    }
    else if ( sib_cell_info_ptr->referenceTimeDifferenceToCell.t ==
      T_rrc_ReferenceTimeDifferenceToCell_accuracy256 )
    {
      l1_cell_info_ptr->ref_tm_diff = (uint16) (sib_cell_info_ptr->referenceTimeDifferenceToCell.u.accuracy256 * REF_TIME_DIFF_ACCURACY_256);
      l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_256_CHIPS;

    }
    else
    {
      l1_cell_info_ptr->ref_tm_diff = (uint16) (sib_cell_info_ptr->referenceTimeDifferenceToCell.u.accuracy2560 * REF_TIME_DIFF_ACCURACY_2560);
      l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_2560_CHIPS;
    }
  }
  else
  {
  /* Reference time difference to cell absent
    * Set reference time difference included to false */
    l1_cell_info_ptr->ref_tm_diff_incl = FALSE;

    l1_cell_info_ptr->ref_tm_diff = 0;
    l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_40_CHIPS;
  }

  /* Primary CPICH info absent */
  l1_cell_info_ptr->pri_scr_code_incl = FALSE;

  /* Primary CPICH TX power present It is an optional parameter */
  l1_cell_info_ptr->pri_cpich_txpwr_incl = FALSE;

  /* Read SFN indicator */
  l1_cell_info_ptr->rd_sfn_ind = FALSE;

  /* Read Tx Diversity indicator */
  l1_cell_info_ptr->tx_diver_ind = FALSE;


  /* Fill in Mode Specific Info */
  if ( sib_cell_info_ptr->modeSpecificInfo.t ==
    T_rrc_CellInfo_modeSpecificInfo_tdd)
  { /* Mode specific info is for TDD */
    MSG_LOW("Using default values for cell info",0,0,0);
  }
  else
  {
  /* Mode specific info is for FDD -First Fill in default values for
    * Pri CPICH Scrambling code and CPICH Tx Power */

    if (sib_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_InfoPresent)
    {
      /* Primary CPICH info present */
      l1_cell_info_ptr->pri_scr_code_incl = TRUE;

      l1_cell_info_ptr->pri_scr_code = (uint16)
        sib_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

    }
    else
    {
      WRRC_MSG0_HIGH("PSC absent ignoring");
      return(FAILURE);
    }

    if ( sib_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_TX_PowerPresent)
    {
      /* Primary CPICH TX power present It is an optional parameter */
      l1_cell_info_ptr->pri_cpich_txpwr_incl = TRUE;

      /* Set its value */
      l1_cell_info_ptr->pri_cpich_txpwr =
        sib_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_TX_Power;

    }

    /* Read SFN indicator */
    l1_cell_info_ptr->rd_sfn_ind =
      (boolean) sib_cell_info_ptr->modeSpecificInfo.u.fdd->readSFN_Indicator;

    /* Read Tx Diversity indicator */
    l1_cell_info_ptr->tx_diver_ind =
      (boolean) sib_cell_info_ptr->modeSpecificInfo.u.fdd->tx_DiversityIndicator;

  } /* End of else */

  /* Cell Select Reselect Info is present. If SIB's do not have values, default values
     have already been set */
  l1_cell_info_ptr->cell_sel_resel_info_incl = TRUE;

  /* Assign the default values for
     rrc_CellInfoSI_ECN0_cellSelectionReselectionInfo */
  l1_cell_info_ptr->cell_sel_info.qoffset1_s_n = QOFFSET1;

  l1_cell_info_ptr->cell_sel_info.qoffset2_s_n = QOFFSET2;

  /*l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = FALSE; */
  /* SIB4 ptr check done again to statisfy LINT */
  if ((sib4_present == TRUE) && (sib4_ptr != NULL))
  {
    if(RRC_CHECK_COMMON_MSG_TYPE(sib4_ptr->cellSelectReselectInfo.modeSpecificInfo,
       rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
    {
      l1_cell_info_ptr->cell_sel_info.max_tx_pwr = (int16)
        sib4_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power;

      l1_cell_info_ptr->cell_sel_info.qual_min  = (int16)
        sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin;

      l1_cell_info_ptr->cell_sel_info.rxlev_min = (int16)
        (sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1;
      /* Check for REL 5 extension ptr */
      if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) &&
        (sib4_ptr->m.v4b0NonCriticalExtensionsPresent) &&
        (sib4_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
        (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType4_v590ext.m.cellSelectReselectInfo_v590extPresent)
        && (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
        sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.m.deltaQrxlevminPresent))
      {
  
        /*   l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = TRUE;
           l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin = sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2; */
        MSG_HIGH("SIB4 Delta-Qrxlev=%d, Qrxlev=%d, PSC=%d",
          (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2),
          l1_cell_info_ptr->cell_sel_info.rxlev_min,
          l1_cell_info_ptr->pri_scr_code);
  
       /* if ((l1_cell_info_ptr->cell_sel_info.rxlev_min + (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2)) < -115)
        {*/
          l1_cell_info_ptr->cell_sel_info.rxlev_min += (int16) (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
           sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2);
       /* } */
      }
    }
    else
    {
      WRRC_MSG1_ERROR("ERR: SIB4 mode_choice NOT FDD %d", sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.t);
    }
  }
  else
  {
    l1_cell_info_ptr->cell_sel_info.max_tx_pwr = (int16)
      sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power;
    if(RRC_CHECK_COMMON_MSG_TYPE(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo,
       rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
    {
      l1_cell_info_ptr->cell_sel_info.qual_min  = (int16)
        sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin;
  
      l1_cell_info_ptr->cell_sel_info.rxlev_min = (int16)
        (sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1;
      /* Check for REL 5 extension ptr */
      if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) &&
        (sib3_ptr->m.v4b0NonCriticalExtensionsPresent) &&
        (sib3_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
        (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType3_v590ext.m.
        cellSelectReselectInfo_v590extPresent) && (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
        sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.m.deltaQrxlevminPresent))
      {

           /*l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = TRUE;
           l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin = sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2; */
        MSG_HIGH("SIB3 Delta-Qrxlev=%d, Qrxlev=%d, PSC=%d",
          (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2),
          l1_cell_info_ptr->cell_sel_info.rxlev_min,
          l1_cell_info_ptr->pri_scr_code);

        /*if ((l1_cell_info_ptr->cell_sel_info.rxlev_min + (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2)) < -115)
        {*/
          l1_cell_info_ptr->cell_sel_info.rxlev_min += (int16) (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
           sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2);
        /*}*/
      }
    }
    else
    {
      WRRC_MSG1_ERROR("ERR: SIB3 mode_choice NOT FDD %d", sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.t);
    }
  }

  /* Fill in cell select reselect info if present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib_cell_info_ptr,
    rrc_CellInfoSI_RSCP,cellSelectionReselectionInfo) )
  {

    
      /* Qoffset2 is applicable only when quality measure is EcN0 */
      l1_cell_info_ptr->cell_sel_info.qoffset1_s_n = (int16)
        sib_cell_info_ptr->cellSelectionReselectionInfo.q_OffsetS_N;
    

    /* Fill in Max Tx Power */
    if (RRC_MSG_COMMON_BITMASK_IE(sib_cell_info_ptr->cellSelectionReselectionInfo,
        rrc_CellSelectReselectInfoSIB_11_12_RSCP,maxAllowedUL_TX_Power) )
    {
      l1_cell_info_ptr->cell_sel_info.max_tx_pwr = (int16)
        sib_cell_info_ptr->cellSelectionReselectionInfo.maxAllowedUL_TX_Power;
    }

    /* Check if fdd present */
    if ( sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.t ==
      T_rrc_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_fdd )
    {
      /* Check if Qqualmin present */
      if ( RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.u.fdd,
           q_QualMin) )
      {
        /* Store Qqualmin in L1 */
        l1_cell_info_ptr->cell_sel_info.qual_min = (int16)
          sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.u.fdd->q_QualMin;
      }

      /* Check if Qrxlevmin present */
      if ( RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.u.fdd,q_RxlevMin) )
      {
        l1_cell_info_ptr->cell_sel_info.rxlev_min = (int16)
          (sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1;
      }
      if(rel5_ext_ptr != NULL)
      {
        if(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(rel5_ext_ptr,deltaQrxlevmin))
        {
          /*l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = TRUE;
          l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin =
            rel5_ext_ptr->value.deltaQrxlevmin * 2;        */
          MSG_HIGH("Delta-Qrxlev=%d, Qrxlev=%d, PSC=%d",
            (rel5_ext_ptr->deltaQrxlevmin * 2),
            l1_cell_info_ptr->cell_sel_info.rxlev_min,
            l1_cell_info_ptr->pri_scr_code);

          /*if ((l1_cell_info_ptr->cell_sel_info.rxlev_min + (rel5_ext_ptr->value.deltaQrxlevmin * 2)) < -115)
          {*/
            l1_cell_info_ptr->cell_sel_info.rxlev_min += (int16) (rel5_ext_ptr->deltaQrxlevmin * 2);
         /* }*/
        }
      }

    } /* End of if of fdd */

  } /* End of cell selection & reselection */

  return(SUCCESS);
}  /* rrcmeas_fill_no_hcs_rscp_cell_info  */



/*===========================================================================

FUNCTION   RRCMEAS_FILL_ECN0_CELL_INFO

DESCRIPTION

 This function fills in Cell Info for a Non-HCS cell when
 Cell Selection Reselection Quality Measure is ECN0.
 The function processes Cell Info in ASN1 format and
 translates into the L1 RRC Interface format.

DEPENDENCIES

 Pointer to rrc_CellInfoSI_ECN0 must be valid.

RETURN VALUE

 FAILURE: If passed pointer is NULL.
 SUCCESS: If able to analyze and fill Cell Info.

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_fill_ecn0_cell_info
(
rrc_CellInfoSI_ECN0 *sib_cell_info_ptr,
l1_cell_info_struct_type *l1_cell_info_ptr
,rrc_CellSelectReselectInfo_v590ext * rel5_ext_ptr
)
{
  rrc_SysInfoType3    *sib3_ptr = NULL;

  rrc_SysInfoType4    *sib4_ptr = NULL;

  boolean sib4_present = FALSE;

  sib3_ptr = (rrc_SysInfoType3 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB3);
  if( sib3_ptr == NULL )
  {
    WRRC_MSG0_ERROR("SIB3 ptr is NULL");
    return( FAILURE );
  }

  if ( sib_cell_info_ptr == NULL )
  {
    MSG_LOW("Cell Info ptr is NULL", 0, 0, 0);
    return(FAILURE);
  }
  /*l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = FALSE; */
  if (((rrcmeas_current_substate == RRCMEAS_CELL_FACH) || (rrcmeas_current_substate == RRCMEAS_PCH)) &&
    ((sib3_ptr->sib4indicator == TRUE)))
  {
    sib4_ptr = (rrc_SysInfoType4 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB4);

    if (sib4_ptr == NULL)
    {
      WRRC_MSG0_ERROR("SIB4 ptr NULL.Use SIB3");
    }
    else
    {
      WRRC_MSG0_HIGH("Use default values from SIB4");
      sib4_present = TRUE;
    }
  }


  l1_cell_info_ptr->cell_offset =
    sib_cell_info_ptr->cellIndividualOffset;

  

  /* Fill in Reference Time Difference to serving cell */
  if ( RRC_MSG_COMMON_BITMASK_IE_PTR(sib_cell_info_ptr,
    rrc_CellInfoSI_ECN0,referenceTimeDifferenceToCell) )
  {
    /* Set reference time difference included to true */
    l1_cell_info_ptr->ref_tm_diff_incl = TRUE;

    if ( sib_cell_info_ptr->referenceTimeDifferenceToCell.t ==
         T_rrc_ReferenceTimeDifferenceToCell_accuracy40 )
    {

      l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_40_CHIPS;

      l1_cell_info_ptr->ref_tm_diff = (uint16)
        (sib_cell_info_ptr->referenceTimeDifferenceToCell.u.accuracy40 * REF_TIME_DIFF_ACCURACY_40);

    }
    else if ( sib_cell_info_ptr->referenceTimeDifferenceToCell.t ==
         T_rrc_ReferenceTimeDifferenceToCell_accuracy256 )
    {

      l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_256_CHIPS;
      l1_cell_info_ptr->ref_tm_diff = (uint16)
        (sib_cell_info_ptr->referenceTimeDifferenceToCell.u.accuracy256 * REF_TIME_DIFF_ACCURACY_256) ;

    }
    else
    {

      l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_2560_CHIPS;
      l1_cell_info_ptr->ref_tm_diff = (uint16)
        (sib_cell_info_ptr->referenceTimeDifferenceToCell.u.accuracy2560 * REF_TIME_DIFF_ACCURACY_2560);
    }
  }
  else
  {
  /* Reference time difference to cell absent
    * Set reference time difference included to false */

    l1_cell_info_ptr->ref_tm_diff_incl = FALSE;

    l1_cell_info_ptr->ref_tm_diff = 0;
    l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_40_CHIPS;
  }

  /* Primary CPICH info absent */
  l1_cell_info_ptr->pri_scr_code_incl = FALSE;

  /* Primary CPICH TX power present It is an optional parameter */
  l1_cell_info_ptr->pri_cpich_txpwr_incl = FALSE;

  /* Read SFN indicator */
  l1_cell_info_ptr->rd_sfn_ind = FALSE;

  /* Read Tx Diversity indicator */
  l1_cell_info_ptr->tx_diver_ind = FALSE;

  /* Fill in Mode Specific Info */
  if ( sib_cell_info_ptr->modeSpecificInfo.t ==
    T_rrc_CellInfo_modeSpecificInfo_tdd)
  {
    MSG_LOW("Using default values",0,0,0);
  }
  else
  {
  /* Mode specific info is for FDD -First Fill in default values for
    * Pri CPICH Scrambling code and CPICH Tx Power */

    if (sib_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_InfoPresent)
    {

      /* Primary CPICH info present */
      l1_cell_info_ptr->pri_scr_code_incl = TRUE;

      l1_cell_info_ptr->pri_scr_code = (uint16)
        sib_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

    }
    else
    {
      WRRC_MSG0_HIGH("PSC absent ignoring");
      return(FAILURE);
    }

    if ( sib_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_TX_PowerPresent)
    {

      /* Primary CPICH TX power present It is an optional parameter */
      l1_cell_info_ptr->pri_cpich_txpwr_incl = TRUE;

      /* Set its value */
      l1_cell_info_ptr->pri_cpich_txpwr =
        sib_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_TX_Power;

    }

    /* Read SFN indicator */
    l1_cell_info_ptr->rd_sfn_ind =
      (boolean) sib_cell_info_ptr->modeSpecificInfo.u.fdd->readSFN_Indicator;

    /* Read Tx Diversity indicator */
    l1_cell_info_ptr->tx_diver_ind =
      (boolean) sib_cell_info_ptr->modeSpecificInfo.u.fdd->tx_DiversityIndicator;

  } /* End of else */

  /* Assign the default values for cell reselection */
  l1_cell_info_ptr->cell_sel_info.qoffset1_s_n = QOFFSET1;

  l1_cell_info_ptr->cell_sel_info.qoffset2_s_n = QOFFSET2;

  /* SIB4 Ptr check done again to satisfy LINT */
  if ((sib4_present == TRUE) && (sib4_ptr != NULL))
  {
    l1_cell_info_ptr->cell_sel_info.max_tx_pwr = (int16)
      sib4_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power;

    if(RRC_CHECK_COMMON_MSG_TYPE(sib4_ptr->cellSelectReselectInfo.modeSpecificInfo,
       rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
    {
      l1_cell_info_ptr->cell_sel_info.qual_min  = (int16)
        sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin;
  
      l1_cell_info_ptr->cell_sel_info.rxlev_min = (int16)
        (sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1;
      /* Check for REL 5 extension ptr */
      if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
        && (sib4_ptr->m.v4b0NonCriticalExtensionsPresent) &&
        (sib4_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
        (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType4_v590ext.m.
        cellSelectReselectInfo_v590extPresent) && (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
        sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.m.deltaQrxlevminPresent))
      {
  
          /* l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = TRUE;
           l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin = sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2; */
        MSG_HIGH("SIB4 Delta-Qrxlev=%d, Qrxlev=%d, PSC=%d",
          (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2),
          l1_cell_info_ptr->cell_sel_info.rxlev_min,
          l1_cell_info_ptr->pri_scr_code);

        /*if ((l1_cell_info_ptr->cell_sel_info.rxlev_min + (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2)) < -115)
        {*/
          l1_cell_info_ptr->cell_sel_info.rxlev_min += (int16) (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
           sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2);
        /*}*/
      }
    }
    else
    {
      WRRC_MSG1_ERROR("ERR: SIB4 mode_choice NOT FDD %d", sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.t);
    }
  }
  else
  {
    l1_cell_info_ptr->cell_sel_info.max_tx_pwr = (int16)
      sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power;

    if(RRC_CHECK_COMMON_MSG_TYPE(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo,
       rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
    {
      l1_cell_info_ptr->cell_sel_info.qual_min  = (int16)
        sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin;

      l1_cell_info_ptr->cell_sel_info.rxlev_min = (int16)
        (sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1;
      /* Check for REL 5 extension ptr */
      if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
        && (sib3_ptr->m.v4b0NonCriticalExtensionsPresent) &&
        (sib3_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
        (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType3_v590ext.m.
        cellSelectReselectInfo_v590extPresent) && (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
        sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.m.deltaQrxlevminPresent))
      {

           /*l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = TRUE;
           l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin = sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2; */
        MSG_HIGH("SIB3 Delta-Qrxlev=%d, Qrxlev=%d, PSC=%d",
          (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2),
          l1_cell_info_ptr->cell_sel_info.rxlev_min,
          l1_cell_info_ptr->pri_scr_code);

        /*if ((l1_cell_info_ptr->cell_sel_info.rxlev_min + (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2)) < -115)
        {*/
          l1_cell_info_ptr->cell_sel_info.rxlev_min += (int16) (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
           sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2);
        /*}*/
      }
    }
    else
    {
      WRRC_MSG1_ERROR("ERR: SIB3 mode_choice NOT FDD %d", sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.t);
    }

  }

    /* Cell Select Reselect Info is present. Even if it is not present in SIB's, L1
  requires the parameters set to default values */
  l1_cell_info_ptr->cell_sel_resel_info_incl = TRUE;

  /* Fill in cell select reselect info */
  if ( RRC_MSG_COMMON_BITMASK_IE_PTR(sib_cell_info_ptr,
    rrc_CellInfoSI_ECN0,cellSelectionReselectionInfo) )
  {
    /* Fill in Qoffset1_s_n */
    
      l1_cell_info_ptr->cell_sel_info.qoffset1_s_n = (int16)
        sib_cell_info_ptr->cellSelectionReselectionInfo.q_Offset1S_N;
    

    
      /* Qoffset2 is applicable when quality measure is EcN0 */
      l1_cell_info_ptr->cell_sel_info.qoffset2_s_n = (int16)
        sib_cell_info_ptr->cellSelectionReselectionInfo.q_Offset2S_N;
    

    /* Fill in Max Tx Power */
    if (RRC_MSG_COMMON_BITMASK_IE(sib_cell_info_ptr->cellSelectionReselectionInfo,
        rrc_CellSelectReselectInfoSIB_11_12_ECN0,maxAllowedUL_TX_Power) )
    {
      l1_cell_info_ptr->cell_sel_info.max_tx_pwr = (int16)
        sib_cell_info_ptr->cellSelectionReselectionInfo.maxAllowedUL_TX_Power;
    }


    /* Check if fdd present */
    if (RRC_CHECK_COMMON_MSG_TYPE(sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo,
      rrc_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_fdd ))
    {
      /* Check if Qqualmin present */

      if (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.u
        .fdd,q_QualMin) )
      {
        /* Store Qqualmin in L1 */
        l1_cell_info_ptr->cell_sel_info.qual_min = (int16)
          sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.
          u.fdd->q_QualMin;
      }

      /* Check if Qrxlevmin present */
      if (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.u
        .fdd,q_RxlevMin) )
      {
        l1_cell_info_ptr->cell_sel_info.rxlev_min = (int16)
          (sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.
          u.fdd->q_RxlevMin * 2) + 1;
      }
      if(rel5_ext_ptr != NULL)
      {
        if(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(rel5_ext_ptr,deltaQrxlevmin))
        {
          /*l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = TRUE;
          l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin =
            rel5_ext_ptr->value.deltaQrxlevmin * 2;        */
          MSG_HIGH("Delta-Qrxlev=%d, Qrxlev=%d, PSC=%d",
            (rel5_ext_ptr->deltaQrxlevmin * 2),
            l1_cell_info_ptr->cell_sel_info.rxlev_min,
            l1_cell_info_ptr->pri_scr_code);

          /*if ((l1_cell_info_ptr->cell_sel_info.rxlev_min + (rel5_ext_ptr->value.deltaQrxlevmin * 2)) < -115)
          {*/
            l1_cell_info_ptr->cell_sel_info.rxlev_min += (int16) (rel5_ext_ptr->deltaQrxlevmin * 2);
          /*}*/
        }
      }
    } /* End of if of fdd */

  }

  return(SUCCESS);

}  /* rrcmeas_fill_ecn0_cell_info  */



/*===========================================================================

FUNCTION     RRCMEAS_FILL_INTRA_FREQ_EVENT_CRITERIA

DESCRIPTION

 This function fills in intra-freq event criteria for a Non-HCS cell when
 Cell Selection Reselection Quality Measure is RCSP or ECNO.
 The function processes intra-ftreq event criteria Info in ASN1 format
 and translates into the L1 RRC Interface format.

DEPENDENCIES

 The passed pointers must be valid.

RETURN VALUE

 No of events.

SIDE EFFECTS

 None

===========================================================================*/

uint16 rrcmeas_fill_intra_freq_event_criteria
(
rrc_IntraFreqReportingCriteria  *rrc_intra_freq_reporting_criteria_ptr,
l1_intra_freq_event_crit_struct_type *l1_intra_freq_event_crit_ptr
, rrc_MeasurementControl_v590ext_IEs *rel5_ext_ptr
, rrc_SysInfoType11_v590ext_IEs *sib11_rel5_ext_ptr
, rrc_SysInfoType12_v590ext_IEs *sib12_rel5_ext_ptr
)
{
  /* To store cell list for 1a or 1b if present */
  rrc_ForbiddenAffectCellList *forbidden_affect_cell_list_ptr = NULL;
  uint32 index =0;
  /* Stores ptr to passed rrc_IntraFreqEventCriteriaList */
   rrc_IntraFreqEventCriteriaList  *rrc_intra_freq_event_criteria_list_ptr = NULL;

  /* Counts forbidden cell count */
  uint16 forbidden_cell_list_count = 0;

  /* To satisfy LINT as e1a, e1b values would be stored here first */
  l1_intra_freq_event_enum_type event_type;

  /* Counts no of events */
  uint16 event_count = 0;
  uint32 idx=0, cell_cnt =0;
  rrc_Intra_FreqEventCriteriaList_v590ext * event_1e_ptr = NULL;
  rrc_Intra_FreqEventCriteriaList_v590ext * event_1f_ptr = NULL;

  if((rel5_ext_ptr != NULL) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(
    rel5_ext_ptr,measurementCommand_v590ext))
   && (rel5_ext_ptr->measurementCommand_v590ext.t == 
   T_rrc_MeasurementControl_v590ext_IEs_measurementCommand_v590ext_intra_frequency))
  {
    event_1e_ptr = &rel5_ext_ptr->measurementCommand_v590ext.u.intra_frequency;
    event_1f_ptr = event_1e_ptr;
  }

  if((sib11_rel5_ext_ptr != NULL) && (RRC_MSG_COMMON_BITMASK_IE_PTR(
    sib11_rel5_ext_ptr,rrc_SysInfoType11_v590ext_IEs,intraFreqEventCriteriaList_v590ext)))
  {
    event_1e_ptr = &sib11_rel5_ext_ptr->intraFreqEventCriteriaList_v590ext;
    event_1f_ptr = event_1e_ptr;
  }

  if((sib12_rel5_ext_ptr != NULL) && (RRC_MSG_COMMON_BITMASK_IE_PTR(
    sib12_rel5_ext_ptr,
    rrc_SysInfoType12_v590ext_IEs,intraFreqEventCriteriaList_v590ext)))
  {
    event_1e_ptr = &sib12_rel5_ext_ptr->intraFreqEventCriteriaList_v590ext;
    event_1f_ptr = event_1e_ptr;
  }

  /* Store event crit list ptr */
  rrc_intra_freq_event_criteria_list_ptr = &rrc_intra_freq_reporting_criteria_ptr->eventCriteriaList;

  if ( rrc_intra_freq_event_criteria_list_ptr->n == 0 )
  {
    MSG_LOW("Intra-freq event criteria ptr is NULL", 0,0,0);
    return event_count;
  }

  index =0;

  /* ReportingRange, Hystersis, W converted by L1 */
  /* Store now the first event reporting criteria value from the list */
  while ( (rrc_intra_freq_event_criteria_list_ptr->n  > idx) &&
    (event_count < L1_INTRA_FREQ_MAX_NUM_EVENT) )
  {

    /* First get the event ID */
    switch ( rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.t )
    {
      case T_rrc_IntraFreqEvent_e1a:
        event_type = L1_INTRA_FREQ_EVENT_1A;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store triggering condition */

        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->
          triggeringCondition);

        /* Store Reporting Range */
        l1_intra_freq_event_crit_ptr[event_count].rpt_range = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingRange;

        /* Store no of cells forbidden to affect reporting range */
        if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a,
            rrc_Event1a,forbiddenAffectCellList) )
        {
          /* Now store the scrambling code for each cell */

          forbidden_affect_cell_list_ptr =
            &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->forbiddenAffectCellList;

          cell_cnt =0;
          while ( (forbidden_affect_cell_list_ptr->n > cell_cnt) &&
            (forbidden_cell_list_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is non-NULL and forbidden cell count hasn't exceeded
            * the maximum. So keep on counting */

            if ( forbidden_affect_cell_list_ptr->elem[cell_cnt].t ==
              T_rrc_ForbiddenAffectCell_tdd )
            {
              /* Set pointer value to next */
              cell_cnt++;

              continue;

            }
            else
            {
              /* Store scrambling code */
              l1_intra_freq_event_crit_ptr->forbidden_cell_scr_code[forbidden_cell_list_count] = (uint16)
                forbidden_affect_cell_list_ptr->elem[cell_cnt].u.fdd->primaryScramblingCode;

              /* Now increment count and store ptr to next value */
              forbidden_cell_list_count++;
              cell_cnt++;


              if ( (forbidden_cell_list_count == L1_MAX_CELL_MEAS) &&
                (forbidden_affect_cell_list_ptr->n > cell_cnt) )
              {

                MSG_LOW("Cannot include all forbidden cells", 0,0,0);
                break;
              }
            } /* End of else */

          } /* End of while of forbidden_affect_cell_list_ptr != NULL */

          /* Now store the number of forbidden affect cells in l1 struct */

          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = forbidden_cell_list_count;
        } /* End of if for forbidden_affect_cell_list actually present */

        else
        { /* forbidden_affect_cell_list actually absent */
          /* Set as per L1 req */
          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = 0;
        }

        /* Now store rest of the parameters of event 1a */

        /* Store WEIGHT */

        /* Use this to verify  rrc_intra_freq_event_criteria_list_ptr   */
        l1_intra_freq_event_crit_ptr[event_count].w = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->w;

        /* Store deactivation threshold */
        l1_intra_freq_event_crit_ptr[event_count].rpt_deact_thresh =
          RRCMEAS_RET_DEACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportDeactivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingInterval);

        MSG_HIGH("1A:RptAmt %d,RptIntvl %dms,Deacthresh %d",
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt,
                 l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
                 l1_intra_freq_event_crit_ptr[event_count].rpt_deact_thresh);


        break; /* Come out of switch and return SUCCESS */

      case T_rrc_IntraFreqEvent_e1b:
        event_type = L1_INTRA_FREQ_EVENT_1B;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store triggering condition 1 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_1(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->triggeringCondition);

        /* Store Reporting Range */
        l1_intra_freq_event_crit_ptr[event_count].rpt_range = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->reportingRange;


        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl = 0;
        l1_intra_freq_event_crit_ptr[event_count].num_rpt = 0;


        if (rel5_ext_ptr == NULL)
        {
          WRRC_MSG0_HIGH("Event 1B Ext absent in MCM");
        }
        else
        {
          if (RRC_MSG_COMMON_BITMASK_IE_PTR(rel5_ext_ptr,
            rrc_MeasurementControl_v590ext_IEs,intraFreqReportingCriteria_1b_r5))
          {
            WRRC_MSG0_HIGH("RRCHS:event1b extension present in MCM");

            /* Store reporting interval */
            l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
            RRCMEAS_RET_REPORTING_INTERVAL(
            rel5_ext_ptr->intraFreqReportingCriteria_1b_r5.periodicReportingInfo_1b.reportingInterval);

            l1_intra_freq_event_crit_ptr[event_count].num_rpt =
              RRCMEAS_RET_REPORTING_AMOUNT(rel5_ext_ptr->intraFreqReportingCriteria_1b_r5.
                                         periodicReportingInfo_1b.reportingAmount);
          }
        }

        if (sib11_rel5_ext_ptr == NULL)
        {
          WRRC_MSG0_HIGH("Event 1B Ext absent in SIB11");
        }
        else
        {
          if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib11_rel5_ext_ptr,
            rrc_SysInfoType11_v590ext_IEs,intraFreqReportingCriteria_1b_r5))
          {
            WRRC_MSG0_HIGH("RRCHS:event1b extension present in SIB11");

            /* Store reporting interval */
            l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
            RRCMEAS_RET_REPORTING_INTERVAL(
            sib11_rel5_ext_ptr->intraFreqReportingCriteria_1b_r5.periodicReportingInfo_1b.reportingInterval);

            l1_intra_freq_event_crit_ptr[event_count].num_rpt =
              RRCMEAS_RET_REPORTING_AMOUNT(sib11_rel5_ext_ptr->intraFreqReportingCriteria_1b_r5.
                                         periodicReportingInfo_1b.reportingAmount);
          }
        }

        if (sib12_rel5_ext_ptr == NULL)
        {
          WRRC_MSG0_HIGH("Event 1B Ext absent in SIB12");
        }
        else
        {
          if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib12_rel5_ext_ptr,
            rrc_SysInfoType12_v590ext_IEs,intraFreqReportingCriteria_1b_r5))
          {
            WRRC_MSG0_HIGH("RRCHS:event1b extension present in SIB12");

            /* Store reporting interval */
            l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
            RRCMEAS_RET_REPORTING_INTERVAL(
            sib12_rel5_ext_ptr->intraFreqReportingCriteria_1b_r5.periodicReportingInfo_1b.reportingInterval);

            l1_intra_freq_event_crit_ptr[event_count].num_rpt =
              RRCMEAS_RET_REPORTING_AMOUNT(sib12_rel5_ext_ptr->intraFreqReportingCriteria_1b_r5.
                                         periodicReportingInfo_1b.reportingAmount);
          }
        }

        WRRC_MSG2_HIGH("RRCHS:Event 1B RptIntvl %d ms, Num rpt %d",
                 l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt);



        if (RRC_MSG_COMMON_BITMASK_IE_PTR( rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b,
          rrc_Event1b,forbiddenAffectCellList) )
        {
          uint32 idy=0;
          /* Now store the scrambling code for each cell */

          forbidden_affect_cell_list_ptr =
            &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->
            forbiddenAffectCellList;


          while ( (forbidden_affect_cell_list_ptr->n > idy) &&
            (forbidden_cell_list_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is non-NULL and forbidden cell count hasn't exceeded
            the maximum. So keep on counting */

            if ( forbidden_affect_cell_list_ptr->elem[idy].t ==
              T_rrc_ForbiddenAffectCell_tdd )
            {
              idy++;
              continue;

            }
            else
            {
              /* Store scrambling code */
              l1_intra_freq_event_crit_ptr[event_count].
                forbidden_cell_scr_code[forbidden_cell_list_count] = (uint16)
                forbidden_affect_cell_list_ptr->elem[idy].u.fdd->primaryScramblingCode;

              /* Now increment count and store ptr to next value */
              forbidden_cell_list_count++;

              idy++;

              if ( (forbidden_cell_list_count == L1_MAX_CELL_MEAS) &&
                (forbidden_affect_cell_list_ptr->n > idy) )
              {

                MSG_LOW("Cannot include all the forbidden cells", 0,0,0);
                break;
              }
            } /* End of else */

          } /* End of while of forbidden_affect_cell_list_ptr != NULL */

          /* Now store the number of forbidden affect cells in l1 struct */

          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
            forbidden_cell_list_count;
        } /* End of if for forbidden_affect_cell_list actually present */

        else
        { /* forbidden_affect_cell_list actually absent */
          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = 0;
        }

        /* Store WEIGHT */

        l1_intra_freq_event_crit_ptr[event_count].w = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->w;

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_e1c:
        event_type = L1_INTRA_FREQ_EVENT_1C;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store replacement activation threshold */

        l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh =
          RRCMEAS_RET_REPLACEMENT_ACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          replacementActivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          reportingInterval);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;

        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        MSG_HIGH("1C:RptAmt %d,RptIntvl %dms,Deacthresh %d",
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt,
                 l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
                 l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh);



        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_e1d:
        event_type = L1_INTRA_FREQ_EVENT_1D;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;


        l1_intra_freq_event_crit_ptr[event_count].evt_1d_trig_cond_incl = FALSE;

        l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl = FALSE;

        if (rel5_ext_ptr == NULL)
        {
          WRRC_MSG0_HIGH("Event 1D Ext absent in MCM");

        }
        else
        {
          if (RRC_MSG_COMMON_BITMASK_IE_PTR(rel5_ext_ptr,
            rrc_MeasurementControl_v590ext_IEs,intraFreqEvent_1d_r5))
          {
            WRRC_MSG0_HIGH("RRCHS:event1d extension present in MCM");
            if (RRC_MSG_COMMON_BITMASK_IE_TYPE2(rel5_ext_ptr->intraFreqEvent_1d_r5,triggeringCondition))
            {
              l1_intra_freq_event_crit_ptr[event_count].evt_1d_trig_cond_incl = TRUE;

              l1_intra_freq_event_crit_ptr[event_count].trig_cond =
              (l1_meas_event_trigger_enum_type)
              RRCMEAS_RET_TRIGGERING_CONDITION_2(rel5_ext_ptr->intraFreqEvent_1d_r5.
                                                 triggeringCondition);

              WRRC_MSG1_HIGH("RRCHS:Event 1D trig cond 0:ASET/1:MSET %d",
                       l1_intra_freq_event_crit_ptr[event_count].trig_cond);

            }
            if ((RRC_MSG_COMMON_BITMASK_IE_TYPE2(rel5_ext_ptr->intraFreqEvent_1d_r5,useCIO))
              && (rel5_ext_ptr->intraFreqEvent_1d_r5.useCIO == TRUE))
            {
              l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl = TRUE;

              WRRC_MSG0_HIGH("RRCHS:Event 1D CIO TRUE");
            }
          }
        }

        if (sib11_rel5_ext_ptr == NULL)
        {
          WRRC_MSG0_HIGH("Event 1D Ext absent in SIB11");

        }
        else
        {
          if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib11_rel5_ext_ptr,rrc_SysInfoType11_v590ext_IEs,intraFreqEvent_1d_r5))
          {
            WRRC_MSG0_HIGH("RRCHS:event1d extension present in SIB11");
            if (RRC_MSG_COMMON_BITMASK_IE_TYPE2(
                sib11_rel5_ext_ptr->intraFreqEvent_1d_r5,triggeringCondition))
            {
              l1_intra_freq_event_crit_ptr[event_count].evt_1d_trig_cond_incl = TRUE;

              l1_intra_freq_event_crit_ptr[event_count].trig_cond =
              (l1_meas_event_trigger_enum_type)
              RRCMEAS_RET_TRIGGERING_CONDITION_2(sib11_rel5_ext_ptr->intraFreqEvent_1d_r5.
                                                 triggeringCondition);

              WRRC_MSG1_HIGH("RRCHS:Event 1D trig cond 0:ASET/1:MSET %d",
                       l1_intra_freq_event_crit_ptr[event_count].trig_cond);

            }
            if ((RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib11_rel5_ext_ptr->intraFreqEvent_1d_r5,useCIO))
              && (sib11_rel5_ext_ptr->intraFreqEvent_1d_r5.useCIO == TRUE))
            {
              l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl = TRUE;

              WRRC_MSG0_HIGH("RRCHS:Event 1D CIO TRUE");
            }
          }
        }

        if (sib12_rel5_ext_ptr == NULL)
        {
          WRRC_MSG0_HIGH("Event 1D Ext absent in SIB12");

        }
        else
        {
          if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib12_rel5_ext_ptr,
            rrc_SysInfoType12_v590ext_IEs,intraFreqEvent_1d_r5))
          {
            WRRC_MSG0_HIGH("RRCHS:event1d extension present in SIB12");
            if (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib12_rel5_ext_ptr->intraFreqEvent_1d_r5,
                triggeringCondition))
            {
              l1_intra_freq_event_crit_ptr[event_count].evt_1d_trig_cond_incl = TRUE;

              l1_intra_freq_event_crit_ptr[event_count].trig_cond =
              (l1_meas_event_trigger_enum_type)
              RRCMEAS_RET_TRIGGERING_CONDITION_2(sib12_rel5_ext_ptr->intraFreqEvent_1d_r5.
                                                 triggeringCondition);

              WRRC_MSG1_HIGH("RRCHS:Event 1D trig cond 0:ASET/1:MSET %d",
                       l1_intra_freq_event_crit_ptr[event_count].trig_cond);

            }
            if ((RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib12_rel5_ext_ptr->intraFreqEvent_1d_r5,useCIO))
              && (sib12_rel5_ext_ptr->intraFreqEvent_1d_r5.useCIO == TRUE))
            {
              l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl = TRUE;

              WRRC_MSG0_HIGH("RRCHS:Event 1D CIO TRUE");
            }
          }
        }


        break; /* Come out of switch and return SUCCESS */

      case T_rrc_IntraFreqEvent_e1e:
        event_type = L1_INTRA_FREQ_EVENT_1E;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store the threshold used frequency */
        l1_intra_freq_event_crit_ptr[event_count].freq_thresh = (int16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1e->thresholdUsedFrequency;

        /* Store triggering condition 2 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1e->
          triggeringCondition);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;


      // l1_intra_freq_event_crit_ptr[event_count].delta_rscp) = FALSE;
        if((NULL != event_1e_ptr) && (event_1e_ptr->n > index))
        {
        /*  l1_intra_freq_event_crit_ptr[event_count].delta_rscp) = TRUE;
          l1_intra_freq_event_crit_ptr[event_count].delta_rscp =
            (int16) event_1e_ptr->value; */
          l1_intra_freq_event_crit_ptr[event_count].freq_thresh += (int16) event_1e_ptr->elem[index];
          index++;
        }

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_e1f:
        event_type = L1_INTRA_FREQ_EVENT_1F;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store the threshold used frequency */
        l1_intra_freq_event_crit_ptr[event_count].freq_thresh = (int16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.
          e1f->thresholdUsedFrequency;

        /* Store triggering condition 1 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_1(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1f->
          triggeringCondition);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

       //l1_intra_freq_event_crit_ptr[event_count].delta_rscp) = FALSE;

        if((NULL != event_1f_ptr) && (event_1f_ptr->n > index))
        {
          /*l1_intra_freq_event_crit_ptr[event_count].delta_rscp) = TRUE;
          l1_intra_freq_event_crit_ptr[event_count].delta_rscp =
            (int16) event_1f_ptr->value; */
          l1_intra_freq_event_crit_ptr[event_count].freq_thresh += (int16) event_1f_ptr->elem[index];
          index++;
        }

        break; /* Come out of switch  */


      default:
        WRRC_MSG0_HIGH("Invalid event type");
    } /* End of switch */

    /* Now store hsyterisis */
    l1_intra_freq_event_crit_ptr[event_count].hyst = (uint16)
      rrc_intra_freq_event_criteria_list_ptr->elem[idx].hysteresis;

    /* Now store timeToTrigger */

    l1_intra_freq_event_crit_ptr[event_count].time_to_trig =
      RRCMEAS_RET_TIME_TO_TRIGGER(rrc_intra_freq_event_criteria_list_ptr->elem[idx].timeToTrigger);

    /* Now store reporting cell status which is optional */
    /* Initialize Cell status information to FALSE */
    l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status_incl = FALSE;


    if (RRC_MSG_LIST_BITMASK_IE(rrc_intra_freq_event_criteria_list_ptr,
      rrc_IntraFreqEventCriteria,reportingCellStatus) )
    {
      MSG_LOW("Reporting cell status present", 0,0,0);

      /* Call a function which stores all the information. */
      if ( rrcmeas_fill_no_of_reporting_cells(
        & rrc_intra_freq_event_criteria_list_ptr->elem[idx].reportingCellStatus,
        & l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status) == SUCCESS )
      {
        l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status_incl = TRUE;
      }
    } /* End of rrc_IntraFreqEventCriteria_reportingCellStatus_present present */


    /* Now increment the event count and the ptr to next value */
    event_count++;
    idx++;
    if ( (event_count == L1_INTRA_FREQ_MAX_NUM_EVENT) &&
      (rrc_intra_freq_event_criteria_list_ptr->n > idx) )
    {
      break; /* Come out of while */
    }

  } /* End of while intra_freq_event_criteria_list_ptr != NULL */

  return event_count;


} /* End of function */


/*===========================================================================

FUNCTION      RRCMEAS_FILL_NO_OF_REPORTING_CELLS

DESCRIPTION

 This function fills no of reporting cells for a Non-HCS cell
 for an event triggered criteria for RCSP or ECNO.
 The function processes this Info in ASN1 format and
 translates into the L1 RRC Interface format.

DEPENDENCIES

 None.

RETURN VALUE

 FAILURE: If unable to fill no of reporting cells correctly
 SUCCESS: If no of reporting cells filled correctly

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_fill_no_of_reporting_cells
(
rrc_ReportingCellStatus  *rrc_rpt_cell_status_ptr,
l1_meas_rpt_cell_status_struct_type  *l1_rpt_cell_status_ptr
)
{
  if ( rrc_rpt_cell_status_ptr == NULL )
  {
    return FAILURE;
  }
  switch ( rrc_rpt_cell_status_ptr->t )
  {
  case T_rrc_ReportingCellStatus_withinActiveSet:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE1;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_ASET;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.withinActiveSet;
    break;
  case T_rrc_ReportingCellStatus_withinMonitoredSetUsedFreq:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE1;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_MSET_USED_FREQ;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.withinMonitoredSetUsedFreq;
    break;
  case T_rrc_ReportingCellStatus_withinActiveAndOrMonitoredUsedFreq:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE1;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_ASET_MSET_USED_FREQ;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.withinActiveAndOrMonitoredUsedFreq;
    break;
  case T_rrc_ReportingCellStatus_withinDetectedSetUsedFreq:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE1;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_DSET_USED_FREQ;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.withinDetectedSetUsedFreq;
    break;
  case T_rrc_ReportingCellStatus_withinMonitoredAndOrDetectedUsedFreq:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE1;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_MSET_DSET_USED_FREQ;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.withinMonitoredAndOrDetectedUsedFreq;
    break;
  case T_rrc_ReportingCellStatus_allActiveplusMonitoredSet:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE3;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_ALL_ASET_MSET_USED_FREQ;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.allActiveplusMonitoredSet;
    break;
  case T_rrc_ReportingCellStatus_allActivePlusDetectedSet:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE3;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_ALL_ASET_DSET_USED_FREQ;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.allActivePlusDetectedSet;
    break;
  case T_rrc_ReportingCellStatus_allActivePlusMonitoredAndOrDetectedSet:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE3;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_ALL_ASET_MSET_DSET_USED_FREQ;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.allActivePlusMonitoredAndOrDetectedSet;
    break;
  case T_rrc_ReportingCellStatus_withinVirtualActSet:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE1;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_VASET;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.withinVirtualActSet;
    break;
  case T_rrc_ReportingCellStatus_withinMonitoredSetNonUsedFreq:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE1;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_MSET_NUSED_FREQ;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.withinMonitoredSetNonUsedFreq;
    break;
  case  T_rrc_ReportingCellStatus_withinMonitoredAndOrVirtualActiveSetNonUsedFreq:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE1;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_ASET_MSET_NUSED_FREQ;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.withinMonitoredAndOrVirtualActiveSetNonUsedFreq;
    break;
  case T_rrc_ReportingCellStatus_allVirtualActSetplusMonitoredSetNonUsedFreq:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE3;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_ALL_VASET_AND_MSET_NUSED_FREQ;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.allVirtualActSetplusMonitoredSetNonUsedFreq;
    break;
  case  T_rrc_ReportingCellStatus_withinActSetOrVirtualActSet_InterRATcells:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE2;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_ASET_AND_VASET;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.withinActSetOrVirtualActSet_InterRATcells;
    break;
  case T_rrc_ReportingCellStatus_withinActSetAndOrMonitoredUsedFreqOrVirtualActSetAndOrMonitoredNonUsedFreq:
    l1_rpt_cell_status_ptr->rpt_cell_type = L1_CELL_REPORTING_TYPE2;
    l1_rpt_cell_status_ptr->rpt_cell_stat = L1_RPT_ASET_AND_MSET_USED_NUSED;
    l1_rpt_cell_status_ptr->max_num_rpt_cells = (uint16) rrc_rpt_cell_status_ptr->u.withinActSetAndOrMonitoredUsedFreqOrVirtualActSetAndOrMonitoredNonUsedFreq;
    break;
  default:
    return FAILURE;
  } /* End of switch */
  /* Incrementing no of reporting cells by 1 */
  l1_rpt_cell_status_ptr->max_num_rpt_cells = l1_rpt_cell_status_ptr->max_num_rpt_cells + 1;


  return SUCCESS;
} /*End of function */



/*===========================================================================

FUNCTION          RRCMEAS_FILL_DCH_STATE_INFO

DESCRIPTION

 This function fills DCH state info for a Non-HCS cell
 for RCSP/ECNO. The function processes this Info in ASN1 format
 and translates into the L1 RRC Interface format.

DEPENDENCIES

 None.

RETURN VALUE

 Success if DCH state info filled correctly
 Failure if unable to fill DCH state info incorrectly

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_fill_dch_state_info
(
rrc_ReportingInfoForCellDCH* rrc_reporting_info_for_cell_dch_ptr,
l1_intra_freq_dch_rpt_info_struct_type* l1_dch_rpt_info_ptr
, rrc_SysInfoType11_v590ext_IEs *sib11_rel5_ext_ptr
, rrc_SysInfoType12_v590ext_IEs *sib12_rel5_ext_ptr
)
{

  if ( rrc_reporting_info_for_cell_dch_ptr == NULL )
  {
    WRRC_MSG0_HIGH("DCH reporting ptr is NULL");
    return FAILURE;
  }

  /* Check for active set, if any reporting quantity is set for FDD */

  if (RRC_CHECK_COMMON_MSG_TYPE(rrc_reporting_info_for_cell_dch_ptr->
    intraFreqReportingQuantity.activeSetReportingQuantities.
    modeSpecificInfo,
    rrc_CellReportingQuantities_modeSpecificInfo_fdd ))
  {
    /* First store active set info */

    /* Store SFN-SFN time difference for active set */

    l1_dch_rpt_info_ptr->aset_quan.sfn_rpt = (l1_sfn_report_enum_type)
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.activeSetReportingQuantities.
      dummy;

    /* Store CFN-SFN time difference for active set */

    l1_dch_rpt_info_ptr->aset_quan.cfn_sfn_delta_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.activeSetReportingQuantities.
      cellSynchronisationInfoReportingIndicator;


    /* Store Cell identity reporting indicator for active set */

    l1_dch_rpt_info_ptr->aset_quan.cell_id_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.activeSetReportingQuantities.
      cellIdentity_reportingIndicator;


    /* Store ec/no  reporting indicator */
    l1_dch_rpt_info_ptr->aset_quan.ec_no_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.activeSetReportingQuantities.
      modeSpecificInfo.u.fdd->cpich_Ec_N0_reportingIndicator;



    /* Store rscp reporting indicator */
    l1_dch_rpt_info_ptr->aset_quan.rscp_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.activeSetReportingQuantities.
      modeSpecificInfo.u.fdd->cpich_RSCP_reportingIndicator;



    /* Store the path loss reporting indicator */
    l1_dch_rpt_info_ptr->aset_quan.pathloss_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.activeSetReportingQuantities.
      modeSpecificInfo.u.fdd->pathloss_reportingIndicator;
  }
  else
  { /* TDD mode mentioned */
    WRRC_MSG0_HIGH("For Active set, TDD quantities reported");
    l1_dch_rpt_info_ptr->aset_quan.cell_id_rpt = FALSE;
    l1_dch_rpt_info_ptr->aset_quan.cfn_sfn_delta_rpt = FALSE;
    l1_dch_rpt_info_ptr->aset_quan.ec_no_rpt = FALSE;
    l1_dch_rpt_info_ptr->aset_quan.pathloss_rpt = FALSE;
    l1_dch_rpt_info_ptr->aset_quan.rscp_rpt = FALSE;
    l1_dch_rpt_info_ptr->aset_quan.sfn_rpt = L1_NO_REPORT;
  }

  /* Now set information for monitored set */


  if (RRC_CHECK_COMMON_MSG_TYPE(rrc_reporting_info_for_cell_dch_ptr->
    intraFreqReportingQuantity.monitoredSetReportingQuantities.
    modeSpecificInfo,
    rrc_CellReportingQuantities_modeSpecificInfo_fdd ))
  {

    /* Store SFN-SFN time difference for monitored set */

    l1_dch_rpt_info_ptr->mset_quan.sfn_rpt = (l1_sfn_report_enum_type)
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.monitoredSetReportingQuantities.
      dummy;

    /* Store CFN-SFN time difference for monitored set */

    l1_dch_rpt_info_ptr->mset_quan.cfn_sfn_delta_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.monitoredSetReportingQuantities.
      cellSynchronisationInfoReportingIndicator;


    /* Store Cell identity reporting indicator for monitored set */

    l1_dch_rpt_info_ptr->mset_quan.cell_id_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.monitoredSetReportingQuantities.
      cellIdentity_reportingIndicator;

      /* Check for monitored set, if any reporting quantity is set
    for FDD */

    /* Store ec/no  reporting indicator */
    l1_dch_rpt_info_ptr->mset_quan.ec_no_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.monitoredSetReportingQuantities.
      modeSpecificInfo.u.fdd->cpich_Ec_N0_reportingIndicator;


    /* Store rscp reporting indicator */
    l1_dch_rpt_info_ptr->mset_quan.rscp_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.monitoredSetReportingQuantities.
      modeSpecificInfo.u.fdd->cpich_RSCP_reportingIndicator;

    /* Store the path loss reporting indicator */
    l1_dch_rpt_info_ptr->mset_quan.pathloss_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.monitoredSetReportingQuantities.
      modeSpecificInfo.u.fdd->pathloss_reportingIndicator;

  }
  else
  {  /* TDD mode mentioned */
    WRRC_MSG0_HIGH("For Monitored set, TDD quantities reported");

    l1_dch_rpt_info_ptr->mset_quan.cell_id_rpt = FALSE;
    l1_dch_rpt_info_ptr->mset_quan.cfn_sfn_delta_rpt = FALSE;
    l1_dch_rpt_info_ptr->mset_quan.ec_no_rpt = FALSE;
    l1_dch_rpt_info_ptr->mset_quan.pathloss_rpt = FALSE;
    l1_dch_rpt_info_ptr->mset_quan.rscp_rpt = FALSE;
    l1_dch_rpt_info_ptr->mset_quan.sfn_rpt = L1_NO_REPORT;

  }

  /* Now store reporting parameters for detected cells */


  /* First check if detected cells reporting present for DCH */
  if ( (RRC_MSG_COMMON_BITMASK_IE_TYPE2(rrc_reporting_info_for_cell_dch_ptr->
    intraFreqReportingQuantity,detectedSetReportingQuantities)) &&
    (RRC_CHECK_COMMON_MSG_TYPE(rrc_reporting_info_for_cell_dch_ptr->
    intraFreqReportingQuantity.detectedSetReportingQuantities.
    modeSpecificInfo,
    rrc_CellReportingQuantities_modeSpecificInfo_fdd ) ))
  {


    /* Detected cells criteria is present. Now process further */
    l1_dch_rpt_info_ptr->dset_quan_incl = TRUE;

    /* Now set information for detected set */

    /* Store SFN-SFN time difference for detected set */

    l1_dch_rpt_info_ptr->dset_quan.sfn_rpt = (l1_sfn_report_enum_type)
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.detectedSetReportingQuantities.
      dummy;

    /* Store CFN-SFN time difference for detected set */

    l1_dch_rpt_info_ptr->dset_quan.cfn_sfn_delta_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.detectedSetReportingQuantities.
      cellSynchronisationInfoReportingIndicator;


    /* Store Cell identity reporting indicator for detected set */

    l1_dch_rpt_info_ptr->dset_quan.cell_id_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.detectedSetReportingQuantities.
      cellIdentity_reportingIndicator;

    /* Check for detected set, if any reporting quantity is set for FDD */

    /* Store ecno reporting indicator */
    l1_dch_rpt_info_ptr->dset_quan.ec_no_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.detectedSetReportingQuantities.
      modeSpecificInfo.u.fdd->cpich_Ec_N0_reportingIndicator;


    /* Store rscp reporting indicator */
    l1_dch_rpt_info_ptr->dset_quan.rscp_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.detectedSetReportingQuantities.
      modeSpecificInfo.u.fdd->cpich_RSCP_reportingIndicator;



    /* Store the path loss reporting indicator */
    l1_dch_rpt_info_ptr->dset_quan.pathloss_rpt =
      rrc_reporting_info_for_cell_dch_ptr->
      intraFreqReportingQuantity.detectedSetReportingQuantities.
      modeSpecificInfo.u.fdd->pathloss_reportingIndicator;


  }  /* End of if detected cells present */

  else
  {
    /* Detected cells criteria is present. Now process further */
    l1_dch_rpt_info_ptr->dset_quan_incl = FALSE;
  }

  /* Periodic or Event Triggered */

  l1_dch_rpt_info_ptr->rpt_mode = RRCMEAS_RET_MEAS_REPORTING_MODE(
    rrc_reporting_info_for_cell_dch_ptr->measurementReportingMode.periodicalOrEventTrigger);

  /* For event reporting criteria for EVENT ... */

  switch ( rrc_reporting_info_for_cell_dch_ptr->reportCriteria.t )
  {

  case T_rrc_CellDCH_ReportCriteria_intraFreqReportingCriteria:

    /* Event triggered intraFreqReportingCriteria list present. Check if list present */

    if ( RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_reporting_info_for_cell_dch_ptr->reportCriteria.u.
      intraFreqReportingCriteria,
      rrc_IntraFreqReportingCriteria,eventCriteriaList))
    {

      WRRC_MSG0_HIGH("IntraF: Event Reporting specified");

      /* Now store the event reporting criteria list */

      /* Set event parameters */
      l1_dch_rpt_info_ptr->rpt_crit.num_event =
        rrcmeas_fill_intra_freq_event_criteria(
        rrc_reporting_info_for_cell_dch_ptr->reportCriteria.u.intraFreqReportingCriteria,
        l1_dch_rpt_info_ptr->rpt_crit.evt, NULL, sib11_rel5_ext_ptr, sib12_rel5_ext_ptr);


    } /* End of if for event criteria list not present */
    else
    {
      /* Set num_event to 0 */
      l1_dch_rpt_info_ptr->rpt_crit.num_event = 0;
    }

    break; /* Come out of switch */

    /* End of case for rrc_CellDCH_ReportCriteria_intraFreqReportingCriteria */

  case T_rrc_CellDCH_ReportCriteria_periodicalReportingCriteria:

    WRRC_MSG0_HIGH("IntraF: Periodic Reporting specified");

  
      /* Store reporting amount */
      l1_dch_rpt_info_ptr->num_rpt =
        RRCMEAS_RET_REPORTING_AMOUNT
        (rrc_reporting_info_for_cell_dch_ptr->reportCriteria.
        u.periodicalReportingCriteria->reportingAmount);

   /* End of else */

    if (rrc_reporting_info_for_cell_dch_ptr->reportCriteria.
      u.periodicalReportingCriteria->reportingInterval == rrc_ReportingIntervalLong_ril0)
    {
      WRRC_MSG0_ERROR("Periodic Intvl 0, Use 250ms");
      l1_dch_rpt_info_ptr->rpt_intvl = 250;
    }
    else
    {
      /* Store Reporting Interval */
      l1_dch_rpt_info_ptr->rpt_intvl =
        RRCMEAS_RET_PERIODIC_REPORTING_INTERVAL
        (rrc_reporting_info_for_cell_dch_ptr->reportCriteria.
        u.periodicalReportingCriteria->reportingInterval);
    }

    break; /* Come out of switch */

    /* End of case */


  default:
    break;
  } /* End of switch */

  return SUCCESS;
}

/*===========================================================================

FUNCTION     RRCMEAS_PROCESS_REMOVED_INTRA_FREQ_CELLS

DESCRIPTION

 This function fills the removed intra-freq cells for HCS Non-HCS cells
 for RSCP and ECN0. The function processes this Info in ASN1 format and
 translates into the L1 RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill removed intra freq cell info correctly
 SUCCESS: If removed intra freq cell info filled correctly

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_process_removed_intra_freq_cells
(
rrc_RemovedIntraFreqCellList *removed_intra_freq_cell_list_ptr,
l1_intra_freq_cell_list_struct_type *l1_intra_freq_cell_ptr
)
{
  uint16 removed_cell_count = 0;
  uint32 idx=0;
  /* To store the temp pointer which reads element from the rrc__seqof3 list */
  rrc_RemovedIntraFreqCellList tmp_RemovedIntraFreqCellList;

  /* Intra Freq Cell Id */
  uint32 intra_freq_cell_id = 0;
  l1_intra_freq_cell_ptr->num_cell_rmv = 0;

  /* initialize the tmp list to satisfy lint */
  RRC_SET_COMMON_MSG_TYPE2(tmp_RemovedIntraFreqCellList,
  rrc_RemovedIntraFreqCellList,removeNoIntraFreqCells);

  if ( removed_intra_freq_cell_list_ptr == NULL )
  {
    WRRC_MSG0_HIGH("Intra-freq cells pointer is NULL");
    return FAILURE;
  }

  switch ( removed_intra_freq_cell_list_ptr->t )
  {
  case T_rrc_RemovedIntraFreqCellList_removeAllIntraFreqCells:

      /* Remove all cells in intra-freq-cell-list */
      WRRC_MSG0_HIGH("Removing all the intra freq cells from cell list");
    l1_intra_freq_cell_ptr->num_cell_rmv = MAX_NO_OF_CELLS;
      rrcmeas_initialize_cell_list();
    break;

  case T_rrc_RemovedIntraFreqCellList_removeSomeIntraFreqCells:

    if ( removed_intra_freq_cell_list_ptr->u.removeSomeIntraFreqCells== NULL )
    {
        MSG_LOW("Assign no of removed cells to be 0", 0,0,0);
        break;
    }
    tmp_RemovedIntraFreqCellList.u.removeSomeIntraFreqCells =
      removed_intra_freq_cell_list_ptr->u.removeSomeIntraFreqCells;
    do
    {
      intra_freq_cell_id =  tmp_RemovedIntraFreqCellList.u.removeSomeIntraFreqCells->elem[idx];

        /* Remove cell at position given by intra_freq_cell_list_rscp_ptr->removedIntraFreqCellList.u.
        removeSomeIntraFreqCells->value in intra_freq_cell_list */
        rrcmeas_remove_cellid
           (
              PRI_FREQ,
           &intra_freq_cell_id);

      removed_cell_count++; /* Increment count */
        WRRC_MSG1_HIGH("removed cell id %d from intra freq cell list", intra_freq_cell_id);
      /*  Get next element in the list */

      idx++;

    } /* Continue if cond satisfied */

    while (( tmp_RemovedIntraFreqCellList.u.removeSomeIntraFreqCells->n > idx) &&
      (removed_cell_count < L1_MAX_CELL_MEAS) );
    l1_intra_freq_cell_ptr->num_cell_rmv =  removed_cell_count;
    break;

  case T_rrc_RemovedIntraFreqCellList_removeNoIntraFreqCells: /* dont remove any cells */
      WRRC_MSG0_HIGH("removed 0 cells from intra freq cell list");
      break;

  default:
    WRRC_MSG0_ERROR("Invalid cell t");
    break;
  } /* End of switch */

  return SUCCESS;
}

/*===========================================================================

FUNCTION    RRCMEAS_SET_INTRA_FREQ_EVENT_ID

DESCRIPTION

 Sets the event id in measurement report from L1 format to ASN1 format

DEPENDENCIES

 None.

RETURN VALUE

 FAILURE if event no is incorrect
 SUCCESS if event no is correct

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_set_intra_freq_event_id
(
uint16 event_id,
rrc_EventIDIntraFreq* rrcmeas_intra_freq_event_id_ptr
)
{
  /* Only 1 event is sent to UTRAN. So if L1 sends more than 1 event, neglect it*/

  WRRC_MSG1_HIGH("EVENT %d reported",event_id);

  /* Find type of event and set it */
  switch ( event_id )
  {
  case 0:
    *rrcmeas_intra_freq_event_id_ptr = rrc_EventIDIntraFreq_e1a;
    break;

  case 1:
    *rrcmeas_intra_freq_event_id_ptr = rrc_EventIDIntraFreq_e1b;
    break;

  case 2:
    *rrcmeas_intra_freq_event_id_ptr = rrc_EventIDIntraFreq_e1c;
    break;

  case 3:
    *rrcmeas_intra_freq_event_id_ptr = rrc_EventIDIntraFreq_e1d;
    break;

  case 4:
    *rrcmeas_intra_freq_event_id_ptr = rrc_EventIDIntraFreq_e1e;
    break;

  case 5:
    *rrcmeas_intra_freq_event_id_ptr = rrc_EventIDIntraFreq_e1f;
    break;

  case 9:
    *rrcmeas_intra_freq_event_id_ptr = rrc_EventIDIntraFreq_e1j;
    break;

  default:
    WRRC_MSG0_ERROR("L1 sent a wrong event ID.");

    return FAILURE;
  }  /* End of switch */
  return SUCCESS;
}


/*===========================================================================

FUNCTION    CHECK_FOR_RACH_REPORTING

DESCRIPTION

 Determines if RACH report can be appended to RACH messages.
 The calling function should call rrc_meas_append_meas_rpt_on_rach
 only it has received APPEND_RRC_MEAS_RACH_REPORT value.

DEPENDENCIES

 None.

RETURN VALUE

 APPEND_RRC_MEAS_RACH_REPORT if RACH report can be appended
 NO_RRC_MEAS_RACH_REPORT if RACH report cannot be appended

SIDE EFFECTS

 None

===========================================================================*/

rach_report_crit_e_type rrcmeas_check_for_rach_reporting
(
void
)
{
  /* First check the current RRC MEAS sub-state */
  switch ( rrcmeas_current_substate )
  {
  case RRCMEAS_INITIAL:
    break;

  case  RRCMEAS_IDLE:
    return sib11_rach_report_crit;

  case RRCMEAS_CELL_DCH:
    MSG_LOW("No RACH reporting in CELL_DCH",0,0,0);
    break;

  case RRCMEAS_CELL_FACH:
  case RRCMEAS_PCH:
    if(sib12_present == SIB12_ABSENT)
    {
      MSG_LOW("SIB12 Absent RACH CRIT in SIB11 IS %d", sib11_rach_report_crit,0,0);
      return sib11_rach_report_crit;
    }
    else
    {
      MSG_LOW("SIB12 Present RACH CRIT in SIB12 IS %d", sib12_rach_report_crit,0,0);
      return sib12_rach_report_crit;
    }

  default:
    break;
  } /* End of switch */

  WRRC_MSG1_HIGH("Cannot append RACH report : Meas state %d",rrcmeas_current_substate);  
  return NO_RRC_MEAS_RACH_REPORT;
}




/*===========================================================================

FUNCTION    RRCMEAS_CLEAR_SIB11

DESCRIPTION

 Initialises SIB11 stored variable, sib11_rach_report_crit, sib12)

DEPENDENCIES

 None.

RETURN VALUE

 void

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_clear_sib11
(
void
)
{
  sib11_rach_report_crit = NO_RRC_MEAS_RACH_REPORT;

  if(NULL == rrcmeas_sib11)
  {
    return;
  }
  rrcmeas_sib11->fach_meas_incl = FALSE;
  rrcmeas_sib11->hcs_used = FALSE;
  rrcmeas_sib11->cell_sel_resel_quan_type = L1_MEAS_NONE;
  rrcmeas_sib11->intra_freq_meas_info_incl = FALSE;
  rrcmeas_sib11->intra_f.meas_quan.filter_coef = 0;
  rrcmeas_sib11->intra_f.meas_quan.quan_type = L1_MEAS_NONE;
  rrcmeas_sib11->intra_f.cell_list_incl = FALSE;
  rrcmeas_sib11->intra_f.cell_list.num_cell_rmv = 0;
  rrcmeas_sib11->intra_f.cell_list.num_cell_add = 0;
  rrcmeas_sib11->intra_f.cell_list.num_cell_meas = 0;
  rrcmeas_sib11->intra_f.cell_list.cells_for_meas_incl = FALSE;
  rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl = FALSE;
  rrcmeas_sib11->intra_f.meas_quan_incl = FALSE;
  rrcmeas_sib11->intra_f.rach_rpt_max_incl = FALSE;
  rrcmeas_sib11->intra_f.rach_rpt_max = L1_RACH_RPT_NONE;
  rrcmeas_sib11->intra_f.rach_rpt_quan_incl = FALSE;
  //rrcmeas_sib11->inter_freq_meas_info_incl = FALSE;
  rrcmeas_sib11->inter_sys_meas_info_incl = FALSE;
  rrcmeas_sib11->inter_s.num_cell_rmv = 0;
  rrcmeas_sib11->inter_s.num_cell_add = 0;
  rrcmeas_sib11->intra_f.dch_rpt_info.rpt_trans_mode =
    ACKNOWLEDGED_MODE;
}

/*===========================================================================

FUNCTION    RRCMEAS_BUILD_SIB12_INTRA_FREQ_LIST_FROM_SIB11

DESCRIPTION

 Builds neighbouring cell list from SIB11 for SIB12.

DEPENDENCIES

 None.

RETURN VALUE

 void

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_build_sib12_intra_freq_list_from_sib11
(
rrc_RemovedIntraFreqCellList *removedIntraFreqCellList,
l1_intra_freq_cell_list_struct_type* sib11_cell_list_ptr,
l1_intra_freq_cell_list_struct_type* sib12_cell_list_ptr,
intra_freq_cell_list_struct_type  *tmp_intra_freq_cell_list
)
{
  /* Initialize all variables */

  /* Stores no of intra-freq cells stored in SIB11 */
  uint32 sib11_added_cells = 0;

  /* Stores no of intra-freq cells stored in SIB12 */
  uint32 sib12_added_cells = 0;

  /* Counts no of cells in SIB12 */
  uint32 sib12_count_cells = 0;

  /* Counts removed cells matched against new intra freq cells of SIB11 */
  uint32 sib12_r_cell = 0;

  /* Counts no of new intra freq cells in SIB11 and helps in comparing
  * with no fo removed cells in SIB12 */
  uint32 sib11_a_cell = 0;

  /* If removed cell is found */
  uint32 match_found = 0;
  uint32 cell_id;
  uint16 new_cell_list = 0;
  uint16 new_cell_list_from_sib11 = 0;
  uint16 count = 0;


  rrc_RemovedIntraFreqCellList tmp_removedIntraFreqCellList;

  /* Stores ptr to SIB12 list */
  l1_intra_freq_cell_list_struct_type* new_cell_list_ptr = NULL;

  sib11_added_cells = sib11_cell_list_ptr->num_cell_add;

  /* First remove no of removed cells in SIB12 from SIB11 and store result
  * in a temporary list i.e. intra_freq_sib12_new_cell_list */

  /* initialize the tmp list to satisfy lint */
  RRC_SET_COMMON_MSG_TYPE2(tmp_removedIntraFreqCellList,
  rrc_RemovedIntraFreqCellList, removeNoIntraFreqCells);
  tmp_removedIntraFreqCellList.u.removeSomeIntraFreqCells = NULL;
  if(RRC_CHECK_COMMON_MSG_TYPE2_PTR(removedIntraFreqCellList,rrc_RemovedIntraFreqCellList,
    removeAllIntraFreqCells))
  {
    /* No cells need to be picked up from SIB 11 */
    sib12_cell_list_ptr->num_cell_rmv = 0;
    return;
  }

  /* Criteria: Match removed cell of SIB12 against all cells of SIB11
  * one at a time */
  count=0;
  for ( sib11_a_cell=0 ; sib11_a_cell<sib11_added_cells; sib11_a_cell++ )
  {
    if(RRC_CHECK_COMMON_MSG_TYPE2_PTR(removedIntraFreqCellList,rrc_RemovedIntraFreqCellList,
        removeSomeIntraFreqCells))
    {
      if(removedIntraFreqCellList->u.removeSomeIntraFreqCells != NULL)
      {
        tmp_removedIntraFreqCellList.u.removeSomeIntraFreqCells
         = removedIntraFreqCellList->u.removeSomeIntraFreqCells;
      }
    }
    count=0;
    for ( sib12_r_cell=0; sib12_r_cell <sib12_cell_list_ptr->num_cell_rmv;
    sib12_r_cell++ )
    {
      if(RRC_CHECK_COMMON_MSG_TYPE2_PTR(removedIntraFreqCellList,
        rrc_RemovedIntraFreqCellList,removeSomeIntraFreqCells))
      {
        
        if((tmp_removedIntraFreqCellList.u.removeSomeIntraFreqCells != NULL) && 
            (tmp_removedIntraFreqCellList.u.removeSomeIntraFreqCells->n > count))
        {
          if(tmp_intra_freq_cell_list[tmp_removedIntraFreqCellList.u.removeSomeIntraFreqCells->elem[count]].psc !=
            sib11_cell_list_ptr->add_cell[sib11_a_cell].psc)
          {
            count++;
            continue; /* Read next value of removed cell*/
          }
          match_found = 1;
        }
      }
      if(match_found == 1)
      {
         /* Do not add this cell to the composite list */
         break;
      }
    }  /* End of for for sib12_r_cell */

    if ( match_found == 0 )
    {
      MSG_LOW("Copying SIB 11 cell back in new list", 0,0,0);

      intra_freq_sib12_new_cell_list.add_cell[new_cell_list].psc =
        sib11_cell_list_ptr->add_cell[sib11_a_cell].psc;

      intra_freq_sib12_new_cell_list.add_cell[new_cell_list].cell_info =
        sib11_cell_list_ptr->add_cell[sib11_a_cell].cell_info;

     intra_freq_sib12_new_cell_list.add_cell[new_cell_list].measure_in_idle_pch_fach =
        sib11_cell_list_ptr->add_cell[sib11_a_cell].measure_in_idle_pch_fach;
      /* Increment counter */
      new_cell_list++;

    } /* End of if */

    /* Reinitialize match_found variable */
    match_found = 0;

    /* Read next SIB 11 cell */

  } /* End of for sib11_a_cell */

  new_cell_list_ptr = & intra_freq_sib12_new_cell_list;
  new_cell_list_from_sib11 = new_cell_list;

  /* Check if SIB12 new intra freq cells have id same as the one already present
   * from SIB 11 if so overwrite, if not append to the list */
  for ( sib12_added_cells =0; sib12_added_cells < sib12_cell_list_ptr->num_cell_add && new_cell_list < L1_MAX_CELL_MEAS;
  sib12_added_cells++ )
  {
    for(cell_id = 0; cell_id < L1_MAX_CELL_MEAS; cell_id++)
    {
     if(intra_freq_cell_list[PRI_FREQ][cell_id].psc == sib12_cell_list_ptr->add_cell[sib12_added_cells].psc)
      {
        break;
      }
    }

    if(tmp_intra_freq_cell_list[cell_id].psc != INVALID_PSC)
    {
      for(count = 0; count < new_cell_list_from_sib11; count++)
      {
        if(tmp_intra_freq_cell_list[cell_id].psc
         == new_cell_list_ptr->add_cell[count].psc)
        {
          new_cell_list_ptr->add_cell[count].psc =
          sib12_cell_list_ptr->add_cell[sib12_added_cells].psc;

          new_cell_list_ptr->add_cell[count].cell_info =
            sib12_cell_list_ptr->add_cell[sib12_added_cells].cell_info;

         new_cell_list_ptr->add_cell[count].measure_in_idle_pch_fach =
          sib12_cell_list_ptr->add_cell[sib12_added_cells].measure_in_idle_pch_fach;
          break;
        }
      }
      if(count == new_cell_list_from_sib11)
      {
        new_cell_list_ptr->add_cell[new_cell_list].psc =
          sib12_cell_list_ptr->add_cell[sib12_added_cells].psc;

        new_cell_list_ptr->add_cell[new_cell_list].cell_info =
          sib12_cell_list_ptr->add_cell[sib12_added_cells].cell_info;
        new_cell_list_ptr->add_cell[new_cell_list].measure_in_idle_pch_fach =
          sib12_cell_list_ptr->add_cell[sib12_added_cells].measure_in_idle_pch_fach;
        new_cell_list++;
      }
    }
    else
    {
      new_cell_list_ptr->add_cell[new_cell_list].psc =
        sib12_cell_list_ptr->add_cell[sib12_added_cells].psc;

      new_cell_list_ptr->add_cell[new_cell_list].cell_info =
        sib12_cell_list_ptr->add_cell[sib12_added_cells].cell_info;

      new_cell_list_ptr->add_cell[new_cell_list].measure_in_idle_pch_fach =
        sib12_cell_list_ptr->add_cell[sib12_added_cells].measure_in_idle_pch_fach;
      new_cell_list++;
    }
  } /* End of for */

  /* Store the no of cells */
  sib12_cell_list_ptr->num_cell_add = new_cell_list;

  MSG_LOW("There are %d cells in SIB12 cell list", new_cell_list, 0,0);

  /* Now copy the structure in SIB12 */
  for ( sib12_count_cells =0; sib12_count_cells<new_cell_list && sib12_count_cells < L1_MAX_CELL_MEAS;
  sib12_count_cells++ )
  {

    sib12_cell_list_ptr->add_cell[sib12_count_cells].psc =
      new_cell_list_ptr->add_cell[sib12_count_cells].psc;

    sib12_cell_list_ptr->add_cell[sib12_count_cells].cell_info =
      new_cell_list_ptr->add_cell[sib12_count_cells].cell_info;

    sib12_cell_list_ptr->add_cell[sib12_count_cells].measure_in_idle_pch_fach =
      new_cell_list_ptr->add_cell[sib12_count_cells].measure_in_idle_pch_fach;
  } /* End of for */

    /* Initialize no of removed cells to 0 as SIB12 intra-freq cell info list has
  * already taken them into account */
  sib12_cell_list_ptr->num_cell_rmv = 0;
} /* End of function */



/*===========================================================================

FUNCTION   RRCMEAS_APPEND_INTRA_FREQ_PERIODIC_MEAS_RESULTS

DESCRIPTION

 Processes intra-freq periodic measurements and appends
 to Measured Results in Measurement Report

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_append_intra_freq_periodic_meas_results
(
l1_intra_freq_meas_rpt_struct_type* l1_intra_freq_periodic_meas_ptr,
rrc_MeasurementReport *meas_rpt_ptr
,rrc_IntraFreqMeasuredResultsList** intra_freq_measured_results_list_dbl_ptr
, boolean addtl_meas

)
{
  /* Struct ptr declared to store values of intra-freq next ptr */
  rrc_IntraFreqMeasuredResultsList* intra_freq_measured_results_list_ptr;
  struct rrc_IntraFrequencyMeasuredResultsList_v590ext *intra_freq_meas_res_ext_ptr = NULL;
  uint16 cell_number = 0;



  /* Update the linked list head ptr */
  if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) && (addtl_meas == FALSE))
  {
    RRC_MSG_COMMON_SET_BITMASK_IE_PTR(meas_rpt_ptr,rrc_MeasurementReport,v390nonCriticalExtensions);

    meas_rpt_ptr->v390nonCriticalExtensions.m.laterNonCriticalExtensionsPresent =1;
    meas_rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.m.
        v4b0NonCriticalExtensionsPresent =1;

    meas_rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
      m.v590NonCriticalExtensionsPresent =1;

    meas_rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
      v590NonCriticalExtensions.measurementReport_v590ext.m.measuredResults_v590extPresent =1;

    RRC_SET_COMMON_MSG_TYPE2(meas_rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
      v590NonCriticalExtensions.measurementReport_v590ext.measuredResults_v590ext,
      rrc_MeasuredResults_v590ext,intraFrequencyMeasuredResultsList);

    intra_freq_meas_res_ext_ptr = 
        rtxMemAllocTypeZ(&enc_ctxt,rrc_IntraFrequencyMeasuredResultsList_v590ext);

    if(l1_intra_freq_periodic_meas_ptr->num_cells < L1_MAX_CELL_MEAS)
    {
      intra_freq_meas_res_ext_ptr->n = l1_intra_freq_periodic_meas_ptr->num_cells;
    }
    else
    {
      intra_freq_meas_res_ext_ptr->n = L1_MAX_CELL_MEAS;
    }
    ALLOC_ASN1ARRAY2(&enc_ctxt,intra_freq_meas_res_ext_ptr,
      rrc_DeltaRSCPPerCell);

    RRC_RESET_MSG_IE_PRESENT(intra_freq_meas_res_ext_ptr->elem[0]);
    
    meas_rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
      v590NonCriticalExtensions.measurementReport_v590ext.measuredResults_v590ext.u.
      intraFrequencyMeasuredResultsList = intra_freq_meas_res_ext_ptr;
  }

  MSG_LOW("No of cells sent by L1 is %d", l1_intra_freq_periodic_meas_ptr->num_cells,0,0);

  intra_freq_measured_results_list_ptr =
  rtxMemAllocTypeZ(&enc_ctxt,rrc_IntraFreqMeasuredResultsList);
    
  *(intra_freq_measured_results_list_dbl_ptr) = intra_freq_measured_results_list_ptr;

  if(l1_intra_freq_periodic_meas_ptr->num_cells < L1_MAX_CELL_MEAS)
  {
    intra_freq_measured_results_list_ptr->n = l1_intra_freq_periodic_meas_ptr->num_cells;
  }
  else
  {
    intra_freq_measured_results_list_ptr->n = L1_MAX_CELL_MEAS;
  }
  
  ALLOC_ASN1ARRAY2(&enc_ctxt,intra_freq_measured_results_list_ptr,
    rrc_CellMeasuredResults);

  /* Read all the cell measured results in a for loop.
  * Also set the scrambling code list for event results in the loop */
  for ( cell_number = 0; (cell_number < l1_intra_freq_periodic_meas_ptr->num_cells)
    && ( cell_number < L1_MAX_CELL_MEAS ); cell_number++ )
  {
    /* Initialize bit mask */
    RRC_RESET_MSG_IE_PRESENT(intra_freq_measured_results_list_ptr->elem[cell_number]);
    if((addtl_meas == FALSE) && (intra_freq_meas_res_ext_ptr!=NULL))
    {
      RRC_RESET_MSG_IE_PRESENT(intra_freq_meas_res_ext_ptr->elem[cell_number]);
    }
    if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].sfn_rpt_ind == L1_NO_REPORT)
    {
      MSG_LOW("SFN SFN observed time diff not set", 0,0,0);
    }
    else
    {
      /* Set bit mask to sfn_sfn present */
      RRC_MSG_COMMON_SET_BITMASK_IE(intra_freq_measured_results_list_ptr->elem[cell_number],
        rrc_CellMeasuredResults,dummy);

      /* Store sfn-sfn type indicator */

      if ( l1_intra_freq_periodic_meas_ptr->cell[cell_number].sfn_rpt_ind == L1_REPORT_TYPE_1)
      {
        intra_freq_measured_results_list_ptr->elem[cell_number].dummy.t =  T_rrc_SFN_SFN_ObsTimeDifference_type1;

        MSG_LOW("sfn-sfn type 1 selected", 0,0,0);
        /* Type 1 report */

        if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].sfn_sfn_tm_diff <=
          SFN_SFN_TYPE1_MAX_VALUE)
        {
          intra_freq_measured_results_list_ptr->elem[cell_number].dummy.u.type1 =
            l1_intra_freq_periodic_meas_ptr->cell[cell_number].sfn_sfn_tm_diff;
        }
        else
        {
          WRRC_MSG1_ERROR("Incorrect SFN-SFN Type1 value %d",
            l1_intra_freq_periodic_meas_ptr->cell[cell_number].sfn_sfn_tm_diff);
          intra_freq_measured_results_list_ptr->elem[cell_number].dummy.u.type1 =
            SFN_SFN_TYPE1_MIN_VALUE;
        }
      }
      else
      {
        MSG_LOW("sfn-sfn type 2 selected", 0,0,0);
        intra_freq_measured_results_list_ptr->elem[cell_number].dummy.t =  T_rrc_SFN_SFN_ObsTimeDifference_type2;
        /* Type 2 report */
        if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].sfn_sfn_tm_diff <=
          SFN_SFN_TYPE2_MAX_VALUE)
        {
          intra_freq_measured_results_list_ptr->elem[cell_number].dummy.u.type2 =
            (rrc_SFN_SFN_ObsTimeDifference2)l1_intra_freq_periodic_meas_ptr->cell[cell_number].sfn_sfn_tm_diff;
        }
        else
        {
          WRRC_MSG1_ERROR("Incorrect SFN-SFN Type2 value %d",
            l1_intra_freq_periodic_meas_ptr->cell[cell_number].sfn_sfn_tm_diff);
          intra_freq_measured_results_list_ptr->elem[cell_number].dummy.u.type2 =
            SFN_SFN_TYPE2_MIN_VALUE;
        }

      }

    } /* End of else */

    /* Check if cell sync info present */

    if ( l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info_incl == TRUE )
    {
      /* Set cell sync info present to rrc_cellSynchronisationInfo) */
      RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2(intra_freq_measured_results_list_ptr->elem[cell_number],
         cellSynchronisationInfo);

      /* Store t Mode info to fdd*/
      intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
        modeSpecificInfo.t =
        T_rrc_CellSynchronisationInfo_modeSpecificInfo_fdd;

      intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
        modeSpecificInfo.u.fdd =
         rtxMemAllocTypeZ(&enc_ctxt,rrc_CellSynchronisationInfo_fdd);

      intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.modeSpecificInfo.u.
        fdd->m.countC_SFN_Frame_differencePresent=1;

      /* Set rrc_CountC_SFN_Frame_difference value structure */

#ifdef FEATURE_WCDMA_CNT_C_SFN_DIFF
      if(l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.count_c_sfn_diff_incl)
      {
        WRRC_MSG1_HIGH("CNT_C_SFN value from L1 : %d", 
          l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.count_c_sfn_high);
        intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.modeSpecificInfo.u.
          fdd->countC_SFN_Frame_difference.countC_SFN_High =
          (uint8)l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.count_c_sfn_high;
      }
      else
      {
        intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.modeSpecificInfo.u.
          fdd->countC_SFN_Frame_difference.countC_SFN_High = 0;
      }
#else
      /* Set countC_SFN_High in the above structure. At present it is set to 0.
       * Would be updated later when it gets implemented */
      intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.modeSpecificInfo.u.
        fdd->countC_SFN_Frame_difference.countC_SFN_High = 0;
#endif

      /* Set off value */
      if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.off <= OFF_MAX)
      {
        intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
          modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.off =
          (uint8)l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.off;
      }
      else
      {
        WRRC_MSG1_ERROR("Off value %d not in range",
          l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.off);
        intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
          modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.off = OFF_MIN;
      }

      /* Store tm value */
      if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.tm <= TM_MAX)
      {
        intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
          modeSpecificInfo.u.fdd->tm =
          (uint16)l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.tm;
      }
      else
      {
        WRRC_MSG1_ERROR("Tm value %d not in range",
          l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.tm);

        intra_freq_measured_results_list_ptr->elem[cell_number].cellSynchronisationInfo.
          modeSpecificInfo.u.fdd->tm = TM_MIN;
      }

    } /* End of if of rrc_cellSynchronisationInfo) */

    /* Set in the FDD mode for rrc_CellMeasuredResults_modeSpecificInfo */
    intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.t =
      T_rrc_CellMeasuredResults_modeSpecificInfo_fdd;

    intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd =
       rtxMemAllocTypeZ(&enc_ctxt,rrc_CellMeasuredResults_fdd);

    /* Set primary scrambling code */
    intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->
      primaryCPICH_Info.primaryScramblingCode =
      l1_intra_freq_periodic_meas_ptr->cell[cell_number].pri_scr_code;

    RRC_RESET_MSG_IE_PRESENT_PTR(intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd);


    /* Check if RSCP included */
    if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].rscp_included)
    {
      /* Check the range of additional rscp value */
      if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].rscp_val <= RSCP_MAX_VALUE)
      {
        /* Set the bit mask to indicate RSCP value */
        intra_freq_measured_results_list_ptr->elem[cell_number].
        modeSpecificInfo.u.fdd->m.cpich_RSCPPresent =1;

        /* Set the additional RSCP value */
        intra_freq_measured_results_list_ptr->elem[cell_number]
          .modeSpecificInfo.u.fdd->cpich_RSCP =  (rrc_CPICH_RSCP)l1_intra_freq_periodic_meas_ptr->cell[cell_number].rscp_val;
        if((addtl_meas == FALSE) && (intra_freq_meas_res_ext_ptr!=NULL))
        {
          if(l1_intra_freq_periodic_meas_ptr->cell[cell_number].delta_rscp_included == TRUE)
          {
            intra_freq_meas_res_ext_ptr->elem[cell_number].m.deltaRSCPPresent =1;
            intra_freq_meas_res_ext_ptr->elem[cell_number].deltaRSCP = 
              (int8)l1_intra_freq_periodic_meas_ptr->cell[cell_number].delta_rscp;
          }
        }
      }
    } /* End of if of rscp included */

    /* Check if Ec/No included */
    if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].ec_no_included)
    {
      /* Check the range of additional ecno value */
      if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].ec_no_val <= ECN0_MAX_VALUE)
      {
        /* Set the bit mask to indicate ecno value */
        intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.
        cpich_Ec_N0Present =1 ;

        /* Set the additional ecno value */
        intra_freq_measured_results_list_ptr->elem[cell_number]
          .modeSpecificInfo.u.fdd->cpich_Ec_N0 =  (rrc_CPICH_Ec_N0)l1_intra_freq_periodic_meas_ptr->cell[cell_number].ec_no_val;


      }

    } /* End of if of ec no included */

    if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].pathloss_included)
    {

      /* Check the range of additional path loss value */
      if ((l1_intra_freq_periodic_meas_ptr->cell[cell_number].pathloss_val > PATH_LOSS_MIN_VALUE) &&
        (l1_intra_freq_periodic_meas_ptr->cell[cell_number].pathloss_val < PATH_LOSS_MAX_VALUE))

      {
        /* Set the bit mask to indicate path loss value */
        intra_freq_measured_results_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.
        pathlossPresent =1;

        /* Set the additional path loss value */
        intra_freq_measured_results_list_ptr->elem[cell_number]
          .modeSpecificInfo.u.fdd->pathloss = (uint8)l1_intra_freq_periodic_meas_ptr->cell[cell_number].pathloss_val;

        WRRC_MSG0_HIGH("pathloss:Path loss value set");

      }

    } /* End of if of ec no included */
  /* End of else */
  } /* End of for loop */

  return;
}

#ifdef FEATURE_WCDMA_DC_HSUPA
/*===========================================================================

FUNCTION   RRCMEAS_APPEND_INTRA_FREQ_PERIODIC_MEAS_RESULTS_SEC_FREQ

DESCRIPTION

 Processes intra-freq periodic measurements and appends
 to Measured Results in Measurement Report for secondary 
 frequency

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_append_intra_freq_periodic_meas_results_sec_freq
(
l1_intra_freq_meas_rpt_struct_type* l1_intra_freq_periodic_meas_ptr,
rrc_MeasurementReport_v920ext_IEs *meas_rpt_ptr
,rrc_IntraFrequencyMeasuredResultsListOnSecULFreq* intra_freq_measured_results_list_dbl_ptr
, boolean addtl_meas

)
{
  uint16 cell_number = 0;

  MSG_LOW("No of cells sent by L1 is %d", l1_intra_freq_periodic_meas_ptr->num_cells,0,0);

  if(l1_intra_freq_periodic_meas_ptr->num_cells < L1_MAX_CELL_MEAS)
  {
    intra_freq_measured_results_list_dbl_ptr->n = l1_intra_freq_periodic_meas_ptr->num_cells;
  }
  else
  {
    intra_freq_measured_results_list_dbl_ptr->n = L1_MAX_CELL_MEAS;
  }
  
  ALLOC_ASN1ARRAY1(&enc_ctxt,intra_freq_measured_results_list_dbl_ptr,
    rrc_CellMeasuredResults_r9);
  if ( intra_freq_measured_results_list_dbl_ptr->elem == NULL )
  {
    ERR_FATAL("Failed to allocate memory",0,0,0);
  }

  /* Read all the cell measured results in a for loop.
  * Also set the scrambling code list for event results in the loop */
  for ( cell_number = 0; (cell_number < l1_intra_freq_periodic_meas_ptr->num_cells)
    && ( cell_number < L1_MAX_CELL_MEAS ); cell_number++ )
  {
    /* Check if cell sync info present */

    if ( l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info_incl == TRUE )
    {
      /* Set cell sync info present to rrc_cellSynchronisationInfo) */
      intra_freq_measured_results_list_dbl_ptr->elem[cell_number].m.cellSynchronisationInfoPresent = 1;
      
      /* Store t Mode info to fdd*/
      intra_freq_measured_results_list_dbl_ptr->elem[cell_number].cellSynchronisationInfo.
        modeSpecificInfo.t =
        T_rrc_CellSynchronisationInfo_modeSpecificInfo_fdd;

      intra_freq_measured_results_list_dbl_ptr->elem[cell_number].cellSynchronisationInfo.
        modeSpecificInfo.u.fdd =
         rtxMemAllocTypeZ(&enc_ctxt,rrc_CellSynchronisationInfo_fdd);

      if(intra_freq_measured_results_list_dbl_ptr->elem[cell_number].cellSynchronisationInfo.
         modeSpecificInfo.u.fdd == NULL)
      {
        ERR_FATAL("Malloc failed",0,0,0);
      }
      intra_freq_measured_results_list_dbl_ptr->elem[cell_number].cellSynchronisationInfo.modeSpecificInfo.u.
        fdd->m.countC_SFN_Frame_differencePresent=1;

      /* Set rrc_CountC_SFN_Frame_difference value structure */

#ifdef FEATURE_WCDMA_CNT_C_SFN_DIFF
      if(l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.count_c_sfn_diff_incl)
      {
        WRRC_MSG1_HIGH("CNT_C_SFN value from L1 : %d",
          l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.count_c_sfn_high);
        intra_freq_measured_results_list_dbl_ptr->elem[cell_number].cellSynchronisationInfo.modeSpecificInfo.u.
          fdd->countC_SFN_Frame_difference.countC_SFN_High =
          (uint8)l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.count_c_sfn_high;
      }
      else
      {
        intra_freq_measured_results_list_dbl_ptr->elem[cell_number].cellSynchronisationInfo.modeSpecificInfo.u.
          fdd->countC_SFN_Frame_difference.countC_SFN_High = 0;
      }
#else
      /* Set countC_SFN_High in the above structure. At present it is set to 0.
       * Would be updated later when it gets implemented */
      intra_freq_measured_results_list_dbl_ptr->elem[cell_number].cellSynchronisationInfo.modeSpecificInfo.u.
        fdd->countC_SFN_Frame_difference.countC_SFN_High = 0;
#endif

      /* Set off value */
      if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.off <= OFF_MAX)
      {
        intra_freq_measured_results_list_dbl_ptr->elem[cell_number].cellSynchronisationInfo.
          modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.off =
          (uint8)l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.off;
      }
      else
      {
        WRRC_MSG1_ERROR("Off value %d not in range",
          l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.off);
        intra_freq_measured_results_list_dbl_ptr->elem[cell_number].cellSynchronisationInfo.
          modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.off = OFF_MIN;
      }

      /* Store tm value */
      if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.tm <= TM_MAX)
      {
        intra_freq_measured_results_list_dbl_ptr->elem[cell_number].cellSynchronisationInfo.
          modeSpecificInfo.u.fdd->tm =
          (uint16)l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.tm;
      }
      else
      {
        WRRC_MSG1_ERROR("Tm value %d not in range",
          l1_intra_freq_periodic_meas_ptr->cell[cell_number].cell_sync_info.tm);

        intra_freq_measured_results_list_dbl_ptr->elem[cell_number].cellSynchronisationInfo.
          modeSpecificInfo.u.fdd->tm = TM_MIN;
      }

    } /* End of if of rrc_cellSynchronisationInfo) */

    /* Set in the FDD mode for rrc_CellMeasuredResults_modeSpecificInfo */
    intra_freq_measured_results_list_dbl_ptr->elem[cell_number].modeSpecificInfo.t =
      T_rrc_CellMeasuredResults_modeSpecificInfo_fdd;

    intra_freq_measured_results_list_dbl_ptr->elem[cell_number].modeSpecificInfo.u.fdd =
       rtxMemAllocTypeZ(&enc_ctxt,rrc_CellMeasuredResults_r9_fdd);

    if(intra_freq_measured_results_list_dbl_ptr->elem[cell_number].modeSpecificInfo.u.fdd == NULL)
    {
      ERR_FATAL("Malloc failed",0,0,0);
    }
    /* Set primary scrambling code */
    intra_freq_measured_results_list_dbl_ptr->elem[cell_number].modeSpecificInfo.u.fdd->
      primaryCPICH_Info.primaryScramblingCode =
      l1_intra_freq_periodic_meas_ptr->cell[cell_number].pri_scr_code;

    RRC_RESET_MSG_IE_PRESENT_PTR(intra_freq_measured_results_list_dbl_ptr->elem[cell_number].modeSpecificInfo.u.fdd);


    /* Check if RSCP included */
    if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].rscp_included)
    {
      /* Check the range of additional rscp value */
      if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].rscp_val <= RSCP_MAX_VALUE)
      {
        /* Set the bit mask to indicate RSCP value */
        intra_freq_measured_results_list_dbl_ptr->elem[cell_number].
        modeSpecificInfo.u.fdd->m.cpich_RSCPPresent =1;

        /* Set the additional RSCP value */
        intra_freq_measured_results_list_dbl_ptr->elem[cell_number]
          .modeSpecificInfo.u.fdd->cpich_RSCP =  (rrc_CPICH_RSCP)l1_intra_freq_periodic_meas_ptr->cell[cell_number].rscp_val;
      }
    } /* End of if of rscp included */

    /* Check if Ec/No included */
    if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].ec_no_included)
    {
      /* Check the range of additional ecno value */
      if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].ec_no_val <= ECN0_MAX_VALUE)
      {
        /* Set the bit mask to indicate ecno value */
        intra_freq_measured_results_list_dbl_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.
        cpich_Ec_N0Present =1 ;

        /* Set the additional ecno value */
        intra_freq_measured_results_list_dbl_ptr->elem[cell_number]
          .modeSpecificInfo.u.fdd->cpich_Ec_N0 =  (rrc_CPICH_Ec_N0)l1_intra_freq_periodic_meas_ptr->cell[cell_number].ec_no_val;
      }

    } /* End of if of ec no included */

    if (l1_intra_freq_periodic_meas_ptr->cell[cell_number].pathloss_included)
    {

      /* Check the range of additional path loss value */
      if ((l1_intra_freq_periodic_meas_ptr->cell[cell_number].pathloss_val > PATH_LOSS_MIN_VALUE) &&
        (l1_intra_freq_periodic_meas_ptr->cell[cell_number].pathloss_val < PATH_LOSS_MAX_VALUE))

      {
        /* Set the bit mask to indicate path loss value */
        intra_freq_measured_results_list_dbl_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.
        pathlossPresent =1;

        /* Set the additional path loss value */
        intra_freq_measured_results_list_dbl_ptr->elem[cell_number]
          .modeSpecificInfo.u.fdd->pathloss = (uint8)l1_intra_freq_periodic_meas_ptr->cell[cell_number].pathloss_val;

        WRRC_MSG0_HIGH("pathloss:Path loss value set");

      }
    } /* End of if of ec no included */
  } /* End of for loop */

  return;
}
#endif


/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_MEAS_CTRL_MSG

DESCRIPTION

 Processes meas control message in DCH state and directs L1 to setup/modify/
 release measurements accordingly. If the message determined is incorrect,
 send a measurement control failure message to UTRAN

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_process_meas_ctrl_msg
(
rrc_cmd_type *cmd_ptr
)
{
  /* Declare ptr to store message received from UTRAN */
  rrc_DL_DCCH_Message* dcch_msg_ptr = NULL;

  /* Declare ptr to point to actual IE's in Meas Ctrl Msg */
  rrc_MeasurementControl_r3_IEs *mcm_ptr = NULL;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  uint8 t;
  /* To keep track of transaction in transaction table */
  uint16 count = 0;

  uint8 meas_ctrl_tr_id = INVALID_TRANSACTION_ID;
  rrc_MeasurementControl_v590ext_IEs *rel5_ext_ptr = NULL;

  /* Store the message */
  dcch_msg_ptr = (rrc_DL_DCCH_Message *)cmd_ptr->cmd.
    downlink_sdu_ind.decoded_msg;

  if ( dcch_msg_ptr == NULL )
  {
    WRRC_MSG0_HIGH("ASN1 decoding failed");

    /* Set transaction ID to 0 */
    rrcmeas_mcf.rrc_transaction_id = 0;

    /* Set error t */
    t = T_rrc_ProtocolErrorMoreInformation_type1_asn1_ViolationOrEncodingError;

    /* Send RRC Status msg to UTRAN */

    rrcmeas_send_rrc_status_msg(&rrcmeas_mcf.rrc_transaction_id, &t);
    return;
  }
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  if (dcch_msg_ptr->message.t == T_rrc_DL_DCCH_MessageType_assistanceDataDelivery)
  {
    WRRC_MSG0_HIGH("POS: Assistance Data Delievery Msg received");
    rrcgps_process_asd_msg(cmd_ptr);

    return;
  }

#endif

  if ( dcch_msg_ptr->message.u.measurementControl.t ==
    T_rrc_MeasurementControl_r3 )
  {
     WRRC_MSG0_HIGH("measctrlr99 rcvd");
     meas_ctrl_tr_id = dcch_msg_ptr->message.u.measurementControl.u.r3.measurementControl_r3.
       rrc_TransactionIdentifier;
     if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
     {
       if((dcch_msg_ptr->message.u.measurementControl.u.r3.m.v390nonCriticalExtensionsPresent)
         && (dcch_msg_ptr->message.u.measurementControl.u.r3.v390nonCriticalExtensions.m.
         v3a0NonCriticalExtensionsPresent) && (dcch_msg_ptr->message.u.
         measurementControl.u.r3.v390nonCriticalExtensions.m.
         v3a0NonCriticalExtensionsPresent) && (dcch_msg_ptr->message.u.
         measurementControl.u.r3.v390nonCriticalExtensions.v3a0NonCriticalExtensions.m.
         laterNonCriticalExtensionsPresent) &&
         (dcch_msg_ptr->message.u.measurementControl.u.r3.v390nonCriticalExtensions.
         v3a0NonCriticalExtensions.m.laterNonCriticalExtensionsPresent) &&
         (dcch_msg_ptr->message.u.measurementControl.u.r3.v390nonCriticalExtensions.v3a0NonCriticalExtensions.
         laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent)
         && (dcch_msg_ptr->message.u.measurementControl.u.r3.v390nonCriticalExtensions.v3a0NonCriticalExtensions.
         laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent)
         && (dcch_msg_ptr->message.u.measurementControl.u.r3.v390nonCriticalExtensions.v3a0NonCriticalExtensions.
         laterNonCriticalExtensions.v4b0NonCriticalExtensions.m.v590NonCriticalExtensionsPresent))
       {
         rel5_ext_ptr = &(dcch_msg_ptr->message.u.measurementControl.u.r3.v390nonCriticalExtensions.
           v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
           v590NonCriticalExtensions.measurementControl_v590ext);
         MSG_LOW("RRCHS:Tr Id Ext is %d", rel5_ext_ptr->rrc_TransactionIdentifier_MSP_v590ext,0,0);

         if (rel5_ext_ptr->rrc_TransactionIdentifier_MSP_v590ext > 3)
         {
           WRRC_MSG1_ERROR("RRCHS:Tr Id Ext %d out of range", rel5_ext_ptr->rrc_TransactionIdentifier_MSP_v590ext);
           /* Use the Tr Id in Message Itself */
           rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

           rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_protocolError;

           rrcmeas_mcf.error_cause = rrc_ProtocolErrorCause_messageExtensionNotComprehended;

           /* Send MCF msg to UTRAN  */
           rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

           return;

         }

         meas_ctrl_tr_id = meas_ctrl_tr_id + rel5_ext_ptr->
           rrc_TransactionIdentifier_MSP_v590ext * 4;
      }
    }
  }
  else if (( dcch_msg_ptr->message.u.measurementControl.t ==
             T_rrc_MeasurementControl_later_than_r3 ) &&
           (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.criticalExtensions.t ==
            T_rrc_MeasurementControl_criticalExtensions_4_r4))
  {
    WRRC_MSG0_HIGH("measctrlr5 rcvd");

    if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
    {
      meas_ctrl_tr_id = dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.rrc_TransactionIdentifier;
      if ((dcch_msg_ptr->message.u.measurementControl.u.
        later_than_r3.criticalExtensions.u.r4.m.v4d0NonCriticalExtensionsPresent) &&
        (dcch_msg_ptr->message.u.measurementControl.u.
        later_than_r3.criticalExtensions.u.r4.v4d0NonCriticalExtensions.m.
        v590NonCriticalExtensionsPresent))
      {
        MSG_LOW("RRCHS:Tr Id Ext is %d", dcch_msg_ptr->message.u.measurementControl.u.
          later_than_r3.criticalExtensions.u.r4.v4d0NonCriticalExtensions.
          v590NonCriticalExtensions.measurementControl_v590ext.rrc_TransactionIdentifier_MSP_v590ext,0,0);

        if (dcch_msg_ptr->message.u.measurementControl.u.
          later_than_r3.criticalExtensions.u.r4.v4d0NonCriticalExtensions.
          v590NonCriticalExtensions.measurementControl_v590ext.rrc_TransactionIdentifier_MSP_v590ext > 3)
        {
          WRRC_MSG1_ERROR("RRCHS:Tr Id Ext %d out of range", dcch_msg_ptr->message.u.measurementControl.u.
            later_than_r3.criticalExtensions.u.r4.v4d0NonCriticalExtensions.
            v590NonCriticalExtensions.measurementControl_v590ext.rrc_TransactionIdentifier_MSP_v590ext);
          /* Use the Tr Id in Message Itself */
          rrcmeas_mcf.rrc_transaction_id = dcch_msg_ptr->message.u.measurementControl.u.
            later_than_r3.rrc_TransactionIdentifier;

          rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_protocolError;

          rrcmeas_mcf.error_cause = rrc_ProtocolErrorCause_messageExtensionNotComprehended;

          /* Send MCF msg to UTRAN  */
          rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

          return;

        }

        meas_ctrl_tr_id = dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.rrc_TransactionIdentifier +
          dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.criticalExtensions.u.r4.v4d0NonCriticalExtensions.
          v590NonCriticalExtensions.measurementControl_v590ext.rrc_TransactionIdentifier_MSP_v590ext * 4;

      }

      for(count =0; count < MAXIMUM_TRANSACTIONS;count++)
      {
        if(rrcmeas_accepted_transaction_table[count].transaction_id == meas_ctrl_tr_id)
        {
          rrcmeas_accepted_transaction_table[count].is_latest_trans = FALSE;
        }
      }
        /* Check for the Free slot in the accepted transaction table if cant find the slot ignore the message*/
      for ( count = 0; count < MAXIMUM_TRANSACTIONS; count++ )
      {
        if (rrcmeas_accepted_transaction_table[count].transaction_id == INVALID_TRANSACTION_ID)
        {
          break;
        }
      }
      if(count == MAXIMUM_TRANSACTIONS)
      {
        WRRC_MSG1_HIGH("RRCMEAS: Lower layers yet to be configured for MAX transactions %d, Ignore the MCM",
            MAXIMUM_TRANSACTIONS);
      }
      rrcmeas_process_mcm_r5(cmd_ptr, meas_ctrl_tr_id);
    }
    else
    {
      WRRC_MSG0_ERROR("Unsupported Critical extensions");

      /* Set transaction ID to 0 */
      rrcmeas_mcf.rrc_transaction_id = 0;

      /* Set error t */
      rrcmeas_mcf.error_choice =
        T_rrc_FailureCauseWithProtErr_protocolError;


      /* Set protocol Error */
      rrcmeas_mcf.error_cause = rrc_ProtocolErrorCause_messageExtensionNotComprehended;

      /* Send MCF msg to UTRAN  */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
    }
    return;
  }
  else if((dcch_msg_ptr->message.u.measurementControl.t ==
           T_rrc_MeasurementControl_later_than_r3 ) &&
           (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.criticalExtensions.t ==
           T_rrc_MeasurementControl_criticalExtensions_4_later_than_r4) && 
           (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
           criticalExtensions.u.later_than_r4.criticalExtensions.t
           == T_rrc_MeasurementControl_criticalExtensions_3_r6))
  {
    WRRC_MSG0_HIGH("measctrlr6 rcvd");
    if(rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL6)
    {
    
      meas_ctrl_tr_id = dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.rrc_TransactionIdentifier;
      if(dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
             criticalExtensions.u.later_than_r4.rrc_TransactionIdentifier_MSP > 3)
      {
        WRRC_MSG1_ERROR("Tr Id Ext %d out of range", dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
             criticalExtensions.u.later_than_r4.rrc_TransactionIdentifier_MSP);
            /* Use the Tr Id in Message Itself */
            rrcmeas_mcf.rrc_transaction_id = dcch_msg_ptr->message.u.measurementControl.u.
              later_than_r3.rrc_TransactionIdentifier;

            rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_protocolError;

            rrcmeas_mcf.error_cause = rrc_ProtocolErrorCause_messageExtensionNotComprehended;

            /* Send MCF msg to UTRAN  */
            rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

            return;
      }
      meas_ctrl_tr_id = meas_ctrl_tr_id + (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
        criticalExtensions.u.later_than_r4.rrc_TransactionIdentifier_MSP * 4);

      for(count =0; count < MAXIMUM_TRANSACTIONS;count++)
      {
        if(rrcmeas_accepted_transaction_table[count].transaction_id == meas_ctrl_tr_id)
        {
          rrcmeas_accepted_transaction_table[count].is_latest_trans = FALSE;
        }
      }
        /* Check for the Free slot in the accepted transaction table if cant find the slot ignore the message*/
      for ( count = 0; count < MAXIMUM_TRANSACTIONS; count++ )
      {
        if (rrcmeas_accepted_transaction_table[count].transaction_id == INVALID_TRANSACTION_ID)
        {
          break;
        }
      }
      if(count == MAXIMUM_TRANSACTIONS)
      {
        WRRC_MSG1_HIGH("RRCMEAS: Lower layers yet to be configured for MAX transactions %d, Ignore the MCM",
            MAXIMUM_TRANSACTIONS);
      }
      rrcmeas_process_mcm_r6(cmd_ptr, meas_ctrl_tr_id);
    }
    else
    {
      WRRC_MSG0_ERROR("Unsupported Critical extensions");

      /* Set transaction ID to 0 */
      rrcmeas_mcf.rrc_transaction_id = 0;

      /* Set error t */
      rrcmeas_mcf.error_choice =
        T_rrc_FailureCauseWithProtErr_protocolError;


      /* Set protocol Error */
      rrcmeas_mcf.error_cause = rrc_ProtocolErrorCause_messageExtensionNotComprehended;

      /* Send MCF msg to UTRAN  */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf); 
    }
    return;
  }
  else if((dcch_msg_ptr->message.u.measurementControl.t ==
           T_rrc_MeasurementControl_later_than_r3 ) &&
           (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.criticalExtensions.t ==
           T_rrc_MeasurementControl_criticalExtensions_4_later_than_r4) &&
           (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
           criticalExtensions.u.later_than_r4.criticalExtensions.t
           == T_rrc_MeasurementControl_criticalExtensions_3_criticalExtensions) && 
           (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
           criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.t ==
           T_rrc_MeasurementControl_criticalExtensions_2_r7))
  {
    WRRC_MSG0_HIGH("measctrl r7 rcvd");
    if(rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL7)
    {
      meas_ctrl_tr_id = dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.rrc_TransactionIdentifier;
      meas_ctrl_tr_id = meas_ctrl_tr_id + (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
        criticalExtensions.u.later_than_r4.rrc_TransactionIdentifier_MSP * 4);

      for(count =0; count < MAXIMUM_TRANSACTIONS;count++)
      {
        if(rrcmeas_accepted_transaction_table[count].transaction_id == meas_ctrl_tr_id)
        {
          rrcmeas_accepted_transaction_table[count].is_latest_trans = FALSE;
        }
      }
        /* Check for the Free slot in the accepted transaction table if cant find the slot ignore the message*/
      for ( count = 0; count < MAXIMUM_TRANSACTIONS; count++ )
      {
        if (rrcmeas_accepted_transaction_table[count].transaction_id == INVALID_TRANSACTION_ID)
        {
          break;
        }
      }
      if(count == MAXIMUM_TRANSACTIONS)
      {
        WRRC_MSG1_HIGH("RRCMEAS: Lower layers yet to be configured for MAX transactions %d, Ignore the MCM",
            MAXIMUM_TRANSACTIONS);
      }
      rrcmeas_process_mcm_r7(cmd_ptr, meas_ctrl_tr_id);
    }
    else
    {
      WRRC_MSG0_ERROR("Unsupported Critical extensions");

      /* Set transaction ID to 0 */
      rrcmeas_mcf.rrc_transaction_id = 0;

      /* Set error t */
      rrcmeas_mcf.error_choice =
        T_rrc_FailureCauseWithProtErr_protocolError;


      /* Set protocol Error */
      rrcmeas_mcf.error_cause = rrc_ProtocolErrorCause_messageExtensionNotComprehended;

      /* Send MCF msg to UTRAN  */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf); 
    }
    return;
  }
  else if((dcch_msg_ptr->message.u.measurementControl.t ==
           T_rrc_MeasurementControl_later_than_r3 ) &&
           (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.criticalExtensions.t ==
           T_rrc_MeasurementControl_criticalExtensions_4_later_than_r4) && (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
           criticalExtensions.u.later_than_r4.criticalExtensions.t
           == T_rrc_MeasurementControl_criticalExtensions_3_criticalExtensions) && 
           (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
           criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.t ==
           T_rrc_MeasurementControl_criticalExtensions_2_criticalExtensions) &&
           (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
           criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.u.criticalExtensions.t ==
           T_rrc_MeasurementControl_criticalExtensions_1_r8))
  {
    WRRC_MSG0_HIGH("REL8:Meas Control Message received.");
    if(rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL8)
    {
      meas_ctrl_tr_id = dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.rrc_TransactionIdentifier;
      meas_ctrl_tr_id = meas_ctrl_tr_id + (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
        criticalExtensions.u.later_than_r4.rrc_TransactionIdentifier_MSP * 4);

      for(count =0; count < MAXIMUM_TRANSACTIONS;count++)
      {
        if(rrcmeas_accepted_transaction_table[count].transaction_id == meas_ctrl_tr_id)
        {
          rrcmeas_accepted_transaction_table[count].is_latest_trans = FALSE;
        }
      }
        /* Check for the Free slot in the accepted transaction table if cant find the slot ignore the message*/
      for ( count = 0; count < MAXIMUM_TRANSACTIONS; count++ )
      {
        if (rrcmeas_accepted_transaction_table[count].transaction_id == INVALID_TRANSACTION_ID)
        {
          break;
        }
      }
      if(count == MAXIMUM_TRANSACTIONS)
      {
        WRRC_MSG1_HIGH("RRCMEAS: Lower layers yet to be configured for MAX transactions %d, Ignore the MCM",
            MAXIMUM_TRANSACTIONS);
      }
      rrcmeas_process_mcm_r8(cmd_ptr, meas_ctrl_tr_id);
    }
    else
    {
      WRRC_MSG0_ERROR("Unsupported Critical extensions");

      /* Set transaction ID to 0 */
      rrcmeas_mcf.rrc_transaction_id = 0;

      /* Set error t */
      rrcmeas_mcf.error_choice =
        T_rrc_FailureCauseWithProtErr_protocolError;


      /* Set protocol Error */
      rrcmeas_mcf.error_cause = rrc_ProtocolErrorCause_messageExtensionNotComprehended;

      /* Send MCF msg to UTRAN  */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf); 
    }
    return;
  }
#ifdef FEATURE_WCDMA_REL9

  else if((dcch_msg_ptr->message.u.measurementControl.t ==
             T_rrc_MeasurementControl_later_than_r3 ) &&
             (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.criticalExtensions.t ==
             T_rrc_MeasurementControl_criticalExtensions_4_later_than_r4) && (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
             criticalExtensions.u.later_than_r4.criticalExtensions.t
             == T_rrc_MeasurementControl_criticalExtensions_3_criticalExtensions) && 
             (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
             criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.t ==
             T_rrc_MeasurementControl_criticalExtensions_2_criticalExtensions) &&
             (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
             criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.u.criticalExtensions.t ==
             T_rrc_MeasurementControl_criticalExtensions_1_later_r8_criticalExtensions) &&
             ((dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
             criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.later_r8_criticalExtensions.t ==
             T_rrc_MeasurementControl_later_r8_criticalExtensions_r9)))
    {
      WRRC_MSG0_HIGH("REL9:Meas Control Message received.");
      if(rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL9)
      {
        meas_ctrl_tr_id = dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.rrc_TransactionIdentifier;
        meas_ctrl_tr_id = meas_ctrl_tr_id + (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
          criticalExtensions.u.later_than_r4.rrc_TransactionIdentifier_MSP * 4);

        for(count =0; count < MAXIMUM_TRANSACTIONS;count++)
        {
          if(rrcmeas_accepted_transaction_table[count].transaction_id == meas_ctrl_tr_id)
          {
            rrcmeas_accepted_transaction_table[count].is_latest_trans = FALSE;
          }
        }
          /* Check for the Free slot in the accepted transaction table if cant find the slot ignore the message*/
        for ( count = 0; count < MAXIMUM_TRANSACTIONS; count++ )
        {
          if (rrcmeas_accepted_transaction_table[count].transaction_id == INVALID_TRANSACTION_ID)
          {
            break;
          }
        }
        if(count == MAXIMUM_TRANSACTIONS)
        {
          WRRC_MSG1_HIGH("RRCMEAS: Lower layers yet to be configured for MAX transactions %d, Ignore the MCM",
              MAXIMUM_TRANSACTIONS);
        }
        rrcmeas_process_mcm_r9(cmd_ptr, meas_ctrl_tr_id);
      }
      else
      {
        WRRC_MSG0_ERROR("Unsupported Critical extensions");

        /* Set transaction ID to 0 */
        rrcmeas_mcf.rrc_transaction_id = 0;

        /* Set error t */
        rrcmeas_mcf.error_choice =
          T_rrc_FailureCauseWithProtErr_protocolError;


        /* Set protocol Error */
        rrcmeas_mcf.error_cause = rrc_ProtocolErrorCause_messageExtensionNotComprehended;

        /* Send MCF msg to UTRAN  */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf); 
    }
    return;
  }

#endif /* FEATURE_WCDMA_REL9 */  

#ifdef FEATURE_WCDMA_REL10
#error code not present
#endif /* FEATURE_WCDMA_REL10 */  

  else
  {
      WRRC_MSG0_ERROR("Unsupported Critical extensions");

    /* Set transaction ID to 0 */
    rrcmeas_mcf.rrc_transaction_id = 0;

    /* Set error t */
    rrcmeas_mcf.error_choice =
      T_rrc_FailureCauseWithProtErr_protocolError;


    /* Set protocol Error */
    rrcmeas_mcf.error_cause = rrc_ProtocolErrorCause_messageExtensionNotComprehended;

    /* Send MCF msg to UTRAN  */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

    return ;

  }



  /* Get the pointer to the actual MC message */
  mcm_ptr = &(dcch_msg_ptr->message.u.measurementControl.u.r3.measurementControl_r3);

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
  {
    for(count =0; count < MAXIMUM_TRANSACTIONS;count++)
    {
      if(rrcmeas_accepted_transaction_table[count].transaction_id == meas_ctrl_tr_id)
      {
        rrcmeas_accepted_transaction_table[count].is_latest_trans = FALSE;
      }
    }
  }
  else
  {
    for(count =0; count < MAXIMUM_TRANSACTIONS;count++)
    {
      if(rrcmeas_accepted_transaction_table[count].transaction_id == mcm_ptr->rrc_TransactionIdentifier)
      {
        rrcmeas_accepted_transaction_table[count].is_latest_trans = FALSE;
      }
    }
  }


    /* Check for the Free slot in the accepted transaction table if cant find the slot ignore the message*/
  for ( count = 0; count < MAXIMUM_TRANSACTIONS; count++ )
  {
    if (rrcmeas_accepted_transaction_table[count].transaction_id == INVALID_TRANSACTION_ID)
    {
      break;
    }
  }
  if(count == MAXIMUM_TRANSACTIONS)
  {
    WRRC_MSG1_HIGH("RRCMEAS: Lower layers yet to be configured for MAX transactions %d, Ignore the MCM",
        MAXIMUM_TRANSACTIONS);
  }
  /* This means transaction is not present in Accepted Transaction table */
  /* But cannot set as of now as there can still be errors and message
  * can still be rejected */

  /* Now process the actual message to read meas info */

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  rrcmeas_read_mcm_measurements(mcm_ptr,cmd_ptr->cmd.downlink_sdu_ind.decoded_msg,dcch_msg_ptr, meas_ctrl_tr_id);
#else
  rrcmeas_read_mcm_measurements(mcm_ptr, dcch_msg_ptr, meas_ctrl_tr_id);
#endif
  return;
}


/*===========================================================================

FUNCTION   RRCMEAS_READ_MCM_MEASUREMENTS

DESCRIPTION

 Reads different measurements, validate the paramters of each meas and sends
 a measurement control message to L1/MAC to do meas based on new parameters.
 Send a measurement control failure message to UTRAN on finding an incorrect/
 unsupported measurement

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_read_mcm_measurements
(
rrc_MeasurementControl_r3_IEs* rrc_mcm_ptr
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
,void* decoded_msg_ptr
#endif
,rrc_DL_DCCH_Message* dcch_msg_ptr
,uint8 meas_ctrl_tr_id
)
{
  uint16 cell_count = 0;

  rrcmeas_layer_e_type meas_owner;

  uint32 measurement_id;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

  pos_info_struct_type pos_info;
#endif

  /* Stores Meas parameters to be sent to L1 */
  l1_meas_ctrl_parm_struct_type *l1_mcm = rrc_malloc(sizeof(l1_meas_ctrl_parm_struct_type));

  /* Meas Validity */
  meas_validity_enum_type meas_validity = NOT_PRESENT;

  uint8 transaction_id = INVALID_TRANSACTION_ID;

  rrcllc_oc_set_status_e_type oc_set_state;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  rrcmeas_layer_e_type primary_meas_type;

  /* Variable defined to check if addtl present in MCM is valid
  This varibale is set to TRUE if addtl meas is valid. True means
  in setting addtl meas in RRC db */
  boolean addtl_meas_validation = FALSE;

  rrc_MeasurementControl_v590ext_IEs *rel5_ext_ptr = NULL;

  uint8 alloc_idx;
  /* Initialize no of additional Meas to keep L1 happy */
  l1_mcm->num_add_meas = 0;

  /* First get the meas type */
  /* Check meas Id from the table. If it exists, good else send mcf */

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  if ((rrc_mcm_ptr == NULL) || (decoded_msg_ptr == NULL))
  {
    rrc_free(l1_mcm);
    return;
  }
#else
  if (rrc_mcm_ptr == NULL)
  {
    rrc_free(l1_mcm);
    return;
  }
#endif

  transaction_id = meas_ctrl_tr_id;
  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
  {
    if((dcch_msg_ptr->message.u.measurementControl.u.r3.m.v390nonCriticalExtensionsPresent)
      && (dcch_msg_ptr->message.u.measurementControl.u.r3.v390nonCriticalExtensions.m.
       v3a0NonCriticalExtensionsPresent) && (dcch_msg_ptr->message.u.
      measurementControl.u.r3.v390nonCriticalExtensions.m.
      v3a0NonCriticalExtensionsPresent) && (dcch_msg_ptr->message.u.
      measurementControl.u.r3.v390nonCriticalExtensions.v3a0NonCriticalExtensions.m.
      laterNonCriticalExtensionsPresent) &&
      (dcch_msg_ptr->message.u.measurementControl.u.r3.v390nonCriticalExtensions.
      v3a0NonCriticalExtensions.m.laterNonCriticalExtensionsPresent) &&
      (dcch_msg_ptr->message.u.measurementControl.u.r3.v390nonCriticalExtensions.v3a0NonCriticalExtensions.
      laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent)
      && (dcch_msg_ptr->message.u.measurementControl.u.r3.v390nonCriticalExtensions.v3a0NonCriticalExtensions.
      laterNonCriticalExtensions.m.v4b0NonCriticalExtensionsPresent)
      && (dcch_msg_ptr->message.u.measurementControl.u.r3.v390nonCriticalExtensions.v3a0NonCriticalExtensions.
      laterNonCriticalExtensions.v4b0NonCriticalExtensions.m.v590NonCriticalExtensionsPresent))
    {
      rel5_ext_ptr = &(dcch_msg_ptr->message.u.measurementControl.u.r3.v390nonCriticalExtensions.
        v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
        v590NonCriticalExtensions.measurementControl_v590ext);
    }
  }


  if((rrc_mcm_ptr->measurementIdentity < MEASUREMENT_IDENTITY_MIN) ||
    (rrc_mcm_ptr->measurementIdentity >MEASUREMENT_IDENTITY_MAX))
  {
    WRRC_MSG1_HIGH("Invalid meas id %d",rrc_mcm_ptr->measurementIdentity);

    /* Set transaction ID */
    rrcmeas_mcf.rrc_transaction_id = transaction_id;

    /* Set error t */
    rrcmeas_mcf.error_choice =
      T_rrc_FailureCauseWithProtErr_invalidConfiguration;

    /* Send MCF msg to UTRAN  */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
    rrc_free(l1_mcm);
    return ;
  }

  measurement_id = rrc_mcm_ptr->measurementIdentity;
  
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  meas_owner = rrcmeas_retrieve_meas_owner(&rrc_mcm_ptr->measurementCommand,
    &measurement_id, &pos_info);

#else
  meas_owner = rrcmeas_retrieve_meas_owner(&rrc_mcm_ptr->measurementCommand,
    &measurement_id);
#endif

  MSG_HIGH("Meas Id is %d, Meas owner %d, Meas sst %d", rrc_mcm_ptr->measurementIdentity,meas_owner,rrcmeas_current_substate);

    /* Added additional check to ignore MCM if UE state is CELL_FACH and
    MCM is Intra/Inter Freq/Sys. The spec behaviour is unspecified in
  this case */

  /* Get OC status */
  oc_set_state = rrcllc_get_ordered_config_status();

  if ((((meas_owner == INTRA_FREQ) || (meas_owner == INTERNAL_MEAS)|| (meas_owner == INTER_FREQ) ||
    (meas_owner == INTER_SYS)) && (rrcmeas_current_substate != RRCMEAS_CELL_DCH))
    || ((oc_set_state == OC_SET_FOR_DCH_CELL_PCH_TRANS) || (oc_set_state == OC_SET_FOR_DCH_URA_PCH_TRANS)))
  {
    rrc_free(l1_mcm);
    return;
  }

  /* Static Analysis tool */
  if((meas_owner != UNKNOWN_MEAS) && (meas_owner != NOT_EXIST))
  {
    rrcmeas_check_meas_id_used_for_different_meas_type(meas_owner, (uint16)rrc_mcm_ptr->measurementIdentity);
  }

  if ( meas_owner ==  MAC_MEAS)
  {
    if (rrctvm_process_traffic_vol_info(rrc_mcm_ptr, transaction_id) == TVM_SUCCESS)
    {
      rrc_free(l1_mcm); 
      return;
    }
    else
    {
      /* Do not store the transaction. Meas Ctrl Failure already sent */
      rrc_free(l1_mcm);
      return;
    }

  } /* End of if of Traffic Vol Meas Id found */
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  else if ( meas_owner ==  POSITION_MEAS)
  {
    if (rrcmeas_process_pos_mcm(decoded_msg_ptr, &pos_info, transaction_id) == SUCCESS)
    {
      rrc_free(l1_mcm);
      return;
    }
  
    rrc_free(l1_mcm);
    return;
  } /* End of if of Positioning Measurements */
#endif
  else if (meas_owner == UNKNOWN_MEAS)
  {
    /* Send Meas Ctrl Failure Message */

    rrcmeas_mcf.rrc_transaction_id = transaction_id;

    /* Set error t */
    rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

    if (pos_meas_failure == TRUE)
    {
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
      pos_meas_failure = FALSE;
    }

#endif

    /* Send MCF msg to UTRAN */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
    rrc_free(l1_mcm);
    return;
  }

  else if (meas_owner == NOT_EXIST)
  {
    if(rrc_mcm_ptr->measurementCommand.t != T_rrc_MeasurementCommand_release)
    {
      /* Send Meas Ctrl Failure Message */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

      if (pos_meas_failure == TRUE)
      {
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
        pos_meas_failure = FALSE;
      }

#endif

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
    }
    else
    {
      MSG_LOW("Ignore MCM release for an nonexistent measurement, do not send MCM failure",0,0,0);
    }
    rrc_free(l1_mcm);
    return;
  }
  /* Check if it is Inter-RAT Meas */

  else if (meas_owner == INTER_SYS)
  {
    /* First check if dual mode is enabled */
    if ((rrcmcm_is_dualmode_enabled() == FALSE)
#ifdef FEATURE_WCDMA_CM_LTE_SEARCH      
        && !rrcirat_is_meas_id_eutra_meas((uint16) rrc_mcm_ptr->measurementIdentity)
#endif        
       )
    {
      /* Send Meas Ctrl Failure Message */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return;
    }

    if (rrcirat_process_mcm(rrc_mcm_ptr, transaction_id
      ,dcch_msg_ptr
      ) == SUCCESS)

    {
      if(!process_interfreq_interrat_meas_rel7)
      {
        rrc_free(l1_mcm);
        return;
      }
      rrc_free(l1_mcm);
      return;
    }
    else
    {
      rrc_free(l1_mcm);
      return;
    }
  }
  else if (meas_owner == INTERNAL_MEAS)
  {
    if (rrcueim_process_mcm(rrc_mcm_ptr, transaction_id) == SUCCESS)
    {
      if((!process_interfreq_interrat_meas_rel7) && (!process_interfreq_uei_meas_rel7))
      {
        rrc_free(l1_mcm);
        return;
      }
      rrc_free(l1_mcm);
      return;
    }
    else
    {
      rrc_free(l1_mcm);
      return;
    }
  }
  /* Check if it is Inter-Freq Meas */
  else if (meas_owner == INTER_FREQ)
  {
    if (rrcifreq_process_mcm(rrc_mcm_ptr, dcch_msg_ptr, transaction_id) == SUCCESS)
    {
      if((!process_interfreq_interrat_meas_rel7) && (!process_interfreq_uei_meas_rel7))
      {
        rrc_free(l1_mcm);
        return;
      }
      rrc_free(l1_mcm);
      return;
    }
    else
    {
      rrc_free(l1_mcm);
      return;
    }
  }

  else if (meas_owner == QUALITY_MEAS)
  {
    if (rrcqm_process_mcm(rrc_mcm_ptr, transaction_id) == SUCCESS)
    {
      rrc_free(l1_mcm);
      return;
    }
    else
    {
      rrc_free(l1_mcm);
      return;
    }
  }
  else
  {
    WRRC_MSG0_HIGH("Processing Intra-freq Measurement");
  }



  /* Make Compressed Mode Status Information as invalid so that L1 is O.K. */
  l1_mcm->dpch_cm_status_incl = FALSE;

  /* Set Compressed Mode Information */
  if ((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr,
    rrc_MeasurementControl_r3_IEs,dpch_CompressedModeStatusInfo)) &&
    (rrc_mcm_ptr->dpch_CompressedModeStatusInfo.tgp_SequenceShortList.n != 0))
  {

    if (rrcmeas_process_compressed_mode_status(&rrc_mcm_ptr->dpch_CompressedModeStatusInfo,
      &l1_mcm->cm_status_info) == FAILURE)
    {
      /* Send Meas Ctrl Failure Message */

      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return;

    }
    /* Set compressed Mode as TRUE */
    l1_mcm->dpch_cm_status_incl = TRUE;

  } /* End of if of compressed mode processing */

  /* Assign default value to Primary Meas Type */
  primary_meas_type = INTRA_FREQ;

  switch ( rrc_mcm_ptr->measurementCommand.t )
  {
  case T_rrc_MeasurementCommand_setup:
    /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

    /* Set trans Id in var trans_id */
    trans_id = l1_mcm->trans_id = transaction_id;

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, 
        rrc_MeasurementControl_r3_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

    }
    else
    {

    /* if reporting mode is set to FALSE. If it is set variable
    * CONFIGURATION_INCOMPLETE to TRUE and send a Measurement
      * Failure Message */

      WRRC_MSG0_ERROR("Meas Reporting Mode missing for SETUP");

      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return;
    }

    if (RRC_CHECK_COMMON_MSG_TYPE_PTR(rrc_mcm_ptr->measurementCommand.u.setup,
      rrc_MeasurementType_intraFrequencyMeasurement))
    {
      /* Set command type in L1 struct */
      l1_mcm->meas_cmd = L1_MEAS_SETUP;

      /* Store meas type */
      l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

      l1_mcm->meas_object_info_included = TRUE;

      /* Check if meas quantity not present */
      /* Store Meas Quantity */
      if ( (!(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
        intraFrequencyMeasurement,
        rrc_IntraFrequencyMeasurement,intraFreqMeasQuantity)) ) ||
        (!(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
        intraFrequencyMeasurement,rrc_IntraFrequencyMeasurement,reportCriteria)) ) ||
        (!(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
        intraFrequencyMeasurement,
        rrc_IntraFrequencyMeasurement,intraFreqReportingQuantity))) )
      {
        WRRC_MSG0_ERROR("Mandatory parameter for SETUP missing");
        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
        rrc_free(l1_mcm);
        return;

      }

      if((RRC_CHECK_COMMON_MSG_TYPE(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
        reportCriteria,rrc_IntraFreqReportCriteria_intraFreqReportingCriteria)) &&
        !(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
        reportCriteria.u.intraFreqReportingCriteria,
        rrc_IntraFreqReportingCriteria,eventCriteriaList)))              
      {
        WRRC_MSG0_ERROR("event criteria for SETUP missing");
        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
        rrc_free(l1_mcm);
        return;
      }
       
      /* Check if Meas Quantity is path loss and txpower is present for cells for meas */
      if (rrc_mcm_ptr->measurementCommand.u.setup->u.
        intraFrequencyMeasurement->intraFreqMeasQuantity.modeSpecificInfo.u.fdd->intraFreqMeasQuantity_FDD
        == rrc_IntraFreqMeasQuantity_FDD_pathloss)
      {
        if(rrcmeas_path_loss_check(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement)
          == RRCMEAS_FAIL)
        {
          /* path loss error*/
          WRRC_MSG0_ERROR("Path loss check failed");

          rrcmeas_mcf.rrc_transaction_id = transaction_id;

          /* Set error t */
          rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

          /* Send MCF msg to UTRAN */
          rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
          rrc_free(l1_mcm);
          return;
        }
      }


      /* Fill intra-freq meas quantity, meas validity, cell list, cell info */
      if ( (rrcmeas_fill_common_mcm_intra_f_info(
        rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement,
        l1_mcm, rel5_ext_ptr) == RRCMEAS_FAIL))
      {
        rrc_free(l1_mcm);
        return;
      }
      /* Process Additional Meas */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r3_IEs,additionalMeasurementList))
      {
        /* Call fn which makes check for additional measurements */
        if (rrcmeas_validate_additional_meas(&rrc_mcm_ptr->additionalMeasurementList, transaction_id, &primary_meas_type,
          rrc_mcm_ptr->measurementIdentity) == FALSE)
        {
          /* Called function has already sent Meas Ctrl Failure */
          /* Retain the old CELL_INFO_LIST */
          WCDMA_MEMCPY(intra_freq_cell_list, 
                       sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                       intra_freq_cell_list_temp,
                       sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);
          rrc_free(l1_mcm);
          return;
        }

        /* This means additional meas has been successfully validated */
        addtl_meas_validation = TRUE;

      } /* End of if of Additional Meas Present */

      if (rrcmeas_check_mcm_for_setup_modify_additional(
        addtl_meas_validation, INTRA_FREQ, rrc_mcm_ptr->measurementIdentity,
        &rrc_mcm_ptr->additionalMeasurementList) == FALSE)
      {
        rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
        rrc_free(l1_mcm);
        return;

      }

      if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement,
        rrc_IntraFrequencyMeasurement,measurementValidity))
      {
        /* No need to check value as by default validity is CELL_DCH and if it is not CELL_DCH,
        then assume it to be CELL_DCH. */
        meas_validity = STATE_DCH;
      }
      /* Time to store the Meas Id, validty, rpt criteria in RRC DB */
      if (rrcmeas_config_intra_freq_db(l1_mcm,meas_validity) == FALSE)
      {
        rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
        rrc_free(l1_mcm);
        return;
      }

      /* If we reached this stage, that means Meas Ctrl Msg is valid */

      /* Check if Additional Meas has been validated successfully. */
      /* If yes, then store all additional meas in RRC DB */
      if (addtl_meas_validation == TRUE)
      {
        rrcmeas_set_additional_meas_in_db(&primary_meas_type, &rrc_mcm_ptr->additionalMeasurementList,
        rrc_mcm_ptr->measurementIdentity);
      }

      /* Time to store this in Accepted transaction list after break */

      break; /* Come out of switch */


      } /* End of if of rrc_intraFrequencyMeasurement */
      else
      {
        WRRC_MSG0_ERROR("Measurement not supported");

        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
        rrc_free(l1_mcm);
        return;
      }

    case T_rrc_MeasurementCommand_modify:
      /* Set meas id in L1 struct */
      l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

      /* Set trans Id in var trans_id */
      trans_id = l1_mcm->trans_id = transaction_id;

      /* Check if rpt mode present */
      if ( RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr,
        rrc_MeasurementControl_r3_IEs,measurementReportingMode) )
      {
        MSG_LOW("Reporting Mode present", 0,0,0);

        /* Store reporting mode to TRUE */
        l1_mcm->rpt_mode_incl = TRUE;

        l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
          rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

      }
      else
      {
        /* Store reporting mode to FALSE */
        l1_mcm->rpt_mode_incl = FALSE;
      }

      /* Set command type in L1 struct */
      l1_mcm->meas_cmd = L1_MEAS_MODIFY;

      /* Set meas type to Intra-freq Meas */
      l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

      if ( !(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.modify,
        rrc_MeasurementCommand_modify,measurementType) ))
      {
        WRRC_MSG1_HIGH("Meas Type for Meas %d absent O.K", l1_mcm->meas_id);

        l1_mcm->meas_object_info_included = FALSE;

      }
      else
      {
        l1_mcm->meas_object_info_included = TRUE;

        /* Fill intra-freq meas quantity, meas validity, cell list, cell info */
        if ((rrcmeas_fill_common_mcm_intra_f_info(
          rrc_mcm_ptr->measurementCommand.u.modify->measurementType.u.intraFrequencyMeasurement,
          l1_mcm, rel5_ext_ptr) == RRCMEAS_FAIL))
        {
          rrc_free(l1_mcm);
          return;
        }

      } /* End of else of Meas Type Present */

      /* Process Additional Meas */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r3_IEs,additionalMeasurementList))
      {
        /* Call fn which makes check for additional measurements */
        if (rrcmeas_validate_additional_meas(&rrc_mcm_ptr->additionalMeasurementList, transaction_id, &primary_meas_type,
          rrc_mcm_ptr->measurementIdentity) == FALSE)
        {
          /* Retain the old CELL_INFO_LIST */
          WCDMA_MEMCPY(intra_freq_cell_list, 
                       sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                       intra_freq_cell_list_temp,
                       sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);
          /* Called function has already sent Meas Ctrl Failure */
          rrc_free(l1_mcm);
          return;
        }

        /* This means additional meas has been successfully validated */
        addtl_meas_validation = TRUE;

      /* Store the Meas Id, rpt criteria in RRC DB only if object is present  */
        if (rrcmeas_check_mcm_for_setup_modify_additional(
          addtl_meas_validation, INTRA_FREQ, rrc_mcm_ptr->measurementIdentity,
          &rrc_mcm_ptr->additionalMeasurementList) == FALSE)
        {
          rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
          rrc_free(l1_mcm);
          return;
        }
      } /* End of if of Additional Meas Present */

      if ((l1_mcm->meas_object_info_included == TRUE) &&
        (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.modify->measurementType.u.intraFrequencyMeasurement,
        rrc_IntraFrequencyMeasurement,measurementValidity)))

      {
        /* No need to check value as by default validity is CELL_DCH and if it is not CELL_DCH,
        then assume it to be CELL_DCH so that it could be resumed on next trans to CELL_DCH */
        meas_validity = STATE_DCH;
      }

      if (rrcmeas_config_intra_freq_db(l1_mcm, meas_validity) == FALSE)
      {
        rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
        rrc_free(l1_mcm);
        return;

      }
      /* Check if Additional Meas has been validated successfully. */
      /* If yes, then store all additional meas in RRC DB */
      if (addtl_meas_validation == TRUE)
      {
        rrcmeas_set_additional_meas_in_db(&primary_meas_type, &rrc_mcm_ptr->additionalMeasurementList,
        rrc_mcm_ptr->measurementIdentity);
      }


      break; /* Come out of switch */

    case T_rrc_MeasurementCommand_release:
      /* With release meas, additional meas should not be present */
      /* Set meas id in L1 struct */
      l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

      /* Set trans Id in var trans_id */
      trans_id = l1_mcm->trans_id = transaction_id;

      /* Check if rpt mode present */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r3_IEs,
        measurementReportingMode) )
      {
        MSG_LOW("Reporting Mode present", 0,0,0);

        /* Store reporting mode to TRUE */
        l1_mcm->rpt_mode_incl = TRUE;

        l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
          rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

      }
      else
      {
        /* Store reporting mode to FALSE */
        l1_mcm->rpt_mode_incl = FALSE;
      }

      /* Set command type in L1 struct */
      l1_mcm->meas_cmd = L1_MEAS_RELEASE;

      /* Store meas type */
      l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

      /* Delete Meas Id from Intra Freq Meas Id List */
      rrcmeas_delete_meas(&l1_mcm->meas_id);

      /* Delete additional meas */
      rrcmeas_delete_addtl_meas(&l1_mcm->meas_id);

      break;

    default:
      WRRC_MSG0_ERROR("Meas command t not possible");
      rrc_free(l1_mcm);
      return;

  } /* End of switch */
  alloc_idx = rrcmeas_get_int_trans_index_for_trans_id(transaction_id);
  l1_mcm->trans_id = alloc_idx;
  /* Print first 5 elements of the list for debugging purposes */
  for (cell_count = 0; cell_count < (L1_MAX_CELL_MEAS - 20); cell_count++)
  {
    MSG_MED("IntraF Element=%d,Pos=%d,psc=%d", cell_count,
      intra_freq_cell_list[PRI_FREQ][cell_count].cell_position,
      intra_freq_cell_list[PRI_FREQ][cell_count].psc);
  }

  rrcmeas_send_l1_cmd(NULL, l1_mcm, NULL, L1_MEAS_CTRL_PARMS);
  rrc_free(l1_mcm);
  return;
}


/*===========================================================================

FUNCTION  RRCMEAS_FILL_MCM_CELL_INFO

DESCRIPTION

 This function fills in Cell Info received from a
 Measurement Control Message. The function processes
 Cell Info in ASN1 format and translates into the L1
 RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill cell info correctly.
 SUCCESS: If cell info is filled correctly

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_fill_mcm_cell_info
(
rrc_CellInfo* mcm_cell_info_ptr,
l1_cell_info_struct_type* l1_cell_info_ptr
)
{
  if ( mcm_cell_info_ptr == NULL )
  {
    return(FAILURE);
  }

  l1_cell_info_ptr->cell_offset =
    mcm_cell_info_ptr->cellIndividualOffset;
  
  /* Fill in Reference Time Difference to serving cell */
  if ( RRC_MSG_COMMON_BITMASK_IE_PTR(mcm_cell_info_ptr,
    rrc_CellInfo,referenceTimeDifferenceToCell) )
  {
    /* Set reference time difference included to true */
    l1_cell_info_ptr->ref_tm_diff_incl = TRUE;

    /* Fill cell time difference */
    rrcmeas_fill_reference_time_difference(&mcm_cell_info_ptr->referenceTimeDifferenceToCell,
      l1_cell_info_ptr);

  }
  else
  {
  /* Reference time difference to cell absent
    * Set reference time difference included to false */

    l1_cell_info_ptr->ref_tm_diff_incl = FALSE;

    l1_cell_info_ptr->ref_tm_diff = 0;
    l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_40_CHIPS;
  }

  /* Initialize the following 2 to FALSE */
  /* Primary CPICH info absent */
  l1_cell_info_ptr->pri_scr_code_incl = FALSE;

  /* Primary CPICH TX power present It is an optional parameter */
  l1_cell_info_ptr->pri_cpich_txpwr_incl = FALSE;


  /* Fill in Mode Specific Info */
  if ( mcm_cell_info_ptr->modeSpecificInfo.t ==
    T_rrc_CellInfo_modeSpecificInfo_tdd)
  {

    /* Mode specific info is for TDD */
    MSG_LOW("Using default values",0,0,0);

    /* Read SFN indicator */
    l1_cell_info_ptr->rd_sfn_ind = FALSE;

    /* Read Tx Diversity indicator */
    l1_cell_info_ptr->tx_diver_ind = FALSE;

    /* Cell Select Reselect Info is absent */
    l1_cell_info_ptr->cell_sel_resel_info_incl = FALSE;

  }
  else
  {
  /* Mode specific info is for FDD
    * Pri CPICH Scrambling code and CPICH Tx Power */

    if (mcm_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_InfoPresent)
    {

      /* Primary CPICH info present */
      l1_cell_info_ptr->pri_scr_code_incl = TRUE;

      l1_cell_info_ptr->pri_scr_code = (uint16)
        mcm_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

    }

    if ( mcm_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_TX_PowerPresent)
    {

      /* Primary CPICH TX power present It is an optional parameter */

      l1_cell_info_ptr->pri_cpich_txpwr_incl = TRUE;

      /* Set its value */
      l1_cell_info_ptr->pri_cpich_txpwr =
        mcm_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_TX_Power;

    }

    /* Read SFN indicator */
    l1_cell_info_ptr->rd_sfn_ind =
      (boolean) mcm_cell_info_ptr->modeSpecificInfo.u.fdd->readSFN_Indicator;

    /* Read Tx Diversity indicator */
    l1_cell_info_ptr->tx_diver_ind =
      (boolean) mcm_cell_info_ptr->modeSpecificInfo.u.fdd->tx_DiversityIndicator;

    /* Cell Select Reselect Info is absent */
    l1_cell_info_ptr->cell_sel_resel_info_incl = FALSE;

  }

  return(SUCCESS);
}  /* rrcmeas_mcm_cell_info  */


/*===========================================================================

FUNCTION  RRCMEAS_FILL_REFERENCE_TIME_DIFFERENCE

DESCRIPTION

 This function fills in Cell Info received from a
 Measurement Control Message. The function processes
 Cell Info in ASN1 format and translates into the L1
 RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_fill_reference_time_difference
(
rrc_ReferenceTimeDifferenceToCell* time_diff_ptr,
l1_cell_info_struct_type* l1_cell_info_ptr
)
{
  if (time_diff_ptr->t == T_rrc_ReferenceTimeDifferenceToCell_accuracy40)
  {
    l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_40_CHIPS;
    l1_cell_info_ptr->ref_tm_diff = (uint16) time_diff_ptr->u.accuracy40;
  }
  else if ( time_diff_ptr->t == T_rrc_ReferenceTimeDifferenceToCell_accuracy256 )
  {
    l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_256_CHIPS;
    l1_cell_info_ptr->ref_tm_diff = (uint16) time_diff_ptr->u.accuracy256;
  }
  else
  {
    l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_2560_CHIPS;
    l1_cell_info_ptr->ref_tm_diff = (uint16) time_diff_ptr->u.accuracy2560;
  }

  return;
}



/*===========================================================================

FUNCTION  RRCMEAS_FILL_COMMON_MCM_INTRA_F_INFO

DESCRIPTION

 This function fills in common Cell Info for meas setup and
 meas modify command type in a Measurement Control Message.
 The function processes Cell Info in ASN1 format and translates
 into the L1RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill common mcm info correctly
 SUCCESS: If common mcm info filled correctly

SIDE EFFECTS

 None

===========================================================================*/

rrcmeas_status_e_type rrcmeas_fill_common_mcm_intra_f_info
(
rrc_IntraFrequencyMeasurement* intra_f_meas_ptr,
l1_meas_ctrl_parm_struct_type *l1_mcm 
, rrc_MeasurementControl_v590ext_IEs *rel5_ext_ptr
)
{
  rrc_RemovedIntraFreqCellList_removeSomeIntraFreqCells *local_remove_some_intra_freq_cells;

  /* For ease of readability */
  rrc_IntraFreqCellInfoList* intra_freq_cell_info_list_ptr = NULL;

  uint16 cell_count = 0;
  uint32 i =0;
  uint16 temp_cell_count = INVALID_CELL_COUNT; /* Some impossible invalid value*/

  uint16 removed_cell_count = 0;

  /* Stores psc from intra_freq_cell_list */
  uint16 psc = INVALID_PSC;

  uint32 cell_position = 0;

  /* Stores intra freq cell id */
  uint32 intra_freq_cell_id = 0;

  /* A list of psc which is obtained as a result of UTRAN adding cells in the
  * intra_freq_cell_list where already a cell existed. So L1 needs to be told
  * to remove these cells */
  uint16 psc_to_be_removed[L1_MAX_CELL_MEAS];

  /* Counts the no of psc to be removed [Cascading Effect count] */
  uint16 psc_removed_count = 0;

  uint16 psc_to_measure = INVALID_PSC;

  /* Stores no of cells to be measured */
  uint16 meas_cells_list[L1_MAX_CELL_MEAS];

  /* To store cell id from "Cells for Measurement" */
  uint32 cell_id;
  uint32 idx=0;
  uint16 freq_idx = 0;

  /* Indicates which cells should be measured by L1 */
  rrc_CellsForIntraFreqMeasList* cells_to_measure_ptr = NULL;
  l1_intra_freq_meas_ctrl_struct_type* l1_intra_f_mcm_ptr = &l1_mcm->meas_object.u.intra_f;

  uint8  meas_id_idx = rrcmeas_find_meas_id_idx(l1_mcm->meas_id);

  /* Initialize arrays to satusfy lint */
  for (cell_count = 0; cell_count < L1_MAX_CELL_MEAS; cell_count++)
  {
    meas_cells_list[cell_count] = 0;
    psc_to_be_removed[cell_count] = 0;
  }

  WCDMA_MEMCPY(intra_freq_cell_list_temp, 
               sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
               intra_freq_cell_list,
               sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);

  /* Assign default values */
  l1_intra_f_mcm_ptr->meas_quan_incl = FALSE;
  l1_intra_f_mcm_ptr->meas_quan.quan_type = L1_MEAS_NONE;

  /* Assign Default value to filter coefficient 0 */
  l1_intra_f_mcm_ptr->meas_quan.filter_coef = 0;

  /* Store Meas Quantity */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr,
    rrc_IntraFrequencyMeasurement,intraFreqMeasQuantity) )
  {
    /* Check if meas quan is for fdd */
    if ( RRC_CHECK_COMMON_MSG_TYPE(intra_f_meas_ptr->
      intraFreqMeasQuantity.modeSpecificInfo,
      rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd ))
    {
      /* Intra freq meas quantity for FDD mode is present */
      l1_intra_f_mcm_ptr->meas_quan_incl = TRUE;

      /* So read the value of meas quantity and filter coefficient */
      l1_intra_f_mcm_ptr->meas_quan.quan_type =
        RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
        intra_f_meas_ptr->
        intraFreqMeasQuantity.modeSpecificInfo.u.fdd->intraFreqMeasQuantity_FDD);

   
    
        /* Store filter coefficient */
        l1_intra_f_mcm_ptr->meas_quan.filter_coef = (uint16)
          RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(intra_f_meas_ptr->
          intraFreqMeasQuantity.filterCoefficient);
      

    } /* End of if for rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd  */

  } /* End of if of intra freq meas quantity not present */

  /* Initialize no of added, removed cells to 0, cell_incl to FALSE */
  for(freq_idx = 0; freq_idx < MAX_NUM_CARR; freq_idx++)
  {
    /* Initialize no of added, removed cells to 0, cell_incl to FALSE */
    l1_intra_f_mcm_ptr->cell_list_incl[freq_idx] = FALSE;
    l1_intra_f_mcm_ptr->cell_list[freq_idx].num_cell_add = 0;
    l1_intra_f_mcm_ptr->cell_list[freq_idx].num_cell_rmv = 0;

    /* Print first few elements of the list for debugging purposes */
    for (cell_count = 0; cell_count < (L1_MAX_CELL_MEAS - 20); cell_count++)
    {
       MSG_MED("Cell list %d element is %d, psc = %d", cell_count,
       intra_freq_cell_list[freq_idx][cell_count].cell_position,
       intra_freq_cell_list[freq_idx][cell_count].psc);
    }
    cell_count = 0;
  }

  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr, rrc_IntraFrequencyMeasurement,
    intraFreqCellInfoList))
  {
    WRRC_MSG0_HIGH("Cell Info list present");

    /* Set cell list present to TRUE */
    l1_intra_f_mcm_ptr->cell_list_incl[PRI_FREQ] = TRUE;


    /* Store cell info list for ease of readability */
    intra_freq_cell_info_list_ptr = &intra_f_meas_ptr->intraFreqCellInfoList;


    if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_cell_info_list_ptr,
      rrc_IntraFreqCellInfoList,removedIntraFreqCellList))
    {
      switch (intra_freq_cell_info_list_ptr->removedIntraFreqCellList.t)
      {
        WRRC_MSG1_HIGH("Remove cell list : type %d[1/2/3 : All/Some/None]",intra_freq_cell_info_list_ptr->removedIntraFreqCellList.t);
        case T_rrc_RemovedIntraFreqCellList_removeAllIntraFreqCells:
          l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv = REMOVE_ALL_INTRA_FREQ_CELLS;

          /* Reinitialize cell count */
          cell_count = 0;
          /* Update Cell_info_list variable */
          for (cell_count = 0; cell_count < L1_MAX_CELL_MEAS; cell_count++)
          {
            intra_freq_cell_list[PRI_FREQ][cell_count].cell_position = VACANT;
            intra_freq_cell_list[PRI_FREQ][cell_count].psc = INVALID_PSC;
          }
          break;

        case T_rrc_RemovedIntraFreqCellList_removeSomeIntraFreqCells:
  
          if ( intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.removeSomeIntraFreqCells== NULL )
          {
            break;
          }
          /* Store head of Link list */
          local_remove_some_intra_freq_cells =  intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.
            removeSomeIntraFreqCells;
          idx=0;
          do
          {
            intra_freq_cell_id = intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.
              removeSomeIntraFreqCells->elem[idx];
            /* Find the psc as per given cell id. This psc is given to L1 */
            if ( rrcmeas_find_psc(
              PRI_FREQ,
              &intra_freq_cell_id,
              &psc) == PSC_ABSENT)
            {
              idx++;
              continue;  
            }
            else
            {
              /* First remove cell from intra freq cell list */
              rrcmeas_remove_cellid(
               PRI_FREQ,
              &intra_freq_cell_id);

              /* Here one needs to put psc so that L1 can remove it */
              l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].rmv_cell[removed_cell_count].psc = (uint16) psc;

              removed_cell_count++; /* Increment count */
            }
            /*  Get next element in the list */
            idx++;
          } /* Continue if cond satisfied */

          while ( (intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.removeSomeIntraFreqCells->n > idx) &&
            (removed_cell_count < L1_MAX_CELL_MEAS) );

          /* Restore the head of linked list pointer */
          intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.
            removeSomeIntraFreqCells = local_remove_some_intra_freq_cells;

          /* Now store the number of actual cells sent by UTRAN */

          l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv =  removed_cell_count;
          WRRC_MSG1_HIGH("Remove: Delete %d cells", removed_cell_count);
          break;

        case T_rrc_RemovedIntraFreqCellList_removeNoIntraFreqCells:
          /* Already set removed cells to 0 */
          /* Remove: Delete no cells selected */
        break;

      default:
        break;
      } /* End of switch */

    } /* End of else of removed intra freq cells present */

    /* Reinitialize these variables */
    cell_count = 0;
    psc = 0;

    /* Check if new cells present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_cell_info_list_ptr,
      rrc_IntraFreqCellInfoList,newIntraFreqCellList))
    {
      WRRC_MSG0_HIGH("MCM:New cells to be added present");

      /* Do not check for cell order. If UTRAN messes up, its their problem */

      /* Save the Head pointer of inked List */
      
      idx=0;
      while ( ( intra_freq_cell_info_list_ptr->newIntraFreqCellList.n > idx) &&
        (cell_count < L1_MAX_CELL_MEAS) )
      {
      /* Pointer to next cell is Non-NULL and cell count
        * hasn't exceeded the max. L1 can handle */

        if ( intra_freq_cell_info_list_ptr->newIntraFreqCellList.elem[idx].
          cellInfo.modeSpecificInfo.t ==
          T_rrc_CellInfo_modeSpecificInfo_tdd)
        {
          /* Nothing doing with a TDD cell. Shun it ! */

          idx++;

          continue;

        }
        /* Fill in Cell Info */
      /* Fill the cell_info in current index of add_cell if intraFreqCellID corresponding to current index is not already used
         Otherwise, all the latest cell_info corresponding to new intraFreqCellID entry should be copied to cell_info in add_cell corresponding to earlier
         intraFreqCellID*/
      for(i=0;i<idx;i++)
      {
        if(intra_freq_cell_info_list_ptr->newIntraFreqCellList.elem[idx].intraFreqCellID == 
            intra_freq_cell_info_list_ptr->newIntraFreqCellList.elem[i].intraFreqCellID)
        {
        /*Here as there is a matching ID is found, cell_info at the earlier index will be 
          populated, so cell_count should be i. After operation on this index is done we should 
          resume from the index in cell_info which we are storing in temp_cell_count and will
          be retrieved later*/
          temp_cell_count = cell_count;
          cell_count = i;
          break;
        }
      }
      if (rrcmeas_fill_mcm_cell_info(
        &intra_freq_cell_info_list_ptr->newIntraFreqCellList.elem[idx].cellInfo,
        &l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].
        cell_info) == FAILURE)
      {
        idx++;
        continue;
      }

        /* Check if cell id present */
        if (RRC_MSG_LIST_BITMASK_IE(&intra_freq_cell_info_list_ptr->newIntraFreqCellList,
            rrc_NewIntraFreqCell,intraFreqCellID))
        {
          cell_position = intra_freq_cell_info_list_ptr->newIntraFreqCellList.elem[idx].
            intraFreqCellID;

          /* Set psc from l1_intra_f_mcm_ptr->cell_list.add_cell[cell_count].
          cell_info.pri_scr_code in the intra freq cell list at position given by
          intra_freq_cell_info_list_ptr->newIntraFreqCellList->value.
          intraFreqCellID. Call rrcmeas_update_intra_freq_cell_list to do that */

        } /*  End of if of intra-freq cell id present */
        else
        {
          cell_position = AVAILABLE_CELL_POSITION;
          /* Set psc from l1_intra_f_mcm_ptr->cell_list.add_cell[cell_count].
          cell_info.pri_scr_code in the first vacant position in intra freq cell list */
        }

        WRRC_MSG1_HIGH("Add: Cell Id position %d [100 : Not present]",cell_position);

        /* If psc contains INVALID_PSC value, then the position at which this cell
        * has been updated is empty. If it contains any other value, then this
        * psc has to be removed. This is CASCADING effect. UTRAN adds a cell at
        * a position which results in a cell which was originally at that position
        * getting deleted */

        if ( rrcmeas_update_intra_freq_cell_list_mcm(
          PRI_FREQ,
          &cell_position,
          &l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].
          cell_info.pri_scr_code, &psc) == RRCMEAS_SUCCESS)
        {
          /* PSC sucessfully stored in the cell info list variable */
          /* Now store psc in the mcm in add cell for layer1 to use psc */
          l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].psc =
            l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].
            cell_info.pri_scr_code;

    /* set this flag to true always for MCM */
          l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].measure_in_idle_pch_fach = TRUE;
          if ((psc != INVALID_PSC) && (psc_removed_count < L1_MAX_CELL_MEAS)
              && (l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv != REMOVE_ALL_INTRA_FREQ_CELLS))
          {
            /* UTRAN wants us to delete this psc. Result of CASCADING effect */
            psc_to_be_removed[psc_removed_count++] = psc;
          }
          if(temp_cell_count != INVALID_CELL_COUNT)
          {
            cell_count = temp_cell_count;
            temp_cell_count = INVALID_CELL_COUNT;
            /*cell_count should be decremented as valid temp_cell_count implies duplicate intraFreqCellID entry*/
            cell_count--;
          }
          /* Increment cell count as add cell successfully stored */
          cell_count ++;
        }  /* End of if of rrcmeas_update_intra_freq_cell_list */

        /* Read next element */
        idx++;

        if ( (cell_count == L1_MAX_CELL_MEAS) &&
          (intra_freq_cell_info_list_ptr->newIntraFreqCellList.n > idx) )
        {
        /* If there are more new cells than can be accomodated in L1
        * Cmd, print a message and hope L1 will change their capability
        * sometime. Just pass the number that L1 can handle.
          */

          WRRC_MSG0_HIGH("All Intra freq cells not included");
          break;
        }
      } /* End of while newIntraFreqCellList != NULL */
      /* Restore the head pointer */

      /* Initialize no of added cells */
      WRRC_MSG1_HIGH("Number of new intraFreq cells added are %d", cell_count);
      l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_add = cell_count;

      /* Reinitialize cell_count again */
      cell_count = 0;
      for (cell_count=0; cell_count < psc_removed_count; cell_count++)
      {
        /* Add this removed cell to the already built removed cell list for L1 */
        WRRC_MSG1_HIGH("Cascading:L1 removed cell list updated with %d psc",
          psc_to_be_removed[cell_count]);
        l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].rmv_cell[removed_cell_count++].psc =
          psc_to_be_removed[cell_count];
      }
      /* Now update the number of removed cells */
      l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv += psc_removed_count;
      MSG_LOW("Thus, L1 should be removing %d cells",
        l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv,0,0);

    } /* End of if for new intra freq cells present */


    /* Initialize no fo cells to 0 */
    l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_meas = 0;
    cell_count = 0;
    l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].cells_for_meas_incl = FALSE;
    /* Check if cells for meas present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_cell_info_list_ptr,
      rrc_IntraFreqCellInfoList,cellsForIntraFreqMeasList))
    {
      WRRC_MSG0_HIGH("Cells for meas present");
      l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].cells_for_meas_incl = TRUE;
      cells_to_measure_ptr = &intra_freq_cell_info_list_ptr->cellsForIntraFreqMeasList;
      idx=0;
      while (cells_to_measure_ptr->n > idx)
      {

        cell_id = cells_to_measure_ptr->elem[idx];
        /* Check if the cell id is present in intra_freq_cell_list VARIABLE */
        if ( rrcmeas_find_psc(
             PRI_FREQ, 
             &cell_id, &psc_to_measure) == PSC_ABSENT)
        {
          MSG_LOW("Invalid cell to measure with id = %d",
            cell_id,0,0);
        } /* End of if for psc not found */
        else
        {
          /* Store psc */
          meas_cells_list[cell_count++] = psc_to_measure;
        }

        /* Increment Ptr */
        idx++;
      } /* End of while */

      l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_meas =  cell_count;
      /* Copy cells to measure list and also no of cells to measure */
      for (cell_count = 0; cell_count < l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_meas;
      cell_count++)
      {
        l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].meas_cells_list[cell_count] =
          meas_cells_list[cell_count];
      }

    } /* End of if of rrc_cellsForIntraFreqMeasList) */

  } /* End of intra freq cell info list present */

  /* Assign default values for intra-f reporting quantity */
  l1_intra_f_mcm_ptr->intra_f_rpt_quan_incl = FALSE;

  /* Check if intra-f reporting quantity present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr, rrc_IntraFrequencyMeasurement,
    intraFreqReportingQuantity))
  {
    if ( (rrcmeas_fill_intra_freq_rep_quan(&intra_f_meas_ptr->intraFreqReportingQuantity,
      l1_intra_f_mcm_ptr)) == SUCCESS )
      l1_intra_f_mcm_ptr->intra_f_rpt_quan_incl = TRUE;

  }

  /* Initialize rpt_mode to no change */
   l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_NO_CHANGE;

  /* Set reporting cell status to FALSE */
   l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = FALSE;
  l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[PRI_FREQ] = FALSE;

#ifdef FEATURE_WCDMA_DC_HSUPA
  /* N/W may configure modify from R9 to pre R9 
   * Configure rpt crit accordingly  */
  if(CHECK_RPT_CRIT_NOT_PRESENT(SEC_FREQ))
  {
  l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_RPT_MODE_NOT_PRESENT;
    if(meas_id_idx < MAX_INTRA_FREQ_MEAS)
    {
      intra_freq_meas_id_list[meas_id_idx].rpt_crit[SEC_FREQ] = NOT_AVAILABLE;
    }
  }
  else
  {
    l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_NO_CHANGE;   
  }


  /* Set reporting cell status to FALSE */
  l1_intra_f_mcm_ptr->rpt_cell_status_incl[SEC_FREQ] = FALSE;

  /* Set reporting crit incl to FALSE */
  l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[SEC_FREQ] = FALSE;
#endif  

  /* Check if INTRA-FREQ reportCriteria (Periodic/Event) present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr, rrc_IntraFrequencyMeasurement,
    reportCriteria))
  {
    WRRC_MSG0_HIGH("Reporting crit present");
    /* Check report criteeria type */
    switch (intra_f_meas_ptr->reportCriteria.t)
    {
    case T_rrc_IntraFreqReportCriteria_intraFreqReportingCriteria:

      

      /* Check if Event triggered intraFreqReportingCriteria list present */

      if (RRC_MSG_COMMON_BITMASK_IE_PTR( intra_f_meas_ptr->reportCriteria.u.
        intraFreqReportingCriteria,rrc_IntraFreqReportingCriteria,eventCriteriaList))
      {
        /* Set event parameters */
         l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].num_event =
          rrcmeas_fill_intra_freq_event_criteria(
          intra_f_meas_ptr->reportCriteria.u.intraFreqReportingCriteria,
           l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].evt, rel5_ext_ptr, NULL, NULL);

        /* Set rpt mode criteria */
         l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_EVENT_TRIGGER_RPT;
      } /* End of if for event criteria list not present */
      else
      {
        MSG_LOW("Setting num_event to 0", 0,0,0);
        /* So set num_event in L1 structure to 0 */

         l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].num_event = 0;
      }

      break; /* Come out of switch */

    case T_rrc_IntraFreqReportCriteria_periodicalReportingCriteria:

      /* Set rpt mode criteria */
       l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_PERIODIC_RPT;


      /* Set reporting cells */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria,
        rrc_PeriodicalWithReportingCellStatus,reportingCellStatus))
      {
        WRRC_MSG0_HIGH("Rpt Cell Status present");

        if (rrcmeas_fill_no_of_reporting_cells(&intra_f_meas_ptr->reportCriteria.u.
          periodicalReportingCriteria->reportingCellStatus,
          & l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ]) == SUCCESS)
        {
           l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = TRUE;
        }
      }

      l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[PRI_FREQ] = TRUE;
  
      /* Store reporting amount */
      l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_amount=
        RRCMEAS_RET_REPORTING_AMOUNT(
        intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->
        periodicalReportingCriteria.reportingAmount);
      

      /* Store reporting interval */
      l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_interval =
        RRCMEAS_RET_PERIODIC_REPORTING_INTERVAL
        (intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->periodicalReportingCriteria.reportingInterval);

      if (intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->
        periodicalReportingCriteria.reportingInterval == rrc_ReportingIntervalLong_ril0)
      {
        WRRC_MSG0_ERROR("Periodic Rpting Intvl 0, Use 250ms");
        l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_interval = 250;
      }

      break; /* Come out of switch */


    case T_rrc_IntraFreqReportCriteria_noReporting:

       l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_NO_RPT;

      /* Set reporting cell status to FALSE */
       l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = FALSE;

      if ((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.noReporting,
        rrc_ReportingCellStatusOpt,reportingCellStatus))  &&
        ( rrcmeas_fill_no_of_reporting_cells(&intra_f_meas_ptr->reportCriteria.u.noReporting->reportingCellStatus,
        & l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ]) == SUCCESS ))
      {
           l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = TRUE;
      }

      break;

    default:

      WRRC_MSG0_ERROR("Invalid reporting criteria");
      return RRCMEAS_FAIL;

    } /* End of switch */

    if (( l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] == TRUE) &&
      (( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_VASET) ||
      ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_MSET_NUSED_FREQ) ||
      ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_ASET_MSET_NUSED_FREQ) ||
      ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_ALL_VASET_AND_MSET_NUSED_FREQ)))
    {
      WRRC_MSG1_ERROR("Rpt Cell Status invalid %d",  l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat);
      /* Retain the old CELL_INFO_LIST */

      WCDMA_MEMCPY(intra_freq_cell_list, 
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                   intra_freq_cell_list_temp,
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);

      return RRCMEAS_FAIL;
    }

  } /* End of if of rrc_reportCriteria) */

  return RRCMEAS_SUCCESS;
}


/*===========================================================================

FUNCTION          RRCMEAS_FILL_INTRA_FREQ_REP_QUAN

DESCRIPTION

 Fills intra freq reporting info obtained from MCM.
 The function processes this Info in ASN1 format and translates
 into the L1 RRC Interface format.

DEPENDENCIES

 None.

RETURN VALUE

 Success if intra freq reporting quantity filled correctly
 Failure if unable to fill intra freq reporting quantity correctly

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_fill_intra_freq_rep_quan
(
rrc_IntraFreqReportingQuantity* rrc_intra_freq_reporting_quan_ptr,
l1_intra_freq_meas_ctrl_struct_type* l1_intra_freq_mcm_ptr
)
{
  if ( rrc_intra_freq_reporting_quan_ptr == NULL )
  {
    return FAILURE;
  }

  /* Check for active set, if any reporting quantity is set for FDD */

  if (RRC_CHECK_COMMON_MSG_TYPE(rrc_intra_freq_reporting_quan_ptr->activeSetReportingQuantities.
    modeSpecificInfo,
    rrc_CellReportingQuantities_modeSpecificInfo_fdd ))
  {

    /* First store active set info */

    /* Store SFN-SFN time difference for active set */

    l1_intra_freq_mcm_ptr->aset_quan.sfn_rpt =  (l1_sfn_report_enum_type)
      rrc_intra_freq_reporting_quan_ptr->activeSetReportingQuantities.
      dummy;

    /* Store CFN-SFN time difference for active set */

    l1_intra_freq_mcm_ptr->aset_quan.cfn_sfn_delta_rpt =
      rrc_intra_freq_reporting_quan_ptr->activeSetReportingQuantities.
      cellSynchronisationInfoReportingIndicator;


    /* Store Cell identity reporting indicator for active set */

    l1_intra_freq_mcm_ptr->aset_quan.cell_id_rpt =
      rrc_intra_freq_reporting_quan_ptr->activeSetReportingQuantities.
      cellIdentity_reportingIndicator;


    /* Store ec/no  reporting indicator */
    l1_intra_freq_mcm_ptr->aset_quan.ec_no_rpt =
      rrc_intra_freq_reporting_quan_ptr->activeSetReportingQuantities.
      modeSpecificInfo.u.fdd->cpich_Ec_N0_reportingIndicator;


    /* Store rscp reporting indicator */
    l1_intra_freq_mcm_ptr->aset_quan.rscp_rpt =
      rrc_intra_freq_reporting_quan_ptr->activeSetReportingQuantities.
      modeSpecificInfo.u.fdd->cpich_RSCP_reportingIndicator;



    /* Store the path loss reporting indicator */
    l1_intra_freq_mcm_ptr->aset_quan.pathloss_rpt =
      rrc_intra_freq_reporting_quan_ptr->activeSetReportingQuantities.
      modeSpecificInfo.u.fdd->pathloss_reportingIndicator;

  }
  else
  { /* TDD mode mentioned */
    l1_intra_freq_mcm_ptr->aset_quan.cell_id_rpt = FALSE;
    l1_intra_freq_mcm_ptr->aset_quan.cfn_sfn_delta_rpt = FALSE;
    l1_intra_freq_mcm_ptr->aset_quan.ec_no_rpt = FALSE;
    l1_intra_freq_mcm_ptr->aset_quan.pathloss_rpt = FALSE;
    l1_intra_freq_mcm_ptr->aset_quan.rscp_rpt = FALSE;
    l1_intra_freq_mcm_ptr->aset_quan.sfn_rpt = L1_NO_REPORT;
  }

  /* Now set information for monitored set */


  if (RRC_CHECK_COMMON_MSG_TYPE(rrc_intra_freq_reporting_quan_ptr->monitoredSetReportingQuantities.
    modeSpecificInfo,
    rrc_CellReportingQuantities_modeSpecificInfo_fdd ))
  {

    /* Store SFN-SFN time difference for monitored set */

    l1_intra_freq_mcm_ptr->mset_quan.sfn_rpt = (l1_sfn_report_enum_type)
      rrc_intra_freq_reporting_quan_ptr->monitoredSetReportingQuantities.
      dummy;

    /* Store CFN-SFN time difference for monitored set */

    l1_intra_freq_mcm_ptr->mset_quan.cfn_sfn_delta_rpt =
      rrc_intra_freq_reporting_quan_ptr->monitoredSetReportingQuantities.
      cellSynchronisationInfoReportingIndicator;


    /* Store Cell identity reporting indicator for monitored set */

    l1_intra_freq_mcm_ptr->mset_quan.cell_id_rpt =
      rrc_intra_freq_reporting_quan_ptr->monitoredSetReportingQuantities.
      cellIdentity_reportingIndicator;

      /* Check for monitored set, if any reporting quantity is set
    for FDD */

    /* Store ec/no  reporting indicator */
    l1_intra_freq_mcm_ptr->mset_quan.ec_no_rpt =
      rrc_intra_freq_reporting_quan_ptr->monitoredSetReportingQuantities.
      modeSpecificInfo.u.fdd->cpich_Ec_N0_reportingIndicator;


    /* Store rscp reporting indicator */
    l1_intra_freq_mcm_ptr->mset_quan.rscp_rpt =
      rrc_intra_freq_reporting_quan_ptr->monitoredSetReportingQuantities.
      modeSpecificInfo.u.fdd->cpich_RSCP_reportingIndicator;

    /* Store the path loss reporting indicator */
    l1_intra_freq_mcm_ptr->mset_quan.pathloss_rpt =
      rrc_intra_freq_reporting_quan_ptr->monitoredSetReportingQuantities.
      modeSpecificInfo.u.fdd->pathloss_reportingIndicator;


  }
  else
  {  /* TDD mode mentioned */
    l1_intra_freq_mcm_ptr->mset_quan.cell_id_rpt = FALSE;
    l1_intra_freq_mcm_ptr->mset_quan.cfn_sfn_delta_rpt = FALSE;
    l1_intra_freq_mcm_ptr->mset_quan.ec_no_rpt = FALSE;
    l1_intra_freq_mcm_ptr->mset_quan.pathloss_rpt = FALSE;
    l1_intra_freq_mcm_ptr->mset_quan.rscp_rpt = FALSE;
    l1_intra_freq_mcm_ptr->mset_quan.sfn_rpt = L1_NO_REPORT;

  }

  /* Now store reporting parameters for detected cells */


  /* First check if detected cells reporting present for DCH */
  if ( (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(rrc_intra_freq_reporting_quan_ptr,
        detectedSetReportingQuantities)) &&
    (RRC_CHECK_COMMON_MSG_TYPE(rrc_intra_freq_reporting_quan_ptr->detectedSetReportingQuantities.
    modeSpecificInfo,
    rrc_CellReportingQuantities_modeSpecificInfo_fdd) ) )
  {
    /* Detected cells criteria is present. Now process further */
    l1_intra_freq_mcm_ptr->dset_quan_incl = TRUE;

    /* Now set information for detected set */

    /* Store SFN-SFN time difference for detected set */

    l1_intra_freq_mcm_ptr->dset_quan.sfn_rpt =  (l1_sfn_report_enum_type)
      rrc_intra_freq_reporting_quan_ptr->detectedSetReportingQuantities.
      dummy;

    /* Store CFN-SFN time difference for detected set */

    l1_intra_freq_mcm_ptr->dset_quan.cfn_sfn_delta_rpt =
      rrc_intra_freq_reporting_quan_ptr->detectedSetReportingQuantities.
      cellSynchronisationInfoReportingIndicator;


    /* Store Cell identity reporting indicator for detected set */

    l1_intra_freq_mcm_ptr->dset_quan.cell_id_rpt =
      rrc_intra_freq_reporting_quan_ptr->detectedSetReportingQuantities.
      cellIdentity_reportingIndicator;

    /* Check for detected set, if any reporting quantity is set for FDD */

    /* Store ecno reporting indicator */
    l1_intra_freq_mcm_ptr->dset_quan.ec_no_rpt =
      rrc_intra_freq_reporting_quan_ptr->detectedSetReportingQuantities.
      modeSpecificInfo.u.fdd->cpich_Ec_N0_reportingIndicator;


    /* Store rscp reporting indicator */
    l1_intra_freq_mcm_ptr->dset_quan.rscp_rpt =
      rrc_intra_freq_reporting_quan_ptr->detectedSetReportingQuantities.
      modeSpecificInfo.u.fdd->cpich_RSCP_reportingIndicator;



    /* Store the path loss reporting indicator */
    l1_intra_freq_mcm_ptr->dset_quan.pathloss_rpt =
      rrc_intra_freq_reporting_quan_ptr->detectedSetReportingQuantities.
      modeSpecificInfo.u.fdd->pathloss_reportingIndicator;


  }  /* End of if detected cells present */

  else
  {
    /* Detected cells criteria is present. Now process further */
    l1_intra_freq_mcm_ptr->dset_quan_incl = FALSE;

  }
  return SUCCESS;
}

/*===========================================================================

FUNCTION     RRCMEAS_SEND_MEAS_CTRL_FAILURE_MSG

DESCRIPTION

 Sends meas control failure message to UTRAN

DEPENDENCIES

 None.

RETURN VALUE

 void


SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_send_meas_ctrl_failure_msg
(
rrcmeas_mcf_struct_type* mcf_ptr
)
{
  rrc_UL_DCCH_Message *msg_ptr = NULL;
  /* Pointer to uplink DCCH message*/

  /* Logical Channel Id */
  rlc_lc_id_type ul_lc_id;

  /* L2 ack status */
  rrcsend_l2ack_status_e_type l2_ack_status;

  /* Tells if send chain is successful in sending msg */
  rrcsend_status_e_type status;


  uint32 tr_id_ext = 0;


  /* Checks whether Logical Channel entity setup for DCCH logical
  * Channel type */
  ul_lc_id = rrclcm_check_ul_rlc_lc_id(UE_LOGCHAN_DCCH,
    DCCH_AM_RADIO_BEARER_ID, UE_MODE_ACKNOWLEDGED_DATA);

  if ( ul_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND )
  {
    WRRC_MSG0_ERROR("Logical channel not found");
    return;
  }

  /* Allocate a buffer for an uplink DCCH Message */
  msg_ptr = (rrc_UL_DCCH_Message *) rrc_malloc (sizeof(struct rrc_UL_DCCH_Message));

  /* At present, Integrity check info not supported. Initialize bit_mask */
  RRC_RESET_MSG_IE_PRESENT_PTR(msg_ptr);

  /* Select the message as RRC MEASUREMENT Control failure message */
  msg_ptr->message.t = T_rrc_UL_DCCH_MessageType_measurementControlFailure;

  /* At present, critical extensions not supported. So initialise bit mask */
  RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.measurementControlFailure);

  msg_ptr->message.u.measurementControlFailure.rrc_TransactionIdentifier =
      mcf_ptr->rrc_transaction_id;
  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
  {
    if (mcf_ptr->rrc_transaction_id < MAX_REL99_TRANSACTION_ID +1)
    {
      tr_id_ext = 0;
    }
    else if (mcf_ptr->rrc_transaction_id == MAX_REL99_TRANSACTION_ID +1)
    {
      mcf_ptr->rrc_transaction_id = 0;

      tr_id_ext = mcf_ptr->rrc_transaction_id / (MAX_REL99_TRANSACTION_ID +1);
    }
    else
    {
      tr_id_ext = mcf_ptr->rrc_transaction_id / (MAX_REL99_TRANSACTION_ID +1);

      mcf_ptr->rrc_transaction_id = mcf_ptr->rrc_transaction_id % (MAX_REL99_TRANSACTION_ID +1);
    }

    MSG_LOW("RRCHS:Tr Id Ext %d, Tr Id %d", tr_id_ext, mcf_ptr->rrc_transaction_id,0);

    /* Now set the Meas Ctrl Extension */
    msg_ptr->message.u.measurementControlFailure.m.laterNonCriticalExtensionsPresent =1;

    msg_ptr->message.u.measurementControlFailure.laterNonCriticalExtensions.m.
        v590NonCriticalExtensionsPresent =1;

    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.measurementControlFailure.laterNonCriticalExtensions.
      v590NonCriticalExtensions);

    if (tr_id_ext > MAX_REL99_TRANSACTION_ID)
    {
      MSG_LOW("RRCHS:Setting Tr Id Ext to 0",0,0,0);
      msg_ptr->message.u.measurementControlFailure.laterNonCriticalExtensions.
        v590NonCriticalExtensions.measurementControlFailure_v590ext.
        rrc_TransactionIdentifier_MSP_v590ext = 0;
    }
    else
    {
      msg_ptr->message.u.measurementControlFailure.laterNonCriticalExtensions.
        v590NonCriticalExtensions.measurementControlFailure_v590ext.
        rrc_TransactionIdentifier_MSP_v590ext = (rrc_RRC_TransactionIdentifier)tr_id_ext;
    }
    msg_ptr->message.u.measurementControlFailure.rrc_TransactionIdentifier =
      (uint8)mcf_ptr->rrc_transaction_id;
    MSG_LOW("RRCHS:Tr Id %d, Ext is %d",msg_ptr->message.u.measurementControlFailure.rrc_TransactionIdentifier,
      msg_ptr->message.u.measurementControlFailure.laterNonCriticalExtensions.
      v590NonCriticalExtensions.measurementControlFailure_v590ext.rrc_TransactionIdentifier_MSP_v590ext,0);
  }

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
  {
    if (mcf_ptr->rrc_transaction_id > MAX_REL99_TRANSACTION_ID)
    {
      msg_ptr->message.u.measurementControlFailure.rrc_TransactionIdentifier = 0;
      MSG_LOW("RRCHS:Tr Is SET",0,0,0);
    }
  }

  /* Set ERROR t*/
  msg_ptr->message.u.measurementControlFailure.failureCause.t =
    mcf_ptr->error_choice;

  /* Check if error t equals FailureCauseWithProtErr_protocolError */
  if (mcf_ptr->error_choice == T_rrc_FailureCauseWithProtErr_protocolError)
  {
    msg_ptr->message.u.measurementControlFailure.failureCause.u.protocolError=
     rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation);
    
    /* Set protocol cause t */
    msg_ptr->message.u.measurementControlFailure.failureCause.u.protocolError->diagnosticsType.t =
      T_rrc_ProtocolErrorInformation_diagnosticsType_type1;

    msg_ptr->message.u.measurementControlFailure.failureCause.u.protocolError->
     diagnosticsType.u.type1 = rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorInformation_type1);

    /* Set protocol error cause */
    msg_ptr->message.u.measurementControlFailure.failureCause.u.protocolError->
      diagnosticsType.u.type1->protocolErrorCause = mcf_ptr->error_cause;

  }

    rrc_log_protocol_error( (uint8) (rrc_get_state()),
                            (uint8) RRC_PROCEDURE_MCMR,
                            (uint8) mcf_ptr->error_choice,
                            (uint8) mcf_ptr->error_cause
                          );

  /* Ack always reqd for mcf */
  l2_ack_status = RRCSEND_L2ACK_NOT_REQUIRED;

#ifdef FEATURE_QSH_EVENT_METRIC
  if(rrc_qsh_dl_committed == FALSE)
  {
    failure_ota.ul_ota_type = RRC_OTA_MEAS;
    failure_ota.msg_id = WRRC_UL_DCCH_MESSAGETYPE_MEASUREMENTCONTROLFAILURE;
    failure_ota.ul_fail_ota.ul_ota_parms.failure_cause = mcf_ptr->error_choice;
  }
  else
  {
    rrc_qsh_log_mcm_fail_params(mcf_ptr->error_choice);
  }
#endif

  /* This places SDU into RLC watermark queue */
  status =  rrcsend_send_ul_sdu(RRC_PROCEDURE_MCMR, (void *) msg_ptr,
    ul_lc_id, l2_ack_status);

  if ( status != RRCSEND_SUCCESS )
  {
    WRRC_MSG0_ERROR("Failed to send Measurement Failure Msg");
  }
  else
  {
    WRRC_MSG0_HIGH("Meas Control Failure message sent from RRC to RLC");
  }

  return;
}


/*===========================================================================

FUNCTION   rrcmeas_trash_and_send_meas_failure

DESCRIPTION
  This function send MCF for all active meas_ctrl msgs

DEPENDENCIES
  None

RETURN VALUE
  void

SIDE EFFECTS
  None
===========================================================================*/

void rrcmeas_trash_and_send_meas_failure(void)
{
  /* Keeps count of trans read */
  uint16 count = 0,  transaction_id =0;
  /* Stores MCF msg parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  /* Meas Ctrl Failure Msg would be sent */
  /* Update the Accepted Transaction Table */
  for ( count = 0; count < MAXIMUM_TRANSACTIONS; count++ )
  {
    // Remove the transaction Id from accepted transaction table
    if (rrcmeas_accepted_transaction_table[count].transaction_id != INVALID_TRANSACTION_ID)
    {
      transaction_id = rrcmeas_accepted_transaction_table[count].transaction_id;
      WRRC_MSG1_HIGH("send MEAS CTRL FAILURE, trans_id %d",transaction_id);

      // Make it invalid as transaction completely processed
      rrcmeas_accepted_transaction_table[count].transaction_id = INVALID_TRANSACTION_ID;
      rrcmeas_accepted_transaction_table[count].is_latest_trans = FALSE;
      

      /* Set transaction id */
      rrcmeas_mcf.rrc_transaction_id = (uint8)transaction_id;
      /* Set Error cause */
      rrcmeas_mcf.error_choice =
        T_rrc_FailureCauseWithProtErr_protocolError;


      /* Set protocol Error */
      rrcmeas_mcf.error_cause = rrc_ProtocolErrorCause_messageExtensionNotComprehended;

      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

    }
  }
}


/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_L1_ACK

DESCRIPTION

 Processes meas control message in DCH state and directs L1 to setup/modify/
 release measurements accordingly. If the message determined is incorrect,
 send a measurement control failure message to UTRAN

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/

void rrcmeas_process_l1_ack
(
rrc_cmd_type* cmd_ptr
)
{
  /* Stores MCF msg parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  switch (cmd_ptr->cmd.rrc_llc_cnf.ll_cnf)
  {
    case RRC_LL_CPHY_MEAS_CTRL_CNF:
      WRRC_MSG2_HIGH("MEAS_CTRL_CNF rcvd...Layer-1 rsp %d [0- reject, 1 - accept] Meas Ctrl Msg. trans id = %d",
        cmd_ptr->cmd.rrc_llc_cnf.cnf.l1_meas_ctrl_cnf.status ,cmd_ptr->cmd.rrc_llc_cnf.cnf.l1_meas_ctrl_cnf.trans_id);    

      if (cmd_ptr->cmd.rrc_llc_cnf.cnf.l1_meas_ctrl_cnf.status == TRUE)
      {
        rrcmeas_accepted_transaction_table[cmd_ptr->cmd.rrc_llc_cnf.cnf.l1_meas_ctrl_cnf.trans_id].
        transaction_id = INVALID_TRANSACTION_ID;
        rrcmeas_accepted_transaction_table[cmd_ptr->cmd.rrc_llc_cnf.cnf.l1_meas_ctrl_cnf.trans_id].
            is_latest_trans = FALSE;
        return;
      }
      else
      {
        if(rrcmeas_accepted_transaction_table[cmd_ptr->cmd.rrc_llc_cnf.cnf.l1_meas_ctrl_cnf.trans_id].is_latest_trans)
        {
          /* Set transaction id */
          rrcmeas_mcf.rrc_transaction_id =
            rrcmeas_accepted_transaction_table[cmd_ptr->cmd.rrc_llc_cnf.cnf.l1_meas_ctrl_cnf.trans_id].
            transaction_id;
    
          /* Set Error cause */
          if (cmd_ptr->cmd.rrc_llc_cnf.cnf.l1_meas_ctrl_cnf.error_cause ==
            INCOMPLETE_CONFIGURATION)
          {
            /* Set failure cause  which is INCOMPLETE_CONFIGURATION */
             rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
          }
          else if(cmd_ptr->cmd.rrc_llc_cnf.cnf.l1_meas_ctrl_cnf.error_cause == UNSUPPORTED_MEASUREMENT)
          {
             rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;
          }
          else
          {
             rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_invalidConfiguration;
          }
    
          rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
        }
        else
        {
          WRRC_MSG1_HIGH("Do not send the Meas CNF as this is not the latest of transaction id %d",
           rrcmeas_accepted_transaction_table[cmd_ptr->cmd.rrc_llc_cnf.cnf.l1_meas_ctrl_cnf.trans_id].transaction_id);
        }
        rrcmeas_accepted_transaction_table[cmd_ptr->cmd.rrc_llc_cnf.cnf.l1_meas_ctrl_cnf.trans_id].
        transaction_id = INVALID_TRANSACTION_ID;
        rrcmeas_accepted_transaction_table[cmd_ptr->cmd.rrc_llc_cnf.cnf.l1_meas_ctrl_cnf.trans_id].
            is_latest_trans = FALSE;
      } /* End of else */
      return;

    default:
      WRRC_MSG0_ERROR("Invalid cmd received");
      return;

  } /* End of switch */
}


/*===========================================================================

FUNCTION   RRCMEAS_FIND_PSC

DESCRIPTION

 Finds the primary scrambling code of the intra freq cell id. The primary
 scrambling code is returned back in psc_ptr provided. If not found,
 then psc_ptr contains INVALID_PSC

DEPENDENCIES

 None

RETURN VALUE

 PSC_ABSENT if psc absent
 PSC) if psc present

SIDE EFFECTS

 None
===========================================================================*/

psc_e_type rrcmeas_find_psc
(
uint8   freq_type,
uint32* intra_freq_cell_id_ptr,
uint16* psc_ptr
)
{
  uint16 count = 0; /* Count variable */

  for (count = 0; count < MAX_NO_OF_CELLS; count++)
  {
    if (count == (*intra_freq_cell_id_ptr))
    {
      /* Found the position for which psc needs to be returned */
      if (intra_freq_cell_list[freq_type][count].cell_position == OCCUPIED)
      {
        /* Found the good psc */
        *psc_ptr = intra_freq_cell_list[freq_type][count].psc;

        return PSC_PRESENT;
      }
      else
      {
        /* PSC at this position not valid */
        *psc_ptr = INVALID_PSC;
        return PSC_ABSENT;
      }
    } /* End of if of count == (*intra_freq_cell_id_ptr) */

  } /* End of for loop */
  WRRC_MSG0_HIGH("Rem:Incorrect cell id.Psc not found");

  return PSC_ABSENT;
}


/*===========================================================================

FUNCTION   RRCMEAS_UPDATE_INTRA_FREQ_CELL_LIST

DESCRIPTION

 Updates the intra freq cell list with new values of intra freq
 cell id. This is done on receving SIB 11 system info.The calling fn gives
 position_no_ptr indicating where to store the psc. If it
 points to AVAILABLE_CELL_POSITION, then store psc in the first
 available position in intra_freq_cell_list and and mark that
 position as occupied. If position_no_ptr points to some other
 value then store psc at the position given by that value

DEPENDENCIES

 None

RETURN VALUE

 RRCMEAS_FAILURE if intra freq cell list cannot be updated due to incorrect
 value of the intra freq cell id
 RRCMEAS_SUCCESS if intra freq cell list can be successfully updated

SIDE EFFECTS

 None
===========================================================================*/

rrcmeas_status_e_type rrcmeas_update_intra_freq_cell_list
(
uint32* position_no_ptr,
uint16* psc_ptr
)
{
  uint16 count = 0;

  /* First check if one has to add this in the first available position */
  if (*position_no_ptr == AVAILABLE_CELL_POSITION)
  {
    for (count = 0; count < MAX_NO_OF_CELLS; count++)
    {
      if (intra_freq_cell_list[PRI_FREQ][count].cell_position == VACANT)
      {
        /* Store this cell in this first available vacant position */
        intra_freq_cell_list[PRI_FREQ][count].cell_position = OCCUPIED;
        intra_freq_cell_list[PRI_FREQ][count].psc = *psc_ptr;

        return RRCMEAS_SUCCESS;
      }
    } /* End of for */
  } /* End of if of  position_no_ptr == AVAILABLE_CELL_POSITION */


  /* Now check which position the cells needs to be updated */
  for (count = 0; count < MAX_NO_OF_CELLS; count++)
  {
    if (count == *position_no_ptr)
    {
    /* We have reached the position in the array which is given by id
    * Check if there is already a cell in this position
      */

      /* Store the new psc at this position */
      intra_freq_cell_list[PRI_FREQ][count].psc = *psc_ptr;

      /* Mark the position as occupied */
      intra_freq_cell_list[PRI_FREQ][count].cell_position = OCCUPIED;
      return RRCMEAS_SUCCESS;
    }
  }
  WRRC_MSG1_ERROR("Intra-freq cell ID = %d not found", *position_no_ptr);
  return RRCMEAS_FAIL;

}

/*===========================================================================

FUNCTION   RRCMEAS_REMOVE_CELLID

DESCRIPTION

 Removes the primary scrambling code at position given by intra freq cell id
 in intra_freq_cell_list. The psc at the removed position is given back so that
 L1 can be informed of removing the particular cell.

DEPENDENCIES

 None

RETURN VALUE

 PSC_ABSENT if psc absent
 PSC) if psc present

SIDE EFFECTS

 None
===========================================================================*/

void rrcmeas_remove_cellid
(
uint8 freq_type,
uint32* intra_freq_cell_id_ptr
)
{
  uint16 count = 0; /* Count variable */

  for (count = 0; count < MAX_NO_OF_CELLS; count++)
  {
    if ((count == (*intra_freq_cell_id_ptr)) &&
      (intra_freq_cell_list[freq_type][count].cell_position == OCCUPIED))
    {
      MSG_LOW("Removing cell id at pos %d with psc %d",
        *intra_freq_cell_id_ptr,intra_freq_cell_list[freq_type][count].psc,0);

      intra_freq_cell_list[freq_type][count].cell_position = VACANT;

      intra_freq_cell_list[freq_type][count].psc =  INVALID_PSC;


    } /* End of if of count == (*intra_freq_cell_id_ptr) */

  } /* End of for loop */

  return;
}


/*===========================================================================

FUNCTION   RRCMEAS_CHECK_CELL_ORDER_ECN0

DESCRIPTION

 Checks if the cells received in SIB11/12 are in the correct order. By correct
 order, one means that the cells should be received in increasing order of
 their cell id's. If not then, ignore these cells and return RRCMEAS_FAIL.
 Consequently the cell list would not be sent to L1 as CELL_LIST_INCL
 would be set to FALSE  in meas command sent to L1

DEPENDENCIES

 None

RETURN VALUE

 RRCMEAS_FAIL if cells are not in ascending order
 RRCMEAS_SUCCESS if cells are in ascending order

SIDE EFFECTS

 None
===========================================================================*/

rrcmeas_status_e_type rrcmeas_check_cell_order_ecn0
(
 rrc_NewIntraFreqCellSI_List_ECN0   *ecn0_intra_freq_cell_list_ptr
)
{
  uint32 cell_id_list[MAX_NO_OF_CELLS];
  uint16 count=0, list_count1 =0, list_count2 = 0;



  /* Initialize cell id list to satisfy lint */
  for (count = 0; count < L1_MAX_CELL_MEAS; count++)
  {
    cell_id_list[count] = 0;
  }

  count = 0;



  /* Store cell id's in a local list and calculate total no of cells */
  while ((ecn0_intra_freq_cell_list_ptr->n > list_count1) && (count < MAX_NO_OF_CELLS))
  {

    if (ecn0_intra_freq_cell_list_ptr->elem[list_count1].m.intraFreqCellIDPresent)
    {
      /* Store cell id */
      cell_id_list[count] = ecn0_intra_freq_cell_list_ptr->elem[list_count1].intraFreqCellID;
      count++;
    }
    /* Cell id was never present which is very likely */
    list_count1++;

  }

  if (count == 0 )
  {
    WRRC_MSG0_HIGH("SIB:Cell list has no cell Id's");
    /* Return successfully as cells would now be stored
    in first available position */
    return RRCMEAS_SUCCESS;
  }
  if (count == 1)
  {
    WRRC_MSG0_HIGH("SIB: Cell list has 1 cell with id");
    /* So no comparision has to be done. */
    return RRCMEAS_SUCCESS;
  }
  /* This means that there are multiple cells in the cell list and there
  order needs to be verified */

  /* Compare 1 st with 2,3,4..... Then 2nd with 3,4,5... and so on */
  for (list_count1 = 0; list_count1 < (count-1); list_count1++)
  {
    for (list_count2 = list_count1+1; list_count2 < count; list_count2++)
    {
      if (cell_id_list[list_count1] < cell_id_list[list_count2])
      {
        /* Good. It is in order */
        continue;
      }
      WRRC_MSG2_ERROR("SIB:Cell List elements %d & %d not in order",cell_id_list[list_count1],cell_id_list[list_count2]);
      return RRCMEAS_FAIL;  /* So ignore this list in the calling fn */
    } /* End of for for list_count2 */
  }  /* End of for for list_count1 */
#ifdef DEBUG_MSG
  WRRC_MSG1_HIGH("SIB:Cell list has %d cells with Cell Id",count);
#endif
  return RRCMEAS_SUCCESS;
}


/*===========================================================================

FUNCTION   RRCMEAS_CHECK_CELL_ORDER_RSCP

DESCRIPTION

 Checks if the cells received in SIB11/12 are in the correct order. By correct
 order, one means that the cells should be received in increasing order of
 their cell id's. If not then, ignore these cells and return RRCMEAS_FAIL.
 Consequently the cell list would not be sent to L1 as CELL_LIST_INCL
 would be set to FALSE  in meas command sent to L1

DEPENDENCIES

 None

RETURN VALUE

 RRCMEAS_FAIL if cells are not in ascending order
 RRCMEAS_SUCCESS if cells are in ascending order

SIDE EFFECTS

 None
===========================================================================*/

rrcmeas_status_e_type rrcmeas_check_cell_order_rscp
(
 rrc_NewIntraFreqCellSI_List_RSCP   *rscp_intra_freq_cell_list_ptr
)
{
  uint32 cell_id_list[MAX_NO_OF_CELLS];
  uint16 count=0, list_count1 =0, list_count2 = 0;


  /* Initialize cell id list to satisfy lint */
  for (count = 0; count < L1_MAX_CELL_MEAS; count++)
  {
    cell_id_list[count] = 0;
  }

  count = 0;

  /* Store cell id's in a local list and calculate total no of cells */
  while ((rscp_intra_freq_cell_list_ptr->n > list_count1) && (count < MAX_NO_OF_CELLS))
  {

    if (rscp_intra_freq_cell_list_ptr->elem[list_count1].m.intraFreqCellIDPresent)
    {
      /* Store cell id */
      cell_id_list[count] = rscp_intra_freq_cell_list_ptr->elem[list_count1].intraFreqCellID;
      count++;
    }
    /* Cell id was never present which is very likely */
    list_count1++;

  }

  if (count == 0 )
  {
    WRRC_MSG0_HIGH("SIB:Cell list has no cell Id's");
    /* Return successfully as cells would now be stored
    in first available position */
    return RRCMEAS_SUCCESS;
  }
  if (count == 1)
  {
    WRRC_MSG0_HIGH("SIB:Cell list has only 1 cell with id");
    /* So no comparision has to be done. */
    return RRCMEAS_SUCCESS;
  }
  /* This means that there are multiple cells in the cell list and there
  order needs to be verified */

  /* Compare 1 st with 2,3,4..... Then 2nd with 3,4,5... and so on */
  for (list_count1 = 0; list_count1 < (count-1); list_count1++)
  {
    for (list_count2 = list_count1+1; list_count2 < count; list_count2++)
    {
      if (cell_id_list[list_count1] < cell_id_list[list_count2])
      {
        /* Good. It is in order */
        continue;
      }
      WRRC_MSG2_ERROR("SIB:Cell List elements %d & %d not in order",cell_id_list[list_count1],cell_id_list[list_count2]);
      return RRCMEAS_FAIL;  /* So ignore this list in the calling fn */
    } /* End of for for list_count2 */
  }  /* End of for for list_count1 */
#ifdef DEBUG_MSG
  WRRC_MSG1_HIGH("SIB:Cell list has %d cells",count);
#endif
  return RRCMEAS_SUCCESS;

}


/*===========================================================================

FUNCTION   RRCMEAS_CHECK_CELL_ORDER_MCM

DESCRIPTION

 Checks if the cells received in Measurement Ctrl Msg are in correct order.
 By correct order, one means that the cells should be received in
 increasing order of their cell id's. If not then, ignore these cells and
 return RRCMEAS_FAIL. Consequently the cell list would not be sent to L1
 as CELL_LIST_INCL would be set to FALSE    in meas command sent to L1

DEPENDENCIES

 None

RETURN VALUE

 RRCMEAS_FAIL if cells are not in ascending order
 RRCMEAS_SUCCESS if cells are in ascending order

SIDE EFFECTS

 None
===========================================================================*/

rrcmeas_status_e_type rrcmeas_check_cell_order_mcm
(
 rrc_NewIntraFreqCellList   *mcm_intra_freq_cell_list_ptr
)
{
  uint32 cell_id_list[MAX_NO_OF_CELLS];
  uint16 count=0, list_count1=0, list_count2 = 0;


  /* Initialize cell id list to satisfy lint */
  for (count = 0; count < L1_MAX_CELL_MEAS; count++)
  {
    cell_id_list[count] = 0;
  }

  count = 0;

  
  /* Store cell id's in a local list */
  while ((mcm_intra_freq_cell_list_ptr->n > list_count1) && (count < MAX_NO_OF_CELLS))
  {

    if (mcm_intra_freq_cell_list_ptr->elem[list_count1].m.intraFreqCellIDPresent)
    {
      /* Store cell id */
      cell_id_list[count] = mcm_intra_freq_cell_list_ptr->elem[list_count1].intraFreqCellID;
      count++;
    }
    /* Cell id was never present which is very likely */

    list_count1++;
  }

  if (count == 0 )
  {
    WRRC_MSG0_HIGH("Add:New Cell list has no cell Id");

    /* Return successfully as cells would now be stored
    in first available position */
    return RRCMEAS_SUCCESS;
  }
  if (count == 1)
  {
    WRRC_MSG0_HIGH("Add:New Cell list has 1 cell with id");
    /* So no comparision has to be done. */
    return RRCMEAS_SUCCESS;
  }
  /* This means that there are multiple cells in the cell list and there
  order needs to be verified */

  /* Compare 1 st with 2,3,4..... Then 2nd with 3,4,5... and so on */
  for (list_count1 = 0; list_count1 < (count-1); list_count1++)
  {
    for (list_count2 = list_count1+1; list_count2 < count; list_count2++)
    {
      if (cell_id_list[list_count1] < cell_id_list[list_count2])
      {
        /* Good. It is in order */
        continue;
      }
      WRRC_MSG2_ERROR("Cell List elements %d & %d not in order",cell_id_list[list_count1],cell_id_list[list_count2]);
      return RRCMEAS_FAIL;  /* So ignore this list in the calling fn */
    } /* End of for for list_count2 */
  }  /* End of for for list_count1 */
#ifdef DEBUG_MSG
  WRRC_MSG0_HIGH("Cells received in MCM are in order");
#endif
  return RRCMEAS_SUCCESS;
}


/*===========================================================================

FUNCTION   RRCMEAS_UPDATE_INTRA_FREQ_CELL_LIST_MCM

DESCRIPTION

 Updates the intra freq cell list with new values of intra freq
 cell id. This is done on receving Meas Ctrl Message. The calling
 function givesposition_no_ptr indicating where to store the psc. If it
 points to AVAILABLE_CELL_POSITION, then store psc in the first
 available position in intra_freq_cell_list and and mark that
 position as occupied. If position_no_ptr points to some other
 value then store psc at the position given by that value. It returns as
 a output parameter in psc_to_remove_ptr, the psc to be removed

DEPENDENCIES

 None

RETURN VALUE

 RRCMEAS_FAILURE if intra freq cell list cannot be updated due to incorrect
 value of the intra freq cell id
 RRCMEAS_SUCCESS if intra freq cell list can be successfully updated

SIDE EFFECTS

 None
===========================================================================*/

rrcmeas_status_e_type rrcmeas_update_intra_freq_cell_list_mcm
(
uint8   freq_type,
uint32* position_no_ptr,
uint16* psc_ptr,
uint16* psc_to_remove_ptr
)
{
  uint16 count = 0;

 /* First check if one has to add this in the first available position */
  if (*position_no_ptr == AVAILABLE_CELL_POSITION)
  {
    for (count = 0; count < MAX_NO_OF_CELLS; count++)
    {
      if (intra_freq_cell_list[freq_type][count].cell_position == VACANT)
      {
        /* Store this cell in this first available vacant position */
        intra_freq_cell_list[freq_type][count].cell_position = OCCUPIED;
        intra_freq_cell_list[freq_type][count].psc = *psc_ptr;
        *psc_to_remove_ptr = INVALID_PSC;
#ifdef DEBUG_MSG
        WRRC_MSG2_HIGH("Add:Cell added at pos %d with psc = %d",count,*psc_ptr);
#endif

        /* Set psc_to_remove_ptr to INVALID_PSC so that calling fn
        * does not need to update this */
        return RRCMEAS_SUCCESS;
      }
    } /* End of for */
  } /* End of if of  position_no_ptr == AVAILABLE_CELL_POSITION */

  /* Now check which position the cells needs to be updated */
  for (count = 0; count < MAX_NO_OF_CELLS; count++)
  {
  /*  Check if there is already a cell in this position
  *  If yes, then this cell has to be removed and L1
    *  has to be informed about it. So store its psc  */

    if ( (count == *position_no_ptr) &&
      (intra_freq_cell_list[freq_type][count].cell_position == OCCUPIED) )
    {
#ifdef DEBUG_MSG
      MSG_HIGH("Add:PSC %d at pos. %d is removed[Cascading] by %d",
        intra_freq_cell_list[freq_type][count].psc,count,*psc_ptr);
#endif

      /* Store the removed psc */
      *psc_to_remove_ptr = intra_freq_cell_list[freq_type][count].psc;

      /* Store the new psc at this position */
      intra_freq_cell_list[freq_type][count].psc = *psc_ptr;

      return RRCMEAS_SUCCESS;
    }
    else if ( (count == *position_no_ptr) &&
      (intra_freq_cell_list[freq_type][count].cell_position == VACANT) )
    {

      /* Store the new psc at this position */
      intra_freq_cell_list[freq_type][count].psc = *psc_ptr;

      /* Mark the position as occupied. NOT REQD */
      intra_freq_cell_list[freq_type][count].cell_position = OCCUPIED;

      /* No psc to be removes as this place is vacant */
      *psc_to_remove_ptr = INVALID_PSC;

      return RRCMEAS_SUCCESS;

    } /* End of else if */
  } /* End of for */
  WRRC_MSG1_ERROR("Intra-freq cell ID = %d not valid", *position_no_ptr);
  return RRCMEAS_FAIL;

}


/*===========================================================================

FUNCTION   RRCMEAS_SET_INTRA_FREQ_MEAS_IDENTITY

DESCRIPTION

 Set intra freq meas identity variable from SIB information.

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/

void rrcmeas_set_intra_freq_meas_identity
(
l1_intra_freq_sib_struct_type* l1_intra_freq_ptr
)
{
  uint8 cnt = 0;

  /* First check if the meas id already exists */

  for ( cnt = 0; cnt < MAX_INTRA_FREQ_MEAS; cnt++ )
  {
    if (intra_freq_meas_id_list[cnt].meas_id == l1_intra_freq_ptr->meas_id)
    {
      intra_freq_meas_id_list[cnt].mcm_owned = FALSE;
      /* Set Validity to NOT) to indicate that it needs to be deleted after trans from CELL_DCH */
      intra_freq_meas_id_list[cnt].meas_validity = NOT_PRESENT;

       intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ] = NOT_AVAILABLE;
#ifdef FEATURE_WCDMA_DC_HSUPA
      intra_freq_meas_id_list[cnt].rpt_crit[SEC_FREQ] = NOT_AVAILABLE;
#endif
      if (l1_intra_freq_ptr->intra_f_dch_rpt_info_incl == TRUE)
      {
         intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ] = MEAS_RPT_CRIT(
          l1_intra_freq_ptr->dch_rpt_info.rpt_mode);
      }
      else
      {
        /* Rpt Criteria not present */
         intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ] = NOT_AVAILABLE;
      }

      MSG_HIGH("Found in db...Commit Meas=%d,Crit=%d,Val=%d",l1_intra_freq_ptr->meas_id,
        intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ],intra_freq_meas_id_list[cnt].meas_validity);

#ifdef FEATURE_WCDMA_DC_HSUPA
       WRRC_MSG1_HIGH("Crit_Sec : %d",
       intra_freq_meas_id_list[cnt].rpt_crit[SEC_FREQ]);
#endif

      return;
    }
  } /* End of for loop */

  for ( cnt = 0; cnt < MAX_INTRA_FREQ_MEAS; cnt++ )
  {
    if (intra_freq_meas_id_list[cnt].meas_id == INVALID_MEAS_ID)
    {
      intra_freq_meas_id_list[cnt].meas_id = l1_intra_freq_ptr->meas_id;

      /* Set Validity to NOT_PRESENT to indicate that it needs to be deleted after trans from CELL_DCH */
      intra_freq_meas_id_list[cnt].meas_validity = NOT_PRESENT;

      intra_freq_meas_id_list[cnt].mcm_owned = FALSE;

      if (l1_intra_freq_ptr->intra_f_dch_rpt_info_incl == TRUE)
      {
         intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ] = MEAS_RPT_CRIT(l1_intra_freq_ptr->dch_rpt_info.rpt_mode);
      }
      else
      {
        /* Rpt Criteria not present */
        intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ] = NOT_AVAILABLE;
#ifdef FEATURE_WCDMA_DC_HSUPA
        intra_freq_meas_id_list[cnt].rpt_crit[SEC_FREQ] = NOT_AVAILABLE;
#endif

      }

      MSG_HIGH("Commit Meas=%d,Crit=%d,Val=%d",l1_intra_freq_ptr->meas_id,
        intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ],intra_freq_meas_id_list[cnt].meas_validity);

#ifdef FEATURE_WCDMA_DC_HSUPA
      WRRC_MSG1_HIGH("Rpt Crit Sec : %d",
        intra_freq_meas_id_list[cnt].rpt_crit[SEC_FREQ]);
#endif

      return;
    }
  } /* End of for loop */
  WRRC_MSG0_ERROR("RRC Intra Freq Meas DB full!!!");
}


/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_MAC_ACK

DESCRIPTION

 Processes ack from MAC

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/

void rrcmeas_process_mac_ack
(
rrc_cmd_type* cmd_ptr
)
{
  /* Stores MCF msg parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  if (cmd_ptr->cmd.mac_meas_ctrl_cnf.status == TRUE)
  {
    rrcmeas_accepted_transaction_table[cmd_ptr->cmd.mac_meas_ctrl_cnf.config_ack_num].
    transaction_id = INVALID_TRANSACTION_ID;
    rrcmeas_accepted_transaction_table[cmd_ptr->cmd.mac_meas_ctrl_cnf.config_ack_num].
    is_latest_trans = FALSE;
    return;
  }
  else
  {
    // Send meas ctrl failure msg
    WRRC_MSG0_HIGH("MAC rejected Meas Ctrl Msg");
    if(rrcmeas_accepted_transaction_table[cmd_ptr->cmd.mac_meas_ctrl_cnf.config_ack_num].is_latest_trans)
    {
      /* Set transaction id */
      rrcmeas_mcf.rrc_transaction_id =
        rrcmeas_accepted_transaction_table[cmd_ptr->cmd.mac_meas_ctrl_cnf.config_ack_num].
        transaction_id;

      /* Set faliure t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_protocolError;
      rrcmeas_mcf.error_cause = rrc_ProtocolErrorCause_ie_ValueNotComprehended;
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
    }
    else
    {
      WRRC_MSG1_HIGH("Do not send the Meas CNF as this is not the latest of transaction id %d",
       rrcmeas_accepted_transaction_table[cmd_ptr->cmd.mac_meas_ctrl_cnf.config_ack_num].transaction_id);
    }
    rrcmeas_accepted_transaction_table[cmd_ptr->cmd.mac_meas_ctrl_cnf.config_ack_num].
    transaction_id = INVALID_TRANSACTION_ID;
    rrcmeas_accepted_transaction_table[cmd_ptr->cmd.mac_meas_ctrl_cnf.config_ack_num].
        is_latest_trans = FALSE;
    return;


  } /* End of else */
}

/*===========================================================================

FUNCTION   RRCMEAS_FIND_MEAS_OWNER

DESCRIPTION

 Finds the owner of measurement identity given in a MCM.

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/

rrcmeas_layer_e_type rrcmeas_retrieve_meas_owner
(
rrc_MeasurementCommand* mcm_ptr,
uint32* meas_id_ptr
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
,pos_info_struct_type* pos_info_ptr
#endif
)
{
  uint8 count = 0;

  boolean meas_found = FALSE;
  /* First find if Meas is Setup/Modify/Delete */
  switch(mcm_ptr->t)
  {
    case T_rrc_MeasurementCommand_setup:
      WRRC_MSG1_HIGH("MCM Setup: Meas ==> %d",mcm_ptr->u.setup->t);

      if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_trafficVolumeMeasurement)
      {
        return MAC_MEAS;
      }
      else
      {
        /* Find the actual L1 owner */
        if (mcm_ptr->u.setup->t ==
          T_rrc_MeasurementType_intraFrequencyMeasurement)
        {
          return INTRA_FREQ;
        }
        else if (mcm_ptr->u.setup->t ==
          T_rrc_MeasurementType_interRATMeasurement)
        {
          return INTER_SYS;
        }
        else if (mcm_ptr->u.setup->t ==
          T_rrc_MeasurementType_interFrequencyMeasurement)
        {
          return INTER_FREQ;
        }
        else if (mcm_ptr->u.setup->t ==
          T_rrc_MeasurementType_ue_InternalMeasurement)
        {
          return INTERNAL_MEAS;
        }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
        else if (mcm_ptr->u.setup->t ==
          T_rrc_MeasurementType_ue_positioning_Measurement)
        {
          /* Also check in reporting quantity what type of meas is that */
          if ((mcm_ptr->u.setup->u.ue_positioning_Measurement->ue_positioning_ReportingQuantity.
            positioningMethod == rrc_PositioningMethod_otdoa) ||
            (mcm_ptr->u.setup->u.ue_positioning_Measurement->ue_positioning_ReportingQuantity.
            positioningMethod == rrc_PositioningMethod_cellID))
          {
            WRRC_MSG1_ERROR("PosMethod=%d unsupported 0/1/2/3 OTD/G/Both/Id",
              mcm_ptr->u.setup->u.ue_positioning_Measurement->ue_positioning_ReportingQuantity.positioningMethod);
            pos_meas_failure = TRUE;
            return UNKNOWN_MEAS;
          }
          /* Store position method and pos cmd */
          pos_info_ptr->pos_meas_cmd = RRC_MEAS_SETUP;
          pos_info_ptr->pos_method_type = RET_POS_METHOD
            (mcm_ptr->u.setup->u.ue_positioning_Measurement->
            ue_positioning_ReportingQuantity.positioningMethod);

          return POSITION_MEAS;
        }
#endif

        else if (mcm_ptr->u.setup->t ==
          T_rrc_MeasurementType_qualityMeasurement)
        {
          return QUALITY_MEAS;
        }
        else
        {
          /* Else some other Meas */
          return UNKNOWN_MEAS;
        }
      }

    case T_rrc_MeasurementCommand_modify:
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(mcm_ptr->u.modify,
        rrc_MeasurementCommand_modify,measurementType))
      {
        WRRC_MSG1_HIGH("MCM:Modify, Meas Type included %d",mcm_ptr->u.modify->measurementType.t);

        if (mcm_ptr->u.modify->
          measurementType.t == T_rrc_MeasurementType_trafficVolumeMeasurement)
        {
          for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
          {
            if (tvm_meas_id_list[count].meas_id == *meas_id_ptr)
            {
              return MAC_MEAS;
            } /* End of if of meas_identity found */
          } /* End of for loop  */

          if (meas_found == FALSE)
          {
            return NOT_EXIST;
          }
        } /* End of if of Traffic Volume Meas */
        else if (mcm_ptr->u.modify->
          measurementType.t ==
          T_rrc_MeasurementType_interRATMeasurement)
        {
          for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
          {
            if (inter_rat_meas_id_list[count].meas_id == *meas_id_ptr)
            {
              return INTER_SYS;
            }
          }
          if (meas_found == FALSE)
          {
            return NOT_EXIST;
          }
        }
        else if (mcm_ptr->u.modify->
          measurementType.t ==
          T_rrc_MeasurementType_ue_InternalMeasurement)
        {
          for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
          {
            if (ueim_meas_id_list[count].meas_id == *meas_id_ptr)
            {
              return INTERNAL_MEAS;
            }
          }
          if (meas_found == FALSE)
          {
            return NOT_EXIST;
          }
        }
        else if (mcm_ptr->u.modify->
          measurementType.t ==
          T_rrc_MeasurementType_interFrequencyMeasurement)
        {
          for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
          {
            if (inter_freq_meas_id_list[count].meas_id == *meas_id_ptr)
            {
              return INTER_FREQ;
            }
          }
          if (meas_found == FALSE)
          {
            return NOT_EXIST;
          }
        }
        else if (mcm_ptr->u.modify->
          measurementType.t ==
          T_rrc_MeasurementType_intraFrequencyMeasurement)
        {
          for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
          {
            if (intra_freq_meas_id_list[count].meas_id == *meas_id_ptr)
            {
              return INTRA_FREQ;
            }
          } /* End of for loop */
          if (meas_found == FALSE)
          {
            return NOT_EXIST;
          }
        } /* End of else if */

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
        else if (mcm_ptr->u.modify->
          measurementType.t ==
          T_rrc_MeasurementType_ue_positioning_Measurement)
        {
          for ( count = 0; count < MAX_POS_MEAS; count++ )
          {
            if (pos_meas_id_list[count].meas_id == *meas_id_ptr)
            {
              /* Store position method and pos cmd */
              pos_info_ptr->pos_meas_cmd = RRC_MEAS_MODIFY;
              pos_info_ptr->pos_method_type =
                RET_POS_METHOD(mcm_ptr->u.modify->measurementType.u.ue_positioning_Measurement->
                ue_positioning_ReportingQuantity.positioningMethod);

              return POSITION_MEAS;
            }
          }
          if (meas_found == FALSE)
          {
            return NOT_EXIST;
          }
        }
#endif
      else if (mcm_ptr->u.modify->
        measurementType.t ==
        T_rrc_MeasurementType_qualityMeasurement)
      {
        for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
        {
          if (quality_meas_id_list[count].meas_id == *meas_id_ptr)
          {
            return QUALITY_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
      else
      {
        return UNKNOWN_MEAS;
      }

    } /* End of if of modify  rrc_measurementType_present */
    else
    { /* Since Meas Type is not given. It must exist at UE.
      If not then send an error msg indicating
      unsupported measurement */

      /* First search in L1 Measurement ID List */

      for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
      {
        if (intra_freq_meas_id_list[count].meas_id == *meas_id_ptr)
        {
          return INTRA_FREQ;
        }

      } /* End of for loop */

      /* Search in Traffic Volume List */

      for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
      {
        if (tvm_meas_id_list[count].meas_id == *meas_id_ptr)
        {
          return MAC_MEAS;
        } /* End of if of meas_identity found */

      } /* End of for loop */


      for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
      {
        if (inter_rat_meas_id_list[count].meas_id == *meas_id_ptr)
        {
          return INTER_SYS;
        }

      }


#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      for ( count = 0; count < MAX_POS_MEAS; count++ )
      {
        if (pos_meas_id_list[count].meas_id == *meas_id_ptr)
        {
          pos_info_ptr->pos_meas_cmd = RRC_MEAS_MODIFY;
          pos_info_ptr->pos_method_type = pos_meas_id_list[count].pos_method_type;
          return POSITION_MEAS;
        }

      }
#endif
      for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
      {
        if (inter_freq_meas_id_list[count].meas_id == *meas_id_ptr)
        {
          return INTER_FREQ;
        }
      }
      for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
      {
        if (ueim_meas_id_list[count].meas_id == *meas_id_ptr)
        {
          return INTERNAL_MEAS;
        }

      }
      for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
      {
        if (quality_meas_id_list[count].meas_id == *meas_id_ptr)
        {
          return QUALITY_MEAS;
        }
      }
      return NOT_EXIST;

    } /* End of else of meas_type not present */


  case T_rrc_MeasurementCommand_release:
    /* First search in L1 Measurement ID List */

    for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
    {
      if (intra_freq_meas_id_list[count].meas_id == *meas_id_ptr)
      {
        return INTRA_FREQ;
      }

    } /* End of for loop */

    /* Search in Traffic Volume List */

    for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
    {
      if (tvm_meas_id_list[count].meas_id == *meas_id_ptr)
      {
        return MAC_MEAS;
      } /* End of if of meas_identity found */

    } /* End of for loop */


    for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
    {
      if (inter_rat_meas_id_list[count].meas_id == *meas_id_ptr)
      {
        return INTER_SYS;
      }

    }

    for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
    {
      if (inter_freq_meas_id_list[count].meas_id == *meas_id_ptr)
      {
        return INTER_FREQ;
      }
    }
    for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
    {
      if (ueim_meas_id_list[count].meas_id == *meas_id_ptr)
      {
        return INTERNAL_MEAS;
      }

    }
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
    for ( count = 0; count < MAX_POS_MEAS; count++ )
    {
      if (pos_meas_id_list[count].meas_id == *meas_id_ptr)
      {
        pos_info_ptr->pos_meas_cmd = RRC_MEAS_DELETE;
        return POSITION_MEAS;
      }

    }
#endif

    for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
    {
      if (quality_meas_id_list[count].meas_id == *meas_id_ptr)
      {
        return QUALITY_MEAS;
      }
    }

    return NOT_EXIST;

  default:
    return UNKNOWN_MEAS;

  } /* End of switch */

}


/*===========================================================================

  FUNCTION     RRCMEAS_VALIDATE_INTRA_FREQ_REPORT

DESCRIPTION

  Processes the Intra-freq Measurement Report from L1 and checks if
  the parameters sent in the report are valid. If the parameter/s are
  found to be invalid, the measurement report is trashed.

DEPENDENCIES

  None.

RETURN VALUE

  None.

SIDE EFFECTS

  Trashing Measurement Report may result in Soft Hand Off not working properly

===========================================================================*/

rrcmeas_status_e_type rrcmeas_validate_intra_freq_report
(
 l1_meas_rpt_struct_type* l1_meas_report_ptr
)
{
  uint8 psc_number = 0;
  uint8 cell_number = 0;
  uint8 freq_idx = 0;

  while(freq_idx < MAX_NUM_CARR)
  {
    MSG_4(MSG_SSID_DIAG, MSG_LEGACY_HIGH,
       "Validating intra freq rpt : rpt crit %d, no of cells event %d, meas result incl %d, no of meas cells %d",
       l1_meas_report_ptr->u.intra_f_rpt[freq_idx].rpt_crit,
       l1_meas_report_ptr->u.intra_f_rpt[freq_idx].num_cells_for_evt,
       l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell_meas_result_incl,
       l1_meas_report_ptr->u.intra_f_rpt[freq_idx].num_cells);
  
    /* Validity check for primary frequency */
    if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].rpt_crit == L1_EVENT_TRIGGER_RPT)
    {
      if ((l1_meas_report_ptr->u.intra_f_rpt[freq_idx].num_cells_for_evt == 0) ||
          (l1_meas_report_ptr->u.intra_f_rpt[freq_idx].num_cells_for_evt > L1_MAX_CELL_MEAS))
      {
        return  RRCMEAS_FAIL;
      }
 
    /* Filling event results */
      for ( psc_number = 0; psc_number <  l1_meas_report_ptr->u.intra_f_rpt[freq_idx].num_cells_for_evt;
        psc_number++ )
      {
        if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell_psc[psc_number] > MAX_PSC)
        {
          WRRC_MSG1_ERROR("Invalid PSC = %d. Trash Meas Report",  l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell_psc[psc_number]);
          return  RRCMEAS_FAIL;
        }
      }
    } /* End of if Event Triggered Report */

    /* Now validate periodic results */
    if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell_meas_result_incl == TRUE)
    {
      /* Now validate Measured Results */
      for ( cell_number = 0; (cell_number <  l1_meas_report_ptr->u.intra_f_rpt[freq_idx].num_cells)
        && ( cell_number < L1_MAX_CELL_MEAS ); cell_number++ )
      {
        if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].sfn_rpt_ind == L1_NO_REPORT)
        {
          MSG_LOW("SFN SFN observed time diff not set", 0,0,0);
        }
        else
        {
          /* Store sfn-sfn type indicator */
          if (  l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].sfn_rpt_ind == L1_REPORT_TYPE_1)
          {
            MSG_LOW("sfn-sfn type 1 selected",0,0,0);
            /* Type 1 report */
            if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].sfn_sfn_tm_diff <=
              SFN_SFN_TYPE1_MAX_VALUE)
            {
              /* This is fine */
            }
            else
            {
              WRRC_MSG1_ERROR("Incorrect SFN-SFN Type1 value %d. Trash Meas Report",
               l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].sfn_sfn_tm_diff);
              return  RRCMEAS_FAIL;
            }
          }
          else
          {
            /* Type 2 report */
            if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].sfn_sfn_tm_diff <=
              SFN_SFN_TYPE2_MAX_VALUE)
            {
              /* This is fine too */
            }
            else
            {
              WRRC_MSG1_ERROR("Incorrect SFN-SFN Type2 value %d. Trash Meas Report",
                 l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].sfn_sfn_tm_diff);
              return  RRCMEAS_FAIL;
            }
          }
        } /* End of else of L1_NO_REPORT */

        /* Check if cell sync info present */
        if (  l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].cell_sync_info_incl == TRUE )
        {
          /* Set off value */
          if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].cell_sync_info.off <= OFF_MAX)
          {
            /* This is O.K. */
          }
          else
          {
            WRRC_MSG1_ERROR("Off value %d not in range. Trash Meas Report",
             l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].cell_sync_info.off);
            return  RRCMEAS_FAIL;
          }

          /* Store tm value */
          if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].cell_sync_info.tm <= TM_MAX)
          {
            /* This is o.k too */
          }
          else
          {
            WRRC_MSG1_ERROR("Tm value %d not in range. Trash Meas Report",
              l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].cell_sync_info.tm);
            return  RRCMEAS_FAIL;
          }
        } /* End of if of rrc_cellSynchronisationInfo_present */

        /* Check primary scrambling code */
        if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].pri_scr_code > MAX_PSC)
        {
          WRRC_MSG1_ERROR("Invalid PSC = %d. Trash Meas Report",   l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].pri_scr_code);
          return  RRCMEAS_FAIL;
        }

        /* Check meas value */
        /* Set meas quantity value */

        /* This is fine */
        /* Check if rscp included */
        if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].rscp_included == TRUE)
        {
          if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].rscp_val <= RSCP_MAX_VALUE)
          {
            /* This is fine */
          }
          else
          {
            WRRC_MSG1_ERROR("Incorrect attached RSCP value %d received. Trash Meas Report",
             l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].rscp_val);
            return  RRCMEAS_FAIL;
          }
          if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
            && ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].delta_rscp_included == TRUE))
          {
            if(( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].delta_rscp > DELTA_RSCP_MAX)
              || ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].delta_rscp < DELTA_RSCP_MIN))
            {
               WRRC_MSG1_ERROR("Delta RSCP not in range -5..-1 %d received. Trash Meas Report",
                  l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].delta_rscp);
               return  RRCMEAS_FAIL;
            }
          }
        }

        if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].ec_no_included == TRUE)
        {
          if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].ec_no_val <= ECN0_MAX_VALUE)
          {
            /* This is fine */
          }
          else
          {
            WRRC_MSG1_ERROR("Incorrect attached EcN0 value %d received. Trash Meas Report",
             l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].ec_no_val);
            return  RRCMEAS_FAIL;
          }
        }

        if( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].pathloss_included == TRUE)
        {
          if ( ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].pathloss_val < PATH_LOSS_MIN_VALUE) ||
            ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].pathloss_val > PATH_LOSS_MAX_VALUE) )
          {
            WRRC_MSG1_ERROR("Incorrect Path Loss value %d received. Trash Meas Report",
               l1_meas_report_ptr->u.intra_f_rpt[freq_idx].cell[cell_number].pathloss_val);
            return  RRCMEAS_FAIL;
          }
        }
      } /* End of for loop */
    } /* End Of Meas Results Included */
    freq_idx++;
  }

  WRRC_MSG0_HIGH("Validation successfull");
  return RRCMEAS_SUCCESS;
}


/*===========================================================================

FUNCTION   RRCMEAS_CONFIG_L1_MEAS_ON_TRANSITION_BY_OTHER_MSG

DESCRIPTION

  Processes the secnario when the transition from DCH-->FACH is
  as a result of radio link failure and the default intra-freq
  measurement needs to be deleted. CELL_INFO_LIST variable
  is cleared. The function tries to read
  SIB11 of the new cell and if SIB11 is valid, it updates the
  MEASUREMENT_IDENTIY variable and also re-configures L1 with
  with Stop & Overwrite command.

DEPENDENCIES

  None

RETURN VALUE

  None

SIDE EFFECTS

  If SIB11 is not valid, then no intra-freq measurements would be done.

===========================================================================*/

void rrcmeas_config_l1_meas_on_transition_by_other_msg
(
 void
)
{

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
  uint8  l1_deferred_meas_from_sib_action = 0;
#endif

  uint8 cnt = 0;
  l1_meas_ctrl_enum_type meas_choice;
  rrc_SysInfoType12 *sib12_ptr;

  boolean delete_inter_freq_meas = FALSE;

  boolean delete_intra_freq_meas = FALSE;

  /* First clear the SIB info */
  rrcmeas_clear_sib11();

  sib12_present = SIB12_ABSENT;

  rrcmeas_initialize_cell_list();
  rrcifreq_initialize_cell_list();
  /* Trash CM params from TOC config */
  rrcllc_initialize_cm_parms();
  state_transition_meas->hcs_used = FALSE;

  WRRC_MSG0_HIGH("Trash all intra-freq meas,Read SIB11");

  /* Check if any valid meas exists. If yes, delete it from DB and tell L1 */
  for (cnt = 0; cnt < MAX_INTRA_FREQ_MEAS; cnt++)
  {
    if (intra_freq_meas_id_list[cnt].meas_id != INVALID_MEAS_ID)
    {
      /* Delete this meas from any Addtl Meas List */
      rrcmeas_delete_addtl_meas(&intra_freq_meas_id_list[cnt].meas_id);

      rrcmeas_delete_meas(&intra_freq_meas_id_list[cnt].meas_id);

      delete_intra_freq_meas = TRUE;
    }
  }
  if (delete_intra_freq_meas == TRUE)
  {
    /* Set Meas Type */
    state_transition_meas->meas_type = L1_INTRA_FREQ;

    /* Set Measurement Action */
    state_transition_meas->meas_action = L1_MEAS_DELETE_ALL;

    MSG_LOW("Indicate L1: Del all IntraFreqMeas",0,0,0);

    /* Send Command to L1 */
    rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);


  }
  state_transition_meas->fach_meas_incl = FALSE;
  /* Read SIB 11 again for the new cell and send it to L1 */

  /* save the meas id list in a temp variable */
  /* temporary intra freq meas id list */
  WCDMA_MEMCPY(tmp_intra_freq_meas_id_list, 
               MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
               intra_freq_meas_id_list, 
               MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
  if(rrcsib_is_sib11_11bis_12_read_deferred(DEFERRED_SIB11))
  {
    l1_deferred_meas_from_sib_action = CLEAR_CELL_INFO_LIST;
    l1_deferred_meas_from_sib_action |= CLEAR_MEAS_IDENTITY;
    rrcmeas_send_deferred_meas_req(l1_deferred_meas_from_sib_action);
  }
  else
#endif
  if ( rrcmeas_read_sib11() == FAILURE )
  {
    WRRC_MSG0_ERROR("Intra-Freq SIB 11 invalid");
    rrcmeas_clear_sib11();
  }
  else
  {
    /* check for SIB 12 and use it if present */
    if ( sib12_present == SIB12_ABSENT )
    {
      MSG_LOW("SIB12 not present", 0,0,0);
    }
    else
    {
      WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

      if((sib12_ptr = (rrc_SysInfoType12*)
        rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
      {
        WRRC_MSG0_HIGH("SIB 12 empty.");
      }
      else
      {
        WRRC_MSG0_HIGH("Undo changes to Meas id varible from SIB11");
        WCDMA_MEMCPY(intra_freq_meas_id_list, 
                     MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                     tmp_intra_freq_meas_id_list, 
                     MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

        /* Everything is O.K. Read SIB12 */
        rrcmeas_read_sib12(sib12_ptr, rrcmeas_sib12);
        /* Set Meas Type */
         state_transition_meas->meas_type = L1_INTRA_FREQ;

         WRRC_MSG2_HIGH("Undo changes to Meas id varible from SIB11...SIB12 : FACH Meas Occas Info incl %d, HCS used %d",rrcmeas_sib12->fach_meas_incl,rrcmeas_sib12->hcs_used);

         if (rrcmeas_sib12->fach_meas_incl == TRUE)
         {
           state_transition_meas->fach_meas_incl = TRUE;

           state_transition_meas->fach = rrcmeas_sib12->fach;
         }

         state_transition_meas->meas_action = L1_MEAS_STOP_AND_OVERWRITE;
         state_transition_meas->meas_id = rrcmeas_sib12->intra_f.meas_id;
         if(rrcmeas_sib12->hcs_used == TRUE)
         {
           state_transition_meas->hcs_used = TRUE;
         }
         /* Set Meas params */
         state_transition_meas->u.l1_new_intra_freq_sib_meas_params = *rrcmeas_sib12;
      }
    } /* Else of SIB12 present */

    if(sib12_present == SIB12_ABSENT)
    {
      /* SIB 11 successfully read for the new cell */
      /* Prepare Intra-Freq Meas in state transition cmd */

      /* Set Measurement Action */
      state_transition_meas->meas_action = L1_MEAS_STOP_AND_OVERWRITE;

      /* Set Meas Id */
      state_transition_meas->meas_id =
        rrcmeas_sib11->intra_f.meas_id;

      /* Set Meas Type */
      state_transition_meas->meas_type = L1_INTRA_FREQ;

      if(rrcmeas_sib11->hcs_used == TRUE)
      {
        state_transition_meas->hcs_used = TRUE;
      }
      state_transition_meas->u.l1_new_intra_freq_sib_meas_params
        = *rrcmeas_sib11;

      if (rrcmeas_sib11->fach_meas_incl == TRUE)
      {
        state_transition_meas->fach_meas_incl = TRUE;

        state_transition_meas->fach = rrcmeas_sib11->fach;
      }
      /* Since at present, we support only 1 intra-freq measurement, come
      out of the loop and send the command to L1. When we start supporting
      multiple intra-freq meas, code needs to be added here */
    }
    MSG_HIGH("Send stop,overwrite to L1 for IntraFreqMeas=%d...SIB11: FACH Meas Occas Info %d Setting HCS flag to %d",state_transition_meas->meas_id,state_transition_meas->fach_meas_incl,state_transition_meas->hcs_used);

    /* Send Command to L1 */
    rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);
  }



  /* Delete Inter Freq Meas if any */
  for (cnt = 0; cnt < MAX_INTER_FREQ_MEAS; cnt++)
  {
    if (inter_freq_meas_id_list[cnt].meas_id != INVALID_MEAS_ID)
    {
      delete_inter_freq_meas = TRUE;

      WRRC_MSG1_HIGH("Delete InterFreq %d Meas",inter_freq_meas_id_list[cnt].meas_id);
      /* Delete this meas from any Addtl Meas List */
      rrcmeas_delete_addtl_meas(&inter_freq_meas_id_list[cnt].meas_id);

    }
  }

  if (delete_inter_freq_meas == TRUE)
  {
    /* Meas type */
    state_transition_meas->meas_type = L1_INTER_FREQ;

    /* Set Measurement Action */
    state_transition_meas->meas_action = L1_MEAS_DELETE_ALL;

    MSG_LOW("Delete all Inter Freq Meas",0,0,0);

    rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);
  }

  /* Initialize the Inter Freq Meas Id List to delete all meas */
  rrcifreq_initialize_meas_id_list();

  /* Now read SIB11 again for Inter-Freq Meas */
#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
  if(rrcsib_is_sib11_11bis_12_read_deferred(DEFERRED_SIB11))
  {
    MSG_LOW("Deferred SIB:Inter Freq SIB11 deferred",0,0,0);
  }
  else
#endif
  if (rrcifreq_read_sib11(rrcmeas_inter_freq_sib11) == FAILURE)
  {
    WRRC_MSG0_HIGH("IFreq:Inter Freq SIB11 ignored");
    rrcifreq_initialize_cell_list();
  }
  if(((rrc_SysInfoType11*)
        rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11)) != NULL)
  {
    if ( sib12_present == SIB12_ABSENT )
    {
      MSG_LOW("SIB12 not present ", 0,0,0);
    }
    else
    {
      MSG_LOW("SIB12 present, processing SIB12",0,0,0);

      if((sib12_ptr = (rrc_SysInfoType12*)
        rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
      {
        WRRC_MSG0_HIGH("SIB 12 empty.");
      }
      else
      {
        /* Everything is O.K. Read SIB12 */
        if(rrcifreq_read_sib12(sib12_ptr, rrcmeas_inter_freq_sib11, rrcmeas_inter_freq_sib12) == FAILURE)
        {
          WRRC_MSG0_HIGH("IFreq:Inter Freq SIB12 ignored");
          rrcifreq_initialize_cell_list();
        }
        else
        {
          meas_choice = L1_INTER_FREQ_SIB_PARMS;
          rrcifreq_send_l1_cmd(&meas_choice, rrcmeas_inter_freq_sib12);
          WRRC_MSG0_HIGH("IFreq:Cell List sent SIB12");
        }
      }
    } /* Else of SIB12 present */

    if((sib12_present == SIB12_ABSENT) && (rrcmeas_inter_freq_sib11->num_cell_add != 0))
    {
      meas_choice = L1_INTER_FREQ_SIB_PARMS;
      rrcifreq_send_l1_cmd(&meas_choice, rrcmeas_inter_freq_sib11);
      WRRC_MSG0_HIGH("IFreq:Cell List sent SIB11");
    }
  }
}


/*===========================================================================

FUNCTION   RRCMEAS_SAVE_INTRA_INTER_FREQ_MEAS

DESCRIPTION

  Gets Measurement from L1 before it goes to Idle Mode in case of
  UE transitioning from DCH-->FACH

DEPENDENCIES

  None

RETURN VALUE

  None

SIDE EFFECTS


===========================================================================*/
void rrcmeas_save_intra_inter_freq_meas
(
 void
)
{
  uint8 count = 0;

  /* Get Intra-Freq Meas */
  for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
  {
    /* Make sure that L1 gets only 1 intra-freq meas */
    if (intra_freq_meas_id_list[count].meas_id != INVALID_MEAS_ID)
    {
      WRRC_MSG1_HIGH("Save Intra-Freq Meas",
        intra_freq_meas_id_list[count].meas_id);

      /* Call L1 function to save Intra Freq Meas */
      l1_get_stored_intra_freq_meas(intra_freq_meas_id_list[count].meas_id);
      break;
    }

  } /* End of for */

  for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
  {
    /* Make sure that L1 gets only 1 intra-freq meas */
    if (inter_freq_meas_id_list[count].meas_id != INVALID_MEAS_ID)
    {
      WRRC_MSG0_HIGH("Save Inter-Freq Meas");
  
      /* Call L1 function to save Inter Freq Meas */
      srchmeas_set_inter_freq_measdb_status_during_state_transition(TRUE);
      break;
    }
  
  } /* End of for */

}


/*===========================================================================

FUNCTION   RRCMEAS_SAVE_L1_MEAS

DESCRIPTION

  Processes the secnario when the transition from DCH-->FACH
  transition determines that intra-freq measurement has to be
  saved and no measurement reporting for this measurement has to be done.
  Since the move may result in selection of a new cell, CELL_INFO_LIST
  has to be configured again. This requires reading cells from SIB11
  again and updating the CELL_INFO_LIST

DEPENDENCIES

  None

RETURN VALUE

  None

SIDE EFFECTS

  If SIB11 is not valid, then no intra-freq measurements would be done.

===========================================================================*/

void rrcmeas_save_l1_meas
(
 void
)
{

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
  uint8  l1_deferred_meas_from_sib_action = 0;
#endif

  /* First save the Intra-Freq Meas */
  uint8 count = 0;

  rrc_SysInfoType12 *sib12_ptr = NULL;
   rrc_SysInfoType11 *sib11_ptr = NULL;

  intra_freq_meas_id_list_struct_type tmp_intra_freq_id;

  /* Following one is for Inter Freq */
  l1_meas_ctrl_enum_type meas_choice = L1_INTER_FREQ_SIB_PARMS;
  /* Stores the Meas Id from the SIB's */
  uint16 meas_id = INVALID_MEAS_ID;

  boolean meas_db_empty = TRUE;

  boolean meas_reconfg_req = FALSE;
  
  /* First clear the SIB info */
  rrcmeas_clear_sib11();

  /* Make SIB12 as absent as new SIB11 would be read */
  sib12_present = SIB12_ABSENT;

  /* Cell List needs to be reinitialized */
  rrcmeas_initialize_cell_list();

 rrcifreq_initialize_cell_list();

  rrcllc_update_cm_parms();
  
  state_transition_meas->hcs_used = FALSE;
  memset(&tmp_intra_freq_id, 0, sizeof(tmp_intra_freq_id));

  /* Save the intra freq meas id list in a temp variable */
  WCDMA_MEMCPY(tmp_intra_freq_meas_id_list, 
               MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
               intra_freq_meas_id_list, 
               MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

#ifdef FEATURE_WCDMA_DEFERRED_SIB11_12_READING
  if(rrcsib_is_sib11_11bis_12_read_deferred(DEFERRED_SIB11))
  {    
    l1_deferred_meas_from_sib_action = CLEAR_CELL_INFO_LIST;
    rrcmeas_send_deferred_meas_req(l1_deferred_meas_from_sib_action);
    return;
  }
#endif

  /* Check meas_db_empty is TRUE. If yes, then overwrite cmd would be
     sent from SIB's. If meas_db_empty is not empty, and if a MCM owned meas
     has same identity as the one present in new SIB's, then just send cmd
     to overwrite the cell list. If not then send a overwrite meas cmd to L1 */

  meas_reconfg_req = rrcmeas_check_if_meas_reconfig_reqd(&meas_id, &meas_db_empty);

  if (meas_reconfg_req == TRUE)
  {
    MSG_LOW("New reconfig meas to be sent",0,0,0);
    /* Send stop and overwrite req  */
    state_transition_meas->meas_action = L1_MEAS_STOP_AND_OVERWRITE;
  }
  else
  { /* Send stop and config cell list req. Meas does not exist in RRC */
    MSG_LOW("New reconfig cell list to be sent",0,0,0);
    state_transition_meas->meas_action = L1_MEAS_STOP_AND_CONFIG_CELL_LIST;
  }

  MSG_HIGH("State trans meas action %d, meas_db_empty %d, meas reconfig req %d",state_transition_meas->meas_action,meas_db_empty,meas_reconfg_req);

  /* Set Meas Id */
  state_transition_meas->meas_id = meas_id;

  /* Set Meas Type */
  state_transition_meas->meas_type = L1_INTRA_FREQ;

  /* Just initialize it so that L1 does not make any mistake */
  state_transition_meas->fach_meas_incl = FALSE;

  if (meas_db_empty == TRUE)
  {
    /* Meas db empty or Meas id of MCM != SIB read SIB11 */

    if ( rrcmeas_read_sib11() == FAILURE )
    {
      WRRC_MSG0_ERROR("Intra-Freq SIB 11 invalid");
      rrcmeas_clear_sib11();

    }
    else
    {
      /* check for SIB 12 and use it if present */
      if ( sib12_present == SIB12_ABSENT )
      {
        MSG_LOW("SIB12 not present", 0,0,0);
      }
      else
      {
        if((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
        {
          WRRC_MSG0_HIGH("SIB 12 empty.");
        }
        else
        {
          MSG_LOW("Undo changes to Meas id varible from SIB11",0,0,0);
          WCDMA_MEMCPY(intra_freq_meas_id_list, 
                       MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                       tmp_intra_freq_meas_id_list, 
                       MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

          /* Everything is O.K. Read SIB12 */
          rrcmeas_read_sib12(sib12_ptr, rrcmeas_sib12);

          WRRC_MSG2_HIGH("FACH Meas Occas Info Set picked from SIB12 %d, HCS used %d",rrcmeas_sib12->fach_meas_incl,rrcmeas_sib12->hcs_used);

          if (rrcmeas_sib12->fach_meas_incl == TRUE)
          {
            state_transition_meas->fach_meas_incl = TRUE;
            state_transition_meas->fach = rrcmeas_sib12->fach;
          }

          state_transition_meas->meas_action = L1_MEAS_STOP_AND_OVERWRITE;
          state_transition_meas->meas_id = rrcmeas_sib12->intra_f.meas_id;
          if(rrcmeas_sib12->hcs_used == TRUE)
          {
            state_transition_meas->hcs_used = TRUE;
          }
          /* Set Meas params */
          state_transition_meas->u.l1_new_intra_freq_sib_meas_params = *rrcmeas_sib12;
        } /* SIB12 present */
      } /* Else of SIB12 present */

      if(sib12_present == SIB12_ABSENT)
      {
        WRRC_MSG2_HIGH("SIB11 : FACH Meas Occas Info incl %d, HCS used %d",rrcmeas_sib11->fach_meas_incl,rrcmeas_sib11->hcs_used);

        if (rrcmeas_sib11->fach_meas_incl == TRUE)
        {
          state_transition_meas->fach_meas_incl = TRUE;

          state_transition_meas->fach = rrcmeas_sib11->fach;
        }

        state_transition_meas->meas_action = L1_MEAS_STOP_AND_OVERWRITE;
        state_transition_meas->meas_id = rrcmeas_sib11->intra_f.meas_id;
        if(rrcmeas_sib11->hcs_used == TRUE)
        {
          state_transition_meas->hcs_used = TRUE;
        }
        /* Set Meas params */
        state_transition_meas->u.l1_new_intra_freq_sib_meas_params = *rrcmeas_sib11;
      }

      MSG_LOW("State Tran meas cmd sent",0,0,0);
      /* Send Command to L1 */
      rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);
    }
  }
  else
  {
    /* Now Configure Intra-Freq Meas. */
    for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
    {
      if (intra_freq_meas_id_list[count].meas_id == meas_id)
      {
        WRRC_MSG1_HIGH("Intra-freq Meas Id %d saved",
          intra_freq_meas_id_list[count].meas_id);

        /* First store the value in a tmp var */
        WCDMA_MEMCPY(&tmp_intra_freq_id,
                     sizeof(tmp_intra_freq_id),
                     &intra_freq_meas_id_list[count], 
                     sizeof(tmp_intra_freq_id));

        /* Read SIB 11 again to get new cell list only and then send cmd to L1 */
        if ( rrcmeas_read_sib11() == FAILURE )
        {
          WRRC_MSG0_ERROR("Intra-Freq SIB 11 invalid");
          /* Put back the original params */
          WCDMA_MEMCPY(&intra_freq_meas_id_list[count], 
                       sizeof(tmp_intra_freq_id),
                       &tmp_intra_freq_id, 
                       sizeof(tmp_intra_freq_id));
          rrcmeas_clear_sib11();
          break;
        }
        else
        {
          /* Check for SIB 12 and process it if present */
          if(sib12_present == SIB12_ABSENT)
          {
            MSG_LOW("SIB12 not present", 0,0,0);
          }
          else
          {
            WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

            if((sib12_ptr = (rrc_SysInfoType12*)
              rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
            {
              WRRC_MSG0_HIGH("SIB 12 empty.");
              WCDMA_MEMCPY(intra_freq_meas_id_list, 
                           MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                           tmp_intra_freq_meas_id_list, 
                           MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));
            }
            else
            {
              /* Everything is O.K. Read SIB12 */
              rrcmeas_read_sib12(sib12_ptr, rrcmeas_sib12);
              WCDMA_MEMCPY(intra_freq_meas_id_list, 
                           MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type),
                           tmp_intra_freq_meas_id_list, 
                           MAX_INTRA_FREQ_MEAS * sizeof(intra_freq_meas_id_list_struct_type));

              MSG_HIGH("SIB12 : FACH Meas Occas Info Set %d, HCS used %d, cell_list_incl %d",rrcmeas_sib12->fach_meas_incl,rrcmeas_sib12->hcs_used, rrcmeas_sib12->intra_f.cell_list_incl);
                /* Set FACH Meas Occasion Info */
              if(rrcmeas_sib12->fach_meas_incl == TRUE)
              {
                state_transition_meas->fach_meas_incl = TRUE;

                state_transition_meas->fach = rrcmeas_sib12->fach;
              }

              if(rrcmeas_sib12->hcs_used == TRUE)
              {
                state_transition_meas->hcs_used = TRUE;
              }

              if(state_transition_meas->meas_action == L1_MEAS_STOP_AND_CONFIG_CELL_LIST)
              {
                /* Check if Cells are not present in SIB12 composite cell list */
                if (rrcmeas_sib12->intra_f.cell_list_incl == TRUE)
                {
                  state_transition_meas->u.l1_new_intra_freq_cell_list.cell_list_incl = TRUE;
                  state_transition_meas->u.l1_new_intra_freq_cell_list.cell_list
                    = rrcmeas_sib12->intra_f.cell_list;
                }
                else
                {
                  WRRC_MSG0_HIGH("IntraFreqCells not present in SIB12. State Trans Meas Cmd not sent");
                  break;
                }
              }
              else
              {
                /* Set Meas params */
                state_transition_meas->u.l1_new_intra_freq_sib_meas_params = *rrcmeas_sib12;
              }
            }
          } /* Else of SIB12 present */
        }
        if(sib12_present == SIB12_ABSENT)
        {
          MSG_HIGH("SIB11 : FACH Meas Occas Info Set: %d, HCS used %d, cell_list_incl %d",rrcmeas_sib11->fach_meas_incl,rrcmeas_sib11->hcs_used,rrcmeas_sib11->intra_f.cell_list_incl);
          /* Set FACH Meas Occasion Info */
          if (rrcmeas_sib11->fach_meas_incl == TRUE)
          {
            state_transition_meas->fach_meas_incl = TRUE;

            state_transition_meas->fach = rrcmeas_sib11->fach;
          }

          if(rrcmeas_sib11->hcs_used == TRUE)
          {
            state_transition_meas->hcs_used = TRUE;
          }
          if (state_transition_meas->meas_action == L1_MEAS_STOP_AND_CONFIG_CELL_LIST)
          {
            /* Check if Cells are not present in SIB11 */
            if (rrcmeas_sib11->intra_f.cell_list_incl == TRUE)
            {
              state_transition_meas->u.l1_new_intra_freq_cell_list.cell_list_incl = TRUE;
              state_transition_meas->u.l1_new_intra_freq_cell_list.cell_list = rrcmeas_sib11->intra_f.cell_list;
            }
            else
            {
              WRRC_MSG0_HIGH("IntraFreqCells not present in SIB11. State Trans Meas Cmd not sent");
              break;
            }
          }
          else
          {
            /* Set Meas params */
            state_transition_meas->u.l1_new_intra_freq_sib_meas_params = *rrcmeas_sib11;
          }
        }
        MSG_LOW("State Tran meas cmd sent",0,0,0);

        /* Send Command to L1 */
        rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);

        /* Since cmd has been sent */

        break;

      } /* End of if of Valid Meas Id */

    } /* End of for */
  } /* End of else */


  /* Get the new cell info list from the SIB 11 */
  if ( rrcifreq_read_sib11(&l1_fach_inter_freq_parms) == FAILURE )
  {
    WRRC_MSG0_HIGH("IFreq:InterFreq SIB 11 ignored");
  }

  if((sib11_ptr =  (rrc_SysInfoType11*)
        rrc_sibdb_return_sib_for_srv_cell(rrc_SIB11)) != NULL)
  {
    if ( sib12_present == SIB12_ABSENT )
    {
      MSG_LOW("SIB12 not present", 0,0,0);
    }
    else
    {
      WRRC_MSG0_HIGH("SIB12 present, processing SIB12");

      if((sib12_ptr = (rrc_SysInfoType12*)
        rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) == NULL)
      {
        MSG_LOW("SIB 12 empty",0,0,0);
      }
      else
      {
        /* Everything is O.K. Read SIB12 */
        if(rrcifreq_read_sib12(sib12_ptr, &l1_fach_inter_freq_parms, rrcmeas_inter_freq_sib12) == FAILURE)
        {
          WRRC_MSG0_HIGH("IFreq:Inter Freq SIB12 ignored");
          rrcifreq_initialize_cell_list();
          return;
        }
      }
    } /* Else of SIB12 present */
  }
  for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
  {
    /* Make sure that L1 gets only 1 inter-freq meas */
    if (inter_freq_meas_id_list[count].meas_id != INVALID_MEAS_ID)
    {
      WRRC_MSG1_HIGH("IFreq:Inter-freq Meas Id %d saved",
        inter_freq_meas_id_list[count].meas_id);

      /* SIB 11 successfully read for the new cell */
      /* Prepare Inter-Freq Meas in state transition cmd */

      /* Set Measurement Action */
      state_transition_meas->meas_action = L1_MEAS_STOP_AND_CONFIG_CELL_LIST;

      /* Set Meas Id */
      state_transition_meas->meas_id =
        inter_freq_meas_id_list[count].meas_id;

      /* Set Meas Type */
      state_transition_meas->meas_type = L1_INTER_FREQ;

      if((sib12_present == SIB12_PRESENT) && (sib12_ptr != NULL))
      {
        state_transition_meas->u.l1_inter_freq_cell_list =
            *rrcmeas_inter_freq_sib12;
        if(rrcmeas_inter_freq_sib12->hcs_used == TRUE)
        {
          MSG_LOW("SIB12 Inter Freq: Setting HCS flag to TRUE",0,0,0);
          state_transition_meas->hcs_used = TRUE;
        }
        state_transition_meas->fach_meas_incl = FALSE;

        if (rrcmeas_sib12->fach_meas_incl == TRUE)
        {
          state_transition_meas->fach_meas_incl = rrcmeas_sib12->fach_meas_incl;
          state_transition_meas->fach.inter_f_ind = rrcmeas_sib12->fach.inter_f_ind;
          state_transition_meas->fach.k = rrcmeas_sib12->fach.k;
          state_transition_meas->fach.k_ind  = rrcmeas_sib12->fach.k_ind;
          state_transition_meas->fach.num_inter_sys  = rrcmeas_sib12->fach.num_inter_sys;
          state_transition_meas->fach.inter_sys[0]   = rrcmeas_sib12->fach.inter_sys[0];
        }
        else
        {
          WRRC_MSG0_HIGH("FACH Meas Occasion Info absent");
        }

        MSG_LOW("SIB12 IFreq:State Tran meas cmd sent",0,0,0);

      }
      else
      {
        state_transition_meas->u.l1_inter_freq_cell_list =
          l1_fach_inter_freq_parms;

        if((sib11_ptr != NULL) &&
          ( RRC_CHECK_COMMON_MSG_TYPE(sib11_ptr->measurementControlSysInfo.use_of_HCS,
    rrc_MeasurementControlSysInfo_use_of_HCS_hcs_used )))
        {
          WRRC_MSG0_HIGH("SIB11 Inter Freq: Setting HCS flag to TRUE");
          state_transition_meas->hcs_used = TRUE;
        }
        state_transition_meas->fach_meas_incl = FALSE;

        if (rrcmeas_get_fach_meas_info() == RRCMEAS_SUCCESS)
        {
          state_transition_meas->fach_meas_incl = rrcmeas_sib11->fach_meas_incl;
          state_transition_meas->fach.inter_f_ind = rrcmeas_sib11->fach.inter_f_ind;
          state_transition_meas->fach.k = rrcmeas_sib11->fach.k;
          state_transition_meas->fach.k_ind  = rrcmeas_sib11->fach.k_ind;
          state_transition_meas->fach.num_inter_sys  = rrcmeas_sib11->fach.num_inter_sys;
          state_transition_meas->fach.inter_sys[0]   = rrcmeas_sib11->fach.inter_sys[0];
        }
        else
        {
          WRRC_MSG0_HIGH("FACH Meas Occasion Info absent");
        }

        MSG_LOW("SIB11 IFreq:State Tran meas cmd sent",0,0,0);
      }
      /* Send Command to L1 */
      rrcmeas_send_l1_cmd(NULL, NULL, state_transition_meas, L1_RRC_STATE_CHANGE_PARMS);
      return;

    } /* End of if of Valid Meas Id */

  } /* End of for */

  /* If we come here, then inter freq cmd has not yet been sent */
  if((sib12_present == SIB12_PRESENT) && (sib12_ptr != NULL))
  {
    if(rrcmeas_inter_freq_sib12->num_cell_add != 0)
    {
      meas_choice = L1_INTER_FREQ_SIB_PARMS;
      rrcifreq_send_l1_cmd(&meas_choice, rrcmeas_inter_freq_sib12);
      WRRC_MSG0_HIGH("IFreq:Sending Ifreq neigbors FACH SIB12");
    }
  }
  else
  {
    if(l1_fach_inter_freq_parms.num_cell_add != 0)
    {
      meas_choice = L1_INTER_FREQ_SIB_PARMS;
      rrcifreq_send_l1_cmd(&meas_choice, &l1_fach_inter_freq_parms);
      WRRC_MSG0_HIGH("IFreq:Sending Ifreq neigbors FACH SIB11");
    }
  }
}


/*===========================================================================

FUNCTION   RRCMEAS_INITIALIZE_CELL_LIST

DESCRIPTION

  Handles initialization of CELL_INFO_LIST variable
  for Intra Freq Measurements.

DEPENDENCIES

  None

RETURN VALUE

  None.

SIDE EFFECTS

  None.

===========================================================================*/

void rrcmeas_initialize_cell_list
(
 void
)
{
  uint8 count = 0;
  WRRC_MSG0_HIGH("Initializing Intra-Freq CELL_INFO_LIST");
  /* Initialize Intra_freq_cell_list variable */
  for ( count = 0; count < MAX_NO_OF_CELLS; count++ )
  {
    /* Set all positions to vacant and make PSC as invalid */
    intra_freq_cell_list[PRI_FREQ][count].cell_position = VACANT;
    intra_freq_cell_list[PRI_FREQ][count].psc = INVALID_PSC;

#ifdef FEATURE_WCDMA_DC_HSUPA
    intra_freq_cell_list[SEC_FREQ][count].cell_position = VACANT;
    intra_freq_cell_list[SEC_FREQ][count].psc = INVALID_PSC;
#endif	
  }
}


/*===========================================================================

FUNCTION   RRCMEAS_INITIALIZE_MEAS_ID_LIST

DESCRIPTION

  Handles initialization of MEASUREMNT_IDENTIY variable
  for Intra Freq Measurements.

DEPENDENCIES

  None

RETURN VALUE

  None.

SIDE EFFECTS

  None.

===========================================================================*/

void rrcmeas_initialize_meas_id_list
(
 void
)
{
  uint8 count = 0, cnt = 0;
  /* Initialize Measurement Identity variable */
  WRRC_MSG0_HIGH("Initializing Intra-Freq Meas Id List");

  for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
  {
    /* Set all positions to vacant and make PSC as invalid */
    intra_freq_meas_id_list[count].meas_id = INVALID_MEAS_ID;
    intra_freq_meas_id_list[count].meas_type = L1_INTRA_FREQ;
    intra_freq_meas_id_list[count].meas_validity = NOT_PRESENT;
     intra_freq_meas_id_list[count].rpt_crit[PRI_FREQ] = NOT_AVAILABLE;
#ifdef FEATURE_WCDMA_DC_HSUPA
    intra_freq_meas_id_list[count].rpt_crit[SEC_FREQ] = NOT_AVAILABLE;
#endif
    intra_freq_meas_id_list[count].mcm_owned = FALSE;
    intra_freq_meas_id_list[count].meas_can_be_reported = TRUE;

    /* Also initialize additional meas */
    for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
     intra_freq_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
  }

}


/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_COMPRESSED_MODE_STATUS

DESCRIPTION

    This function processes Compressed Mode Status information received
 in a Meas Ctrl Message


DEPENDENCIES

    None

RETURN VALUE

    FAILURE: If compressed mode status info is valid
    SUCCESS: If compressed mode status info is invalid

SIDE EFFECTS

    None

===========================================================================*/

uecomdef_status_e_type rrcmeas_process_compressed_mode_status
(
  rrc_DPCH_CompressedModeStatusInfo* rrc_cm_ptr,
  l1_cm_status_info_struct_type* l1_cm_ptr
)
{
  /* Declare local pointer to store pointer to TGPSI list */
  rrc_DPCH_CompressedModeStatusInfo_tgp_SequenceShortList * local_tgpsi_list_ptr = NULL;

  uint8 cnt = 0;




  l1_cm_ptr->sdu_time = rrc_cfn_before_decode[RRC_PROCEDURE_MCMR];

  WRRC_MSG1_MED("CM: SDU rcvd Time is %d", l1_cm_ptr->sdu_time);

  /* Store reconfigurtion cfn */
  l1_cm_ptr->tgps_reconfig_cfn = (uint16)rrc_cm_ptr->tgps_Reconfiguration_CFN;

  local_tgpsi_list_ptr = &rrc_cm_ptr->tgp_SequenceShortList;

    while ((cnt < L1_MAX_TGPS) && (local_tgpsi_list_ptr->n > cnt))
  {
    /* Set TGPSI */
    l1_cm_ptr->tgps_array[cnt].tgpsi = (uint16) local_tgpsi_list_ptr->elem[cnt].tgpsi;

    switch(local_tgpsi_list_ptr->elem[cnt].tgps_Status.t)
    {
    case T_rrc_TGP_SequenceShort_tgps_Status_activate:

      /* Pattern Status */
      l1_cm_ptr->tgps_array[cnt].status = L1_TGPS_ACTIVE;


       if ((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) &&
           (hsdpa_cm_enabled == FALSE))
       {
         if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
         {
           return FAILURE;
         }
       }

       if ((!rrc_wcdma_hsupa_cm_enabled) &&
           (TRUE == rrc_is_eul_active()))
       {
           return FAILURE;
       }

      /* Set TGCFN */
      l1_cm_ptr->tgps_array[cnt].tgcfn = (uint16)
        local_tgpsi_list_ptr->elem[cnt].tgps_Status.u.activate->tgcfn;

      break;

    case T_rrc_TGP_SequenceShort_tgps_Status_deactivate:
      l1_cm_ptr->tgps_array[cnt].status = L1_TGPS_INACTIVE;

      break;

    default:
      return FAILURE;
    } /* End of switch */

    cnt++;

    

    if ((local_tgpsi_list_ptr->n > cnt) && (cnt == L1_MAX_TGPS))
    {
      break;
    }

  } /* End of while */

  /* Set number of TGPSI's */
  l1_cm_ptr->num_tgps = cnt;

  return SUCCESS;
}



/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_DELETE_MEAS_ID

DESCRIPTION

    This function processes the deletion of Measurement Identity from
    MEASUREMENT_IDENTITY list. The Measurement Identity belongs either to
    Inter-RAT Measurements or to Inter-Freq Measurements


DEPENDENCIES

    None

RETURN VALUE

    None

SIDE EFFECTS

    None

===========================================================================*/

void rrcmeas_process_delete_meas_id
(
  uint16* meas_id_ptr
)
{
  uint8 cnt = 0;

  /* Deleted Meas from MEASUREMENT_IDENTITY list */
  /* First check in INTER RAT MEAS ID LIST */
  for (cnt =0; cnt <MAX_INTER_RAT_MEAS; cnt++ )
  {
    if (inter_rat_meas_id_list[cnt].meas_id == *meas_id_ptr)
    {
      WRRC_MSG1_HIGH("Deleting InterRat Meas %d", *meas_id_ptr);
      inter_rat_meas_id_list[cnt].meas_id = INVALID_MEAS_ID;
      return;
    }

  } /* End of for */
}


#ifdef FEATURE_WCDMA_DC_HSUPA
/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_ADDITIONAL_MEASURED_RESULTS

DESCRIPTION

    This function contains the logic of checking if additional measurements
    need to be appended and also appends additional measurements to measured results.

DEPENDENCIES

    The calling function should provide rpt_ptr as NULL if additional results
    do not exist at all.

RETURN VALUE

    None.

SIDE EFFECTS

    None

===========================================================================*/

void rrcmeas_process_additional_measured_results_sec_freq
(
 uint16* primary_meas_id_ptr,
 rrcmeas_layer_e_type primary_meas_type,
 rrc_MeasurementReport* rpt_ptr
)
{
  uint8 count = 0, cnt = 0,index=0;
  /* Stores additional Meas in this Local List from specific Meas List */
  uint8 addl_meas[MAX_ADDITIONAL_MEAS];
   l1_meas_rpt_struct_type  l1_rpt;
  uint16 addl_meas_id;
  rrcmeas_layer_e_type addl_meas_info[MAX_ADDITIONAL_MEAS];

  /* The following 2 variables are not used but decalred to satisfy fn requirement */
  rpt_crit_enum_type rpt_crit;

  meas_validity_enum_type meas_validity;

  rrc_MeasurementReport_v920ext_IEs *rrc_mr_v920_ptr = NULL;

  rrc_mr_v920_ptr = &rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.
                 v4b0NonCriticalExtensions.v590NonCriticalExtensions.v5b0NonCriticalExtensions.
                 v690NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions.
                 v920NonCriticalExtensions.measurementReport_v920ext;

  /* Initialize addl meas list to satisfy lint */
  for (count = 0; count < MAX_ADDITIONAL_MEAS; count++)
  {
    addl_meas[count] = INVALID_MEAS_ID;
  }

  count = 0;

  /* Check if for this Meas Id, Additional Meas Exists. If yes, copy the additional
  measurement id to a local array */
  switch(primary_meas_type)
  {
  case INTRA_FREQ:
    for (count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
    {
      if (intra_freq_meas_id_list[count].meas_id == *primary_meas_id_ptr)
      {
        /* Check if it has any additional meas */
        /* Additional Meas are always stored in Meas Id List in Ascending Order.
        Spec requirement is that additional meas should be appended in ascending order */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
          addl_meas[cnt] = intra_freq_meas_id_list[count].additional_meas[cnt];
        /* Addtl Meas Stored in Local Variable */
        break;
      }
    } /* End of for of Intra Freq */
    break;

  default:
    WRRC_MSG1_ERROR("Unsupported Primary Meas Type %d",primary_meas_type);
    return;
  } /* End of switch */


  /* Check if it has any additional meas */
  /* Additional Meas are always stored in Meas Id List in Ascending Order.
  Spec requirement is that additional meas should be appended in ascending order */

  memset(addl_meas_info,0xFF,(sizeof(rrcmeas_layer_e_type)) *MAX_ADDITIONAL_MEAS);
  for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
  {
    if (addl_meas[cnt] != INVALID_MEAS_ID)
    {
      WRRC_MSG2_HIGH("Found Addl Meas %d, PrimMeas %d",
        addl_meas[cnt],*primary_meas_id_ptr);

      addl_meas_id = addl_meas[cnt];
      /* Additional Meas found. Get type of additional Meas. rpt_crit, validity not used */
      switch(rrcmeas_find_additional_meas_type_sec_freq(&addl_meas_id, &rpt_crit, &meas_validity))
      {
      case INTRA_FREQ:
        /* The called function would set additional meas bit mask if results are appended */
        if (rrcmeas_append_intra_freq_results(SEC_FREQ,&addl_meas[cnt], &l1_rpt) == FALSE)
        {
          WRRC_MSG1_HIGH("Addtl IntraFreq Meas %d not appended",addl_meas[cnt]);
        }
        else
        {
          WRRC_MSG1_HIGH("Addtl Intra Freq Meas %d appended", addl_meas[cnt]);
          addl_meas_info[index]=INTRA_FREQ;
          index++;
        }
        break; /* Out of switch */

      default:
        WRRC_MSG1_ERROR("Unknown type for Addtl Meas %d", addl_meas[cnt]);
        break;
      } /* End of switch */
    } /* End of if of Additional Meas != INVALID_MEAS_ID */
  } /* End of for loop of additional measurements */
  
  if(index > 0)
  {
    rrc_mr_v920_ptr->additionalMeasuredResultsOnSecUlFreq.n  = index;
    ALLOC_ASN1ARRAY2(&enc_ctxt,&rrc_mr_v920_ptr->additionalMeasuredResultsOnSecUlFreq,
          rrc_MeasuredResultsOnSecUlFreq);
    
    /* Set additional results to being present */
    rrc_mr_v920_ptr->m.additionalMeasuredResultsOnSecUlFreqPresent = 1;
     
    for(cnt=0;cnt<index;cnt++)
    {
      switch(addl_meas_info[cnt])  
      {
        case INTRA_FREQ:
          /* The called function would set additional meas bit mask if results are appended */
           /* Set Additional Report type to Intra Freq report */
        rrcmeas_append_intra_freq_periodic_meas_results_sec_freq(&l1_rpt.u.intra_f_rpt[SEC_FREQ],
          rrc_mr_v920_ptr, &rrc_mr_v920_ptr->additionalMeasuredResultsOnSecUlFreq.elem[cnt].intraFreqMeasuredResultsList, TRUE);
          break; /* Out of switch */

        default:
          WRRC_MSG1_ERROR("Unknown type for Addtl Meas %d", addl_meas_info[cnt]);
          break;
      }
    }
  }
  return;
}
#endif


/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_ADDITIONAL_MEASURED_RESULTS

DESCRIPTION

    This function contains the logic of checking if additional measurements
    need to be appended and also appends additional measurements to measured results.

DEPENDENCIES

    The calling function should provide rpt_ptr as NULL if additional results
    do not exist at all.

RETURN VALUE

    None.

SIDE EFFECTS

    None

===========================================================================*/

void rrcmeas_process_additional_measured_results
(
 uint16* primary_meas_id_ptr,
 rrcmeas_layer_e_type primary_meas_type,
 rrc_MeasurementReport* rpt_ptr
)
{
  uint8 count = 0, cnt = 0,index=0,sec_index=0,sec_addl_meas_found=0,addl_meas_found=0;
  /* Stores additional Meas in this Local List from specific Meas List */
  uint8 addl_meas[MAX_ADDITIONAL_MEAS];
  l1_ue_internal_meas_rpt_struct_type *ue_internal_meas =  rrc_malloc(sizeof(l1_ue_internal_meas_rpt_struct_type));
   mac_ul_traffic_meas_ind_type  *additional_tvm =  rrc_malloc(sizeof(mac_ul_traffic_meas_ind_type));
   l1_inter_sys_meas_result_struct_type  *l1_meas_results = rrc_malloc(sizeof(l1_inter_sys_meas_result_struct_type));
   l1_meas_rpt_struct_type  *inter_freq_l1_rpt = rrc_malloc(sizeof(l1_meas_rpt_struct_type));
   l1_meas_rpt_struct_type  *l1_rpt = rrc_malloc(sizeof(l1_meas_rpt_struct_type));
  uint16 addl_meas_id;
  
  rrc_MeasurementReport_v860NonCriticalExtensions *rrc_mr_v860_ptr = NULL;
  rrc_MeasurementReport_v5b0NonCriticalExtensions *rrc_mr_v590_ptr = NULL;
  rrc_MeasurementReport_v920ext_IEs *rrc_mr_v920_ptr =NULL; 

  /* The following 2 variables are not used but decalred to satisfy fn requirement */
  rpt_crit_enum_type rpt_crit;

  meas_validity_enum_type meas_validity;

  /* Initialize addl meas list to satisfy lint */
  for (count = 0; count < MAX_ADDITIONAL_MEAS; count++)
  {
    addl_meas[count] = INVALID_MEAS_ID;
  }

  count = 0;

  /* Check if for this Meas Id, Additional Meas Exists. If yes, copy the additional
  measurement id to a local array */
  switch(primary_meas_type)
  {
  case INTRA_FREQ:

    for (count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
    {
      if (intra_freq_meas_id_list[count].meas_id == *primary_meas_id_ptr)
      {
        /* Check if it has any additional meas */
        /* Additional Meas are always stored in Meas Id List in Ascending Order.
        Spec requirement is that additional meas should be appended in ascending order */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
        {
          if(intra_freq_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID)
          {
            addl_meas_found=1;
            addl_meas[cnt] = intra_freq_meas_id_list[count].additional_meas[cnt];
          }
        }
        /* Addtl Meas Stored in Local Variable */
        break;
      }
    } /* End of for of Intra Freq */
    break;


  case INTER_SYS:
    for (count = 0; count < MAX_INTER_RAT_MEAS; count++ )
    {
      if (inter_rat_meas_id_list[count].meas_id == *primary_meas_id_ptr)
      {
        /* Check if it has any additional meas */
        /* Additional Meas are always stored in Meas Id List in Ascending Order.
        Spec requirement is that additional meas should be appended in ascending order */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
        {
          if(inter_rat_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID)
          {
            addl_meas_found=1;
            addl_meas[cnt] = inter_rat_meas_id_list[count].additional_meas[cnt];
          }
        }
        /* Addtl Meas Stored in Local Variable */
        break;
      }
    } /* End of for of Inter RAT */
    break;

  case MAC_MEAS:
    for (count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
    {
      if (tvm_meas_id_list[count].meas_id == *primary_meas_id_ptr)
      {
        /* Check if it has any additional meas */
        /* Additional Meas are always stored in Meas Id List in Ascending Order.
        Spec requirement is that additional meas should be appended in ascending order */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
        {
          if(tvm_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID)
          {
            addl_meas_found=1;
            addl_meas[cnt] = tvm_meas_id_list[count].additional_meas[cnt];
          }
        }
        /* Addtl Meas Stored in Local Variable */
        break;
      }
    } /* End of for of Inter RAT */
    break;
  case INTERNAL_MEAS:
    for (count = 0; count < MAX_INTERNAL_MEAS; count++ )
    {
      if (ueim_meas_id_list[count].meas_id == *primary_meas_id_ptr)
      {
        /* Check if it has any additional meas */
        /* Additional Meas are always stored in Meas Id List in Ascending Order.
        Spec requirement is that additional meas should be appended in ascending order */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
        {
          if(ueim_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID)
          {
            addl_meas_found=1;
            addl_meas[cnt] = ueim_meas_id_list[count].additional_meas[cnt];
          }
        }
        /* Addtl Meas Stored in Local Variable */
        break;
      }
    } /* End of for of Internal Meas */
    break;

  case INTER_FREQ:

    for (count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
    {
      if (inter_freq_meas_id_list[count].meas_id == *primary_meas_id_ptr)
      {
        /* Check if it has any additional meas */
        /* Additional Meas are always stored in Meas Id List in Ascending Order.
        Spec requirement is that additional meas should be appended in ascending order */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
        {
          if(inter_freq_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID)
          {
            addl_meas_found=1;
            addl_meas[cnt] = inter_freq_meas_id_list[count].additional_meas[cnt];
          }
        }
        /* Addtl Meas Stored in Local Variable */
        break;
      }
    } /* End of for of Intra Freq */
    break;

  case QUALITY_MEAS:
    for (count = 0; count < MAX_QUALITY_MEAS; count++ )
    {
      if (quality_meas_id_list[count].meas_id == *primary_meas_id_ptr)
      {
        /* Check if it has any additional meas */
        /* Additional Meas are always stored in Meas Id List in Ascending Order.
        Spec requirement is that additional meas should be appended in ascending order */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
        {
          if(quality_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID)
          {
            addl_meas_found=1;
            addl_meas[cnt] = quality_meas_id_list[count].additional_meas[cnt];
          }
        }
        /* Addtl Meas Stored in Local Variable */
        break;
      }
    } /* End of for of Quality Meas */
    break;

  default:
    WRRC_MSG1_ERROR("Unsupported Primary Meas Type %d",primary_meas_type);
   rrc_free(ue_internal_meas);
   rrc_free(additional_tvm);
   rrc_free(l1_meas_results);
   rrc_free(inter_freq_l1_rpt);
   rrc_free(l1_rpt);
    return;
  } /* End of switch */


  /* Check if it has any additional meas */
  /* Additional Meas are always stored in Meas Id List in Ascending Order.
  Spec requirement is that additional meas should be appended in ascending order */

  if(addl_meas_found==1)
  {
    rpt_ptr->additionalMeasuredResults.n  = MAX_ADDITIONAL_MEAS;
    ALLOC_ASN1ARRAY2(&enc_ctxt,&rpt_ptr->additionalMeasuredResults,
          rrc_MeasuredResults);
    
      
  for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
  {
    if (addl_meas[cnt] != INVALID_MEAS_ID)
    {
      WRRC_MSG2_HIGH("Found Addl Meas %d, PrimMeas %d",
        addl_meas[cnt],*primary_meas_id_ptr);

      addl_meas_id = addl_meas[cnt];
      /* Additional Meas found. Get type of additional Meas. rpt_crit, validity not used */
      switch(rrcmeas_find_additional_meas_type(&addl_meas_id, &rpt_crit, &meas_validity))
      {
      case INTERNAL_MEAS:
        memset(ue_internal_meas,0,sizeof(l1_ue_internal_meas_rpt_struct_type));
        if (rrcmeas_append_internal_meas_results(&addl_meas[cnt], ue_internal_meas) == FALSE)
        {
          MSG_LOW("Addtl UEInternal Meas %d not appended",addl_meas[cnt],0,0);
        }
        else
        {
          MSG_LOW("Addtl UEInternal Meas %d appended", addl_meas[cnt],0,0);
          rpt_ptr->additionalMeasuredResults.elem[index].t = T_rrc_MeasuredResults_ue_InternalMeasuredResults;
          rrcmeas_append_internal_meas_results_ptr(
              &rpt_ptr->additionalMeasuredResults.elem[index],
              ue_internal_meas);
              
  
          index++;
          
        }
        break;
      case MAC_MEAS:
          memset(additional_tvm,0,sizeof(mac_ul_traffic_meas_ind_type));
        /* The called function would set additional meas bit mask if results are appended */
        if (rrctvm_append_traffic_vol_results(&addl_meas[cnt], additional_tvm) == FALSE)
        {
            MSG_LOW("Addtl TVM %d not appended",addl_meas[cnt],0,0);
        }
        else
        {
          MSG_LOW("Addtl TVM %d appended",addl_meas[cnt],0,0);
          rpt_ptr->additionalMeasuredResults.elem[index].t = T_rrc_MeasuredResults_trafficVolumeMeasuredResultsList;
          rrctvm_append_traffic_vol_results_ptr(
            &rpt_ptr->additionalMeasuredResults.elem[index],
            additional_tvm);
  
          index++;
        }
     
        break;

      case INTRA_FREQ:
          memset(l1_rpt,0,sizeof(l1_meas_rpt_struct_type));
        /* The called function would set additional meas bit mask if results are appended */
        if (rrcmeas_append_intra_freq_results(
#ifdef FEATURE_WCDMA_DC_HSUPA
            PRI_FREQ,
#endif
            &addl_meas[cnt], l1_rpt) == FALSE)
        {
          MSG_LOW("Addtl IntraFreq Meas %d not appended",addl_meas[cnt],0,0);
        }
        else
        {
          MSG_LOW("Addtl Intra Freq Meas %d appended", addl_meas[cnt],0,0);
          rpt_ptr->additionalMeasuredResults.elem[index].t = T_rrc_MeasuredResults_intraFreqMeasuredResultsList;
            
          rrcmeas_append_intra_freq_periodic_meas_results(&l1_rpt->u.intra_f_rpt[PRI_FREQ],
          rpt_ptr, &rpt_ptr->additionalMeasuredResults.elem[index].u.intraFreqMeasuredResultsList, TRUE);
            index++;
        }
#ifdef FEATURE_WCDMA_DC_HSUPA

          if(rrcmeas_append_intra_freq_results(
            SEC_FREQ,
            &addl_meas[cnt], l1_rpt) == FALSE)
          {
             WRRC_MSG1_HIGH("Addtl IntraFreq Meas %d not appended for Secondary",addl_meas[cnt]);
          }
          else
          {
             rpt_ptr->m.v390nonCriticalExtensionsPresent =1;

             rpt_ptr->v390nonCriticalExtensions.m.laterNonCriticalExtensionsPresent =1;
    
             rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.m.
                  v4b0NonCriticalExtensionsPresent =1;
    
             rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.
                v4b0NonCriticalExtensions.m.v590NonCriticalExtensionsPresent =1;
      
             rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.
                 v4b0NonCriticalExtensions.v590NonCriticalExtensions.m.v5b0NonCriticalExtensionsPresent = 1;
  
   
             rrc_mr_v590_ptr = &rpt_ptr->v390nonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.v590NonCriticalExtensions.v5b0NonCriticalExtensions;

             rrc_mr_v590_ptr->m.v690NonCriticalExtensionsPresent = 1;
       
             rrc_mr_v590_ptr->v690NonCriticalExtensions.m.v770NonCriticalExtensionsPresent = 1;

             rrc_mr_v590_ptr->v690NonCriticalExtensions.v770NonCriticalExtensions.m.v860NonCriticalExtensionsPresent = 1;
        
             rrc_mr_v860_ptr = &rrc_mr_v590_ptr->v690NonCriticalExtensions.v770NonCriticalExtensions.v860NonCriticalExtensions;
      
             rrc_mr_v860_ptr->m.v920NonCriticalExtensionsPresent = 1;

             rrc_mr_v920_ptr = &rrc_mr_v860_ptr->v920NonCriticalExtensions.measurementReport_v920ext;


             rrc_mr_v920_ptr->additionalMeasuredResultsOnSecUlFreq.n  = MAX_ADDITIONAL_MEAS;

             ALLOC_ASN1ARRAY2(&enc_ctxt,&rrc_mr_v920_ptr->additionalMeasuredResultsOnSecUlFreq,
                                   rrc_MeasuredResultsOnSecUlFreq);
    
            /* Set additional results to being present */

            rrc_mr_v920_ptr->m.additionalMeasuredResultsOnSecUlFreqPresent =1;
            sec_addl_meas_found=1;

            rrcmeas_append_intra_freq_periodic_meas_results_sec_freq(&l1_rpt->u.intra_f_rpt[SEC_FREQ],
                      rrc_mr_v920_ptr,
                      &rrc_mr_v920_ptr->additionalMeasuredResultsOnSecUlFreq.elem[sec_index].intraFreqMeasuredResultsList,
                      TRUE);
            WRRC_MSG1_HIGH("Addtl IntraFreq Meas %d appended for Secondary",addl_meas[cnt]);
           sec_index++;
        }
          #endif
      
        break; /* Out of switch */


      case INTER_SYS:
          memset(l1_meas_results,0,sizeof(l1_inter_sys_meas_result_struct_type));
        /* The called function would set additional meas bit mask if results are appended */
        if (rrcmeas_append_inter_rat_results(&addl_meas[cnt], l1_meas_results) == FALSE)
        {
          MSG_LOW("Addtl InterRAT Meas %d not appended",addl_meas[cnt],0,0);
        }
        else
        {
          MSG_LOW("Addtl InterRAT Meas %d appended", addl_meas[cnt],0,0);
          rpt_ptr->additionalMeasuredResults.elem[index].t = T_rrc_MeasuredResults_interRATMeasuredResultsList;
          rrcmeas_append_inter_rat_results_ptr(
          &rpt_ptr->additionalMeasuredResults.elem[index],
          l1_meas_results);
    
          if(rpt_ptr->additionalMeasuredResults.elem[index].t == T_rrc_MeasuredResults_interRATMeasuredResultsList)
            rrcirat_add_irat_cell_info_ind(rpt_ptr);
          index++;
        }
        break;

      case INTER_FREQ:
          memset(inter_freq_l1_rpt,0,sizeof(l1_meas_rpt_struct_type));
        if (rrcmeas_append_inter_freq_meas_results(&addl_meas[cnt], inter_freq_l1_rpt) == FALSE)
        {
          MSG_LOW("Addtl InterFreq Meas %d not appended",addl_meas[cnt],0,0);
        }
        else
        {
          MSG_LOW("Addtl InterFreq Meas %d appended", addl_meas[cnt],0,0);
          rpt_ptr->additionalMeasuredResults.elem[index].t = T_rrc_MeasuredResults_interFreqMeasuredResultsList;
          rrcmeas_append_inter_freq_meas_results_ptr(
              &rpt_ptr->additionalMeasuredResults.elem[index],
              inter_freq_l1_rpt);
          
          index++;
        }
        break;
      default:
        WRRC_MSG1_ERROR("Unknown type for Addtl Meas %d", addl_meas[cnt]);
        break;
      } /* End of switch */

    } /* End of if of Additional Meas != INVALID_MEAS_ID */
  } /* End of for loop of additional measurements */
    if(index >0)
    {
      /* Set additional results to being present  only when we have at least 1 meas appended*/
      RRC_MSG_COMMON_SET_BITMASK_IE_PTR(rpt_ptr,
      rrc_MeasurementReport,additionalMeasuredResults);
    }
    rpt_ptr->additionalMeasuredResults.n  = index;
    if(sec_addl_meas_found==1)
    {
      rrc_mr_v920_ptr->additionalMeasuredResultsOnSecUlFreq.n  = sec_index;
    }
  }
   rrc_free(ue_internal_meas);
   rrc_free(additional_tvm);
   rrc_free(l1_meas_results);
   rrc_free(inter_freq_l1_rpt);
   rrc_free(l1_rpt);
  return;
}   


#ifdef FEATURE_WCDMA_DC_HSUPA
/*===========================================================================

FUNCTION   RRCMEAS_FIND_ADDITIONAL_MEAS_TYPE_SEC_FREQ

DESCRIPTION

    This function checks if additional measurements exists in RRC database for secondary frequency
  . If it exists, it returns its type else returns unknown Measurement which essentially
    implies that the additional measurement does not exist. The function also returns
    the reporting criteria and meas validity as per the measurement type. The reporting criteria is used by
    the calling function to determine if UTRAN is trying to append an event triggered meas


DEPENDENCIES

    None.

RETURN VALUE

    None.

SIDE EFFECTS

    None

===========================================================================*/

rrcmeas_layer_e_type rrcmeas_find_additional_meas_type_sec_freq
(
 uint16* additional_meas_id_ptr,
 rpt_crit_enum_type* rpt_crit_ptr,
 meas_validity_enum_type* addtl_meas_validity_ptr
)
{
  uint8 count = 0;

  /* Check in Intra Freq Meas */
  for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
  {
    if (intra_freq_meas_id_list[count].meas_id == *additional_meas_id_ptr)
    {
      WRRC_MSG1_HIGH("Addt.Meas %d is Intra-Freq",*additional_meas_id_ptr);

      *rpt_crit_ptr = intra_freq_meas_id_list[count].rpt_crit[SEC_FREQ];

      *addtl_meas_validity_ptr = intra_freq_meas_id_list[count].meas_validity;

      return INTRA_FREQ;
    }
  }


  WRRC_MSG1_ERROR("Not Found. AddtMeas %d & its type",*additional_meas_id_ptr);
  return UNKNOWN_MEAS;

}
#endif

/*===========================================================================

FUNCTION   RRCMEAS_FIND_ADDITIONAL_MEAS_TYPE

DESCRIPTION

    This function checks if additional measurements exists in RRC database. If it
    exists, it returns its type else returns unknown Measurement which essentially
    implies that the additional measurement does not exist. The function also returns
    the reporting criteria and meas validity as per the measurement type. The reporting criteria is used by
    the calling function to determine if UTRAN is trying to append an event triggered meas


DEPENDENCIES

    None.

RETURN VALUE

    None.

SIDE EFFECTS

    None

===========================================================================*/

rrcmeas_layer_e_type rrcmeas_find_additional_meas_type
(
 uint16* additional_meas_id_ptr,
 rpt_crit_enum_type* rpt_crit_ptr,
 meas_validity_enum_type* addtl_meas_validity_ptr
)
{
  uint8 cnt = 0;
  /* Check in UE Internal Meas */
  for ( cnt = 0; cnt < MAX_INTERNAL_MEAS; cnt++ )
  {
    if (ueim_meas_id_list[cnt].meas_id == *additional_meas_id_ptr)
    {
      *rpt_crit_ptr = ueim_meas_id_list[cnt].rpt_crit;

      *addtl_meas_validity_ptr = ueim_meas_id_list[cnt].meas_validity;

      return INTERNAL_MEAS;
    }

  }
  /* Check in Intra Freq Meas */
  for ( cnt = 0; cnt < MAX_INTRA_FREQ_MEAS; cnt++ )
  {
    if (intra_freq_meas_id_list[cnt].meas_id == *additional_meas_id_ptr)
    {
      *rpt_crit_ptr =  intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ];

      *addtl_meas_validity_ptr = intra_freq_meas_id_list[cnt].meas_validity;

      return INTRA_FREQ;
    }
  }

  /* Check in Intra RAT Meas */
  for ( cnt = 0; cnt < MAX_INTER_RAT_MEAS; cnt++ )
  {
    if (inter_rat_meas_id_list[cnt].meas_id == *additional_meas_id_ptr)
    {
      *rpt_crit_ptr = inter_rat_meas_id_list[cnt].rpt_crit;

      *addtl_meas_validity_ptr = inter_rat_meas_id_list[cnt].meas_validity;

      return INTER_SYS;
    }

  }
  /* Check in Traffic Volume Meas */
  for (cnt = 0; cnt < MAX_TRAFFIC_VOLUME_MEASUREMENTS; cnt++)
  {
    if (tvm_meas_id_list[cnt].meas_id == *additional_meas_id_ptr)
    {
      *rpt_crit_ptr = tvm_meas_id_list[cnt].rpt_crit;

      *addtl_meas_validity_ptr = tvm_meas_id_list[cnt].meas_validity;

      return MAC_MEAS;
    }
  }


  /* Check in Intra Freq Meas */
  for ( cnt = 0; cnt < MAX_INTER_FREQ_MEAS; cnt++ )
  {
    if (inter_freq_meas_id_list[cnt].meas_id == *additional_meas_id_ptr)
    {
      *rpt_crit_ptr = inter_freq_meas_id_list[cnt].rpt_crit;

      *addtl_meas_validity_ptr = inter_freq_meas_id_list[cnt].meas_validity;

      return INTER_FREQ;
    }

  }

  /* Check in Quality Meas */
  for ( cnt = 0; cnt < MAX_QUALITY_MEAS; cnt++ )
  {
    if (quality_meas_id_list[cnt].meas_id == *additional_meas_id_ptr)
    {
      *rpt_crit_ptr = quality_meas_id_list[cnt].rpt_crit;

      *addtl_meas_validity_ptr = quality_meas_id_list[cnt].meas_validity;

      return QUALITY_MEAS;
    }
  }

  return UNKNOWN_MEAS;

}

/*===========================================================================

FUNCTION   RRCMEAS_APPEND_INTER_RAT_RESULTS

DESCRIPTION

    This function appends Inter-RAT Measured Results to any report.
    It first checks if additional measured results have already been appended
    the measurement report. If yes, then it increments the pointer to point
    to the next available space in additional measured result list


DEPENDENCIES

    The calling function must have initialized the additional measured
    results pointer

RETURN VALUE

    True
    False

SIDE EFFECTS

    None

===========================================================================*/

void rrcmeas_append_inter_rat_results_ptr
(
 rrc_MeasuredResults* measured_results_ptr,
 l1_inter_sys_meas_result_struct_type * l1_meas_results
)
{
    /* Contains Ptr to the head of GSM cells in one Inter-RAT system */
       rrc_GSM_MeasuredResultsList* local_rrc_gsm_list_ptr = NULL;
    
      /* Stores RSSI value */
      uint8 rssi_value = 0;
    
      uint8 gsm_cell_count = 0;  
   

  /* Set Additional Report type to Inter-RAT report */
  RRC_SET_COMMON_MSG_TYPE_PTR(measured_results_ptr,
  rrc_MeasuredResults_interRATMeasuredResultsList);

   measured_results_ptr->u.interRATMeasuredResultsList =
    rtxMemAllocTypeZ (&enc_ctxt, rrc_InterRATMeasuredResultsList);

   measured_results_ptr->u.interRATMeasuredResultsList->n =1;

   ALLOC_ASN1ARRAY2(&enc_ctxt,measured_results_ptr->u.interRATMeasuredResultsList,rrc_InterRATMeasuredResults);
  /* Allocate Mem for Inter-RAT Measured Results List */
  
  /* Set t to GSM */
  measured_results_ptr->u.interRATMeasuredResultsList->elem[0].t =
    T_rrc_InterRATMeasuredResults_gsm;

  /* Allocate Mem for GSM cells */
  local_rrc_gsm_list_ptr =
  rtxMemAllocTypeZ (&enc_ctxt, rrc_GSM_MeasuredResultsList);

  /* Assign Head Ptr */
  measured_results_ptr->u.interRATMeasuredResultsList->elem[0].u.gsm
    = local_rrc_gsm_list_ptr;

  local_rrc_gsm_list_ptr->n = l1_meas_results->inter_sys_msmt_results[0].u.gsm.measured_gsm_cells;

  ALLOC_ASN1ARRAY2(&enc_ctxt,local_rrc_gsm_list_ptr,rrc_GSM_MeasuredResults);
  
  /* For First RAT, read the GSM cell */
  for (gsm_cell_count = 0;
  gsm_cell_count < l1_meas_results->inter_sys_msmt_results[0].u.gsm.measured_gsm_cells;
  gsm_cell_count++)
  {

    RRC_RESET_MSG_IE_PRESENT(local_rrc_gsm_list_ptr->elem[gsm_cell_count]);

    /* If BSIC Verified */
    if (l1_meas_results->inter_sys_msmt_results[0].u.gsm.measured_cells[gsm_cell_count].bsic_choice
      == L1_BSIC_VERIFIED)
    {
      local_rrc_gsm_list_ptr->elem[gsm_cell_count].bsicReported.t = T_rrc_BSICReported_verifiedBSIC;

      WRRC_MSG1_HIGH("Verified BSIC is %d", l1_meas_results->inter_sys_msmt_results[0].u.gsm.
        measured_cells[gsm_cell_count].u.bsic_verified.inter_sys_cell_id);

      /* Set cell id to Verified BSIC */
      local_rrc_gsm_list_ptr->elem[gsm_cell_count].bsicReported.u.verifiedBSIC =
        l1_meas_results->inter_sys_msmt_results[0].u.gsm.measured_cells[gsm_cell_count].u.bsic_verified.inter_sys_cell_id;
    }
    else
    {
      local_rrc_gsm_list_ptr->elem[gsm_cell_count].bsicReported.t = T_rrc_BSICReported_nonVerifiedBSIC;

      WRRC_MSG1_HIGH("Non-Verified BSIC is %d", CONVERT_ARFCN_TO_NUM(l1_meas_results->inter_sys_msmt_results[0].u.gsm.
        measured_cells[gsm_cell_count].u.bsic_not_verified.bcch_arfcn));

      /* Set cell id to Non Verified BSIC */
      local_rrc_gsm_list_ptr->elem[gsm_cell_count].bsicReported.u.nonVerifiedBSIC =
        CONVERT_ARFCN_TO_NUM(l1_meas_results->inter_sys_msmt_results[0].u.gsm.
        measured_cells[gsm_cell_count].u.bsic_not_verified.bcch_arfcn);

    }

    /* Now set GSM time difference */
    if (l1_meas_results->inter_sys_msmt_results[0].u.gsm.
      measured_cells[gsm_cell_count].gsm_time_diff_incl == TRUE)
    {
      local_rrc_gsm_list_ptr->elem[gsm_cell_count].m.dummyPresent =1;

      /* GSM Time Difference */
      local_rrc_gsm_list_ptr->elem[gsm_cell_count].dummy2 =
        l1_meas_results->inter_sys_msmt_results[0].u.gsm.
        measured_cells[gsm_cell_count].gsm_time_diff;
    }

    /* Set RSSI value */
    if (l1_meas_results->inter_sys_msmt_results[0].u.gsm.
      measured_cells[gsm_cell_count].gsm_carrier_rssi_incl == TRUE)
    {
      /* Convert value from uint8 to oss bit string */
      rrcirat_convert_rssi_value(
        &l1_meas_results->inter_sys_msmt_results[0].u.gsm.
        measured_cells[gsm_cell_count].gsm_carrier_rssi, &rssi_value);

      /* Double check if value is O.K */
      if (rssi_value <= 63)
      {
       

       

        rssi_value = rssi_value << 2;     /*lint !e734 */

        /* Put Actual Value to be 6 bits */
        local_rrc_gsm_list_ptr->elem[gsm_cell_count].gsm_CarrierRSSI.numbits= 6;

        *(local_rrc_gsm_list_ptr->elem[gsm_cell_count].gsm_CarrierRSSI.data) = (unsigned char ) (rssi_value);


        /* Set RSSI value present in Meas Report */
        local_rrc_gsm_list_ptr->elem[gsm_cell_count].m.gsm_CarrierRSSIPresent =1;

      }  /* End of rssi value less than MAX_RSSI */

    } /* End of RSSI included */
   
  } /* End of for loop of gsm_cell_count */

}
/*===========================================================================

FUNCTION   RRCMEAS_APPEND_INTER_RAT_RESULTS

DESCRIPTION

    This function appends Inter-RAT Measured Results to any report.
    It first checks if additional measured results have already been appended
    the measurement report. If yes, then it increments the pointer to point
    to the next available space in additional measured result list


DEPENDENCIES

    The calling function must have initialized the additional measured
    results pointer

RETURN VALUE

    True
    False

SIDE EFFECTS

    None

===========================================================================*/
boolean rrcmeas_append_inter_rat_results
(
 uint8* meas_id_ptr,
 l1_inter_sys_meas_result_struct_type * l1_meas_results
)
{
  /* Passed to L1 to get Inter-RAT Measured Results */
  

  boolean addtl_meas_present = FALSE;

  
#ifndef FEATURE_WCDMA_FREE_FLOATING_TASK
  WCDMA_RRC_TASK_LOCK();

  if (l1m_is_connected())
  {
    addtl_meas_present = l1_get_periodic_inter_rat_msmt_results(*meas_id_ptr,l1_meas_results);
  }

  WCDMA_RRC_TASK_FREE();
#else

  if (l1m_is_connected())
  {
    addtl_meas_present = rrcff_l1_get_periodic_inter_rat_msmt_results(*meas_id_ptr,l1_meas_results);
  }
#endif

  /* Call L1 function to determine if report can be appended */
  if (addtl_meas_present == FALSE)
  {
    return FALSE;
  }

  /* Validate Measured Results */
  if (rrcirat_validate_measured_results(l1_meas_results) == FAILURE)
  {
    return FALSE;
  }

  /* Check for 0 cells as this has not been validated */
  if (l1_meas_results->inter_sys_msmt_results[0].u.gsm.measured_gsm_cells == 0)
  {
    return FALSE;
  }

  return TRUE;
}

/*===========================================================================

FUNCTION   RRCMEAS_APPEND_INTRA_FREQ_RESULTS

DESCRIPTION

    This function appends Intra-Freq Measured Results to any report.
    It first checks if additional measured results have already been appended
    the measurement report. If yes, then it increments the pointer to point
    to the next space in additional measured result list and sets the result
    in that location. Additional Measurement Identity passed to
    this function has already been validated

DEPENDENCIES

    The calling function must have initialized the additional measured
    results pointer

RETURN VALUE

    True if results successfully appended
    False otherwise

SIDE EFFECTS

    None

===========================================================================*/
boolean rrcmeas_append_intra_freq_results
(
#ifdef FEATURE_WCDMA_DC_HSUPA
 uint8 freq_type,
#endif
 uint8* meas_id_ptr,
 l1_meas_rpt_struct_type * l1_meas_report_ptr
)
{
  /* Dggeclared for storing additional measured results */
  

  boolean addtl_meas_present = FALSE;
#ifdef FEATURE_WCDMA_DC_HSUPA
  uint8 freq_idx = freq_type;
#else
    uint8 freq_idx = PRI_FREQ;
#endif

  /* The whole rpt decaltred to make use of the existing fn */
  
  l1_meas_report_ptr->u.intra_f_rpt[freq_idx].rpt_crit = L1_PERIODIC_RPT;

#ifndef FEATURE_WCDMA_FREE_FLOATING_TASK
  WCDMA_RRC_TASK_LOCK();

  if (l1m_is_connected())
  {
    addtl_meas_present = l1_get_additional_intra_freq_msmt_results(freq_idx,*meas_id_ptr,
                                                                   & l1_meas_report_ptr->u.intra_f_rpt[freq_idx]);
  }

  WCDMA_RRC_TASK_FREE();
#else
  if (l1m_is_connected())
  {
    addtl_meas_present = rrcff_l1_get_additional_intra_freq_msmt_results(*meas_id_ptr,
                                                                         & l1_meas_report_ptr->u.intra_f_rpt[freq_idx],freq_idx);
  }
#endif

  if (addtl_meas_present == FALSE)
  {
    return FALSE;
  }

  /* Validate the measured results */
  if (rrcmeas_validate_intra_freq_report(l1_meas_report_ptr) == RRCMEAS_FAIL)
  {
    return FALSE;
  }

  if ( l1_meas_report_ptr->u.intra_f_rpt[freq_idx].num_cells == 0)
  {
    return FALSE;
  }
  /* Validation is successful */

  return TRUE;
}


/*===========================================================================

FUNCTION   RRCMEAS_CONFIG_INTRA_FREQ_DB

DESCRIPTION

  Sets Intra Freq Reporting Criteria in RRC Measurement Database
  from Measurement Control Message after the validation of
  the message has been completed

DEPENDENCIES

  None

RETURN VALUE

  None

SIDE EFFECTS

  None
===========================================================================*/

boolean rrcmeas_config_intra_freq_db
(
 l1_meas_ctrl_parm_struct_type* l1_mcm_ptr,
 meas_validity_enum_type m_validity
)
{
  uint16 cnt = 0;
  /* First check if the meas id already exists */

  /* SETUP existing & MODIFY scenario */
  for ( cnt = 0; cnt < MAX_INTRA_FREQ_MEAS; cnt++ )
  {
    if (intra_freq_meas_id_list[cnt].meas_id == l1_mcm_ptr->meas_id)
    {
      MSG_HIGH("Meas id found...Before commiting Id %d, Val %d, Owner %d",intra_freq_meas_id_list[cnt].meas_id,
        intra_freq_meas_id_list[cnt].meas_validity,
        intra_freq_meas_id_list[cnt].mcm_owned);

      /* If a setup, always overwrite validity */
      if (l1_mcm_ptr->meas_cmd == L1_MEAS_SETUP)
      {
        /* Set Validity */
        intra_freq_meas_id_list[cnt].meas_validity = m_validity;
      }
      /* For MODIFY scenario, when validity not specified */
      else if ((l1_mcm_ptr->meas_cmd == L1_MEAS_MODIFY) &&
        (l1_mcm_ptr->meas_object_info_included == TRUE) &&
        (m_validity == NOT_PRESENT))
      {
        MSG_LOW("Retain Current Validity %d", intra_freq_meas_id_list[cnt].meas_validity,0,0);
      }
      /* UTRAN specified Meas Validity with a Modify */
      else if ((l1_mcm_ptr->meas_cmd == L1_MEAS_MODIFY) &&
        (l1_mcm_ptr->meas_object_info_included == TRUE) &&
        (m_validity != NOT_PRESENT))
      {
        MSG_LOW("Overwrite Current Validity %d with %d",
          intra_freq_meas_id_list[cnt].meas_validity,m_validity,0);

        intra_freq_meas_id_list[cnt].meas_validity = m_validity;
      }
      else /* To satisfy LINT */
      {
        /* Normal processing */
      }

      /* MCM is the owner of this meas */
      intra_freq_meas_id_list[cnt].mcm_owned = TRUE;

      /* This Meas can be reported */
      intra_freq_meas_id_list[cnt].meas_can_be_reported = TRUE;

      /* Set Report Criteria */
      /* Do not modify rpt_crit for RPT_MODE_NOT_PRESENT and NO_CHANGE */
      if ((l1_mcm_ptr->meas_object_info_included == TRUE) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[PRI_FREQ] != L1_RPT_MODE_NOT_PRESENT) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[PRI_FREQ] != L1_NO_CHANGE))
      {
          intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ] =
          MEAS_RPT_CRIT(l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[PRI_FREQ]);
      }
      WRRC_MSG1_HIGH("Meas Crit for Primary freq %d ",  intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ]);

#ifdef FEATURE_WCDMA_DC_HSUPA
      /* Set Report Criteria */
      /* Do not modify rpt_crit for RPT_MODE_NOT_PRESENT and NO_CHANGE */
      if ((l1_mcm_ptr->meas_object_info_included == TRUE) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[SEC_FREQ] != L1_RPT_MODE_NOT_PRESENT) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[SEC_FREQ] != L1_NO_CHANGE))
      {
          intra_freq_meas_id_list[cnt].rpt_crit[SEC_FREQ] =
          MEAS_RPT_CRIT(l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[SEC_FREQ]);

      }
      WRRC_MSG1_HIGH("Meas Crit for secondary freq %d", intra_freq_meas_id_list[cnt].rpt_crit[SEC_FREQ]);	  
#endif


      MSG_HIGH("After commiting. Id %d, Val %d, Owner %d", intra_freq_meas_id_list[cnt].meas_id,
        intra_freq_meas_id_list[cnt].meas_validity,
        intra_freq_meas_id_list[cnt].mcm_owned);
      return TRUE;
    }

  } /* End of for loop */

  /* SETUP not existing scenario */
  for ( cnt = 0; cnt < MAX_INTRA_FREQ_MEAS; cnt++ )
  {
    /* If Meas Id not found, then it is a new Meas. Set it in first available position */
    if (intra_freq_meas_id_list[cnt].meas_id == INVALID_MEAS_ID)
    {
      MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH, 
        "Before commiting. Id %d, Val %d, Owner %d. Setting Meas Id = %d in RRC db",intra_freq_meas_id_list[cnt].meas_id,
        intra_freq_meas_id_list[cnt].meas_validity,
        intra_freq_meas_id_list[cnt].mcm_owned,
        l1_mcm_ptr->meas_id);

#ifdef FEATURE_WCDMA_DC_HSUPA	  
      intra_freq_meas_id_list[cnt].rpt_crit[SEC_FREQ] = NOT_AVAILABLE;
#endif
      intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ] = NOT_AVAILABLE;

      intra_freq_meas_id_list[cnt].meas_id = l1_mcm_ptr->meas_id;

      intra_freq_meas_id_list[cnt].meas_validity = m_validity;

      intra_freq_meas_id_list[cnt].mcm_owned = TRUE;

      intra_freq_meas_id_list[cnt].meas_can_be_reported = TRUE;

      /* Set Report Criteria */
      /* Do not modify rpt_crit for RPT_MODE_NOT_PRESENT and NO_CHANGE */
      if ((l1_mcm_ptr->meas_object_info_included == TRUE) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[PRI_FREQ] != L1_RPT_MODE_NOT_PRESENT) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[PRI_FREQ] != L1_NO_CHANGE))
      {
           intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ] =
           MEAS_RPT_CRIT(l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[PRI_FREQ]);

      }
      WRRC_MSG1_HIGH("Meas Crit for Primary freq %d",  intra_freq_meas_id_list[cnt].rpt_crit[PRI_FREQ]);

#ifdef FEATURE_WCDMA_DC_HSUPA
       /* Set Report Criteria */
      /* Do not modify rpt_crit for RPT_MODE_NOT_PRESENT and NO_CHANGE */
       if ((l1_mcm_ptr->meas_object_info_included == TRUE) &&
           (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[SEC_FREQ] != L1_RPT_MODE_NOT_PRESENT) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[SEC_FREQ] != L1_NO_CHANGE))
       {
           intra_freq_meas_id_list[cnt].rpt_crit[SEC_FREQ] =
           MEAS_RPT_CRIT(l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[SEC_FREQ]);

       }
       WRRC_MSG1_HIGH("Meas Crit for secondary freq %d", intra_freq_meas_id_list[cnt].rpt_crit[SEC_FREQ]);
#endif

      MSG_HIGH("After commiting. Id %d, Val %d, Owner %d", intra_freq_meas_id_list[cnt].meas_id,
               intra_freq_meas_id_list[cnt].meas_validity,
               intra_freq_meas_id_list[cnt].mcm_owned);

      return TRUE;
    }

  } /* End of for loop */

  WRRC_MSG0_ERROR("RRC MeasDB for IntraFreq FULL!!");
  return FALSE;

}

/*===========================================================================

FUNCTION   RRCMEAS_DELETE_MEAS

DESCRIPTION

  Removes Intra Freq Meas Information in RRC Measurement Database.

DEPENDENCIES

  None

RETURN VALUE

  None

SIDE EFFECTS

  None
===========================================================================*/

void rrcmeas_delete_meas(uint16* meas_id_ptr)
{
  uint8 count = 0, cnt = 0;
  /* Check in Intra Freq Meas */
  for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
  {
    if (intra_freq_meas_id_list[count].meas_id == *meas_id_ptr)
    {
      WRRC_MSG1_HIGH("Intra Freq Meas %d deleted",*meas_id_ptr);

      /* Make Meas Id Invalid */
      intra_freq_meas_id_list[count].meas_id = INVALID_MEAS_ID;

      intra_freq_meas_id_list[count].meas_validity = NOT_PRESENT;

      intra_freq_meas_id_list[count].mcm_owned = FALSE;

       intra_freq_meas_id_list[count].rpt_crit[PRI_FREQ] = NOT_AVAILABLE;
#ifdef FEATURE_WCDMA_DC_HSUPA
      intra_freq_meas_id_list[count].rpt_crit[SEC_FREQ] = NOT_AVAILABLE;
#endif

      intra_freq_meas_id_list[count].meas_validity = NOT_PRESENT;

      intra_freq_meas_id_list[count].meas_can_be_reported = TRUE;

      /* Just delete the addtl meas associated with this identity
      The actual measurement still exists */
      for (cnt=0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
      {
        intra_freq_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
      }
      /* Come out of for */
      break;
    }
  }
}


/*===========================================================================

FUNCTION   RRCMEAS_SET_ADDITIONAL_MEAS_IN_DB

DESCRIPTION

  This function sets Additional Measurements in
  RRC database for the measurement type. This function is only called if
  it has been determined previously that the primary measurement exists
  and the new additional measurement does not conflict with the primary
  measurement validity and reporting criteria


DEPENDENCIES

  None

RETURN VALUE

  None

SIDE EFFECTS

  None

===========================================================================*/

void rrcmeas_set_additional_meas_in_db
(
 rrcmeas_layer_e_type* meas_type_ptr,
 rrc_AdditionalMeasurementID_List * additional_list_ptr,
 uint32 meas_id
)
{
  uint8 count = 0, cnt = 0;
  boolean adnl_meas_exist;
  uint32 idx=0;
  switch(*meas_type_ptr)
  {
  case INTRA_FREQ:
    /* Now Store Additional Meas in RRC DB */

    for (count = 0; count < MAX_INTRA_FREQ_MEAS; count++)
    {
      if (intra_freq_meas_id_list[count].meas_id == meas_id)
      {
        /* Store Additional Meas */
        while (additional_list_ptr->n > idx)
        {
          adnl_meas_exist = FALSE;
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          {
            if ((intra_freq_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID) &&
            (intra_freq_meas_id_list[count].additional_meas[cnt] == (uint8) additional_list_ptr->elem[idx]))
            {
            //added
              adnl_meas_exist= TRUE;
              idx++;
              break;
            }
          }
          if(!adnl_meas_exist)
          {
            for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            {
              if (intra_freq_meas_id_list[count].additional_meas[cnt] == INVALID_MEAS_ID)
              {
                /* Set additional Meas Identity in this place */
                WRRC_MSG1_HIGH("Addtl Meas %d stored", additional_list_ptr->elem[idx]);
                intra_freq_meas_id_list[count].additional_meas[cnt] = (uint8) additional_list_ptr->elem[idx];
                idx++;

                break; /* COME OUT OF FOR */
              }
            } /* End of for of cnt loop */
            if (cnt == MAX_ADDITIONAL_MEAS)
            {
              return;
            }
          }

        } /* End of while of additional_list_ptr */
        break; /* Come out of for loop */
      } /* End of if of measurement identity */
    } /* End of for loop */

    break; /* Come out of switch */


  case INTER_FREQ:
    idx=0;
    for (count = 0; count < MAX_INTER_FREQ_MEAS; count++)
    {
      if (inter_freq_meas_id_list[count].meas_id == meas_id)
      {
        /* Store Additional Meas */
        while (additional_list_ptr->n > idx)
        {
          adnl_meas_exist = FALSE;
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          {
            if ((inter_freq_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID) &&
               (inter_freq_meas_id_list[count].additional_meas[cnt] == (uint8) additional_list_ptr->elem[idx]))
            {
             //added
              adnl_meas_exist= TRUE;
              idx++;
              break;
            }
          }
          if(!adnl_meas_exist)
          {
            for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            {
              if (inter_freq_meas_id_list[count].additional_meas[cnt] == INVALID_MEAS_ID)
              {
                /* Set additional Meas Identity in this place */
                WRRC_MSG1_HIGH("IFreq:Addtl Meas %d stored", additional_list_ptr->elem[idx]);
                inter_freq_meas_id_list[count].additional_meas[cnt] = (uint8) additional_list_ptr->elem[idx];
                idx++;

                break; /* COME OUT OF FOR */
              }
            } /* End of for of cnt loop */
            if (cnt == MAX_ADDITIONAL_MEAS)
            {
              return;
            }
          }
        } /* End of while of additional_list_ptr */
        break; /* Come out of for loop */
      } /* End of if of measurement identity */
    } /* End of for loop */

    break;


  case INTER_SYS:
    /* Now Store Additional Meas in RRC DB */
    idx=0;
    for (count = 0; count < MAX_INTER_RAT_MEAS; count++)
    {
      if (inter_rat_meas_id_list[count].meas_id == meas_id)
      {
        /* Store Additional Meas */
        while (additional_list_ptr->n > idx)
        {
          adnl_meas_exist = FALSE;
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          {
            if ((inter_rat_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID) &&
               (inter_rat_meas_id_list[count].additional_meas[cnt] == (uint8) additional_list_ptr->elem[idx]))
            {
              //added
              adnl_meas_exist= TRUE;
              idx++;
              break;
            }
          }
          if(!adnl_meas_exist)
          {
            for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            {
              if (inter_rat_meas_id_list[count].additional_meas[cnt] == INVALID_MEAS_ID)
              {
                /* Set additional Meas Identity in this place */
                WRRC_MSG1_HIGH("Addtl Meas %d stored", additional_list_ptr->elem[idx]);
                inter_rat_meas_id_list[count].additional_meas[cnt] = (uint8) additional_list_ptr->elem[idx];
                idx++;

                break; /* COME OUT OF FOR */
              }
            } /* End of for of cnt loop */
            if (cnt == MAX_ADDITIONAL_MEAS)
            {
              return;
            }
          }
        } /* End of while of additional_list_ptr */
        break; /* Come out of for loop */
      } /* End of if of measurement identity */
    } /* End of for loop */

    break; /* Come out of switch */

  case INTERNAL_MEAS:
    /* Now Store Additional Meas in RRC DB */
    idx=0;
    for (count = 0; count < MAX_INTERNAL_MEAS; count++)
    {
      if (ueim_meas_id_list[count].meas_id == meas_id)
      {
        /* Store Additional Meas */
        while (additional_list_ptr->n > idx)
        {
          adnl_meas_exist = FALSE;
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          {
            if ((ueim_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID) &&
               (ueim_meas_id_list[count].additional_meas[cnt] == (uint8) additional_list_ptr->elem[idx]))
            {
              //added
              adnl_meas_exist= TRUE;
              idx++;
              break;
            }
          }
          if(!adnl_meas_exist)
          {
            for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            {
              if (ueim_meas_id_list[count].additional_meas[cnt] == INVALID_MEAS_ID)
              {
                /* Set additional Meas Identity in this place */
                WRRC_MSG1_HIGH("Addtl Meas %d stored", additional_list_ptr->elem[idx]);
                ueim_meas_id_list[count].additional_meas[cnt] = (uint8) additional_list_ptr->elem[idx];
                idx++;

                break; /* COME OUT OF FOR */
              }
            } /* End of for of cnt loop */
            if (cnt == MAX_ADDITIONAL_MEAS)
            {
              return;
            }
          }
        } /* End of while of additional_list_ptr */
        break; /* Come out of for loop */
      } /* End of if of measurement identity */
    } /* End of for loop */

    break; /* Come out of switch */

  case MAC_MEAS:
    idx=0;
    for (count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++)
    {
      if (tvm_meas_id_list[count].meas_id == meas_id)
      {
        /* Store Additional Meas */
        while (additional_list_ptr->n > idx)
        {
          adnl_meas_exist = FALSE;
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          {
            if ((tvm_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID) &&
               (tvm_meas_id_list[count].additional_meas[cnt] == (uint8) additional_list_ptr->elem[idx]))
            {
              //added
              adnl_meas_exist= TRUE;
              idx++;
              break;
            }
          }
          if(!adnl_meas_exist)
          {
            for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            {
              if (tvm_meas_id_list[count].additional_meas[cnt] == INVALID_MEAS_ID)
              {
                /* Set additional Meas Identity in this place */
                tvm_meas_id_list[count].additional_meas[cnt] = (uint8) additional_list_ptr->elem[idx];
                idx++;

                break;
              }
            } /* End of for of cnt loop */
            if (cnt == MAX_ADDITIONAL_MEAS)
            {
              return;
            }
          }
        } /* End of while of additional_list_ptr */
        break;  /* Come out of for loop */
      } /* End of if of  measurement identity */

    } /* End of for */
    break;

  case QUALITY_MEAS:
    /* Now Store Additional Meas in RRC DB */
    idx=0;
    for (count = 0; count < MAX_QUALITY_MEAS; count++)
    {
      if (quality_meas_id_list[count].meas_id == meas_id)
      {
        /* Store Additional Meas */
        while (additional_list_ptr->n > idx)
        {
          adnl_meas_exist = FALSE;
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          {
            if ((quality_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID) &&
              (quality_meas_id_list[count].additional_meas[cnt] == (uint8) additional_list_ptr->elem[idx]))
            {
              //added
              adnl_meas_exist= TRUE;
              idx++;
              break;
            }
          }
          if(!adnl_meas_exist)
          {
            for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            {
              if (quality_meas_id_list[count].additional_meas[cnt] == INVALID_MEAS_ID)
              {
                /* Set additional Meas Identity in this place */
                WRRC_MSG1_HIGH("Addtl Meas %d stored", additional_list_ptr->elem[idx]);
                quality_meas_id_list[count].additional_meas[cnt] = (uint8) additional_list_ptr->elem[idx];
                idx++;

                break; /* COME OUT OF FOR */
              }
            } /* End of for of cnt loop */
            if (cnt == MAX_ADDITIONAL_MEAS)
            {
              return;
            }
          }
        } /* End of while of additional_list_ptr */
        break; /* Come out of for loop */
      } /* End of if of measurement identity */
    } /* End of for loop */

    break; /* Come out of switch */


  default:
    break;
  } /* End of switch */
  return;
}



/*===========================================================================

FUNCTION   RRCMEAS_VALIDATE_ADDITIONAL_MEAS

DESCRIPTION

    This function checks if additional measurements exists in RRC database and have the
    same validity as the primary measurement. If it
    exists, it returns its type else returns unknown Measurement which essentially
    implies that the additional measurement does not exist. The function also returns
    the reporting criteria as per the measurement type. The reporting criteria is used by
    the calling function to determine if UTRAN is trying to append an event triggered meas
    The function also sends Measurement Control Failure Message in case of error cond.
    This function is only used if primary measurement is other than Traffic Volume
    Measurements


DEPENDENCIES

    None.

RETURN VALUE

    True if additional measurement has been validated successfully
    False Otherwise

SIDE EFFECTS

    None

===========================================================================*/

boolean rrcmeas_validate_additional_meas
(
  rrc_AdditionalMeasurementID_List * additional_list_ptr,
  uint32 tr_id,
  rrcmeas_layer_e_type* primary_meas_type_ptr,
  uint32 mid
)
{
  rrcmeas_layer_e_type additional_meas_type;

  rpt_crit_enum_type a_rpt_crit;

  uint16 additional_meas_id;
  uint32 idx =0;
  uint8 transaction_id = INVALID_TRANSACTION_ID;
  /* Set validity to default value */
  meas_validity_enum_type addtl_meas_validity = NOT_PRESENT;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;
  transaction_id = tr_id;

  switch (*primary_meas_type_ptr)
  {
  case INTRA_FREQ:
  case INTER_FREQ:
  case INTER_SYS:
  case QUALITY_MEAS:
  case INTERNAL_MEAS:


    /* Now compare if validity is the same */
    while (additional_list_ptr->n  > idx)
    {
      additional_meas_id = (uint16) additional_list_ptr->elem[idx];

      /* First check if additional measurement exists in RRC DB or not */

      additional_meas_type = rrcmeas_find_additional_meas_type(&additional_meas_id, &a_rpt_crit, &addtl_meas_validity);

      MSG_HIGH("Addtl Meas %d,PMeas %d, add_meas type %d",additional_meas_id,
          mid,additional_meas_type);

      if (additional_meas_type == UNKNOWN_MEAS)
      {
        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

        return FALSE;
      } /* End of if of rrcmeas_find_additional_meas_type */


      if (additional_meas_type == QUALITY_MEAS)
      {
        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_invalidConfiguration;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

        return FALSE;
      }
      /* To Add check if more than one meas of same type would be include with Prim Meas */

      /* UTRAN might messup by making addtl meas as Event Triggered for
      Intra Freq, Inter Freq, Inter RAT */
      if (((additional_meas_type == INTER_FREQ) && (a_rpt_crit == EVENT)) ||
        ((additional_meas_type == INTER_SYS)  && (a_rpt_crit == EVENT)) ||
        ((additional_meas_type == INTRA_FREQ)  && (a_rpt_crit == EVENT)))
      {
        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

        return FALSE;
      }
      /* Get VALIDITY of primary measurement */

      /* Check validity of the additional and primary meas */
      /* Since Primary is an intra-freq meas, it is valid in CELL_DCH only */
      if (addtl_meas_validity == ALL_STATES_BUT_DCH)
      {
        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_invalidConfiguration;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

        return FALSE;
      }
      else
      {
        MSG_LOW("Validity Addtl & Primary Meas Match",0,0,0);
      }

      /* Go to the next addtl Meas to be appended */
      idx++;

    } /* End of while */

    break;

  default:
    /* Bail Out */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
    rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

        return FALSE;
  } /* End of switch */
  return TRUE;
}


/*===========================================================================

FUNCTION   RRCMEAS_DELETE_ADDTL_MEAS

DESCRIPTION

    This function deletes any additional measurement that may be present
  in any of the MEASUREMENT_IDENTITY list at RRC level. The primary
  measurement identity has already been deleted


DEPENDENCIES

    None

RETURN VALUE

    None

SIDE EFFECTS

    None

===========================================================================*/

void rrcmeas_delete_addtl_meas(uint16* prim_meas_id_ptr)
{
/* Check if the primary meas id that has already been deleted was configured as addtl meas
  in any of the MEASUREMENT_IDENTITY variable. If yes, delete it */

  uint8 count = 0, cnt = 0;
  rrcmeas_layer_e_type meas_type = NOT_EXIST;

  /* The deleted additional meas can be present in more than on MEAS_ID list.
  So check in all of them */

  for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
  {
    for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
    {
      if (intra_freq_meas_id_list[count].additional_meas[cnt] == *prim_meas_id_ptr)
      {
        meas_type = INTRA_FREQ;
        intra_freq_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
      }
    }
  } /* End of for loop */


  /* Search in Traffic Volume List */
  for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
  {
    for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
    {
      if (tvm_meas_id_list[count].additional_meas[cnt] == *prim_meas_id_ptr)
      {
        meas_type = MAC_MEAS;
        tvm_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
      }
    }
  } /* End of for loop */

  for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
  {
    for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
    {
      if (inter_rat_meas_id_list[count].additional_meas[cnt] == *prim_meas_id_ptr)
      {
        meas_type = INTER_SYS;
        inter_rat_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
      }
    }
  } /* End of for loop */

  for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
  {
    for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
    {
      if (ueim_meas_id_list[count].additional_meas[cnt] == *prim_meas_id_ptr)
      {
        meas_type = INTERNAL_MEAS;  
        ueim_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
      }
    }
  } /* End of for loop */

  for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
  {
    for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
    {
      if (inter_freq_meas_id_list[count].additional_meas[cnt] == *prim_meas_id_ptr)
      {
        meas_type = INTER_FREQ;  
        inter_freq_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
      }
    }
  } /* End of for loop */

  WRRC_MSG2_HIGH("Delete Addtl Meas Id %d of meas type %d",*prim_meas_id_ptr,meas_type);

  /* To add code once other measurements get supported */
  return;
}


/*===========================================================================

FUNCTION  RRCMEAS_FILL_HCS_INFO

DESCRIPTION

 This function fills the overall HCS info for an Intra Freq Cell.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill cell info correctly
 SUCCESS: If Cell Info is filled correctly

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_fill_hcs_info
(
  rrc_MeasurementControlSysInfo* sib_meas_ctrl_ptr
  ,rrc_SysInfoType11_v590ext_IEs *sib11_rel5_ext_ptr
)
{
  /* Allocate a pointer for ease in readability */
  rrc_IntraFreqMeasurementSysInfo_HCS_RSCP *intra_freq_meas_rscp_ptr = NULL;
  rrc_IntraFreqMeasurementSysInfo_HCS_ECN0  *intra_freq_meas_ecn0_ptr = NULL;

  /* Allocate pointer to read intra freq cell list */
  rrc_NewIntraFreqCellSI_List_HCS_RSCP   *rscp_intra_freq_cell_list_ptr = NULL;
  rrc_NewIntraFreqCellSI_List_HCS_ECN0   *ecn0_intra_freq_cell_list_ptr = NULL;

  uint16   cell_count = 0;
  uint32 idx=0;
  uint32 cell_position = 0;
  rrc_SysInfoType11_v590ext_IEs_newIntraFrequencyCellInfoList_v590ext * rel5_ext_ptr = NULL;
  rrc_SysInfoType18 *sib18_ptr = NULL; /* Declared to store the value of SIB 18*/
  rrc_PLMNsOfIntraFreqCellsList *tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = NULL;
  rrc_MultiplePLMNsOfIntraFreqCellsList *tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr = NULL;
  rrc_plmn_identity_type tmp_plmn_identity;
  rrc_plmn_identity_type selected_plmn_identity;
  rrc_int_cell_id_type  tmp_cell_id;
  boolean sib18_present = FALSE;
  uint16 prev_cell_count = 0;
  tmp_plmn_identity.mcc[0] =  tmp_plmn_identity.mcc[1] = tmp_plmn_identity.mcc[2] = 0;
  tmp_plmn_identity.num_mnc_digits = 0;
  tmp_plmn_identity.mnc[0] =  tmp_plmn_identity.mnc[1] = 0;
   /* SIB18 */
  if((sib18_ptr = (rrc_SysInfoType18*)  rrc_sibdb_return_sib_for_srv_cell
    (rrc_SIB18)) != NULL)
  {
  
    if(((rrcmeas_current_substate == RRCMEAS_CELL_DCH)
      || (rrcmeas_current_substate == RRCMEAS_PCH)
      || (rrcmeas_current_substate == RRCMEAS_CELL_FACH)))
    {
      /*
       1>if System Information Block type 11bis is scheduled on BCH:
       2>the PLMN lists to be considered are the ones included, when present, in the IE "Connected mode PLMN identities for SIB 11bis"; 
       2>otherwise,
                 the UE shall use, in place of any missing list, when present, the corresponding one in the IE "Idle mode PLMN identities for SIB11bis";
       2>otherwise,
                 the UE shall use, in place of any missing list, when present, the corresponding one in the IE "Connected mode PLMN identities"; 
       2>otherwise, 
                 the UE shall use, in place of any missing list, the corresponding one in the IE "Idle mode PLMN identities";
       
       1> else
       2>the PLMN lists to be considered are the ones included, when present, in the IE "Connected mode PLMN identities"; 
       2>otherwise,
                 the UE shall use, in place of any missing list, the corresponding one in the IE "Idle mode PLMN identities";
      */
      if((rrc_sibdb_is_sib11bis_present_in_srv_cell()) &&
        (RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
          (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext,
       connectedModePLMNIdentitiesSIB11bis)) &&
          (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.connectedModePLMNIdentitiesSIB11bis,
            plmnsOfIntraFreqCellsList)) &&
          (sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.connectedModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.
            connectedModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11bis:SIB11 processing SIB18 Conn Intra Freq from bis extension ");
        sib18_present = TRUE;
      }
      else if((rrc_sibdb_is_sib11bis_present_in_srv_cell()) &&
        (sib18_ptr->m.v6b0NonCriticalExtensionsPresent) &&
          (sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.m.idleModePLMNIdentitiesSIB11bisPresent) &&
          (sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.idleModePLMNIdentitiesSIB11bis.m.plmnsOfIntraFreqCellsListPresent) &&
          (sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.idleModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.
            idleModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11bis:SIB11 processing SIB18 idle Intra Freq from bis extension ");
        sib18_present = TRUE;
      }
      else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions,v860NonCriticalExtensions))&&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext,connectedModePLMNIdentities)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.connectedModePLMNIdentities,multipleplmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.connectedModePLMNIdentities.multipleplmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.connectedModePLMNIdentities.multipleplmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11 processing SIB18 Conn Multiple PLMNs Intra Freq");
        sib18_present = TRUE;
      }
      else if((sib18_ptr->m.connectedModePLMNIdentitiesPresent) &&
        (sib18_ptr->connectedModePLMNIdentities.m.plmnsOfIntraFreqCellsListPresent) &&
        (sib18_ptr->connectedModePLMNIdentities.plmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->connectedModePLMNIdentities.plmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11 processing SIB18 Conn Intra Freq");
        sib18_present = TRUE;
      }
      else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions,v860NonCriticalExtensions))&&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext,idleModePLMNIdentities)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities,multipleplmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities.multipleplmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities.multipleplmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11 processing SIB18 Idle Multiple PLMNs Intra Freq");
        sib18_present = TRUE;
      }
      else if((sib18_ptr->m.idleModePLMNIdentitiesPresent) &&
        (sib18_ptr->idleModePLMNIdentities.m.plmnsOfIntraFreqCellsListPresent) &&
        (sib18_ptr->idleModePLMNIdentities.plmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->idleModePLMNIdentities.plmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11 processing SIB18 Idle Intra Freq");
        sib18_present = TRUE;
      }
    }
    else
    {
      /*
       If SIB11bis is present and SIB18 bis extenstions are present, use SIB18 bis extension
       If SIB11bis is present and SIb18 bis extensions are absent, use SIB18
       If SIB11bis is absent, use SIB18
      */
      if((rrc_sibdb_is_sib11bis_present_in_srv_cell()) &&
        (sib18_ptr->m.v6b0NonCriticalExtensionsPresent) &&
        (sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.m.idleModePLMNIdentitiesSIB11bisPresent) &&
        (sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.idleModePLMNIdentitiesSIB11bis.m.plmnsOfIntraFreqCellsListPresent) &&
        (sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.idleModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.sysInfoType18_v6b0ext.
            idleModePLMNIdentitiesSIB11bis.plmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11bis:SIB11 processing SIB18 Idle Intra Freq from bis extension ");
        sib18_present = TRUE;
      }
      else if((RRC_MSG_COMMON_BITMASK_IE_PTR(sib18_ptr,rrc_SysInfoType18,v6b0NonCriticalExtensions)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions,v860NonCriticalExtensions))&&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext,idleModePLMNIdentities)) &&
        (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities,multipleplmnsOfIntraFreqCellsList)) &&
        (sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities.multipleplmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->v6b0NonCriticalExtensions.v860NonCriticalExtensions.sysInfoType18_v860ext.idleModePLMNIdentities.multipleplmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11 processing SIB18 Idle Multiple PLMNs Intra Freq");
        sib18_present = TRUE;
      }
      else if((sib18_ptr->m.idleModePLMNIdentitiesPresent)
        &&
        (sib18_ptr->idleModePLMNIdentities.m.plmnsOfIntraFreqCellsListPresent)
        &&
        (sib18_ptr->idleModePLMNIdentities.plmnsOfIntraFreqCellsList.n != 0))
      {
        tmp_rrc_PLMNsOfIntraFreqCellsList_ptr = &sib18_ptr->idleModePLMNIdentities.plmnsOfIntraFreqCellsList;
        WRRC_MSG0_HIGH("SIB11 processing SIB18 Idle Intra Freq ");
        sib18_present = TRUE;
      }
    }
  }
  if(rrc_ccm_get_serv_plmn_cellid(&tmp_cell_id, &selected_plmn_identity) == RRC_CELL_LOSS_NO_NEW_CELL)
  {
    sib18_present = FALSE;
  }
  else
  {
    WCDMA_MEMCPY(&tmp_plmn_identity, 
                 sizeof(rrc_plmn_identity_type),
                 &selected_plmn_identity, 
                 sizeof(rrc_plmn_identity_type));
  }
  if(rrccsp_is_ue_in_true_limited_service() == TRUE)
  {
    sib18_present = FALSE;
    MSG_LOW("UE in limited service ignoring SIB18",0,0,0);
  }



  if((sib11_rel5_ext_ptr != NULL) && (RRC_MSG_COMMON_BITMASK_IE_PTR(sib11_rel5_ext_ptr,
    rrc_SysInfoType11_v590ext_IEs,newIntraFrequencyCellInfoList_v590ext)))
  {
    rel5_ext_ptr = &sib11_rel5_ext_ptr->newIntraFrequencyCellInfoList_v590ext;
  }

  switch(sib_meas_ctrl_ptr->use_of_HCS.u.hcs_used->cellSelectQualityMeasure.t)
  {
  case T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_1_cpich_RSCP:

    /* Store first the cell selection and reselection quality parameter */
    rrcmeas_sib11->cell_sel_resel_quan_type =  L1_RSCP;

    /* The Cell Select Quality Measure is RSCP */
    if (!(sib_meas_ctrl_ptr->use_of_HCS.u.hcs_used->cellSelectQualityMeasure.u.cpich_RSCP->m.
        intraFreqMeasurementSysInfoPresent))
    {
      /* Optional param Intra freq meas sys RSCP info is absent */
      /* No need to initialize intra_freq_meas_info_incl as it is already set to FALSE */
      /* At present no other measurement besides intra-freq are being supported by L1 */

      if(rrcmeas_read_sib11bis(sib18_present,tmp_rrc_PLMNsOfIntraFreqCellsList_ptr, tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr)== FAILURE)
      {
        WRRC_MSG0_HIGH("SIB11bis: Intra Frequency in SIB11bis Ignored");
        rrcmeas_sib11->intra_f.cell_list.num_cell_add = 0;
        rrcmeas_sib11->intra_f.cell_list_incl = FALSE;
        rrcmeas_sib11->intra_freq_meas_info_incl = FALSE;
      }
      return SUCCESS;

    }
    else
    {
      /* Intra freq meas sys info is present */
      rrcmeas_sib11->intra_freq_meas_info_incl = TRUE;

      /* Associate a local pointer for readability */
      intra_freq_meas_rscp_ptr =
        &sib_meas_ctrl_ptr->use_of_HCS.u.hcs_used->
        cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo;

        /* Measurement ID is present */
        rrcmeas_sib11->intra_f.meas_id =
          (uint16) intra_freq_meas_rscp_ptr->intraFreqMeasurementID;

      /* Get the FDD Intra freq meas quantity if present */

      if ((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
        rrc_IntraFreqMeasurementSysInfo_HCS_RSCP,intraFreqMeasQuantity))
        &&
        (RRC_CHECK_COMMON_MSG_TYPE(intra_freq_meas_rscp_ptr->intraFreqMeasQuantity.modeSpecificInfo,
        rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd)))
      {

        /* Intra freq meas quantity for FDD mode is present */
        rrcmeas_sib11->intra_f.meas_quan_incl = TRUE;

        /* So read the value of meas quantity and filter coefficient */

        rrcmeas_sib11->intra_f.meas_quan.quan_type =  RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
          intra_freq_meas_rscp_ptr->intraFreqMeasQuantity.modeSpecificInfo.u.fdd->
          intraFreqMeasQuantity_FDD);

        /* Get the Filter Coefficient */
        /* Check if rrc_IntraFreqMeasQuantity_filterCoefficient_present */
        /* If not, fill in a default value */



          rrcmeas_sib11->intra_f.meas_quan.filter_coef = (uint16)
            RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(
            intra_freq_meas_rscp_ptr->intraFreqMeasQuantity.filterCoefficient);
        

      } /* End of if for rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd */

      /* Check intra-freq cell info present */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
        rrc_IntraFreqMeasurementSysInfo_HCS_RSCP,intraFreqCellInfoSI_List))
      {
        /* Intra freq cell info list is present */
        rrcmeas_sib11->intra_f.cell_list_incl = TRUE;

        /* Intra freq Cell Info list is present */
        /* Always ignore the number of removed cells in System Info 11. */
        /* Process the new cell list */
        cell_count = 0;
	idx =0;
        rscp_intra_freq_cell_list_ptr =
          &intra_freq_meas_rscp_ptr->intraFreqCellInfoSI_List.
          newIntraFreqCellList;

        /* Intra freq cell info list is present */
        rrcmeas_sib11->intra_f.cell_list_incl = TRUE;

        while ( (rscp_intra_freq_cell_list_ptr->n > idx) &&
          (cell_count < L1_MAX_CELL_MEAS) )
        {
          /* Pointer to next cell is Non-NULL and cell count
          * hasn't exceeded the max. L1 can handle */

          if ( rscp_intra_freq_cell_list_ptr->elem[idx].cellInfo.
            modeSpecificInfo.t ==
            T_rrc_CellInfo_modeSpecificInfo_tdd)
          {
            /* Nothing doing with a TDD cell. Shun it ! */
            idx++;
            continue;
          }

          /* Set default values for the HCS neighboring cell info if it is first cell
          * else use the info from the previous cell */
          if(cell_count == 0)
          {
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio = 0;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs = 115;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time = 0;
          }
          else
          {
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.hcs_prio;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.q_hcs;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.penalty_time;

            if(rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.penalty_time
              != 0)
            {
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.tmp_offset1 =
                rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.tmp_offset1;
            }
          }
          /* First store cell info so that psc of this cell can be extracted */
          if (rrcmeas_fill_hcs_rscp_cell_info(&rscp_intra_freq_cell_list_ptr->elem[idx].
            cellInfo, &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info,((rel5_ext_ptr != NULL) ? ((rel5_ext_ptr->n > idx) ? (&rel5_ext_ptr->elem[idx]) : NULL) : NULL)) == FAILURE)
          {
            idx++;
            continue;
          }

          /* Check if intra-freq cell ID is present */
          if (RRC_MSG_LIST_BITMASK_IE(rscp_intra_freq_cell_list_ptr,
            rrc_NewIntraFreqCellSI_HCS_RSCP,intraFreqCellID))
          {
            cell_position = rscp_intra_freq_cell_list_ptr->elem[idx].intraFreqCellID;
            /* Set psc from rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info.pri_scr_code in the intra freq cell list at position given by
            rscp_intra_freq_cell_list_ptr->value.intraFreqCellID. Call
            rrcmeas_update_intra_freq_cell_list to do that */

          } /* End of if of intra-freq cell id present */

          else
          {
            cell_position = AVAILABLE_CELL_POSITION;
            /* Set psc from rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info.pri_scr_code in the first vacant position in intra freq cell list */

          } /* End of else of intra-freq cell id not present */


          if ( rrcmeas_update_intra_freq_cell_list(
            &cell_position,
            &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info.pri_scr_code) == RRCMEAS_SUCCESS)
          {
          
            /* PSC sucessfully stored in the cell info list variable */
            /* Now store psc in the sib11 in add cell for layer1 to use psc */
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].psc =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
              cell_info.pri_scr_code;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach = TRUE;
                  if(sib18_present)
                  {
                    rrcmeas_process_sib18_filtering(
                       tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
                       tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
                       &tmp_plmn_identity,
                       cell_count,
                       &(rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach),
                       (cell_count > 0)?rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count -1].measure_in_idle_pch_fach: TRUE);
                  }
                  else
                  {
                    /* Add code to set flag meas_pch_fach_idle to TRUE for the cell */
                    WRRC_MSG1_MED("psc %d measured in IDLE,FACH,PCH,DCH",rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].psc);
                  }
            /* Increment cell count as add cell successfully stored */
            cell_count ++;
          }  /* End of if of rrcmeas_update_intra_freq_cell_list */


          idx++;
          if ( (cell_count == L1_MAX_CELL_MEAS) &&
            (rscp_intra_freq_cell_list_ptr->n > idx) )
          {
          /* If there are more new cells than can be accomodated in L1
          Cmd, print a message and hope L1 will change their capability
          sometime. Just pass the number that L1 can handle.
            */
            WRRC_MSG0_HIGH("All Intra freq cells not included");
            break;
          }

        } /* while((rscp_intra_freq_cell_list_ptr != NULL) */
        /* Set number of added cells */
        rrcmeas_sib11->intra_f.cell_list.num_cell_add = cell_count;

      } /* Intra freq cell info list is present */

      /* Fill in Intra freq reporting quantity for RACH reporting */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
        rrc_IntraFreqMeasurementSysInfo_HCS_RSCP,intraFreqReportingQuantityForRACH))
      {
        /* Intra freq reporting quantity for RACH reporting is present */
        /* Fill in the FDD reporting quantity if present */
        if (RRC_CHECK_COMMON_MSG_TYPE( intra_freq_meas_rscp_ptr->intraFreqReportingQuantityForRACH.
          modeSpecificInfo,
          rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd) )
        {
          rrcmeas_sib11->intra_f.rach_rpt_quan_incl = TRUE;

          /* Fill in SFN SFN TM delta ReportType:1/2/None */
          rrcmeas_sib11->intra_f.rach_rpt_quan.rach_sfn_tm_delta =
            RRCMEAS_RET_INTRA_FREQ_SFN_DELTA(
            intra_freq_meas_rscp_ptr->intraFreqReportingQuantityForRACH.sfn_SFN_OTD_Type);

          /* Fill in rach reporting quantity RSCP/ECNO..*/
          rrcmeas_sib11->intra_f.rach_rpt_quan.rach_rpt_quan =
            RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(
            intra_freq_meas_rscp_ptr->intraFreqReportingQuantityForRACH.
            modeSpecificInfo.u.fdd->intraFreqRepQuantityRACH_FDD);

        }  /* End of if of RACH_modeSpecificInfo_fdd */
      } /* End of if of intraFreqReportingQuantityForRACH) */

      /* Check if max number of reported cells on RACH */
      /* If present then only set rach reporting to TRUE */

      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
          rrc_IntraFreqMeasurementSysInfo_HCS_RSCP,maxReportedCellsOnRACH))
      {
        WRRC_MSG0_HIGH("Max no of reporting cells present");

        /* Max reported cells on RACH is present */
        rrcmeas_sib11->intra_f.rach_rpt_max_incl = TRUE;

        /* Fill max no of reported cells */
        rrcmeas_sib11->intra_f.rach_rpt_max =
          RRCMEAS_RET_RACH_REPORTED_CELLS(
          intra_freq_meas_rscp_ptr->maxReportedCellsOnRACH);

        /* Modify RACH reporting criteria if maxReportedCellsOnRACH present */

        if ( intra_freq_meas_rscp_ptr->maxReportedCellsOnRACH !=
          rrc_MaxReportedCellsOnRACH_noReport )
        {
          /* Set reporting criteria for RACH to no report */
          sib11_rach_report_crit = APPEND_RRC_MEAS_RACH_REPORT;
        }

      } /* End of if of RSCP_maxReportedCellsOnRACH) */

      /* Now check if the Reporting info in state Cell_DCH is present */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_rscp_ptr,
        rrc_IntraFreqMeasurementSysInfo_RSCP,reportingInfoForCellDCH))
      {
        /* Initialize RLC reporting mode criteria */
        rrcmeas_sib11->intra_f.dch_rpt_info.rpt_trans_mode =
          RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
          intra_freq_meas_rscp_ptr->reportingInfoForCellDCH.measurementReportingMode.
          measurementReportTransferMode);

        /* To fill in the DCH info, call function */
        if ( rrcmeas_fill_dch_state_info(
          & intra_freq_meas_rscp_ptr->reportingInfoForCellDCH,
          & rrcmeas_sib11->intra_f.dch_rpt_info, sib11_rel5_ext_ptr, NULL) == SUCCESS )
        {

          rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl = TRUE;
        }

      } /* if of Reporting info in state DCH present */

    } /* Intra freq meas sys info is present */

    break;

  case T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_1_cpich_Ec_N0:
    /* Store first the cell selection and reselction quality parameter */
    rrcmeas_sib11->cell_sel_resel_quan_type =  L1_EC_NO;

    /* Check if Intra freq meas system info is present */
    if (!(sib_meas_ctrl_ptr->use_of_HCS.u.hcs_used->cellSelectQualityMeasure.u.cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent))
    {
      /* At present return as no other measurements are being supported by L1 */
      WRRC_MSG0_HIGH("Intra freq sys info absent.");
      if(rrcmeas_read_sib11bis(sib18_present,tmp_rrc_PLMNsOfIntraFreqCellsList_ptr, tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr)== FAILURE)
      {
        WRRC_MSG0_HIGH("SIB11bis: Intra Frequency in SIB11bis Ignored");
        rrcmeas_sib11->intra_f.cell_list.num_cell_add = 0;
        rrcmeas_sib11->intra_f.cell_list_incl = FALSE;
        rrcmeas_sib11->intra_freq_meas_info_incl = FALSE;
      }

      return SUCCESS;
    }
    else
    {
      /* Intra freq meas sys info is present */
      rrcmeas_sib11->intra_freq_meas_info_incl = TRUE;

      /* Associate a local pointer for readability */
      intra_freq_meas_ecn0_ptr =
        &sib_meas_ctrl_ptr->use_of_HCS.u.hcs_used->cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo;

  
        /* Measurement ID present */
        rrcmeas_sib11->intra_f.meas_id =
          (uint16) intra_freq_meas_ecn0_ptr->intraFreqMeasurementID;

      
      WRRC_MSG1_HIGH("Intra freq meas id in SIB11 is %d",
        rrcmeas_sib11->intra_f.meas_id);

      /* Get the FDD Intra freq meas quantity if present */
      if ((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
        rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,intraFreqMeasQuantity))
        &&
        (RRC_CHECK_COMMON_MSG_TYPE(intra_freq_meas_ecn0_ptr->intraFreqMeasQuantity.modeSpecificInfo,
        rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd)))
      {

        /* Intra freq meas quantity for FDD mode is present */
        rrcmeas_sib11->intra_f.meas_quan_incl = TRUE;

        /* Intra freq meas quantity for FDD mode is present */
        rrcmeas_sib11->intra_f.meas_quan.quan_type =
          RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
          intra_freq_meas_ecn0_ptr->intraFreqMeasQuantity.
          modeSpecificInfo.u.fdd->intraFreqMeasQuantity_FDD);

        /* Get the Filter Coefficient */
        /* Check if rrc_IntraFreqMeasQuantity_filterCoefficient) */
        /* If not, fill in a default value */

      
          rrcmeas_sib11->intra_f.meas_quan.filter_coef = (uint16)
            RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(
            intra_freq_meas_ecn0_ptr->intraFreqMeasQuantity.
            filterCoefficient);
        
      }  /* End of if for rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd */
      idx=0;
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
        rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,intraFreqCellInfoSI_List))
      {
        /*  Process the new cell list */
        cell_count = 0;
        ecn0_intra_freq_cell_list_ptr =
          &intra_freq_meas_ecn0_ptr->intraFreqCellInfoSI_List.
          newIntraFreqCellList;

        /* Intra freq cell info list is present */
        rrcmeas_sib11->intra_f.cell_list_incl = TRUE;

        while ( (ecn0_intra_freq_cell_list_ptr->n > idx) &&
          (cell_count < L1_MAX_CELL_MEAS) )
        {
        /* Pointer to next cell is Non-NULL and cell count
          * hasn't exceeded the max. L1 can handle */

          if ( ecn0_intra_freq_cell_list_ptr->elem[idx].
            cellInfo.modeSpecificInfo.t ==
            T_rrc_CellInfo_modeSpecificInfo_tdd)
          {

            /* Nothing doing with a TDD cell. Shun it ! */
            idx++;
            continue;
          }


          /* Set default values for the HCS neighboring cell info if it is first cell
          * else use the info from the previous cell */
          if(cell_count == 0)
          {
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio = 0;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs = 24 * 2;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time = 0;
          }
          else
          {
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.hcs_prio;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.q_hcs;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.penalty_time;

            if(rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.penalty_time
              != 0)
            {
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.tmp_offset1 =
                rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.tmp_offset1;
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.tmp_offset2 =
                rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.tmp_offset2;
            }
          }
          /* Call a function to fill the cell info */
          if ( rrcmeas_fill_hcs_ecn0_cell_info(&ecn0_intra_freq_cell_list_ptr->elem[idx].
            cellInfo, &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info, ((rel5_ext_ptr != NULL) ? ((rel5_ext_ptr->n > idx) ? (&rel5_ext_ptr->elem[idx]) : NULL) : NULL)) == FAILURE )
          {
            WRRC_MSG0_HIGH("Incorrect cell info sent in SIB. Ignore");
            idx++;
            continue;
          }

          /* Fill in the cell ID if present */
          if (RRC_MSG_LIST_BITMASK_IE(ecn0_intra_freq_cell_list_ptr,
            rrc_NewIntraFreqCellSI_HCS_ECN0,intraFreqCellID))
          {
            cell_position = ecn0_intra_freq_cell_list_ptr->elem[idx].intraFreqCellID;
            /* Set psc from rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info.pri_scr_code in the intra freq cell list at position given by
            ecn0_intra_freq_cell_list_ptr->value.intraFreqCellID. Call
            rrcmeas_update_intra_freq_cell_list to do that */

          }
          else
          {
            cell_position = AVAILABLE_CELL_POSITION;
            /* Set psc from rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info.pri_scr_code in the first vacant position in intra freq cell list */

          }


          if ( rrcmeas_update_intra_freq_cell_list(
            &cell_position,
            &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info.pri_scr_code) == RRCMEAS_SUCCESS)
          {
            /* PSC sucessfully stored in the cell info list variable */
            /* Now store psc in the sib11 in add cell for layer1 to use psc */
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].psc =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
              cell_info.pri_scr_code;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach = TRUE;
                  if(sib18_present)
                  {
                    rrcmeas_process_sib18_filtering(
                       tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
                       tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
                       &tmp_plmn_identity,
                       cell_count,
                       &(rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach),
                       (cell_count > 0)?rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count -1].measure_in_idle_pch_fach: TRUE);
                  }
                  else
                  {
                    /* Add code to set flag meas_pch_fach_idle to TRUE for the cell */
                    WRRC_MSG1_MED("psc %d measured in IDLE,FACH,PCH,DCH",rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].psc);
                  }
            /* Increment cell count as add cell successfully stored */
            cell_count ++;
          }  /* End of if of rrcmeas_update_intra_freq_cell_list */

          idx++;
          if ( (cell_count == L1_MAX_CELL_MEAS) &&
            (ecn0_intra_freq_cell_list_ptr->n > idx) )
          {
            /* If there are more new cells than can be accomodated in L1 Cmd,
            * print a message and hope L1 will change their capability
            * sometime. Just pass the number that L1 can handle.
            */

            WRRC_MSG0_HIGH("All Intra freq cells not included");
            break;
          }

        } /* while((ecn0_intra_freq_cell_list_ptr != NULL) */

        /* Set number of added cells */
        rrcmeas_sib11->intra_f.cell_list.num_cell_add = cell_count;

      } /*  Intra freq cell info list is present */

      /* Fill in Intra freq reporting quantity for RACH reporting */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
        rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,intraFreqReportingQuantityForRACH))
      {
        /* Fill in the FDD reporting quantity if present */
        if (RRC_CHECK_COMMON_MSG_TYPE( intra_freq_meas_ecn0_ptr->
          intraFreqReportingQuantityForRACH.modeSpecificInfo,
          rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd ))
        {

          rrcmeas_sib11->intra_f.rach_rpt_quan_incl = TRUE;

          /* Fill in SFN SFN TM delta */
          rrcmeas_sib11->intra_f.rach_rpt_quan.rach_sfn_tm_delta =
            RRCMEAS_RET_INTRA_FREQ_SFN_DELTA(
            intra_freq_meas_ecn0_ptr->intraFreqReportingQuantityForRACH.sfn_SFN_OTD_Type);

          /* Fill in rach reporting quantity RSCP/ECNO..*/
          rrcmeas_sib11->intra_f.rach_rpt_quan.rach_rpt_quan =
            RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(
            intra_freq_meas_ecn0_ptr->intraFreqReportingQuantityForRACH.
            modeSpecificInfo.u.fdd->intraFreqRepQuantityRACH_FDD);

        }  /* End of if of RACH_modeSpecificInfo_fdd */

      } /* End of if of intraFreqReportingQuantityForRACH) */

      /* Check  max number of reported cells on RACH */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
        rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,maxReportedCellsOnRACH))
      {
        MSG_LOW("Max no of reporting cells present", 0,0,0);

        /* Max reported cells on RACH is present */
        rrcmeas_sib11->intra_f.rach_rpt_max_incl = TRUE;

        /* Fill max no of reported cells */
        rrcmeas_sib11->intra_f.rach_rpt_max =
          RRCMEAS_RET_RACH_REPORTED_CELLS(
          intra_freq_meas_ecn0_ptr->maxReportedCellsOnRACH);

        /* Modify RACH reporting criteria if maxReportedCellsOnRACH present */
        if ( intra_freq_meas_ecn0_ptr->maxReportedCellsOnRACH !=
          rrc_MaxReportedCellsOnRACH_noReport )
        {
          /* Set reporting criteria for RACH to no report */
          sib11_rach_report_crit = APPEND_RRC_MEAS_RACH_REPORT;
        }

      } /* End of if of RSCP_maxReportedCellsOnRACH) */


      /* Now check if the Reporting info in state Cell_DCH is present */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_meas_ecn0_ptr,
        rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,reportingInfoForCellDCH))
      {
        /* Set Meas transfer mode criteria */
        rrcmeas_sib11->intra_f.dch_rpt_info.rpt_trans_mode =
          RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
          intra_freq_meas_ecn0_ptr->reportingInfoForCellDCH.measurementReportingMode.
          measurementReportTransferMode);


        /* To fill in the DCH info, call a function */
        if ( rrcmeas_fill_dch_state_info(& intra_freq_meas_ecn0_ptr->reportingInfoForCellDCH,
          & rrcmeas_sib11->intra_f.dch_rpt_info, sib11_rel5_ext_ptr, NULL) == SUCCESS )
        {
          rrcmeas_sib11->intra_f.intra_f_dch_rpt_info_incl = TRUE;
        }

      } /* if of Reporting info in state DCH present*/

    } /* Intra freq meas sys info is present */

    break;

  default:
    WRRC_MSG1_ERROR("Invalid cellSelectQualityMeasure %d",
      sib_meas_ctrl_ptr->use_of_HCS.u.hcs_used->cellSelectQualityMeasure.t);

    return FAILURE;
  }
  prev_cell_count = rrcmeas_sib11->intra_f.cell_list.num_cell_add;
  /* PSR need to ceck here if the ead list needs to passed or the list has o be travered and then passed.*/
  if(rrcmeas_read_sib11bis(sib18_present,tmp_rrc_PLMNsOfIntraFreqCellsList_ptr, tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr)== FAILURE)
  {
    WRRC_MSG0_HIGH("SIB11bis: Intra Frequency in SIB11bis Ignored");
    rrcmeas_sib11->intra_f.cell_list.num_cell_add = prev_cell_count ;
  }
  return SUCCESS;
}


/*===========================================================================

FUNCTION  RRCMEAS_FILL_HCS_RSCP_CELL_INFO

DESCRIPTION

 This function fills in Cell Info for a HCS cell when
 Cell Selection Reselection Quality Measure is RSCP.
 The function processes Cell Info in ASN1 format and
 translates into the L1 RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill cell info correctly
 SUCCESS: If Cell Info is filled correctly

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_fill_hcs_rscp_cell_info
(
  rrc_CellInfoSI_HCS_RSCP *sib_cell_info_ptr,
  l1_cell_info_struct_type* l1_cell_info_ptr
,rrc_CellSelectReselectInfo_v590ext * rel5_ext_ptr
)
{
  rrc_SysInfoType3    *sib3_ptr = NULL;

  rrc_SysInfoType4    *sib4_ptr = NULL;

  boolean sib4_present = FALSE;

  sib3_ptr = (rrc_SysInfoType3 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB3);
  if(sib3_ptr == NULL )
  {
    WRRC_MSG0_ERROR("SIB3 ptr is NULL");
    return (FAILURE);
  }

  if (sib_cell_info_ptr == NULL)
  {
    MSG_LOW("Cell info pointer is NULL", 0, 0, 0);
    return(FAILURE);
  }
 /* l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = FALSE; */
  if (((rrcmeas_current_substate == RRCMEAS_CELL_FACH) || (rrcmeas_current_substate == RRCMEAS_PCH)) &&
    ((sib3_ptr->sib4indicator == TRUE)))
  {
    sib4_ptr = (rrc_SysInfoType4 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB4);

    if (sib4_ptr == NULL)
    {
      WRRC_MSG0_ERROR("SIB4 ptr NULL.Use SIB3");
    }
    else
    {
      WRRC_MSG0_HIGH("Use default values from SIB4");
      sib4_present = TRUE;
    }
  }


  l1_cell_info_ptr->cell_offset =
    sib_cell_info_ptr->cellIndividualOffset;
  

  /* Fill in Reference Time Difference to serving cell */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib_cell_info_ptr,
    rrc_CellInfoSI_HCS_RSCP,referenceTimeDifferenceToCell))

  {
    /* Set reference time difference included to true */
    l1_cell_info_ptr->ref_tm_diff_incl = TRUE;

    if ( sib_cell_info_ptr->referenceTimeDifferenceToCell.t ==
      T_rrc_ReferenceTimeDifferenceToCell_accuracy40 )
    {
      /* L1 expects uint 16 */
      l1_cell_info_ptr->ref_tm_diff = (uint16) (sib_cell_info_ptr->referenceTimeDifferenceToCell.u.accuracy40 * REF_TIME_DIFF_ACCURACY_40);

      l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_40_CHIPS;

    }
    else if ( sib_cell_info_ptr->referenceTimeDifferenceToCell.t ==
      T_rrc_ReferenceTimeDifferenceToCell_accuracy256 )
    {
      l1_cell_info_ptr->ref_tm_diff = (uint16) (sib_cell_info_ptr->referenceTimeDifferenceToCell.u.accuracy256 * REF_TIME_DIFF_ACCURACY_256);
      l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_256_CHIPS;
    }
    else
    {
      l1_cell_info_ptr->ref_tm_diff = (uint16) (sib_cell_info_ptr->referenceTimeDifferenceToCell.u.accuracy2560 * REF_TIME_DIFF_ACCURACY_2560);
      l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_2560_CHIPS;
    }

  }
  else
  {
  /* Reference time difference to cell absent
    * Set reference time difference included to false */
    l1_cell_info_ptr->ref_tm_diff_incl = FALSE;

    l1_cell_info_ptr->ref_tm_diff = 0;
    l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_40_CHIPS;
  }

  /* Primary CPICH info absent */
  l1_cell_info_ptr->pri_scr_code_incl = FALSE;

  /* Primary CPICH TX power present It is an optional parameter */
  l1_cell_info_ptr->pri_cpich_txpwr_incl = FALSE;

  /* Read SFN indicator */
  l1_cell_info_ptr->rd_sfn_ind = FALSE;

  /* Read Tx Diversity indicator */
  l1_cell_info_ptr->tx_diver_ind = FALSE;


  /* Fill in Mode Specific Info */
  if ( sib_cell_info_ptr->modeSpecificInfo.t ==
        T_rrc_CellInfoSI_HCS_RSCP_modeSpecificInfo_tdd)
  { /* Mode specific info is for TDD */
    MSG_LOW("Using default values for cell info",0,0,0);
  }
  else
  {
  /* Mode specific info is for FDD -First Fill in default values for
    * Pri CPICH Scrambling code and CPICH Tx Power */

    if (sib_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_InfoPresent)
    {
      /* Primary CPICH info present */
      l1_cell_info_ptr->pri_scr_code_incl = TRUE;

      l1_cell_info_ptr->pri_scr_code = (uint16)
        sib_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

    }
    else
    {
      WRRC_MSG0_HIGH("PSC absent ignoring");
      return(FAILURE);
    }

    if (sib_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_TX_PowerPresent)
    {
      /* Primary CPICH TX power present It is an optional parameter */
      l1_cell_info_ptr->pri_cpich_txpwr_incl = TRUE;

      /* Set its value */
      l1_cell_info_ptr->pri_cpich_txpwr =
        sib_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_TX_Power;

    }

    /* Read SFN indicator */
    l1_cell_info_ptr->rd_sfn_ind =
      (boolean) sib_cell_info_ptr->modeSpecificInfo.u.fdd->readSFN_Indicator;

    /* Read Tx Diversity indicator */
    l1_cell_info_ptr->tx_diver_ind =
      (boolean) sib_cell_info_ptr->modeSpecificInfo.u.fdd->tx_DiversityIndicator;

  } /* End of else */

    /* Cell Select Reselect Info is present. If SIB's do not have values, default values
  have already been set */
  l1_cell_info_ptr->cell_sel_resel_info_incl = TRUE;

  /* Assign the default values for
  rrc_CellInfoSI_RSCP_cellSelectionReselectionInfo */
  l1_cell_info_ptr->cell_sel_info.qoffset1_s_n = QOFFSET1;

  l1_cell_info_ptr->cell_sel_info.qoffset2_s_n = QOFFSET2;

  if ((sib4_present == TRUE) && (sib4_ptr != NULL) &&
      (sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.t == T_rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
  {
    l1_cell_info_ptr->cell_sel_info.max_tx_pwr = (int16)
      sib4_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power;

    l1_cell_info_ptr->cell_sel_info.qual_min  = (int16)
      sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin;

    l1_cell_info_ptr->cell_sel_info.rxlev_min = (int16)
      (sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1;
    /* Check for REL 5 extension ptr */
    if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) &&
      (sib4_ptr->m.v4b0NonCriticalExtensionsPresent) &&
      (sib4_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
      (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType4_v590ext.m.
      cellSelectReselectInfo_v590extPresent) && (sib4_ptr->v4b0NonCriticalExtensions.
      v590NonCriticalExtension.sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.m.deltaQrxlevminPresent))
    {

    /*     l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = TRUE;
         l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin = sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
          sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2; */
      MSG_HIGH("SIB4 Delta-Qrxlev=%d, Qrxlev=%d, PSC=%d",
        (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
          sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2),
        l1_cell_info_ptr->cell_sel_info.rxlev_min,
        l1_cell_info_ptr->pri_scr_code);

     /* if ((l1_cell_info_ptr->cell_sel_info.rxlev_min + (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
          sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2)) < -115)
      {*/
        l1_cell_info_ptr->cell_sel_info.rxlev_min += (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
         sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2);
      /*}*/
    }
  }
  else if((sib3_ptr != NULL) && 
          (sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.t == T_rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
  {
    l1_cell_info_ptr->cell_sel_info.max_tx_pwr = (int16)
      sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power;

    l1_cell_info_ptr->cell_sel_info.qual_min  = (int16)
      sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin;

    l1_cell_info_ptr->cell_sel_info.rxlev_min = (int16)
      (sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1;
    /* Check for REL 5 extension ptr */
    if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) &&
      (sib3_ptr->m.v4b0NonCriticalExtensionsPresent) &&
      (sib3_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
      (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType3_v590ext.m.
      cellSelectReselectInfo_v590extPresent) && (sib3_ptr->v4b0NonCriticalExtensions.
      v590NonCriticalExtension.
      sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.m.deltaQrxlevminPresent))
    {

       /*  l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = TRUE;
         l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin = sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
          sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2; */
      MSG_HIGH("SIB3 Delta-Qrxlev=%d, Qrxlev=%d, PSC=%d",
        (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
          sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2),
        l1_cell_info_ptr->cell_sel_info.rxlev_min,
        l1_cell_info_ptr->pri_scr_code);

      /*if ((l1_cell_info_ptr->cell_sel_info.rxlev_min + (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
          sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2)) < -115)
      {*/
        l1_cell_info_ptr->cell_sel_info.rxlev_min += (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
         sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2);
      /*}*/
    }
  }

  /* Fill in cell select reselect info if present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib_cell_info_ptr,
    rrc_CellInfoSI_HCS_RSCP,cellSelectionReselectionInfo))
  {

    /* Fill in Qoffset1_s_n */
  
      /* Qoffset2 is applicable only when quality measure is EcN0 */
      l1_cell_info_ptr->cell_sel_info.qoffset1_s_n = (int16)
        sib_cell_info_ptr->cellSelectionReselectionInfo.q_OffsetS_N;
    

    /* Fill in Max Tx Power */
    if (RRC_MSG_COMMON_BITMASK_IE(sib_cell_info_ptr->cellSelectionReselectionInfo,
      rrc_CellSelectReselectInfoSIB_11_12_HCS_RSCP,maxAllowedUL_TX_Power))
    {
      l1_cell_info_ptr->cell_sel_info.max_tx_pwr = (int16)
        sib_cell_info_ptr->cellSelectionReselectionInfo.maxAllowedUL_TX_Power;
    }

    /* Check if fdd present */
    if (RRC_CHECK_COMMON_MSG_TYPE(sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo,
        rrc_CellSelectReselectInfoSIB_11_12_HCS_RSCP_modeSpecificInfo_fdd ))
    {
      /* Check if Qqualmin present */
      if (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.u.fdd,
        q_QualMin))
      {
        /* Store Qqualmin in L1 */
        l1_cell_info_ptr->cell_sel_info.qual_min = (int16)
          sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.u.fdd->q_QualMin;
      }

      /* Check if Qrxlevmin present */
      if (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.u.fdd,
          q_RxlevMin))
      {
        l1_cell_info_ptr->cell_sel_info.rxlev_min = (int16)
          (sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1;
      }
      if(rel5_ext_ptr != NULL)
      {
        if(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(rel5_ext_ptr,deltaQrxlevmin))
        {
          /*l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = TRUE;
          l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin =
            rel5_ext_ptr->value.deltaQrxlevmin * 2;        */

          MSG_HIGH("Delta-Qrxlev=%d, Qrxlev=%d, PSC=%d",
            (rel5_ext_ptr->deltaQrxlevmin * 2),
            l1_cell_info_ptr->cell_sel_info.rxlev_min,
            l1_cell_info_ptr->pri_scr_code);

          /*if ((l1_cell_info_ptr->cell_sel_info.rxlev_min + (rel5_ext_ptr->value.deltaQrxlevmin * 2)) < -115)
          {*/
            l1_cell_info_ptr->cell_sel_info.rxlev_min += (rel5_ext_ptr->deltaQrxlevmin * 2);
          /*}*/
        }
      }
    } /* End of if of fdd */

    /* HCS inforamtion */
    if(RRC_MSG_COMMON_BITMASK_IE(sib_cell_info_ptr->cellSelectionReselectionInfo,
      rrc_CellSelectReselectInfoSIB_11_12_HCS_RSCP,hcs_NeighbouringCellInformation_RSCP))
    {
      /* default intialzation for the HCS params */
      l1_cell_info_ptr->hcs_info.hcs_prio = 0;
      l1_cell_info_ptr->hcs_info.q_hcs = 115;
      l1_cell_info_ptr->hcs_info.penalty_time = 0;

      /* HCS PRIO*/
    
        l1_cell_info_ptr->hcs_info.hcs_prio = (uint16)
          sib_cell_info_ptr->cellSelectionReselectionInfo.hcs_NeighbouringCellInformation_RSCP.hcs_PRIO;
     
        if(sib_cell_info_ptr->cellSelectionReselectionInfo.hcs_NeighbouringCellInformation_RSCP.q_HCS < 90)
        {
          l1_cell_info_ptr->hcs_info.q_hcs = (uint16) (115 -
            sib_cell_info_ptr->cellSelectionReselectionInfo.hcs_NeighbouringCellInformation_RSCP.q_HCS);
        }
        else
        {
          l1_cell_info_ptr->hcs_info.q_hcs = MAX_QHCS_RSCP;
        }
        //l1_cell_info_ptr->hcs_info.delta_qhcs_included = FALSE;
        if(rel5_ext_ptr != NULL)
        {
          if(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(rel5_ext_ptr,deltaQhcs))
          {
            /*l1_cell_info_ptr->hcs_info.delta_qhcs_included = TRUE;
            l1_cell_info_ptr->hcs_info.delta_qhcs = rel5_ext_ptr->value.deltaQhcs; */
            MSG_HIGH("Delta-Qhcs=%d, Qhcs=%d, PSC=%d",
              rel5_ext_ptr->deltaQhcs,
              l1_cell_info_ptr->hcs_info.q_hcs,
              l1_cell_info_ptr->pri_scr_code);

            /*if ((l1_cell_info_ptr->hcs_info.q_hcs + (-rel5_ext_ptr->value.deltaQhcs)) > 115)
            {*/
              l1_cell_info_ptr->hcs_info.q_hcs += (-rel5_ext_ptr->deltaQhcs);
            /*}*/
          }
        }
      

      /* PENALTY TIME*/
      if(!(RRC_CHECK_COMMON_MSG_TYPE(sib_cell_info_ptr->cellSelectionReselectionInfo.hcs_NeighbouringCellInformation_RSCP.
        hcs_CellReselectInformation.penaltyTime,rrc_PenaltyTime_RSCP_notUsed)))
      {

        switch(sib_cell_info_ptr->cellSelectionReselectionInfo.hcs_NeighbouringCellInformation_RSCP.
          hcs_CellReselectInformation.penaltyTime.t)
        {
        case T_rrc_PenaltyTime_RSCP_pt10:
          l1_cell_info_ptr->hcs_info.penalty_time = 10;
          l1_cell_info_ptr->hcs_info.tmp_offset1 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET1(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_RSCP.hcs_CellReselectInformation
            .penaltyTime.u.pt10);
          break;

        case T_rrc_PenaltyTime_RSCP_pt20:
          l1_cell_info_ptr->hcs_info.penalty_time = 20;
          l1_cell_info_ptr->hcs_info.tmp_offset1 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET1(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_RSCP.hcs_CellReselectInformation
            .penaltyTime.u.pt20);
          break;

        case T_rrc_PenaltyTime_RSCP_pt30:
          l1_cell_info_ptr->hcs_info.penalty_time = 30;
          l1_cell_info_ptr->hcs_info.tmp_offset1 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET1(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_RSCP.hcs_CellReselectInformation
            .penaltyTime.u.pt30);
          break;

        case T_rrc_PenaltyTime_RSCP_pt40:
          l1_cell_info_ptr->hcs_info.penalty_time = 40;
          l1_cell_info_ptr->hcs_info.tmp_offset1 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET1(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_RSCP.hcs_CellReselectInformation
            .penaltyTime.u.pt40);
          break;

        case T_rrc_PenaltyTime_RSCP_pt50:
          l1_cell_info_ptr->hcs_info.penalty_time = 50;
          l1_cell_info_ptr->hcs_info.tmp_offset1 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET1(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_RSCP.hcs_CellReselectInformation
            .penaltyTime.u.pt50);
          break;

        case T_rrc_PenaltyTime_RSCP_pt60:
          l1_cell_info_ptr->hcs_info.penalty_time = 60;
          l1_cell_info_ptr->hcs_info.tmp_offset1 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET1(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_RSCP.hcs_CellReselectInformation
            .penaltyTime.u.pt60);
          break;

        default:  /* should not happen */
          break;
        }
      }
    }



  } /* End of cell selection & reselection */

  return(SUCCESS);
}  /* rrcmeas_fill_hcs_rscp_cell_info  */



/*===========================================================================

FUNCTION   RRCMEAS_FILL_HCS_ECN0_CELL_INFO

DESCRIPTION

 This function fills in Cell Info for a HCS cell when
 Cell Selection Reselection Quality Measure is ECN0.
 The function processes Cell Info in ASN1 format and
 translates into the L1 RRC Interface format.

DEPENDENCIES

 Pointer to rrc_CellInfoSI_ECN0 must be valid.

RETURN VALUE

 FAILURE: If passed pointer is NULL.
 SUCCESS: If able to analyze and fill Cell Info.

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_fill_hcs_ecn0_cell_info
(
rrc_CellInfoSI_HCS_ECN0 *sib_cell_info_ptr,
l1_cell_info_struct_type *l1_cell_info_ptr
,rrc_CellSelectReselectInfo_v590ext * rel5_ext_ptr
)
{
  rrc_SysInfoType3    *sib3_ptr = NULL;

  rrc_SysInfoType4    *sib4_ptr = NULL;

  boolean sib4_present = FALSE;

  sib3_ptr = (rrc_SysInfoType3 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB3);
  if( sib3_ptr == NULL )
  {
    WRRC_MSG0_ERROR("SIB3 ptr is NULL");
    return( FAILURE );
  }

  if ( sib_cell_info_ptr == NULL )
  {
    MSG_LOW("Cell Info ptr is NULL", 0, 0, 0);
    return(FAILURE);
  }
  /*l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = FALSE; */
  if (((rrcmeas_current_substate == RRCMEAS_CELL_FACH) || (rrcmeas_current_substate == RRCMEAS_PCH)) &&
    ((sib3_ptr->sib4indicator == TRUE)))
  {
    sib4_ptr = (rrc_SysInfoType4 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB4);

    if (sib4_ptr == NULL)
    {
      WRRC_MSG0_ERROR("SIB4 ptr NULL.Use SIB3");
    }
    else
    {
      WRRC_MSG0_HIGH("Use default values from SIB4");
      sib4_present = TRUE;
    }
  }

 
  l1_cell_info_ptr->cell_offset =
    sib_cell_info_ptr->cellIndividualOffset;

 

  /* Fill in Reference Time Difference to serving cell */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib_cell_info_ptr,
    rrc_CellInfoSI_HCS_ECN0,referenceTimeDifferenceToCell))
  {
    /* Set reference time difference included to true */
    l1_cell_info_ptr->ref_tm_diff_incl = TRUE;

    if ( sib_cell_info_ptr->referenceTimeDifferenceToCell.t ==
      T_rrc_ReferenceTimeDifferenceToCell_accuracy40 )
    {

      l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_40_CHIPS;

      l1_cell_info_ptr->ref_tm_diff = (uint16)
        (sib_cell_info_ptr->referenceTimeDifferenceToCell.u.accuracy40 * REF_TIME_DIFF_ACCURACY_40);

    }
    else if ( sib_cell_info_ptr->referenceTimeDifferenceToCell.t ==
      T_rrc_ReferenceTimeDifferenceToCell_accuracy256 )
    {

      l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_256_CHIPS;
      l1_cell_info_ptr->ref_tm_diff = (uint16)
        (sib_cell_info_ptr->referenceTimeDifferenceToCell.u.accuracy256 * REF_TIME_DIFF_ACCURACY_256) ;

    }
    else
    {

      l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_2560_CHIPS;
      l1_cell_info_ptr->ref_tm_diff = (uint16)
        (sib_cell_info_ptr->referenceTimeDifferenceToCell.u.accuracy2560 * REF_TIME_DIFF_ACCURACY_2560);
    }
  }
  else
  {
  /* Reference time difference to cell absent
    * Set reference time difference included to false */

    l1_cell_info_ptr->ref_tm_diff_incl = FALSE;

    l1_cell_info_ptr->ref_tm_diff = 0;
    l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_40_CHIPS;
  }

  /* Primary CPICH info absent */
  l1_cell_info_ptr->pri_scr_code_incl = FALSE;

  /* Primary CPICH TX power present It is an optional parameter */
  l1_cell_info_ptr->pri_cpich_txpwr_incl = FALSE;

  /* Read SFN indicator */
  l1_cell_info_ptr->rd_sfn_ind = FALSE;

  /* Read Tx Diversity indicator */
  l1_cell_info_ptr->tx_diver_ind = FALSE;

  /* Fill in Mode Specific Info */
  if ( sib_cell_info_ptr->modeSpecificInfo.t ==
    T_rrc_CellInfo_modeSpecificInfo_tdd)
  {
    MSG_LOW("Using default values",0,0,0);
  }
  else
  {
  /* Mode specific info is for FDD -First Fill in default values for
    * Pri CPICH Scrambling code and CPICH Tx Power */

    if (sib_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_InfoPresent)
    {

      /* Primary CPICH info present */
      l1_cell_info_ptr->pri_scr_code_incl = TRUE;

      l1_cell_info_ptr->pri_scr_code = (uint16)
        sib_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

    }
    else
    {
      WRRC_MSG0_HIGH("PSC absent ignoring");
      return(FAILURE);
    }

    if (sib_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_TX_PowerPresent)
    {

      /* Primary CPICH TX power present It is an optional parameter */
      l1_cell_info_ptr->pri_cpich_txpwr_incl = TRUE;

      /* Set its value */
      l1_cell_info_ptr->pri_cpich_txpwr =
        sib_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_TX_Power;
    }

    /* Read SFN indicator */
    l1_cell_info_ptr->rd_sfn_ind =
      (boolean) sib_cell_info_ptr->modeSpecificInfo.u.fdd->readSFN_Indicator;

    /* Read Tx Diversity indicator */
    l1_cell_info_ptr->tx_diver_ind =
      (boolean) sib_cell_info_ptr->modeSpecificInfo.u.fdd->tx_DiversityIndicator;

  } /* End of else */

  l1_cell_info_ptr->cell_sel_resel_info_incl = TRUE;

  /* Assign the default values for cell reselection */
  l1_cell_info_ptr->cell_sel_info.qoffset1_s_n = QOFFSET1;

  l1_cell_info_ptr->cell_sel_info.qoffset2_s_n = QOFFSET2;

  if ((sib4_present == TRUE) && (sib4_ptr != NULL))
  {
    l1_cell_info_ptr->cell_sel_info.max_tx_pwr = (int16)
      sib4_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power;

    if(RRC_CHECK_COMMON_MSG_TYPE(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo,
       rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
    {
      l1_cell_info_ptr->cell_sel_info.qual_min  = (int16)
        sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin;

      l1_cell_info_ptr->cell_sel_info.rxlev_min = (int16)
        (sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1;
      /* Check for REL 5 extension ptr */
      if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) &&
        (sib4_ptr->m.v4b0NonCriticalExtensionsPresent) &&
        (sib4_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
        (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType4_v590ext.m.
        cellSelectReselectInfo_v590extPresent) && (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
        sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.m.deltaQrxlevminPresent))
      {

           /*l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = TRUE;
           l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin = sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2; */
        MSG_HIGH("SIB4 Delta-Qrxlev=%d, Qrxlev=%d, PSC=%d",
          (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2),
          l1_cell_info_ptr->cell_sel_info.rxlev_min,
          l1_cell_info_ptr->pri_scr_code);

        /*if ((l1_cell_info_ptr->cell_sel_info.rxlev_min + (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2)) < -115)
        {*/
          l1_cell_info_ptr->cell_sel_info.rxlev_min += (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
           sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2);
        /*}*/
      }
    }
    else
    {
      WRRC_MSG1_ERROR("ERR: SIB3 mode_choice NOT FDD %d", sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.t);
    }
  }
  else
  {
    l1_cell_info_ptr->cell_sel_info.max_tx_pwr = (int16)
      sib3_ptr->cellSelectReselectInfo.maxAllowedUL_TX_Power;

    if(RRC_CHECK_COMMON_MSG_TYPE(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo,
       rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
    {
      l1_cell_info_ptr->cell_sel_info.qual_min  = (int16)
        sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin;

      l1_cell_info_ptr->cell_sel_info.rxlev_min = (int16)
        (sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1;
      /* Check for REL 5 extension ptr */
      if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) &&
        (sib3_ptr->m.v4b0NonCriticalExtensionsPresent) &&
        (sib3_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
        (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType3_v590ext.m.
        cellSelectReselectInfo_v590extPresent) && (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
        sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.m.deltaQrxlevminPresent))
      {

           /*l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = TRUE;
           l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin = sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2; */
        MSG_HIGH("SIB3 Delta-Qrxlev=%d, Qrxlev=%d, PSC=%d",
          ( sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2),
          l1_cell_info_ptr->cell_sel_info.rxlev_min,
          l1_cell_info_ptr->pri_scr_code);
 
        /*if ((l1_cell_info_ptr->cell_sel_info.rxlev_min + ( sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
            sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2)))
        {*/
          l1_cell_info_ptr->cell_sel_info.rxlev_min += ( sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
           sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2);
        /*}*/
      }
    }
    else
    {
      WRRC_MSG1_ERROR("ERR: SIB3 mode_choice NOT FDD %d", sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.t);
    }
  }

  /* Fill in cell select reselect info */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib_cell_info_ptr,
    rrc_CellInfoSI_HCS_ECN0,cellSelectionReselectionInfo))
  {
  
      l1_cell_info_ptr->cell_sel_info.qoffset1_s_n = (int16)
        sib_cell_info_ptr->cellSelectionReselectionInfo.q_Offset1S_N;
    
      /* Qoffset2 is applicable when quality measure is EcN0 */
      l1_cell_info_ptr->cell_sel_info.qoffset2_s_n = (int16)
        sib_cell_info_ptr->cellSelectionReselectionInfo.q_Offset2S_N;
    

    /* Fill in Max Tx Power */
    if (RRC_MSG_COMMON_BITMASK_IE(sib_cell_info_ptr->cellSelectionReselectionInfo,
      rrc_CellSelectReselectInfoSIB_11_12_HCS_ECN0,maxAllowedUL_TX_Power))
    {
      l1_cell_info_ptr->cell_sel_info.max_tx_pwr = (int16)
        sib_cell_info_ptr->cellSelectionReselectionInfo.maxAllowedUL_TX_Power;
    }


    /* Check if fdd present */
    if (RRC_CHECK_COMMON_MSG_TYPE(sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo,
      rrc_CellSelectReselectInfoSIB_11_12_RSCP_modeSpecificInfo_fdd))
    {
      /* Check if Qqualmin present */

      if (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.u
        .fdd,q_QualMin) )
      {
        /* Store Qqualmin in L1 */
        l1_cell_info_ptr->cell_sel_info.qual_min = (int16)
          sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.
          u.fdd->q_QualMin;
      }

      /* Check if Qrxlevmin present */
      if (sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.u
        .fdd->m.q_RxlevMinPresent)
      {
        l1_cell_info_ptr->cell_sel_info.rxlev_min = (int16)
          (sib_cell_info_ptr->cellSelectionReselectionInfo.modeSpecificInfo.
          u.fdd->q_RxlevMin * 2) + 1;
      }
      if(rel5_ext_ptr != NULL)
      {
        if(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(rel5_ext_ptr,deltaQrxlevmin))
        {
          /*l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin_included = TRUE;
          l1_cell_info_ptr->cell_sel_info.delta_qrxlevmin =
            rel5_ext_ptr->value.deltaQrxlevmin * 2;        */
          MSG_HIGH("Delta-Qrxlev=%d, Qrxlev=%d, PSC=%d",
            (rel5_ext_ptr->deltaQrxlevmin * 2),
            l1_cell_info_ptr->cell_sel_info.rxlev_min,
            l1_cell_info_ptr->pri_scr_code);

          /*if ((l1_cell_info_ptr->cell_sel_info.rxlev_min + (rel5_ext_ptr->value.deltaQrxlevmin * 2)) < -115)
          {*/
            l1_cell_info_ptr->cell_sel_info.rxlev_min += (rel5_ext_ptr->deltaQrxlevmin * 2);
          /*}*/
        }
      }
    } /* End of if of fdd */

    /* HCS inforamtion */
    if(RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib_cell_info_ptr->cellSelectionReselectionInfo,
      hcs_NeighbouringCellInformation_ECN0))
    {
      /* default values for the HCS params */
      l1_cell_info_ptr->hcs_info.hcs_prio = 0;
      l1_cell_info_ptr->hcs_info.q_hcs = 24 * 2;
      l1_cell_info_ptr->hcs_info.penalty_time = 0;

      /* HCS PRIO*/
      
        l1_cell_info_ptr->hcs_info.hcs_prio = (uint16)
          sib_cell_info_ptr->cellSelectionReselectionInfo.hcs_NeighbouringCellInformation_ECN0.hcs_PRIO;
      

      /*Q HCS */
     
        if(sib_cell_info_ptr->cellSelectionReselectionInfo.hcs_NeighbouringCellInformation_ECN0.q_HCS < 49)
        {
          l1_cell_info_ptr->hcs_info.q_hcs = (uint16) ((24 -
            (0.5 * sib_cell_info_ptr->cellSelectionReselectionInfo.hcs_NeighbouringCellInformation_ECN0.q_HCS)) * 2);
        }
        else
        {
          l1_cell_info_ptr->hcs_info.q_hcs = 0;
        }
      

      /* PENALTY TIME*/
      if(sib_cell_info_ptr->cellSelectionReselectionInfo.hcs_NeighbouringCellInformation_ECN0.
        hcs_CellReselectInformation.penaltyTime.t != T_rrc_PenaltyTime_ECN0_notUsed)
      {

        switch(sib_cell_info_ptr->cellSelectionReselectionInfo.hcs_NeighbouringCellInformation_ECN0.
          hcs_CellReselectInformation.penaltyTime.t)
        {
        case T_rrc_PenaltyTime_RSCP_pt10:

          l1_cell_info_ptr->hcs_info.penalty_time = 10;

          l1_cell_info_ptr->hcs_info.tmp_offset1 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET1(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_ECN0.hcs_CellReselectInformation
            .penaltyTime.u.pt10->temporaryOffset1);

          l1_cell_info_ptr->hcs_info.tmp_offset2 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET2(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_ECN0.hcs_CellReselectInformation
            .penaltyTime.u.pt10->temporaryOffset2);

          break;

        case T_rrc_PenaltyTime_RSCP_pt20:

          l1_cell_info_ptr->hcs_info.penalty_time = 20;

          l1_cell_info_ptr->hcs_info.tmp_offset1 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET1(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_ECN0.hcs_CellReselectInformation
            .penaltyTime.u.pt20->temporaryOffset1);

          l1_cell_info_ptr->hcs_info.tmp_offset2 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET2(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_ECN0.hcs_CellReselectInformation
            .penaltyTime.u.pt20->temporaryOffset2);

          break;

        case T_rrc_PenaltyTime_RSCP_pt30:

          l1_cell_info_ptr->hcs_info.penalty_time = 30;

          l1_cell_info_ptr->hcs_info.tmp_offset1 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET1(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_ECN0.hcs_CellReselectInformation
            .penaltyTime.u.pt30->temporaryOffset1);

          l1_cell_info_ptr->hcs_info.tmp_offset2 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET2(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_ECN0.hcs_CellReselectInformation
            .penaltyTime.u.pt30->temporaryOffset2);

          break;

        case T_rrc_PenaltyTime_RSCP_pt40:

          l1_cell_info_ptr->hcs_info.penalty_time = 40;

          l1_cell_info_ptr->hcs_info.tmp_offset1 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET1(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_ECN0.hcs_CellReselectInformation
            .penaltyTime.u.pt40->temporaryOffset1);

          l1_cell_info_ptr->hcs_info.tmp_offset2 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET2(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_ECN0.hcs_CellReselectInformation
            .penaltyTime.u.pt40->temporaryOffset2);

          break;

        case T_rrc_PenaltyTime_RSCP_pt50:

          l1_cell_info_ptr->hcs_info.penalty_time = 50;

          l1_cell_info_ptr->hcs_info.tmp_offset1 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET1(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_ECN0.hcs_CellReselectInformation
            .penaltyTime.u.pt50->temporaryOffset1);

          l1_cell_info_ptr->hcs_info.tmp_offset2 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET2(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_ECN0.hcs_CellReselectInformation
            .penaltyTime.u.pt50->temporaryOffset2);

          break;

        case T_rrc_PenaltyTime_RSCP_pt60:

          l1_cell_info_ptr->hcs_info.penalty_time = 60;

          l1_cell_info_ptr->hcs_info.tmp_offset1 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET1(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_ECN0.hcs_CellReselectInformation
            .penaltyTime.u.pt60->temporaryOffset1);

          l1_cell_info_ptr->hcs_info.tmp_offset2 = (uint16)
            RRCMEAS_RET_HCS_TMP_OFFSET2(sib_cell_info_ptr->cellSelectionReselectionInfo.
            hcs_NeighbouringCellInformation_ECN0.hcs_CellReselectInformation
            .penaltyTime.u.pt60->temporaryOffset2);

          break;

        default:  /* should not happen */
          break;
        }
      }
    }
  }

  return(SUCCESS);

}  /* rrcmeas_fill_hcs_ecn0_cell_info  */


void  rrcmeas_append_inter_freq_meas_results_ptr
(
 rrc_MeasuredResults * measured_results_ptr,
 l1_meas_rpt_struct_type * l1_rpt
)
{
    uint8 cnt = 0, cell_number = 0;
    
     rrc_InterFreqMeasuredResultsList* local_rrc_meas_results_ptr = NULL;
    
     rrc_InterFreqCellMeasuredResultsList* local_inter_freq_cell_list_ptr = NULL;

    
      

    /* Set Additional Report type to Inter Freq report */
    RRC_SET_COMMON_MSG_TYPE_PTR(measured_results_ptr,rrc_MeasuredResults_interFreqMeasuredResultsList);

    /* Allocate Memory */

    measured_results_ptr->u.interFreqMeasuredResultsList =
      rtxMemAllocTypeZ(&enc_ctxt,rrc_InterFreqMeasuredResultsList);

    local_rrc_meas_results_ptr = measured_results_ptr->u.interFreqMeasuredResultsList;

    local_rrc_meas_results_ptr->n = l1_rpt->u.inter_f_rpt.inter_freq_measurements.num_msmt_results;

    ALLOC_ASN1ARRAY2(&enc_ctxt,local_rrc_meas_results_ptr,rrc_InterFreqMeasuredResults);

    for (cnt = 0; (cnt < L1_MAX_FREQ) && (cnt < l1_rpt->u.inter_f_rpt.inter_freq_measurements.num_msmt_results); cnt++)
    {
      RRC_RESET_MSG_IE_PRESENT(local_rrc_meas_results_ptr->elem[cnt]);

      if (l1_rpt->u.inter_f_rpt.inter_freq_measurements.
        msmt_results[cnt].utra_carrier_rssi_incl == TRUE)
      {
        local_rrc_meas_results_ptr->elem[cnt].m.utra_CarrierRSSIPresent=1;

        local_rrc_meas_results_ptr->elem[cnt].utra_CarrierRSSI =
          l1_rpt->u.inter_f_rpt.inter_freq_measurements.
          msmt_results[cnt].utra_carrier_rssi;
      }

      /* Set bit maks for Freq Info */
      local_rrc_meas_results_ptr->elem[cnt].m.frequencyInfoPresent=1;

      /* Set t to fdd */
      local_rrc_meas_results_ptr->elem[cnt].frequencyInfo.modeSpecificInfo.t =
        T_rrc_FrequencyInfo_modeSpecificInfo_fdd;

      local_rrc_meas_results_ptr->elem[cnt].frequencyInfo.modeSpecificInfo.u.fdd =
        rtxMemAllocTypeZ(&enc_ctxt,rrc_FrequencyInfoFDD);

      /* Set UL ARFCN bit mask to 0 */
      RRC_RESET_MSG_IE_PRESENT_PTR(local_rrc_meas_results_ptr->elem[cnt].frequencyInfo.modeSpecificInfo.u.fdd);

      if (l1_rpt->u.inter_f_rpt.inter_freq_measurements.
        msmt_results[cnt].freq_info.uarfcn_ul_incl == TRUE)
      {
        local_rrc_meas_results_ptr->elem[cnt].frequencyInfo.modeSpecificInfo.u.fdd->m.uarfcn_ULPresent=1;

        local_rrc_meas_results_ptr->elem[cnt].frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_UL =
          l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].freq_info.uarfcn_ul;
      }

      local_rrc_meas_results_ptr->elem[cnt].frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL =
        l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].freq_info.uarfcn_dl;

      local_rrc_meas_results_ptr->elem[cnt].interFreqCellMeasuredResultsList.n = 0;


      /* Now get Inter Freq Cells */

      if (l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].num_cells == 0)
      {
        WRRC_MSG1_HIGH("IFreq:Num cells per freq is %d",
          l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].num_cells);
      }
      else
      {
        /* Assign memory for these cells */

        local_inter_freq_cell_list_ptr =
            &local_rrc_meas_results_ptr->elem[cnt].interFreqCellMeasuredResultsList;


        /* Set bit mask for Cell Meas Results List present */
        local_rrc_meas_results_ptr->elem[cnt].m.interFreqCellMeasuredResultsListPresent =1;

        /* Assign head */
 

        local_inter_freq_cell_list_ptr->n =
            l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].num_cells;

        ALLOC_ASN1ARRAY2(&enc_ctxt,local_inter_freq_cell_list_ptr,rrc_CellMeasuredResults);
        
        
        /* Now validate Measured Results */
        for ( cell_number = 0; ((cell_number < l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].num_cells)
          && ( cell_number < L1_MAX_CELL_MEAS)); cell_number++ )
        {
          RRC_RESET_MSG_IE_PRESENT(local_inter_freq_cell_list_ptr->elem[cell_number]);
          if (l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]->sfn_rpt_ind == L1_NO_REPORT)
          {
            MSG_LOW("SFN SFN observed time diff not set", 0,0,0);
          }
          else
          {
            /* Set bit mask to sfn_sfn present */
            local_inter_freq_cell_list_ptr->elem[cell_number].m.dummyPresent = 1;

            /* Store sfn-sfn type indicator */

            if ( l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]->sfn_rpt_ind == L1_REPORT_TYPE_1)
            {
              local_inter_freq_cell_list_ptr->elem[cell_number].dummy.t =  T_rrc_SFN_SFN_ObsTimeDifference_type1;

              MSG_LOW("Report type 1 selected", 0,0,0);
              /* Type 1 report */
              local_inter_freq_cell_list_ptr->elem[cell_number].dummy.u.type1 =
                l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]->sfn_sfn_tm_diff;

            }
            else
            {
              MSG_LOW("Report type 2 selected", 0,0,0);
              local_inter_freq_cell_list_ptr->elem[cell_number].dummy.t =  T_rrc_SFN_SFN_ObsTimeDifference_type2;
              /* Type 2 report */
              local_inter_freq_cell_list_ptr->elem[cell_number].dummy.u.type2 =
                l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]->sfn_sfn_tm_diff;

            }

          } /* End of else of L1_NO_REPORT */

          /* Check if cell sync info present */

          if ( l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]->cell_sync_info_incl == TRUE )
          {
            /* Set cell sync info present to rrc_cellSynchronisationInfo) */
            local_inter_freq_cell_list_ptr->elem[cell_number].m.cellSynchronisationInfoPresent = 1;

            /* Store t Mode info to fdd*/
            local_inter_freq_cell_list_ptr->elem[cell_number].cellSynchronisationInfo.
              modeSpecificInfo.t =
              T_rrc_CellSynchronisationInfo_modeSpecificInfo_fdd;

            local_inter_freq_cell_list_ptr->elem[cell_number].cellSynchronisationInfo.
              modeSpecificInfo.u.fdd =
              rtxMemAllocTypeZ(&enc_ctxt,rrc_CellSynchronisationInfo_fdd);

            local_inter_freq_cell_list_ptr->elem[cell_number].cellSynchronisationInfo.
              modeSpecificInfo.u.fdd->tm =
              l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]->cell_sync_info.tm;



            /* Set bit mask indicating rrc_CountC_SFN_Frame_difference present */
            local_inter_freq_cell_list_ptr->elem[cell_number].cellSynchronisationInfo.
              modeSpecificInfo.u.fdd->m.countC_SFN_Frame_differencePresent = 1;


            /* Set off value */
            local_inter_freq_cell_list_ptr->elem[cell_number].cellSynchronisationInfo.
              modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.off =
              l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]->cell_sync_info.off;


              /* Set countC_SFN_High to 0 till the time RLC implements RLC transparent
            * Mode count-C */
            local_inter_freq_cell_list_ptr->elem[cell_number].cellSynchronisationInfo.
              modeSpecificInfo.u.fdd->countC_SFN_Frame_difference.countC_SFN_High = 0;

          } /* End of if of rrc_cellSynchronisationInfo) */

          /* Set in the FDD mode for rrc_CellMeasuredResults_modeSpecificInfo */
          local_inter_freq_cell_list_ptr->elem[cell_number].modeSpecificInfo.t =
            T_rrc_CellMeasuredResults_modeSpecificInfo_fdd;

          local_inter_freq_cell_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd =
            rtxMemAllocTypeZ(&enc_ctxt,rrc_CellMeasuredResults_fdd);

          /* Set primary scrambling code */
          local_inter_freq_cell_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->
            primaryCPICH_Info.primaryScramblingCode =
            l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]->pri_scr_code;

          RRC_RESET_MSG_IE_PRESENT_PTR(local_inter_freq_cell_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd);



          /* Convert meas value to UTRAN format */

          /* Check if RSCP included */
          if (l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]->rscp_included == TRUE)
          {
            local_inter_freq_cell_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->cpich_RSCP =
              l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]->rscp_val;

            /* Set bit mask */
            local_inter_freq_cell_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.cpich_RSCPPresent = 1;
          }
          /* Check if EC/Io included */
          if (l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]->ec_no_included == TRUE)
          {
            local_inter_freq_cell_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->cpich_Ec_N0 =
              l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]->ec_no_val;

            /* Set bit mask */
            local_inter_freq_cell_list_ptr->elem[cell_number].modeSpecificInfo.u.fdd->m.cpich_Ec_N0Present = 1;

          }
          /* One cell completely filled here */
        } /* End of for loop */

      } /* No of cell != 0 */

      /* First result filled completely */
    } /* End of for of meas results */

    

    for (cnt = 0; (cnt < l1_rpt->u.inter_f_rpt.inter_freq_measurements.num_msmt_results) &&
      (l1_rpt->u.inter_f_rpt.meas_results_included == TRUE); cnt++)
    {
      for ( cell_number = 0; ((cell_number < l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].num_cells)
        && ( cell_number < L1_MAX_CELL_MEAS)); cell_number++ )
      {
        if (l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number] != NULL)
        {          
          rrc_free_interlayer_cmd(l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number]);
          l1_rpt->u.inter_f_rpt.inter_freq_measurements.msmt_results[cnt].cell[cell_number] = NULL;
        }
      }
    }

  }


/*===========================================================================

FUNCTION   RRCMEAS_APPEND_INTER_FREQ_MEAS_RESULTS

DESCRIPTION

    This function appends Inter-Freq Measured Results to any report.
    It first checks if additional measured results have already been appended
    the measurement report. If yes, then it increments the pointer to point
    to the next space in additional measured result list and sets the result
    in that location. Additional Measurement Identity passed to
  this function has already been validated

DEPENDENCIES

    The calling function must have initialized the additional measured
    results pointer

RETURN VALUE

    True if results successfully appended
    False otherwise

SIDE EFFECTS

    None

===========================================================================*/
boolean rrcmeas_append_inter_freq_meas_results
(
 uint8* meas_id_ptr,
 l1_meas_rpt_struct_type * l1_rpt
)
{
  /* Declared for storing additional measured results */

  boolean addtl_meas_present = FALSE;

  boolean meas_results_incl = FALSE;

 

  /* The whole rpt declared to make use of the existing fn */
  

  l1_rpt->rpt_crit = L1_PERIODIC_RPT;

#ifndef FEATURE_WCDMA_FREE_FLOATING_TASK
  WCDMA_RRC_TASK_LOCK();

  if (l1m_is_connected())
  {
    addtl_meas_present = l1_get_additional_interf_msmt_results(*meas_id_ptr,
    &l1_rpt->u.inter_f_rpt);
  }

  WCDMA_RRC_TASK_FREE();
#else
  if (l1m_is_connected())
  {
    addtl_meas_present = rrcff_l1_get_additional_interf_msmt_results(*meas_id_ptr,
    &l1_rpt->u.inter_f_rpt);
  }
#endif

  MSG_HIGH("IFreq: Addtl Meas Results : addtl meas present %d, meas_results_incl %d, num_msmt_results %d",
    addtl_meas_present,l1_rpt->u.inter_f_rpt.meas_results_included,l1_rpt->u.inter_f_rpt.inter_freq_measurements.num_msmt_results);

  if ((addtl_meas_present == FALSE) || (l1_rpt->u.inter_f_rpt.meas_results_included == FALSE))
  {
    MSG_LOW("IFreq:Meas Results unavaliable from L1",0,0,0);
  }
  else if(l1_rpt->u.inter_f_rpt.inter_freq_measurements.num_msmt_results == 0)
  {
    MSG_LOW("Addtl Ifreq Meas Results 0 not appending",0,0,0);
  }
  else if (rrcifreq_validate_meas_report(l1_rpt) == FALSE)
  {
    MSG_LOW("IFreq:Meas VAlidation failed",0,0,0);
  }
  else
  {
    meas_results_incl = TRUE;
  } /* End of else, Meas Results appended */

  return meas_results_incl;
}

/*===========================================================================

FUNCTION   RRCMEAS_APPEND_INTERNAL_MEAS_RESULTS_PTR

DESCRIPTION

    This function appends Internal Measured Results to any report.
    It first checks if additional measured results have already been appended
    the measurement report. If yes, then it increments the pointer to point
    to the next available space in additional measured result list


DEPENDENCIES

    The calling function must have initialized the additional measured
    results pointer

RETURN VALUE

    True if measured results successfully appended
    False Otherwise

SIDE EFFECTS

    None

===========================================================================*/
void rrcmeas_append_internal_meas_results_ptr
(
 rrc_MeasuredResults * measured_results_ptr,
 l1_ue_internal_meas_rpt_struct_type * ue_internal_meas
)
{
      rrc_UE_RX_TX_ReportEntryList *ue_RX_TX_ReportEntryList_ptr = NULL;
      uint8 rl_count = 0;

      /* Now add additional measured results */
      RRC_SET_COMMON_MSG_TYPE_PTR(measured_results_ptr,rrc_MeasuredResults_ue_InternalMeasuredResults);
      measured_results_ptr->u.ue_InternalMeasuredResults
        = rtxMemAllocTypeZ(&enc_ctxt,rrc_UE_InternalMeasuredResults);

      RRC_SET_COMMON_MSG_TYPE(measured_results_ptr->u.ue_InternalMeasuredResults->modeSpecificInfo,
        rrc_UE_InternalMeasuredResults_modeSpecificInfo_fdd);
    
      measured_results_ptr->u.ue_InternalMeasuredResults->modeSpecificInfo.u.fdd 
        = rtxMemAllocTypeZ(&enc_ctxt,rrc_UE_InternalMeasuredResults_fdd);
      RRC_MSG_COMMON_SET_BITMASK_IE_TYPE2_PTR(measured_results_ptr->u.ue_InternalMeasuredResults->modeSpecificInfo.u.fdd,
        ue_TransmittedPowerFDD);
    
      measured_results_ptr->u.ue_InternalMeasuredResults->modeSpecificInfo.
        u.fdd->ue_TransmittedPowerFDD = ue_internal_meas->cell_measured_result_info.ue_tx_pwr;
    
      measured_results_ptr->u.ue_InternalMeasuredResults->modeSpecificInfo.
        u.fdd->ue_RX_TX_ReportEntryList.n = 0;
    
      if(ue_internal_meas->cell_measured_result_info.ue_rx_tx_time_diff_included)
      {
        measured_results_ptr->u.ue_InternalMeasuredResults->modeSpecificInfo.
          u.fdd->m.ue_RX_TX_ReportEntryListPresent = 1;
       ue_RX_TX_ReportEntryList_ptr= &
        measured_results_ptr->u.ue_InternalMeasuredResults->modeSpecificInfo.
        u.fdd->ue_RX_TX_ReportEntryList;

        ue_RX_TX_ReportEntryList_ptr->n = ue_internal_meas->cell_measured_result_info.num_rl;

        ALLOC_ASN1ARRAY2(&enc_ctxt,ue_RX_TX_ReportEntryList_ptr,rrc_UE_RX_TX_ReportEntry);
        for(rl_count = 0; rl_count < ue_internal_meas->cell_measured_result_info.num_rl; rl_count++)
        {
         
          ue_RX_TX_ReportEntryList_ptr->elem[rl_count].primaryCPICH_Info.primaryScramblingCode
              = (uint32) ue_internal_meas->cell_measured_result_info.rx_tx_rpt[rl_count].pri_scr_code;
            ue_RX_TX_ReportEntryList_ptr->elem[rl_count].ue_RX_TX_TimeDifferenceType1
              = (uint32) ue_internal_meas->cell_measured_result_info.rx_tx_rpt[rl_count].rx_tx_diff_type_1;
    
         
        }
      }
    
}

/*===========================================================================

FUNCTION   RRCMEAS_APPEND_INTERNAL_MEAS_RESULTS

DESCRIPTION

    This function appends Internal Measured Results to any report.
    It first checks if additional measured results have already been appended
    the measurement report. If yes, then it increments the pointer to point
    to the next available space in additional measured result list


DEPENDENCIES

    The calling function must have initialized the additional measured
    results pointer

RETURN VALUE

    True if measured results successfully appended
    False Otherwise

SIDE EFFECTS

    None

===========================================================================*/
boolean rrcmeas_append_internal_meas_results
(
 uint8* meas_id_ptr,
 l1_ue_internal_meas_rpt_struct_type * ue_internal_meas
)
{  
  boolean addtl_meas_present = FALSE;

 

  /* initialize ue_internal_meas for lint */
  ue_internal_meas->cell_measured_results_included = FALSE;
  ue_internal_meas->evt_id = L1_INTERNAL_MEAS_EVENT_6A;
  ue_internal_meas->cell_psc = 0;

#ifndef FEATURE_WCDMA_FREE_FLOATING_TASK
  WCDMA_RRC_TASK_LOCK();

  if (l1m_is_connected())
  {
    addtl_meas_present = l1_get_additional_internal_msmt_results(*meas_id_ptr, ue_internal_meas);
  }
  else
  {
    MSG_LOW("Addtl Internal Results not appended",0,0,0);
  }

  WCDMA_RRC_TASK_FREE();
#else
  if (l1m_is_connected())
  {
    addtl_meas_present = rrcff_l1_get_additional_internal_msmt_results(*meas_id_ptr, ue_internal_meas);
  }
  else
  {
    MSG_LOW("Addtl Internal Results not appended",0,0,0);
  }
#endif


  MSG_HIGH("UEIM:Addtl Meas Results : addtl meas present %d, meas results incl %d, ue_tx_pwr_incl %d",
    addtl_meas_present,ue_internal_meas->cell_measured_results_included,ue_internal_meas->cell_measured_result_info.ue_tx_pwr_included);

  if (addtl_meas_present == FALSE)
  {
    return FALSE;
  }

  if ((ue_internal_meas->cell_measured_results_included != TRUE) ||
    (ue_internal_meas->cell_measured_result_info.ue_tx_pwr_included != TRUE))
  {
    return FALSE;
  }

  if (rrcueim_validate_measured_results(ue_internal_meas) == FAILURE)
  {
    return FALSE;
  }

  return TRUE;
}

/*===========================================================================

FUNCTION   RRCMEAS_CHECK_MCM_FOR_SETUP_MODIFY_ADDITIONAL

DESCRIPTION

  This function checks if the existing measurement already exists
  in the measurement database. If yes, then it deletes the
  additional measurement associated with it. Also for a modify
  it checks if UTRAN tries to add more than the maximum no of
  allowed measurements, then it rejects the configuration

DEPENDENCIES

  None

RETURN VALUE

  True/False

SIDE EFFECTS

  None
===========================================================================*/

boolean rrcmeas_check_mcm_for_setup_modify_additional
(
 boolean addtl_meas_incl,
 rrcmeas_layer_e_type primary_meas_type,
 uint32 mid,
 rrc_AdditionalMeasurementID_List * local_addtl_meas_list_ptr
)
{

  uint8 count = 0, cnt = 0, addtl_meas_cnt = 0;
  rrcmeas_layer_e_type meas_type = NOT_EXIST;

  if ((addtl_meas_incl == TRUE) && (local_addtl_meas_list_ptr == NULL))
  {
    MSG_LOW("Addtl Meas ptr NULL",0,0,0);
  }
  else if (addtl_meas_incl == FALSE)
  {
    MSG_LOW("Addtl Meas absent",0,0,0);
  }
  else
  {
    /* Count no of addtl meas specified by UTRAN */
    addtl_meas_cnt = local_addtl_meas_list_ptr->n;
    if (addtl_meas_cnt > MAX_ADDITIONAL_MEAS)
    {
      WRRC_MSG1_ERROR("Addtl Meas specified %d, Max is 4", addtl_meas_cnt);
      return FALSE;
    }
  }

  switch(primary_meas_type)
  {
    case INTRA_FREQ:
      /* Indicates that it is a setup-> Find if this meas already existed */
      /* Only if that meas already existed, just delete the addtional meas */
      for (count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
      {
        if (intra_freq_meas_id_list[count].meas_id == mid)
        {
          meas_type = INTRA_FREQ;
          WRRC_MSG2_HIGH("Overwrite IntraFreq Addnl Meas %d meas type %d", mid, meas_type);
          /* Clear Addtl Meas */
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            intra_freq_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
          break; /* Come out of for of intra freq meas */
        }
      } /* End of for of Intra Freq */
      break; /* Come out of switch */

    case INTER_SYS:
      /* Indicates that it is a setup-> Find if this meas already existed */
      /* Only if that meas already existed, just delete the addtional meas */
      for (count = 0; count < MAX_INTER_RAT_MEAS; count++ )
      {
        if (inter_rat_meas_id_list[count].meas_id == mid)
        {
          meas_type = INTER_SYS;
          WRRC_MSG2_HIGH("Overwrite IntraFreq Addnl Meas %d meas type %d", mid, meas_type);
          /* Clear Addtl Meas */
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            inter_rat_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
  
          break; /* Come out of for of Inter RAT meas */
        }
      } /* End of for of Inter RAT */
      break;

    case MAC_MEAS:
      /* Indicates that it is a setup-> Find if this meas already existed */
      /* Only if that meas already existed, just delete the addtional meas */
      for (count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
      {
        if (tvm_meas_id_list[count].meas_id == mid)
        {
          meas_type = MAC_MEAS;
          WRRC_MSG2_HIGH("Overwrite IntraFreq Addnl Meas %d meas type %d", mid, meas_type);
          /* Clear Addtl Meas */
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            tvm_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
          break; /* Come out of for of TVM */
        }
      } /* End of for of TVM */
      break;

    case INTERNAL_MEAS:
      /* Indicates that it is a setup-> Find if this meas already existed */
      /* Only if that meas already existed, just delete the addtional meas */
      for (count = 0; count < MAX_INTERNAL_MEAS; count++ )
      {
        if (ueim_meas_id_list[count].meas_id == mid)
        {
          meas_type = INTERNAL_MEAS;
          /* Clear Addtl Meas */
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            ueim_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
          break; /* Come out of for of UEIM */
        }
      } /* End of for of UEIM */
    break;

    case INTER_FREQ:
      /* Indicates that it is a setup-> Find if this meas already existed */
      /* Only if that meas already existed, just delete the addtional meas */
      for (count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
      {
        if (inter_freq_meas_id_list[count].meas_id == mid)
        {
          meas_type = INTER_FREQ;
          WRRC_MSG2_HIGH("Overwrite IntraFreq Addnl Meas %d meas type %d", mid, meas_type);
          /* Clear Addtl Meas */
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            inter_freq_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
          break; /* Come out of for of IFREQ */
        }
      } /* End of for of IFREQ */
      break;

    case QUALITY_MEAS:
      /* Indicates that it is a setup-> Find if this meas already existed */
      /* Only if that meas already existed, just delete the addtional meas */
      for (count = 0; count < MAX_QUALITY_MEAS; count++ )
      {
        if (quality_meas_id_list[count].meas_id == mid)
        {
          meas_type = QUALITY_MEAS;
          /* Clear Addtl Meas */
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            quality_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;

          break; /* Come out of for of intra freq meas */
        }
      } /* End of for of Intra Freq */
      break; /* Come out of switch */

    default:
      WRRC_MSG1_ERROR("Unsupported Primary Meas Type %d",primary_meas_type);
      return FALSE;
  } /* End of switch */

  
  return TRUE;
}

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

/*===========================================================================

FUNCTION   RRCMEAS_CONFIG_POS_DB

DESCRIPTION

 Sets Positioning Meas Information in RRC Measurement Database.

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/

boolean rrcmeas_config_pos_db
(
 pos_info_struct_type* pos_info_ptr,
 meas_validity_enum_type* p_meas_validity,
 rpt_crit_enum_type* pos_rpt_crit,
 boolean modify_meas_params_incl /* Only applicable for MODIFY */
)
{
  uint8 count = 0;
  /* First check if the meas id already exists */

  /* SETUP existing & MODIFY scenario */
  for ( count = 0; count < MAX_POS_MEAS; count++ )
  {
    if (pos_meas_id_list[count].meas_id == pos_info_ptr->meas_id)
    {
      /* Check if it is a MODIFY cmd */
      if (pos_info_ptr->pos_meas_cmd == RRC_MEAS_MODIFY)
      {
        if (modify_meas_params_incl == TRUE)
        {
          /* Reporting Criteria for MODIFY */
          pos_meas_id_list[count].rpt_crit = *pos_rpt_crit;

          /* Store Method type */
          pos_meas_id_list[count].pos_method_type = pos_info_ptr->pos_method_type;
        }

        /* If for MODIFY, Validity is not present, then copy it from Meas DB */
        if (*p_meas_validity != NOT_PRESENT)
        {
          /* New validity specified. Lets copy it */
          pos_meas_id_list[count].meas_validity = *p_meas_validity;
        }
      } /* End of MODIFY */
      else /* SETUP Overwrite case */
      {
        pos_meas_id_list[count].rpt_crit = *pos_rpt_crit;

        pos_meas_id_list[count].meas_validity = *p_meas_validity;

        pos_meas_id_list[count].pos_method_type = pos_info_ptr->pos_method_type;
      }

      return TRUE;
    } /* End of if of Meas Id found */

  } /* End of for loop */


  /* SETUP not existing scenario */
  for ( count = 0; count < MAX_POS_MEAS; count++ )
  {
    /* If Meas Id not found, then it is a new Meas. Set it in first available position */
    if (pos_meas_id_list[count].meas_id == INVALID_MEAS_ID)
    {
      pos_meas_id_list[count].meas_id = (uint8) pos_info_ptr->meas_id;

      pos_meas_id_list[count].pos_method_type = pos_info_ptr->pos_method_type;

      pos_meas_id_list[count].meas_validity = *p_meas_validity;

      pos_meas_id_list[count].rpt_crit = *pos_rpt_crit;

      return TRUE;
    }

  } /* End of for loop */

  /* Not Possible */
  WRRC_MSG0_ERROR("RRC MeasDB for TVM FULL!!");
  return FALSE;

}

/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_POS_MCM

DESCRIPTION

 This function processes the Positioning Measurement Control Message and
 determines if it is a A-GPS or Cell Id or OTDOA Message. Depending upon that
 it configures either LSM or L1 with measurement parameters

DEPENDENCIES

 None

RETURN VALUE

 FAILURE:
 SUCCESS:

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_process_pos_mcm
(
  void* msg_ptr,
  pos_info_struct_type* pos_info_ptr
  ,uint8 meas_ctrl_tr_id
)
{

  /* Check if it is a Release */
  if (pos_info_ptr->pos_meas_cmd == RRC_MEAS_DELETE)
  {
    if (rrcgps_process_mcm(msg_ptr, pos_info_ptr, meas_ctrl_tr_id) == SUCCESS)
      return SUCCESS;
    else
      return FAILURE;
  }

  /* Now route it */
  switch(pos_info_ptr->pos_method_type)
  {
  case RRC_GPS:
  case RRC_OTDOAorGPS:
    if (rrcgps_process_mcm(msg_ptr, pos_info_ptr, meas_ctrl_tr_id) == SUCCESS)
      return SUCCESS;
    else
      return FAILURE;

  default:
    /* Not possible */
    break;


  } /* End of switch */
  return FAILURE;
}



/*===========================================================================

FUNCTION   RRCMEAS_INITIALIZE_MEAS_ID_LIST

DESCRIPTION

  Handles initialization of MEASUREMNT_IDENTIY variable
  for Intra Freq Measurements.

DEPENDENCIES

  None

RETURN VALUE

  None.

SIDE EFFECTS

  None.

===========================================================================*/

void rrcmeas_initialize_pos_meas_id_list
(
 void
)
{
  uint8 count = 0, cnt = 0;
  /* Initialize Measurement Identity variable */
  for ( count = 0; count < MAX_POS_MEAS; count++ )
  {
    /* Set all positions to vacant and make PSC as invalid */
    pos_meas_id_list[count].meas_id = INVALID_MEAS_ID;
    pos_meas_id_list[count].meas_validity = NOT_PRESENT;
    pos_meas_id_list[count].rpt_crit = NOT_AVAILABLE;

    /* Also initialize additional meas */
    for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
      pos_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
  }

}

#endif


/*===========================================================================

FUNCTION    RRCMEAS_SEND_RRC_STATUS_MSG

DESCRIPTION

 Sends RRC Status Message to UTRAN

DEPENDENCIES

 None.

RETURN VALUE

 void

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_send_rrc_status_msg
(
 uint8* transaction_id_ptr,
 uint8* error_choice_ptr
)
{
  /* Stores UL MSG */
  rrc_UL_DCCH_Message* msg_ptr = NULL;

  /* Stores status of send chain */
  rrcsend_status_e_type status;

  /* RLC ack or unack mode */
  uecomdef_logch_mode_e_type logical_channel_mode;

  /* Logical Channel Id */
  rlc_lc_id_type ul_lc_id = 0;

  /* Radio bearer mode */
  rrc_RB_Identity rb_mode = 0;

  /* L2 ack status */
  rrcsend_l2ack_status_e_type l2_ack_status;

  logical_channel_mode = UE_MODE_ACKNOWLEDGED_DATA;

  rb_mode = DCCH_AM_RADIO_BEARER_ID;

  l2_ack_status = RRCSEND_L2ACK_NOT_REQUIRED;

  ul_lc_id = rrclcm_check_ul_rlc_lc_id ( UE_LOGCHAN_DCCH, rb_mode,
    logical_channel_mode);

  if ( ul_lc_id == RRCLCM_RLC_LC_ID_NOT_FOUND )
  {
    WRRC_MSG0_ERROR("RLC Logical channel not found");
    return;
  }

  /* Allocate a buffer for an uplink DCCH Message. This buffer
  * should be released by SEND_CHAIN using OSS compiler functions */

  msg_ptr = (rrc_UL_DCCH_Message *) rrc_malloc (sizeof(struct rrc_UL_DCCH_Message));

  /* Store meas report chosen */
  msg_ptr->message.t = T_rrc_UL_DCCH_MessageType_rrcStatus;

  /* First set bit mask to 0 */
  RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.rrcStatus);

  msg_ptr->message.u.rrcStatus.protocolErrorInformation.diagnosticsType.t =
    T_rrc_ProtocolErrorMoreInformation_diagnosticsType_type1;
 
 msg_ptr->message.u.rrcStatus.protocolErrorInformation.
    diagnosticsType.u.type1 = rtxMemAllocTypeZ (&enc_ctxt, rrc_ProtocolErrorMoreInformation_type1);
 
  msg_ptr->message.u.rrcStatus.protocolErrorInformation.diagnosticsType.u.type1->t
    = *error_choice_ptr;

  switch(*error_choice_ptr)
  {
  case T_rrc_ProtocolErrorMoreInformation_type1_ie_ValueNotComprehended:
     msg_ptr->message.u.rrcStatus.protocolErrorInformation.diagnosticsType.u.type1->u.
      ie_ValueNotComprehended=
      rtxMemAllocTypeZ (&enc_ctxt, rrc_IdentificationOfReceivedMessage);
    msg_ptr->message.u.rrcStatus.protocolErrorInformation.diagnosticsType.u.type1->u.
      ie_ValueNotComprehended->receivedMessageType = rrc_ReceivedMessageType_assistanceDataDelivery;

    msg_ptr->message.u.rrcStatus.protocolErrorInformation.diagnosticsType.u.
      type1->u.ie_ValueNotComprehended->rrc_TransactionIdentifier = *transaction_id_ptr;

    break;

  case T_rrc_ProtocolErrorMoreInformation_type1_messageExtensionNotComprehended:

    msg_ptr->message.u.rrcStatus.protocolErrorInformation.diagnosticsType.u.type1->u.
      messageExtensionNotComprehended=
       rtxMemAllocTypeZ (&enc_ctxt, rrc_IdentificationOfReceivedMessage);
    msg_ptr->message.u.rrcStatus.protocolErrorInformation.diagnosticsType.u.type1->u.
      messageExtensionNotComprehended->receivedMessageType = rrc_ReceivedMessageType_assistanceDataDelivery;

    msg_ptr->message.u.rrcStatus.protocolErrorInformation.diagnosticsType.u.
      type1->u.messageExtensionNotComprehended->rrc_TransactionIdentifier = *transaction_id_ptr;

    break;

  case T_rrc_ProtocolErrorMoreInformation_type1_asn1_ViolationOrEncodingError:
    break;

  default:
    rrc_free(msg_ptr);
    return;
  }

  WRRC_MSG0_HIGH("POS:Sending RRC Status Message");

  /* This places SDU into RLC watermark queue */
  status =  rrcsend_send_ul_sdu(RRC_PROCEDURE_MCMR, (void *) msg_ptr,
    ul_lc_id, l2_ack_status);

  if ( status != RRCSEND_SUCCESS )
  {
    WRRC_MSG0_ERROR("Send chain failed RRC Status Msg");
  }
  else
  {
    MSG_LOW("RRC Status Msg sent",0,0,0);
  }

  return;

}

/*===========================================================================

  FUNCTION     RRCMEAS_GET_FACH_MEAS_INFO

DESCRIPTION

  Gets FACH Meas Occasion Info from SIB11

DEPENDENCIES

  None.

RETURN VALUE

  None.

SIDE EFFECTS

  Trashing Measurement Report may result in Soft Hand Off not working properly

===========================================================================*/

rrcmeas_status_e_type rrcmeas_get_fach_meas_info
(
 void
)
{
  rrc_SysInfoType11 *sib11_ptr = NULL; /* Declared to store the value of SIB 11*/

  rrc_FACH_MeasurementOccasionInfo_inter_RAT_meas_ind* local_sib_inter_rat_ptr = NULL;
  uint32 idx=0;
  sib11_ptr = (rrc_SysInfoType11*)  rrc_sibdb_return_sib_for_srv_cell
      (rrc_SIB11);

  if ( sib11_ptr == NULL )
  {
    return RRCMEAS_FAIL;
  }

  /* Initialize the following value to Default values */
  rrcmeas_sib11->fach_meas_incl = FALSE;
  rrcmeas_sib11->fach.k_ind = FALSE;
  rrcmeas_sib11->fach.inter_f_ind = FALSE;
  rrcmeas_sib11->fach.num_inter_sys = 0;

  /* Check if the FACH Measurement Occassion Info if present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(sib11_ptr,rrc_SysInfoType11,fach_MeasurementOccasionInfo))
  {
    rrcmeas_sib11->fach_meas_incl = TRUE;

    /* Check if fACH_meas_occasion_coeff present */
    if (RRC_MSG_COMMON_BITMASK_IE_TYPE2(sib11_ptr->fach_MeasurementOccasionInfo,
        fACH_meas_occasion_coeff))
    {
      /* Set the flag */
      rrcmeas_sib11->fach.k_ind = TRUE;
      rrcmeas_sib11->fach.k =
        sib11_ptr->fach_MeasurementOccasionInfo.fACH_meas_occasion_coeff;
    }

    /* Check if Inter Freq indicator present */
    if (sib11_ptr->fach_MeasurementOccasionInfo.inter_freq_FDD_meas_ind == TRUE)
    {
      rrcmeas_sib11->fach.inter_f_ind = TRUE;
    }

    if(sib11_ptr->fach_MeasurementOccasionInfo.m.inter_RAT_meas_indPresent)
    {
        /* Check if Inter RAT indicator present */
      local_sib_inter_rat_ptr = &sib11_ptr->fach_MeasurementOccasionInfo.inter_RAT_meas_ind;

      while (local_sib_inter_rat_ptr->n > idx)
      {
        if (local_sib_inter_rat_ptr->elem[idx] == rrc_RAT_Type_gsm)
        {
          rrcmeas_sib11->fach.num_inter_sys = 1;
          rrcmeas_sib11->fach.inter_sys[0] = L1_GSM_SYSTEM;
          break;
        }
        idx++;
      }      
    }    
  }

  return RRCMEAS_SUCCESS;

}

/*===========================================================================

FUNCTION rrcmeas_get_rach_rpt_quantity

DESCRIPTION

 Gets RACH reporting measurement quantity

DEPENDENCIES

 This fn is only called when RACH criteria for the new cell is supported

RETURN VALUE

 Success if RACH quantity read is supported
 Failure if RACH quantity read is not supported

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_get_rach_rpt_quantity
(
  l1_meas_quan_enum_type* meas_quantity_ptr
)
{
  rrc_SysInfoType11 *sib11_ptr = NULL; /* Declared to store the value of SIB 11*/

  rrc_SysInfoType12 *sib12_ptr = NULL; /* Declared to store the value of SIB 12*/

  uecomdef_status_e_type rach_status = FAILURE;


  sib11_ptr = (rrc_SysInfoType11*)  rrc_sibdb_return_sib_for_srv_cell
    (rrc_SIB11);


  /* Check if the value received is O.K. */

  if ( sib11_ptr == NULL )
  {
    rach_status = FAILURE;
  }
  else
  {
    /* Check if HCS is in use. */
    if ( RRC_CHECK_COMMON_MSG_TYPE(sib11_ptr->measurementControlSysInfo.use_of_HCS,
    rrc_MeasurementControlSysInfo_use_of_HCS_hcs_used ))
    {
      /* Get Rpt Criteria */
      if (sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->cellSelectQualityMeasure.t ==
        T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_1_cpich_Ec_N0)
      {
        /* Check if RACH reporting criteria present */
        if ( (sib11_ptr->measurementControlSysInfo.use_of_HCS.u.
          hcs_used->cellSelectQualityMeasure.u.cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent) &&

          (RRC_MSG_COMMON_BITMASK_IE(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.
          hcs_used->cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo,
          rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,intraFreqReportingQuantityForRACH))  &&
          (RRC_CHECK_COMMON_MSG_TYPE(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.
          hcs_used->cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo.
          intraFreqReportingQuantityForRACH.modeSpecificInfo,
          rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd)))
        {
          *meas_quantity_ptr = RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.
            hcs_used->cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo.
            intraFreqReportingQuantityForRACH.modeSpecificInfo.
            u.fdd->intraFreqRepQuantityRACH_FDD);

          rach_status = SUCCESS;
        }

      }

      else /* RSCP */
      {
        if ((sib11_ptr->measurementControlSysInfo.use_of_HCS.u.
          hcs_used->cellSelectQualityMeasure.u.cpich_RSCP->m.intraFreqMeasurementSysInfoPresent)
          &&(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.
            hcs_used->cellSelectQualityMeasure.u.
            cpich_RSCP->intraFreqMeasurementSysInfo.m.intraFreqReportingQuantityForRACHPresent) &&
          (RRC_CHECK_COMMON_MSG_TYPE(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.
          hcs_used->cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.intraFreqReportingQuantityForRACH.modeSpecificInfo,
          rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd)))
        {
          *meas_quantity_ptr = RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.
            hcs_used->cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.
            intraFreqReportingQuantityForRACH.modeSpecificInfo.
            u.fdd->intraFreqRepQuantityRACH_FDD);

          rach_status = SUCCESS;
        }
      }

    }
    else
    { /* HCS is NOT in use */

      if ( sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
        cellSelectQualityMeasure.t ==
        T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_cpich_RSCP )
      {
        /* The Cell Select Quality Measure is RSCP */
        if ((sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_RSCP->m.intraFreqMeasurementSysInfoPresent) &&
          (RRC_MSG_COMMON_BITMASK_IE(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo,
          rrc_IntraFreqMeasurementSysInfo_RSCP,intraFreqReportingQuantityForRACH)) &&
          (RRC_CHECK_COMMON_MSG_TYPE(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.
          intraFreqReportingQuantityForRACH.modeSpecificInfo,
          rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd)))
        {
          *meas_quantity_ptr = RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
            cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.
            intraFreqReportingQuantityForRACH.modeSpecificInfo.u.fdd->intraFreqRepQuantityRACH_FDD);

          rach_status = SUCCESS;
        }
      }
      else
      {
        if ((sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent) &&
          (RRC_MSG_COMMON_BITMASK_IE(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo,
          rrc_IntraFreqMeasurementSysInfo_ECN0,intraFreqReportingQuantityForRACH)) &&
          (RRC_CHECK_COMMON_MSG_TYPE(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo.
          intraFreqReportingQuantityForRACH.modeSpecificInfo,
          rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd)))
        {
          *meas_quantity_ptr = RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
            cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo.
            intraFreqReportingQuantityForRACH.modeSpecificInfo.u.fdd->intraFreqRepQuantityRACH_FDD);

          rach_status = SUCCESS;
        }
      }
    } /* End of else */
  } /* End of sib11_ptr not NULL */

  if((sib11_ptr != NULL) && (sib11_ptr->sib12indicator == TRUE) && (rrcmeas_current_substate != RRCMEAS_IDLE)
   && ((sib12_ptr = (rrc_SysInfoType12*)
          rrc_sibdb_return_sib_for_srv_cell(rrc_SIB12)) != NULL))
  {
    /* Check if HCS is in use. */
    if ( RRC_CHECK_COMMON_MSG_TYPE(sib12_ptr->measurementControlSysInfo.use_of_HCS,
    rrc_MeasurementControlSysInfo_use_of_HCS_hcs_used ))
    {
      /* Get Rpt Criteria */
      if (sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->cellSelectQualityMeasure.t ==
        T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_1_cpich_Ec_N0)
      {
        /* Check if RACH reporting criteria present */
        if ( (sib12_ptr->measurementControlSysInfo.use_of_HCS.u.
          hcs_used->cellSelectQualityMeasure.u.cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent) &&

          (RRC_MSG_COMMON_BITMASK_IE(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.
          hcs_used->cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo,
          rrc_IntraFreqMeasurementSysInfo_HCS_ECN0,intraFreqReportingQuantityForRACH))  &&

          (RRC_CHECK_COMMON_MSG_TYPE(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.
          hcs_used->cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo.
          intraFreqReportingQuantityForRACH.modeSpecificInfo,
          rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd)))
        {
          *meas_quantity_ptr = RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.
            hcs_used->cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo.
            intraFreqReportingQuantityForRACH.modeSpecificInfo.
            u.fdd->intraFreqRepQuantityRACH_FDD);

          rach_status = SUCCESS;
        }

      }

      else /* RSCP */
      {
        if ((sib12_ptr->measurementControlSysInfo.use_of_HCS.u.
          hcs_used->cellSelectQualityMeasure.u.cpich_RSCP->m.intraFreqMeasurementSysInfoPresent)
          &&(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.
          hcs_used->cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.m.intraFreqReportingQuantityForRACHPresent) &&
          (RRC_CHECK_COMMON_MSG_TYPE(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.
          hcs_used->cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.intraFreqReportingQuantityForRACH.modeSpecificInfo,
          rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd)))
        {
          *meas_quantity_ptr = RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.
            hcs_used->cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.
            intraFreqReportingQuantityForRACH.modeSpecificInfo.
            u.fdd->intraFreqRepQuantityRACH_FDD);

          rach_status = SUCCESS;
        }
      }

    }
    else
    { /* HCS is NOT in use */

      if ( sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
        cellSelectQualityMeasure.t ==
        T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_cpich_RSCP )
      {
        /* The Cell Select Quality Measure is RSCP */
        if ((sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_RSCP->m.intraFreqMeasurementSysInfoPresent) &&
          (RRC_MSG_COMMON_BITMASK_IE(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo,
          rrc_IntraFreqMeasurementSysInfo_RSCP,intraFreqReportingQuantityForRACH)) &&
          (RRC_CHECK_COMMON_MSG_TYPE(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.
          intraFreqReportingQuantityForRACH.modeSpecificInfo,
          rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd)))
        {
          *meas_quantity_ptr = RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
            cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.
            intraFreqReportingQuantityForRACH.modeSpecificInfo.u.fdd->intraFreqRepQuantityRACH_FDD);

          rach_status = SUCCESS;
        }
      }
      else
      {
        if ((sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent) &&
          (RRC_MSG_COMMON_BITMASK_IE(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo,
          rrc_IntraFreqMeasurementSysInfo_ECN0,intraFreqReportingQuantityForRACH)) &&
          (RRC_CHECK_COMMON_MSG_TYPE(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo.
          intraFreqReportingQuantityForRACH.modeSpecificInfo,
          rrc_IntraFreqReportingQuantityForRACH_modeSpecificInfo_fdd)))
        {
          *meas_quantity_ptr = RRCMEAS_RET_INTRA_FREQ_RACH_REP_QUAN(sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
            cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo.
            intraFreqReportingQuantityForRACH.modeSpecificInfo.u.fdd->intraFreqRepQuantityRACH_FDD);

          rach_status = SUCCESS;
        }
      }
    } /* End of else */
  }

  if ((rach_status == SUCCESS) && (*meas_quantity_ptr == L1_MEAS_NONE))
  {
    WRRC_MSG1_HIGH("SIB11 and SIB12 RACH quantity is %d. RACH quantity not supported", *meas_quantity_ptr);
    rach_status = FAILURE;
  }
  return rach_status;
}


/*===========================================================================

FUNCTION rrcmeas_check_if_scr_present_in_aset

DESCRIPTION

 Checks if SCR Code is present in ASET when UE transitions from Idle-->DCH
 or from FACH-->DCH

DEPENDENCIES



RETURN VALUE

 Success if SCR present in ASET
 Failure if SCR not present in ASET

SIDE EFFECTS

 None

===========================================================================*/

boolean rrcmeas_check_if_scr_present_in_aset
(
  void
)
{
  uint32 cnt = 0;

  if (current_config_ptr == NULL)
  {
    /* Return TRUE as reporting should not stop bec of err in CC */
    return TRUE;
  }
  else
  {
    WRRC_MSG1_HIGH("OLD SCR is %d", last_scr_code);
    if (current_config_ptr->l1_dl_chan_parms.num_rl == 0)
    {
      MSG_MED("CC has 0 RL in ASET",0,0,0);
      /* Return TRUE as reporting should not stop bec of err in CC */
      return TRUE;
    }
    for (cnt = 0; cnt < current_config_ptr->l1_dl_chan_parms.num_rl; cnt++)
    {
      /* Get no of radio links */
      if (last_scr_code == current_config_ptr->l1_dl_chan_parms.dl_per_rl[cnt].pri_cpich_scr_code)
      {
        return TRUE;
      }
    }
  }
  WRRC_MSG1_HIGH("SCR %d not found in ASET", last_scr_code);
  return FALSE;
}



/*===========================================================================

FUNCTION rrcmeas_update_meas_after_state_trans

DESCRIPTION

 Updates in all meas id variable that the specific meas cannot be reported

DEPENDENCIES


RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_update_meas_after_state_trans
(
  void
)
{
  uint32 cnt = 0;

  for (cnt =0; cnt < MAX_INTRA_FREQ_MEAS; cnt++ )
  {
    if (intra_freq_meas_id_list[cnt].meas_id != INVALID_MEAS_ID)
    {
    /* Make reporting as invalid */
      WRRC_MSG2_HIGH("Intra:Meas %d, Val %d cannot be reported",intra_freq_meas_id_list[cnt].meas_id,
               intra_freq_meas_id_list[cnt].meas_validity);
      intra_freq_meas_id_list[cnt].meas_can_be_reported = FALSE;
    }
  }

}


/*===========================================================================

FUNCTION rrcmeas_check_if_rpt_can_be_txted

DESCRIPTION

 Updates in all meas id variable that the specific meas cannot be reported

DEPENDENCIES


RETURN VALUE

 True/False

SIDE EFFECTS

 None

===========================================================================*/

boolean rrcmeas_check_if_rpt_can_be_txted
(
  uint16 m_id
)
{
  uint32 cnt = 0;

  for (cnt =0; cnt < MAX_INTRA_FREQ_MEAS; cnt++ )
  {
    if (intra_freq_meas_id_list[cnt].meas_id == m_id)
    {
      if (intra_freq_meas_id_list[cnt].meas_can_be_reported == FALSE)
      {
        WRRC_MSG2_HIGH("Meas %d, Val %d not reported", intra_freq_meas_id_list[cnt].meas_id,
                 intra_freq_meas_id_list[cnt].meas_validity);
        return FALSE;
      }
     }
   }
  return TRUE;

}


/*===========================================================================

FUNCTION rrcmeas_check_if_meas_reconfig_reqd

DESCRIPTION

 Get the meas id from SIB11 of the new cell. Then compare
 if this meas id matches with any of the meas id which was
 owned by a MCM. If TRUE, then return FALSE indicating that
 complete measurement reconfig not required. Else return TRUE
 indicating that complete meas reconfig required. The fn also checks
 if at meas db is empty. In that case it returns true in meas_db_empty_ptr

DEPENDENCIES


RETURN VALUE

 True/False

SIDE EFFECTS

 None

===========================================================================*/

boolean rrcmeas_check_if_meas_reconfig_reqd
(
  uint16* m_id_ptr,
  boolean* meas_db_empty_ptr
)
{
  uint32 cnt = 0;

  rrc_SysInfoType11 *sib11_ptr = NULL; /* Declared to store the value of SIB 11*/
  rrc_SysInfoType12 *sib12_ptr = NULL;

  sib11_ptr = (rrc_SysInfoType11*)  rrc_sibdb_return_sib_for_srv_cell
    (rrc_SIB11);
  sib12_ptr = (rrc_SysInfoType12*)  rrc_sibdb_return_sib_for_srv_cell
    (rrc_SIB12);

  /* Check if the value received is O.K. */

  if ( sib11_ptr == NULL )
  {
    return FALSE;
  }
  if((sib11_ptr->sib12indicator == TRUE) && (sib12_ptr != NULL))
  {
    if ( RRC_CHECK_COMMON_MSG_TYPE(sib12_ptr->measurementControlSysInfo.use_of_HCS,
    rrc_MeasurementControlSysInfo_use_of_HCS_hcs_used ))
    {
      if ( sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
        cellSelectQualityMeasure.t ==
        T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_1_cpich_RSCP )
      {

        /* The Cell Select Quality Measure is RSCP */
        if (sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
          cellSelectQualityMeasure.u.cpich_RSCP->m.intraFreqMeasurementSysInfoPresent)
        {
          *m_id_ptr = (uint16) sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
            cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.intraFreqMeasurementID;
        }
        else
        {
          /* Default meas id is 1 */
          *m_id_ptr = 1;
        }
      }
      else
      {
        /* The Cell Select Quality Measure is EcN0 */
        if (sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
          cellSelectQualityMeasure.u.cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent)
        {
          *m_id_ptr = (uint16) sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
            cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo.intraFreqMeasurementID;

        }
        else
        {
          /* Default meas id is 1 */
          *m_id_ptr = 1;
        }
      }
    }
    else
    { /* HCS is NOT in use */

      if ( sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
        cellSelectQualityMeasure.t ==
        T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_cpich_RSCP )
      {

        /* The Cell Select Quality Measure is RSCP */
        if (sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_RSCP->m.intraFreqMeasurementSysInfoPresent)
          
        {
          *m_id_ptr = (uint16) sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
            cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.intraFreqMeasurementID;
        }
        else
        {
          /* Default meas id is 1 */
          *m_id_ptr = 1;
        }
      }
      else
      {
        /* The Cell Select Quality Measure is EcN0 */
        if (sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent)
          
        {
          *m_id_ptr = (uint16) sib12_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
            cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo.intraFreqMeasurementID;
        }
        else
        {
          /* Default meas id is 1 */
          *m_id_ptr = 1;
        }
      }
    }
  }
  else
  {
  if ( RRC_CHECK_COMMON_MSG_TYPE(sib11_ptr->measurementControlSysInfo.use_of_HCS,
    rrc_MeasurementControlSysInfo_use_of_HCS_hcs_used ))
  {
    if ( sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
      cellSelectQualityMeasure.t ==
      T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_1_cpich_RSCP )
    {

      /* The Cell Select Quality Measure is RSCP */
      if (sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
        cellSelectQualityMeasure.u.cpich_RSCP->m.intraFreqMeasurementSysInfoPresent)
      {
        *m_id_ptr = (uint16) sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
          cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.intraFreqMeasurementID;
        }
      else
      {
        /* Default meas id is 1 */
        *m_id_ptr = 1;
      }
    }
    else
    {
      /* The Cell Select Quality Measure is EcN0 */
      if (sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
        cellSelectQualityMeasure.u.cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent)
        {
        *m_id_ptr = (uint16) sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
          cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo.intraFreqMeasurementID;

      }
      else
      {
        /* Default meas id is 1 */
        *m_id_ptr = 1;
      }
    }
  }
  else
  { /* HCS is NOT in use */

    if ( sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
      cellSelectQualityMeasure.t ==
      T_rrc_MeasurementControlSysInfo_cellSelectQualityMeasure_cpich_RSCP )
    {

      /* The Cell Select Quality Measure is RSCP */
      if (sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
        cellSelectQualityMeasure.u.cpich_RSCP->m.intraFreqMeasurementSysInfoPresent)
      {
        *m_id_ptr = (uint16) sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_RSCP->intraFreqMeasurementSysInfo.intraFreqMeasurementID;

      }
      else
      {
        /* Default meas id is 1 */
        *m_id_ptr = 1;
      }
    }
    else
    {
      /* The Cell Select Quality Measure is EcN0 */
      if (sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
        cellSelectQualityMeasure.u.cpich_Ec_N0->m.intraFreqMeasurementSysInfoPresent)
      {
        *m_id_ptr = (uint16) sib11_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
          cellSelectQualityMeasure.u.cpich_Ec_N0->intraFreqMeasurementSysInfo.intraFreqMeasurementID;
      }
      else
      {
        /* Default meas id is 1 */
        *m_id_ptr = 1;
      }
    }
  }
  }

  WRRC_MSG1_HIGH("Meas id %d",*m_id_ptr);  
  /* Now check if MCM owns a Meas Id that is the same as the one in SIB's */
  for (cnt =0; cnt < MAX_INTRA_FREQ_MEAS; cnt++ )
  {
    if ((intra_freq_meas_id_list[cnt].meas_id == *m_id_ptr) && (intra_freq_meas_id_list[cnt].mcm_owned == TRUE))
    {
      WRRC_MSG2_HIGH("Meas Id %d MCM matches SIB Meas Id. Only take cell list from SIB11", intra_freq_meas_id_list[cnt].meas_id,
        intra_freq_meas_id_list[cnt].meas_validity);
      *meas_db_empty_ptr = FALSE;
      return FALSE;
    }
    else if (intra_freq_meas_id_list[cnt].meas_id != INVALID_MEAS_ID)
    {
      WRRC_MSG0_HIGH("At Least One Meas exists in Meas DB");
      *meas_db_empty_ptr = TRUE;
    }
  }
  return TRUE;

}

#if defined (FEATURE_CGPS)
/*===========================================================================

FUNCTION rrcmeas_get_cell_id_plmn_info

DESCRIPTION

 Returns the PLMN id, Cell id ,Psc, Freq of the current serving cell.
 If the fn is invoked in INITIAL or DCH substate of measurement
 procedure, then false is returned indicating that cell id is not
 available

DEPENDENCIES
 None

RETURN VALUE

 True if Cell Id/PLMN/FREQ/SCR code available
 False if Cell Id/PLMN/FREQ/SCR code unavailable

SIDE EFFECTS

 None

===========================================================================*/

boolean rrcmeas_get_cell_plmn_info
(
  rrcmeas_plmn_cell_info_struct_type* plmn_cell_info_ptr
)
{
  rrc_camped_on_status_e_type rrc_camp_sts = rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_MCMR);

  WRRC_MSG2_HIGH("Cell Id requested : Meas state %d, Camped sts %d",rrcmeas_current_substate, rrc_camp_sts);

  if(RRC_CAMPED_ON != rrc_camp_sts)
  {
    return FALSE;
  }

  switch (rrcmeas_current_substate)
  {
  case RRCMEAS_INITIAL:
  case RRCMEAS_CELL_DCH:
    return FALSE;

  case RRCMEAS_IDLE:
  case RRCMEAS_CELL_FACH:
  case RRCMEAS_PCH:
    *plmn_cell_info_ptr = plmn_cell_info;
    return TRUE;

  default:
    return FALSE;
  }
}


/*===========================================================================

FUNCTION rrcmeas_set_cell_plmn_info

DESCRIPTION

 Sets the PLMN id, Cell id ,Psc, Freq of the current serving cell.

DEPENDENCIES
 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_set_cell_plmn_info
(
  void
)
{
  rrc_lai_type lai;
  rrc_new_cell_status_e_type ccm_sts = rrc_ccm_get_serv_plmn_cellid(&plmn_cell_info.cell_id, &plmn_cell_info.plmn_id);

  WRRC_MSG2_HIGH("Setting Cell/PLMN Info sub-state %d CCM sts %d",rrcmeas_current_substate,ccm_sts);

  if (RRC_NEW_CELL_SELECTED == ccm_sts)
  {
    plmn_cell_info.psc = rrc_ccm_get_curr_camped_psc();
    plmn_cell_info.freq = rrc_ccm_get_curr_camped_freq();
    if(SUCCESS == rrc_get_lac_id(&lai))
    {
      plmn_cell_info.lac[0] = lai.lac[0];
      plmn_cell_info.lac[1] = lai.lac[1];
    }
    else
    {
      MSG_LOW("Failed to get LAC",0,0,0);
    }
  }
  else
  {
    MSG_LOW("CCM indicated NoCell.Use previous",0,0,0);
  }
}
#endif /*FEATURE_CGPS */


/*===========================================================================

FUNCTION RRCMEAS_PATH_LOSS_CHECK

DESCRIPTION
 This function checks if the intra fq reporting quantity is path loss for SETUP & if
 so verifies if the cpich tx power is present in the cell info in valid range.
 If not it returns an error

DEPENDENCIES

 None

RETURN VALUE

FAILURE: Path loss error
SUCCESS: Path loss check validated

SIDE EFFECTS

 None
============================================================================*/
rrcmeas_status_e_type rrcmeas_path_loss_check
(
rrc_IntraFrequencyMeasurement* intra_f_meas_ptr
)
{
  rrc_CellsForIntraFreqMeasList *cells_for_meas_ptr = NULL;
  rrc_NewIntraFreqCellList *new_cell_list_ptr = NULL;
  uint32 idx=0,idy=0;
  /* Path loss checks */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr, rrc_IntraFrequencyMeasurement,intraFreqCellInfoList))
  {
    if((RRC_MSG_COMMON_BITMASK_IE(intra_f_meas_ptr->intraFreqCellInfoList,
      rrc_IntraFreqCellInfoList,newIntraFreqCellList))  &&
      (RRC_MSG_COMMON_BITMASK_IE(intra_f_meas_ptr->intraFreqCellInfoList,
      rrc_IntraFreqCellInfoList,cellsForIntraFreqMeasList)))
    {
      cells_for_meas_ptr = &intra_f_meas_ptr->intraFreqCellInfoList.cellsForIntraFreqMeasList;

      while(cells_for_meas_ptr->n > idx)
      {
        new_cell_list_ptr =
          &intra_f_meas_ptr->intraFreqCellInfoList.newIntraFreqCellList;
        idy=0;
        while(new_cell_list_ptr->n > idy)
        {
          if (! ((new_cell_list_ptr->elem[idy].cellInfo.modeSpecificInfo.t ==
            T_rrc_CellInfo_modeSpecificInfo_fdd) && (RRC_MSG_COMMON_BITMASK_IE(
            new_cell_list_ptr->elem[idy],rrc_NewIntraFreqCell,intraFreqCellID))
            && (cells_for_meas_ptr->elem[idx] == new_cell_list_ptr->elem[idy].intraFreqCellID)))
          {
            idy++;
            continue;
          }

          /* Now check if Tx Power is present */
          if ((new_cell_list_ptr->elem[idy].cellInfo.modeSpecificInfo.u.fdd->m.primaryCPICH_TX_PowerPresent) &&
            ((new_cell_list_ptr->elem[idy].cellInfo.modeSpecificInfo.u.fdd->primaryCPICH_TX_Power >= MIN_CPICH_TX_POWER_RANGE) &&
            (new_cell_list_ptr->elem[idy].cellInfo.modeSpecificInfo.u.fdd->primaryCPICH_TX_Power <= MAX_CPICH_TX_POWER_RANGE)))
          {
            MSG_LOW("path loss check O.K",0,0,0);
            /* Come out of while and check the next cell in the new cell list */
            break;

          }
          else
          {
            MSG_LOW("Txion Power invalid for cell id %d",
              new_cell_list_ptr->elem[idy].intraFreqCellID,0,0);
            return RRCMEAS_FAIL;
          }

        } /* End of while of new_curr */
        /* Get the next cell for meas */
        idx++;;
      } /* End of while for meas_curr */
    } /* End of if of cells for meas and new cells present */
    else
    {
      idx=0;
      if(RRC_MSG_COMMON_BITMASK_IE(intra_f_meas_ptr->intraFreqCellInfoList,
        rrc_IntraFreqCellInfoList,newIntraFreqCellList))
      {
        /* just check the new intra fq list for the path loss check */
        new_cell_list_ptr = &intra_f_meas_ptr->intraFreqCellInfoList.newIntraFreqCellList;
        while(new_cell_list_ptr->n > idx)
        {
          if (!((new_cell_list_ptr->elem[idx].cellInfo.modeSpecificInfo.t ==
            T_rrc_CellInfo_modeSpecificInfo_fdd) && (RRC_MSG_LIST_BITMASK_IE(new_cell_list_ptr,
             rrc_NewIntraFreqCell,intraFreqCellID))))
          {
            idx++;
            continue;
          }
          /* Now check if Tx Power is present */
          if ((new_cell_list_ptr->elem[idx].cellInfo.modeSpecificInfo.u.fdd->m.primaryCPICH_TX_PowerPresent) &&
            ((new_cell_list_ptr->elem[idx].cellInfo.modeSpecificInfo.u.fdd->primaryCPICH_TX_Power >= MIN_CPICH_TX_POWER_RANGE) &&
            (new_cell_list_ptr->elem[idx].cellInfo.modeSpecificInfo.u.fdd->primaryCPICH_TX_Power <= MAX_CPICH_TX_POWER_RANGE)))

          {
            MSG_LOW("pathloss:Check O.K",0,0,0);
            /* Check for next cell */
            idx++;
            continue;
          }
          else
          {
            MSG_LOW("pathloss:Txion Power unspecified for cell id %d",
              new_cell_list_ptr->elem[idx].intraFreqCellID,0,0);

            return RRCMEAS_FAIL;
          }

        } /* End of while of new_curr */
      } /* end of if of rrc_newIntraFreqCellList) */
    } /* end of else of rrc_newIntraFreqCellList) & rrc_cellsForIntraFreqMeasList) */
  } /* End of if of rrc_intraFreqCellInfoList) */
  return RRCMEAS_SUCCESS;
}

/*===========================================================================

FUNCTION    RRCMEAS_INITIALIZE_TRANSACTION_ID_LIST

DESCRIPTION

 Initialises transaction id list

 None.

RETURN VALUE

 void

SIDE EFFECTS

 None

===========================================================================*/

void rrcmeas_initialize_transaction_id_list
(
 void
)
{
  uint8 count;
  /* Initialize Transaction Identity variable */
  for ( count = 0; count < MAXIMUM_TRANSACTIONS; count++ )
  {
    rrcmeas_accepted_transaction_table[count].transaction_id = INVALID_TRANSACTION_ID;
    rrcmeas_accepted_transaction_table[count].is_latest_trans = FALSE;
  }
}

/*===========================================================================

FUNCTION rrcmeas_check_meas_id_used_for_different_meas_type

DESCRIPTION

 The function checks if the new meas id is already used for a different meas type
 and if so releases the measurement from the primary measurement database, from
 the additional measurement dtabase and send a release command to L1 to release
 the measurement.

DEPENDENCIES
 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/
void rrcmeas_check_meas_id_used_for_different_meas_type
(
  rrcmeas_layer_e_type meas_owner,
  uint16 meas_id
)
{
  uint8 count = 0;
  uint8 cnt = 0;
  boolean meas_found = FALSE;
  l1_meas_ctrl_parm_struct_type *l1_mcm = rrc_malloc(sizeof(l1_meas_ctrl_parm_struct_type));
  mac_ul_traffic_meas_config_type  mac_mcm_params;
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  rrc_meas_params_struct_type  *gps_meas_params;
  gps_meas_params = &temp_gps;
  memset(gps_meas_params,0,sizeof(rrc_meas_params_struct_type));
#endif
  if(meas_owner != INTRA_FREQ)
  {
    for(count = 0; count < MAX_INTRA_FREQ_MEAS; count++)
    {
      if(intra_freq_meas_id_list[count].meas_id == meas_id)
      {
        meas_found = TRUE;
        /* Store meas type */
        l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

        /* Delete Meas Id from Intra Freq Meas Id List */
        rrcmeas_delete_meas(&meas_id);

        /* Delete additional meas */
        rrcmeas_delete_addtl_meas(&meas_id);
        break;
      }
    }
  }

  if((meas_owner != INTER_FREQ) && (!meas_found))
  {
    for(count = 0; count < MAX_INTER_FREQ_MEAS; count++)
    {
      if(inter_freq_meas_id_list[count].meas_id == meas_id)
      {
        meas_found = TRUE;
        /* Store meas type */
        l1_mcm->meas_object.meas_type = L1_INTER_FREQ;
        inter_freq_meas_id_list[count].meas_id = INVALID_MEAS_ID;
        inter_freq_meas_id_list[count].rpt_crit = NOT_AVAILABLE;
        inter_freq_meas_id_list[count].mcm_owned = FALSE;
        inter_freq_meas_id_list[count].meas_validity = NOT_PRESENT;

        /* Also initialize additional meas */
        for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
          inter_freq_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;

        /* Delete additional meas */
        rrcmeas_delete_addtl_meas(&meas_id);
        break;
      }
    }
  }

  if((meas_owner != INTER_SYS) && (!meas_found))
  {
    for(count = 0; count < MAX_INTER_RAT_MEAS; count++)
    {
      if(inter_rat_meas_id_list[count].meas_id == meas_id)
      {
        meas_found = TRUE;
        /* Store meas type */
        l1_mcm->meas_object.meas_type = L1_INTER_SYS;
        inter_rat_meas_id_list[count].meas_id = INVALID_MEAS_ID;

        /* Also initialize additional meas */
        for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
          inter_rat_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;

        /* Delete additional meas */
        rrcmeas_delete_addtl_meas(&meas_id);
        break;
      }
    }
  }

  if((meas_owner != INTERNAL_MEAS) && (!meas_found))
  {
    for(count = 0; count < MAX_INTERNAL_MEAS; count++)
    {
      if(ueim_meas_id_list[count].meas_id == meas_id)
      {
        meas_found = TRUE;
        /* Store meas type */
        l1_mcm->meas_object.meas_type = L1_UE_INTERNAL;
        ueim_meas_id_list[count].meas_id = INVALID_MEAS_ID;
        ueim_meas_id_list[count].rpt_crit = NOT_AVAILABLE;

        /* Also initialize additional meas */
        for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
          ueim_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;

        /* Delete additional meas */
        rrcmeas_delete_addtl_meas(&meas_id);
        break;
      }
    }
  }

  if((meas_owner != QUALITY_MEAS) && (!meas_found))
  {
    for(count = 0; count < MAX_QUALITY_MEAS; count++)
    {
      if(quality_meas_id_list[count].meas_id == meas_id)
      {
        meas_found = TRUE;
        /* Store meas type */
        l1_mcm->meas_object.meas_type = L1_QUALITY;
        quality_meas_id_list[count].meas_id = INVALID_MEAS_ID;

        /* Also initialize additional meas */
        for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
          quality_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;

        break;
      }
    }
  }

  if(meas_found)
  {
     WRRC_MSG0_HIGH("Sending MCM release to L1");
    /* With release meas, additional meas should not be present */
    /* Set meas id in L1 struct */
    l1_mcm->meas_id = meas_id;

    /* Set trans Id in var trans_id */
    l1_mcm->trans_id = L1_NO_CNF_TRANSACTION_ID;//TBD
    l1_mcm->meas_object_info_included = FALSE;

    l1_mcm->dpch_cm_status_incl = FALSE;
    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_RELEASE;
    rrcmeas_send_l1_cmd(NULL, l1_mcm, NULL, L1_MEAS_CTRL_PARMS);
    rrc_free(l1_mcm);
    return;
  }

  if(meas_owner != MAC_MEAS)
  {
    for(count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++)
    {
      if(tvm_meas_id_list[count].meas_id == meas_id)
      {
        WRRC_MSG1_HIGH("Releasing earlier TVM meas with id %d", meas_id);
        meas_found = TRUE;
        mac_mcm_params.meas_id = meas_id;
        mac_mcm_params.meas_cmd = MAC_TRAFFIC_MEAS_DELETE;
        /* Delete Addtl Meas if any from the DB */
        rrcmeas_delete_addtl_meas(&mac_mcm_params.meas_id);
        mac_mcm_params.config_conf_ind = FALSE;
        tvm_meas_id_list[count].meas_id = INVALID_MEAS_ID;
        tvm_meas_id_list[count].block_rach_incl = FALSE;
        tvm_meas_id_list[count].meas_ctrl_msg = FALSE;
        tvm_meas_id_list[count].meas_validity = NOT_PRESENT;
        tvm_meas_id_list[count].rpt_crit = NOT_AVAILABLE;

        /* Also remove any Addtl Meas associated with it */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
        {
          tvm_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
        }
        rrctvm_send_mac_cmd(&mac_mcm_params);
        break;  /* Come out of for */
      }
    }
  }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  if((meas_owner != POSITION_MEAS) && (!meas_found))
  {
    for(count = 0; count < MAX_POS_MEAS; count++)
    {
      if(pos_meas_id_list[count].meas_id == meas_id)
      {
        WRRC_MSG1_HIGH("Releasing earlier POS meas with id %d", meas_id);
        meas_found = TRUE;
        pos_meas_id_list[count].meas_id = INVALID_MEAS_ID;
        pos_meas_id_list[count].meas_validity = NOT_PRESENT;
        pos_meas_id_list[count].rpt_crit = NOT_AVAILABLE;

        /* Also initialize additional meas */
        for ( cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++ )
          pos_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;

        rrcmeas_delete_addtl_meas(&meas_id);

        rrcgps_send_lsm_cmd(gps_meas_params);
        break;
      }
    }
  }
#endif
rrc_free(l1_mcm);
  return;
}


/*===========================================================================

FUNCTION   RRCMEAS_RETRIEVE_MEAS_OWNER_R5

DESCRIPTION

 Finds the owner of measurement identity given in a MCM Rel 5 Msg

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/

rrcmeas_layer_e_type rrcmeas_retrieve_meas_owner_r5
(
rrc_MeasurementCommand_r4* mcm_ptr,
uint32 meas_id
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
,pos_info_struct_type* pos_info_ptr
#endif
)
{
  uint8 count = 0;

  boolean meas_found = FALSE;
  /* First find if Meas is Setup/Modify/Delete */
  switch(mcm_ptr->t)
  {
  case T_rrc_MeasurementCommand_r4_setup:
    WRRC_MSG1_HIGH("MCM Setup: Meas %d",mcm_ptr->u.setup->t);
    if (mcm_ptr->u.setup->t ==
      T_rrc_MeasurementType_r4_trafficVolumeMeasurement)
    {
      return MAC_MEAS;
    }
    else
    {
      /* Find the actual L1 owner */
      if (mcm_ptr->u.setup->t ==
          T_rrc_MeasurementType_r4_intraFrequencyMeasurement)
      {
        return INTRA_FREQ;
      }
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r4_interRATMeasurement)
      {
        return INTER_SYS;
      }

      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r4_interFrequencyMeasurement)
      {
        return INTER_FREQ;
      }
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r4_ue_InternalMeasurement)
      {
        return INTERNAL_MEAS;
      }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r4_up_Measurement)
      {
        /* Also check in reporting quantity what type of meas is that */
        if ((mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.
          positioningMethod == rrc_PositioningMethod_otdoa) ||
          (mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.
          positioningMethod == rrc_PositioningMethod_cellID))
        {
          WRRC_MSG1_ERROR("PosMethod=%d unsupported 0/1/2/3 OTD/G/Both/Id",
            mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.positioningMethod);
          return UNKNOWN_MEAS;
        }
        /* Store position method and pos cmd */
        pos_info_ptr->pos_meas_cmd = RRC_MEAS_SETUP;
        pos_info_ptr->pos_method_type = RET_POS_METHOD
          (mcm_ptr->u.setup->u.up_Measurement->
          ue_positioning_ReportingQuantity.positioningMethod);

        return POSITION_MEAS;
      }
#endif

      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r4_qualityMeasurement)
      {
        return QUALITY_MEAS;
      }
      else
      {
        /* Else some other Meas */
        return UNKNOWN_MEAS;
      }
    }

  case T_rrc_MeasurementCommand_r4_modify:
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(mcm_ptr->u.modify,
      rrc_MeasurementCommand_r4_modify,measurementType))
    {
      WRRC_MSG1_HIGH("MCM:Modify, Meas Type included %d",mcm_ptr->u.modify->measurementType.t);

      if (RRC_CHECK_COMMON_MSG_TYPE(mcm_ptr->u.modify->measurementType,
        rrc_MeasurementType_r4_trafficVolumeMeasurement))
      {
        for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
        {
          if (tvm_meas_id_list[count].meas_id == meas_id)
          {
            return MAC_MEAS;
          } /* End of if of meas_identity found */

        } /* End of for loop  */

        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      } /* End of if of Traffic Volume Meas */

      else if (RRC_CHECK_COMMON_MSG_TYPE(mcm_ptr->u.modify->measurementType,
        rrc_MeasurementType_r4_interRATMeasurement))
      {
        for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
        {
          if (inter_rat_meas_id_list[count].meas_id == meas_id)
          {
            return INTER_SYS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
      else if (RRC_CHECK_COMMON_MSG_TYPE(mcm_ptr->u.modify->measurementType,
        rrc_MeasurementType_r4_ue_InternalMeasurement))
      {
        for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
        {
          if (ueim_meas_id_list[count].meas_id == meas_id)
          {
            return INTERNAL_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
      else if (RRC_CHECK_COMMON_MSG_TYPE(mcm_ptr->u.modify->measurementType,
        rrc_MeasurementType_r4_interFrequencyMeasurement))
      {
        for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
        {
          if (inter_freq_meas_id_list[count].meas_id == meas_id)
          {
            return INTER_FREQ;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }

      else if (RRC_CHECK_COMMON_MSG_TYPE(mcm_ptr->u.modify->measurementType,
        rrc_MeasurementType_r4_intraFrequencyMeasurement))
      {
        for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
        {
          if (intra_freq_meas_id_list[count].meas_id == meas_id)
          {
            return INTRA_FREQ;
          }

        } /* End of for loop */
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }

      } /* End of else if */

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      else if (RRC_CHECK_COMMON_MSG_TYPE(mcm_ptr->u.modify->
        measurementType,
        rrc_MeasurementType_r4_up_Measurement))
      {
        for ( count = 0; count < MAX_POS_MEAS; count++ )
        {
          if (pos_meas_id_list[count].meas_id == meas_id)
          {
            /* Store position method and pos cmd */
            pos_info_ptr->pos_meas_cmd = RRC_MEAS_MODIFY;
            pos_info_ptr->pos_method_type =
              RET_POS_METHOD(mcm_ptr->u.modify->measurementType.u.up_Measurement->
              ue_positioning_ReportingQuantity.positioningMethod);

            return POSITION_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
#endif

      else if (RRC_CHECK_COMMON_MSG_TYPE(mcm_ptr->u.modify->
        measurementType,
        rrc_MeasurementType_r4_qualityMeasurement))
      {
        for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
        {
          if (quality_meas_id_list[count].meas_id == meas_id)
          {
            return QUALITY_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
      else
      {
        return UNKNOWN_MEAS;
      }

    } /* End of if of modify  rrc_measurementType_present */
    else
    { /* Since Meas Type is not given. It must exist at UE.
      If not then send an error msg indicating
      unsupported measurement */

      /* First search in L1 Measurement ID List */

      for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
      {
        if (intra_freq_meas_id_list[count].meas_id == meas_id)
        {
          return INTRA_FREQ;
        }

      } /* End of for loop */

      /* Search in Traffic Volume List */

      for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
      {
        if (tvm_meas_id_list[count].meas_id == meas_id)
        {
          return MAC_MEAS;
        } /* End of if of meas_identity found */

      } /* End of for loop */


      for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
      {
        if (inter_rat_meas_id_list[count].meas_id == meas_id)
        {
          return INTER_SYS;
        }
      }


#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      for ( count = 0; count < MAX_POS_MEAS; count++ )
      {
        if (pos_meas_id_list[count].meas_id == meas_id)
        {
          pos_info_ptr->pos_meas_cmd = RRC_MEAS_MODIFY;
          pos_info_ptr->pos_method_type = pos_meas_id_list[count].pos_method_type;
          return POSITION_MEAS;
        }

      }
#endif
      for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
      {
        if (inter_freq_meas_id_list[count].meas_id == meas_id)
        {
          return INTER_FREQ;
        }
      }

      for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
      {
        if (ueim_meas_id_list[count].meas_id == meas_id)
        {
          return INTERNAL_MEAS;
        }

      }

      for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
      {
        if (quality_meas_id_list[count].meas_id == meas_id)
        {
          return QUALITY_MEAS;
        }
      }
      return NOT_EXIST;
    } /* End of else of meas_type not present */


  case T_rrc_MeasurementCommand_r4_release:
    WRRC_MSG0_HIGH("Rel 5 : MCM Release");

    /* First search in L1 Measurement ID List */

    for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
    {
      if (intra_freq_meas_id_list[count].meas_id == meas_id)
      {
        return INTRA_FREQ;
      }

    } /* End of for loop */

    /* Search in Traffic Volume List */

    for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
    {
      if (tvm_meas_id_list[count].meas_id == meas_id)
      {
        return MAC_MEAS;
      } /* End of if of meas_identity found */

    } /* End of for loop */


    for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
    {
      if (inter_rat_meas_id_list[count].meas_id == meas_id)
      {
        return INTER_SYS;
      }
    }

    for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
    {
      if (inter_freq_meas_id_list[count].meas_id == meas_id)
      {
        return INTER_FREQ;
      }
    }

    for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
    {
      if (ueim_meas_id_list[count].meas_id == meas_id)
      {
        return INTERNAL_MEAS;
      }

    }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
    for ( count = 0; count < MAX_POS_MEAS; count++ )
    {
      if (pos_meas_id_list[count].meas_id == meas_id)
      {
        pos_info_ptr->pos_meas_cmd = RRC_MEAS_DELETE;
        return POSITION_MEAS;
      }

    }
#endif

    for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
    {
      if (quality_meas_id_list[count].meas_id == meas_id)
      {
        return QUALITY_MEAS;
      }
    }

    return NOT_EXIST;


  default:
    return UNKNOWN_MEAS;

  } /* End of switch */

}

/*===========================================================================

FUNCTION   rrcmeas_process_mcm_r5

DESCRIPTION

    This function processed the Release 5 Meas Ctrl Message

DEPENDENCIES

    None

RETURN VALUE
   Void


SIDE EFFECTS

    None

===========================================================================*/

void rrcmeas_process_mcm_r5
(
  rrc_cmd_type *cmd_ptr,
  uint8 meas_ctrl_tr_id
)
{
  rrc_MeasurementControl_r4_IEs* mcm_ptr = NULL;

  rrc_DL_DCCH_Message* dcch_msg_ptr = NULL;

  /* Local var to store meas variable */
  rrcmeas_layer_e_type meas_owner;

  /* To store OC SET Status */
  rrcllc_oc_set_status_e_type oc_set_state;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  /* Local Variable to store meas id */
  uint32 meas_id;
  
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  pos_info_struct_type pos_info;
#endif

  /* Store the message. No need to check again */
  dcch_msg_ptr = (rrc_DL_DCCH_Message *)cmd_ptr->cmd.
    downlink_sdu_ind.decoded_msg;

  /* Store actual mcm ptr in a local variable */
  mcm_ptr = &dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.r4.measurementControl_r4;

  meas_id = mcm_ptr->measurementIdentity;

  /* Retrieve the Meas Owner */
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  meas_owner = rrcmeas_retrieve_meas_owner_r5(&mcm_ptr->measurementCommand,
    meas_id, &pos_info);
#else
  meas_owner = rrcmeas_retrieve_meas_owner_r5(&mcm_ptr->measurementCommand,
    meas_id);
#endif

  /* Get OC status */
  oc_set_state = rrcllc_get_ordered_config_status();

  MSG_HIGH("REL5: meas id %d, meas owner %d, oc_state %d",meas_id, meas_owner, oc_set_state);

  if ((((meas_owner == INTRA_FREQ) || (meas_owner == INTERNAL_MEAS)|| (meas_owner == INTER_FREQ) ||
    (meas_owner == INTER_SYS)) && (rrcmeas_current_substate != RRCMEAS_CELL_DCH))
    || ((oc_set_state == OC_SET_FOR_DCH_CELL_PCH_TRANS) || (oc_set_state == OC_SET_FOR_DCH_URA_PCH_TRANS)))
  {
    return;
  }

  /* Static Analysis tool */
  if((meas_owner != UNKNOWN_MEAS) && (meas_owner != NOT_EXIST))
  {
    rrcmeas_check_meas_id_used_for_different_meas_type(meas_owner, meas_id);
  }
  if (meas_owner == UNKNOWN_MEAS)
  {
    /* Send Meas Ctrl Failure Message */

    rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

    /* Set error t */
    rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

    if (pos_meas_failure == TRUE)
    {
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
      pos_meas_failure = FALSE;
    }

#endif

    /* Send MCF msg to UTRAN */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

    return;
  }

  if (meas_owner == NOT_EXIST)
  {
    if(mcm_ptr->measurementCommand.t != T_rrc_MeasurementCommand_r4_release)
    {
      /* Send Meas Ctrl Failure Message */
  
      rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;
  
      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
  
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  
      if (pos_meas_failure == TRUE)
      {
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
        pos_meas_failure = FALSE;
      }
  
#endif
  
      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
    }
    else
    {
      WRRC_MSG0_HIGH("Ignore MCM release for an nonexistent measurement, do not send MCM failure");
    }
    return;
  }


  /* Check if it is Inter-Freq Meas */
  if (meas_owner == INTRA_FREQ)
  {
    if (rrcmeas_process_intrafreq_r5(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      return;
    }
    else
    {
      return;
    }
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == INTER_FREQ)
  {
    if (rrcifreq_process_mcm_r5(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if((!process_interfreq_interrat_meas_rel7) && (!process_interfreq_uei_meas_rel7))
      {
        return;
      }
      return;
    }
    else
    {
      return;
    }
  }
  else if (meas_owner == MAC_MEAS)
  {
    if (rrctvm_process_traffic_vol_info_r5(cmd_ptr, meas_ctrl_tr_id) == TVM_SUCCESS)
    {
      return;
    }
    else
    {

      return;
    }
  }


  else if (meas_owner == INTER_SYS)
  {
    /* First check if dual mode is enabled */
    if (rrcmcm_is_dualmode_enabled() == FALSE)
    {
      /* Send Meas Ctrl Failure Message */

      rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      return;
    }

    if (rrcirat_process_mcm_r5(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if(!process_interfreq_interrat_meas_rel7)
      {
        return;
      }
      return;
    }
    else
    {
      return;
    }
  }

  else if (meas_owner == INTERNAL_MEAS)
  {
    if (rrcueim_process_mcm_r5(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if((!process_interfreq_interrat_meas_rel7) && (!process_interfreq_uei_meas_rel7))
      {
        return;
      }
      return;
    }
    else
    {
      return;
    }
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == QUALITY_MEAS)
  {
    if (rrcqm_process_mcm_r5(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      return;
    }
    else
    {
      return;
    }
  }
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  else if ( meas_owner ==  POSITION_MEAS)
  {
    if (rrcmeas_process_pos_mcm_r5(cmd_ptr->cmd.
      downlink_sdu_ind.decoded_msg, &pos_info, meas_ctrl_tr_id) == SUCCESS)
    {
      MSG_LOW("POS: MCM processed successfully",0,0,0);
    }
    else
    {
      MSG_LOW("POS: MCM not processed successfully",0,0,0);
    }
    return;
  } /* End of if of Positioning Measurements */
#endif
  else
  {
    WRRC_MSG0_ERROR("RRCHS:UNSUPPORTED Rel 5 Meas");
    /* Set transaction ID */

    rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

    /* Set error t */
    rrcmeas_mcf.error_choice =
      T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

    /* Send RRC Meas Ctrl Failure msg to UTRAN */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
  }

}

/*===========================================================================

FUNCTION  RRCMEAS_PROCESS_MCM_INTRA_F_CELL_INFO_R5

DESCRIPTION

 This function processes the Cell Info for meas setup and
 meas modify command type in a Measurement Control Message.
 The function processes Cell Info in ASN1 format and translates
 into the L1RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill mcm cell info correctly
 SUCCESS: If common mcm info filled correctly

SIDE EFFECTS

 None

===========================================================================*/

rrcmeas_status_e_type rrcmeas_process_mcm_intra_f_cell_info_r5
(
rrc_IntraFreqCellInfoList_r4* intra_freq_cell_info_list_ptr,
l1_intra_freq_meas_ctrl_struct_type* l1_intra_f_mcm_ptr
)
{
  rrc_RemovedIntraFreqCellList_removeSomeIntraFreqCells *local_remove_some_intra_freq_cells;

  rrc_NewIntraFreqCellList_r4 *local_new_intra_freq_celllist = NULL;
  uint32 idx=0;
  uint16 cell_count = 0;
  uint32 i =0;
  uint16 temp_cell_count = INVALID_CELL_COUNT; /* Some impossible invalid value*/

  uint16 removed_cell_count = 0;

  /* Stores psc from intra_freq_cell_list */
  uint16 psc = INVALID_PSC;

  uint32 cell_position = 0;

  /* Stores intra freq cell id */
  uint32 intra_freq_cell_id = 0;

  /* A list of psc which is obtained as a result of UTRAN adding cells in the
  * intra_freq_cell_list where already a cell existed. So L1 needs to be told
  * to remove these cells */
  uint16 psc_to_be_removed[L1_MAX_CELL_MEAS];

  /* Counts the no of psc to be removed [Cascading Effect count] */
  uint16 psc_removed_count = 0;

  uint16 psc_to_measure = INVALID_PSC;

  /* Stores no of cells to be measured */
  uint16 meas_cells_list[L1_MAX_CELL_MEAS];

  /* To store cell id from "Cells for Measurement" */
  uint32 cell_id;

  /* Indicates which cells should be measured by L1 */
  rrc_CellsForIntraFreqMeasList* cells_to_measure_ptr = NULL;
    /* Set cell list present to TRUE */

  /* Initialize arrays to satusfy lint */
  for (cell_count = 0; cell_count < L1_MAX_CELL_MEAS; cell_count++)
  {
    meas_cells_list[cell_count] = 0;
    psc_to_be_removed[cell_count] = 0;
  }

  l1_intra_f_mcm_ptr->cell_list_incl[PRI_FREQ] = TRUE;

  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_cell_info_list_ptr,
    rrc_IntraFreqCellInfoList_r4,removedIntraFreqCellList))
  {
    switch (intra_freq_cell_info_list_ptr->removedIntraFreqCellList.t)
    {
      WRRC_MSG1_HIGH("Remove cell list : type %d [1/2/3 : All/Some/None]",intra_freq_cell_info_list_ptr->removedIntraFreqCellList.t);
      case T_rrc_RemovedIntraFreqCellList_removeAllIntraFreqCells:
        l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv = REMOVE_ALL_INTRA_FREQ_CELLS;

        /* Reinitialize cell count */
        cell_count = 0;
        /* Update Cell_info_list variable */
        for (cell_count = 0; cell_count < L1_MAX_CELL_MEAS; cell_count++)
        {
          intra_freq_cell_list[PRI_FREQ][cell_count].cell_position = VACANT;
          intra_freq_cell_list[PRI_FREQ][cell_count].psc = INVALID_PSC;
        }

        break;

      case T_rrc_RemovedIntraFreqCellList_removeSomeIntraFreqCells:

        if ( (intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.removeSomeIntraFreqCells== NULL)
          ||(intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.removeSomeIntraFreqCells->n == 0))
        {
          break;
        }

        /* Store head of Link list */
        local_remove_some_intra_freq_cells =  intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.
          removeSomeIntraFreqCells;
        do
        {
          intra_freq_cell_id = local_remove_some_intra_freq_cells->elem[idx];
          /* Find the psc as per given cell id. This psc is given to L1 */
          if ( rrcmeas_find_psc(
            PRI_FREQ,
            &intra_freq_cell_id,
            &psc) == PSC_ABSENT)
          {
            WRRC_MSG1_ERROR("Remove:Incorrect cell id %d",intra_freq_cell_id);
            idx++;
            continue;
          }
          else
          {
            /* First remove cell from intra freq cell list */
            rrcmeas_remove_cellid(
            PRI_FREQ,
            &intra_freq_cell_id);

            /* Here one needs to put psc so that L1 can remove it */
            l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].rmv_cell[removed_cell_count].psc = (uint16) psc;

            removed_cell_count++; /* Increment count */
          }

          /*  Get next element in the list */
          idx++;
        } /* Continue if cond satisfied */

        while ( (local_remove_some_intra_freq_cells->n > idx) &&
          (removed_cell_count < L1_MAX_CELL_MEAS) );

        /* Restore the head of linked list pointer */
        /* intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.
           removeSomeIntraFreqCells = local_remove_some_intra_freq_cells 
           Now store the number of actual cells sent by UTRAN */

        l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv =  removed_cell_count;
        WRRC_MSG1_HIGH("Remove: Delete %d cells", removed_cell_count);

        break;

      case T_rrc_RemovedIntraFreqCellList_removeNoIntraFreqCells:
        /* Already set removed cells to 0 */
        MSG_LOW("Remove: Delete no cells selected",0,0,0);
        break;

      default:
        MSG_LOW("Invalid cell t",0,0,0);
        break;
    } /* End of switch */
  } /* End of else of removed intra freq cells present */

  /* Reinitialize these variables */
  cell_count = 0;
  psc = 0;

  /* Check if new cells present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_cell_info_list_ptr,
    rrc_IntraFreqCellInfoList_r4,newIntraFreqCellList))
  {
    /* Do not check for cell order. If UTRAN messes up, its their problem */

    /* Save the Head pointer of inked List */
    local_new_intra_freq_celllist = &intra_freq_cell_info_list_ptr->newIntraFreqCellList;
    idx=0;
    while ( ( local_new_intra_freq_celllist->n > idx) &&
      (cell_count < L1_MAX_CELL_MEAS) )
    {
    /* Pointer to next cell is Non-NULL and cell count
      * hasn't exceeded the max. L1 can handle */

      if ( local_new_intra_freq_celllist->elem[idx].
        cellInfo.modeSpecificInfo.t ==
        T_rrc_CellInfo_r4_modeSpecificInfo_tdd)
      {
        /* Nothing doing with a TDD cell. Shun it ! */

        idx++;

        continue;

      }
      /* Fill in Cell Info */
      /* Fill the cell_info in current index of add_cell if intraFreqCellID corresponding to current index is not already used
         Otherwise, all the latest cell_info corresponding to new intraFreqCellID entry should be copied to cell_info in add_cell corresponding to earlier
         intraFreqCellID*/
      for(i=0;i<idx;i++)
      {
        if(intra_freq_cell_info_list_ptr->newIntraFreqCellList.elem[idx].intraFreqCellID == 
            intra_freq_cell_info_list_ptr->newIntraFreqCellList.elem[i].intraFreqCellID)
        {
          /*Here as there is a matching ID is found, cell_info at the earlier index will be 
            populated, so cell_count should be i. After operation on this index is done we should 
            resume from the index in cell_info which we are storing in temp_cell_count and will
            be retrieved later*/
          temp_cell_count = cell_count;
          cell_count = i;
          break;
        }
      }
      if (rrcmeas_fill_mcm_cell_info_r5(
        &local_new_intra_freq_celllist->elem[idx].cellInfo,
        &l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].
        cell_info) == FAILURE)
      {
        idx++;
        continue;

      }

      /* Check if cell id present */
      if (RRC_MSG_LIST_BITMASK_IE(local_new_intra_freq_celllist,
        rrc_NewIntraFreqCell,intraFreqCellID))
      {
        cell_position = local_new_intra_freq_celllist->elem[idx].
          intraFreqCellID;


        /* Set psc from l1_intra_f_mcm_ptr->cell_list.add_cell[cell_count].
        cell_info.pri_scr_code in the intra freq cell list at position given by
        intra_freq_cell_info_list_ptr->newIntraFreqCellList->value.
        intraFreqCellID. Call rrcmeas_update_intra_freq_cell_list to do that */

      } /*  End of if of intra-freq cell id present */
      else
      {
        WRRC_MSG0_HIGH("Add: Cell Id not present");
        cell_position = AVAILABLE_CELL_POSITION;
        /* Set psc from l1_intra_f_mcm_ptr->cell_list.add_cell[cell_count].
        cell_info.pri_scr_code in the first vacant position in intra freq cell list */
      }

      /* If psc contains INVALID_PSC value, then the position at which this cell
      * has been updated is empty. If it contains any other value, then this
      * psc has to be removed. This is CASCADING effect. UTRAN adds a cell at
      * a position which results in a cell which was originally at that position
      * getting deleted */

      if ( rrcmeas_update_intra_freq_cell_list_mcm(
          PRI_FREQ,
        &cell_position,
        &l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].
        cell_info.pri_scr_code, &psc) == RRCMEAS_SUCCESS)
      {
        /* PSC sucessfully stored in the cell info list variable */
        /* Now store psc in the mcm in add cell for layer1 to use psc */
        l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].psc =
          l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].
          cell_info.pri_scr_code;

        if ((psc != INVALID_PSC) && (psc_removed_count < L1_MAX_CELL_MEAS)
            && (l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv != REMOVE_ALL_INTRA_FREQ_CELLS))
        {
          /* UTRAN wants us to delete this psc. Result of CASCADING effect */
          psc_to_be_removed[psc_removed_count++] = psc;
        }
        if(temp_cell_count != INVALID_CELL_COUNT)
        {
          cell_count = temp_cell_count;
          temp_cell_count = INVALID_CELL_COUNT;
          /*cell_count should be decremented as valid temp_cell_count implies duplicate intraFreqCellID entry*/
          cell_count--;
        }
        /* Increment cell count as add cell successfully stored */
        cell_count ++;
      }  /* End of if of rrcmeas_update_intra_freq_cell_list */

      /* Read next element */
      idx++;

      if ( (cell_count == L1_MAX_CELL_MEAS) &&
        (local_new_intra_freq_celllist->n > idx) )
      {
      /* If there are more new cells than can be accomodated in L1
      * Cmd, print a message and hope L1 will change their capability
      * sometime. Just pass the number that L1 can handle.
        */
        break;
      }
    } /* End of while newIntraFreqCellList != NULL */
    /* Restore the head pointer */

    //intra_freq_cell_info_list_ptr->newIntraFreqCellList = local_new_intra_freq_celllist;

    /* Initialize no of added cells */
    WRRC_MSG1_HIGH("Number of new intraFreq cells added are %d", cell_count);
    l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_add = cell_count;

    /* Reinitialize cell_count again */
    cell_count = 0;
    for (cell_count=0; cell_count < psc_removed_count; cell_count++)
    {
      /* Add this removed cell to the already built removed cell list for L1 */
      WRRC_MSG1_HIGH("Cascading:L1 removed cell list updated with %d psc",
        psc_to_be_removed[cell_count]);
      l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].rmv_cell[removed_cell_count++].psc =
        psc_to_be_removed[cell_count];
    }
    /* Now update the number of removed cells */
    l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv += psc_removed_count;
    MSG_LOW("Thus, L1 should be removing %d cells",
      l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv,0,0);

  } /* End of if for new intra freq cells present */


  /* Initialize no fo cells to 0 */
  l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_meas = 0;
  cell_count = 0;
  l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].cells_for_meas_incl = FALSE;
  /* Check if cells for meas present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_cell_info_list_ptr,
    rrc_IntraFreqCellInfoList_r4,cellsForIntraFreqMeasList))
  {
    l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].cells_for_meas_incl = TRUE;
    idx=0;
    cells_to_measure_ptr = &intra_freq_cell_info_list_ptr->cellsForIntraFreqMeasList;
    while (cells_to_measure_ptr->n > idx)
    {

      cell_id = cells_to_measure_ptr->elem[idx];
      /* Check if the cell id is present in intra_freq_cell_list VARIABLE */
      if ( rrcmeas_find_psc(
           PRI_FREQ,
            &cell_id, &psc_to_measure) == PSC_ABSENT)
      {
        MSG_LOW("Invalid cell to measure with id = %d",
          cell_id,0,0);

      } /* End of if for psc not found */
      else
      {
        /* Store psc */
        if(cell_count < L1_MAX_CELL_MEAS)
        {
          meas_cells_list[cell_count++] = psc_to_measure;
        }
      }

      /* Increment Ptr */
      idx++;
    } /* End of while */

    l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_meas =  cell_count;
    /* Copy cells to measure list and also no of cells to measure */
    for (cell_count = 0; cell_count < l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_meas;
    cell_count++)
    {
      l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].meas_cells_list[cell_count] =
        meas_cells_list[cell_count];
    }

  } /* End of if of rrc_cellsForIntraFreqMeasList_present */
  return RRCMEAS_SUCCESS;
}

/*===========================================================================

FUNCTION  RRCMEAS_FILL_COMMON_MCM_INTRA_F_INFO_R5

DESCRIPTION

 This function fills in common Cell Info for meas setup and
 meas modify command type in a Measurement Control Message.
 The function processes Cell Info in ASN1 format and translates
 into the L1RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill common mcm info correctly
 SUCCESS: If common mcm info filled correctly

SIDE EFFECTS

 None

===========================================================================*/

rrcmeas_status_e_type rrcmeas_fill_common_mcm_intra_f_info_r5
(
rrc_IntraFrequencyMeasurement_r4* intra_f_meas_ptr,
l1_meas_ctrl_parm_struct_type *l1_mcm ,
rrc_MeasurementControl_v590ext_IEs* mcm_ext_ptr
)
{
  uint16 cell_count = 0;
  uint16 freq_idx = 0;

  l1_intra_freq_meas_ctrl_struct_type* l1_intra_f_mcm_ptr = &l1_mcm->meas_object.u.intra_f;

  uint8  meas_id_idx = rrcmeas_find_meas_id_idx(l1_mcm->meas_id);

  WCDMA_MEMCPY(intra_freq_cell_list_temp, 
               sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
               intra_freq_cell_list,
               sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);

  /* Assign default values */
  l1_intra_f_mcm_ptr->meas_quan_incl = FALSE;
  l1_intra_f_mcm_ptr->meas_quan.quan_type = L1_MEAS_NONE;

  /* Assign Default value to filter coefficient 0 */
  l1_intra_f_mcm_ptr->meas_quan.filter_coef = 0;

  /* Store Meas Quantity */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr,
    rrc_IntraFrequencyMeasurement_r4,intraFreqMeasQuantity))
  {
    /* Check if meas quan is for fdd */
    if (RRC_CHECK_COMMON_MSG_TYPE(intra_f_meas_ptr->
      intraFreqMeasQuantity.modeSpecificInfo,
      rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd ))
    {
      /* Intra freq meas quantity for FDD mode is present */
      l1_intra_f_mcm_ptr->meas_quan_incl = TRUE;

      /* So read the value of meas quantity and filter coefficient */
      l1_intra_f_mcm_ptr->meas_quan.quan_type =
        RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
        intra_f_meas_ptr->
        intraFreqMeasQuantity.modeSpecificInfo.u.fdd->intraFreqMeasQuantity_FDD);

 
      /* Check if rrc_IntraFreqMeasQuantity_filterCoefficient_present */
    
        /* Store filter coefficient */
        l1_intra_f_mcm_ptr->meas_quan.filter_coef = (uint16)
          RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(intra_f_meas_ptr->
          intraFreqMeasQuantity.filterCoefficient);
      

    } /* End of if for rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd  */

  } /* End of if of intra freq meas quantity not present */

  /* Initialize no of added, removed cells to 0, cell_incl to FALSE */
  for(freq_idx = 0; freq_idx < MAX_NUM_CARR; freq_idx++)
  {
    /* Initialize no of added, removed cells to 0, cell_incl to FALSE */
    l1_intra_f_mcm_ptr->cell_list_incl[freq_idx] = FALSE;
    l1_intra_f_mcm_ptr->cell_list[freq_idx].num_cell_add = 0;
    l1_intra_f_mcm_ptr->cell_list[freq_idx].num_cell_rmv = 0;

    /* Print first few elements of the list for debugging purposes */
    for (cell_count = 0; cell_count < (L1_MAX_CELL_MEAS - 20); cell_count++)
    {
       MSG_MED("Cell list %d element is %d, psc = %d", cell_count,
       intra_freq_cell_list[freq_idx][cell_count].cell_position,
       intra_freq_cell_list[freq_idx][cell_count].psc);
    }
    cell_count = 0;
  }

  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr,
      rrc_IntraFrequencyMeasurement_r4,intraFreqCellInfoList))
  {
    if(RRCMEAS_FAIL == rrcmeas_process_mcm_intra_f_cell_info_r5(&intra_f_meas_ptr->intraFreqCellInfoList, l1_intra_f_mcm_ptr))
    {
      return RRCMEAS_FAIL;
    }

  } /* End of intra freq cell info list present */

  /* Assign default values for intra-f reporting quantity */
  l1_intra_f_mcm_ptr->intra_f_rpt_quan_incl = FALSE;

  /* Check if intra-f reporting quantity present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr, rrc_IntraFrequencyMeasurement_r4,intraFreqReportingQuantity))
  {
    if ( (rrcmeas_fill_intra_freq_rep_quan(&intra_f_meas_ptr->intraFreqReportingQuantity,
      l1_intra_f_mcm_ptr)) == SUCCESS )
      l1_intra_f_mcm_ptr->intra_f_rpt_quan_incl = TRUE;

  }

  /* Initialize rpt_mode to no change */
   l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_NO_CHANGE;

  /* Set reporting cell status to FALSE */
   l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = FALSE;
  l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[PRI_FREQ] = FALSE;

#ifdef FEATURE_WCDMA_DC_HSUPA
  /* N/W may configure modify from R9 to pre R9 
   * Configure rpt crit accordingly  */
  if(CHECK_RPT_CRIT_NOT_PRESENT(SEC_FREQ))
  {
  l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_RPT_MODE_NOT_PRESENT;
    if(meas_id_idx < MAX_INTRA_FREQ_MEAS)
    {
      intra_freq_meas_id_list[meas_id_idx].rpt_crit[SEC_FREQ] = NOT_AVAILABLE;
    }
  }
  else
  {
    l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_NO_CHANGE;   
  }


  /* Set reporting cell status to FALSE */
  l1_intra_f_mcm_ptr->rpt_cell_status_incl[SEC_FREQ] = FALSE;

  /* Set reporting crit incl to FALSE */
  l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[SEC_FREQ] = FALSE;
#endif


  /* Check if INTRA-FREQ reportCriteria (Periodic/Event) present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr, rrc_IntraFrequencyMeasurement_r4,reportCriteria))
  {
    /* Check report criteeria type */
    switch (intra_f_meas_ptr->reportCriteria.t)
    {
    case T_rrc_IntraFreqReportCriteria_r4_intraFreqReportingCriteria:
      /* Check if Event triggered intraFreqReportingCriteria list present */

      if (RRC_MSG_COMMON_BITMASK_IE_PTR( intra_f_meas_ptr->reportCriteria.u.
        intraFreqReportingCriteria,rrc_IntraFreqReportingCriteria_r4,eventCriteriaList))
      {
        /* Set event parameters */
         l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].num_event =
          rrcmeas_fill_intra_freq_event_criteria_r5(
          intra_f_meas_ptr->reportCriteria.u.intraFreqReportingCriteria,
           l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].evt,mcm_ext_ptr);
        /* Set rpt mode criteria */
         l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_EVENT_TRIGGER_RPT;

      } /* End of if for event criteria list not present */
      else
      {
        MSG_LOW("Setting num_event to 0", 0,0,0);
        /* So set num_event in L1 structure to 0 */

         l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].num_event = 0;
      }

      break; /* Come out of switch */

    case T_rrc_IntraFreqReportCriteria_r4_periodicalReportingCriteria:

      /* Set rpt mode criteria */
       l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_PERIODIC_RPT;


      /* Set reporting cells */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria,
        rrc_PeriodicalWithReportingCellStatus,reportingCellStatus))
      {
        if (rrcmeas_fill_no_of_reporting_cells(&intra_f_meas_ptr->reportCriteria.u.
          periodicalReportingCriteria->reportingCellStatus,
          & l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ]) == SUCCESS)
        {
           l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = TRUE;
        }
      }

      l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[PRI_FREQ] = TRUE;
      /* Store reporting amount */
      l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_amount=
        RRCMEAS_RET_REPORTING_AMOUNT(
        intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->
        periodicalReportingCriteria.reportingAmount);
      

      /* Store reporting interval */
      l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_interval =
        RRCMEAS_RET_PERIODIC_REPORTING_INTERVAL
        (intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->periodicalReportingCriteria.reportingInterval);

      if (intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->
        periodicalReportingCriteria.reportingInterval == rrc_ReportingIntervalLong_ril0)
      {
        l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_interval = 250;
      }

      break; /* Come out of switch */


    case T_rrc_IntraFreqReportCriteria_r4_noReporting:

       l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_NO_RPT;

      /* Set reporting cell status to FALSE */
       l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = FALSE;

      if ((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.noReporting,
        rrc_ReportingCellStatusOpt,reportingCellStatus))  &&
        ( rrcmeas_fill_no_of_reporting_cells(&intra_f_meas_ptr->reportCriteria.u.noReporting->reportingCellStatus,
        & l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ]) == SUCCESS ))
      {
         l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = TRUE;
      }

      break;

    default:
      return RRCMEAS_FAIL;

    } /* End of switch */

    if (( l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] == TRUE) &&
      (( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_VASET) ||
      ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_MSET_NUSED_FREQ) ||
      ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_ASET_MSET_NUSED_FREQ) ||
      ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_ALL_VASET_AND_MSET_NUSED_FREQ)))
    {
      WRRC_MSG1_ERROR("Rpt Cell Status invalid %d",  l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat);
      /* Retain the old CELL_INFO_LIST */

      WCDMA_MEMCPY(intra_freq_cell_list, 
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                   intra_freq_cell_list_temp,
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);

      return RRCMEAS_FAIL;
    }

  } /* End of if of rrc_reportCriteria) */

  return RRCMEAS_SUCCESS;
}


/*===========================================================================

FUNCTION  RRCMEAS_FILL_MCM_CELL_INFO_R5

DESCRIPTION

 This function fills in Cell Info received from a R5
 Measurement Control Message. The function processes
 Cell Info in ASN1 format and translates into the L1
 RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill cell info correctly.
 SUCCESS: If cell info is filled correctly

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_fill_mcm_cell_info_r5
(
rrc_CellInfo_r4* mcm_cell_info_ptr,
l1_cell_info_struct_type* l1_cell_info_ptr
)
{

    l1_cell_info_ptr->cell_offset =
      mcm_cell_info_ptr->cellIndividualOffset;
  

  /* Fill in Reference Time Difference to serving cell */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(mcm_cell_info_ptr,
    rrc_CellInfo_r4,referenceTimeDifferenceToCell))
  {
    /* Set reference time difference included to true */
    l1_cell_info_ptr->ref_tm_diff_incl = TRUE;

    /* Fill cell time difference */
    rrcmeas_fill_reference_time_difference(&mcm_cell_info_ptr->referenceTimeDifferenceToCell,
      l1_cell_info_ptr);

  }
  else
  {
  /* Reference time difference to cell absent
    * Set reference time difference included to false */

    l1_cell_info_ptr->ref_tm_diff_incl = FALSE;

    l1_cell_info_ptr->ref_tm_diff = 0;
    l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_40_CHIPS;

    MSG_LOW("Reference time diff : %d  Time acc is %d",l1_cell_info_ptr->ref_tm_diff,l1_cell_info_ptr->time_acc,0);
  }

  /* Initialize the following 2 to FALSE */
  /* Primary CPICH info absent */
  l1_cell_info_ptr->pri_scr_code_incl = FALSE;

  /* Primary CPICH TX power present It is an optional parameter */
  l1_cell_info_ptr->pri_cpich_txpwr_incl = FALSE;


  /* Fill in Mode Specific Info */
  if ( mcm_cell_info_ptr->modeSpecificInfo.t ==
    T_rrc_CellInfo_r4_modeSpecificInfo_tdd )
  {

    /* Mode specific info is for TDD */
    MSG_LOW("Using default values",0,0,0);

    /* Read SFN indicator */
    l1_cell_info_ptr->rd_sfn_ind = FALSE;

    /* Read Tx Diversity indicator */
    l1_cell_info_ptr->tx_diver_ind = FALSE;

    /* Cell Select Reselect Info is absent */
    l1_cell_info_ptr->cell_sel_resel_info_incl = FALSE;

  }
  else
  {
  /* Mode specific info is for FDD
    * Pri CPICH Scrambling code and CPICH Tx Power */

    if (mcm_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_InfoPresent)
    {

      /* Primary CPICH info present */
      l1_cell_info_ptr->pri_scr_code_incl = TRUE;

      l1_cell_info_ptr->pri_scr_code = (uint16)
        mcm_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;
    }

    if ( mcm_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_TX_PowerPresent)
    {

      /* Primary CPICH TX power present It is an optional parameter */

      l1_cell_info_ptr->pri_cpich_txpwr_incl = TRUE;

      /* Set its value */
      l1_cell_info_ptr->pri_cpich_txpwr =
        mcm_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_TX_Power;
    }

    /* Read SFN indicator */
    l1_cell_info_ptr->rd_sfn_ind =
      (boolean) mcm_cell_info_ptr->modeSpecificInfo.u.fdd->readSFN_Indicator;

    /* Read Tx Diversity indicator */
    l1_cell_info_ptr->tx_diver_ind =
      (boolean) mcm_cell_info_ptr->modeSpecificInfo.u.fdd->tx_DiversityIndicator;

    /* Cell Select Reselect Info is absent */
    l1_cell_info_ptr->cell_sel_resel_info_incl = FALSE;

  }


  return(SUCCESS);
}  /* rrcmeas_fill_mcm_cell_info_r5  */

/*===========================================================================

FUNCTION     RRCMEAS_FILL_INTRA_FREQ_EVENT_CRITERIA_R5

DESCRIPTION

 This function fills in intra-freq event criteria for a Non-HCS cell when
 Cell Selection Reselection Quality Measure is RCSP or ECNO for R5 Message
 The function processes intra-ftreq event criteria Info in ASN1 format
 and translates into the L1 RRC Interface format.

DEPENDENCIES

 The passed pointers must be valid.

RETURN VALUE

 No of events.

SIDE EFFECTS

 None

===========================================================================*/

uint16 rrcmeas_fill_intra_freq_event_criteria_r5
(
rrc_IntraFreqReportingCriteria_r4  *rrc_intra_freq_reporting_criteria_ptr,
l1_intra_freq_event_crit_struct_type *l1_intra_freq_event_crit_ptr,
rrc_MeasurementControl_v590ext_IEs* mcm_ext_ptr
)
{
  /* To store cell list for 1a or 1b if present */
  rrc_ForbiddenAffectCellList_r4 *forbidden_affect_cell_list_ptr = NULL;
  uint32 idx=0,idy=0;
  /* Stores ptr to passed rrc_IntraFreqEventCriteriaList */
  rrc_IntraFreqEventCriteriaList_r4  *rrc_intra_freq_event_criteria_list_ptr = NULL;

  /* Counts forbidden cell count */
  uint16 forbidden_cell_list_count = 0;

  /* To satisfy LINT as e1a, e1b values would be stored here first */
  l1_intra_freq_event_enum_type event_type;

  /* Counts no of events */
  uint16 event_count = 0;

  rrc_Intra_FreqEventCriteriaList_v590ext * event_1e_ptr = NULL;
  rrc_Intra_FreqEventCriteriaList_v590ext * event_1f_ptr = NULL;

  if((mcm_ext_ptr != NULL) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(
    mcm_ext_ptr,measurementCommand_v590ext))
    && (mcm_ext_ptr->measurementCommand_v590ext.t == T_rrc_MeasurementControl_v590ext_IEs_measurementCommand_v590ext_intra_frequency))
  {
    event_1e_ptr = &mcm_ext_ptr->measurementCommand_v590ext.u.intra_frequency;
    event_1f_ptr = event_1e_ptr;
  }

  /* Store event crit list ptr */
  rrc_intra_freq_event_criteria_list_ptr = &rrc_intra_freq_reporting_criteria_ptr->eventCriteriaList;

  if ( rrc_intra_freq_event_criteria_list_ptr->n == 0 )
  {
    MSG_LOW("Intra-freq event criteria list is Empty", 0,0,0);
    return event_count;
  }


  idy=0;
  /* ReportingRange, Hystersis, W converted by L1 */
  /* Store now the first event reporting criteria value from the list */
  while ( (rrc_intra_freq_event_criteria_list_ptr->n > idx) &&
    (event_count < L1_INTRA_FREQ_MAX_NUM_EVENT) )
  {

    /* First get the event ID */
    switch ( rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.t )
    {
      case T_rrc_IntraFreqEvent_r4_e1a:
        event_type = L1_INTRA_FREQ_EVENT_1A;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store triggering condition */

        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->
          triggeringCondition);

        /* Store Reporting Range */
        l1_intra_freq_event_crit_ptr[event_count].rpt_range = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingRange;

        /* Store no of cells forbidden to affect reporting range */
        if (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->m.
            forbiddenAffectCellListPresent)
        {
          /* Now store the scrambling code for each cell */

          forbidden_affect_cell_list_ptr =
            &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->forbiddenAffectCellList;

          idy=0;
          while ( (forbidden_affect_cell_list_ptr->n > idy) &&
            (forbidden_cell_list_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is non-NULL and forbidden cell count hasn't exceeded
            * the maximum. So keep on counting */

            if ( forbidden_affect_cell_list_ptr->elem[idy].t ==
              T_rrc_ForbiddenAffectCell_r4_tdd )
            {
              /* Set pointer value to next */
              idy++;

              continue;

            }
            else
            {
              /* Store scrambling code */
              l1_intra_freq_event_crit_ptr->forbidden_cell_scr_code[forbidden_cell_list_count] = (uint16)
                forbidden_affect_cell_list_ptr->elem[idy].u.fdd->primaryScramblingCode;

              /* Now increment count and store ptr to next value */
              forbidden_cell_list_count++;
              idy++;


              if ( (forbidden_cell_list_count == L1_MAX_CELL_MEAS) &&
                (forbidden_affect_cell_list_ptr->n > idy) )
              {

                MSG_LOW("Cannot include all forbidden cells", 0,0,0);
                break;
              }
            } /* End of else */

          } /* End of while of forbidden_affect_cell_list_ptr != NULL */

          /* Now store the number of forbidden affect cells in l1 struct */

          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = forbidden_cell_list_count;
        } /* End of if for forbidden_affect_cell_list actually present */

        else
        { /* forbidden_affect_cell_list actually absent */
          /* Set as per L1 req */
          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = 0;
        }

        /* Now store rest of the parameters of event 1a */

        /* Store WEIGHT */

        /* Use this to verify  rrc_intra_freq_event_criteria_list_ptr   */
        l1_intra_freq_event_crit_ptr[event_count].w = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->w;

        /* Store deactivation threshold */
        l1_intra_freq_event_crit_ptr[event_count].rpt_deact_thresh =
          RRCMEAS_RET_DEACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportDeactivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingInterval);

        MSG_HIGH("1A:RptAmt %d,RptIntvl %dms,Deacthresh %d",
         l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_deact_thresh);


        break; /* Come out of switch and return SUCCESS */

      case T_rrc_IntraFreqEvent_r4_e1b:
        event_type = L1_INTRA_FREQ_EVENT_1B;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store triggering condition 1 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_1(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->triggeringCondition);

        /* Store Reporting Range */
        l1_intra_freq_event_crit_ptr[event_count].rpt_range = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->reportingRange;

        /* Initialize reporting intvl to 0 */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl = 0;

        /* Initialize no of rpts to 0 */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt = 0;

        if (mcm_ext_ptr == NULL)
        {
          MSG_LOW("Event 1B Ext absent",0,0,0);
        }
        else
        {
          if (RRC_MSG_COMMON_BITMASK_IE_PTR(mcm_ext_ptr,
            rrc_MeasurementControl_v590ext_IEs,intraFreqReportingCriteria_1b_r5))
          {
            /* Store reporting interval */
            l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
            RRCMEAS_RET_REPORTING_INTERVAL(
            mcm_ext_ptr->intraFreqReportingCriteria_1b_r5.periodicReportingInfo_1b.reportingInterval);

            l1_intra_freq_event_crit_ptr[event_count].num_rpt =
              RRCMEAS_RET_REPORTING_AMOUNT(mcm_ext_ptr->intraFreqReportingCriteria_1b_r5.
                                         periodicReportingInfo_1b.reportingAmount);
          }
        }

        WRRC_MSG2_HIGH("RRCHS:Event 1B RptIntvl %d ms, Num rpt %d",
                 l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt);




        if ( rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->m.
            forbiddenAffectCellListPresent )
        {
          /* Now store the scrambling code for each cell */

          forbidden_affect_cell_list_ptr =
            &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->
            forbiddenAffectCellList;

          idy=0;
          while ( (forbidden_affect_cell_list_ptr->n > idy) &&
            (forbidden_cell_list_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is non-NULL and forbidden cell count hasn't exceeded
            the maximum. So keep on counting */

            if ( forbidden_affect_cell_list_ptr->elem[idy].t ==
              T_rrc_ForbiddenAffectCell_r4_tdd )
            {
              idy++;
              continue;

            }
            else
            {
              /* Store scrambling code */
              l1_intra_freq_event_crit_ptr[event_count].
                forbidden_cell_scr_code[forbidden_cell_list_count] = (uint16)
                forbidden_affect_cell_list_ptr->elem[idy].u.fdd->primaryScramblingCode;

              /* Now increment count and store ptr to next value */
              forbidden_cell_list_count++;

              idy++;

              if ( (forbidden_cell_list_count == L1_MAX_CELL_MEAS) &&
                (forbidden_affect_cell_list_ptr->n > idy) )
              {

                MSG_LOW("Cannot include all the forbidden cells", 0,0,0);
                break;
              }
            } /* End of else */

          } /* End of while of forbidden_affect_cell_list_ptr != NULL */

          /* Now store the number of forbidden affect cells in l1 struct */

          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
            forbidden_cell_list_count;
        } /* End of if for forbidden_affect_cell_list actually present */

        else
        { /* forbidden_affect_cell_list actually absent */
          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = 0;
        }

        /* Store WEIGHT */

        l1_intra_freq_event_crit_ptr[event_count].w = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->w;

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_r4_e1c:
        event_type = L1_INTRA_FREQ_EVENT_1C;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store replacement activation threshold */

        l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh =
          RRCMEAS_RET_REPLACEMENT_ACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          replacementActivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          reportingInterval);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;

        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        MSG_HIGH("1C:RptAmt %d,RptIntvl %dms,Deacthresh %d",
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh);



        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_r4_e1d:
        event_type = L1_INTRA_FREQ_EVENT_1D;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        l1_intra_freq_event_crit_ptr[event_count].evt_1d_trig_cond_incl = FALSE;

        l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl = FALSE;

        if (mcm_ext_ptr == NULL)
        {
          MSG_LOW("Event 1D Ext absent",0,0,0);
        }
        else
        {
          if (RRC_MSG_COMMON_BITMASK_IE_PTR(mcm_ext_ptr,
            rrc_MeasurementControl_v590ext_IEs,intraFreqEvent_1d_r5))
          {
            if (RRC_MSG_COMMON_BITMASK_IE_TYPE2(mcm_ext_ptr->intraFreqEvent_1d_r5,
                triggeringCondition))
            {
              l1_intra_freq_event_crit_ptr[event_count].evt_1d_trig_cond_incl = TRUE;

              l1_intra_freq_event_crit_ptr[event_count].trig_cond =
              (l1_meas_event_trigger_enum_type)
              RRCMEAS_RET_TRIGGERING_CONDITION_2(mcm_ext_ptr->intraFreqEvent_1d_r5.
                                                 triggeringCondition);

              MSG_LOW("RRCHS:Event 1D trig cond 0:ASET/1:MSET %d",
                       l1_intra_freq_event_crit_ptr[event_count].trig_cond,0,0);

            }
            if ((mcm_ext_ptr->intraFreqEvent_1d_r5.m.useCIOPresent)
              && (mcm_ext_ptr->intraFreqEvent_1d_r5.useCIO == TRUE))
            {
              l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl = TRUE;

              MSG_LOW("RRCHS:Event 1D CIO TRUE",0,0,0);
            }
          }
        }




        break; /* Come out of switch and return SUCCESS */

      case T_rrc_IntraFreqEvent_r4_e1e:
        event_type = L1_INTRA_FREQ_EVENT_1E;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store the threshold used frequency */
        l1_intra_freq_event_crit_ptr[event_count].freq_thresh = (int16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1e->thresholdUsedFrequency;

        /* Store triggering condition 2 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1e->
          triggeringCondition);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        //l1_intra_freq_event_crit_ptr[event_count].delta_rscp) = FALSE;

        if((NULL != event_1e_ptr) && (event_1e_ptr->n > event_count))
        {
          /*l1_intra_freq_event_crit_ptr[event_count].delta_rscp) = TRUE;
          l1_intra_freq_event_crit_ptr[event_count].delta_rscp =
            (int16) event_1e_ptr->value; */
          l1_intra_freq_event_crit_ptr[event_count].freq_thresh += event_1e_ptr->elem[event_count];          
        }

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_r4_e1f:
        event_type = L1_INTRA_FREQ_EVENT_1F;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store the threshold used frequency */
        l1_intra_freq_event_crit_ptr[event_count].freq_thresh = (int16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.
          e1f->thresholdUsedFrequency;

        /* Store triggering condition 1 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_1(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1f->
          triggeringCondition);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;


        //l1_intra_freq_event_crit_ptr[event_count].delta_rscp_present = FALSE;
        if((NULL != event_1f_ptr) && (event_1f_ptr->n > event_count))
        {
          /*l1_intra_freq_event_crit_ptr[event_count].delta_rscp_present = TRUE;
          l1_intra_freq_event_crit_ptr[event_count].delta_rscp =
            (int16) event_1f_ptr->value; */

          l1_intra_freq_event_crit_ptr[event_count].freq_thresh += event_1f_ptr->elem[event_count];
        }

        break; /* Come out of switch  */


      default:
        MSG_LOW("Invalid event type",0,0,0);
    } /* End of switch */

    /* Now store hsyterisis */
    l1_intra_freq_event_crit_ptr[event_count].hyst = (uint16)
      rrc_intra_freq_event_criteria_list_ptr->elem[idx].hysteresis;

    /* Now store timeToTrigger */

    l1_intra_freq_event_crit_ptr[event_count].time_to_trig =
      RRCMEAS_RET_TIME_TO_TRIGGER(rrc_intra_freq_event_criteria_list_ptr->elem[idx].timeToTrigger);

    /* Now store reporting cell status which is optional */
    /* Initialize Cell status information to FALSE */
    l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status_incl = FALSE;


    if (RRC_MSG_LIST_BITMASK_IE(rrc_intra_freq_event_criteria_list_ptr,
      rrc_IntraFreqEventCriteria_r4,reportingCellStatus) )
    {
      MSG_LOW("Reporting cell status present", 0,0,0);

      /* Call a function which stores all the information. */
      if ( rrcmeas_fill_no_of_reporting_cells(
        & rrc_intra_freq_event_criteria_list_ptr->elem[idx].reportingCellStatus,
        & l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status) == SUCCESS )
      {
        l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status_incl = TRUE;
      }
    } /* End of rrc_IntraFreqEventCriteria_reportingCellStatus_present present */


    /* Now increment the event count and the ptr to next value */
    event_count++;
    idx++;

    if ( (event_count == L1_INTRA_FREQ_MAX_NUM_EVENT) &&
      (rrc_intra_freq_event_criteria_list_ptr->n > idx) )
    {
      break; /* Come out of while */
    }

  } /* End of while intra_freq_event_criteria_list_ptr != NULL */

  return event_count;


} /* End of function */


/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_INTRAFREQ_R5

DESCRIPTION

 Processed Intra Freq Meas in Rel5 Meas Ctrl Message

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/
uecomdef_status_e_type rrcmeas_process_intrafreq_r5
(
  rrc_cmd_type* cmd_ptr,
  uint8 transaction_id
)
{
  /* Stores Meas parameters to be sent to L1 */
  l1_meas_ctrl_parm_struct_type *l1_mcm = rrc_malloc(sizeof(l1_meas_ctrl_parm_struct_type));

  /* Meas Validity */
  meas_validity_enum_type meas_validity = NOT_PRESENT;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  rrcmeas_layer_e_type primary_meas_type = INTRA_FREQ;

  rrc_MeasurementControl_r4_IEs* rrc_mcm_ptr = NULL;

  rrc_DL_DCCH_Message* dcch_msg_ptr = NULL;

  rrc_MeasurementControl_v590ext_IEs* mcm_590_ext_ptr = NULL;

  uint8 cell_count = 0;

  boolean addtl_meas_validation = FALSE;

  uint8 alloc_idx = MAXIMUM_TRANSACTIONS;
  /* Store the message */
  dcch_msg_ptr = (rrc_DL_DCCH_Message *)cmd_ptr->cmd.
    downlink_sdu_ind.decoded_msg;

  /* Store actual mcm ptr in a local variable */
  rrc_mcm_ptr = &dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.r4.measurementControl_r4;

  if ((dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
      criticalExtensions.u.r4.m.v4d0NonCriticalExtensionsPresent) &&
      (dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
      criticalExtensions.u.r4.v4d0NonCriticalExtensions.m.v590NonCriticalExtensionsPresent))
  {
    mcm_590_ext_ptr = &dcch_msg_ptr->message.u.measurementControl.u.later_than_r3.
      criticalExtensions.u.r4.v4d0NonCriticalExtensions.v590NonCriticalExtensions.measurementControl_v590ext;
  }

  /* Set trans Id in var trans_id */
  trans_id = l1_mcm->trans_id = transaction_id;

  /* Make Compressed Mode Status Information as invalid so that L1 is O.K. */
  l1_mcm->dpch_cm_status_incl = FALSE;
  /* Set Compressed Mode Information */
  if ((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r4_IEs,dpch_CompressedModeStatusInfo)) &&
    (rrc_mcm_ptr->dpch_CompressedModeStatusInfo.tgp_SequenceShortList.n != 0))
  {

    if (rrcmeas_process_compressed_mode_status(&rrc_mcm_ptr->dpch_CompressedModeStatusInfo,
      &l1_mcm->cm_status_info) == FAILURE)
    {
      /* Send Meas Ctrl Failure Message */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;

    }
    /* Set compressed Mode as TRUE */
    l1_mcm->dpch_cm_status_incl = TRUE;

  } /* End of if of compressed mode processing */

  ///***************************

  /* Store MCM contents in a Local Ptr */
  /* Assign default value to Primary Meas Type */
  primary_meas_type = INTRA_FREQ;

  /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

  switch ( rrc_mcm_ptr->measurementCommand.t )
  {
    case T_rrc_MeasurementCommand_r4_setup:

      /* Check if rpt mode present */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r4_IEs,measurementReportingMode))
      {
        MSG_LOW("Reporting Mode present", 0,0,0);

        /* Store reporting mode to TRUE */
        l1_mcm->rpt_mode_incl = TRUE;

        l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
          rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

      }
      else
      {
        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
        rrc_free(l1_mcm);
        return FAILURE;
      }


      /* Set command type in L1 struct */
      l1_mcm->meas_cmd = L1_MEAS_SETUP;

      /* Store meas type */
      l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

      l1_mcm->meas_object_info_included = TRUE;

      /* Check if meas quantity not present */
     /* Store Meas Quantity */
      if (!((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
        intraFrequencyMeasurement,
        rrc_IntraFrequencyMeasurement_r4,intraFreqMeasQuantity))  &&
        (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
        intraFrequencyMeasurement,rrc_IntraFrequencyMeasurement_r4,reportCriteria)) &&
        (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
        intraFrequencyMeasurement,
        rrc_IntraFrequencyMeasurement_r4,intraFreqReportingQuantity))))
      {
        WRRC_MSG0_ERROR("Mandatory parameter for SETUP missing");
        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
        rrc_free(l1_mcm);
        return FAILURE;
      }

    if((RRC_CHECK_COMMON_MSG_TYPE(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
      reportCriteria,rrc_IntraFreqReportCriteria_r4_intraFreqReportingCriteria)) &&
      !(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
      reportCriteria.u.intraFreqReportingCriteria,
      rrc_IntraFreqReportingCriteria_r4,eventCriteriaList)))              
    {
       WRRC_MSG0_ERROR("event criteria for SETUP missing");
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;
    }

    /* Fill intra-freq meas quantity, meas validity, cell list, cell info */
    if ( (rrcmeas_fill_common_mcm_intra_f_info_r5(
      rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement, l1_mcm,
      mcm_590_ext_ptr) == RRCMEAS_FAIL))

    {
      rrc_free(l1_mcm);
      return FAILURE;
    }
    /* Process Additional Meas */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r4_IEs,additionalMeasurementList))
    {
      /* Call fn which makes check for additional measurements */
      if (rrcmeas_validate_additional_meas(&rrc_mcm_ptr->additionalMeasurementList, transaction_id, &primary_meas_type,
        rrc_mcm_ptr->measurementIdentity) == FALSE)
      {
        /* Called function has already sent Meas Ctrl Failure */
        /* Retain the old CELL_INFO_LIST */
        WCDMA_MEMCPY(intra_freq_cell_list, 
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                     intra_freq_cell_list_temp,
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);
        rrc_free(l1_mcm);
        return FAILURE;
      }

      /* This means additional meas has been successfully validated */
      addtl_meas_validation = TRUE;

    } /* End of if of Additional Meas Present */

    if (rrcmeas_check_mcm_for_setup_modify_additional(
      addtl_meas_validation, INTRA_FREQ, rrc_mcm_ptr->measurementIdentity,
        &rrc_mcm_ptr->additionalMeasurementList) == FALSE)
    {

      rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
      rrc_free(l1_mcm);
      return FAILURE;

    }


    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r4,measurementValidity))
    {
      /* Set it to CELL_DCH */
      meas_validity = STATE_DCH;
    }
    /* Time to store the Meas Id, validty, rpt criteria in RRC DB */
    if (rrcmeas_config_intra_freq_db(l1_mcm,meas_validity) == FALSE)
    {
      rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
      rrc_free(l1_mcm);
      return FAILURE;

    }

    /* If we reached this stage, that means Meas Ctrl Msg is valid */

    /* Check if Additional Meas has been validated successfully. */
    /* If yes, then store all additional meas in RRC DB */
    if (addtl_meas_validation == TRUE)
    {
      rrcmeas_set_additional_meas_in_db(&primary_meas_type, &rrc_mcm_ptr->additionalMeasurementList,
        rrc_mcm_ptr->measurementIdentity);
    }

    /* Time to store this in Accepted transaction list after break */

    break; /* Come out of switch */


  case T_rrc_MeasurementCommand_r4_modify:
    /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r4_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);
    }
    else
    {
      /* Store reporting mode to FALSE */
      l1_mcm->rpt_mode_incl = FALSE;
    }

    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_MODIFY;

    /* Set meas type to Intra-freq Meas */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.modify,
        rrc_MeasurementCommand_r4_modify,measurementType)))
    {
      l1_mcm->meas_object_info_included = FALSE;
    }
    else
    {
      l1_mcm->meas_object_info_included = TRUE;

      /* Fill intra-freq meas quantity, meas validity, cell list, cell info */
      if ((rrcmeas_fill_common_mcm_intra_f_info_r5(
        rrc_mcm_ptr->measurementCommand.u.modify->measurementType.u.intraFrequencyMeasurement,l1_mcm, mcm_590_ext_ptr) == RRCMEAS_FAIL))
      {
        rrc_free(l1_mcm);
        return FAILURE;
      }

    } /* End of else of Meas Type Present */

        /* Process Additional Meas */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r4_IEs,additionalMeasurementList))
    {
      /* Call fn which makes check for additional measurements */
      if (rrcmeas_validate_additional_meas(&rrc_mcm_ptr->additionalMeasurementList, transaction_id, &primary_meas_type,
        rrc_mcm_ptr->measurementIdentity) == FALSE)
      {
        /* Called function has already sent Meas Ctrl Failure */
        /* Retain the old CELL_INFO_LIST */
        WCDMA_MEMCPY(intra_freq_cell_list, 
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                     intra_freq_cell_list_temp,
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);
        rrc_free(l1_mcm);
        return FAILURE;
      }

      /* This means additional meas has been successfully validated */
      addtl_meas_validation = TRUE;

      if (rrcmeas_check_mcm_for_setup_modify_additional(
        addtl_meas_validation, INTRA_FREQ, rrc_mcm_ptr->measurementIdentity,
          &rrc_mcm_ptr->additionalMeasurementList) == FALSE)
      {
        rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);

        rrc_free(l1_mcm);
        return FAILURE;

      }
    } /* End of if of Additional Meas Present */

    if ((l1_mcm->meas_object_info_included == TRUE) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.modify->measurementType.u.intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r4,measurementValidity)))

    {
      /* No need to check value as by default validity is CELL_DCH and if it is not CELL_DCH,
      then assume it to be CELL_DCH so that it could be resumed on next trans to CELL_DCH */
      meas_validity = STATE_DCH;
    }

    if (rrcmeas_config_intra_freq_db(l1_mcm, meas_validity) == FALSE)
    {
      rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
      rrc_free(l1_mcm);
      return FAILURE;

    }

    /* If we reached this stage, that means Meas Ctrl Msg is valid */

    /* Check if Additional Meas has been validated successfully. */
    /* If yes, then store all additional meas in RRC DB */
    if (addtl_meas_validation == TRUE)
    {
      rrcmeas_set_additional_meas_in_db(&primary_meas_type, &rrc_mcm_ptr->additionalMeasurementList,
        rrc_mcm_ptr->measurementIdentity);
    }


    break; /* Come out of switch */

  case T_rrc_MeasurementCommand_r4_release:
    /* With release meas, additional meas should not be present */
    /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r4_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

    }
    else
    {
      /* Store reporting mode to FALSE */
      l1_mcm->rpt_mode_incl = FALSE;
    }

    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_RELEASE;

    /* Store meas type */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    /* Delete Meas Id from Intra Freq Meas Id List */
    rrcmeas_delete_meas(&l1_mcm->meas_id);

    /* Delete additional meas */
    rrcmeas_delete_addtl_meas(&l1_mcm->meas_id);

    break;

  default:
    rrc_free(l1_mcm);
    return FAILURE;

  } /* End of switch */
  alloc_idx = rrcmeas_get_int_trans_index_for_trans_id(transaction_id);
  l1_mcm->trans_id = alloc_idx;
  /* Print first 5 elements of the list for debugging purposes */
  for (cell_count = 0; cell_count < (L1_MAX_CELL_MEAS - 20); cell_count++)
  {
    MSG_MED("IntraF Element=%d,Pos=%d,psc=%d", cell_count,
      intra_freq_cell_list[PRI_FREQ][cell_count].cell_position,
      intra_freq_cell_list[PRI_FREQ][cell_count].psc);
  }

  rrcmeas_send_l1_cmd(NULL, l1_mcm, NULL, L1_MEAS_CTRL_PARMS);

  rrc_free(l1_mcm);
  return SUCCESS;

  ///***************************

}

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_POS_MCM_R5

DESCRIPTION

 This function processes the Positioning Measurement Control Message and
 determines if it is a A-GPS or Cell Id or OTDOA Message. Depending upon that
 it configures either LSM or L1 with measurement parameters

DEPENDENCIES

 None

RETURN VALUE

 FAILURE:
 SUCCESS:

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_process_pos_mcm_r5
(
  void* msg_ptr,
  pos_info_struct_type* pos_info_ptr,
  uint8 meas_ctrl_tr_id
)
{

  /* Check if it is a Release */
  if (pos_info_ptr->pos_meas_cmd == RRC_MEAS_DELETE)
  {
    if (rrcgps_process_mcm_r5(msg_ptr, pos_info_ptr, meas_ctrl_tr_id) == SUCCESS)
      return SUCCESS;
    else
      return FAILURE;
  }

  /* Now route it */
  switch(pos_info_ptr->pos_method_type)
  {
  case RRC_GPS:
  case RRC_OTDOAorGPS:
    if (rrcgps_process_mcm_r5(msg_ptr, pos_info_ptr, meas_ctrl_tr_id) == SUCCESS)
      return SUCCESS;
    else
      return FAILURE;

  default:
    /* Not possible */
    break;


  } /* End of switch */
  return FAILURE;
}
#endif /* FEATURE_CGPS_UMTS_CP_WCDMA  */





/*===========================================================================

FUNCTION   rrcmeas_process_mcm_r6

DESCRIPTION

    This function processed the Release 6 Meas Ctrl Message

DEPENDENCIES

    None

RETURN VALUE
   Void


SIDE EFFECTS

    None

===========================================================================*/

void rrcmeas_process_mcm_r6
(
  rrc_cmd_type *cmd_ptr,
  uint8 meas_ctrl_tr_id
)
{
  rrc_MeasurementControl_r6_IEs* mcm_ptr = NULL;

  rrc_DL_DCCH_Message* dcch_msg_ptr = NULL;

  /* Local var to store meas variable */
  rrcmeas_layer_e_type meas_owner;

  /* To store OC SET Status */
  rrcllc_oc_set_status_e_type oc_set_state;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  /* Local Variable to store meas id */
  uint32 meas_id;
  
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
 pos_info_struct_type pos_info;
#endif

  /* Store the message. No need to check again */
  dcch_msg_ptr = (rrc_DL_DCCH_Message *)cmd_ptr->cmd.
    downlink_sdu_ind.decoded_msg;

  /* Store actual mcm ptr in a local variable */
  mcm_ptr = &dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.later_than_r4.criticalExtensions.u.r6.measurementControl_r6;

  meas_id = mcm_ptr->measurementIdentity;

  /* Retrieve the Meas Owner */
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  meas_owner = rrcmeas_retrieve_meas_owner_r6(&mcm_ptr->measurementCommand,
    meas_id, &pos_info);
#else
  meas_owner = rrcmeas_retrieve_meas_owner_r6(&mcm_ptr->measurementCommand,
    meas_id);
#endif

  /* Get OC status */
  oc_set_state = rrcllc_get_ordered_config_status();

  MSG_HIGH("REL6: meas id %d, meas owner %d, oc_state %d",meas_id, meas_owner, oc_set_state);

  if ((((meas_owner == INTRA_FREQ) || (meas_owner == INTERNAL_MEAS)|| (meas_owner == INTER_FREQ) ||
    (meas_owner == INTER_SYS)) && (rrcmeas_current_substate != RRCMEAS_CELL_DCH))
    || ((oc_set_state == OC_SET_FOR_DCH_CELL_PCH_TRANS) || (oc_set_state == OC_SET_FOR_DCH_URA_PCH_TRANS)))
  {
    return;
  }
  /* Static Analysis tool */
  if((meas_owner != UNKNOWN_MEAS) && (meas_owner != NOT_EXIST))
  {
    rrcmeas_check_meas_id_used_for_different_meas_type(meas_owner, meas_id);
  }
  if (meas_owner == UNKNOWN_MEAS)
  {
    /* Send Meas Ctrl Failure Message */

    rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

    /* Set error t */
    rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

    if (pos_meas_failure == TRUE)
    {
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
      pos_meas_failure = FALSE;
    }

#endif

    /* Send MCF msg to UTRAN */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

    return;
  }

  if (meas_owner == NOT_EXIST)
  {
    if(mcm_ptr->measurementCommand.t != T_rrc_MeasurementCommand_r6_release)
    {
      /* Send Meas Ctrl Failure Message */
  
      rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;
  
      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
  
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  
      if (pos_meas_failure == TRUE)
      {
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
        pos_meas_failure = FALSE;
      }
  
#endif
  
      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
    }
    else
    {
      WRRC_MSG0_HIGH("Ignore MCM release for an nonexistent measurement, do not send MCM failure");
    }
    return;
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == INTRA_FREQ)
  {
    if (rrcmeas_process_intrafreq_r6(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      return;
    }
    else
    {
      return;
    }
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == INTER_FREQ)
  {
    if (rrcifreq_process_mcm_r6(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if((!process_interfreq_interrat_meas_rel7) && (!process_interfreq_uei_meas_rel7))
      {
        return;
      }
      return;
    }
    else
    {
      return;
    }
  }
  else if (meas_owner == MAC_MEAS)
  {
    if (rrctvm_process_traffic_vol_info_r6(cmd_ptr, meas_ctrl_tr_id) == TVM_SUCCESS)
    {
      return;
    }
    else
    {

      return;
    }
  }

  else if (meas_owner == INTER_SYS)
  {
    /* First check if dual mode is enabled */
    if (rrcmcm_is_dualmode_enabled() == FALSE)
    {
      /* Send Meas Ctrl Failure Message */

      rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      return;
    }

    if (rrcirat_process_mcm_r6(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if(!process_interfreq_interrat_meas_rel7)
      {
        return;
      }
      return;
    }
    else
    {
      return;
    }
  }

  else if (meas_owner == INTERNAL_MEAS)
  {
    if (rrcueim_process_mcm_r6(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if((!process_interfreq_interrat_meas_rel7) && (!process_interfreq_uei_meas_rel7))
      {
        return;
      }
      return;
    }
    else
    {
      return;
    }
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == QUALITY_MEAS)
  {
    if (rrcqm_process_mcm_r6(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      return;
    }
    else
    {
      return;
    }
  }
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  else if ( meas_owner ==  POSITION_MEAS)
  {
    if (rrcmeas_process_pos_mcm_r6(cmd_ptr->cmd.
      downlink_sdu_ind.decoded_msg, &pos_info, meas_ctrl_tr_id) == SUCCESS)
    {
      MSG_LOW("POS: MCM successfully processed",0,0,0);
    }
    else
    {
      MSG_LOW("POS: MCM not processed successfully",0,0,0);
    }
    return;
  } /* End of if of Positioning Measurements */
#endif
  else
  {
    /* Set transaction ID */

    rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

    /* Set error t */
    rrcmeas_mcf.error_choice =
      T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

    /* Send RRC Meas Ctrl Failure msg to UTRAN */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
  }

}

/*===========================================================================

FUNCTION   RRCMEAS_RETRIEVE_MEAS_OWNER_R6

DESCRIPTION

 Finds the owner of measurement identity given in a MCM Rel 6 Msg

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/

rrcmeas_layer_e_type rrcmeas_retrieve_meas_owner_r6
(
rrc_MeasurementCommand_r6* mcm_ptr,
uint32 meas_id
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
,pos_info_struct_type* pos_info_ptr
#endif
)
{
  uint8 count = 0;

  boolean meas_found = FALSE;
  /* First find if Meas is Setup/Modify/Delete */
  switch(mcm_ptr->t)
  {
  case T_rrc_MeasurementCommand_r6_setup:
    WRRC_MSG1_HIGH("REL6: MCM Setup: Meas ==> %d",mcm_ptr->u.setup->t);

    if (mcm_ptr->u.setup->t ==
      T_rrc_MeasurementType_r6_trafficVolumeMeasurement)
    {
      return MAC_MEAS;
    }
    else
    {
      /* Find the actual L1 owner */

      if (mcm_ptr->u.setup->t ==
          T_rrc_MeasurementType_r6_intraFrequencyMeasurement)
      {
        return INTRA_FREQ;
      }
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r6_interRATMeasurement)
      {
        return INTER_SYS;
      }

      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r6_interFrequencyMeasurement)
      {
        return INTER_FREQ;
      }
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r6_ue_InternalMeasurement)
      {
        return INTERNAL_MEAS;
      }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r6_up_Measurement)
      {
        /* Also check in reporting quantity what type of meas is that */
        if ((mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.
          positioningMethod == rrc_PositioningMethod_otdoa) ||
          (mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.
          positioningMethod == rrc_PositioningMethod_cellID))
        {
          WRRC_MSG1_ERROR("PosMethod=%d unsupported 0/1/2/3 OTD/G/Both/Id",
            mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.positioningMethod);
          return UNKNOWN_MEAS;
        }
        /* Store position method and pos cmd */
        pos_info_ptr->pos_meas_cmd = RRC_MEAS_SETUP;
        pos_info_ptr->pos_method_type = RET_POS_METHOD
          (mcm_ptr->u.setup->u.up_Measurement->
          ue_positioning_ReportingQuantity.positioningMethod);

        return POSITION_MEAS;
      }
#endif

      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r6_qualityMeasurement)
      {
        return QUALITY_MEAS;
      }
      else
      {
        /* Else some other Meas */
        return UNKNOWN_MEAS;
      }
    }

  case T_rrc_MeasurementCommand_r6_modify:
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(mcm_ptr->u.modify,
      rrc_MeasurementCommand_r6_modify,measurementType))
    {
      WRRC_MSG1_HIGH("MCM:Modify, Meas Type included %d", mcm_ptr->u.modify->measurementType.t);

      if ( mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r6_trafficVolumeMeasurement)
      {
        for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
        {
          if (tvm_meas_id_list[count].meas_id == meas_id)
          {
            return MAC_MEAS;
          } /* End of if of meas_identity found */

        } /* End of for loop  */

        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      } /* End of if of Traffic Volume Meas */

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r6_interRATMeasurement)
      {
        for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
        {
          if (inter_rat_meas_id_list[count].meas_id == meas_id)
          {
            return INTER_SYS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r6_ue_InternalMeasurement)
      {
        for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
        {
          if (ueim_meas_id_list[count].meas_id == meas_id)
          {
            return INTERNAL_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r6_interFrequencyMeasurement)
      {
        for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
        {
          if (inter_freq_meas_id_list[count].meas_id == meas_id)
          {
            return INTER_FREQ;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r6_intraFrequencyMeasurement)
      {
        for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
        {
          if (intra_freq_meas_id_list[count].meas_id == meas_id)
          {
            return INTRA_FREQ;
          }

        } /* End of for loop */
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }

      } /* End of else if */

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      else if (mcm_ptr->u.modify->
        measurementType.t ==
        T_rrc_MeasurementType_r6_up_Measurement)
      {
        for ( count = 0; count < MAX_POS_MEAS; count++ )
        {
          if (pos_meas_id_list[count].meas_id == meas_id)
          {
            /* Store position method and pos cmd */
            pos_info_ptr->pos_meas_cmd = RRC_MEAS_MODIFY;
            pos_info_ptr->pos_method_type =
              RET_POS_METHOD(mcm_ptr->u.modify->measurementType.u.up_Measurement->
              ue_positioning_ReportingQuantity.positioningMethod);

            return POSITION_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
#endif

      else if (mcm_ptr->u.modify->
        measurementType.t ==
        T_rrc_MeasurementType_r6_qualityMeasurement)
      {
        for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
        {
          if (quality_meas_id_list[count].meas_id == meas_id)
          {
            return QUALITY_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
      else
      {
        return UNKNOWN_MEAS;
      }

    } /* End of if of modify  rrc_measurementType) */
    else
    { /* Since Meas Type is not given. It must exist at UE.
      If not then send an error msg indicating
      unsupported measurement */

      /* First search in L1 Measurement ID List */

      for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
      {
        if (intra_freq_meas_id_list[count].meas_id == meas_id)
        {
          return INTRA_FREQ;
        }

      } /* End of for loop */

      /* Search in Traffic Volume List */

      for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
      {
        if (tvm_meas_id_list[count].meas_id == meas_id)
        {
          return MAC_MEAS;
        } /* End of if of meas_identity found */

      } /* End of for loop */


      for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
      {
        if (inter_rat_meas_id_list[count].meas_id == meas_id)
        {
          return INTER_SYS;
        }

      }
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      for ( count = 0; count < MAX_POS_MEAS; count++ )
      {
        if (pos_meas_id_list[count].meas_id == meas_id)
        {
          pos_info_ptr->pos_meas_cmd = RRC_MEAS_MODIFY;
          pos_info_ptr->pos_method_type = pos_meas_id_list[count].pos_method_type;
          return POSITION_MEAS;
        }

      }
#endif
      for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
      {
        if (inter_freq_meas_id_list[count].meas_id == meas_id)
        {
          return INTER_FREQ;
        }
      }

      for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
      {
        if (ueim_meas_id_list[count].meas_id == meas_id)
        {
          return INTERNAL_MEAS;
        }

      }
      for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
      {
        if (quality_meas_id_list[count].meas_id == meas_id)
        {
          return QUALITY_MEAS;
        }
      }
      WRRC_MSG1_ERROR("Modify: Meas Id %d not present in UE",meas_id);
      return UNKNOWN_MEAS;

    } /* End of else of meas_type not present */


  case T_rrc_MeasurementCommand_r6_release:

     WRRC_MSG0_HIGH("Rel 6: MCM Release");
    /* First search in L1 Measurement ID List */

    for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
    {
      if (intra_freq_meas_id_list[count].meas_id == meas_id)
      {
        return INTRA_FREQ;
      }

    } /* End of for loop */

    /* Search in Traffic Volume List */

    for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
    {
      if (tvm_meas_id_list[count].meas_id == meas_id)
      {
        return MAC_MEAS;
      } /* End of if of meas_identity found */

    } /* End of for loop */


    for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
    {
      if (inter_rat_meas_id_list[count].meas_id == meas_id)
      {
        return INTER_SYS;
      }

    }
    for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
    {
      if (inter_freq_meas_id_list[count].meas_id == meas_id)
      {
        return INTER_FREQ;
      }
    }

    for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
    {
      if (ueim_meas_id_list[count].meas_id == meas_id)
      {
        return INTERNAL_MEAS;
      }

    }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
    for ( count = 0; count < MAX_POS_MEAS; count++ )
    {
      if (pos_meas_id_list[count].meas_id == meas_id)
      {
        pos_info_ptr->pos_meas_cmd = RRC_MEAS_DELETE;
        return POSITION_MEAS;
      }

    }
#endif

    for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
    {
      if (quality_meas_id_list[count].meas_id == meas_id)
      {
        return QUALITY_MEAS;
      }
    }

    WRRC_MSG0_ERROR("MCM:Release: Meas not present in UE");
    return NOT_EXIST;


  default:
    return UNKNOWN_MEAS;

  } /* End of switch */

}

/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_INTRAFREQ_R6

DESCRIPTION

 Processed Intra Freq Meas in Rel6 Meas Ctrl Message

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/
uecomdef_status_e_type rrcmeas_process_intrafreq_r6
(
  rrc_cmd_type* cmd_ptr,
  uint8 transaction_id
)
{
  /* Stores Meas parameters to be sent to L1 */
  l1_meas_ctrl_parm_struct_type *l1_mcm = rrc_malloc(sizeof(l1_meas_ctrl_parm_struct_type));

  /* Meas Validity */
  meas_validity_enum_type meas_validity = NOT_PRESENT;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  rrcmeas_layer_e_type primary_meas_type = INTRA_FREQ;

  rrc_MeasurementControl_r6_IEs* rrc_mcm_ptr = NULL;

  rrc_IntraFreqReportingCriteria_1b_r5 *intraFreqReportingCriteria_1b_r5_ptr = NULL;

  rrc_DL_DCCH_Message* dcch_msg_ptr = NULL;

  uint8 cell_count = 0;

  boolean addtl_meas_validation = FALSE;

  uint8 alloc_idx = MAXIMUM_TRANSACTIONS;

  /* Store the message */
  dcch_msg_ptr = (rrc_DL_DCCH_Message *)cmd_ptr->cmd.
    downlink_sdu_ind.decoded_msg;

  /* Store actual mcm ptr in a local variable */
  rrc_mcm_ptr = &dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.later_than_r4.criticalExtensions.u.r6.measurementControl_r6;

  if((dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.later_than_r4.criticalExtensions.u.r6.m.
    v6a0NonCriticalExtensionsPresent) && (dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.later_than_r4.criticalExtensions.u.r6.
    v6a0NonCriticalExtensions.measurementControl_v6a0ext.m.
    intraFreqReportingCriteria_1b_r5Present))
  {
    intraFreqReportingCriteria_1b_r5_ptr = &dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.later_than_r4.criticalExtensions.u.r6.
    v6a0NonCriticalExtensions.measurementControl_v6a0ext.intraFreqReportingCriteria_1b_r5;
  }

  /* Set trans Id in var trans_id */
  trans_id = l1_mcm->trans_id = transaction_id;

  /* Make Compressed Mode Status Information as invalid so that L1 is O.K. */
  l1_mcm->dpch_cm_status_incl = FALSE;
  /* Set Compressed Mode Information */
  if ((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r6_IEs,
    dpch_CompressedModeStatusInfo)) &&
    (rrc_mcm_ptr->dpch_CompressedModeStatusInfo.tgp_SequenceShortList.n != 0))
  {

    if (rrcmeas_process_compressed_mode_status(&rrc_mcm_ptr->dpch_CompressedModeStatusInfo,
      &l1_mcm->cm_status_info) == FAILURE)
    {
      /* Send Meas Ctrl Failure Message */

      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;

    }
    /* Set compressed Mode as TRUE */
    l1_mcm->dpch_cm_status_incl = TRUE;

  } /* End of if of compressed mode processing */

  ///***************************

  /* Store MCM contents in a Local Ptr */
  /* Assign default value to Primary Meas Type */
  primary_meas_type = INTRA_FREQ;

  /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

  switch ( rrc_mcm_ptr->measurementCommand.t )
  {
  case T_rrc_MeasurementCommand_r6_setup:

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r6_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

    }
    else
    {
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;
    }


    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_SETUP;

    /* Store meas type */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    l1_mcm->meas_object_info_included = TRUE;

    /* Check if meas quantity not present */
    /* Store Meas Quantity */
    if (!((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
      intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r6,intraFreqMeasQuantity)) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
      intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r6,intraFreqReportingQuantity))))
    {
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;

    }

    if((RRC_CHECK_COMMON_MSG_TYPE(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
      reportCriteria,rrc_IntraFreqReportCriteria_r6_intraFreqReportingCriteria) )&&
      !(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
      reportCriteria.u.intraFreqReportingCriteria,
      rrc_IntraFreqReportingCriteria_r6,eventCriteriaList)))              
    {
       WRRC_MSG0_ERROR("event criteria for SETUP missing");
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;
    }

    /* Fill intra-freq meas quantity, meas validity, cell list, cell info */
    if ( (rrcmeas_fill_common_mcm_intra_f_info_r6(
      rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement, 
      l1_mcm, intraFreqReportingCriteria_1b_r5_ptr)
      == RRCMEAS_FAIL))

    {
      rrc_free(l1_mcm);
      return FAILURE;
    }
    /* Process Additional Meas */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r6_IEs,additionalMeasurementList))
    {
      /* Call fn which makes check for additional measurements */
      if (rrcmeas_validate_additional_meas(&rrc_mcm_ptr->additionalMeasurementList, transaction_id, &primary_meas_type,
        rrc_mcm_ptr->measurementIdentity) == FALSE)
      {
        /* Called function has already sent Meas Ctrl Failure */
        /* Retain the old CELL_INFO_LIST */
        WCDMA_MEMCPY(intra_freq_cell_list, 
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                     intra_freq_cell_list_temp,
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);
        rrc_free(l1_mcm);
        return FAILURE;
      }

      /* This means additional meas has been successfully validated */
      addtl_meas_validation = TRUE;

    } /* End of if of Additional Meas Present */

    if (rrcmeas_check_mcm_for_setup_modify_additional(
      addtl_meas_validation, INTRA_FREQ, rrc_mcm_ptr->measurementIdentity,
        &rrc_mcm_ptr->additionalMeasurementList) == FALSE)
    {
      rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);

      rrc_free(l1_mcm);
      return FAILURE;

    }


    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r6,measurementValidity))
    {
      /* Set it to CELL_DCH */
      meas_validity = STATE_DCH;
    }
    /* Time to store the Meas Id, validty, rpt criteria in RRC DB */
    if (rrcmeas_config_intra_freq_db(l1_mcm,meas_validity) == FALSE)
    {
      /* Retain the old CELL_INFO_LIST */
      WCDMA_MEMCPY(intra_freq_cell_list, 
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                   intra_freq_cell_list_temp,
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);

      /* As UTRAN tried to configure more than 8 Intra Freq Meas */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_invalidConfiguration;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;

    }

    /* If we reached this stage, that means Meas Ctrl Msg is valid */

    /* Check if Additional Meas has been validated successfully. */
    /* If yes, then store all additional meas in RRC DB */
    if (addtl_meas_validation == TRUE)
    {
      rrcmeas_set_additional_meas_in_db(&primary_meas_type, &rrc_mcm_ptr->additionalMeasurementList,
        rrc_mcm_ptr->measurementIdentity);
    }

    /* Time to store this in Accepted transaction list after break */

    break; /* Come out of switch */


  case T_rrc_MeasurementCommand_r6_modify:
    /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r6_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);
    }
    else
    {
      /* Store reporting mode to FALSE */
      l1_mcm->rpt_mode_incl = FALSE;
    }

    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_MODIFY;

    /* Set meas type to Intra-freq Meas */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.modify,
        rrc_MeasurementCommand_r6_modify,measurementType)))
    {
      l1_mcm->meas_object_info_included = FALSE;
    }
    else
    {
      l1_mcm->meas_object_info_included = TRUE;

      /* Fill intra-freq meas quantity, meas validity, cell list, cell info */
      if ((rrcmeas_fill_common_mcm_intra_f_info_r6(
        rrc_mcm_ptr->measurementCommand.u.modify->measurementType.u.intraFrequencyMeasurement,
        l1_mcm, intraFreqReportingCriteria_1b_r5_ptr) == RRCMEAS_FAIL))
      {
        rrc_free(l1_mcm);
        return FAILURE;
      }

    } /* End of else of Meas Type Present */

        /* Process Additional Meas */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r6_IEs,additionalMeasurementList))
    {
      /* Call fn which makes check for additional measurements */
      if (rrcmeas_validate_additional_meas(&rrc_mcm_ptr->additionalMeasurementList, transaction_id, &primary_meas_type,
        rrc_mcm_ptr->measurementIdentity) == FALSE)
      {
        /* Called function has already sent Meas Ctrl Failure */
        /* Retain the old CELL_INFO_LIST */
        WCDMA_MEMCPY(intra_freq_cell_list, 
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                     intra_freq_cell_list_temp,
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);
        rrc_free(l1_mcm);
        return FAILURE;
      }

      /* This means additional meas has been successfully validated */
      addtl_meas_validation = TRUE;

      if (rrcmeas_check_mcm_for_setup_modify_additional(
        addtl_meas_validation, INTRA_FREQ, rrc_mcm_ptr->measurementIdentity,
          &rrc_mcm_ptr->additionalMeasurementList) == FALSE)
      {
        rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);

        rrc_free(l1_mcm);
        return FAILURE;

      }
    } /* End of if of Additional Meas Present */

    if ((l1_mcm->meas_object_info_included == TRUE) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u
      .modify->measurementType.u.intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r6,measurementValidity)))

    {
      /* No need to check value as by default validity is CELL_DCH and if it is not CELL_DCH,
      then assume it to be CELL_DCH so that it could be resumed on next trans to CELL_DCH */
      meas_validity = STATE_DCH;
    }

    if (rrcmeas_config_intra_freq_db(l1_mcm, meas_validity) == FALSE)
    {
      rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
      rrc_free(l1_mcm);
      return FAILURE;

    }

    /* If we reached this stage, that means Meas Ctrl Msg is valid */

    /* Check if Additional Meas has been validated successfully. */
    /* If yes, then store all additional meas in RRC DB */
    if (addtl_meas_validation == TRUE)
    {
      rrcmeas_set_additional_meas_in_db(&primary_meas_type, &rrc_mcm_ptr->additionalMeasurementList,
        rrc_mcm_ptr->measurementIdentity);
    }


    break; /* Come out of switch */

  case T_rrc_MeasurementCommand_r6_release:
    /* With release meas, additional meas should not be present */
    /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r6_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

    }
    else
    {
      /* Store reporting mode to FALSE */
      l1_mcm->rpt_mode_incl = FALSE;
    }

    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_RELEASE;

    /* Store meas type */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    /* Delete Meas Id from Intra Freq Meas Id List */
    rrcmeas_delete_meas(&l1_mcm->meas_id);

    /* Delete additional meas */
    rrcmeas_delete_addtl_meas(&l1_mcm->meas_id);

    break;

  default:
    rrc_free(l1_mcm);
    return FAILURE;

  } /* End of switch */

  alloc_idx = rrcmeas_get_int_trans_index_for_trans_id(transaction_id);
  l1_mcm->trans_id = alloc_idx;

  /* Print first 5 elements of the list for debugging purposes */
  for (cell_count = 0; cell_count < (L1_MAX_CELL_MEAS - 20); cell_count++)
  {
    MSG_MED("IntraF Element=%d,Pos=%d,psc=%d", cell_count,
      intra_freq_cell_list[PRI_FREQ][cell_count].cell_position,
      intra_freq_cell_list[PRI_FREQ][cell_count].psc);
  }

  rrcmeas_send_l1_cmd(NULL, l1_mcm, NULL, L1_MEAS_CTRL_PARMS);

  rrc_free(l1_mcm);
  return SUCCESS;

  ///***************************

}

/*===========================================================================

FUNCTION  RRCMEAS_FILL_COMMON_MCM_INTRA_F_INFO_R6

DESCRIPTION

 This function fills in common Cell Info for meas setup and
 meas modify command type in a Measurement Control Message.
 The function processes Cell Info in ASN1 format and translates
 into the L1RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill common mcm info correctly
 SUCCESS: If common mcm info filled correctly

SIDE EFFECTS

 None

===========================================================================*/

rrcmeas_status_e_type rrcmeas_fill_common_mcm_intra_f_info_r6
(
rrc_IntraFrequencyMeasurement_r6* intra_f_meas_ptr,
l1_meas_ctrl_parm_struct_type *l1_mcm ,
rrc_IntraFreqReportingCriteria_1b_r5* intraFreqReportingCriteria_1b_r5_ptr
)
{

  uint16 cell_count = 0;
  uint16 freq_idx = 0;

  l1_intra_freq_meas_ctrl_struct_type* l1_intra_f_mcm_ptr = &l1_mcm->meas_object.u.intra_f;

  uint8  meas_id_idx = rrcmeas_find_meas_id_idx(l1_mcm->meas_id);

  WCDMA_MEMCPY(intra_freq_cell_list_temp, 
               sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
               intra_freq_cell_list,
               sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);

  /* Assign default values */
  l1_intra_f_mcm_ptr->meas_quan_incl = FALSE;
  l1_intra_f_mcm_ptr->meas_quan.quan_type = L1_MEAS_NONE;

  /* Assign Default value to filter coefficient 0 */
  l1_intra_f_mcm_ptr->meas_quan.filter_coef = 0;

  /* Store Meas Quantity */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr,
    rrc_IntraFrequencyMeasurement_r6,intraFreqMeasQuantity))
  {
    /* Check if meas quan is for fdd */
    if ( RRC_CHECK_COMMON_MSG_TYPE(intra_f_meas_ptr->
      intraFreqMeasQuantity.modeSpecificInfo,
      rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd ))
    {
      /* Intra freq meas quantity for FDD mode is present */
      l1_intra_f_mcm_ptr->meas_quan_incl = TRUE;

      /* So read the value of meas quantity and filter coefficient */
      l1_intra_f_mcm_ptr->meas_quan.quan_type =
        RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
        intra_f_meas_ptr->
        intraFreqMeasQuantity.modeSpecificInfo.u.fdd->intraFreqMeasQuantity_FDD);

        /* Check if rrc_IntraFreqMeasQuantity_filterCoefficient) */
   /* Store filter coefficient */
        l1_intra_f_mcm_ptr->meas_quan.filter_coef = (uint16)
          RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(intra_f_meas_ptr->
          intraFreqMeasQuantity.filterCoefficient);
      

    } /* End of if for rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd  */

  } /* End of if of intra freq meas quantity not present */

  /* Initialize no of added, removed cells to 0, cell_incl to FALSE */
  for(freq_idx = 0; freq_idx < MAX_NUM_CARR; freq_idx++)
  {
    /* Initialize no of added, removed cells to 0, cell_incl to FALSE */
    l1_intra_f_mcm_ptr->cell_list_incl[freq_idx] = FALSE;
    l1_intra_f_mcm_ptr->cell_list[freq_idx].num_cell_add = 0;
    l1_intra_f_mcm_ptr->cell_list[freq_idx].num_cell_rmv = 0;

    /* Print first few elements of the list for debugging purposes */
    for (cell_count = 0; cell_count < (L1_MAX_CELL_MEAS - 20); cell_count++)
    {
       MSG_MED("Cell list %d element is %d, psc = %d", cell_count,
       intra_freq_cell_list[freq_idx][cell_count].cell_position,
       intra_freq_cell_list[freq_idx][cell_count].psc);
    }
    cell_count = 0;
  }

  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr,
      rrc_IntraFrequencyMeasurement_r6,intraFreqCellInfoList))
  {
    if(RRCMEAS_FAIL == rrcmeas_process_mcm_intra_f_cell_info_r5(&intra_f_meas_ptr->intraFreqCellInfoList, l1_intra_f_mcm_ptr))
    {
      return RRCMEAS_FAIL;
    }
  } /* End of intra freq cell info list present */

  /* Assign default values for intra-f reporting quantity */
  l1_intra_f_mcm_ptr->intra_f_rpt_quan_incl = FALSE;

  /* Check if intra-f reporting quantity present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr, rrc_IntraFrequencyMeasurement_r6,intraFreqReportingQuantity))
  {
    if ( (rrcmeas_fill_intra_freq_rep_quan(&intra_f_meas_ptr->intraFreqReportingQuantity,
      l1_intra_f_mcm_ptr)) == SUCCESS )
      l1_intra_f_mcm_ptr->intra_f_rpt_quan_incl = TRUE;
  }

  /* Initialize rpt_mode to no change */
   l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_NO_CHANGE;

  /* Set reporting cell status to FALSE */
   l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = FALSE;
   l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[PRI_FREQ] = FALSE;
#ifdef FEATURE_WCDMA_DC_HSUPA
  /* N/W may configure modify from R9 to pre R9 
   * Configure rpt crit accordingly  */
  if(CHECK_RPT_CRIT_NOT_PRESENT(SEC_FREQ))
  {
  l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_RPT_MODE_NOT_PRESENT;
    if(meas_id_idx < MAX_INTRA_FREQ_MEAS)
    {
      intra_freq_meas_id_list[meas_id_idx].rpt_crit[SEC_FREQ] = NOT_AVAILABLE;
    }
  }
  else
  {
    l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_NO_CHANGE;   
  }


  /* Set reporting cell status to FALSE */
  l1_intra_f_mcm_ptr->rpt_cell_status_incl[SEC_FREQ] = FALSE;

  /* Set reporting crit incl to FALSE */
  l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[SEC_FREQ] = FALSE;
#endif


  /* Check report criteeria type */
  switch (intra_f_meas_ptr->reportCriteria.t)
  {
  case T_rrc_IntraFreqReportCriteria_r6_intraFreqReportingCriteria:

    /* Set rpt mode criteria */

    /* Check if Event triggered intraFreqReportingCriteria list present */

    if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.
      intraFreqReportingCriteria,
      rrc_IntraFreqReportingCriteria_r6,eventCriteriaList))
    {
      /* Set event parameters */
       l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].num_event =
        rrcmeas_fill_intra_freq_event_criteria_r6(
        intra_f_meas_ptr->reportCriteria.u.intraFreqReportingCriteria, l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].evt,
        intraFreqReportingCriteria_1b_r5_ptr);
       l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_EVENT_TRIGGER_RPT;

    } /* End of if for event criteria list present */
    else
    {
      MSG_LOW("Setting num_event to 0", 0,0,0);
      /* So set num_event in L1 structure to 0 */

       l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].num_event = 0;
    }

    break; /* Come out of switch */

  case T_rrc_IntraFreqReportCriteria_r6_periodicalReportingCriteria:

    /* Set rpt mode criteria */
     l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_PERIODIC_RPT;


    /* Set reporting cells */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria,
      rrc_PeriodicalWithReportingCellStatus,reportingCellStatus))
    {
      if (rrcmeas_fill_no_of_reporting_cells(&intra_f_meas_ptr->reportCriteria.u.
        periodicalReportingCriteria->reportingCellStatus,
        & l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ]) == SUCCESS)
      {
         l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = TRUE;
      }
    }

    l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[PRI_FREQ] = TRUE;
    /* Store reporting amount */
    l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_amount=
      RRCMEAS_RET_REPORTING_AMOUNT(
      intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->
      periodicalReportingCriteria.reportingAmount);
    

      /* Store reporting interval */
      l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_interval =
        RRCMEAS_RET_PERIODIC_REPORTING_INTERVAL
        (intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->periodicalReportingCriteria.reportingInterval);

    if (intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->
      periodicalReportingCriteria.reportingInterval == rrc_ReportingIntervalLong_ril0)
    {
        l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_interval = 250;
    }

    break; /* Come out of switch */


  case T_rrc_IntraFreqReportCriteria_r6_noReporting:

     l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_NO_RPT;

    /* Set reporting cell status to FALSE */
     l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = FALSE;

    if ((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.noReporting,
      rrc_ReportingCellStatusOpt,reportingCellStatus))  &&
      ( rrcmeas_fill_no_of_reporting_cells(&intra_f_meas_ptr->reportCriteria.u.noReporting->reportingCellStatus,
      & l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ]) == SUCCESS ))
    {
       l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = TRUE;
    }

    break;

  default:
    return RRCMEAS_FAIL;

  } /* End of switch */

  if (( l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] == TRUE) &&
    (( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_VASET) ||
    ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_MSET_NUSED_FREQ) ||
    ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_ASET_MSET_NUSED_FREQ) ||
    ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_ALL_VASET_AND_MSET_NUSED_FREQ)))
  {
    WRRC_MSG1_ERROR("Rpt Cell Status invalid %d",  l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat);
    /* Retain the old CELL_INFO_LIST */
      WCDMA_MEMCPY(intra_freq_cell_list, 
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                   intra_freq_cell_list_temp,
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);

    return RRCMEAS_FAIL;
  }

  return RRCMEAS_SUCCESS;
}

/*===========================================================================

FUNCTION     RRCMEAS_FILL_INTRA_FREQ_EVENT_CRITERIA_R6

DESCRIPTION

 This function fills in intra-freq event criteria for a Non-HCS cell when
 Cell Selection Reselection Quality Measure is RCSP or ECNO for R5 Message
 The function processes intra-ftreq event criteria Info in ASN1 format
 and translates into the L1 RRC Interface format.

DEPENDENCIES

 The passed pointers must be valid.

RETURN VALUE

 No of events.

SIDE EFFECTS

 None

===========================================================================*/

uint16 rrcmeas_fill_intra_freq_event_criteria_r6
(
rrc_IntraFreqReportingCriteria_r6  *rrc_intra_freq_reporting_criteria_ptr,
l1_intra_freq_event_crit_struct_type *l1_intra_freq_event_crit_ptr,
rrc_IntraFreqReportingCriteria_1b_r5* intraFreqReportingCriteria_1b_r5_ptr
)
{
  /* To store cell list for 1a or 1b if present */
  rrc_ForbiddenAffectCellList_r4 *forbidden_affect_cell_list_ptr = NULL;

  /* Stores ptr to passed rrc_IntraFreqEventCriteriaList */
  rrc_IntraFreqEventCriteriaList_r6  *rrc_intra_freq_event_criteria_list_ptr = NULL;

  /* Counts forbidden cell count */
  uint16 forbidden_cell_list_count = 0;

  /* To satisfy LINT as e1a, e1b values would be stored here first */
  l1_intra_freq_event_enum_type event_type;
  uint32 idx=0,idy=0;
  /* Counts no of events */
  uint16 event_count = 0;

  /* Store event crit list ptr */
  rrc_intra_freq_event_criteria_list_ptr = &rrc_intra_freq_reporting_criteria_ptr->eventCriteriaList;

  if (rrc_intra_freq_event_criteria_list_ptr->n == 0)
  {
    MSG_LOW("Intra-freq event criteria list is empty", 0,0,0);
    return event_count;
  }

  /* ReportingRange, Hystersis, W converted by L1 */
  /* Store now the first event reporting criteria value from the list */
  while ( (rrc_intra_freq_event_criteria_list_ptr->n > idx) &&
    (event_count < L1_INTRA_FREQ_MAX_NUM_EVENT) )
  {

    /* First get the event ID */
    switch ( rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.t )
    {
      case T_rrc_IntraFreqEvent_r6_e1a:
        event_type = L1_INTRA_FREQ_EVENT_1A;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store triggering condition */

        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->
          triggeringCondition);

        /* Store Reporting Range */
        l1_intra_freq_event_crit_ptr[event_count].rpt_range = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingRange;

        /* Store no of cells forbidden to affect reporting range */
        if (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->m.forbiddenAffectCellListPresent)
        {
          /* Now store the scrambling code for each cell */

          forbidden_affect_cell_list_ptr =
            &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->forbiddenAffectCellList;

         idy=0;
          while ( (forbidden_affect_cell_list_ptr->n >idy) &&
            (forbidden_cell_list_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is non-NULL and forbidden cell count hasn't exceeded
            * the maximum. So keep on counting */

            if ( forbidden_affect_cell_list_ptr->elem[idy].t ==
              T_rrc_ForbiddenAffectCell_r4_tdd )
            {
              /* Set pointer value to next */
              idy++;

              continue;

            }
            else
            {
              /* Store scrambling code */
              l1_intra_freq_event_crit_ptr->forbidden_cell_scr_code[forbidden_cell_list_count] = (uint16)
                forbidden_affect_cell_list_ptr->elem[idy].u.fdd->primaryScramblingCode;

              /* Now increment count and store ptr to next value */
              forbidden_cell_list_count++;
              idy++;


              if ( (forbidden_cell_list_count == L1_MAX_CELL_MEAS) &&
                (forbidden_affect_cell_list_ptr->n > idy) )
              {

                MSG_LOW("Cannot include all forbidden cells", 0,0,0);
                break;
              }
            } /* End of else */

          } /* End of while of forbidden_affect_cell_list_ptr != NULL */

          /* Now store the number of forbidden affect cells in l1 struct */

          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = forbidden_cell_list_count;
        } /* End of if for forbidden_affect_cell_list actually present */

        else
        { /* forbidden_affect_cell_list actually absent */
          /* Set as per L1 req */
          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = 0;
        }

        /* Now store rest of the parameters of event 1a */

        /* Store WEIGHT */

        /* Use this to verify  rrc_intra_freq_event_criteria_list_ptr   */
        l1_intra_freq_event_crit_ptr[event_count].w = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->w;

        /* Store deactivation threshold */
        l1_intra_freq_event_crit_ptr[event_count].rpt_deact_thresh =
          RRCMEAS_RET_DEACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportDeactivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingInterval);

        MSG_HIGH("1A:RptAmt %d,RptIntvl %dms,Deacthresh %d",
         l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_deact_thresh);


        break; /* Come out of switch and return SUCCESS */

      case T_rrc_IntraFreqEvent_r6_e1b:
        event_type = L1_INTRA_FREQ_EVENT_1B;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store triggering condition 1 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_1(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->triggeringCondition);

        /* Store Reporting Range */
        l1_intra_freq_event_crit_ptr[event_count].rpt_range = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->reportingRange;

        /* Initialize reporting intvl to 0 */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl = 0;

        /* Initialize no of rpts to 0 */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt = 0;

        if (intraFreqReportingCriteria_1b_r5_ptr == NULL)
        {
          MSG_LOW("Event 1B Ext absent",0,0,0);
        }
        else
        {
          /* Store reporting interval */
          l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          intraFreqReportingCriteria_1b_r5_ptr->periodicReportingInfo_1b.reportingInterval);

          l1_intra_freq_event_crit_ptr[event_count].num_rpt =
            RRCMEAS_RET_REPORTING_AMOUNT(intraFreqReportingCriteria_1b_r5_ptr->
                                       periodicReportingInfo_1b.reportingAmount);
        }

        WRRC_MSG2_HIGH("Event 1B RptIntvl %d ms, Num rpt %d",
                 l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt);

        if ( rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->m.forbiddenAffectCellListPresent)
        {
          /* Now store the scrambling code for each cell */

          forbidden_affect_cell_list_ptr =
            &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->
            forbiddenAffectCellList;

          idy=0;
          while ( (forbidden_affect_cell_list_ptr->n > idy) &&
            (forbidden_cell_list_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is non-NULL and forbidden cell count hasn't exceeded
            the maximum. So keep on counting */

            if ( forbidden_affect_cell_list_ptr->elem[idy].t ==
              T_rrc_ForbiddenAffectCell_r4_tdd )
            {
              idy++;
              continue;

            }
            else
            {
              /* Store scrambling code */
              l1_intra_freq_event_crit_ptr[event_count].
                forbidden_cell_scr_code[forbidden_cell_list_count] = (uint16)
                forbidden_affect_cell_list_ptr->elem[idy].u.fdd->primaryScramblingCode;

              /* Now increment count and store ptr to next value */
              forbidden_cell_list_count++;

              idy++;

              if ( (forbidden_cell_list_count == L1_MAX_CELL_MEAS) &&
                (forbidden_affect_cell_list_ptr->n > idy) )
              {

                MSG_LOW("Cannot include all the forbidden cells", 0,0,0);
                break;
              }
            } /* End of else */

          } /* End of while of forbidden_affect_cell_list_ptr != NULL */

          /* Now store the number of forbidden affect cells in l1 struct */

          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
            forbidden_cell_list_count;
        } /* End of if for forbidden_affect_cell_list actually present */

        else
        { /* forbidden_affect_cell_list actually absent */
          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = 0;
        }

        /* Store WEIGHT */

        l1_intra_freq_event_crit_ptr[event_count].w = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->w;

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_r6_e1c:
        event_type = L1_INTRA_FREQ_EVENT_1C;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store replacement activation threshold */

        l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh =
          RRCMEAS_RET_REPLACEMENT_ACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          replacementActivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          reportingInterval);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;

        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        MSG_HIGH("1C:RptAmt %d,RptIntvl %dms,Deacthresh %d",
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh);

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_r6_e1d:
        event_type = L1_INTRA_FREQ_EVENT_1D;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        l1_intra_freq_event_crit_ptr[event_count].evt_1d_trig_cond_incl = FALSE;

        l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl = FALSE;

        if (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1d->m.triggeringConditionPresent)
        {
          l1_intra_freq_event_crit_ptr[event_count].evt_1d_trig_cond_incl = TRUE;

          l1_intra_freq_event_crit_ptr[event_count].trig_cond =
          (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1d->
                                             triggeringCondition);
        }
        if ((rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1d->m.useCIOPresent)
          && (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1d->useCIO == TRUE))
        {
          l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl = TRUE;
        }

        break; /* Come out of switch and return SUCCESS */

      case T_rrc_IntraFreqEvent_r6_e1e:
        event_type = L1_INTRA_FREQ_EVENT_1E;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store the threshold used frequency */
        l1_intra_freq_event_crit_ptr[event_count].freq_thresh = (int16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1e->thresholdUsedFrequency;

        /* Store triggering condition 2 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1e->
          triggeringCondition);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_r6_e1f:
        event_type = L1_INTRA_FREQ_EVENT_1F;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store the threshold used frequency */
        l1_intra_freq_event_crit_ptr[event_count].freq_thresh = (int16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.
          e1f->thresholdUsedFrequency;

        /* Store triggering condition 1 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_1(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1f->
          triggeringCondition);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        break; /* Come out of switch  */

      case T_rrc_IntraFreqEvent_r6_e1j:
        event_type = L1_INTRA_FREQ_EVENT_1J;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store replacement activation threshold */

        l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh =
          RRCMEAS_RET_REPLACEMENT_ACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1j->
          replacementActivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1j->
          reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1j->
          reportingInterval);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;

        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        MSG_HIGH("1J:RptAmt %d,RptIntvl %dms,Deacthresh %d",
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh);

      
        break;

      default:
        MSG_LOW("Invalid event type",0,0,0);
    } /* End of switch */

    /* Now store hsyterisis */
    l1_intra_freq_event_crit_ptr[event_count].hyst = (uint16)
      rrc_intra_freq_event_criteria_list_ptr->elem[idx].hysteresis;

    /* Now store timeToTrigger */

    l1_intra_freq_event_crit_ptr[event_count].time_to_trig =
      RRCMEAS_RET_TIME_TO_TRIGGER(rrc_intra_freq_event_criteria_list_ptr->elem[idx].timeToTrigger);

    /* Now store reporting cell status which is optional */
    /* Initialize Cell status information to FALSE */
    l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status_incl = FALSE;


    if (RRC_MSG_LIST_BITMASK_IE(rrc_intra_freq_event_criteria_list_ptr,
      rrc_IntraFreqEventCriteria_r6,reportingCellStatus) )
    {
      MSG_LOW("Reporting cell status present", 0,0,0);

      /* Call a function which stores all the information. */
      if ( rrcmeas_fill_no_of_reporting_cells(
        & rrc_intra_freq_event_criteria_list_ptr->elem[idx].reportingCellStatus,
        & l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status) == SUCCESS )
      {
        l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status_incl = TRUE;
      }
    } /* End of rrc_IntraFreqEventCriteria_reportingCellStatus_present present */

    /* Now increment the event count and the ptr to next value */
    event_count++;
   idx++;

    if ( (event_count == L1_INTRA_FREQ_MAX_NUM_EVENT) &&
      (rrc_intra_freq_event_criteria_list_ptr->n > idx) )
    {
      break; /* Come out of while */
    }

  } /* End of while intra_freq_event_criteria_list_ptr != NULL */

  return event_count;

} /* End of function */

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_POS_MCM_R6

DESCRIPTION

 This function processes the Positioning Measurement Control Message and
 determines if it is a A-GPS or Cell Id or OTDOA Message. Depending upon that
 it configures either LSM or L1 with measurement parameters

DEPENDENCIES

 None

RETURN VALUE

 FAILURE:
 SUCCESS:

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_process_pos_mcm_r6
(
  void* msg_ptr,
  pos_info_struct_type* pos_info_ptr,
  uint8 meas_ctrl_tr_id
)
{

  /* Check if it is a Release */
  if (pos_info_ptr->pos_meas_cmd == RRC_MEAS_DELETE)
  {
    if (rrcgps_process_mcm_r6(msg_ptr, pos_info_ptr, meas_ctrl_tr_id) == SUCCESS)
      return SUCCESS;
    else
      return FAILURE;
  }

  /* Now route it */
  switch(pos_info_ptr->pos_method_type)
  {
  case RRC_GPS:
  case RRC_OTDOAorGPS:
    if (rrcgps_process_mcm_r6(msg_ptr, pos_info_ptr, meas_ctrl_tr_id) == SUCCESS)
      return SUCCESS;
    else
      return FAILURE;

  default:
    /* Not possible */
    break;


  } /* End of switch */
  return FAILURE;
}
#endif /*FEATURE_CGPS_UMTS_CP */

/*===========================================================================

FUNCTION rrcmeas_read_sib11bis

DESCRIPTION

  Reads SIB11bis from the current active serving cell for all the measurements.
  If SIB11bis information is incorrect, meas setup command is not send to L1
  and UE does not do any measurements..

DEPENDENCIES

  SIB must have been stored by the SIB procedure and SIB11 should have been read

RETURN VALUE

  Success if SIB11bis has been correctly read
  Failure if SIB11bis has not been correctly read

SIDE EFFECTS

  None

===========================================================================*/

uecomdef_status_e_type rrcmeas_read_sib11bis
(
  boolean sib18_present,
  rrc_PLMNsOfIntraFreqCellsList* tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
  rrc_MultiplePLMNsOfIntraFreqCellsList* tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr
)
{
  rrc_SysInfoType11bis *sib11bis_ptr = NULL;
  uint32 idx=0;
  rrc_MeasurementControlSysInfoExtensionAddon_r5 *sib11bis_rel5_ptr = NULL;
  rrc_NewIntraFreqCellSI_List_HCS_RSCP * intra_freq_meas_hcs_rscp_ptr = NULL;
  rrc_NewIntraFreqCellSI_List_HCS_ECN0 * intra_freq_meas_hcs_ecn0_ptr = NULL;
  rrc_NewIntraFreqCellSI_List_RSCP * intra_freq_meas_rscp_ptr = NULL;
  rrc_NewIntraFreqCellSI_List_ECN0 * intra_freq_meas_ecn0_ptr = NULL;
  rrc_MeasurementControlSysInfoExtensionAddon_r5_newIntraFrequencyCellInfoListAddon_r5 *rel5_ext_ptr = NULL;
  uint16 cell_count = 0;
  uint32 cell_position = 0;
  rrc_plmn_identity_type tmp_plmn_identity;
  rrc_plmn_identity_type selected_plmn_identity;
  rrc_int_cell_id_type  tmp_cell_id;
  tmp_plmn_identity.mcc[0] =  tmp_plmn_identity.mcc[1] = tmp_plmn_identity.mcc[2] = 0;
  tmp_plmn_identity.num_mnc_digits = 0;
  tmp_plmn_identity.mnc[0] =  tmp_plmn_identity.mnc[1] = 0;
  
  selected_plmn_identity.mcc[0] =  selected_plmn_identity.mcc[1] = selected_plmn_identity.mcc[2] = 0;
  selected_plmn_identity.num_mnc_digits = 0;
  selected_plmn_identity.mnc[0] =  selected_plmn_identity.mnc[1] = 0;
  
  if(!rrc_sibdb_is_sib11bis_present_in_srv_cell())
  {
    return FAILURE;
  }
  sib11bis_ptr = (rrc_SysInfoType11bis *)  rrc_sibdb_return_sib_for_srv_cell
    (rrc_SIB11bis);
  if(sib11bis_ptr == NULL)
  {
    return FAILURE;
  }
  if(!(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib11bis_ptr,measurementControlSysInfo)))
  {
    return FAILURE;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib11bis_ptr,measurementControlSysInfoExtensionAddon_r5))
  {
    sib11bis_rel5_ptr = &sib11bis_ptr->measurementControlSysInfoExtensionAddon_r5;
    if(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(sib11bis_rel5_ptr,
        newIntraFrequencyCellInfoListAddon_r5))
    {
      rel5_ext_ptr = &sib11bis_rel5_ptr->newIntraFrequencyCellInfoListAddon_r5;
    }
  }

  if(sib18_present == FALSE)
  {
    WRRC_MSG0_HIGH("SIB11bis: SIB18 is Absent/Ignored");
  }
  else if(rrc_ccm_get_serv_plmn_cellid(&tmp_cell_id, &selected_plmn_identity) != RRC_CELL_LOSS_NO_NEW_CELL)
  {
    WCDMA_MEMCPY(&tmp_plmn_identity, 
                 sizeof(rrc_plmn_identity_type),
                 &selected_plmn_identity, 
                 sizeof(rrc_plmn_identity_type));
  }
  else
  {
    sib18_present = FALSE;
  }
  if(sib11bis_ptr->measurementControlSysInfo.use_of_HCS.t == 
      T_rrc_MeasurementControlSysInfoExtension_use_of_HCS_hcs_used)
  {
    switch(sib11bis_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->cellSelectQualityMeasure.t)
    {
      WRRC_MSG1_HIGH("SIB11bis: cellSelectQualityMeasure is %d [1/2 : RSCP/EcNo]",sib11bis_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->cellSelectQualityMeasure.t);
      /*RSCP is choosen and HCS is used*/
      case T_rrc_MeasurementControlSysInfoExtension_cellSelectQualityMeasure_1_cpich_RSCP:
        rrcmeas_sib11->cell_sel_resel_quan_type =  L1_RSCP;
        if(!(sib11bis_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->cellSelectQualityMeasure.u.cpich_RSCP->m.newIntraFreqCellListPresent ))
        {
          return FAILURE;
        }
        rrcmeas_sib11->intra_freq_meas_info_incl = TRUE;
        intra_freq_meas_hcs_rscp_ptr = &sib11bis_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
            cellSelectQualityMeasure.u.cpich_RSCP->newIntraFreqCellList;
        if(rrcmeas_sib11->intra_f.cell_list_incl == TRUE)
        {
          cell_count = rrcmeas_sib11->intra_f.cell_list.num_cell_add;
        }
        rrcmeas_sib11->intra_f.cell_list_incl = TRUE;
        idx=0;
        while ( (intra_freq_meas_hcs_rscp_ptr->n > idx) &&
          (cell_count < L1_MAX_CELL_MEAS) )
        {
          if ( intra_freq_meas_hcs_rscp_ptr->elem[idx].cellInfo.
            modeSpecificInfo.t ==
            T_rrc_CellInfoSI_HCS_RSCP_modeSpecificInfo_tdd)
          {
            /* Nothing doing with a TDD cell. Shun it ! */
            idx++;
            
            continue;
          }
          /* Set default values for the HCS neighboring cell info if it is first cell
          * else use the info from the previous cell */
          if(cell_count == 0)
          {
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio = 0;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs = 115;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time = 0;
          }
          else
          {
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.hcs_prio;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.q_hcs;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.penalty_time;

            if(rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.penalty_time
              != 0)
            {
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.tmp_offset1 =
                rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.tmp_offset1;
            }
          }
          if (rrcmeas_fill_hcs_rscp_cell_info(&intra_freq_meas_hcs_rscp_ptr->elem[idx].
            cellInfo, &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info, ((rel5_ext_ptr != NULL) ? ((rel5_ext_ptr->n > idx) ? (&rel5_ext_ptr->elem[idx]) : NULL) : NULL)) == FAILURE)
          {
            idx++;
            continue;
          }
          /* Check if intra-freq cell ID is present */
          if (RRC_MSG_LIST_BITMASK_IE(intra_freq_meas_hcs_rscp_ptr,
            rrc_NewIntraFreqCellSI_HCS_RSCP,intraFreqCellID))
          {
            cell_position = intra_freq_meas_hcs_rscp_ptr->elem[idx].intraFreqCellID;
          } /* End of if of intra-freq cell id present */
          else
          {
            cell_position = AVAILABLE_CELL_POSITION;
          } /* End of else of intra-freq cell id not present */
          
          if ( rrcmeas_update_intra_freq_cell_list(
            &cell_position,
            &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info.pri_scr_code) == RRCMEAS_SUCCESS)
          {
            /* PSC sucessfully stored in the cell info list variable */
            /* Now store psc in the sib11 in add cell for layer1 to use psc */
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].psc =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
              cell_info.pri_scr_code;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach = TRUE;
            if(sib18_present)
            {
              rrcmeas_process_sib18_filtering(
                 tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
                 tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
                 &tmp_plmn_identity,
                 cell_count,
                 &(rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach),
                 (cell_count > 0)?rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count -1].measure_in_idle_pch_fach: TRUE);
            }

            /* Increment cell count as add cell successfully stored */
            cell_count ++;
          }
          idx++;
          if ( (cell_count == L1_MAX_CELL_MEAS) &&
            (intra_freq_meas_hcs_rscp_ptr->n > idx) )
          {
          /* If there are more new cells than can be accomodated in L1
          Cmd, print a message and hope L1 will change their capability
          sometime. Just pass the number that L1 can handle.
            */
            MSG_LOW("SIB11bis: All Intra freq cells not included",0,0,0);
            break;
          }
        }
        rrcmeas_sib11->intra_f.cell_list.num_cell_add = cell_count;
        WRRC_MSG1_HIGH("SIB11bis: Number of cells added from SIB11 and SIB11bis is %d",rrcmeas_sib11->intra_f.cell_list.num_cell_add);
        if(rrcmeas_sib11->intra_f.cell_list.num_cell_add == 0)
        {
          rrcmeas_sib11->intra_f.cell_list_incl = FALSE;
          return FAILURE;
        }
        break;

      /*ECNO is choosen and HCS is used*/
      case T_rrc_MeasurementControlSysInfoExtension_cellSelectQualityMeasure_1_cpich_Ec_N0:
        rrcmeas_sib11->cell_sel_resel_quan_type =  L1_EC_NO;

        if(!(sib11bis_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->cellSelectQualityMeasure.u.cpich_Ec_N0->m.
            newIntraFreqCellListPresent ))
        {
          return FAILURE;
        }
        intra_freq_meas_hcs_ecn0_ptr = &sib11bis_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_used->
            cellSelectQualityMeasure.u.cpich_Ec_N0->newIntraFreqCellList;
        rrcmeas_sib11->intra_freq_meas_info_incl = TRUE;
        if(rrcmeas_sib11->intra_f.cell_list_incl == TRUE)
        {
          cell_count = rrcmeas_sib11->intra_f.cell_list.num_cell_add;
        }
        rrcmeas_sib11->intra_f.cell_list_incl = TRUE;
        idx=0;
        while ( (intra_freq_meas_hcs_ecn0_ptr->n > idx) &&
          (cell_count < L1_MAX_CELL_MEAS) )
        {
          if ( intra_freq_meas_hcs_ecn0_ptr->elem[idx].cellInfo.
            modeSpecificInfo.t ==
            T_rrc_CellInfoSI_HCS_ECN0_modeSpecificInfo_tdd)
          {
            /* Nothing doing with a TDD cell. Shun it ! */
            idx++;
            continue;
          }
          /* Set default values for the HCS neighboring cell info if it is first cell
          * else use the info from the previous cell */
          if(cell_count == 0)
          {
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio = 0;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs = 115;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time = 0;
          }
          else
          {
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.hcs_prio;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.q_hcs;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.penalty_time;

            if(rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.penalty_time
              != 0)
            {
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.tmp_offset1 =
                rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count - 1].cell_info.hcs_info.tmp_offset1;
            }
          }
          if (rrcmeas_fill_hcs_ecn0_cell_info(&intra_freq_meas_hcs_ecn0_ptr->elem[idx].
            cellInfo, &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info, ((rel5_ext_ptr != NULL) ? ((rel5_ext_ptr->n > idx) ? (&rel5_ext_ptr->elem[idx]) : NULL) : NULL)) == FAILURE)
          {
            idx++;
            continue;
          }
          /* Check if intra-freq cell ID is present */
          if (RRC_MSG_LIST_BITMASK_IE(intra_freq_meas_hcs_ecn0_ptr,
            rrc_NewIntraFreqCellSI_HCS_ECN0,intraFreqCellID))
          {
            cell_position = intra_freq_meas_hcs_ecn0_ptr->elem[idx].intraFreqCellID;
          } /* End of if of intra-freq cell id present */
          else
          {
            cell_position = AVAILABLE_CELL_POSITION;
            /* Set psc from rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info.pri_scr_code in the first vacant position in intra freq cell list */
          } /* End of else of intra-freq cell id not present */
          if ( rrcmeas_update_intra_freq_cell_list(
            &cell_position,
            &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info.pri_scr_code) == RRCMEAS_SUCCESS)
          {
            /* PSC sucessfully stored in the cell info list variable */
            /* Now store psc in the sib11 in add cell for layer1 to use psc */
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].psc =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
              cell_info.pri_scr_code;
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach = TRUE;
            if(sib18_present)
            {
              rrcmeas_process_sib18_filtering(
                 tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
                 tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
                 &tmp_plmn_identity,
                 cell_count,
                 &(rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach),
                 (cell_count > 0)?rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count -1].measure_in_idle_pch_fach: TRUE);
            }

            /* Increment cell count as add cell successfully stored */
            cell_count ++;
          }
          idx++;
          if ( (cell_count == L1_MAX_CELL_MEAS) &&
            (intra_freq_meas_hcs_ecn0_ptr->n > idx) )
          {
          /* If there are more new cells than can be accomodated in L1
          Cmd, print a message and hope L1 will change their capability
          sometime. Just pass the number that L1 can handle.
            */
            MSG_LOW("SIB11bis: All Intra freq cells not included",0,0,0);
            break;
          }
        }
        rrcmeas_sib11->intra_f.cell_list.num_cell_add = cell_count;
        WRRC_MSG1_HIGH("SIB11bis: Number if cells added from SIB11 and SIB11bis is %d",rrcmeas_sib11->intra_f.cell_list.num_cell_add);
        if(rrcmeas_sib11->intra_f.cell_list.num_cell_add == 0)
        {
          rrcmeas_sib11->intra_f.cell_list_incl = FALSE;
          return FAILURE;
        }
        
        break;
        
      default:
        return FAILURE;
    }
    rrcmeas_sib11->hcs_used = TRUE;
  }
  else
  {
    WRRC_MSG0_HIGH("SIB11bis: HCS is not Used in SIB11bis");
    switch(sib11bis_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->cellSelectQualityMeasure.t)
    {
      WRRC_MSG1_HIGH("SIB11bis: cellSelectQualityMeasure is %d [1/2 : RSCP/EcNo]",sib11bis_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->cellSelectQualityMeasure.t);
      case T_rrc_MeasurementControlSysInfoExtension_cellSelectQualityMeasure_cpich_RSCP:
        rrcmeas_sib11->cell_sel_resel_quan_type =  L1_RSCP;

        if(!(sib11bis_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->cellSelectQualityMeasure.u.cpich_RSCP->m.
            newIntraFreqCellListPresent ))
        {
          return FAILURE;
        }
        rrcmeas_sib11->intra_freq_meas_info_incl = TRUE;
        intra_freq_meas_rscp_ptr = &sib11bis_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
            cellSelectQualityMeasure.u.cpich_RSCP->newIntraFreqCellList;
        if(rrcmeas_sib11->intra_f.cell_list_incl == TRUE)
        {
          cell_count = rrcmeas_sib11->intra_f.cell_list.num_cell_add;
        }
        rrcmeas_sib11->intra_f.cell_list_incl = TRUE;

        idx=0;
        while ( (intra_freq_meas_rscp_ptr->n > idx) &&
          (cell_count < L1_MAX_CELL_MEAS) )
        {
        /* Pointer to next cell is Non-NULL and cell count
          * hasn't exceeded the max. L1 can handle */
  
          if ( intra_freq_meas_rscp_ptr->elem[idx].cellInfo.
            modeSpecificInfo.t ==
            T_rrc_CellInfoSI_RSCP_modeSpecificInfo_tdd)
          {
            /* Nothing doing with a TDD cell. Shun it ! */
            idx++;
            continue;
          }
          /* Set default values for the HCS neighboring cell info if it is first cell
          * else use the info from the previous cell */
          rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio = 0;
          rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs = 115;
          rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time = 0;
  
          if (rrcmeas_fill_rscp_cell_info(&intra_freq_meas_rscp_ptr->elem[idx].
            cellInfo, &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info, ((rel5_ext_ptr != NULL) ? ((rel5_ext_ptr->n > idx) ? (&rel5_ext_ptr->elem[idx]) : NULL) : NULL)) == FAILURE)
          {
            idx++;
            continue;
          }
          /* Check if intra-freq cell ID is present */
          if (RRC_MSG_LIST_BITMASK_IE(intra_freq_meas_rscp_ptr,
            rrc_NewIntraFreqCellSI_RSCP,intraFreqCellID))
          {
            cell_position = intra_freq_meas_rscp_ptr->elem[idx].intraFreqCellID;
          } /* End of if of intra-freq cell id present */
          else
          {
            cell_position = AVAILABLE_CELL_POSITION;
          } /* End of else of intra-freq cell id not present */

          if ( rrcmeas_update_intra_freq_cell_list(
            &cell_position,
            &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info.pri_scr_code) == RRCMEAS_SUCCESS)
          {
            /* PSC sucessfully stored in the cell info list variable */
            /* Now store psc in the sib11 in add cell for layer1 to use psc */
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].psc =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
              cell_info.pri_scr_code;
  
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
              measure_in_idle_pch_fach = TRUE;
            if(sib18_present)
            {
              rrcmeas_process_sib18_filtering(
                 tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
                 tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
                 &tmp_plmn_identity,
                 cell_count,
                 &(rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach),
                 (cell_count > 0)?rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count -1].measure_in_idle_pch_fach: TRUE);
            }

            /* Increment cell count as add cell successfully stored */
            cell_count ++;
          }  /* End of if of rrcmeas_update_intra_freq_cell_list */

         idx++;
          if ( (cell_count == L1_MAX_CELL_MEAS) &&
            (intra_freq_meas_rscp_ptr->n > idx) )
          {
          /* If there are more new cells than can be accomodated in L1
          Cmd, print a message and hope L1 will change their capability
          sometime. Just pass the number that L1 can handle.
            */
            MSG_LOW("SIB11bis: All Intra freq cells not included",0,0,0);
            break;
          }
        }
        rrcmeas_sib11->intra_f.cell_list.num_cell_add = cell_count;
        
        WRRC_MSG1_HIGH("SIB11bis: Number if cells added from SIB11 and SIB11bis is %d",rrcmeas_sib11->intra_f.cell_list.num_cell_add);
        if(rrcmeas_sib11->intra_f.cell_list.num_cell_add == 0)
        {
          rrcmeas_sib11->intra_f.cell_list_incl = FALSE;
          return FAILURE;
        }
        
        break;

        
      case T_rrc_MeasurementControlSysInfoExtension_cellSelectQualityMeasure_cpich_Ec_N0:
        rrcmeas_sib11->cell_sel_resel_quan_type =  L1_EC_NO;
        if(!(sib11bis_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->cellSelectQualityMeasure.u.cpich_Ec_N0->m.
            newIntraFreqCellListPresent ))
        {
          return FAILURE;
        }
        intra_freq_meas_ecn0_ptr = &sib11bis_ptr->measurementControlSysInfo.use_of_HCS.u.hcs_not_used->
            cellSelectQualityMeasure.u.cpich_Ec_N0->newIntraFreqCellList;
        rrcmeas_sib11->intra_freq_meas_info_incl = TRUE;
        if(rrcmeas_sib11->intra_f.cell_list_incl == TRUE)
        {
          cell_count = rrcmeas_sib11->intra_f.cell_list.num_cell_add;
        }
        rrcmeas_sib11->intra_f.cell_list_incl = TRUE;

        idx=0;
        while ( (intra_freq_meas_ecn0_ptr->n > idx) &&
          (cell_count < L1_MAX_CELL_MEAS) )
        {
        /* Pointer to next cell is Non-NULL and cell count
          * hasn't exceeded the max. L1 can handle */
  
          if ( intra_freq_meas_ecn0_ptr->elem[idx].cellInfo.
            modeSpecificInfo.t ==
            T_rrc_CellInfoSI_ECN0_modeSpecificInfo_tdd)
          {
            /* Nothing doing with a TDD cell. Shun it ! */
            idx++;
            continue;
          }
          /* Set default values for the HCS neighboring cell info if it is first cell
          * else use the info from the previous cell */
          rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.hcs_prio = 0;
          rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.q_hcs = 115;
          rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].cell_info.hcs_info.penalty_time = 0;
  
          if (rrcmeas_fill_ecn0_cell_info(&intra_freq_meas_ecn0_ptr->elem[idx].
            cellInfo, &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info, ((rel5_ext_ptr != NULL) ? ((rel5_ext_ptr->n > idx) ? (&rel5_ext_ptr->elem[idx]) : NULL) : NULL)) == FAILURE)
          {
            idx++;
            continue;
          }
          /* Check if intra-freq cell ID is present */
          if (RRC_MSG_LIST_BITMASK_IE(intra_freq_meas_ecn0_ptr,
            rrc_NewIntraFreqCellSI_ECN0,intraFreqCellID))
          {
            cell_position = intra_freq_meas_ecn0_ptr->elem[idx].intraFreqCellID;
          } /* End of if of intra-freq cell id present */
          else
          {
            cell_position = AVAILABLE_CELL_POSITION;
          } /* End of else of intra-freq cell id not present */

          if ( rrcmeas_update_intra_freq_cell_list(
            &cell_position,
            &rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
            cell_info.pri_scr_code) == RRCMEAS_SUCCESS)
          {
            /* PSC sucessfully stored in the cell info list variable */
            /* Now store psc in the sib11 in add cell for layer1 to use psc */
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].psc =
              rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
              cell_info.pri_scr_code;
  
            rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].
              measure_in_idle_pch_fach = TRUE;
            /* Increment cell count as add cell successfully stored */
            if(sib18_present)
            {
              rrcmeas_process_sib18_filtering(
                 tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
                 tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
                 &tmp_plmn_identity,
                 cell_count,
                 &(rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count].measure_in_idle_pch_fach),
                 (cell_count > 0)?rrcmeas_sib11->intra_f.cell_list.add_cell[cell_count -1].measure_in_idle_pch_fach: TRUE);
            }
            cell_count ++;
          }  /* End of if of rrcmeas_update_intra_freq_cell_list */

          idx++;
          if ( (cell_count == L1_MAX_CELL_MEAS) &&
            (intra_freq_meas_ecn0_ptr->n > idx) )
          {
          /* If there are more new cells than can be accomodated in L1
          Cmd, print a message and hope L1 will change their capability
          sometime. Just pass the number that L1 can handle.
            */
            MSG_LOW("SIB11bis: All Intra freq cells not included",0,0,0);
            break;
          }
        }
        rrcmeas_sib11->intra_f.cell_list.num_cell_add = cell_count;
        WRRC_MSG1_HIGH("SIB11bis: Number if cells added from SIB11 and SIB11bis is %d",rrcmeas_sib11->intra_f.cell_list.num_cell_add);
        if(rrcmeas_sib11->intra_f.cell_list.num_cell_add == 0)
        {
          rrcmeas_sib11->intra_f.cell_list_incl = FALSE;
          return FAILURE;
        }
        
        break;

      default:
        return FAILURE;
    }
    rrcmeas_sib11->hcs_used = FALSE;
  }
  rrcmeas_sib11->intra_freq_meas_info_incl = TRUE;
  rrcmeas_sib11->intra_f.cell_list_incl = TRUE;
  return SUCCESS;
}



#ifdef FEATURE_WCDMA
/*===========================================================================

FUNCTION   RRCMEAS_HANDLE_UTRAN_NMR_INFO_REQ

DESCRIPTION


DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/
void rrcmeas_handle_utran_nmr_info_req
(
  rrc_cmd_type* cmd_ptr
)
{
  rrc_mode_e_type   rrc_mode;
  l1_meas_utran_nmr_info_union_type l1_meas_utran_nmr_info = {{0}};
  rrc_gstk_utran_nmr_info_req_type nmr_req = cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req;
  /* Stores meas report */
  rrc_UL_DCCH_Message* msg_ptr = NULL;
  uint16 i = 0, j = 0, k = 0;
  /* Stores RSSI value */
  uint8 rssi_value = 0;
  pdu_buf_type encoded_sdu;                
  rrc_IntraFreqMeasuredResultsList* intra_freq_measured_results_list_ptr = NULL;
  rrc_InterFreqMeasuredResultsList* local_rrc_meas_results_ptr = NULL;
  rrc_InterFreqCellMeasuredResultsList* local_inter_freq_cell_list_ptr = NULL;
  rrc_GSM_MeasuredResultsList* local_rrc_gsm_list_ptr = NULL;
  boolean l1_nmr_success = TRUE;

  WRRC_MSG0_HIGH("RRCNMR: Rcvd RRC_GSTK_UTRAN_NMR_INFO_REQ.");

  rrc_mode = rrcmcm_get_rrc_mode();

  /* See if the cmd can be processed before querying WL1 */
  if ((rrcmeas_current_substate == RRCMEAS_INITIAL) ||
      (rrc_mode != RRC_MODE_ACTIVE) ||
      (RRC_CAMPED_ON != rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_MCMR)) ||
      (WTOW_SEARCH_STOP != rrc_csp_bplmn_srch_in_progress())) 
  {
    /* If UE is OOS, WCDMA stop, BPLMN, suspended, , HHOAquisition and freq scan <WL1 to reject>,   */

    if (RRC_CAMPED_ON != rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_MCMR))
    {
      gstk_queue_rrc_utran_nmr_rsp(GSTK_UTRAN_NMR_RESULT_FAIL_UE_OOS, 0, NULL, nmr_req.ref_id);
    }
    else
    {
      gstk_queue_rrc_utran_nmr_rsp(GSTK_UTRAN_NMR_RESULT_FAIL_OTHER, 0, NULL, nmr_req.ref_id);
    }
    WRRC_MSG0_HIGH ("RRCNMR: Request not honored.  Fail");
  }
  else
  {
#ifndef FEATURE_WCDMA_FREE_FLOATING_TASK
    WCDMA_RRC_TASK_LOCK();
	l1_nmr_success = l1_get_utran_nmr_info(&l1_meas_utran_nmr_info, RRCMEAS_XLATE_NMR_TYPE(nmr_req.report_type));
	WCDMA_RRC_TASK_FREE();
#else
    l1_nmr_success = rrcff_l1_get_utran_nmr_info(&l1_meas_utran_nmr_info, RRCMEAS_XLATE_NMR_TYPE(nmr_req.report_type));
#endif

    if (FALSE == l1_nmr_success)
    {
      WRRC_MSG0_HIGH ("RRCNMR: Not able to retrieve NMR info");
      gstk_queue_rrc_utran_nmr_rsp(GSTK_UTRAN_NMR_RESULT_FAIL_OTHER, 0, NULL, nmr_req.ref_id);
      return;
    }


    if (((nmr_req.report_type == GSTK_NMR_INTRA_FREQ_MEAS) && (l1_meas_utran_nmr_info.intra_freq_info.num_cells == 0)) ||
        ((nmr_req.report_type == GSTK_NMR_INTER_FREQ_MEAS) && (l1_meas_utran_nmr_info.inter_freq_info.num_freq == 0)) ||
        ((nmr_req.report_type == GSTK_NMR_INTRA_FREQ_MEAS) && (l1_meas_utran_nmr_info.irat_info.num_cells == 0)))
    {
      WRRC_MSG0_HIGH("RRCNMR: No cells to report.");
      gstk_queue_rrc_utran_nmr_rsp(GSTK_UTRAN_NMR_RESULT_FAIL_OTHER, 0, NULL, nmr_req.ref_id);
      return;
    }

    /* Build measurement report */
    msg_ptr = (rrc_UL_DCCH_Message *) rrc_malloc (sizeof(struct rrc_UL_DCCH_Message));

    /* Store meas report chosen */
    msg_ptr->message.t = T_rrc_UL_DCCH_MessageType_measurementReport;
    /* Meas Identity for NMR should always be 1.  As per 31.111 */
    msg_ptr->message.u.measurementReport.measurementIdentity = 1;
    /* Initialize Meas Report bit mask */
    RRC_RESET_MSG_IE_PRESENT(msg_ptr->message.u.measurementReport);

    /* Store bit mask to indicate measured results present */
    RRC_MSG_COMMON_SET_BITMASK_IE(msg_ptr->message.u.measurementReport,
    rrc_MeasurementReport,measuredResults);

    if (nmr_req.report_type == GSTK_NMR_INTRA_FREQ_MEAS) 
    {
      /* Fill in intra-freq info */
      msg_ptr->message.u.measurementReport.measuredResults.t = 
        T_rrc_MeasuredResults_intraFreqMeasuredResultsList;

      /* Allocate memory for intra-freq result structure */
      intra_freq_measured_results_list_ptr =
        rtxMemAllocTypeZ(&enc_ctxt,rrc_IntraFreqMeasuredResultsList);

      msg_ptr->message.u.measurementReport.measuredResults.u.intraFreqMeasuredResultsList =
        intra_freq_measured_results_list_ptr;
      
      intra_freq_measured_results_list_ptr->n =
        (l1_meas_utran_nmr_info.intra_freq_info.num_cells > cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req.num_cells ) ?
        (cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req.num_cells ):(l1_meas_utran_nmr_info.intra_freq_info.num_cells);

      ALLOC_ASN1ARRAY2(&enc_ctxt,intra_freq_measured_results_list_ptr,
            rrc_CellMeasuredResults);

      for (i = 0; 
            (i < l1_meas_utran_nmr_info.intra_freq_info.num_cells) &&
            (i < cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req.num_cells);
            i++)
      {
        RRC_RESET_MSG_IE_PRESENT(intra_freq_measured_results_list_ptr->elem[i]);

        /* Set in the FDD mode for rrc_CellMeasuredResults_modeSpecificInfo */
        intra_freq_measured_results_list_ptr->elem[i].modeSpecificInfo.t =
          T_rrc_CellMeasuredResults_modeSpecificInfo_fdd;

        intra_freq_measured_results_list_ptr->elem[i].modeSpecificInfo.u.fdd =
          rtxMemAllocTypeZ(&enc_ctxt,rrc_CellMeasuredResults_fdd);
        intra_freq_measured_results_list_ptr->elem[i].modeSpecificInfo.u.fdd->
          primaryCPICH_Info.primaryScramblingCode =
         l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].psc;

        MSG_HIGH("RRCNMR: Present Fields ec_no %d, rscp %d path_loss %d",
                 l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].cpich_ec_no_present,
                 l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].cpich_ec_no_present,
                 l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].pathloss);

        if ((l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].cpich_ec_no_present) &&
            (l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].cpich_ec_no <= ECN0_MAX_VALUE))
        {
          intra_freq_measured_results_list_ptr->elem[i].modeSpecificInfo.u.fdd->
            m.cpich_Ec_N0Present =1; 
          intra_freq_measured_results_list_ptr->elem[i]
            .modeSpecificInfo.u.fdd->cpich_Ec_N0 =  l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].cpich_ec_no;

        }
        if ((l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].cpich_rscp_present) &&
            (l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].cpich_rscp <= RSCP_MAX_VALUE))
        {
          intra_freq_measured_results_list_ptr->elem[i].modeSpecificInfo.u.fdd->
            m.cpich_RSCPPresent=1; 
          intra_freq_measured_results_list_ptr->elem[i]
            .modeSpecificInfo.u.fdd->cpich_RSCP = 
            l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].cpich_rscp;
        }
        if (l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].pathloss_present &&
            (l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].pathloss > PATH_LOSS_MIN_VALUE) &&
            (l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].pathloss < PATH_LOSS_MAX_VALUE)) 
        {
          intra_freq_measured_results_list_ptr->elem[i].modeSpecificInfo.u.fdd->
            m.pathlossPresent =1; 
          intra_freq_measured_results_list_ptr->elem[i]
            .modeSpecificInfo.u.fdd->pathloss = 
            l1_meas_utran_nmr_info.intra_freq_info.nmr_cell_info[i].pathloss;
        }

      }
    }
    else if (nmr_req.report_type == GSTK_NMR_INTER_FREQ_MEAS) 
    {
      /* Fill in inter-freq info */
      msg_ptr->message.u.measurementReport.measuredResults.t = 
        T_rrc_MeasuredResults_interFreqMeasuredResultsList;

      /* Allocate Memory */
      local_rrc_meas_results_ptr = rtxMemAllocTypeZ(&enc_ctxt,
               rrc_InterFreqMeasuredResultsList);
      
      msg_ptr->message.u.measurementReport.measuredResults.u.interFreqMeasuredResultsList =
        local_rrc_meas_results_ptr;

      local_rrc_meas_results_ptr->n = l1_meas_utran_nmr_info.inter_freq_info.num_freq;

      ALLOC_ASN1ARRAY2(&enc_ctxt,local_rrc_meas_results_ptr,rrc_InterFreqMeasuredResults);

      for (j = 0; (j < l1_meas_utran_nmr_info.inter_freq_info.num_freq) && (j < L1_MAX_NON_USED_FREQ); j++) 
      {
         /* Now get Inter Freq Cells */
        if (l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].num_cells == 0)
        {
          WRRC_MSG2_HIGH("RRCNMR:Num cells : %d freq is %d ...ignoring this freq",
                   l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].num_cells,
                   l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].freq);
        }
        else
        {
          RRC_RESET_MSG_IE_PRESENT(local_rrc_meas_results_ptr->elem[k]);
          local_rrc_meas_results_ptr->elem[k].m.frequencyInfoPresent =1;
          local_rrc_meas_results_ptr->elem[k].frequencyInfo.modeSpecificInfo.t =
          T_rrc_FrequencyInfo_modeSpecificInfo_fdd;

          local_rrc_meas_results_ptr->elem[k].frequencyInfo.modeSpecificInfo.u.fdd =
         rtxMemAllocTypeZ(&enc_ctxt,rrc_FrequencyInfoFDD);

          RRC_RESET_MSG_IE_PRESENT_PTR(local_rrc_meas_results_ptr->elem[k].frequencyInfo.modeSpecificInfo.u.fdd);
          local_rrc_meas_results_ptr->elem[k].frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL = 
          l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].freq;
        if(l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].utra_carrier_rssi <=127)
        {
            local_rrc_meas_results_ptr->elem[k].m.utra_CarrierRSSIPresent=1;
            local_rrc_meas_results_ptr->elem[k].utra_CarrierRSSI=l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].utra_carrier_rssi;
        }
        else
        {
           WRRC_MSG0_HIGH("RSSI value not available");
           gstk_queue_rrc_utran_nmr_rsp(GSTK_UTRAN_NMR_RESULT_SUCCESS, 0, NULL, nmr_req.ref_id);
          return;
        }

       
          
          /* Set bit mask for Cell Meas Results List present */
            local_rrc_meas_results_ptr->elem[k].m.interFreqCellMeasuredResultsListPresent = 1;

            local_inter_freq_cell_list_ptr =&local_rrc_meas_results_ptr->elem[k].interFreqCellMeasuredResultsList;
           
           local_inter_freq_cell_list_ptr->n =
                   (l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].num_cells > 
                   cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req.num_cells) ?
                   (cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req.num_cells):
                   (l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].num_cells );
   
          ALLOC_ASN1ARRAY2(&enc_ctxt,local_inter_freq_cell_list_ptr,rrc_CellMeasuredResults);

          for (i = 0; 
                (i < l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].num_cells) &&
                (i < cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req.num_cells);
                i++)
          {
            RRC_RESET_MSG_IE_PRESENT(local_inter_freq_cell_list_ptr->elem[i]);

            /* Set in the FDD mode for rrc_CellMeasuredResults_modeSpecificInfo */
            local_inter_freq_cell_list_ptr->elem[i].modeSpecificInfo.t =
              T_rrc_CellMeasuredResults_modeSpecificInfo_fdd;
            
            local_inter_freq_cell_list_ptr->elem[i].modeSpecificInfo.u.fdd =
              rtxMemAllocTypeZ(&enc_ctxt,rrc_CellMeasuredResults_fdd);

            /* Set primary scrambling code */
            local_inter_freq_cell_list_ptr->elem[i].modeSpecificInfo.u.fdd->
              primaryCPICH_Info.primaryScramblingCode =
              l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].nmr_cell_info[i].psc;
            
            MSG_HIGH("RRCNMR: Present fields ec_no %d, rscp %d path_loss %d",
                     l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].nmr_cell_info[i].cpich_ec_no_present,
                     l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].nmr_cell_info[i].cpich_rscp_present,
                     l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].nmr_cell_info[i].pathloss_present);
            
            RRC_RESET_MSG_IE_PRESENT_PTR(local_inter_freq_cell_list_ptr->elem[i].modeSpecificInfo.u.fdd);

            /* Check if EC/Io included */
            if (l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].nmr_cell_info[i].cpich_ec_no_present)
            {  
              local_inter_freq_cell_list_ptr->elem[i].modeSpecificInfo.u.fdd->cpich_Ec_N0 =
                l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].nmr_cell_info[i].cpich_ec_no;                
              /* Set bit mask */
              local_inter_freq_cell_list_ptr->elem[i].modeSpecificInfo.u.fdd->m.cpich_Ec_N0Present =1;              
            }

            /* Check if RSCP included */
            if (l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].nmr_cell_info[i].cpich_rscp_present)
            {
              local_inter_freq_cell_list_ptr->elem[i].modeSpecificInfo.u.fdd->cpich_RSCP =
                l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].nmr_cell_info[i].cpich_rscp;
              
              /* Set bit mask */
              local_inter_freq_cell_list_ptr->elem[i].modeSpecificInfo.u.fdd->m.cpich_RSCPPresent =1;
            }

            /* Check if Path Loss included */
            if (l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].nmr_cell_info[i].pathloss_present)
            {
              local_inter_freq_cell_list_ptr->elem[i].modeSpecificInfo.u.fdd->pathloss =
                l1_meas_utran_nmr_info.inter_freq_info.l1_meas_utran_nmr_info[j].nmr_cell_info[i].pathloss;

              /* Set bit mask */
              
                local_inter_freq_cell_list_ptr->elem[i].modeSpecificInfo.u.fdd->m.pathlossPresent =1;
            }
          } 
           k++;
        }
      }
      local_rrc_meas_results_ptr->n = k;
      if(local_rrc_meas_results_ptr->n == 0)
      {
         /* If no cells are measured for freq configured.*/

            WRRC_MSG0_HIGH("RRCNMR:Cannot measure cells of frequencies configured...sending failure to GSTK");
            gstk_queue_rrc_utran_nmr_rsp(GSTK_UTRAN_NMR_RESULT_FAIL_OTHER, 0, NULL, nmr_req.ref_id);
            return;
      }
    }
    else if (nmr_req.report_type == GSTK_NMR_INTER_RAT_MEAS) 
    {
      /*fill in IRAT info*/
      msg_ptr->message.u.measurementReport.measuredResults.t = 
        T_rrc_MeasuredResults_interRATMeasuredResultsList;

      /* Allocate Mem for Inter-RAT Measured Results List */
      msg_ptr->message.u.measurementReport.measuredResults.u.interRATMeasuredResultsList =
        rtxMemAllocTypeZ(&enc_ctxt,rrc_InterRATMeasuredResultsList);

      msg_ptr->message.u.measurementReport.measuredResults.u.interRATMeasuredResultsList->n =1;

      ALLOC_ASN1ARRAY2(&enc_ctxt, msg_ptr->message.u.measurementReport.measuredResults.u.interRATMeasuredResultsList, 
               rrc_InterRATMeasuredResults);
      /* Set t to GSM */
      msg_ptr->message.u.measurementReport.measuredResults.u.interRATMeasuredResultsList->elem[0].t =
        T_rrc_InterRATMeasuredResults_gsm;
      
      /* Allocate Mem for GSM cells */
      local_rrc_gsm_list_ptr = rtxMemAllocTypeZ(&enc_ctxt,rrc_GSM_MeasuredResultsList);
      
      /* Assign Head Ptr */
      msg_ptr->message.u.measurementReport.measuredResults.u.interRATMeasuredResultsList->elem[0].u.gsm
        = local_rrc_gsm_list_ptr;

      local_rrc_gsm_list_ptr->n=
        (l1_meas_utran_nmr_info.irat_info.num_cells > cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req.num_cells )?
        cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req.num_cells :l1_meas_utran_nmr_info.irat_info.num_cells;

      ALLOC_ASN1ARRAY2(&enc_ctxt, local_rrc_gsm_list_ptr, rrc_GSM_MeasuredResults); 

      for (i = 0;
            (i <  l1_meas_utran_nmr_info.irat_info.num_cells) &&
            (i < cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req.num_cells);
            i++)
      {
        RRC_RESET_MSG_IE_PRESENT(local_rrc_gsm_list_ptr->elem[i]);

        /* If BSIC Verified */
        if ( l1_meas_utran_nmr_info.irat_info.irat_cell_info[i].bsic_choice
             == L1_BSIC_VERIFIED)
        {
          local_rrc_gsm_list_ptr->elem[i].bsicReported.t = T_rrc_BSICReported_verifiedBSIC;
          /* Set cell id to Verified BSIC */
          local_rrc_gsm_list_ptr->elem[i].bsicReported.u.verifiedBSIC =
            l1_meas_utran_nmr_info.irat_info.irat_cell_info[i].u.bsic_verified.inter_sys_cell_id;
        }
        else
        {
          local_rrc_gsm_list_ptr->elem[i].bsicReported.t = T_rrc_BSICReported_nonVerifiedBSIC;
          
          /* Set cell id to Non Verified BSIC */
          local_rrc_gsm_list_ptr->elem[i].bsicReported.u.nonVerifiedBSIC =
            CONVERT_ARFCN_TO_NUM(l1_meas_utran_nmr_info.irat_info.irat_cell_info[i].u.bsic_not_verified.bcch_arfcn);

        }

        /* Set RSSI value */
        if (l1_meas_utran_nmr_info.irat_info.irat_cell_info[i].gsm_carrier_rssi_present == TRUE)
        {
          /* Convert value from uint8 to oss bit string */
          rrcirat_convert_rssi_value(
            &l1_meas_utran_nmr_info.irat_info.irat_cell_info[i].gsm_carrier_rssi, &rssi_value);

          /* Double check if value is O.K */
          if (rssi_value <= 63)
          {
            rssi_value = rssi_value << 2;     /*lint !e734 */
            
            /* Put Actual Value to be 6 bits */
            local_rrc_gsm_list_ptr->elem[i].gsm_CarrierRSSI.numbits= 6;
            
            *(local_rrc_gsm_list_ptr->elem[i].gsm_CarrierRSSI.data) = (unsigned char ) (rssi_value);
            
            
            /* Set RSSI value present in Meas Report */
            local_rrc_gsm_list_ptr->elem[i].m.gsm_CarrierRSSIPresent =1 ;

          }  /* End of rssi value less than MAX_RSSI */
        } /* End of RSSI included */
      }
    }

    msg_ptr->message.u.measurementReport.additionalMeasuredResults.n = 0;

    encoded_sdu = rrcasn1_encode_pdu((void*)msg_ptr, (int) rrc_UL_DCCH_Message_PDU);

    if(encoded_sdu.value !=NULL)            
    {
       for(i=0;i<encoded_sdu.length;i++)
       {
         encoded_sdu.value[i]<<=6;
         if(i<(encoded_sdu.length-1))
         {
            encoded_sdu.value[i]|=((encoded_sdu.value[i+1])>>2)&0x3F;
         }
         else
         {
           encoded_sdu.value[i]&=0xC0;
         }
      }
      gstk_queue_rrc_utran_nmr_rsp(GSTK_UTRAN_NMR_RESULT_SUCCESS, encoded_sdu.length, encoded_sdu.value, nmr_req.ref_id);

      /* Once GSTK copies the info, free the allocated memory*/

      //Not required to call for Objetive sys. As freeing of cxtx rees the buffer alsoi.e. encoded data
     // rrcasn1_free_buf(encoded_sdu.value);
      if(rrcasn1_free_pdu((int )rrc_UL_DCCH_Message_PDU, msg_ptr)) 
      {
        /* This is a memory leak and it should never happen.*/
        MSG_LOW("RRCNMR: Memory freeing is unsuccessful",0,0,0);
      }
      msg_ptr =NULL;
    }
    else
    {
      WRRC_MSG0_ERROR("RRCNMR: Failed to encode NMR msg.  Clean up");
      /*Encoding didn't succeed*/
      gstk_queue_rrc_utran_nmr_rsp(GSTK_UTRAN_NMR_RESULT_FAIL_OTHER, 0, NULL, nmr_req.ref_id);
      if(rrcasn1_free_pdu((int )rrc_UL_DCCH_Message_PDU, msg_ptr)) 
      {
        /* This is a memory leak and it should never happen.*/
        MSG_LOW("RRCNMR:Memory freeing is unsuccessful",0,0,0);
      }
      msg_ptr = NULL;
    }
  }
} /* rrcmeas_handle_utran_nmr_info_req */
/*===========================================================================

FUNCTION   RRC_GSTK_GET_UTRAN_NMR_INFO

DESCRIPTION

 This function is invoked by GSTK in it's context when it needs some UTRAN 
 network measurment information.  RRC will post an internal command and 
 process the request.

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None

===========================================================================*/
void rrc_gstk_get_utran_nmr_req
(
  uint8 num_cells, gstk_nmr_utran_qualifier_enum_type report_type, 
  uint32 *ref_id,
  sys_modem_as_id_e_type as_id
)
{
  rrc_cmd_type *int_cmd_ptr;
  rrc_mode_e_type   rrc_mode = rrcmcm_get_rrc_mode();
  WRRC_MSG2_HIGH("RRCNMR: Rcvd request for NMR %d report type, num_cells %d", report_type, num_cells);
  if(rrc_mode == RRC_MODE_ACTIVE)
  {
#ifdef FEATURE_DUAL_SIM
    if((rrc_is_sim_id_valid) && (rrc_sim_id_recvd != as_id))
    {
      gstk_queue_rrc_utran_nmr_rsp(GSTK_UTRAN_NMR_RESULT_FAIL_ASID_MISMATCH, 0, NULL, ref_id);
    }
    else if(!rrc_is_sim_id_valid)
    {
      WRRC_MSG0_HIGH("DSIM: RRC AS_ID is not updated yet");
    }
    else
#endif
    if ( (int_cmd_ptr =  rrc_get_int_cmd_buf()) != NULL)
    {
      /* Fill in the command parameters for RRC_CELL_UPDATE_INITIATE_REQ */
      int_cmd_ptr->cmd_hdr.cmd_id = RRC_GSTK_UTRAN_NMR_INFO_REQ;
      int_cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req.num_cells = num_cells;
      int_cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req.report_type = report_type;
      int_cmd_ptr->cmd.rrc_gstk_utran_nmr_info_req.ref_id = ref_id;
      WRRC_MSG1_HIGH("RRCNMR: self post RRC_GSTK_UTRAN_NMR_INFO_REQ. RRC state :%d",rrc_get_state());
      rrc_put_int_cmd(int_cmd_ptr);             
    }
  }
  else
  {
    WRRC_MSG1_ERROR("RRCNMR: RRC mode %d.  Cannot process req",rrc_mode);
    gstk_queue_rrc_utran_nmr_rsp(GSTK_UTRAN_NMR_RESULT_FAIL_OTHER, 0, NULL, ref_id);
  }
}

#endif /*FEATURE_WCDMA*/

/*===========================================================================

FUNCTION  rrcmeas_get_int_trans_index_for_trans_id

DESCRIPTION

  This function will return internal transaction index given the trans_id of the MCM and updates the current idx in accepted
  transactions as latest
    
DEPENDENCIES

  None.
 
RETURN VALUE

Internal transaction index

SIDE EFFECTS

  None.

===========================================================================*/
uint8 rrcmeas_get_int_trans_index_for_trans_id
(
  uint8 transaction_id
)
{
  int idx = MAXIMUM_TRANSACTIONS;
  uint8 trans_idx = MAXIMUM_TRANSACTIONS;
  
  for(idx=0;idx<MAXIMUM_TRANSACTIONS;idx++)
  {
    if(rrcmeas_accepted_transaction_table[idx].transaction_id == INVALID_TRANSACTION_ID)
    {
      rrcmeas_accepted_transaction_table[idx].transaction_id = transaction_id;
      rrcmeas_accepted_transaction_table[idx].is_latest_trans = TRUE;

      trans_idx = idx;
      break;
    }
  }
  
  return trans_idx;
}

/*===========================================================================

FUNCTION   rrcmeas_process_mcm_r7

DESCRIPTION

    This function processed the Release 7 Meas Ctrl Message

DEPENDENCIES

    None

RETURN VALUE
   Void


SIDE EFFECTS

    None

===========================================================================*/

void rrcmeas_process_mcm_r7
(
  rrc_cmd_type *cmd_ptr,
  uint8 meas_ctrl_tr_id
)
{
  rrc_MeasurementControl_r7_IEs* mcm_ptr = NULL;

  rrc_DL_DCCH_Message* dcch_msg_ptr = NULL;

  /* Local var to store meas variable */
  rrcmeas_layer_e_type meas_owner;

  /* To store OC SET Status */
  rrcllc_oc_set_status_e_type oc_set_state;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  /* Local Variable to store meas id */
  uint32 meas_id;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  pos_info_struct_type pos_info;
#endif

  /* Store the message. No need to check again */
  dcch_msg_ptr = (rrc_DL_DCCH_Message *)cmd_ptr->cmd.
    downlink_sdu_ind.decoded_msg;

  /* Store actual mcm ptr in a local variable */
  mcm_ptr = &dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.u.r7.measurementControl_r7;

  meas_id = mcm_ptr->measurementIdentity;

  /* Retrieve the Meas Owner */
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  meas_owner = rrcmeas_retrieve_meas_owner_r7(&mcm_ptr->measurementCommand,
    meas_id, &pos_info);
#else
  meas_owner = rrcmeas_retrieve_meas_owner_r7(&mcm_ptr->measurementCommand,
    meas_id);
#endif

  /* Get OC status */
  oc_set_state = rrcllc_get_ordered_config_status();

  MSG_HIGH("REL7: meas id %d, meas owner %d, oc_state %d",meas_id, meas_owner, oc_set_state);

  if ((((meas_owner == INTRA_FREQ) || (meas_owner == INTERNAL_MEAS)|| (meas_owner == INTER_FREQ) ||
    (meas_owner == INTER_SYS)) && (rrcmeas_current_substate != RRCMEAS_CELL_DCH))
    || ((oc_set_state == OC_SET_FOR_DCH_CELL_PCH_TRANS) || (oc_set_state == OC_SET_FOR_DCH_URA_PCH_TRANS)))
  {
    return;
  }

  /* Static Analysis tool */
  if((meas_owner != UNKNOWN_MEAS) && (meas_owner != NOT_EXIST))
  {
    rrcmeas_check_meas_id_used_for_different_meas_type(meas_owner, meas_id);
  }
  if (meas_owner == UNKNOWN_MEAS)
  {
    /* Send Meas Ctrl Failure Message */

    rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

    /* Set error t */
    rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

    if (pos_meas_failure == TRUE)
    {
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
      pos_meas_failure = FALSE;
    }

#endif

    /* Send MCF msg to UTRAN */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

    return;
  }

  if (meas_owner == NOT_EXIST)
  {
    if(mcm_ptr->measurementCommand.t != T_rrc_MeasurementCommand_r7_release)
    {
      /* Send Meas Ctrl Failure Message */

      rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

      if (pos_meas_failure == TRUE)
      {
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
        pos_meas_failure = FALSE;
      }

#endif

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
    }
    else
    {
      WRRC_MSG0_HIGH("Ignore MCM release for an nonexistent measurement, do not send MCM failure");
    }
    return;
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == INTRA_FREQ)
  {
    if (rrcmeas_process_intrafreq_r7(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      return;
    }
    else
    {
      return;
    }
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == INTER_FREQ)
  {
    if (rrcifreq_process_mcm_r7(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if((!process_interfreq_interrat_meas_rel7) && (!process_interfreq_uei_meas_rel7))
      {
        return;
      }
      return;
    }
    else
    {
      return;
    }
  }
  else if (meas_owner == MAC_MEAS)
  {
    if (rrctvm_process_traffic_vol_info_r7(cmd_ptr, meas_ctrl_tr_id) == TVM_SUCCESS)
    {
      return;
    }
    else
    {

      return;
    }
  }

  else if (meas_owner == INTER_SYS)
  {
    /* First check if dual mode is enabled */
    if (rrcmcm_is_dualmode_enabled() == FALSE)
    {
      /* Send Meas Ctrl Failure Message */

      rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      return;
    }

    if (rrcirat_process_mcm_r7(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if(!process_interfreq_interrat_meas_rel7)
      {
        return;
      }
      return;
    }
    else
    {
      return;
    }
  }

  else if (meas_owner == INTERNAL_MEAS)
  {
    if (rrcueim_process_mcm_r7(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if((!process_interfreq_interrat_meas_rel7) && (!process_interfreq_uei_meas_rel7))
      {
        return;
      }

      return;
    }
    else
    {
      return;
    }
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == QUALITY_MEAS)
  {
    if (rrcqm_process_mcm_r7(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      return;
    }
    else
    {
      return;
    }
  }
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  else if ( meas_owner ==  POSITION_MEAS)
  {
    if (rrcmeas_process_pos_mcm_r7(cmd_ptr->cmd.
      downlink_sdu_ind.decoded_msg, &pos_info, meas_ctrl_tr_id) == SUCCESS)
    {
      MSG_LOW("POS: MCM successfully processed",0,0,0);
    }
    else
    {
      MSG_LOW("POS: MCM not successfully processed",0,0,0);
    }
    return;
  } /* End of if of Positioning Measurements */
#endif
  else
  {
    WRRC_MSG0_ERROR("UNSUPPORTED Rel 7 Meas");
    /* Set transaction ID */
    rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

    /* Set error t */
    rrcmeas_mcf.error_choice =
      T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

    /* Send RRC Meas Ctrl Failure msg to UTRAN */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
  }

}


/*===========================================================================

FUNCTION   RRCMEAS_RETRIEVE_MEAS_OWNER_R7

DESCRIPTION

 Finds the owner of measurement identity given in a MCM Rel 7 Msg

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/

rrcmeas_layer_e_type rrcmeas_retrieve_meas_owner_r7
(
rrc_MeasurementCommand_r7* mcm_ptr,
uint32 meas_id
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
,pos_info_struct_type* pos_info_ptr
#endif
)
{
  uint8 count = 0;

  boolean meas_found = FALSE;
  /* First find if Meas is Setup/Modify/Delete */
  switch(mcm_ptr->t)
  {
  case T_rrc_MeasurementCommand_r7_setup:
      WRRC_MSG1_HIGH("R7 : MCM Setup: Meas ==> %d",mcm_ptr->u.setup->t);
    if (mcm_ptr->u.setup->t ==
      T_rrc_MeasurementType_r7_trafficVolumeMeasurement)
    {
      return MAC_MEAS;
    }
    else
    {
      /* Find the actual L1 owner */
      if (mcm_ptr->u.setup->t ==
          T_rrc_MeasurementType_r7_intraFrequencyMeasurement)
      {
        return INTRA_FREQ;
      }
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r7_interRATMeasurement)
      {
        return INTER_SYS;
      }

      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r7_interFrequencyMeasurement)
      {
        return INTER_FREQ;
      }
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r7_ue_InternalMeasurement)
      {
        return INTERNAL_MEAS;
      }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r7_up_Measurement)
      {
        /* Also check in reporting quantity what type of meas is that */
        if ((mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.
          positioningMethod == rrc_PositioningMethod_otdoa) ||
          (mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.
          positioningMethod == rrc_PositioningMethod_cellID))
        {
          WRRC_MSG1_ERROR("PosMethod=%d unsupported 0/1/2/3 OTD/G/Both/Id",
            mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.positioningMethod);
          return UNKNOWN_MEAS;
        }
        /* Store position method and pos cmd */
        pos_info_ptr->pos_meas_cmd = RRC_MEAS_SETUP;
        pos_info_ptr->pos_method_type = RET_POS_METHOD
          (mcm_ptr->u.setup->u.up_Measurement->
          ue_positioning_ReportingQuantity.positioningMethod);

        return POSITION_MEAS;
      }
#endif

      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r7_qualityMeasurement)
      {
        return QUALITY_MEAS;
      }
      else
      {
        /* Else some other Meas */
        return UNKNOWN_MEAS;
      }
    }

  case T_rrc_MeasurementCommand_r7_modify:
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(mcm_ptr->u.modify,
      rrc_MeasurementCommand_r7_modify,measurementType))
    {
      WRRC_MSG1_HIGH("MCM:Modify, Meas Type included %d",mcm_ptr->u.modify->measurementType.t);

      if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r7_trafficVolumeMeasurement)
      {
        for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
        {
          if (tvm_meas_id_list[count].meas_id == meas_id)
          {
            return MAC_MEAS;
          } /* End of if of meas_identity found */

        } /* End of for loop  */

        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      } /* End of if of Traffic Volume Meas */

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r7_interRATMeasurement)
      {
        for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
        {
          if (inter_rat_meas_id_list[count].meas_id == meas_id)
          {
            return INTER_SYS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r7_ue_InternalMeasurement)
      {
        for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
        {
          if (ueim_meas_id_list[count].meas_id == meas_id)
          {
            return INTERNAL_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r7_interFrequencyMeasurement)
      {
        for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
        {
          if (inter_freq_meas_id_list[count].meas_id == meas_id)
          {
            return INTER_FREQ;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r7_intraFrequencyMeasurement)
      {
        for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
        {
          if (intra_freq_meas_id_list[count].meas_id == meas_id)
          {
            return INTRA_FREQ;
          }

        } /* End of for loop */
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }

      } /* End of else if */

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      else if (mcm_ptr->u.modify->
        measurementType.t ==
        T_rrc_MeasurementType_r7_up_Measurement)
      {
        for ( count = 0; count < MAX_POS_MEAS; count++ )
        {
          if (pos_meas_id_list[count].meas_id == meas_id)
          {
            /* Store position method and pos cmd */
            pos_info_ptr->pos_meas_cmd = RRC_MEAS_MODIFY;
            pos_info_ptr->pos_method_type =
              RET_POS_METHOD(mcm_ptr->u.modify->measurementType.u.up_Measurement->
              ue_positioning_ReportingQuantity.positioningMethod);

            return POSITION_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
#endif

      else if (mcm_ptr->u.modify->
        measurementType.t ==
        T_rrc_MeasurementType_r7_qualityMeasurement)
      {
        for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
        {
          if (quality_meas_id_list[count].meas_id == meas_id)
          {
            return QUALITY_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
      else
      {
        return UNKNOWN_MEAS;
      }

    } /* End of if of modify  rrc_measurementType_present */
    else
    { /* Since Meas Type is not given. It must exist at UE.
      If not then send an error msg indicating
      unsupported measurement */

      /* First search in L1 Measurement ID List */

      for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
      {
        if (intra_freq_meas_id_list[count].meas_id == meas_id)
        {
          return INTRA_FREQ;
        }

      } /* End of for loop */

      /* Search in Traffic Volume List */

      for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
      {
        if (tvm_meas_id_list[count].meas_id == meas_id)
        {
          return MAC_MEAS;
        } /* End of if of meas_identity found */

      } /* End of for loop */


      for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
      {
        if (inter_rat_meas_id_list[count].meas_id == meas_id)
        {
          return INTER_SYS;
        }
      }
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      for ( count = 0; count < MAX_POS_MEAS; count++ )
      {
        if (pos_meas_id_list[count].meas_id == meas_id)
        {
          pos_info_ptr->pos_meas_cmd = RRC_MEAS_MODIFY;
          pos_info_ptr->pos_method_type = pos_meas_id_list[count].pos_method_type;
          return POSITION_MEAS;
        }

      }
#endif
      for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
      {
        if (inter_freq_meas_id_list[count].meas_id == meas_id)
        {
          return INTER_FREQ;
        }
      }

      for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
      {
        if (ueim_meas_id_list[count].meas_id == meas_id)
        {
          return INTERNAL_MEAS;
        }

      }

      for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
      {
        if (quality_meas_id_list[count].meas_id == meas_id)
        {
          return QUALITY_MEAS;
        }
      }
      return UNKNOWN_MEAS;
    } /* End of else of meas_type not present */


  case T_rrc_MeasurementCommand_r7_release:
      WRRC_MSG0_HIGH("R7 : MCM Release");
    /* First search in L1 Measurement ID List */
    for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
    {
      if (intra_freq_meas_id_list[count].meas_id == meas_id)
      {
        return INTRA_FREQ;
      }
    } /* End of for loop */

    /* Search in Traffic Volume List */
    for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
    {
      if (tvm_meas_id_list[count].meas_id == meas_id)
      {
        return MAC_MEAS;
      } /* End of if of meas_identity found */
    } /* End of for loop */

    for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
    {
      if (inter_rat_meas_id_list[count].meas_id == meas_id)
      {
        return INTER_SYS;
      }
    }

    for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
    {
      if (inter_freq_meas_id_list[count].meas_id == meas_id)
      {
        return INTER_FREQ;
      }
    }

    for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
    {
      if (ueim_meas_id_list[count].meas_id == meas_id)
      {
        return INTERNAL_MEAS;
      }
    }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
    for ( count = 0; count < MAX_POS_MEAS; count++ )
    {
      if (pos_meas_id_list[count].meas_id == meas_id)
      {
        pos_info_ptr->pos_meas_cmd = RRC_MEAS_DELETE;
        return POSITION_MEAS;
      }
    }
#endif

    for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
    {
      if (quality_meas_id_list[count].meas_id == meas_id)
      {
        return QUALITY_MEAS;
      }
    }

    return NOT_EXIST;

  default:
    return UNKNOWN_MEAS;

  } /* End of switch */

}


#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_POS_MCM_R7

DESCRIPTION

 This function processes the Positioning Measurement Control Message and
 determines if it is a A-GPS or Cell Id or OTDOA Message. Depending upon that
 it configures either LSM or L1 with measurement parameters

DEPENDENCIES

 None

RETURN VALUE

 FAILURE:
 SUCCESS:

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_process_pos_mcm_r7
(
  void* msg_ptr,
  pos_info_struct_type* pos_info_ptr,
  uint8 meas_ctrl_tr_id
)
{

  /* Check if it is a Release */
  if (pos_info_ptr->pos_meas_cmd == RRC_MEAS_DELETE)
  {
    if (rrcgps_process_mcm_r7(msg_ptr, pos_info_ptr, meas_ctrl_tr_id) == SUCCESS)
      return SUCCESS;
    else
      return FAILURE;
  }

  /* Now route it */
  switch(pos_info_ptr->pos_method_type)
  {
  case RRC_GPS:
  case RRC_OTDOAorGPS:
    if (rrcgps_process_mcm_r7(msg_ptr, pos_info_ptr, meas_ctrl_tr_id) == SUCCESS)
      return SUCCESS;
    else
      return FAILURE;

  default:
    /* Not possible */
    break;


  } /* End of switch */
  return FAILURE;
}
#endif /* FEATURE_CGPS_UMTS_CP_WCDMA */

/*===========================================================================

FUNCTION          WCDMA_MFBI_IS_SUPPORTED

DESCRIPTION       This function indicates WCDMA MFBI Support by UE.

DEPENDENCIES      NONE

RETURN VALUE      TRUE if UE supports MFBI
                  FALSE if UE doesnt support MFBI.
                  
SIDE EFFECTS      NONE
===========================================================================*/
boolean wcdma_mfbi_is_supported(void)
{
#ifdef FEATURE_WCDMA_MULTI_FREQ_BAND_INDICATOR
  if(rrc_mfbi_support_nv)
  {
    return TRUE;
  }
#endif
  return FALSE;
}
/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_INTRAFREQ_R7

DESCRIPTION

 Processed Intra Freq Meas in Rel7 Meas Ctrl Message

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/
uecomdef_status_e_type rrcmeas_process_intrafreq_r7
(
  rrc_cmd_type* cmd_ptr,
  uint8 transaction_id
)
{
  /* Stores Meas parameters to be sent to L1 */
  l1_meas_ctrl_parm_struct_type *l1_mcm = rrc_malloc(sizeof(l1_meas_ctrl_parm_struct_type));

  /* Meas Validity */
  meas_validity_enum_type meas_validity = NOT_PRESENT;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  rrcmeas_layer_e_type primary_meas_type = INTRA_FREQ;
  
  rrc_MeasurementControl_r7_IEs* rrc_mcm_ptr = NULL;

  rrc_DL_DCCH_Message* dcch_msg_ptr = NULL;

  boolean addtl_meas_validation = FALSE;

  uint8 alloc_idx = MAXIMUM_TRANSACTIONS;
  dcch_msg_ptr = (rrc_DL_DCCH_Message *)cmd_ptr->cmd.
    downlink_sdu_ind.decoded_msg;
  
  rrc_mcm_ptr = &dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.u.r7.measurementControl_r7;

    /* Set trans Id in var trans_id */
  trans_id = l1_mcm->trans_id = transaction_id;

  /* Make Compressed Mode Status Information as invalid so that L1 is O.K. */
  l1_mcm->dpch_cm_status_incl = FALSE;
  /* Set Compressed Mode Information */
  if ((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r7_IEs,dpch_CompressedModeStatusInfo)) &&
    (rrc_mcm_ptr->dpch_CompressedModeStatusInfo.tgp_SequenceShortList.n != 0))
  {

    if (rrcmeas_process_compressed_mode_status(&rrc_mcm_ptr->dpch_CompressedModeStatusInfo,
      &l1_mcm->cm_status_info) == FAILURE)
    {
      /* Send Meas Ctrl Failure Message */

      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;

    }
    /* Set compressed Mode as TRUE */
    l1_mcm->dpch_cm_status_incl = TRUE;

  } /* End of if of compressed mode processing */

  /* Store MCM contents in a Local Ptr */
  /* Assign default value to Primary Meas Type */
  primary_meas_type = INTRA_FREQ;

  /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;


  switch ( rrc_mcm_ptr->measurementCommand.t )
  {
  case T_rrc_MeasurementCommand_r7_setup:

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r7_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

    }
    else
    {
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;
    }


    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_SETUP;

    /* Store meas type */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    l1_mcm->meas_object_info_included = TRUE;

    /* Check if meas quantity not present */
    /* Store Meas Quantity */
    if (!((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
      intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r7,intraFreqMeasQuantity)) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
      intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r7,intraFreqReportingQuantity)) &&
      (rrc_mcm_ptr->measurementCommand.u.setup->u.
      intraFrequencyMeasurement->m.reportCriteriaPresent)))
    {
      WRRC_MSG0_ERROR("Mandatory parameter for SETUP missing");
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;

    }

    if((RRC_CHECK_COMMON_MSG_TYPE(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
      reportCriteria,rrc_IntraFreqReportCriteria_r7_intraFreqReportingCriteria)) &&
      !(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
      reportCriteria.u.intraFreqReportingCriteria,
      rrc_IntraFreqReportingCriteria_r7,eventCriteriaList)))              
    {
       WRRC_MSG0_ERROR("event criteria for SETUP missing");
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;
    }

    /* Fill intra-freq meas quantity, meas validity, cell list, cell info */
    if ( (rrcmeas_fill_common_mcm_intra_f_info_r7(
      rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement, 
      l1_mcm)
      == RRCMEAS_FAIL))

    {
      rrc_free(l1_mcm);
      return FAILURE;
    }
    /* Process Additional Meas */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r7_IEs,additionalMeasurementList))
    {
      WRRC_MSG1_HIGH("MCM:Addtl Meas given for Id %d", rrc_mcm_ptr->measurementIdentity);

      /* Call fn which makes check for additional measurements */
      if (rrcmeas_validate_additional_meas(&rrc_mcm_ptr->additionalMeasurementList, transaction_id, &primary_meas_type,
        rrc_mcm_ptr->measurementIdentity) == FALSE)
      {
        /* Called function has already sent Meas Ctrl Failure */
        /* Retain the old CELL_INFO_LIST */
        WCDMA_MEMCPY(intra_freq_cell_list, 
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                     intra_freq_cell_list_temp,
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);
        rrc_free(l1_mcm);
        return FAILURE;
      }

      /* This means additional meas has been successfully validated */
      addtl_meas_validation = TRUE;

    } /* End of if of Additional Meas Present */

    if (rrcmeas_check_mcm_for_setup_modify_additional(
      addtl_meas_validation, INTRA_FREQ, rrc_mcm_ptr->measurementIdentity,
        &rrc_mcm_ptr->additionalMeasurementList) == FALSE)
    {
      rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
       rrc_free(l1_mcm);
      return FAILURE;

    }


    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r7,measurementValidity))
    {
      WRRC_MSG0_HIGH("Meas Validity present");
      /* Set it to CELL_DCH */
      meas_validity = STATE_DCH;
    }
    /* Time to store the Meas Id, validty, rpt criteria in RRC DB */
    if (rrcmeas_config_intra_freq_db(l1_mcm,meas_validity) == FALSE)
    {
      rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);

      rrc_free(l1_mcm);
      return FAILURE;
    }

    /* If we reached this stage, that means Meas Ctrl Msg is valid */

    /* Check if Additional Meas has been validated successfully. */
    /* If yes, then store all additional meas in RRC DB */
    if (addtl_meas_validation == TRUE)
    {
      rrcmeas_set_additional_meas_in_db(&primary_meas_type, &rrc_mcm_ptr->additionalMeasurementList,
        rrc_mcm_ptr->measurementIdentity);
      WRRC_MSG0_HIGH("Additional Meas set in RRC DB");
    }

    /* Time to store this in Accepted transaction list after break */

    break; /* Come out of switch */


  case T_rrc_MeasurementCommand_r7_modify:
    /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r7_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);
    }
    else
    {
      /* Store reporting mode to FALSE */
      l1_mcm->rpt_mode_incl = FALSE;
    }

    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_MODIFY;

    /* Set meas type to Intra-freq Meas */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.modify,
        rrc_MeasurementCommand_r7_modify,measurementType)))
    {
      WRRC_MSG1_HIGH("Meas Type for Meas %d absent O.K", l1_mcm->meas_id);

      l1_mcm->meas_object_info_included = FALSE;
    }
    else
    {
      l1_mcm->meas_object_info_included = TRUE;

      /* Fill intra-freq meas quantity, meas validity, cell list, cell info */
      if ((rrcmeas_fill_common_mcm_intra_f_info_r7(
        rrc_mcm_ptr->measurementCommand.u.modify->measurementType.u.intraFrequencyMeasurement,
        l1_mcm) == RRCMEAS_FAIL))
      {
        rrc_free(l1_mcm);
        return FAILURE;
      }

    } /* End of else of Meas Type Present */

        /* Process Additional Meas */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r7_IEs,additionalMeasurementList))
    {
      WRRC_MSG1_HIGH("MCM:Addtl Meas given for Id %d", rrc_mcm_ptr->measurementIdentity);

      /* Call fn which makes check for additional measurements */
      if (rrcmeas_validate_additional_meas(&rrc_mcm_ptr->additionalMeasurementList, transaction_id, &primary_meas_type,
        rrc_mcm_ptr->measurementIdentity) == FALSE)
      {
        /* Called function has already sent Meas Ctrl Failure */
        /* Retain the old CELL_INFO_LIST */
        WCDMA_MEMCPY(intra_freq_cell_list, 
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                     intra_freq_cell_list_temp,
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);
        rrc_free(l1_mcm);
        return FAILURE;
      }

      /* This means additional meas has been successfully validated */
      addtl_meas_validation = TRUE;

      if (rrcmeas_check_mcm_for_setup_modify_additional(
        addtl_meas_validation, INTRA_FREQ, rrc_mcm_ptr->measurementIdentity,
          &rrc_mcm_ptr->additionalMeasurementList) == FALSE)
      {
        rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
        rrc_free(l1_mcm);
        return FAILURE;
      }
    } /* End of if of Additional Meas Present */

    if ((l1_mcm->meas_object_info_included == TRUE) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.modify->measurementType.u.intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r7,measurementValidity)))

    {
      WRRC_MSG0_HIGH("Meas Validity present");
      /* No need to check value as by default validity is CELL_DCH and if it is not CELL_DCH,
      then assume it to be CELL_DCH so that it could be resumed on next trans to CELL_DCH */
      meas_validity = STATE_DCH;
    }

    if (rrcmeas_config_intra_freq_db(l1_mcm, meas_validity) == FALSE)
    {
      rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
       rrc_free(l1_mcm);
      return FAILURE;
    }

    /* If we reached this stage, that means Meas Ctrl Msg is valid */

    /* Check if Additional Meas has been validated successfully. */
    /* If yes, then store all additional meas in RRC DB */
    if (addtl_meas_validation == TRUE)
    {
      rrcmeas_set_additional_meas_in_db(&primary_meas_type, &rrc_mcm_ptr->additionalMeasurementList,
        rrc_mcm_ptr->measurementIdentity);
      WRRC_MSG0_HIGH("Additional Meas set in RRC DB");
    }


    break; /* Come out of switch */

  case T_rrc_MeasurementCommand_r7_release:
    /* With release meas, additional meas should not be present */
    /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r7_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

    }
    else
    {
      /* Store reporting mode to FALSE */
      l1_mcm->rpt_mode_incl = FALSE;
    }

    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_RELEASE;

    /* Store meas type */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    /* Delete Meas Id from Intra Freq Meas Id List */
    rrcmeas_delete_meas(&l1_mcm->meas_id);

    /* Delete additional meas */
    rrcmeas_delete_addtl_meas(&l1_mcm->meas_id);

    break;

  default:
    WRRC_MSG0_ERROR("Meas command t not possible");
    rrc_free(l1_mcm);
    return FAILURE;

  }
  
  alloc_idx = rrcmeas_get_int_trans_index_for_trans_id(transaction_id);
  l1_mcm->trans_id = alloc_idx;
  rrcmeas_send_l1_cmd(NULL, l1_mcm, NULL, L1_MEAS_CTRL_PARMS);
  
  rrc_free(l1_mcm);
  return SUCCESS;
}

/*===========================================================================

FUNCTION  RRCMEAS_FILL_COMMON_MCM_INTRA_F_INFO_R7

DESCRIPTION

 This function fills in common Cell Info for meas setup and
 meas modify command type in a Measurement Control Message.
 The function processes Cell Info in ASN1 format and translates
 into the L1RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill common mcm info correctly
 SUCCESS: If common mcm info filled correctly

SIDE EFFECTS

 None

===========================================================================*/

rrcmeas_status_e_type rrcmeas_fill_common_mcm_intra_f_info_r7
(
rrc_IntraFrequencyMeasurement_r7* intra_f_meas_ptr,
l1_meas_ctrl_parm_struct_type *l1_mcm
)
{
  uint16 cell_count = 0;
  uint16 freq_idx = 0;
  l1_intra_freq_meas_ctrl_struct_type* l1_intra_f_mcm_ptr = &l1_mcm->meas_object.u.intra_f;

  uint8  meas_id_idx = rrcmeas_find_meas_id_idx(l1_mcm->meas_id);

  WCDMA_MEMCPY(intra_freq_cell_list_temp, 
               sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
               intra_freq_cell_list,
               sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);


  /* Assign default values */
  l1_intra_f_mcm_ptr->meas_quan_incl = FALSE;
  l1_intra_f_mcm_ptr->meas_quan.quan_type = L1_MEAS_NONE;

  /* Assign Default value to filter coefficient 0 */
  l1_intra_f_mcm_ptr->meas_quan.filter_coef = 0;

  /* Store Meas Quantity */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr,
    rrc_IntraFrequencyMeasurement_r7,intraFreqMeasQuantity))
  {
    /* Check if meas quan is for fdd */
    if (RRC_CHECK_COMMON_MSG_TYPE(intra_f_meas_ptr->
      intraFreqMeasQuantity.modeSpecificInfo,
      rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd ))
    {
      /* Intra freq meas quantity for FDD mode is present */
      l1_intra_f_mcm_ptr->meas_quan_incl = TRUE;

      /* So read the value of meas quantity and filter coefficient */
      l1_intra_f_mcm_ptr->meas_quan.quan_type =
        RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
        intra_f_meas_ptr->
        intraFreqMeasQuantity.modeSpecificInfo.u.fdd->intraFreqMeasQuantity_FDD);

        /* Check if rrc_IntraFreqMeasQuantity_filterCoefficient) */
    
        /* Store filter coefficient */
        l1_intra_f_mcm_ptr->meas_quan.filter_coef = (uint16)
          RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(intra_f_meas_ptr->
          intraFreqMeasQuantity.filterCoefficient);
    

    } /* End of if for rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd  */

  } /* End of if of intra freq meas quantity not present */

  /* Initialize no of added, removed cells to 0, cell_incl to FALSE */
  for(freq_idx = 0; freq_idx < MAX_NUM_CARR; freq_idx++)
  {
    /* Initialize no of added, removed cells to 0, cell_incl to FALSE */
    l1_intra_f_mcm_ptr->cell_list_incl[freq_idx] = FALSE;
    l1_intra_f_mcm_ptr->cell_list[freq_idx].num_cell_add = 0;
    l1_intra_f_mcm_ptr->cell_list[freq_idx].num_cell_rmv = 0;

    /* Print first few elements of the list for debugging purposes */
    for (cell_count = 0; cell_count < (L1_MAX_CELL_MEAS - 20); cell_count++)
    {
      MSG_MED("Cell list %d element is %d, psc = %d", cell_count,
      intra_freq_cell_list[freq_idx][cell_count].cell_position,
      intra_freq_cell_list[freq_idx][cell_count].psc);
    }
   cell_count = 0;
  }

  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr,
      rrc_IntraFrequencyMeasurement_r7,intraFreqCellInfoList))
  {
    if(RRCMEAS_FAIL == rrcmeas_process_mcm_intra_f_cell_info_r5(&intra_f_meas_ptr->intraFreqCellInfoList, l1_intra_f_mcm_ptr))
    {
      return RRCMEAS_FAIL;
    }
  } /* End of intra freq cell info list present */

  /* Assign default values for intra-f reporting quantity */
  l1_intra_f_mcm_ptr->intra_f_rpt_quan_incl = FALSE;

  /* Check if intra-f reporting quantity present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr, rrc_IntraFrequencyMeasurement_r7,intraFreqReportingQuantity))
  {
    if ( (rrcmeas_fill_intra_freq_rep_quan(&intra_f_meas_ptr->intraFreqReportingQuantity,
      l1_intra_f_mcm_ptr)) == SUCCESS )
      l1_intra_f_mcm_ptr->intra_f_rpt_quan_incl = TRUE;
  }

  /* Initialize rpt_mode to no change */
   l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_NO_CHANGE;

  /* Set reporting cell status to FALSE */
   l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = FALSE;
  l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[PRI_FREQ] = FALSE;

#ifdef FEATURE_WCDMA_DC_HSUPA
  /* N/W may configure modify from R9 to pre R9 
   * Configure rpt crit accordingly  */
  if(CHECK_RPT_CRIT_NOT_PRESENT(SEC_FREQ))
  {
  l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_RPT_MODE_NOT_PRESENT;
    if(meas_id_idx < MAX_INTRA_FREQ_MEAS)
    {
      intra_freq_meas_id_list[meas_id_idx].rpt_crit[SEC_FREQ] = NOT_AVAILABLE;
    }
  }
  else
  {
    l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_NO_CHANGE;   
  }

  /* Set reporting cell status to FALSE */
  l1_intra_f_mcm_ptr->rpt_cell_status_incl[SEC_FREQ] = FALSE;

  /* Set reporting crit incl to FALSE */
  l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[SEC_FREQ] = FALSE;
#endif

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr, rrc_IntraFrequencyMeasurement_r7,reportCriteria))
  {
    /* Check report criteeria type */
    switch (intra_f_meas_ptr->reportCriteria.t)
    {
    case T_rrc_IntraFreqReportCriteria_r7_intraFreqReportingCriteria:
  
      /* Set rpt mode criteria */
  
      /* Check if Event triggered intraFreqReportingCriteria list present */
  
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.
        intraFreqReportingCriteria,rrc_IntraFreqReportingCriteria_r7,eventCriteriaList))
      {
        /* Set event parameters */
         l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].num_event =
          rrcmeas_fill_intra_freq_event_criteria_r7(
           intra_f_meas_ptr->reportCriteria.u.intraFreqReportingCriteria, l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].evt);
         l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_EVENT_TRIGGER_RPT;
  
      } /* End of if for event criteria list present */
      else
      {
        MSG_LOW("Setting num_event to 0", 0,0,0);
        /* So set num_event in L1 structure to 0 */
  
         l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].num_event = 0;
      }
  
      break; /* Come out of switch */
  
    case T_rrc_IntraFreqReportCriteria_r7_periodicalReportingCriteria:
  
      /* Set rpt mode criteria */
       l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_PERIODIC_RPT;
  
  
      /* Set reporting cells */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria,
        rrc_PeriodicalWithReportingCellStatus,reportingCellStatus))
      {
        if (rrcmeas_fill_no_of_reporting_cells(&intra_f_meas_ptr->reportCriteria.u.
          periodicalReportingCriteria->reportingCellStatus,
          & l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ]) == SUCCESS)
        {
           l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = TRUE;
        }
      }
  
      l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[PRI_FREQ] = TRUE;
      /* Store reporting amount */
      l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_amount=
        RRCMEAS_RET_REPORTING_AMOUNT(
        intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->
        periodicalReportingCriteria.reportingAmount);
     
  
      /* Store reporting interval */
      l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_interval =
        RRCMEAS_RET_PERIODIC_REPORTING_INTERVAL
        (intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->periodicalReportingCriteria.reportingInterval);
  
      if (intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->
        periodicalReportingCriteria.reportingInterval == rrc_ReportingIntervalLong_ril0)
      {
        l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_interval = 250;
      }
  
      break; /* Come out of switch */
  
  
    case T_rrc_IntraFreqReportCriteria_r7_noReporting:
  
       l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_NO_RPT;
  
      /* Set reporting cell status to FALSE */
       l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = FALSE;
  
      if ((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.noReporting,
        rrc_ReportingCellStatusOpt,reportingCellStatus))  &&
        ( rrcmeas_fill_no_of_reporting_cells(&intra_f_meas_ptr->reportCriteria.u.noReporting->reportingCellStatus,
        & l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ]) == SUCCESS ))
      {
         l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = TRUE;
      }
  
      break;
  
    default:
      return RRCMEAS_FAIL;
  
    } /* End of switch */
  
  
    if (( l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] == TRUE) &&
      (( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_VASET) ||
      ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_MSET_NUSED_FREQ) ||
      ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_ASET_MSET_NUSED_FREQ) ||
      ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_ALL_VASET_AND_MSET_NUSED_FREQ)))
    {
      WRRC_MSG1_ERROR("Rpt Cell Status invalid %d",  l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat);
      /* Retain the old CELL_INFO_LIST */
      WCDMA_MEMCPY(intra_freq_cell_list, 
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                   intra_freq_cell_list_temp,
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);

      return RRCMEAS_FAIL;
    }
  }
  return RRCMEAS_SUCCESS;
}

/*===========================================================================

FUNCTION     RRCMEAS_FILL_INTRA_FREQ_EVENT_CRITERIA_R7

DESCRIPTION

 This function fills in intra-freq event criteria for a Non-HCS cell when
 Cell Selection Reselection Quality Measure is RCSP or ECNO for R7 Message
 The function processes intra-ftreq event criteria Info in ASN1 format
 and translates into the L1 RRC Interface format.

DEPENDENCIES

 The passed pointers must be valid.

RETURN VALUE

 No of events.

SIDE EFFECTS

 None

===========================================================================*/

uint16 rrcmeas_fill_intra_freq_event_criteria_r7
(
  rrc_IntraFreqReportingCriteria_r7  *rrc_intra_freq_reporting_criteria_ptr,
  l1_intra_freq_event_crit_struct_type *l1_intra_freq_event_crit_ptr
)
{
  /* To store cell list for 1a or 1b if present */
  rrc_ForbiddenAffectCellList_r4 *forbidden_affect_cell_list_ptr = NULL;

  /* Stores ptr to passed rrc_IntraFreqEventCriteriaList */
  rrc_IntraFreqEventCriteriaList_r7  *rrc_intra_freq_event_criteria_list_ptr = NULL;

  rrc_PeriodicReportingInfo_1b *periodicReportingInfo_1b;
  /* Counts forbidden cell count */
  uint16 forbidden_cell_list_count = 0;
  uint32 idx=0,idy=0;
  /* To satisfy LINT as e1a, e1b values would be stored here first */
  l1_intra_freq_event_enum_type event_type;

  /* Counts no of events */
  uint16 event_count = 0;

  /* Store event crit list ptr */
  rrc_intra_freq_event_criteria_list_ptr = &rrc_intra_freq_reporting_criteria_ptr->eventCriteriaList;

  if ( rrc_intra_freq_event_criteria_list_ptr->n == 0)
  {
    MSG_LOW("Intra-freq event criteria list is empty", 0,0,0);
    return event_count;
  }

  /* ReportingRange, Hystersis, W converted by L1 */
  /* Store now the first event reporting criteria value from the list */
  while ( (rrc_intra_freq_event_criteria_list_ptr->n > idx) &&
    (event_count < L1_INTRA_FREQ_MAX_NUM_EVENT) )
  {

    /* First get the event ID */
    switch ( rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.t )
    {
      case T_rrc_IntraFreqEvent_r7_e1a:
        event_type = L1_INTRA_FREQ_EVENT_1A;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store triggering condition */

        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->
          triggeringCondition);

        /* Store Reporting Range */
        l1_intra_freq_event_crit_ptr[event_count].rpt_range = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingRange;

        /* Store no of cells forbidden to affect reporting range */
        if (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->m.forbiddenAffectCellListPresent)
        {
          /* Now store the scrambling code for each cell */

          forbidden_affect_cell_list_ptr =
            &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->forbiddenAffectCellList;

          idy=0;
          while ( (forbidden_affect_cell_list_ptr->n > idy) &&
            (forbidden_cell_list_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is non-NULL and forbidden cell count hasn't exceeded
            * the maximum. So keep on counting */

            if ( forbidden_affect_cell_list_ptr->elem[idy].t ==
              T_rrc_ForbiddenAffectCell_r4_tdd )
            {
              /* Set pointer value to next */
              idy++;

              continue;

            }
            else
            {
              /* Store scrambling code */
              l1_intra_freq_event_crit_ptr->forbidden_cell_scr_code[forbidden_cell_list_count] = (uint16)
                forbidden_affect_cell_list_ptr->elem[idy].u.fdd->primaryScramblingCode;

              /* Now increment count and store ptr to next value */
              forbidden_cell_list_count++;
              idy++;


              if ( (forbidden_cell_list_count == L1_MAX_CELL_MEAS) &&
                (forbidden_affect_cell_list_ptr->n > idy) )
              {

                MSG_LOW("Cannot include all forbidden cells", 0,0,0);
                break;
              }
            } /* End of else */

          } /* End of while of forbidden_affect_cell_list_ptr != NULL */

          /* Now store the number of forbidden affect cells in l1 struct */

          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = forbidden_cell_list_count;
        } /* End of if for forbidden_affect_cell_list actually present */

        else
        { /* forbidden_affect_cell_list actually absent */
          /* Set as per L1 req */
          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = 0;
        }

        /* Now store rest of the parameters of event 1a */

        /* Store WEIGHT */

        /* Use this to verify  rrc_intra_freq_event_criteria_list_ptr   */
        l1_intra_freq_event_crit_ptr[event_count].w = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->w;

        /* Store deactivation threshold */
        l1_intra_freq_event_crit_ptr[event_count].rpt_deact_thresh =
          RRCMEAS_RET_DEACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportDeactivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingInterval);

        MSG_HIGH("1A:RptAmt %d,RptIntvl %dms,Deacthresh %d",
         l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_deact_thresh);


        break; /* Come out of switch and return SUCCESS */

      case T_rrc_IntraFreqEvent_r7_e1b:
        event_type = L1_INTRA_FREQ_EVENT_1B;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store triggering condition 1 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_1(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->triggeringCondition);

        /* Store Reporting Range */
        l1_intra_freq_event_crit_ptr[event_count].rpt_range = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->reportingRange;

        /* Initialize reporting intvl to 0 */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl = 0;

        /* Initialize no of rpts to 0 */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt = 0;

        if (!(rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->m.periodicReportingInfo_1bPresent))
        {
          MSG_LOW("Event 1B Periodic reporting info absent",0,0,0);
        }
        else
        {
          periodicReportingInfo_1b = &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->periodicReportingInfo_1b;
          /* Store reporting interval */
          l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          periodicReportingInfo_1b->reportingInterval);

          l1_intra_freq_event_crit_ptr[event_count].num_rpt =
            RRCMEAS_RET_REPORTING_AMOUNT(periodicReportingInfo_1b->reportingAmount);
        }

        WRRC_MSG2_HIGH("Event 1B RptIntvl %d ms, Num rpt %d",
                 l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt);

        if ( rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->m.forbiddenAffectCellListPresent )
        {
          /* Now store the scrambling code for each cell */

          forbidden_affect_cell_list_ptr =
            &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->
            forbiddenAffectCellList;

          idy=0;
          while ( (forbidden_affect_cell_list_ptr->n > idy) &&
            (forbidden_cell_list_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is non-NULL and forbidden cell count hasn't exceeded
            the maximum. So keep on counting */

            if ( forbidden_affect_cell_list_ptr->elem[idy].t ==
              T_rrc_ForbiddenAffectCell_r4_tdd )
            {
              idy++;
              continue;

            }
            else
            {
              /* Store scrambling code */
              l1_intra_freq_event_crit_ptr[event_count].
                forbidden_cell_scr_code[forbidden_cell_list_count] = (uint16)
                forbidden_affect_cell_list_ptr->elem[idy].u.fdd->primaryScramblingCode;

              /* Now increment count and store ptr to next value */
              forbidden_cell_list_count++;

              idy++;

              if ( (forbidden_cell_list_count == L1_MAX_CELL_MEAS) &&
                (forbidden_affect_cell_list_ptr->n > idy) )
              {

                MSG_LOW("Cannot include all the forbidden cells", 0,0,0);
                break;
              }
            } /* End of else */

          } /* End of while of forbidden_affect_cell_list_ptr != NULL */

          /* Now store the number of forbidden affect cells in l1 struct */

          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
            forbidden_cell_list_count;
        } /* End of if for forbidden_affect_cell_list actually present */

        else
        { /* forbidden_affect_cell_list actually absent */
          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = 0;
        }

        /* Store WEIGHT */

        l1_intra_freq_event_crit_ptr[event_count].w = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->w;

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_r7_e1c:
        event_type = L1_INTRA_FREQ_EVENT_1C;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store replacement activation threshold */

        l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh =
          RRCMEAS_RET_REPLACEMENT_ACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          replacementActivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          reportingInterval);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;

        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        MSG_HIGH("1C:RptAmt %d,RptIntvl %dms,Deacthresh %d",
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh);

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_r7_e1d:
        event_type = L1_INTRA_FREQ_EVENT_1D;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        l1_intra_freq_event_crit_ptr[event_count].evt_1d_trig_cond_incl = FALSE;

        l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl = FALSE;

        if (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1d->m.
            triggeringConditionPresent)
        {
          l1_intra_freq_event_crit_ptr[event_count].evt_1d_trig_cond_incl = TRUE;

          l1_intra_freq_event_crit_ptr[event_count].trig_cond =
          (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1d->
                                             triggeringCondition);

          MSG_LOW("Event 1D trig cond 0:ASET/1:MSET %d",
                   l1_intra_freq_event_crit_ptr[event_count].trig_cond,0,0);

        }
        if ((rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1d->m.useCIOPresent)
          && (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1d->useCIO == TRUE))
        {
          l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl = TRUE;
        }

        break; /* Come out of switch and return SUCCESS */

      case T_rrc_IntraFreqEvent_r7_e1e:
        event_type = L1_INTRA_FREQ_EVENT_1E;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store the threshold used frequency */
        l1_intra_freq_event_crit_ptr[event_count].freq_thresh = (int16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1e->thresholdUsedFrequency;

        /* Store triggering condition 2 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1e->
          triggeringCondition);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_r7_e1f:
        event_type = L1_INTRA_FREQ_EVENT_1F;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store the threshold used frequency */
        l1_intra_freq_event_crit_ptr[event_count].freq_thresh = (int16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1f->thresholdUsedFrequency;

        /* Store triggering condition 1 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_1(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1f->
          triggeringCondition);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        break; /* Come out of switch  */

      case T_rrc_IntraFreqEvent_r7_e1j:
        event_type = L1_INTRA_FREQ_EVENT_1J;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store replacement activation threshold */

        l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh =
          RRCMEAS_RET_REPLACEMENT_ACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1j->
          replacementActivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1j->
          reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1j->
          reportingInterval);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;

        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        MSG_HIGH("1J:RptAmt %d,RptIntvl %dms,Deacthresh %d",
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh);

      
        break;

      default:
        MSG_LOW("Invalid event type",0,0,0);
    } /* End of switch */

    /* Now store hsyterisis */
    l1_intra_freq_event_crit_ptr[event_count].hyst = (uint16)
      rrc_intra_freq_event_criteria_list_ptr->elem[idx].hysteresis;

    /* Now store timeToTrigger */

    l1_intra_freq_event_crit_ptr[event_count].time_to_trig =
      RRCMEAS_RET_TIME_TO_TRIGGER(rrc_intra_freq_event_criteria_list_ptr->elem[idx].timeToTrigger);

    /* Now store reporting cell status which is optional */
    /* Initialize Cell status information to FALSE */
    l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status_incl = FALSE;


    if (RRC_MSG_LIST_BITMASK_IE(rrc_intra_freq_event_criteria_list_ptr,
      rrc_IntraFreqEventCriteria_r7,reportingCellStatus) )
    {
      MSG_LOW("Reporting cell status present", 0,0,0);

      /* Call a function which stores all the information. */
      if ( rrcmeas_fill_no_of_reporting_cells(
        & rrc_intra_freq_event_criteria_list_ptr->elem[idx].reportingCellStatus,
        & l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status) == SUCCESS )
      {
        l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status_incl = TRUE;
      }
    } /* End of rrc_IntraFreqEventCriteria_reportingCellStatus) present */

    /* Now increment the event count and the ptr to next value */
    event_count++;
    idx++;

    if ( (event_count == L1_INTRA_FREQ_MAX_NUM_EVENT) &&
      (rrc_intra_freq_event_criteria_list_ptr->n >idx) )
    {
      break; /* Come out of while */
    }

  } /* End of while intra_freq_event_criteria_list_ptr != NULL */

  return event_count;

}

/*===========================================================================

FUNCTION   rrcmeas_process_mcm_r8

DESCRIPTION

    This function processed the Release 8 Meas Ctrl Message

DEPENDENCIES

    None

RETURN VALUE
   Void


SIDE EFFECTS

    None

===========================================================================*/

void rrcmeas_process_mcm_r8
(
  rrc_cmd_type *cmd_ptr,
  uint8 meas_ctrl_tr_id
)
{
  rrc_MeasurementControl_r8_IEs* mcm_ptr = NULL;

  rrc_DL_DCCH_Message* dcch_msg_ptr = NULL;

  /* Local var to store meas variable */
  rrcmeas_layer_e_type meas_owner;

  /* To store OC SET Status */
  rrcllc_oc_set_status_e_type oc_set_state;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  /* Local Variable to store meas id */
  uint32 meas_id;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  pos_info_struct_type pos_info;
#endif /*FEATURE_CGPS_UMTS_CP_WCDMA*/

  /* Store the message. No need to check again */
  dcch_msg_ptr = (rrc_DL_DCCH_Message *)cmd_ptr->cmd.
    downlink_sdu_ind.decoded_msg;

  /* Store actual mcm ptr in a local variable */
  mcm_ptr = &dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.measurementControl_r8;

  meas_id = mcm_ptr->measurementIdentity;

  /* Retrieve the Meas Owner */
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  meas_owner = rrcmeas_retrieve_meas_owner_r8(&mcm_ptr->measurementCommand,
    meas_id, &pos_info);
#else /*FEATURE_CGPS_UMTS_CP_WCDMA*/
  meas_owner = rrcmeas_retrieve_meas_owner_r8(&mcm_ptr->measurementCommand,
    meas_id);
#endif /*FEATURE_CGPS_UMTS_CP_WCDMA*/

  /* Get OC status */
  oc_set_state = rrcllc_get_ordered_config_status();

  MSG_HIGH("REL8: meas id %d, meas owner %d, oc_state %d",meas_id, meas_owner, oc_set_state);

  if ((((meas_owner == INTRA_FREQ) || (meas_owner == INTERNAL_MEAS)|| (meas_owner == INTER_FREQ) ||
    (meas_owner == INTER_SYS)) && (rrcmeas_current_substate != RRCMEAS_CELL_DCH))
    || ((oc_set_state == OC_SET_FOR_DCH_CELL_PCH_TRANS) || (oc_set_state == OC_SET_FOR_DCH_URA_PCH_TRANS)))
  {
    return;
  }

  if((meas_owner != UNKNOWN_MEAS)&& (meas_owner != NOT_EXIST))
  {
    rrcmeas_check_meas_id_used_for_different_meas_type(meas_owner, meas_id);
  }
  if (meas_owner == UNKNOWN_MEAS)
  {
    /* Send Meas Ctrl Failure Message */

    rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

    /* Set error t */
    rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

    if (pos_meas_failure == TRUE)
    {
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
      pos_meas_failure = FALSE;
    }

#endif

    /* Send MCF msg to UTRAN */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

    return;
  }

  if (meas_owner == NOT_EXIST)
  { 
    if(mcm_ptr->measurementCommand.t != T_rrc_MeasurementCommand_r8_release)
    {
      /* Send Meas Ctrl Failure Message */

      rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

      if (pos_meas_failure == TRUE)
      {
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
        pos_meas_failure = FALSE;
      }

#endif

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
    }
    else
    {
      WRRC_MSG0_HIGH("Ignore MCM release for an nonexistent measurement, do not send MCM failure");
    }
    return;
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == INTRA_FREQ)
  {
    if (rrcmeas_process_intrafreq_r8(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      return;
    }
    else
    {
      return;
    }
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == INTER_FREQ)
  {
    if (rrcifreq_process_mcm_r8(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if((!process_interfreq_interrat_meas_rel7) && (!process_interfreq_uei_meas_rel7))
      {
        return;
      }
      return;
    }
    else
    {
      return;
    }
  }
  else if (meas_owner == MAC_MEAS)
  {
    if (rrctvm_process_traffic_vol_info_r8(cmd_ptr, meas_ctrl_tr_id) == TVM_SUCCESS)
    {
      return;
    }
    else
    {

      return;
    }
  }
  else if (meas_owner == INTER_SYS)
  {
    if (rrcirat_process_mcm_r8(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if(!process_interfreq_interrat_meas_rel7)
      {
        return;
      }
      return;
    }
    else
    {
      return;
    }
  }
  else if (meas_owner == INTERNAL_MEAS)
  {
    if (rrcueim_process_mcm_r8(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if((!process_interfreq_interrat_meas_rel7) && (!process_interfreq_uei_meas_rel7))
      {
        return;
      }

      return;
    }
    else
    {
      return;
    }
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == QUALITY_MEAS)
  {
    if (rrcqm_process_mcm_r8(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      return;
    }
    else
    {
      return;
    }
  }
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  else if ( meas_owner ==  POSITION_MEAS)
  {
    if (rrcmeas_process_pos_mcm_r8(cmd_ptr->cmd.
      downlink_sdu_ind.decoded_msg, &pos_info, meas_ctrl_tr_id) == SUCCESS)
    {
      MSG_LOW("REL8:POS: MCM successfully processed",0,0,0);
    }
    else
    {
      MSG_LOW("REL8:POS: MCM not processed successfully",0,0,0);
    }
    return;
  } /* End of if of Positioning Measurements */
#endif
  else
  {
    /* Set transaction ID */
    rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

    /* Set error t */
    rrcmeas_mcf.error_choice =
      T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

    /* Send RRC Meas Ctrl Failure msg to UTRAN */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
  }

}


/*===========================================================================
FUNCTION   RRCMEAS_RETRIEVE_MEAS_OWNER_R8

DESCRIPTION

 Finds the owner of measurement identity given in a MCM Rel 7 Msg

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/

rrcmeas_layer_e_type rrcmeas_retrieve_meas_owner_r8
(
rrc_MeasurementCommand_r8* mcm_ptr,
uint32 meas_id
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
,pos_info_struct_type* pos_info_ptr
#endif
)
{
  uint8 count = 0;

  boolean meas_found = FALSE;
  /* First find if Meas is Setup/Modify/Delete */
  switch(mcm_ptr->t)
  {
  case T_rrc_MeasurementCommand_r8_setup:
    WRRC_MSG1_HIGH("REL8:MCM Setup: Meas ==> %d",mcm_ptr->u.setup->t);  	
    if (mcm_ptr->u.setup->t ==
      T_rrc_MeasurementType_r8_trafficVolumeMeasurement)
    {
      return MAC_MEAS;
    }
    else
    {
      /* Find the actual L1 owner */

      if (mcm_ptr->u.setup->t ==
          T_rrc_MeasurementType_r8_intraFrequencyMeasurement)
      {
        return INTRA_FREQ;
      }
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r8_interRATMeasurement)
      {
        return INTER_SYS;
      }

      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r8_interFrequencyMeasurement)
      {
        return INTER_FREQ;
      }
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r8_ue_InternalMeasurement)
      {
        return INTERNAL_MEAS;
      }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r8_up_Measurement)
      {
        /* Also check in reporting quantity what type of meas is that */
        if ((mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.
          positioningMethod == rrc_PositioningMethod_otdoa) ||
          (mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.
          positioningMethod == rrc_PositioningMethod_cellID))
        {
          WRRC_MSG1_ERROR("REL8:PosMethod=%d unsupported 0/1/2/3 OTD/G/Both/Id",
            mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.positioningMethod);
          return UNKNOWN_MEAS;
        }
        /* Store position method and pos cmd */
        pos_info_ptr->pos_meas_cmd = RRC_MEAS_SETUP;
        pos_info_ptr->pos_method_type = RET_POS_METHOD
          (mcm_ptr->u.setup->u.up_Measurement->
          ue_positioning_ReportingQuantity.positioningMethod);

        return POSITION_MEAS;
      }
#endif

      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r8_qualityMeasurement)
      {
        return QUALITY_MEAS;
      }
      else
      {
        /* Else some other Meas */
        return UNKNOWN_MEAS;
      }
    }

  case T_rrc_MeasurementCommand_r8_modify:
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(mcm_ptr->u.modify,
      rrc_MeasurementCommand_r8_modify,measurementType))
    {
      WRRC_MSG1_HIGH("REL8:MCM:Modify, Meas Type included %d",mcm_ptr->u.modify->measurementType.t);

      if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r8_trafficVolumeMeasurement)
      {
        for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
        {
          if (tvm_meas_id_list[count].meas_id == meas_id)
          {
            return MAC_MEAS;
          } /* End of if of meas_identity found */

        } /* End of for loop  */

        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      } /* End of if of Traffic Volume Meas */

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r8_interRATMeasurement)
      {
        for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
        {
          if (inter_rat_meas_id_list[count].meas_id == meas_id)
          {
            return INTER_SYS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r8_ue_InternalMeasurement)
      {
        for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
        {
          if (ueim_meas_id_list[count].meas_id == meas_id)
          {
            return INTERNAL_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r8_interFrequencyMeasurement)
      {
        for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
        {
          if (inter_freq_meas_id_list[count].meas_id == meas_id)
          {
            return INTER_FREQ;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r8_intraFrequencyMeasurement)
      {
        for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
        {
          if (intra_freq_meas_id_list[count].meas_id == meas_id)
          {
            return INTRA_FREQ;
          }

        } /* End of for loop */
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }

      } /* End of else if */

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      else if (mcm_ptr->u.modify->
        measurementType.t ==
        T_rrc_MeasurementType_r8_up_Measurement)
      {
        for ( count = 0; count < MAX_POS_MEAS; count++ )
        {
          if (pos_meas_id_list[count].meas_id == meas_id)
          {
            /* Store position method and pos cmd */
            pos_info_ptr->pos_meas_cmd = RRC_MEAS_MODIFY;
            pos_info_ptr->pos_method_type =
              RET_POS_METHOD(mcm_ptr->u.modify->measurementType.u.up_Measurement->
              ue_positioning_ReportingQuantity.positioningMethod);

            return POSITION_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
#endif

      else if (mcm_ptr->u.modify->
        measurementType.t ==
        T_rrc_MeasurementType_r8_qualityMeasurement)
      {
        for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
        {
          if (quality_meas_id_list[count].meas_id == meas_id)
          {
            return QUALITY_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
      else
      {
        return UNKNOWN_MEAS;
      }

    } /* End of if of modify  rrc_measurementType_present */
    else
    { /* Since Meas Type is not given. It must exist at UE.
      If not then send an error msg indicating
      unsupported measurement */

      /* First search in L1 Measurement ID List */

      for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
      {
        if (intra_freq_meas_id_list[count].meas_id == meas_id)
        {
          return INTRA_FREQ;
        }

      } /* End of for loop */

      /* Search in Traffic Volume List */

      for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
      {
        if (tvm_meas_id_list[count].meas_id == meas_id)
        {
          return MAC_MEAS;
        } /* End of if of meas_identity found */

      } /* End of for loop */


      for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
      {
        if (inter_rat_meas_id_list[count].meas_id == meas_id)
        {
          return INTER_SYS;
        }

      }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      for ( count = 0; count < MAX_POS_MEAS; count++ )
      {
        if (pos_meas_id_list[count].meas_id == meas_id)
        {
          pos_info_ptr->pos_meas_cmd = RRC_MEAS_MODIFY;
          pos_info_ptr->pos_method_type = pos_meas_id_list[count].pos_method_type;
          return POSITION_MEAS;
        }

      }
#endif
      for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
      {
        if (inter_freq_meas_id_list[count].meas_id == meas_id)
        {
          return INTER_FREQ;
        }
      }

      for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
      {
        if (ueim_meas_id_list[count].meas_id == meas_id)
        {
          return INTERNAL_MEAS;
        }

      }

      for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
      {
        if (quality_meas_id_list[count].meas_id == meas_id)
        {
          return QUALITY_MEAS;
        }
      }
      return UNKNOWN_MEAS;

    } /* End of else of meas_type not present */


  case T_rrc_MeasurementCommand_r8_release:
    WRRC_MSG0_HIGH("REL8:MCM Release");
    /* First search in L1 Measurement ID List */

    for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
    {
      if (intra_freq_meas_id_list[count].meas_id == meas_id)
      {
        return INTRA_FREQ;
      }

    } /* End of for loop */

    /* Search in Traffic Volume List */

    for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
    {
      if (tvm_meas_id_list[count].meas_id == meas_id)
      {
        return MAC_MEAS;
      } /* End of if of meas_identity found */

    } /* End of for loop */


    for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
    {
      if (inter_rat_meas_id_list[count].meas_id == meas_id)
      {
        return INTER_SYS;
      }

    }

    for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
    {
      if (inter_freq_meas_id_list[count].meas_id == meas_id)
      {
        return INTER_FREQ;
      }
    }

    for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
    {
      if (ueim_meas_id_list[count].meas_id == meas_id)
      {
        return INTERNAL_MEAS;
      }

    }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
    for ( count = 0; count < MAX_POS_MEAS; count++ )
    {
      if (pos_meas_id_list[count].meas_id == meas_id)
      {
        pos_info_ptr->pos_meas_cmd = RRC_MEAS_DELETE;
        return POSITION_MEAS;
      }

    }
#endif

    for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
    {
      if (quality_meas_id_list[count].meas_id == meas_id)
      {
        return QUALITY_MEAS;
      }
    }
    return NOT_EXIST;

  default:
    return UNKNOWN_MEAS;

  } /* End of switch */

}


/*===========================================================================
FUNCTION   RRCMEAS_MEAS_CTRL_FAIL_ACTION

DESCRIPTION

 Process the actions to be sent in measurement control failure message

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/
void rrcmeas_meas_ctrl_fail_action(uint8 transaction_id, uint32 meas_err_cause)
{
  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  /* Retain the old CELL_INFO_LIST */
  WCDMA_MEMCPY(intra_freq_cell_list, 
               sizeof(intra_freq_cell_list_struct_type) * MAX_NUM_CARR * L1_MAX_CELL_MEAS,
               intra_freq_cell_list_temp,
               sizeof(intra_freq_cell_list_struct_type) * MAX_NUM_CARR * L1_MAX_CELL_MEAS);

  /* As UTRAN tried to configure more than 4 Addtl Meas */
  WRRC_MSG0_HIGH("REL8:Sending Meas Ctrl Failure");
  
  rrcmeas_mcf.rrc_transaction_id = transaction_id;
  
  /* Set error t */
  rrcmeas_mcf.error_choice = meas_err_cause;
  
  /* Send MCF msg to UTRAN */
  rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
}



/*===========================================================================
FUNCTION   RRCMEAS_PROCESS_INTRAFREQ_R8

DESCRIPTION

 Processed Intra Freq Meas in Rel8 Meas Ctrl Message

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/
uecomdef_status_e_type rrcmeas_process_intrafreq_r8
(
  rrc_cmd_type* cmd_ptr,
  uint8 transaction_id
)
{
  /* Stores Meas parameters to be sent to L1 */
  l1_meas_ctrl_parm_struct_type *l1_mcm = rrc_malloc(sizeof(l1_meas_ctrl_parm_struct_type));

  /* Meas Validity */
  meas_validity_enum_type meas_validity = NOT_PRESENT;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  rrcmeas_layer_e_type primary_meas_type = INTRA_FREQ;
  
  rrc_MeasurementControl_r8_IEs* rrc_mcm_ptr = NULL;

  rrc_DL_DCCH_Message* dcch_msg_ptr = NULL;

  boolean addtl_meas_validation = FALSE;

  uint8 alloc_idx = MAXIMUM_TRANSACTIONS;
  dcch_msg_ptr = (rrc_DL_DCCH_Message *)cmd_ptr->cmd.
    downlink_sdu_ind.decoded_msg;
  
  rrc_mcm_ptr = &dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.measurementControl_r8;

    /* Set trans Id in var trans_id */
  trans_id = l1_mcm->trans_id = transaction_id;

  /* Make Compressed Mode Status Information as invalid so that L1 is O.K. */
  l1_mcm->dpch_cm_status_incl = FALSE;
  /* Set Compressed Mode Information */
  if ((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r8_IEs,dpch_CompressedModeStatusInfo)) &&
    (rrc_mcm_ptr->dpch_CompressedModeStatusInfo.tgp_SequenceShortList.n != 0))
  {

    if (rrcmeas_process_compressed_mode_status(&rrc_mcm_ptr->dpch_CompressedModeStatusInfo,
      &l1_mcm->cm_status_info) == FAILURE)
    {
      /* Send Meas Ctrl Failure Message */

      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;

    }
    /* Set compressed Mode as TRUE */
    l1_mcm->dpch_cm_status_incl = TRUE;

  } /* End of if of compressed mode processing */

  /* Store MCM contents in a Local Ptr */
  /* Assign default value to Primary Meas Type */
  primary_meas_type = INTRA_FREQ;

  /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

  switch ( rrc_mcm_ptr->measurementCommand.t )
  {
  case T_rrc_MeasurementCommand_r8_setup:

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r8_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

    }
    else
    {
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;
    }


    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_SETUP;

    /* Store meas type */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    l1_mcm->meas_object_info_included = TRUE;

    /* Check if meas quantity not present */
    /* Store Meas Quantity */
    if (!((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
      intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r7,intraFreqMeasQuantity)) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
      intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r7,intraFreqReportingQuantity)) &&
      (rrc_mcm_ptr->measurementCommand.u.setup->u.
      intraFrequencyMeasurement->m.reportCriteriaPresent)))
    {
      WRRC_MSG0_ERROR("REL8:Mandatory parameter for SETUP missing");
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;

    }

    if((RRC_CHECK_COMMON_MSG_TYPE(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
      reportCriteria,rrc_IntraFreqReportCriteria_r7_intraFreqReportingCriteria) )&&
      !(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
      reportCriteria.u.intraFreqReportingCriteria,
      rrc_IntraFreqReportingCriteria_r7,eventCriteriaList)))              
    {
       WRRC_MSG0_ERROR("REL8:event criteria for SETUP missing");
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
       rrc_free(l1_mcm);
      return FAILURE;
    }

    /* Fill intra-freq meas quantity, meas validity, cell list, cell info */
    if ( (rrcmeas_fill_common_mcm_intra_f_info_r7(
      rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement, 
      l1_mcm)
      == RRCMEAS_FAIL))

    {
      rrc_free(l1_mcm);
      return FAILURE;
    }
    /* Process Additional Meas */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r8_IEs,additionalMeasurementList))
    {
      /* Call fn which makes check for additional measurements */
      if (rrcmeas_validate_additional_meas(&rrc_mcm_ptr->additionalMeasurementList, transaction_id, &primary_meas_type,
        rrc_mcm_ptr->measurementIdentity) == FALSE)
      {
        /* Called function has already sent Meas Ctrl Failure */
        /* Retain the old CELL_INFO_LIST */
        WCDMA_MEMCPY(intra_freq_cell_list, 
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                     intra_freq_cell_list_temp,
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);
        rrc_free(l1_mcm);
        return FAILURE;
      }

      /* This means additional meas has been successfully validated */
      addtl_meas_validation = TRUE;

    } /* End of if of Additional Meas Present */

    if (rrcmeas_check_mcm_for_setup_modify_additional(
      addtl_meas_validation, INTRA_FREQ, rrc_mcm_ptr->measurementIdentity,
        &rrc_mcm_ptr->additionalMeasurementList) == FALSE)
    {
      /* Send MCF msg to UTRAN and retain the old cell info list */
      rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
      rrc_free(l1_mcm);
      return FAILURE;
    }


    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r7,measurementValidity))
    {
      /* Set it to CELL_DCH */
      meas_validity = STATE_DCH;
    }
    /* Time to store the Meas Id, validty, rpt criteria in RRC DB */
    if (rrcmeas_config_intra_freq_db(l1_mcm,meas_validity) == FALSE)
    {
      /* Send MCF msg to UTRAN and retain the old cell info list */
      rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
       rrc_free(l1_mcm);
      return FAILURE;

    }

    /* If we reached this stage, that means Meas Ctrl Msg is valid */

    /* Check if Additional Meas has been validated successfully. */
    /* If yes, then store all additional meas in RRC DB */
    if (addtl_meas_validation == TRUE)
    {
      rrcmeas_set_additional_meas_in_db(&primary_meas_type, &rrc_mcm_ptr->additionalMeasurementList,
        rrc_mcm_ptr->measurementIdentity);
    }

    /* Time to store this in Accepted transaction list after break */

    break; /* Come out of switch */


  case T_rrc_MeasurementCommand_r8_modify:
    /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r8_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);
    }
    else
    {
      /* Store reporting mode to FALSE */
      l1_mcm->rpt_mode_incl = FALSE;
    }

    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_MODIFY;

    /* Set meas type to Intra-freq Meas */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.modify,
        rrc_MeasurementCommand_r8_modify,measurementType)))
    {
      WRRC_MSG1_HIGH("REL8:Meas Type for Meas %d absent O.K", l1_mcm->meas_id);

      l1_mcm->meas_object_info_included = FALSE;
    }
    else
    {
      l1_mcm->meas_object_info_included = TRUE;

      /* Fill intra-freq meas quantity, meas validity, cell list, cell info */
      if ((rrcmeas_fill_common_mcm_intra_f_info_r7(
        rrc_mcm_ptr->measurementCommand.u.modify->measurementType.u.intraFrequencyMeasurement,
        l1_mcm) == RRCMEAS_FAIL))
      {
        rrc_free(l1_mcm);
        return FAILURE;
      }

    } /* End of else of Meas Type Present */

        /* Process Additional Meas */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r8_IEs,additionalMeasurementList))
    {
      /* Call fn which makes check for additional measurements */
      if (rrcmeas_validate_additional_meas(&rrc_mcm_ptr->additionalMeasurementList, transaction_id, &primary_meas_type,
        rrc_mcm_ptr->measurementIdentity) == FALSE)
      {
        /* Called function has already sent Meas Ctrl Failure */
        /* Retain the old CELL_INFO_LIST */
        WCDMA_MEMCPY(intra_freq_cell_list, 
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                     intra_freq_cell_list_temp,
                     sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);
        rrc_free(l1_mcm);
        return FAILURE;
      }

      /* This means additional meas has been successfully validated */
      addtl_meas_validation = TRUE;

      if (rrcmeas_check_mcm_for_setup_modify_additional(
        addtl_meas_validation, INTRA_FREQ, rrc_mcm_ptr->measurementIdentity,
          &rrc_mcm_ptr->additionalMeasurementList) == FALSE)
      {
        rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);

        rrc_free(l1_mcm);
        return FAILURE;

      }
    } /* End of if of Additional Meas Present */

    if ((l1_mcm->meas_object_info_included == TRUE) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.modify->measurementType.u.intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r7,measurementValidity)))

    {
      /* No need to check value as by default validity is CELL_DCH and if it is not CELL_DCH,
      then assume it to be CELL_DCH so that it could be resumed on next trans to CELL_DCH */
      meas_validity = STATE_DCH;
    }

    if (rrcmeas_config_intra_freq_db(l1_mcm, meas_validity) == FALSE)
    {
      rrcmeas_meas_ctrl_fail_action(transaction_id,T_rrc_FailureCauseWithProtErr_invalidConfiguration);
      rrc_free(l1_mcm);
      return FAILURE;

    }

    /* If we reached this stage, that means Meas Ctrl Msg is valid */

    /* Check if Additional Meas has been validated successfully. */
    /* If yes, then store all additional meas in RRC DB */
    if (addtl_meas_validation == TRUE)
    {
      rrcmeas_set_additional_meas_in_db(&primary_meas_type, &rrc_mcm_ptr->additionalMeasurementList,
        rrc_mcm_ptr->measurementIdentity);
    }


    break; /* Come out of switch */

  case T_rrc_MeasurementCommand_r8_release:
    /* With release meas, additional meas should not be present */
    /* Set meas id in L1 struct */
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r8_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

    }
    else
    {
      /* Store reporting mode to FALSE */
      l1_mcm->rpt_mode_incl = FALSE;
    }

    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_RELEASE;

    /* Store meas type */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    /* Delete Meas Id from Intra Freq Meas Id List */
    rrcmeas_delete_meas(&l1_mcm->meas_id);

    /* Delete additional meas */
    rrcmeas_delete_addtl_meas(&l1_mcm->meas_id);

    break;

  default:
    rrc_free(l1_mcm);
    return FAILURE;

  }
  
  alloc_idx = rrcmeas_get_int_trans_index_for_trans_id(transaction_id);
  l1_mcm->trans_id = alloc_idx;
  rrcmeas_send_l1_cmd(NULL, l1_mcm, NULL, L1_MEAS_CTRL_PARMS);
  
  rrc_free(l1_mcm);
  return SUCCESS;
 
}


#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
/*===========================================================================

FUNCTION   RRCMEAS_PROCESS_POS_MCM_R8

DESCRIPTION

 This function processes the Positioning Measurement Control Message and
 determines if it is a A-GPS or Cell Id or OTDOA Message. Depending upon that
 it configures either LSM or L1 with measurement parameters

DEPENDENCIES

 None

RETURN VALUE

 FAILURE:
 SUCCESS:

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_process_pos_mcm_r8
(
  void* msg_ptr,
  pos_info_struct_type* pos_info_ptr,
  uint8 meas_ctrl_tr_id
)
{

  /* Check if it is a Release */
  if (pos_info_ptr->pos_meas_cmd == RRC_MEAS_DELETE)
  {
    if (rrcgps_process_mcm_r8(msg_ptr, pos_info_ptr, meas_ctrl_tr_id) == SUCCESS)
      return SUCCESS;
    else
      return FAILURE;
  }

  /* Now route it */
  switch(pos_info_ptr->pos_method_type)
  {
  case RRC_GPS:
  case RRC_OTDOAorGPS:
    if (rrcgps_process_mcm_r8(msg_ptr, pos_info_ptr, meas_ctrl_tr_id) == SUCCESS)
      return SUCCESS;
    else
      return FAILURE;

  default:
    /* Not possible */
    break;


  } /* End of switch */
  return FAILURE;
}
#endif /*FEATURE_CGPS_UMTS_CP_WCDMA*/



/*====================================================================
FUNCTION: rrcmeas_init_dynamic_ptrs()

DESCRIPTION:
  This function is called to allocate dynamic ptrs

DEPENDENCIES:
  None.

RETURN VALUE:
  None
  
SIDE EFFECTS:

====================================================================*/
void rrcmeas_init_dynamic_ptrs(
  void
  )
{
  WRRC_MSG0_HIGH("Allocate Dynamic Ptrs");
  if((rrcmeas_sib11 !=NULL) ||
      (rrcmeas_sib12 !=NULL) ||
      (rrcmeas_inter_freq_sib11 !=NULL) ||
      (rrcmeas_inter_freq_sib12 !=NULL) ||
      (state_transition_meas !=NULL))
  {
    ERR_FATAL("Dynamics Ptrs are not Null",0,0,0);
  }

  
#ifdef FEATURE_WCDMA_RRC_HEAP_TO_BSS
  rrcmeas_sib11 =            &rrcmeas_sib11_glob_var;
  rrcmeas_sib12 =            &rrcmeas_sib12_glob_var;
  rrcmeas_inter_freq_sib11 = &rrcmeas_inter_freq_sib11_glob_var;
  rrcmeas_inter_freq_sib12 = &rrcmeas_inter_freq_sib12_glob_var;
  state_transition_meas =    &state_transition_meas_glob_var;
#else
  rrcmeas_sib11 = (l1_meas_sib_parm_struct_type *)modem_mem_calloc
    (1, sizeof(l1_meas_sib_parm_struct_type), MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT);
  if(rrcmeas_sib11 == NULL)
  {
    ERR_FATAL("Dynamic allocation of rrcmeas_sib11 failed", 0, 0, 0);
  }
  rrcmeas_sib12 = (l1_meas_sib_parm_struct_type *)modem_mem_calloc
    (1, sizeof(l1_meas_sib_parm_struct_type), MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT);
  if(rrcmeas_sib12  == NULL)
  {
    ERR_FATAL("Dynamic allocation of rrcmeas_sib12 failed", 0, 0, 0);
  }
  rrcmeas_inter_freq_sib11 = (l1_inter_freq_cell_list_struct_type *)modem_mem_calloc
    (1, sizeof(l1_inter_freq_cell_list_struct_type), MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT);
  if(rrcmeas_inter_freq_sib11 == NULL)
  {
    ERR_FATAL("Dynamic allocation of rrcmeas_inter_freq_sib11 failed", 0, 0, 0);
  }
  rrcmeas_inter_freq_sib12 = (l1_inter_freq_cell_list_struct_type *)modem_mem_calloc
    (1, sizeof(l1_inter_freq_cell_list_struct_type), MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT);
  if(rrcmeas_inter_freq_sib12 == NULL)
  {
    ERR_FATAL("Dynamic allocation of rrcmeas_inter_freq_sib12 failed", 0, 0, 0);
  }
  state_transition_meas = (l1_meas_trans_type *)modem_mem_calloc
    (1, sizeof(l1_meas_trans_type), MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT);
  if(state_transition_meas == NULL)
  {
    ERR_FATAL("Dynamic allocation of state_transition_meas failed", 0, 0, 0);
  }
#endif /* FEATURE_WCDMA_RRC_HEAP_TO_BSS */
}

/*====================================================================
FUNCTION: rrcmeas_free_dynamic_ptrs()

DESCRIPTION:
  This function is called to free dynamic ptrs

DEPENDENCIES:
  None.

RETURN VALUE:
  None
  
SIDE EFFECTS:

====================================================================*/
void rrcmeas_free_dynamic_ptrs(
  void
  )
{
  WRRC_MSG0_HIGH("Free Dynamic Ptrs");
  if((rrcmeas_sib11 ==NULL) ||
      (rrcmeas_sib12 ==NULL) ||
      (rrcmeas_inter_freq_sib11 ==NULL) ||
      (rrcmeas_inter_freq_sib12 ==NULL) ||
      (state_transition_meas ==NULL))
  {
    WRRC_MSG0_HIGH("Dynamics Ptrs are Null");
  }
  
#ifdef FEATURE_WCDMA_RRC_HEAP_TO_BSS
  rrcmeas_sib11 =            NULL;
  rrcmeas_sib12 =            NULL;
  rrcmeas_inter_freq_sib11 = NULL;
  rrcmeas_inter_freq_sib12 = NULL;
  state_transition_meas =    NULL;
#else
  if(NULL != rrcmeas_sib11)
  {
    modem_mem_free(rrcmeas_sib11, MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT);
    rrcmeas_sib11 = NULL;
  }
  if(NULL != rrcmeas_sib12)
  {
    modem_mem_free(rrcmeas_sib12, MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT);
    rrcmeas_sib12 = NULL;
  }
  if(NULL != rrcmeas_inter_freq_sib11)
  {
    modem_mem_free(rrcmeas_inter_freq_sib11, MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT);
    rrcmeas_inter_freq_sib11 = NULL;
  }
  if(NULL != rrcmeas_inter_freq_sib12)
  {
    modem_mem_free(rrcmeas_inter_freq_sib12, MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT);
    rrcmeas_inter_freq_sib12 = NULL;
  }
  if(NULL != state_transition_meas)
  {
    modem_mem_free(state_transition_meas, MODEM_MEM_CLIENT_WCDMA_RRC_GLOBAL_CRIT);
    state_transition_meas = NULL;
  }
#endif /*FEATURE_WCDMA_RRC_HEAP_TO_BSS*/
}

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY
/*===========================================================================

FUNCTION   rrcmeas_get_index_to_eutra_ded_pri_layer_info

DESCRIPTION 
  This function return the idx to EUTRA frequency in ded pri layer info

DEPENDENCIES
  None

RETURN VALUE
  Index to the EUTRA ded pri layer info if present
  INVALID otherwise

SIDE EFFECTS
  None

===========================================================================*/
uint8 rrcmeas_get_index_to_eutra_ded_pri_layer_info
(
  uint32 frequency
)
{
  uint8 idx;
  boolean found = FALSE;

  for(idx = 0;idx<rrc_dedicated_priority_info.num_eutra_layers && idx < RRC_MAX_EUTRA_DED_PRI_LAYERS;idx++)
  {
    if(rrc_dedicated_priority_info.eutra_priority_layers[idx].frequency == frequency)
    {
      found = TRUE;
      break;
    }
  }
  if(found)
  {
    return idx;
  }
  else
  {
    return RRC_MAX_EUTRA_DED_PRI_LAYERS;
  }
}

#ifdef FEATURE_LTE_TO_WCDMA
/*===========================================================================

FUNCTION   rrc_is_earfcn_in_deprio_list

DESCRIPTION 
  This function checks if earfcn is present in deprio ;ist or not.

DEPENDENCIES
  None

RETURN VALUE
  SUCCESS : If EUTRA frequency is present in deprio list
  FAILURE   : Otherwise

SIDE EFFECTS
  None

===========================================================================*/
boolean rrc_is_earfcn_in_deprio_list(uint32 earfcn)
{
 uint8 cnt;
 if(rrc_deprioritization_db.depri_all_freq)
 {
    WRRC_MSG0_HIGH("LTE whole RAT deprioritized");
    return TRUE;
 }
 for(cnt =0; cnt<rrc_deprioritization_db.num_depri_freq && cnt < WCDMA_RRC_MAX_LTE_DEPRI_FREQ ;cnt++)
 {
    if(earfcn == rrc_deprioritization_db.depri_freqs[cnt])
    {
       WRRC_MSG0_HIGH("EARFCN %d present in De-Prioritization DB");
       return TRUE;
    }
 }
 return FALSE;
}

#endif

#ifdef FEATURE_WCDMA_TO_LTE
/*===========================================================================

FUNCTION   rrc_check_operator_plmn_support

DESCRIPTION 
  This function checks for the PLMN ID configured in EFS against MIB

DEPENDENCIES
  None

RETURN VALUE
  TRUE : If any of the PLMNs are supported
  FALSE   : Otherwise

SIDE EFFECTS
  None

===========================================================================*/
boolean rrc_check_operator_plmn_support(void)
{
  rrc_MasterInformationBlock *mib_ptr = NULL;
  mib_ptr = (rrc_MasterInformationBlock *)rrc_sibdb_return_sib_for_srv_cell(rrc_MIB);  
  rrc_plmn_identity_type shared_plmn_list[MAX_SHARED_PLMNS];
  rrc_plmn_identity_type mib_plmn;  
  uint8 num_of_shared_plmns;
  uint8 count =0;
  boolean ret_val = FALSE;

  if(mib_ptr == NULL)
  {
    return FALSE;
  }

  PRINT_PLMN_ID(efs_plmn_id);

  if(rrc_is_nw_shared(mib_ptr))
  {
    num_of_shared_plmns = rrccsp_construct_multiple_plmn_list_from_mib(mib_ptr,shared_plmn_list);

    for(count = 0;count < num_of_shared_plmns; count++)
    {
      PRINT_PLMN_ID(shared_plmn_list[count]);
      ret_val = rrc_bcch_plmns_match(efs_plmn_id,shared_plmn_list[count]);

      if(ret_val == TRUE)
      {
        break;
      }
    }
  }
  else
  {
    if(RRC_CHECK_COMMON_MSG_TYPE(mib_ptr->plmn_Type,rrc_PLMN_Type_gsm_MAP ))
    {
      rrc_translate_gsm_map_plmn_id(&(mib_ptr->plmn_Type.u.gsm_MAP->plmn_Identity), &mib_plmn);
      PRINT_PLMN_ID(mib_plmn);
      ret_val = rrc_bcch_plmns_match(efs_plmn_id,mib_plmn);
    }
  }
  return ret_val;
}

#ifdef FEATURE_WCDMA_MULTI_FREQ_BAND_INDICATOR 
/*===========================================================================

FUNCTION   rrc_meas_check_mfbi_list

DESCRIPTION 
  This function checks for the supported bands in MFBI list

DEPENDENCIES
  None

RETURN VALUE
  TRUE : If EMFBI band is supported by UE
  FALSE   : Otherwise

SIDE EFFECTS
  None

===========================================================================*/
boolean rrc_meas_check_mfbi_list(uint32 earfcn, uint32 *mfbi_earfcn, uint8 index, boolean num_applicable_earfcn_check)
{
  boolean earfcn_found = FALSE;
  uint32  supported_earfcn;
  uint8 cnt = 0;
  rrc_SysInfoType19 *sib19_ptr = NULL;

  uint16 unsupported_band;
  boolean is_valid;


  rrc_MultipleEUTRAFrequencyBandIndicatorList *multiearfcn_ptr = NULL;
  rrc_MultipleEUTRAFrequencyBandIndicatorExtensionList *multiearfcn_ext_ptr = NULL;

  sib19_ptr = (rrc_SysInfoType19 *)rrc_sibdb_return_sib_for_srv_cell(rrc_SIB19);

  if(sib19_ptr == NULL)
  {
    return earfcn_found;
  }
  
  /*We dont support the earfcn passed.So look into MFBI list and check if we support any band*/
  if((num_applicable_earfcn_check) && 
   (lte_rrc_cap_mfbi_is_supported(lte_rrc_cell_is_tdd(earfcn))) &&
   (sib19_ptr != NULL) && 
   (sib19_ptr->m.v920NonCriticalExtensionsPresent) &&
   (sib19_ptr->v920NonCriticalExtensions.m.va80NonCriticalExtensionsPresent) && 
   (sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.sysInfoType19_va80ext.m.multipleEutraFrequencyInfoListPresent) &&
   ((sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.sysInfoType19_va80ext.multipleEutraFrequencyInfoList.n) > index) &&
   (sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.sysInfoType19_va80ext.multipleEutraFrequencyInfoList.elem[index].m.multipleEUTRAFrequencyBandIndicatorlistPresent))
  {
    multiearfcn_ptr=&(sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.sysInfoType19_va80ext.multipleEutraFrequencyInfoList.elem[index].multipleEUTRAFrequencyBandIndicatorlist);
    
    cnt = 0;
    while(((cnt < multiearfcn_ptr->n) && !earfcn_found))
    {
      supported_earfcn = earfcn;
      unsupported_band= lte_rrc_get_band_from_dl_earfcn(earfcn,&is_valid);
      if(is_valid)
      {
        if(lte_rrc_convert_dl_earfcn_by_band(&supported_earfcn,unsupported_band,(lte_rrc_band_from_int_to_enum(multiearfcn_ptr->elem[cnt]))) == E_SUCCESS)
        {
          if(lte_rrc_earfcn_is_supported(supported_earfcn,rrccsp_get_lte_band_pref()))
          {
            earfcn_found = TRUE;
            *mfbi_earfcn = supported_earfcn;
            WRRC_MSG0_HIGH("UE supports the band in the MFBI list");
            return earfcn_found;
          }
        }
      }
      cnt++;
    }
  }

  /*We dont support the earfcn passed.So look into MFBI list and check if we support any band*/
  if((earfcn_found == FALSE) &&
   (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL9) &&
   (WCDMA_RRC_IDLE_FEATURES(RRC_EXTENDED_EARFCN_SUPPORT)) &&
   (lte_rrc_cap_mfbi_is_supported(lte_rrc_cell_is_tdd(earfcn))) &&
   sib19_ptr->m.v920NonCriticalExtensionsPresent &&
   sib19_ptr->v920NonCriticalExtensions.m.va80NonCriticalExtensionsPresent &&
   sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.m.vb30NonCriticalExtensionsPresent &&
   sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.m.vb50NonCriticalExtensionsPresent &&
   sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.vb50NonCriticalExtensions.sysInfoType19_vb50ext.m.multipleEutraFrequencyInfoExtensionListPresent &&
   (sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.vb50NonCriticalExtensions.sysInfoType19_vb50ext.multipleEutraFrequencyInfoExtensionList.n > index)&&
   sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.vb50NonCriticalExtensions.sysInfoType19_vb50ext.multipleEutraFrequencyInfoExtensionList.elem[index].m.multipleEUTRAFrequencyBandIndicatorlistPresent
  )
  {
    multiearfcn_ext_ptr=&(sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.vb50NonCriticalExtensions.sysInfoType19_vb50ext.multipleEutraFrequencyInfoExtensionList.elem[index].multipleEUTRAFrequencyBandIndicatorlist);
    cnt = 0;

    while(((cnt < multiearfcn_ext_ptr->n) && !earfcn_found))
    {
      supported_earfcn = earfcn;
      unsupported_band= lte_rrc_get_band_from_dl_earfcn(earfcn,&is_valid);
      if(is_valid)
      {
        if(lte_rrc_convert_dl_earfcn_by_band(&supported_earfcn,unsupported_band,(lte_rrc_band_from_int_to_enum(multiearfcn_ext_ptr->elem[cnt]))) == E_SUCCESS)
        {
          if(lte_rrc_earfcn_is_supported(supported_earfcn,rrccsp_get_lte_band_pref()))
          {
            earfcn_found = TRUE;
            *mfbi_earfcn = supported_earfcn;
            WRRC_MSG0_HIGH("UE supports the band in the extended MFBI list");
            return earfcn_found;
          }
        }
      }
      cnt++;
    }
  }
  return earfcn_found;
}
#endif
/*===========================================================================

FUNCTION   rrcmeas_populate_eutra_layers_priority_info_freq_list_l1_req

DESCRIPTION 
  This function uses stored dedicated priority info and SIB19 to populated EUTRA layers priority info, EUTRA freq list in l1 req

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_populate_eutra_layers_priority_info_freq_list_l1_req
(
  l1_meas_priority_info_type *pri_info_ptr,
  l1_meas_eutra_frequency_list_type *eutra_cell_list_ptr
)
{
  rrc_SysInfoType19 *sib19_ptr = NULL;
  boolean is_ded_pri_valid = rrc_dedicated_priority_info.is_valid;
  boolean configure_eutra_pri = TRUE;
  uint8 index=0,num_eutra_pri_layers = 0;
  uint32 n_value=0;
  uint16 absol_freq_of_supported_earfcns[MAX_EUTRA_FREQUENCIES];
  uint8 max_absol_frequencies = 0;
  uint8 i;
  uint8 num_of_earfcn_deprioritized =0;
  uint8 earfcn_in_deprio_list = FALSE;
  uint8 num_eutra_freqs = 0;  
  uint32 n_index=0; 
#ifdef FEATURE_EUTRA_DETECT
  is_sib19_eutradetect_present = FALSE;
#endif

  /* Resetting SIB19 band mask of current cell used for filling capability */
#ifdef LTE_BAND_NUM
  memset(&rrcueci_sib19_band_mask, 0, sizeof(sys_lte_band_mask_e_type));
#else
  rrcueci_sib19_band_mask = 0;
#endif
  if((!rrcmcm_is_lte_mode_enabled()) || (!rrccsp_get_lte_resel_allow_status()))
  {
    MSG_LOW("ABSOL_PRI:LTE mode not enabled/or lte resel is not allowed due to ATTACH reject with cause 14",0,0,0);
    return;
  }

if((((rrcmeas_current_substate == RRCMEAS_INITIAL)
    || (rrcmeas_current_substate == RRCMEAS_IDLE)
    || (rrcmeas_current_substate == RRCMEAS_PCH)
    )
    &&(rrc_disable_meas_nv & RRC_DISABLE_WTOL_IDLE_MEAS))

   || ((rrcmeas_current_substate == RRCMEAS_CELL_FACH)
        &&(rrc_disable_meas_nv & RRC_DISABLE_WTOL_FACH_MEAS))
   )
{
   WRRC_MSG2_HIGH("Dont configure EUTRA priorities  Disable IRAT/IFREQ NV %d  in meas state  %d",rrc_disable_meas_nv,rrcmeas_current_substate);
   return;
}

  /*
  <TBD> Incorporate below Spec section considering that UE supports CS voice services

  5.2.2.5 Camped on any cell State overview

  In this state if the UE supports CS voice services, the UE shall avoid reselecting an acceptable cell of E-UTRA regardless of priorities
  provided in system information of current cell.

  */

  /*Spec reference : 25.304, 5.2.2.5*/
  if(!rrccsp_check_if_camped_normally())
  {
    return;
  }

  if(rrcmeas_current_substate == RRCMEAS_CELL_DCH)
  {
    /*Spec section 13.4.15c*/
    configure_eutra_pri = FALSE;
  }

  /*Now populate EUTRA freq info and EUTRA layers priority info*/
  {
#ifdef FEATURE_WCDMA_TO_LTE
    sib19_ptr = (rrc_SysInfoType19 *)rrc_sibdb_return_sib_for_srv_cell(rrc_SIB19);
    if(sib19_ptr == NULL)
    {
      sib19_ptr = rrc_sibdb_return_psuedo_sib19();
    }
#endif
    if(sib19_ptr == NULL)
    {
      return;
    }
    if(sib19_ptr->m.eutra_FrequencyAndPriorityInfoListPresent)
    {
      rrc_EUTRA_FrequencyAndPriorityInfoList *eutr_freq_pri_list_ptr = &(sib19_ptr->eutra_FrequencyAndPriorityInfoList);

      sys_band_mask_type lte_band = 0; 
      boolean band_is_valid = FALSE;

      n_value = eutr_freq_pri_list_ptr->n;
      n_index = 0;
      /*Populate EUTRA list and priority info*/
      max_absol_frequencies = 0;
      while((n_value > 0) && (n_index <= L1_MAX_EUTRA_PRIORITY_LAYERS))
      {
        uint32 earfcn = eutr_freq_pri_list_ptr->elem[n_index].earfcn;
        uint8 num_black_listed_cells = 0;
#ifdef FEATURE_WCDMA_MULTI_FREQ_BAND_INDICATOR 
        uint32 mfbi_earfcn;
        boolean earfcn_found = FALSE;
#endif
        boolean absolute_freq_match = FALSE;

        if(!lte_rrc_earfcn_is_supported(earfcn,rrccsp_get_lte_band_pref()))
        {
#ifdef FEATURE_WCDMA_MULTI_FREQ_BAND_INDICATOR 
          earfcn_found = rrc_meas_check_mfbi_list(earfcn,&mfbi_earfcn,n_index,TRUE);
            
          if(earfcn_found)
          {
            /*we found a supported band in the MFBI list.convert the previous EARFCN to the EARFCN of the current band*/
            earfcn = mfbi_earfcn;
          }
          else
#endif
          {
            WRRC_MSG1_HIGH("EARFCN %d not supported by UE",earfcn);
            n_value--;
            n_index++;
            continue;
          }
        }

        /* Logic for pruning duplicate physical frequencies. Configuring duplicate is a spec violation */
        for(i=0;i<max_absol_frequencies;i++)
        {
          if(absol_freq_of_supported_earfcns[i] == lte_rrc_get_freq_from_earfcn(earfcn))
          {
            absolute_freq_match = TRUE;
            break;
          }
        }
        if(absolute_freq_match == TRUE)
        {
          n_value--;
          n_index++;
          WRRC_MSG2_HIGH("earfcn %d not added whose absolute frequency %d is already present in the list",earfcn,lte_rrc_get_freq_from_earfcn(earfcn));
          continue;
        }
        absol_freq_of_supported_earfcns[max_absol_frequencies++] = lte_rrc_get_freq_from_earfcn(earfcn);

#ifdef FEATURE_EUTRA_DETECT
        if(eutr_freq_pri_list_ptr->elem[n_index].eutraDetection == TRUE)
        {
          MSG_LOW("EUTRA_DETECT: IE detected",0,0,0);
          is_sib19_eutradetect_present = TRUE;
        }
#endif
        if(num_eutra_freqs < L1_MAX_EUTRA_FREQ)
        {
          eutra_cell_list_ptr->eutra_frequency[num_eutra_freqs].EARFCN = earfcn;

          /* Get corresponding band for the earfcn passed */
          lte_band = lte_rrc_get_band_from_dl_earfcn(earfcn,&band_is_valid);

          if(band_is_valid == TRUE)
          {
            /* Update the band into SIB19 band mask */
            if(lte_band < RRC_MAX_LTE_BAND_SUPPORT)
            {
#ifdef LTE_BAND_NUM
              SYS_LTE_BAND_MASK_ADD_BAND(&(rrcueci_sib19_band_mask),lte_band);
#else
              rrcueci_sib19_band_mask |=  ((sys_band_mask_type) SYS_BM_64BIT(lte_band));
#endif  
            }
          }

          /*Populate black listed cells*/
          if(eutr_freq_pri_list_ptr->elem[n_index].m.eutra_blackListedCellListPresent)
          {
            rrc_EUTRA_BlacklistedCellPerFreqList *black_listed_cell_ptr = NULL;
            uint32 n_value_BlacklistedCellPerFreqList=0;
            uint32 n_index_BlacklistedCellPerFreqList=0;
            
            black_listed_cell_ptr = &(eutr_freq_pri_list_ptr->elem[n_index].eutra_blackListedCellList);
            n_value_BlacklistedCellPerFreqList = black_listed_cell_ptr->n;
            
            while(n_value_BlacklistedCellPerFreqList != 0)
            {
              eutra_cell_list_ptr->eutra_frequency[num_eutra_freqs].blacklisted_cells[num_black_listed_cells++] =
                  (uint16)black_listed_cell_ptr->elem[n_index_BlacklistedCellPerFreqList].physicalCellIdentity;
              n_index_BlacklistedCellPerFreqList++;
              n_value_BlacklistedCellPerFreqList--;
              if(num_black_listed_cells == L1_MAX_EUTRA_CELLS_PER_FREQUENCY-1)
              {
                MSG_LOW("ABSOL_PRI:Maximim blacklisted cells per frequency",0,0,0);
                break;
              }
            }
          }
          eutra_cell_list_ptr->eutra_frequency[num_eutra_freqs].num_blacklisted_cells = num_black_listed_cells;
          if(eutr_freq_pri_list_ptr->elem[n_index].m.measurementBandwidthPresent)
          {
            eutra_cell_list_ptr->eutra_frequency[num_eutra_freqs].meas_band_width = 
              RRCMEAS_GET_EUTRA_MEAS_BANDWIDTH(eutr_freq_pri_list_ptr->elem[n_index].measurementBandwidth);
          }
          else
          {
            /*25.331 section 10.3.7.115*/
            eutra_cell_list_ptr->eutra_frequency[num_eutra_freqs].meas_band_width = l1_mbw6;
          }
          WRRC_MSG1_HIGH("ABSOL_PRI: EARFCN %d added in list",earfcn);
          num_eutra_freqs++;
        }

        if((configure_eutra_pri) && (num_eutra_pri_layers < L1_MAX_EUTRA_PRIORITY_LAYERS))
        {
           /*Check for De-prioritization list*/
           earfcn_in_deprio_list = rrc_is_earfcn_in_deprio_list(earfcn);
          WRRC_MSG2_HIGH("De-prioritization DB valid %d, EARFCN deprioritized %d",rrc_deprioritization_db.is_deprio_db_valid,earfcn_in_deprio_list);

           if(rrc_deprioritization_db.is_deprio_db_valid)
           {
              if((rrc_deprioritization_db.depri_all_freq) || (TRUE == earfcn_in_deprio_list))
              {
                 /*Set priority to lowest so that it doesnt match with utra serving cell priority in case
                   utra serving cell priority is set to -1 */
                 pri_info_ptr->eutra_priority[num_eutra_pri_layers].priority = LOWEST_DEPRIO_PRIORITY;
                 num_of_earfcn_deprioritized ++;
             }
          }
          if(is_ded_pri_valid &&  (FALSE == earfcn_in_deprio_list))
          {
            uint8 eutra_ded_pri_index = rrcmeas_get_index_to_eutra_ded_pri_layer_info(earfcn);
            if(eutra_ded_pri_index != RRC_MAX_EUTRA_DED_PRI_LAYERS)
            {
              WRRC_MSG2_HIGH("ABSOL_PRI:DED PRI present for EUTRA freq %d @ idx %d",earfcn,eutra_ded_pri_index);
              pri_info_ptr->eutra_priority[num_eutra_pri_layers].priority = 
                rrc_dedicated_priority_info.eutra_priority_layers[eutra_ded_pri_index].priority;
            }
            else
            {
              n_value--;
              n_index++;
              continue;
            }
          }
          pri_info_ptr->eutra_priority[num_eutra_pri_layers].EARFCN = earfcn;
          pri_info_ptr->eutra_priority[num_eutra_pri_layers].q_rxlevmin_eutra = 2*(int16)eutr_freq_pri_list_ptr->elem[n_index].qRxLevMinEUTRA;
          pri_info_ptr->eutra_priority[num_eutra_pri_layers].threshx_low = 2 * (uint8)eutr_freq_pri_list_ptr->elem[n_index].threshXlow;
          pri_info_ptr->eutra_priority[num_eutra_pri_layers].threshx_high = 2 * (uint8)eutr_freq_pri_list_ptr->elem[n_index].threshXhigh;
          /* as per spec RSRQ, dB default value is negative infinity, L1 should treat FF as default */
          pri_info_ptr->eutra_priority[num_eutra_pri_layers].q_qualmin_eutra = 0xFF;

          if(!is_ded_pri_valid && !earfcn_in_deprio_list)
          {
            pri_info_ptr->eutra_priority[num_eutra_pri_layers].priority = (uint8)eutr_freq_pri_list_ptr->elem[n_index].priority;
          }

         MSG_5(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"ABSOL_PRI: EARFCN %d,  priority %d, Actual q_rxlevmin %d threshx_low %d, threshx_high %d",
            earfcn,pri_info_ptr->eutra_priority[num_eutra_pri_layers].priority,
            pri_info_ptr->eutra_priority[num_eutra_pri_layers].q_rxlevmin_eutra,
            pri_info_ptr->eutra_priority[num_eutra_pri_layers].threshx_low,
            pri_info_ptr->eutra_priority[num_eutra_pri_layers].threshx_high );
          num_eutra_pri_layers++;
        }
        n_value--;
        n_index++;
      }
      eutra_cell_list_ptr->num_eutra_frequencies = num_eutra_freqs;
      pri_info_ptr->num_eutra_priorities = num_eutra_pri_layers;
      /* Wait for standards approval to implement the below : */
     /*If all the earfcn in SIB 19 are de-prioritized then exclude pre-redirection info in Conn-request*/
      /*
        if(rrc_deprioritization_db.is_deprio_db_valid && (num_of_earfcn_deprioritized == num_eutra_pri_layers))
        {
          WRRC_MSG0_HIGH("All the SIB 19 earfcn are De-prioritized.. Exclude pre-redirection info in conn request");
          rrc_csp_int_data.exclude_preredir_info_in_conn_req_msg = TRUE;
        } */
    }

    if((LTE_3GPP_REL9 <= lte_rrc_get_3gpp_release_version()) && sib19_ptr->m.v920NonCriticalExtensionsPresent)
    {
      rrc_SysInfoType19_v920ext  *sib19_920_ext = &(sib19_ptr->v920NonCriticalExtensions.sysInfoType19_v920ext);
      n_value = sib19_920_ext->eutra_FrequencyAndPriorityInfoList_v920ext.n;
      
      for(index =0;index <MIN(n_value,num_eutra_pri_layers ); index++)
      {
        if(sib19_920_ext->eutra_FrequencyAndPriorityInfoList_v920ext.elem[index].m.qqualMinEUTRAPresent)
        {
          pri_info_ptr->eutra_priority[index].q_qualmin_eutra = 
               sib19_920_ext->eutra_FrequencyAndPriorityInfoList_v920ext.elem[index].qqualMinEUTRA;
        }
        else
        {
         /* as per spec RSRQ, dB default value is negative infinity, L1 should treat FF as default */
          pri_info_ptr->eutra_priority[index].q_qualmin_eutra = 0xFF;
        }
        
        if(sib19_920_ext->eutra_FrequencyAndPriorityInfoList_v920ext.elem[index].m.threshXhigh2Present)
        {
          pri_info_ptr->eutra_priority[index].high2_incl = TRUE;
          pri_info_ptr->eutra_priority[index].threshx_high2 = 
               sib19_920_ext->eutra_FrequencyAndPriorityInfoList_v920ext.elem[index].threshXhigh2;  
        }
        if(sib19_920_ext->eutra_FrequencyAndPriorityInfoList_v920ext.elem[index].m.threshXlow2Present)
        {
          pri_info_ptr->eutra_priority[index].low2_incl = TRUE;            
          pri_info_ptr->eutra_priority[index].threshx_low2 = 
               sib19_920_ext->eutra_FrequencyAndPriorityInfoList_v920ext.elem[index].threshXlow2;     
        }

        MSG_HIGH("ABSOL_PRI: RSRQ: qualmin_eutra %d threshx_high2 %d threshx_low2 %d",
          pri_info_ptr->eutra_priority[index].q_qualmin_eutra, pri_info_ptr->eutra_priority[index].threshx_high2, pri_info_ptr->eutra_priority[index].threshx_low2);
      }
    }

    /* Release 11 extended EARFCN implementation
       spec CR5316 and 5601 */
    if(
        (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL9) &&
        (WCDMA_RRC_IDLE_FEATURES(RRC_EXTENDED_EARFCN_SUPPORT)) &&
        (rrc_check_operator_plmn_support()) &&
        sib19_ptr->m.v920NonCriticalExtensionsPresent &&
        sib19_ptr->v920NonCriticalExtensions.m.va80NonCriticalExtensionsPresent &&
        sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.m.vb30NonCriticalExtensionsPresent &&
        sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.m.vb50NonCriticalExtensionsPresent &&
        sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.vb50NonCriticalExtensions.sysInfoType19_vb50ext.m.eutra_FrequencyAndPriorityInfoExtensionListPresent
    )
    {
      rrc_EUTRA_FrequencyAndPriorityInfoExtensionList *eutr_freq_pri_list_ext_ptr = &(sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.vb50NonCriticalExtensions.sysInfoType19_vb50ext.eutra_FrequencyAndPriorityInfoExtensionList);
      sys_band_mask_type lte_band = 0; 
      boolean band_is_valid = FALSE;
#ifdef FEATURE_WCDMA_MULTI_FREQ_BAND_INDICATOR 
      uint8 num_applicable_earfcn = 0;
      boolean applicable_earfcn_check = FALSE;
#endif  

      n_value = eutr_freq_pri_list_ext_ptr->n;
      n_index = 0;

#ifdef FEATURE_WCDMA_MULTI_FREQ_BAND_INDICATOR 
      if( 
          sib19_ptr->m.v920NonCriticalExtensionsPresent &&
          sib19_ptr->v920NonCriticalExtensions.m.va80NonCriticalExtensionsPresent &&
          sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.m.vb30NonCriticalExtensionsPresent &&
          sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.m.vb50NonCriticalExtensionsPresent &&
          sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.vb50NonCriticalExtensions.sysInfoType19_vb50ext.m.numberOfApplicableEARFCNPresent
       )
      {
        /* This IE should be present if Extended EARFCN list is present */
        /* Only if this IE is present, we need to check the legacy MFBI list */
        applicable_earfcn_check = TRUE;
        num_applicable_earfcn = sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.vb50NonCriticalExtensions.sysInfoType19_vb50ext.numberOfApplicableEARFCN;
      }
#endif

      /*Populate EUTRA list and priority info*/
      while((n_value > 0) && (n_index <= L1_MAX_EUTRA_PRIORITY_LAYERS))
      {
        uint8 num_black_listed_cells = 0;
#ifdef FEATURE_WCDMA_MULTI_FREQ_BAND_INDICATOR 
        uint32 mfbi_earfcn;
        boolean earfcn_found = FALSE;
#endif
        boolean absolute_freq_match = FALSE;
        uint32 earfcn = eutr_freq_pri_list_ext_ptr->elem[n_index].earfcn;

        if(!lte_rrc_earfcn_is_supported(earfcn,rrccsp_get_lte_band_pref()))
        {
#ifdef FEATURE_WCDMA_MULTI_FREQ_BAND_INDICATOR 
          earfcn_found = rrc_meas_check_mfbi_list(earfcn,&mfbi_earfcn,n_index + num_applicable_earfcn,applicable_earfcn_check);

          if(earfcn_found)
          {
            /*we found a supported band in the MFBI list.convert the previous EARFCN to the EARFCN of the current band*/
            earfcn = mfbi_earfcn;
          }
          else
#endif
          {
            WRRC_MSG1_HIGH("EARFCN %d not supported by UE",earfcn);
            n_value--;
            n_index++;
            continue;
          }
        }

        /* Logic for pruning duplicate physical frequencies. Configuring duplicate is a spec violation */
        for(i=0;i<max_absol_frequencies;i++)
        {
          if(absol_freq_of_supported_earfcns[i] == lte_rrc_get_freq_from_earfcn(earfcn))
          {
            absolute_freq_match = TRUE;
            break;
          }
        }
        if(absolute_freq_match == TRUE)
        {
          n_value--;
          n_index++;
          WRRC_MSG2_HIGH("earfcn %d not added whose absolute frequency %d is already present in the list",earfcn,lte_rrc_get_freq_from_earfcn(earfcn));
          continue;
        }
        absol_freq_of_supported_earfcns[max_absol_frequencies++] = lte_rrc_get_freq_from_earfcn(earfcn);

#ifdef FEATURE_EUTRA_DETECT
        if(eutr_freq_pri_list_ext_ptr->elem[n_index].eutraDetection == TRUE)
        {
          MSG_LOW("EUTRA_DETECT: IE detected",0,0,0);
          is_sib19_eutradetect_present = TRUE;
        }
#endif
        if(num_eutra_freqs < L1_MAX_EUTRA_FREQ)
        {
          eutra_cell_list_ptr->eutra_frequency[num_eutra_freqs].EARFCN = earfcn;
          /* Get corresponding band for the earfcn passed */
          lte_band = lte_rrc_get_band_from_dl_earfcn(earfcn,&band_is_valid);

          if(band_is_valid == TRUE)
          {
            /* Update the band into SIB19 band mask */
            if(lte_band < RRC_MAX_LTE_BAND_SUPPORT)
            {
#ifdef LTE_BAND_NUM
              SYS_LTE_BAND_MASK_ADD_BAND(&(rrcueci_sib19_band_mask),lte_band);
#else
              rrcueci_sib19_band_mask |=  ((sys_band_mask_type) SYS_BM_64BIT(lte_band));
#endif  
            }
          }

          /*Populate black listed cells*/
          if(eutr_freq_pri_list_ext_ptr->elem[n_index].m.eutra_blackListedCellListPresent)
          {
            rrc_EUTRA_BlacklistedCellPerFreqList *black_listed_cell_ptr = NULL;
            uint32 n_value_BlacklistedCellPerFreqList=0;
            uint32 n_index_BlacklistedCellPerFreqList=0;

            black_listed_cell_ptr = &(eutr_freq_pri_list_ext_ptr->elem[n_index].eutra_blackListedCellList);
            n_value_BlacklistedCellPerFreqList = black_listed_cell_ptr->n;

            while(n_value_BlacklistedCellPerFreqList != 0)
            {
              eutra_cell_list_ptr->eutra_frequency[num_eutra_freqs].blacklisted_cells[num_black_listed_cells++] =  (uint16)black_listed_cell_ptr->elem[n_index_BlacklistedCellPerFreqList].physicalCellIdentity;
              n_index_BlacklistedCellPerFreqList++;
              n_value_BlacklistedCellPerFreqList--;
              if(num_black_listed_cells == L1_MAX_EUTRA_CELLS_PER_FREQUENCY-1)
              {
                MSG_LOW("ABSOL_PRI:Maximim blacklisted cells per frequency",0,0,0);
                break;
              }
            }
          }
          eutra_cell_list_ptr->eutra_frequency[num_eutra_freqs].num_blacklisted_cells = num_black_listed_cells;
          if(eutr_freq_pri_list_ext_ptr->elem[n_index].m.measurementBandwidthPresent)
          {
            eutra_cell_list_ptr->eutra_frequency[num_eutra_freqs].meas_band_width = 
            RRCMEAS_GET_EUTRA_MEAS_BANDWIDTH(eutr_freq_pri_list_ext_ptr->elem[n_index].measurementBandwidth);
          }
          else
          {
            /*25.331 section 10.3.7.115*/
            eutra_cell_list_ptr->eutra_frequency[num_eutra_freqs].meas_band_width = l1_mbw6;
          }
          WRRC_MSG1_HIGH("ABSOL_PRI: EARFCN %d added in list",earfcn);
          num_eutra_freqs++;
        }

        if((configure_eutra_pri) && (num_eutra_pri_layers < L1_MAX_EUTRA_PRIORITY_LAYERS))
        {
          /*Check for De-prioritization list*/
          earfcn_in_deprio_list = rrc_is_earfcn_in_deprio_list(earfcn);

          WRRC_MSG2_HIGH("De-prioritization DB valid %d, EARFCN deprioritized %d",rrc_deprioritization_db.is_deprio_db_valid,earfcn_in_deprio_list);

          if(rrc_deprioritization_db.is_deprio_db_valid)
          {
            if((rrc_deprioritization_db.depri_all_freq) || (TRUE == earfcn_in_deprio_list))
            {
              /*Set priority to lowest so that it doesnt match with utra serving cell priority in case utra serving cell priority is set to -1 */
              pri_info_ptr->eutra_priority[num_eutra_pri_layers].priority = LOWEST_DEPRIO_PRIORITY;
              num_of_earfcn_deprioritized ++;
            }
          }

          if(is_ded_pri_valid && (FALSE == earfcn_in_deprio_list))
          {
            uint8 eutra_ded_pri_index = rrcmeas_get_index_to_eutra_ded_pri_layer_info(earfcn);
            if(eutra_ded_pri_index != RRC_MAX_EUTRA_DED_PRI_LAYERS)
            {
              WRRC_MSG2_HIGH("ABSOL_PRI:DED PRI present for EUTRA freq %d @ idx %d",earfcn,eutra_ded_pri_index);
              pri_info_ptr->eutra_priority[num_eutra_pri_layers].priority = 
              rrc_dedicated_priority_info.eutra_priority_layers[eutra_ded_pri_index].priority;
            }
            else
            {
              n_value--;
              n_index++;
              continue;
            }
          }
          pri_info_ptr->eutra_priority[num_eutra_pri_layers].EARFCN = earfcn;
          pri_info_ptr->eutra_priority[num_eutra_pri_layers].q_rxlevmin_eutra = 2*(int16)eutr_freq_pri_list_ext_ptr->elem[n_index].qRxLevMinEUTRA;
          pri_info_ptr->eutra_priority[num_eutra_pri_layers].threshx_low = 2 * (uint8)eutr_freq_pri_list_ext_ptr->elem[n_index].threshXlow;
          pri_info_ptr->eutra_priority[num_eutra_pri_layers].threshx_high = 2 * (uint8)eutr_freq_pri_list_ext_ptr->elem[n_index].threshXhigh;
          /* as per spec RSRQ, dB default value is negative infinity, L1 should treat FF as default */
          pri_info_ptr->eutra_priority[num_eutra_pri_layers].q_qualmin_eutra = 0xFF;

          if(!is_ded_pri_valid)
          {
            pri_info_ptr->eutra_priority[num_eutra_pri_layers].priority = (uint8)eutr_freq_pri_list_ext_ptr->elem[n_index].priority;
          }

          if(eutr_freq_pri_list_ext_ptr->elem[index].m.qqualMinEUTRAPresent)
          {
            pri_info_ptr->eutra_priority[index].q_qualmin_eutra = 
            eutr_freq_pri_list_ext_ptr->elem[index].qqualMinEUTRA;
          }
          else
          {
            /* as per spec RSRQ, dB default value is negative infinity, L1 should treat FF as default */
            pri_info_ptr->eutra_priority[index].q_qualmin_eutra = 0xFF;
          }

          if(eutr_freq_pri_list_ext_ptr->elem[index].m.threshXhigh2Present)
          {
            pri_info_ptr->eutra_priority[index].high2_incl = TRUE;
            pri_info_ptr->eutra_priority[index].threshx_high2 = 
              eutr_freq_pri_list_ext_ptr->elem[index].threshXhigh2;
          }
          if(eutr_freq_pri_list_ext_ptr->elem[index].m.threshXlow2Present)
          {
            pri_info_ptr->eutra_priority[index].low2_incl = TRUE;
            pri_info_ptr->eutra_priority[index].threshx_low2 = 
              eutr_freq_pri_list_ext_ptr->elem[index].threshXlow2;
          }

         MSG_5(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"ABSOL_PRI: EARFCN %d,  priority %d, Actual q_rxlevmin %d threshx_low %d, threshx_high %d",
            earfcn,pri_info_ptr->eutra_priority[num_eutra_pri_layers].priority,
            pri_info_ptr->eutra_priority[num_eutra_pri_layers].q_rxlevmin_eutra,
            pri_info_ptr->eutra_priority[num_eutra_pri_layers].threshx_low,
            pri_info_ptr->eutra_priority[num_eutra_pri_layers].threshx_high );

          num_eutra_pri_layers++;
        }
        n_value--;
        n_index++;
      }
      eutra_cell_list_ptr->num_eutra_frequencies = num_eutra_freqs;
      pri_info_ptr->num_eutra_priorities = num_eutra_pri_layers;
    }

    if(num_eutra_pri_layers != 0)
    {
      pri_info_ptr->inter_rat_eutra_priority_info_incl = TRUE;
    }
  }
}
#endif


/*===========================================================================

FUNCTION   rrcmeas_get_index_to_utra_ded_pri_layer_info

DESCRIPTION 
  This function return the idx to UTRA frequency in ded pri layer info

DEPENDENCIES
  None

RETURN VALUE
  Index to the UTRA ded pri layer info if present
  INVALID otherwise


SIDE EFFECTS
  None

===========================================================================*/
uint8 rrcmeas_get_index_to_utra_ded_pri_layer_info
(
  uint16 frequency
)
{
  uint8 idx;
  boolean found = FALSE;

  for(idx = 0;idx<rrc_dedicated_priority_info.num_utra_layers && idx < RRC_MAX_UTRA_DED_PRI_LAYERS;idx++)
  {
    if(rrc_dedicated_priority_info.utra_priority_layers[idx].frequency == frequency)
    {
      found = TRUE;
      break;
    }
  }
  if(found)
  {
    return idx;
  }
  else
  {
    return RRC_MAX_UTRA_DED_PRI_LAYERS;
  }
}

/*===========================================================================

FUNCTION   rrcmeas_get_index_to_gsm_ded_pri_layer_info

DESCRIPTION 
  This function return the idx to GSM frequency in ded pri layer info

DEPENDENCIES
  None

RETURN VALUE
  Index to the GSM ded pri layer info if present
  INVALID otherwise


SIDE EFFECTS
  None

===========================================================================*/
uint8 rrcmeas_get_index_to_gsm_ded_pri_layer_info
(
  uint16 frequency
)
{
  uint8 idx;
  boolean found = FALSE;

  for(idx = 0;idx<rrc_dedicated_priority_info.num_gsm_layers && idx < RRC_MAX_GSM_DED_PRI_LAYERS;idx++)
  {
    if(rrc_dedicated_priority_info.gsm_priority_layers[idx].frequency == frequency)
    {
      found = TRUE;
      break;
    }
  }
  if(found)
  {
    return idx;
  }
  else
  {
    return RRC_MAX_GSM_DED_PRI_LAYERS;
  }
}

/*===========================================================================

FUNCTION   rrcmeas_check_gsm_arfcn)_in_cell_group

DESCRIPTION 
  This function checks if a arfcn is present in a cell group

DEPENDENCIES
  None

RETURN VALUE
  TRUE is present
  FALSE otherwise

SIDE EFFECTS
  None

===========================================================================*/
boolean rrcmeas_check_gsm_arfcn_present_in_cell_group
(
  uint16 arfcn,
  rrc_GSM_CellGroup *gsm_cellgroup_ptr
)
{
  boolean found = FALSE;
  uint16 starting_arfcn = (uint16)gsm_cellgroup_ptr->startingARFCN;

  if(arfcn == (uint16)gsm_cellgroup_ptr->startingARFCN)
  {
    found = TRUE;
  }
  else
  {
    switch(gsm_cellgroup_ptr->followingARFCNs.t)
    {
      case T_rrc_GSM_CellGroup_followingARFCNs_explicitListOfARFCNs :
        {
          struct rrc_GSM_CellGroup_explicitListOfARFCNs *explixcit_list = gsm_cellgroup_ptr->followingARFCNs.u.explicitListOfARFCNs;
          uint32 n_value=0, n_index=0;
          n_value = explixcit_list->n;
          
          while(n_value != 0)
          {
            if(arfcn == (uint16)explixcit_list->elem[n_index])
            {
              found = TRUE;
              break;
            }
            n_value--;
            n_index++;
          }
        }
        break;
      case T_rrc_GSM_CellGroup_followingARFCNs_equallySpacedARFCNs:
        {
          uint8 space, num_following_arfcns,idx;
          uint16 derived_arfcn;
          space = (uint8)gsm_cellgroup_ptr->followingARFCNs.u.equallySpacedARFCNs->arfcn_Spacing;
          num_following_arfcns = (uint8)gsm_cellgroup_ptr->followingARFCNs.u.equallySpacedARFCNs->numberOfFollowingARFCNs;
          for(idx =1;idx <= num_following_arfcns; idx++)
          {
            derived_arfcn = (starting_arfcn + (idx*space))%1024;
            if(derived_arfcn == arfcn)
            {
              found = TRUE;
              break;
            }
          }
        }
        break;
      case T_rrc_GSM_CellGroup_followingARFCNs_variableBitMapOfARFCNs:
        {
          uint8 num_octets ,curr_octet , octet_idx ;
          uint16 derived_arfcn;
          num_octets = (uint8)gsm_cellgroup_ptr->followingARFCNs.u.variableBitMapOfARFCNs->numocts;
          for(octet_idx = 1;(!found) && ( octet_idx <= num_octets) ;octet_idx++)
          {
            uint8 bit_idx;
            curr_octet = gsm_cellgroup_ptr->followingARFCNs.u.variableBitMapOfARFCNs->data[octet_idx-1];
            for(bit_idx =1 ; bit_idx <= 8;bit_idx++)
            {
              if(curr_octet & (1 << (8-(bit_idx))))
              {
                derived_arfcn = (starting_arfcn + (octet_idx * bit_idx))%1024;
                if(derived_arfcn == arfcn)
                {
                  found = TRUE;
                  break;
                }
              }
            }
          }
        }
        break;
      case T_rrc_GSM_CellGroup_followingARFCNs_continuousRangeOfARFCNs :
        {
          uint16 ending_arfcn;
          ending_arfcn = (uint16)gsm_cellgroup_ptr->followingARFCNs.u.continuousRangeOfARFCNs->endingARFCN;
          if(starting_arfcn < ending_arfcn)
          {
             if((arfcn > starting_arfcn) && (arfcn <= ending_arfcn))
            {
              found = TRUE;
              break;
            }
          }
          else
          {
             /*Case when starting arfcn is greater than ending arfcn*/
             if((arfcn > starting_arfcn)||(arfcn <= ending_arfcn))
            {
                found = TRUE;
              break;
            }
          }
          
        }
        break;
    }
  }
  return found;
}

/*===========================================================================

FUNCTION   rrcmeas_fill_default_qual_value_from_serving_cell

DESCRIPTION 
  This function is used to set the qualmin and rxlevmin values by default from
  serving cell to pass to L1. 

DEPENDENCIES
  None

RETURN VALUE
  SUCCESS/FAULURE

SIDE EFFECTS
  None

===========================================================================*/

uecomdef_status_e_type rrcmeas_fill_default_qual_value_from_serving_cell(int16 *qualmin, int16 *rxlevmin)
{

  rrc_SysInfoType3    *sib3_ptr = NULL;

  rrc_SysInfoType4    *sib4_ptr = NULL;
  boolean sib4_present = FALSE;

  sib3_ptr = (rrc_SysInfoType3 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB3);
  if( sib3_ptr == NULL )
  {
    WRRC_MSG0_ERROR("SIB3 ptr is NULL");
    return( FAILURE );
  }

  if (((rrcmeas_current_substate == RRCMEAS_CELL_FACH) || (rrcmeas_current_substate == RRCMEAS_PCH)) &&
    ((sib3_ptr->sib4indicator == TRUE)))
  {
    sib4_ptr = (rrc_SysInfoType4 *) rrc_sibdb_return_sib_for_srv_cell(rrc_SIB4);

    if (sib4_ptr == NULL)
    {
      WRRC_MSG0_ERROR("SIB4 ptr NULL.Use SIB3");
    }
    else
    {
      WRRC_MSG0_HIGH("Use default values from SIB4");
      sib4_present = TRUE;
    }
  }

  if ((sib4_present == TRUE) && (sib4_ptr != NULL))
  {
    if(RRC_CHECK_COMMON_MSG_TYPE(sib4_ptr->cellSelectReselectInfo.modeSpecificInfo,
       rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
    {
      *qualmin  = (int16)sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin;
  
      *rxlevmin = (int16)(sib4_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1;
      /* Check for REL 5 extension ptr */
      if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) &&
        (sib4_ptr->m.v4b0NonCriticalExtensionsPresent) &&
        (sib4_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
        (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType4_v590ext.m.cellSelectReselectInfo_v590extPresent)
        && (sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
        sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.m.deltaQrxlevminPresent))
      {
        *rxlevmin += (int16)(sib4_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
           sysInfoType4_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2);
      }
    }
    else
    {
      return( FAILURE );
    }
  }
  else
  {
    if(RRC_CHECK_COMMON_MSG_TYPE(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo,
       rrc_CellSelectReselectInfoSIB_3_4_modeSpecificInfo_fdd))
    {
      *qualmin  = (int16)sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_QualMin;

      *rxlevmin = (int16)(sib3_ptr->cellSelectReselectInfo.modeSpecificInfo.u.fdd->q_RxlevMin * 2) + 1;
      /* Check for REL 5 extension ptr */
      if((rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) &&
        (sib3_ptr->m.v4b0NonCriticalExtensionsPresent) &&
        (sib3_ptr->v4b0NonCriticalExtensions.m.v590NonCriticalExtensionPresent) &&
        (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.sysInfoType3_v590ext.m.
        cellSelectReselectInfo_v590extPresent) && (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
        sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.m.deltaQrxlevminPresent))
      {
        *rxlevmin += (int16) (sib3_ptr->v4b0NonCriticalExtensions.v590NonCriticalExtension.
           sysInfoType3_v590ext.cellSelectReselectInfo_v590ext.deltaQrxlevmin * 2);
      }
    }
    else
    {
      return( FAILURE );
    }
  }    
  WRRC_MSG2_HIGH("SIB3 Qrxlev=%d, Qualmin=%d", *rxlevmin,*qualmin); 
  return( SUCCESS );
}

/*===========================================================================

FUNCTION   rrcmeas_populate_utra_layers_priority_info_l1_req

DESCRIPTION 
  This function uses stored dedicated priority info and SIB19 to populated UTRA layers priority info in l1 req

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_populate_utra_layers_priority_info_l1_req
(
  l1_meas_priority_info_type *pri_info_ptr
)
{
  rrc_SysInfoType19 *sib19_ptr = NULL;
  rrc_freq_type serving_cell_freq;
  boolean is_ded_pri_valid = rrc_dedicated_priority_info.is_valid;
  uint8 num_pri_layers = 0;
  uint8 interf_cell_idx,utra_ded_pri_layer_idx;
  int16 qualmin = 0, rxlevmin = 0;
  uint16 freq_sib19,freq_sib11;
  rrc_plmn_identity_type selected_plmn_identity = rrc_ccm_get_curr_camped_plmn();

  /*Spec reference : 25.331, 13.4.15c*/
  if(!rrccsp_check_if_camped_normally())
  {
    is_ded_pri_valid = FALSE;
  }

#ifdef FEATURE_WCDMA_TO_LTE
  sib19_ptr = (rrc_SysInfoType19 *)rrc_sibdb_return_sib_for_srv_cell(rrc_SIB19);
  if(sib19_ptr == NULL)
  {
    sib19_ptr = rrc_sibdb_return_psuedo_sib19();
  }
#endif

  if(sib19_ptr == NULL)
  {
    return;
  }

  /*First populate the serving cell priority info*/
  serving_cell_freq = rrc_ccm_get_curr_camped_freq();
  pri_info_ptr->serving_cell_priority.s_prioritysearch1 = 2 *((uint8)sib19_ptr->utra_PriorityInfoList.utra_ServingCell.s_PrioritySearch1);
  pri_info_ptr->serving_cell_priority.thresh_servinglow = 2 *((uint8)sib19_ptr->utra_PriorityInfoList.utra_ServingCell.threshServingLow);
  pri_info_ptr->serving_cell_priority.thresh_servinglow2 = 0;

  if(sib19_ptr->utra_PriorityInfoList.utra_ServingCell.m.s_PrioritySearch2Present)
  {
    pri_info_ptr->serving_cell_priority.s_prioritysearch2 = sib19_ptr->utra_PriorityInfoList.utra_ServingCell.s_PrioritySearch2;
  }
  else
  {
    pri_info_ptr->serving_cell_priority.s_prioritysearch2 = 0;
  }
  if((LTE_3GPP_REL9 <= lte_rrc_get_3gpp_release_version()) && sib19_ptr->m.v920NonCriticalExtensionsPresent)
  {
    rrc_SysInfoType19_v920ext  *sib19_920_ext = &(sib19_ptr->v920NonCriticalExtensions.sysInfoType19_v920ext);
    if(sib19_920_ext->utra_PriorityInfoList_v920ext.m.threshServingLow2Present)
    {
      pri_info_ptr->serving_cell_priority.thresh_servinglow2 = 
            sib19_920_ext->utra_PriorityInfoList_v920ext.threshServingLow2;
    }
  }
  
  if(is_ded_pri_valid)
  {
    utra_ded_pri_layer_idx = rrcmeas_get_index_to_utra_ded_pri_layer_info(serving_cell_freq);
    if(utra_ded_pri_layer_idx != RRC_MAX_UTRA_DED_PRI_LAYERS)
    {
      pri_info_ptr->serving_cell_priority.priority = rrc_dedicated_priority_info.utra_priority_layers[utra_ded_pri_layer_idx].priority;
    }
    else 
    {
      pri_info_ptr->serving_cell_priority.priority = LOWEST_ABS_PRIORITY;
    }
  }
  else
  {
    pri_info_ptr->serving_cell_priority.priority = (uint8)sib19_ptr->utra_PriorityInfoList.utra_ServingCell.priority;
  }

  MSG_5(MSG_SSID_DIAG, MSG_LEGACY_HIGH,
    "ABSOL_PRI: Serving cell priority :%d, Actual s_prioritysearch1 %d, thresh_servinglow %d, s_prioritysearch2 %d RSRQ thresh_servinglow2 %d",
    pri_info_ptr->serving_cell_priority.priority,
             pri_info_ptr->serving_cell_priority.s_prioritysearch1,
             pri_info_ptr->serving_cell_priority.thresh_servinglow,
             pri_info_ptr->serving_cell_priority.s_prioritysearch2,
             pri_info_ptr->serving_cell_priority.thresh_servinglow2);


  /*Now populate UTRA neighbors Priroity info*/
  if(sib19_ptr->utra_PriorityInfoList.m.utran_FDD_FrequencyListPresent)
  {
    rrc_UTRAN_FDD_FrequencyList *utran_list_ptr = &(sib19_ptr->utra_PriorityInfoList.utran_FDD_FrequencyList);
    uint32 n_value=0, n_index=0;
    pri_info_ptr->inter_freq_priority_info_incl = TRUE;

    {
      for(interf_cell_idx = 0; interf_cell_idx < L1_MAX_CELL_MEAS;interf_cell_idx++)
      {
        if(inter_freq_cell_list[interf_cell_idx].cell_position == OCCUPIED)
        {
          uint16 uarfcn = inter_freq_cell_list[interf_cell_idx].dl_freq;
          if(is_ded_pri_valid)
          {
            utra_ded_pri_layer_idx = rrcmeas_get_index_to_utra_ded_pri_layer_info(uarfcn);
            if(utra_ded_pri_layer_idx != RRC_MAX_UTRA_DED_PRI_LAYERS)
            {
              WRRC_MSG2_HIGH("ABSOL_PRI:DED PRI present for freq %d @ idx %d",uarfcn,utra_ded_pri_layer_idx);
              pri_info_ptr->inter_freq_priority[num_pri_layers].priority = 
                rrc_dedicated_priority_info.utra_priority_layers[utra_ded_pri_layer_idx].priority;
            }
            else
            {
              continue;
            }
          }
          
          n_value = utran_list_ptr->n;
          n_index = 0;          
          while((n_value > 0) && (n_index<= L1_MAX_INTERF_PRIORITY_LAYERS))
          {
            freq_sib11 = rrccsp_derive_freq_from_uarfcn(uarfcn,rrc_get_frequency_band(uarfcn,selected_plmn_identity));
            freq_sib19 = rrccsp_derive_freq_from_uarfcn(((uint16)utran_list_ptr->elem[n_index].uarfcn),rrc_get_frequency_band(((uint16)utran_list_ptr->elem[n_index].uarfcn),selected_plmn_identity));
            if(freq_sib11 == freq_sib19)
            {
              pri_info_ptr->inter_freq_priority[num_pri_layers].UARFCN = uarfcn;
              pri_info_ptr->inter_freq_priority[num_pri_layers].threshx_high = 2 * (uint8)utran_list_ptr->elem[n_index].threshXhigh;
              pri_info_ptr->inter_freq_priority[num_pri_layers].threshx_low = 2 * (uint8)utran_list_ptr->elem[n_index].threshXlow;
              
              if(rrcmeas_fill_default_qual_value_from_serving_cell(&qualmin, &rxlevmin) == SUCCESS)
              {
                pri_info_ptr->inter_freq_priority[num_pri_layers].q_rxlevmin_fdd = rxlevmin;
                pri_info_ptr->inter_freq_priority[num_pri_layers].q_qualmin_fdd = qualmin;
              }
              else
              {
                pri_info_ptr->inter_freq_priority[num_pri_layers].q_rxlevmin_fdd = -119;
                pri_info_ptr->inter_freq_priority[num_pri_layers].q_qualmin_fdd = -24;
              }
              if(utran_list_ptr->elem[n_index].m.qRxLevMinFDDPresent)
              {
                pri_info_ptr->inter_freq_priority[num_pri_layers].q_rxlevmin_fdd = (2 * (int16)utran_list_ptr->elem[n_index].qRxLevMinFDD)+1;
              }
              if(utran_list_ptr->elem[n_index].m.qQualMinFDDPresent)
              {
                pri_info_ptr->inter_freq_priority[num_pri_layers].q_qualmin_fdd = (int16)utran_list_ptr->elem[n_index].qQualMinFDD;
              }
              if(!is_ded_pri_valid)
              {
                pri_info_ptr->inter_freq_priority[num_pri_layers].priority = (uint8)utran_list_ptr->elem[n_index].priority;
              }

              MSG_6(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"ABSOL_PRI: UARFCN %d, priority %d, Actual threshx_high %d, threshx_low %d, q_rxlevmin_fdd %d, q_qualmin_fdd %d",
                         uarfcn,pri_info_ptr->inter_freq_priority[num_pri_layers].priority,
                         pri_info_ptr->inter_freq_priority[num_pri_layers].threshx_high,
                         pri_info_ptr->inter_freq_priority[num_pri_layers].threshx_low,
                         pri_info_ptr->inter_freq_priority[num_pri_layers].q_rxlevmin_fdd,
                         pri_info_ptr->inter_freq_priority[num_pri_layers].q_qualmin_fdd);
              num_pri_layers ++;
              break;
            }
            n_index++;
            n_value--;
          }
        }
        if(num_pri_layers >= L1_MAX_INTERF_PRIORITY_LAYERS)
        {
          break;
        }
      }
      pri_info_ptr->num_inter_freq_priorities = num_pri_layers;
    }
  }
}


/*===========================================================================

FUNCTION   rrcmeas_populate_gsm_layers_priority_info_l1_req

DESCRIPTION 
  This function uses stored dedicated priority info and SIB19 to populated GSM layers priority info in l1 req

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_populate_gsm_layers_priority_info_l1_req
(
  l1_meas_priority_info_type *pri_info_ptr
)
{
  rrc_SysInfoType19 *sib19_ptr = NULL;
  boolean is_ded_pri_valid = rrc_dedicated_priority_info.is_valid;
  uint8 num_pri_layers = 0;
  uint8 gsm_cell_idx;

  if(!rrcmcm_is_dualmode_enabled())
  {
    return;
  }

if((((rrcmeas_current_substate == RRCMEAS_INITIAL)
      || (rrcmeas_current_substate == RRCMEAS_IDLE)
      || (rrcmeas_current_substate == RRCMEAS_PCH)
      )
      &&(rrc_disable_meas_nv & RRC_DISABLE_WTOG_IDLE_MEAS))

     || ((rrcmeas_current_substate == RRCMEAS_CELL_FACH)
        &&(rrc_disable_meas_nv & RRC_DISABLE_WTOG_FACH_MEAS))
    )
  {
     WRRC_MSG2_HIGH("Dont configure GSM priorities  Disable IRAT/IFREQ NV %d  in meas state  %d",rrc_disable_meas_nv,rrcmeas_current_substate);
     return;
  }

  /*Spec reference : 25.331, 13.4.15c*/
  if(!rrccsp_check_if_camped_normally())
  {
    is_ded_pri_valid = FALSE;
  }

#ifdef FEATURE_WCDMA_TO_LTE
  sib19_ptr = (rrc_SysInfoType19 *)rrc_sibdb_return_sib_for_srv_cell(rrc_SIB19);
  if(sib19_ptr == NULL)
  {
    sib19_ptr = rrc_sibdb_return_psuedo_sib19();
  }
#endif

  if(sib19_ptr == NULL)
  {
    return;
  }

  if(sib19_ptr->m.gsm_PriorityInfoListPresent)
  {
    rrc_GSM_PriorityInfoList *gsm_pri_list_ptr = &(sib19_ptr->gsm_PriorityInfoList);
    uint32 n_value=0, n_index=0;
    
    pri_info_ptr->inter_rat_gsm_priority_info_incl = TRUE;

  
    for(gsm_cell_idx = 0; gsm_cell_idx < L1_MAX_CELL_MEAS  ;gsm_cell_idx++)
    {
      if(inter_rat_cell_list[gsm_cell_idx].cell_position == OCCUPIED)
      {
        uint16 arfcn = inter_rat_cell_list[gsm_cell_idx].arfcn;
        if(is_ded_pri_valid)
        {
          uint8 gsm_ded_pri_layer_idx = rrcmeas_get_index_to_gsm_ded_pri_layer_info(arfcn);
          if(gsm_ded_pri_layer_idx != RRC_MAX_GSM_DED_PRI_LAYERS)
          {
            WRRC_MSG2_HIGH("ABSOL_PRI:DED PRI present for GSM freq %d @ idx %d",arfcn,gsm_ded_pri_layer_idx);
            pri_info_ptr->gsm_priority[num_pri_layers].priority = 
                rrc_dedicated_priority_info.gsm_priority_layers[gsm_ded_pri_layer_idx].priority;
          }
          else
          {
            continue;
          }
        }
        
        n_value = gsm_pri_list_ptr->n;
        n_index = 0;
        while((n_value > 0) && (n_index <= L1_MAX_GSM_PRIORITY_LAYERS))
        {
          /*Check if ARFCN is present in GSM cell group*/
          if(rrcmeas_check_gsm_arfcn_present_in_cell_group(arfcn,&(gsm_pri_list_ptr->elem[n_index].gsmCellGroup)))
          {
            CONVERT_ARFCN_TO_NUM(pri_info_ptr->gsm_priority[num_pri_layers].ARFCN) = arfcn;
            pri_info_ptr->gsm_priority[num_pri_layers].q_rxlevmin_gsm = (2*(int16)gsm_pri_list_ptr->elem[n_index].qRxLevMinGSM) +1 ;
            pri_info_ptr->gsm_priority[num_pri_layers].threshxlow = 2* (uint8)gsm_pri_list_ptr->elem[n_index].threshXlow;
            pri_info_ptr->gsm_priority[num_pri_layers].threshx_high= 2* (uint8)gsm_pri_list_ptr->elem[n_index].threshXhigh;
            if(!is_ded_pri_valid)
            {
              pri_info_ptr->gsm_priority[num_pri_layers].priority = (uint8)gsm_pri_list_ptr->elem[n_index].priority;
            }

            MSG_5(MSG_SSID_DIAG, MSG_LEGACY_HIGH,
              "ABSOL_PRI: GSM ARFCN: %d priority :%d, q_rxlevmin_gsm %d, threshxlow %d, threshx_high %d",
               arfcn,pri_info_ptr->gsm_priority[num_pri_layers].priority,
                pri_info_ptr->gsm_priority[num_pri_layers].q_rxlevmin_gsm,
                pri_info_ptr->gsm_priority[num_pri_layers].threshxlow,
                pri_info_ptr->gsm_priority[num_pri_layers].threshx_high);
            num_pri_layers++;
            break;
          }
          n_index++;
          n_value--;
        }
      }
      if(num_pri_layers >= L1_MAX_GSM_PRIORITY_LAYERS)
      {
        break;
      }
    }
    pri_info_ptr->num_gsm_priorities = num_pri_layers;
  }
}


/*===========================================================================

FUNCTION   rrcmeas_update_eutra_dedicated_priority_layer_info

DESCRIPTION 
  This function updates the EUTRA dedicated priority layer information stored

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void rrcmeas_update_eutra_dedicated_priority_layer_info
(
  uint8 priority,
  uint32 frequency
)
{
  uint8 layer_idx=0;
  for(layer_idx = 0; layer_idx < rrc_dedicated_priority_info.num_eutra_layers && 
                                                      layer_idx < RRC_MAX_EUTRA_DED_PRI_LAYERS; layer_idx++)
  {
    if(rrc_dedicated_priority_info.eutra_priority_layers[layer_idx].frequency == frequency)
    {
      rrc_dedicated_priority_info.eutra_priority_layers[layer_idx].priority = priority;

      break;
    }
  }
  if((layer_idx == rrc_dedicated_priority_info.num_eutra_layers) && 
     (layer_idx < RRC_MAX_EUTRA_DED_PRI_LAYERS ))
  {
    rrc_dedicated_priority_info.eutra_priority_layers[layer_idx].frequency = frequency;
    rrc_dedicated_priority_info.eutra_priority_layers[layer_idx].priority = priority;
    rrc_dedicated_priority_info.num_eutra_layers++;
  }
  MSG_HIGH("ABSOL_PRI: Created/Updated idx %d with frequency %d priority %d",layer_idx,frequency,priority);
}

/*===========================================================================

FUNCTION   rrcmeas_configure_l1_with_priority_info_eutra_cell_list

DESCRIPTION 
  This function uses stored dedicated priority info and SIB19 to configure WL1 with priority info and E-UTRA cell list

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_configure_l1_with_priority_info_eutra_cell_list
(
  void
)
{
  rrc_SysInfoType19 *sib19_ptr = NULL;
  l1_meas_priority_eutra_cell_list_info_type *l1_req = rrc_malloc(sizeof(l1_meas_priority_eutra_cell_list_info_type));
  l1_meas_priority_info_type *pri_info_ptr;
#ifdef FEATURE_WCDMA_TO_LTE
  l1_meas_eutra_frequency_list_type *eutra_cell_list_ptr;
#endif

  rrc_cmd_type        *rrc_meas_out_cmd_ptr = NULL;
  l1_req_cmd * llc_cmd_l1_req = NULL;
  boolean configure_priorities = TRUE;

  pri_info_ptr = &(l1_req->priority_info);
#ifdef FEATURE_WCDMA_TO_LTE
  eutra_cell_list_ptr = &(l1_req->eutra_cell_list);
  pri_info_ptr->inter_rat_eutra_priority_info_incl = FALSE;
#endif

  pri_info_ptr->inter_freq_priority_info_incl = pri_info_ptr->inter_rat_gsm_priority_info_incl = FALSE;

  memset(&pri_info_ptr->serving_cell_priority,0,sizeof(l1_serving_cell_priority_info_type));

  MSG_4(MSG_SSID_DIAG, MSG_LEGACY_HIGH,"ABSOL_PRI: Dedicated priority validity: %d, configure priorities %d, Camped normally %d, camped st %d",
    rrc_dedicated_priority_info.is_valid, configure_priorities, rrccsp_check_if_camped_normally(),rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_MCMR));

  if(rrcmeas_current_substate == RRCMEAS_CELL_DCH)
  {
    /*Spec section 13.4.15c*/
    /*Do not configure Priorities*/
    configure_priorities = FALSE;
  }
  if(RRC_CAMPED_ON != rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_MCMR))
  {
    rrc_free(l1_req);
    return;
  }

  //RRC doesn't delete the dedicated priorities when the camped PLMN is same as the PLMN in which 
  //the priorities are received
  //SPEC CR : 25.304 CR 0288 - RRC doesn't delete the dedicated priorities when moving between ePLMNs
  if((rrccsp_check_if_camped_normally()) &&
      (rrc_dedicated_priority_info.is_valid) &&
    !((sys_plmn_match(mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_dedicated_priority_info.plmn_id),
       mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_ccm_get_curr_camped_plmn()))) ||
       (rrccsp_check_for_eplmn(mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_dedicated_priority_info.plmn_id)))))
  {
    rrcmeas_invalidate_dedicated_priority_info();
    /*If WCDMA is the owner , set the owner to None*/
    rrcmeas_handle_clear_dedicated_pri_ind();
  }
  {
    /*Call the SIB API to get the serving cell SIB19 ptr*/
#ifdef FEATURE_WCDMA_TO_LTE
    sib19_ptr = (rrc_SysInfoType19 *)rrc_sibdb_return_sib_for_srv_cell(rrc_SIB19);
    if(sib19_ptr == NULL)
    {
      sib19_ptr = rrc_sibdb_return_psuedo_sib19();
    }
#endif
    if(sib19_ptr == NULL)
    {
#ifdef FEATURE_EUTRA_DETECT
       is_sib19_eutradetect_present = FALSE;
#endif
    }
    else
    {
      pri_info_ptr->num_gsm_priorities = pri_info_ptr->num_inter_freq_priorities = 0;

#ifdef FEATURE_WCDMA_ABSOLUTE_PRIORITY_FACH
      pri_info_ptr->fach_meas_indicator_incl = FALSE;
  
      pri_info_ptr->rrc_fe_fach_support = rrc_fe_fach_support_nv;
  
      /*FE-FACH Changes*/
      if(rrcueci_check_fe_fach_concurrency() && (sib19_ptr->m.v920NonCriticalExtensionsPresent &&
         sib19_ptr->v920NonCriticalExtensions.m.va80NonCriticalExtensionsPresent &&
         sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.m.vb30NonCriticalExtensionsPresent &&
         sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.sysInfoType19_vb30ext.m.cell_fach_meas_indPresent))
      {
          pri_info_ptr->fach_meas_indicator_incl = TRUE;
  
          pri_info_ptr->fach_meas_indicator = FE_FACH_NOT_SUPPORTED; 
  
          switch(sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.
                      vb30NonCriticalExtensions.sysInfoType19_vb30ext.
                 cell_fach_meas_ind)
          {
              case rrc_SysInfoType19_vb30ext_cell_fach_meas_ind_high_priority_layers:
                    pri_info_ptr->fach_meas_indicator = FE_FACH_HIGH_PRIORITY_LAYERS;
               break;
  
              case rrc_SysInfoType19_vb30ext_cell_fach_meas_ind_all_layers:
                    pri_info_ptr->fach_meas_indicator = FE_FACH_ALL_LAYERS;
               break;
          }
          WRRC_MSG2_HIGH("FE-FACH : Fach meas ind sent to L1 : %d   NV set to %d ",pri_info_ptr->fach_meas_indicator,pri_info_ptr->rrc_fe_fach_support);
      }
      /*FE_FACH changes End*/
#endif
      if(configure_priorities)
      {
        rrcmeas_populate_utra_layers_priority_info_l1_req(pri_info_ptr);
        rrcmeas_populate_gsm_layers_priority_info_l1_req(pri_info_ptr);
      }
#ifdef FEATURE_WCDMA_TO_LTE
      pri_info_ptr->num_eutra_priorities = 0;
      eutra_cell_list_ptr->num_eutra_frequencies = 0;

      if(!discard_EUTRA_info_from_SIB19)
      {
      rrcmeas_populate_eutra_layers_priority_info_freq_list_l1_req(pri_info_ptr,eutra_cell_list_ptr);
      }
#endif
       pri_info_ptr->gsm_treselection_scalingfactor_present = FALSE;
       pri_info_ptr->eutra_treselection_scalingfactor_present = FALSE;

       if(sib19_ptr->m.v920NonCriticalExtensionsPresent &&
          sib19_ptr->v920NonCriticalExtensions.m.va80NonCriticalExtensionsPresent &&
          sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.m.vb30NonCriticalExtensionsPresent &&
          sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.m.vb50NonCriticalExtensionsPresent
        )
       {
         rrc_SysInfoType19_vb50ext *SIB19_b50ext =  &(sib19_ptr->v920NonCriticalExtensions.va80NonCriticalExtensions.vb30NonCriticalExtensions.vb50NonCriticalExtensions.sysInfoType19_vb50ext);
         if(SIB19_b50ext->m.gsmTreselectionScalingFactorPresent)
         {
            pri_info_ptr->gsm_treselection_scalingfactor_present = TRUE;
            pri_info_ptr->gsm_treselection_scalingfactor = SIB19_b50ext->gsmTreselectionScalingFactor;
         }
         if(SIB19_b50ext->m.eutraTreselectionScalingFactorPresent)
         {
            pri_info_ptr->eutra_treselection_scalingfactor_present = TRUE;
            pri_info_ptr->eutra_treselection_scalingfactor = SIB19_b50ext->eutraTreselectionScalingFactor;
         }
       }
      rrc_meas_out_cmd_ptr = rrc_get_int_cmd_buf();
      RRC_GET_POINTER_L1_REQ_VALUE(rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.l1_req,llc_cmd_l1_req);
      rrc_meas_out_cmd_ptr->cmd_hdr.cmd_id= RRC_LLC_CMD_REQ;
      rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.procedure = RRC_PROCEDURE_MCMR;
      rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.cmd_dest = LAYER1_PHY;
      rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id = CPHY_MEASUREMENT_REQ;
      rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.l1_cmd.act_time_type =
        L1_ACTIVATION_TIME_NONE;
      /* Now allocate memory to the pointer inside the command */
      llc_cmd_l1_req->meas.meas_ptr =
            (l1_meas_parm_type *)rrc_malloc_interlayer_cmd(sizeof(l1_meas_parm_type));
      llc_cmd_l1_req->meas.meas_ptr->parm_type = L1_PRIORITY_EUTRA_CELL_LIST_INFO;
      llc_cmd_l1_req->meas.meas_ptr->u.priority_eutra_cell_list = *l1_req;
      rrc_put_int_cmd( rrc_meas_out_cmd_ptr );

    }
  }
  rrc_free(l1_req);
}
/*===========================================================================

FUNCTION   rrcmeas_update_utra_dedicated_priority_layer_info

DESCRIPTION 
  This function updates the UTRA dedicated priority layer information stored

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void rrcmeas_update_utra_dedicated_priority_layer_info
(
  uint8 priority,
  uint16 frequency
)
{
  uint8 layer_idx=0;
  for(layer_idx = 0; layer_idx < rrc_dedicated_priority_info.num_utra_layers && 
                                                      layer_idx < RRC_MAX_UTRA_DED_PRI_LAYERS; layer_idx++)
  {
    if(rrc_dedicated_priority_info.utra_priority_layers[layer_idx].frequency == frequency)
    {
      rrc_dedicated_priority_info.utra_priority_layers[layer_idx].priority = priority;
      break;
    }
  }
  if((layer_idx == rrc_dedicated_priority_info.num_utra_layers) && 
     (layer_idx < RRC_MAX_UTRA_DED_PRI_LAYERS ))
  {
    rrc_dedicated_priority_info.utra_priority_layers[layer_idx].frequency = frequency;
    rrc_dedicated_priority_info.utra_priority_layers[layer_idx].priority = priority;
    rrc_dedicated_priority_info.num_utra_layers++;
  }
  MSG_HIGH("ABSOL_PRI: Created/updated idx %d with frequency %d priority %d",layer_idx,frequency,priority);    
}

/*===========================================================================

FUNCTION   rrcmeas_update_utra_dedicated_priority_info_from_ota

DESCRIPTION 
  This function updates the UTRA dedicated priority information stored with OTA

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void rrcmeas_update_utra_dedicated_priority_info_from_ota
(
  uint8 priority,
  rrc_PriorityLevel_utraFDD *utra_fdd_list
)
{
  uint32 n_value=0, n_index=0;

  n_value = utra_fdd_list->n;
  while(n_value != 0)
  {
    rrcmeas_update_utra_dedicated_priority_layer_info(priority,(uint16)utra_fdd_list->elem[n_index].uarfcn);
    if(rrc_dedicated_priority_info.num_utra_layers == RRC_MAX_UTRA_DED_PRI_LAYERS)
    {
      WRRC_MSG0_ERROR("ABSOL_PRI: Reached Maximum layers");
      break;
    }
    n_value--;
    n_index++;
  }
}

#ifndef FEATURE_WCDMA_DEDICATED_PRI_INFO
/*===========================================================================

FUNCTION   rrcmeas_update_gsm_dedicated_priority_layer_info

DESCRIPTION 
  This function updates the GSM dedicated priority layer information stored

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void rrcmeas_update_gsm_dedicated_priority_layer_info
(
  uint8 priority,
  uint16 frequency
)
{
  uint8 layer_idx=0;
  for(layer_idx = 0; layer_idx < rrc_dedicated_priority_info.num_gsm_layers && 
                                                      layer_idx < RRC_MAX_GSM_DED_PRI_LAYERS; layer_idx++)
  {
    if(rrc_dedicated_priority_info.gsm_priority_layers[layer_idx].frequency == frequency)
    {
      rrc_dedicated_priority_info.gsm_priority_layers[layer_idx].priority = priority;
      break;
    }
  }
  if((layer_idx == rrc_dedicated_priority_info.num_gsm_layers) && 
     (layer_idx < RRC_MAX_GSM_DED_PRI_LAYERS))
  {
    rrc_dedicated_priority_info.gsm_priority_layers[layer_idx].frequency = frequency;
    rrc_dedicated_priority_info.gsm_priority_layers[layer_idx].priority = priority;
    rrc_dedicated_priority_info.num_gsm_layers++;
  }
  MSG_HIGH("ABSOL_PRI: Created/updated idx %d with frequency %d priority %d",layer_idx,frequency,priority);  
}
#else
/*===========================================================================

FUNCTION   rrcmeas_update_gsm_dedicated_priority_layer_info_for_geran

DESCRIPTION 
  This function updates the GSM dedicated priority layer information stored

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void rrcmeas_update_gsm_dedicated_priority_layer_info_for_geran
(
  uint8 priority,
  uint16 frequency,
  uint32 band_ind
)
{
  uint8 layer_idx=0;
  for(layer_idx = 0; layer_idx < rrc_dedicated_priority_info.num_gsm_layers && 
                                                      layer_idx < RRC_MAX_GSM_DED_PRI_LAYERS; layer_idx++)
  {
    if(rrc_dedicated_priority_info.gsm_priority_layers[layer_idx].frequency == frequency)
    {
      rrc_dedicated_priority_info.gsm_priority_layers[layer_idx].priority = priority;
      rrc_dedicated_priority_info.gsm_priority_layers[layer_idx].band_ind = band_ind;
      break;
    }
  }
  if((layer_idx == rrc_dedicated_priority_info.num_gsm_layers) && 
     (layer_idx < RRC_MAX_GSM_DED_PRI_LAYERS))
  {
    rrc_dedicated_priority_info.gsm_priority_layers[layer_idx].frequency = frequency;
    rrc_dedicated_priority_info.gsm_priority_layers[layer_idx].band_ind = band_ind;
    rrc_dedicated_priority_info.gsm_priority_layers[layer_idx].priority = priority;
    rrc_dedicated_priority_info.num_gsm_layers++;
  }
  MSG_HIGH("ABSOL_PRI: Created/updated idx %d with frequency %d priority %d",layer_idx,frequency,priority);    
}

#endif

/*===========================================================================

FUNCTION   rrcmeas_update_gsm_dedicated_priority_info

DESCRIPTION 
  This function updates the GSM dedicated priority information stored with OTA

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void rrcmeas_update_gsm_dedicated_priority_info_from_ota
(
  uint8 priority,
  rrc_GSM_CellGroup *gsm_cellgroup
)
{
  uint16 starting_arfcn = (uint16)gsm_cellgroup->startingARFCN;

#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO
  uint32 band_ind;
  band_ind = gsm_cellgroup->bandIndicator;
#endif

#ifndef FEATURE_WCDMA_DEDICATED_PRI_INFO
  rrcmeas_update_gsm_dedicated_priority_layer_info(priority,starting_arfcn);
#else
  rrcmeas_update_gsm_dedicated_priority_layer_info_for_geran(priority,starting_arfcn,band_ind);
#endif

  if(rrc_dedicated_priority_info.num_gsm_layers == RRC_MAX_GSM_DED_PRI_LAYERS)
  {
    WRRC_MSG0_ERROR("ABSOL_PRI: Reached Maximum layers");
    return;
  }
  switch(gsm_cellgroup->followingARFCNs.t)
  {
    case T_rrc_GSM_CellGroup_followingARFCNs_explicitListOfARFCNs:
      {
        rrc_GSM_CellGroup_explicitListOfARFCNs *explixcit_list = gsm_cellgroup->followingARFCNs.u.explicitListOfARFCNs;
        uint32 n_value=0, n_index=0;

        n_value = explixcit_list->n;
        while(n_value != 0)
        {
        
#ifndef FEATURE_WCDMA_DEDICATED_PRI_INFO
          rrcmeas_update_gsm_dedicated_priority_layer_info(priority,(uint16)explixcit_list->elem[n_index]);
#else
          rrcmeas_update_gsm_dedicated_priority_layer_info_for_geran(priority,(uint16)explixcit_list->elem[n_index],band_ind);
#endif
          if(rrc_dedicated_priority_info.num_gsm_layers == RRC_MAX_GSM_DED_PRI_LAYERS)
          {
            break;
          }
          n_value--;
          n_index++;
        }
      }
      break;
    case T_rrc_GSM_CellGroup_followingARFCNs_equallySpacedARFCNs:
      {
        uint8 space, num_following_arfcns,idx;
        uint16 arfcn;
        space = (uint8)gsm_cellgroup->followingARFCNs.u.equallySpacedARFCNs->arfcn_Spacing;
        num_following_arfcns = (uint8)gsm_cellgroup->followingARFCNs.u.equallySpacedARFCNs->numberOfFollowingARFCNs;
        for(idx =1;idx <= num_following_arfcns; idx++)
        {
          arfcn = (starting_arfcn + (idx*space))%1024;
#ifndef FEATURE_WCDMA_DEDICATED_PRI_INFO
          rrcmeas_update_gsm_dedicated_priority_layer_info(priority,arfcn);
#else
          rrcmeas_update_gsm_dedicated_priority_layer_info_for_geran(priority,arfcn,band_ind);
#endif
          if(rrc_dedicated_priority_info.num_gsm_layers == RRC_MAX_GSM_DED_PRI_LAYERS)
          {
            break;
          }
        }
      }
      break;
    case T_rrc_GSM_CellGroup_followingARFCNs_variableBitMapOfARFCNs:
      {
        uint8 num_octets ,curr_octet , octet_idx ;
        uint16 arfcn;
        num_octets = (uint8)gsm_cellgroup->followingARFCNs.u.variableBitMapOfARFCNs->numocts;
        for(octet_idx = 1;octet_idx <= num_octets ;octet_idx++)
        {
          uint8 bit_idx;
          curr_octet = gsm_cellgroup->followingARFCNs.u.variableBitMapOfARFCNs->data[octet_idx-1];
          for(bit_idx =1 ; bit_idx <= 8;bit_idx++)
          {
            if(curr_octet & (1 << (8-(bit_idx))))
            {
              arfcn = (starting_arfcn + (octet_idx * bit_idx))%1024;
#ifndef FEATURE_WCDMA_DEDICATED_PRI_INFO
              rrcmeas_update_gsm_dedicated_priority_layer_info(priority,arfcn);
#else
              rrcmeas_update_gsm_dedicated_priority_layer_info_for_geran(priority,arfcn,band_ind);
#endif
              if(rrc_dedicated_priority_info.num_gsm_layers == RRC_MAX_GSM_DED_PRI_LAYERS)
              {
                break;
              }
            }
          }
          if(rrc_dedicated_priority_info.num_gsm_layers == RRC_MAX_GSM_DED_PRI_LAYERS)
          {
            break;
          }
        }
      }
      break;
    case T_rrc_GSM_CellGroup_followingARFCNs_continuousRangeOfARFCNs:
      {
        uint16 arfcn,ending_arfcn;
        uint8 arfcn_idx = 1;
        ending_arfcn = (uint16)gsm_cellgroup->followingARFCNs.u.continuousRangeOfARFCNs->endingARFCN;
        while(1)
        {
          arfcn = (starting_arfcn + arfcn_idx) % 1024;
          arfcn_idx ++;
#ifndef FEATURE_WCDMA_DEDICATED_PRI_INFO
          rrcmeas_update_gsm_dedicated_priority_layer_info(priority,arfcn);
#else
          rrcmeas_update_gsm_dedicated_priority_layer_info_for_geran(priority,arfcn,band_ind);
#endif
          if(rrc_dedicated_priority_info.num_gsm_layers == RRC_MAX_GSM_DED_PRI_LAYERS)
          {
            break;
          }
          if(arfcn == ending_arfcn)
          {
            break;
          }
        }
      }
      break;
  }

  if(rrc_dedicated_priority_info.num_gsm_layers == RRC_MAX_GSM_DED_PRI_LAYERS)
  {
    WRRC_MSG0_ERROR("ABSOL_PRI: Reached Maximum layers");
  }
}


/*===========================================================================

FUNCTION   rrcmeas_update_eutra_dedicated_priority_info

DESCRIPTION 
  This function updates the EUTRA dedicated priority information stored with OTA

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
static void rrcmeas_update_eutra_dedicated_priority_info_from_ota
(
  uint8 priority,
  rrc_PriorityLevel_eutra *eutra_list
)
{
  uint32 n_value=0, n_index=0;
  uint32 earfcn;
  n_value = eutra_list->n;
  while(n_value != 0)
  {
    earfcn = eutra_list->elem[n_index].earfcn;
    rrcmeas_update_eutra_dedicated_priority_layer_info(priority,earfcn);
    if(rrc_dedicated_priority_info.num_eutra_layers == RRC_MAX_EUTRA_DED_PRI_LAYERS)
    {
      WRRC_MSG0_ERROR("ABSOL_PRI: Reached Maximum layers");
      break;
    }
    n_value--;
    n_index++;
  }
}

/*===========================================================================

FUNCTION   rrcmeas_update_dedicated_priority_info_from_ota

DESCRIPTION 
  This function updates the dedicated priority information stored with dedicated
  priority information in UTRAN Mobility Information (UMI) message.
  If dedicated priorities are configured, will start the validity timer also (T322)

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_update_dedicated_priority_info_from_ota
(
  rrc_DedicatedPriorityInformation *ded_pri_info_ptr
)
{
  uint8 priority;
  rrc_PriorityLevelList *pri_level_list_ptr = NULL;
  rrclog_wcdma_ded_pri_val_tmr_start_event_type ded_pri_tmr_start ;
  uint32 n_value=0, n_index=0;

  rrcmeas_invalidate_dedicated_priority_info();

  if(ded_pri_info_ptr->action.t == T_rrc_DedicatedPriorityInformation_action_clearDedicatedPriorities)
  {
    WRRC_MSG0_HIGH("ABSOL_PRI: Clear dedicated priority information");
#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
    /*call the same API as handling clear ded pri ind*/
    rrcmeas_handle_clear_dedicated_pri_ind();
#endif
  }
  else /*rrc_configureDedicatedPriorities*/
  {
    if(ded_pri_info_ptr->action.u.configureDedicatedPriorities->m.priorityLevelListPresent)
    {
      rrc_dedicated_priority_info.is_valid = TRUE;
      rrc_dedicated_priority_info.dedicated_priority_info_crit_sec = TRUE;
      pri_level_list_ptr = &(ded_pri_info_ptr->action.u.configureDedicatedPriorities->priorityLevelList);

      n_value = pri_level_list_ptr->n;
      while(n_value != 0)
      {
        if(pri_level_list_ptr->elem[n_index].m.priorityPresent)
        {
          priority = (uint8) pri_level_list_ptr->elem[n_index].priority;
        }
        else
        {
          WRRC_MSG0_HIGH("ABSOL_PRI: Priority not given in OTA, use lowest priority");
          priority = LOWEST_ABS_PRIORITY;
        }
        switch(pri_level_list_ptr->elem[n_index].radioAccessTechnology.t)
        {
          WRRC_MSG1_HIGH("ABSOL_PRI: RAT is %d [1/2/3/4 : UTRA FDD/UTRA TDD/EUTRA/GSM]",pri_level_list_ptr->elem[n_index].radioAccessTechnology.t);        
          case T_rrc_PriorityLevel_radioAccessTechnology_utraFDD:
            rrcmeas_update_utra_dedicated_priority_info_from_ota(
                priority,pri_level_list_ptr->elem[n_index].radioAccessTechnology.u.utraFDD);
            break;
          case T_rrc_PriorityLevel_radioAccessTechnology_gsm:
            rrcmeas_update_gsm_dedicated_priority_info_from_ota(
                priority,&pri_level_list_ptr->elem[n_index].radioAccessTechnology.u.gsm->gsm_CellGroup);
            break;
          case T_rrc_PriorityLevel_radioAccessTechnology_eutra:
            rrcmeas_update_eutra_dedicated_priority_info_from_ota(
                priority,pri_level_list_ptr->elem[n_index].radioAccessTechnology.u.eutra);            
            break;
          default :
            break;
        }
        n_index++;
        n_value--;
      }
    }

    ded_pri_tmr_start.validity_timer_in_ms = 0XFFFFFFFF; /*Set the maximum value*/
    if(ded_pri_info_ptr->action.u.configureDedicatedPriorities->m.t_322Present)
    {
      /*Derive the T322 values from OTA*/
      rrc_dedicated_priority_info.validity_timer = RRCMEAS_GET_T322_FROM_OTA(ded_pri_info_ptr->action.u.configureDedicatedPriorities->t_322);
      WRRC_MSG2_HIGH("ABSOL_PRI: T322 timer value from OTA in mins is %d, ded_prio_validity %d",rrc_dedicated_priority_info.validity_timer,rrc_dedicated_priority_info.is_valid);

      rrc_dedicated_priority_info.validity_timer *= (60*1000);
      if(!rrc_dedicated_priority_info.is_valid)
      {
        rrc_dedicated_priority_info.validity_timer = 0;
      }
    }
    if(rrc_dedicated_priority_info.is_valid && (rrc_dedicated_priority_info.validity_timer !=0))
    {
      /*Start the timer in ms*/
      rrctmr_start_timer(RRCTMR_DED_PRI_VALIDITY_TIMER,(rrc_dedicated_priority_info.validity_timer));
      ded_pri_tmr_start.validity_timer_in_ms = rrc_dedicated_priority_info.validity_timer;
    }
    rrc_dedicated_priority_info.plmn_id = rrc_ccm_get_curr_camped_plmn();
#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
    lte_rrc_dedicated_pri_set_owner(LTE_RRC_DEDICATED_PRI_OWNER_WCDMA);
#endif
    event_report_payload(EVENT_WCDMA_DED_PRIORITIES_VALIDITY_TIMER_START, sizeof(ded_pri_tmr_start),
                 (void *)&ded_pri_tmr_start);
  }
}


/*===========================================================================

FUNCTION   rrcmeas_update_dedicated_priority_info_from_irat_req

DESCRIPTION 
  This function updates the dedicated priority information stored with dedicated
   priority information received from interRAT message
   
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_update_dedicated_priority_info_from_irat_req
(
  lte_irat_dedicated_priority_info_s *irat_ded_priority_info,
  rrc_plmn_identity_type plmn_id
)
{
  uint8 idx;
  lte_irat_dedicated_priority_list_s *irat_ded_priority_list = &irat_ded_priority_info->priority_list;
  rrcmeas_invalidate_dedicated_priority_info();
  rrc_dedicated_priority_info.dedicated_priority_info_crit_sec = FALSE;

  if((irat_ded_priority_list->num_1x_band_class != 0) ||
      (irat_ded_priority_list->num_hrdp_band_class != 0)||
      (irat_ded_priority_list->num_eutra_freq != 0)||
      (irat_ded_priority_list->num_geran_freq != 0)||
      (irat_ded_priority_list->num_utra_fdd_freq != 0)||
      (irat_ded_priority_list->num_utra_tdd_freq != 0))
  {
    rrc_dedicated_priority_info.is_valid = TRUE;
  }
  else
  {
    WRRC_MSG0_HIGH("ABSOL_PRI: Dedicated Priority info absent in IRAT Req");
    return;
  }

  rrc_dedicated_priority_info.plmn_id = plmn_id;
  rrc_dedicated_priority_info.validity_timer =0;

  if(irat_ded_priority_info->rem_validity_timer_is_present)
  {
    rrc_dedicated_priority_info.validity_timer = irat_ded_priority_info->rem_validity_timer;
  }

  MSG_HIGH("ABSOL_PRI: Dedicated priority info num_utra_fdd_freq %d num_eutra_freq %d num_geran_freq %d",irat_ded_priority_list->num_utra_fdd_freq,
    irat_ded_priority_list->num_eutra_freq,irat_ded_priority_list->num_geran_freq);
  
  for(idx=0;idx<irat_ded_priority_list->num_utra_fdd_freq && idx < LTE_IRAT_MAX_UTRAN_FREQ;idx++)
  {
    rrc_dedicated_priority_info.utra_priority_layers[idx].frequency = 
        irat_ded_priority_list->utra_fdd_freq_list[idx].arfcn;
    rrc_dedicated_priority_info.utra_priority_layers[idx].priority= 
        irat_ded_priority_list->utra_fdd_freq_list[idx].priority;
    rrc_dedicated_priority_info.num_utra_layers++;
  }

  for(idx=0;idx<irat_ded_priority_list->num_eutra_freq && idx < LTE_IRAT_MAX_EUTRAN_FREQ;idx++)
  {
    rrc_dedicated_priority_info.eutra_priority_layers[idx].frequency = 
        irat_ded_priority_list->eutra_freq_list[idx].arfcn;
    rrc_dedicated_priority_info.eutra_priority_layers[idx].priority= 
        irat_ded_priority_list->eutra_freq_list[idx].priority;
    rrc_dedicated_priority_info.num_eutra_layers++;
  }

  for(idx=0;idx<irat_ded_priority_list->num_geran_freq && idx < LTE_IRAT_MAX_GERAN_FREQ;idx++)
  {
    rrc_dedicated_priority_info.gsm_priority_layers[idx].frequency = 
        irat_ded_priority_list->geran_freq_list[idx].arfcn;
    rrc_dedicated_priority_info.gsm_priority_layers[idx].priority= 
        irat_ded_priority_list->geran_freq_list[idx].priority;
    rrc_dedicated_priority_info.num_gsm_layers++;
  }

  rrc_dedicated_priority_info.num_utra_tdd_freq = irat_ded_priority_list->num_utra_tdd_freq;
  WCDMA_MEMCPY(rrc_dedicated_priority_info.utra_tdd_freq_list, 
               LTE_IRAT_MAX_UTRAN_FREQ * sizeof(lte_irat_reselection_priority_s),
               irat_ded_priority_list->utra_tdd_freq_list,
               LTE_IRAT_MAX_UTRAN_FREQ * sizeof(lte_irat_reselection_priority_s));

  rrc_dedicated_priority_info.num_hrdp_band_class = irat_ded_priority_list->num_hrdp_band_class;
  WCDMA_MEMCPY(rrc_dedicated_priority_info.cdma_hrpd_list, 
               LTE_IRAT_MAX_CDMA_BAND_CLASS * sizeof(lte_irat_cdma_reselection_priority_s),
               irat_ded_priority_list->cdma_hrpd_list,
               LTE_IRAT_MAX_CDMA_BAND_CLASS * sizeof(lte_irat_cdma_reselection_priority_s));

  rrc_dedicated_priority_info.num_1x_band_class = irat_ded_priority_list->num_1x_band_class;
  WCDMA_MEMCPY(rrc_dedicated_priority_info.cdma_1x_list, 
               LTE_IRAT_MAX_CDMA_BAND_CLASS * sizeof(lte_irat_cdma_reselection_priority_s),
               irat_ded_priority_list->cdma_1x_list,
               LTE_IRAT_MAX_CDMA_BAND_CLASS * sizeof(lte_irat_cdma_reselection_priority_s));

  if(rrc_dedicated_priority_info.validity_timer !=0)
  {
    /*Start the timer in ms*/
    rrctmr_start_timer(RRCTMR_DED_PRI_VALIDITY_TIMER,rrc_dedicated_priority_info.validity_timer);
  }
}

/*===========================================================================

FUNCTION   rrcmeas_populate_dedicated_priority_info_for_irat_req

DESCRIPTION 
  This function populates the dedicated priorioty info in inter request with the stored values
   
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_populate_dedicated_priority_info_for_irat_req
(
  lte_irat_dedicated_priority_info_s *irat_ded_priority_info
)
{
  uint8 idx;

#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO
  boolean is_band_valid;
  sys_sband_e_type band;
#endif

  lte_irat_dedicated_priority_list_s *irat_ded_priority_list = &irat_ded_priority_info->priority_list;

  irat_ded_priority_info->rem_validity_timer = 0;
  irat_ded_priority_list->num_utra_fdd_freq = irat_ded_priority_list->num_eutra_freq =
    irat_ded_priority_list->num_geran_freq= irat_ded_priority_list->num_utra_tdd_freq= 
    irat_ded_priority_list->num_hrdp_band_class = irat_ded_priority_list->num_1x_band_class = 0 ;
  irat_ded_priority_info->rem_validity_timer_is_present = FALSE;

  if(rrc_dedicated_priority_info.is_valid)
  {
    if(rrc_dedicated_priority_info.validity_timer != 0)
    {
      
      irat_ded_priority_info->rem_validity_timer_is_present = TRUE;
      irat_ded_priority_info->rem_validity_timer = rrctmr_get_remaining_time(RRCTMR_DED_PRI_VALIDITY_TIMER);
    }
	
    MSG_HIGH("ABSOL_PRI: Dedicated priority info num_utra_layers %d num_eutra_layers %d num_gsm_layers %d ",rrc_dedicated_priority_info.num_utra_layers,
      rrc_dedicated_priority_info.num_eutra_layers,rrc_dedicated_priority_info.num_gsm_layers);
    for(idx=0;idx<rrc_dedicated_priority_info.num_utra_layers && idx < LTE_IRAT_MAX_UTRAN_FREQ;idx++)
    {
      irat_ded_priority_list->utra_fdd_freq_list[idx].arfcn =
        rrc_dedicated_priority_info.utra_priority_layers[idx].frequency;
      irat_ded_priority_list->utra_fdd_freq_list[idx].priority = 
        rrc_dedicated_priority_info.utra_priority_layers[idx].priority;
      irat_ded_priority_list->num_utra_fdd_freq++;
    }

    for(idx=0;idx<rrc_dedicated_priority_info.num_eutra_layers && idx < LTE_IRAT_MAX_EUTRAN_FREQ;idx++)
    {
      irat_ded_priority_list->eutra_freq_list[idx].arfcn =
        rrc_dedicated_priority_info.eutra_priority_layers[idx].frequency;
      irat_ded_priority_list->eutra_freq_list[idx].priority =
        rrc_dedicated_priority_info.eutra_priority_layers[idx].priority;
       irat_ded_priority_list->num_eutra_freq++;
    }

    for(idx=0;idx<rrc_dedicated_priority_info.num_gsm_layers&& idx < LTE_IRAT_MAX_GERAN_FREQ;idx++)
    {
      irat_ded_priority_list->geran_freq_list[idx].arfcn =
        rrc_dedicated_priority_info.gsm_priority_layers[idx].frequency;
      irat_ded_priority_list->geran_freq_list[idx].priority =
        rrc_dedicated_priority_info.gsm_priority_layers[idx].priority ;
#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO
      band = geran_grr_get_arfcn_band (rrc_dedicated_priority_info.gsm_priority_layers[idx].frequency,
                            rrc_dedicated_priority_info.gsm_priority_layers[idx].band_ind,&is_band_valid);
      if(is_band_valid == TRUE)
        irat_ded_priority_list->geran_freq_list[idx].band = band;
#endif
      irat_ded_priority_list->num_geran_freq++;
    }

    irat_ded_priority_list->num_utra_tdd_freq = rrc_dedicated_priority_info.num_utra_tdd_freq ;
    WCDMA_MEMCPY(irat_ded_priority_list->utra_tdd_freq_list, 
                 LTE_IRAT_MAX_UTRAN_FREQ * sizeof(lte_irat_reselection_priority_s),
                 rrc_dedicated_priority_info.utra_tdd_freq_list,
                 LTE_IRAT_MAX_UTRAN_FREQ * sizeof(lte_irat_reselection_priority_s));

    irat_ded_priority_list->num_hrdp_band_class = rrc_dedicated_priority_info.num_hrdp_band_class;
    WCDMA_MEMCPY(irat_ded_priority_list->cdma_hrpd_list, 
                 LTE_IRAT_MAX_CDMA_BAND_CLASS * sizeof(lte_irat_cdma_reselection_priority_s),
                 rrc_dedicated_priority_info.cdma_hrpd_list,
                 LTE_IRAT_MAX_CDMA_BAND_CLASS * sizeof(lte_irat_cdma_reselection_priority_s));

    irat_ded_priority_list->num_1x_band_class = rrc_dedicated_priority_info.num_1x_band_class;
    WCDMA_MEMCPY(irat_ded_priority_list->cdma_1x_list, 
                 LTE_IRAT_MAX_CDMA_BAND_CLASS * sizeof(lte_irat_cdma_reselection_priority_s),
                 rrc_dedicated_priority_info.cdma_1x_list,
                 LTE_IRAT_MAX_CDMA_BAND_CLASS * sizeof(lte_irat_cdma_reselection_priority_s));
  }
}
/*===========================================================================

FUNCTION   rrcmeas_post_dedicated_priority_change_indication

DESCRIPTION 
  This function checks posts RRC_DED_PRI_CHANGE_IND to internal queue on reception of dedicated
  priority information in UTRAN Mobility Information (UMI) message

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_post_dedicated_priority_change_indication
(
  void
)
{
  rrc_cmd_type                  *rrc_cmd_ptr;
  rrc_cmd_ptr = rrc_get_int_cmd_buf();

  rrc_cmd_ptr->cmd_hdr.cmd_id = RRC_DED_PRI_CHANGE_IND;
  WRRC_MSG0_HIGH("ABSOL_PRI: Posting RRC_DED_PRI_CHANGE_IND");
  rrc_put_int_cmd(rrc_cmd_ptr);
}
/*===========================================================================

FUNCTION   rrcmeas_invalidate_dedicated_priority_info

DESCRIPTION 
  This function invalidates the dedicated priority information stored and stops the validity timer if running

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_invalidate_dedicated_priority_info
(
  void
)
{
  WRRC_MSG0_HIGH("ABSOL_PRI: Invalidate Ded priority info");
  rrctmr_stop_timer(RRCTMR_DED_PRI_VALIDITY_TIMER);
  rrc_dedicated_priority_info.is_valid = FALSE;
  rrc_dedicated_priority_info.validity_timer = 0;
  rrc_dedicated_priority_info.num_utra_layers = rrc_dedicated_priority_info.num_gsm_layers = 
      rrc_dedicated_priority_info.num_eutra_layers = 0;
  rrc_dedicated_priority_info.dedicated_priority_info_crit_sec = FALSE;
  rrc_dedicated_priority_info.num_hrdp_band_class = 0;
  rrc_dedicated_priority_info.num_1x_band_class = 0;
}

#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
/*===========================================================================

FUNCTION   rrcmeas_handle_get_dedicated_pri_req

DESCRIPTION 
  This function handles the get dedicated priorities req from inter RAT

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_handle_get_dedicated_pri_req
(
  rrc_cmd_type* cmd_ptr
)
{
  if((cmd_ptr->cmd_hdr.cmd_id == RRC_LTE_RRC_CMD) &&
      (WCDMA_RRC_LTE_GET_DEDICATED_PRI_REQ == cmd_ptr->cmd.wcdma_rrc_lte_irat_cmd.cmd.msg_hdr.id))
  {
    wcdma_rrc_lte_get_dedicated_pri_rsp_type *get_ded_pri_rsp = rrc_malloc(sizeof(wcdma_rrc_lte_get_dedicated_pri_rsp_type));
    memset(get_ded_pri_rsp,0,sizeof(wcdma_rrc_lte_get_dedicated_pri_rsp_type));
    rrcmeas_populate_dedicated_priority_info_for_irat_req(&get_ded_pri_rsp->dedicated_pri_info);
    get_ded_pri_rsp->dedicated_pri_valid = rrc_dedicated_priority_info.is_valid;
    get_ded_pri_rsp->plmn = mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_dedicated_priority_info.plmn_id);
    rrc_send_lte_cmd(&get_ded_pri_rsp->msg_hdr,WCDMA_RRC_LTE_GET_DEDICATED_PRI_RSP,sizeof(wcdma_rrc_lte_get_dedicated_pri_rsp_type));
    rrc_free(get_ded_pri_rsp);
  }
}

/*===========================================================================

FUNCTION   rrcmeas_handle_clear_dedicated_pri_ind

DESCRIPTION 
  This function handles the clear dedicated priorities ind from inter RAT

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_handle_clear_dedicated_pri_ind
(
  void
)
{
  if(LTE_RRC_DEDICATED_PRI_OWNER_WCDMA == lte_rrc_dedicated_pri_get_owner())
  {
    lte_rrc_dedicated_pri_set_owner(LTE_RRC_DEDICATED_PRI_OWNER_NONE);
    WRRC_MSG0_HIGH("DED_PRI: Owner set to None");
  }
}
/*===========================================================================

FUNCTION   rrcmeas_send_clear_ded_pri_ind_set_owner

DESCRIPTION 
  This function checks the current owner of dedicated priorities and send the clear ind to the owner and
  sets owner
   
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_send_clear_ded_pri_ind_set_owner
(
  void
)
{
  lte_rrc_dedicated_pri_owner_e curr_owner =lte_rrc_dedicated_pri_get_owner();

  if((rrc_dedicated_priority_info.is_valid) && (LTE_RRC_DEDICATED_PRI_OWNER_NONE != curr_owner))
  {
    lte_rrc_dedicated_pri_set_owner(LTE_RRC_DEDICATED_PRI_OWNER_WCDMA);
  }
  else
  {
    lte_rrc_dedicated_pri_set_owner(LTE_RRC_DEDICATED_PRI_OWNER_NONE);
  }

  switch(curr_owner)
  {
    case LTE_RRC_DEDICATED_PRI_OWNER_LTE:
      {
        lte_rrc_clear_dedicated_pri_ind_s clear_ded_pri_ind;
        rrc_send_lte_cmd(&clear_ded_pri_ind.msg_hdr,LTE_RRC_CLEAR_DEDICATED_PRI_IND,sizeof(lte_rrc_clear_dedicated_pri_ind_s));
        WRRC_MSG0_HIGH("LTOW: LTE_RRC_CLEAR_DEDICATED_PRI_IND sent to LTE RRC");
      }
      break;
#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO
    case LTE_RRC_DEDICATED_PRI_OWNER_GERAN:
      {
        rr_clear_dedicated_priorities_ind_type clear_ded_pri_ind;
        /* Send the RR_CLEAR_DEDICATED_PRIORITIES_IND message to RR */
        rr_send_rrc_message_to_rr_internal((void *)(&(clear_ded_pri_ind)), RR_CLEAR_DEDICATED_PRIORITIES_IND,
                       sizeof(rr_clear_dedicated_priorities_ind_type));

        WRRC_MSG0_HIGH("WTOG: RR_CLEAR_DEDICATED_PRIORITIES_IND sent to GSM RR");
      }
      break;
#endif
    default :
      break;
  }
}
/*===========================================================================

FUNCTION   rrcmeas_send_get_dedicated_priority_req

DESCRIPTION 
  This function checks the current owner of dedicated priorities and send the get req to the owner
   
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_send_get_dedicated_priority_req
(
  void
)
{
  lte_rrc_dedicated_pri_owner_e owner =lte_rrc_dedicated_pri_get_owner();

  if(LTE_RRC_DEDICATED_PRI_OWNER_WCDMA != owner)
  {
    rrcmeas_invalidate_dedicated_priority_info();
  }
  else
  {
    return;
  }
  switch(owner)
  {
    case LTE_RRC_DEDICATED_PRI_OWNER_LTE:
      {
        lte_rrc_get_dedicated_pri_req_s get_ded_pri_req;
        rrc_send_lte_cmd(&get_ded_pri_req.msg_hdr,LTE_RRC_GET_DEDICATED_PRI_REQ,sizeof(lte_rrc_get_dedicated_pri_req_s));
        WRRC_MSG0_HIGH("LTOW: LTE_RRC_GET_DEDICATED_PRI_REQ sent to LTE RRC");
      }
      break;
#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO
    case LTE_RRC_DEDICATED_PRI_OWNER_GERAN:
      {
        rr_dedicated_priorities_req_type get_ded_pri_req;
        /* Send the RR_DEDICATED_PRIORITIES_REQ message to RR */
       rr_send_rrc_message_to_rr_internal((void *)(&(get_ded_pri_req)), RR_DEDICATED_PRIORITIES_REQ,
                      sizeof(rr_dedicated_priorities_req_type));

        WRRC_MSG0_HIGH("WTOG: RR_DEDICATED_PRIORITIES_REQ sent to GSM RR");

      }
      break;
#endif
    default:

      break;
  }
}
#endif

#ifdef FEATURE_WCDMA_DEDICATED_PRI_INFO

/*===========================================================================

FUNCTION   rrcmeas_handle_gsm_get_dedicated_pri_req

DESCRIPTION 
  This function handles the get dedicated priorities req from inter RAT

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_handle_gsm_get_dedicated_pri_req
(
  rrc_rr_cmd_type* cmd_ptr
)
{
  if(cmd_ptr->cmd_hdr.cmd_id == RRC_DEDICATED_PRIORITIES_REQ)
  {
    rrc_dedicated_priorities_rsp_type *get_ded_pri_rsp = rrc_malloc(sizeof(rrc_dedicated_priorities_rsp_type));
    memset(get_ded_pri_rsp,0,sizeof(rrc_dedicated_priorities_rsp_type));
    rrcmeas_populate_dedicated_priority_info_for_irat_req(&get_ded_pri_rsp->dedicated_pri_info);
    get_ded_pri_rsp->dedicated_pri_valid = rrc_dedicated_priority_info.is_valid;
    get_ded_pri_rsp->plmn = mmumts_convert_rrc_plmn_id_to_nas_plmn_id(rrc_dedicated_priority_info.plmn_id);

        /* Send the RRC_DEDICATED_PRIORITIES_RSP message to RR */
        rr_send_rrc_message_to_rr_internal((void *)((get_ded_pri_rsp)), RRC_DEDICATED_PRIORITIES_RSP,
                   sizeof(rrc_dedicated_priorities_rsp_type));
        rrc_free(get_ded_pri_rsp);
  }
}

#if 0

/*===========================================================================

FUNCTION   rrcmeas_send_clear_ded_pri_ind_set_owner_gsm

DESCRIPTION 
  This function checks the current owner of dedicated priorities and send the clear ind to the owner and
  sets owner
   
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_send_clear_ded_pri_ind_set_owner_gsm
(
  void
)
{
  lte_rrc_dedicated_pri_owner_e curr_owner =lte_rrc_dedicated_pri_get_owner();

  if((rrc_dedicated_priority_info.is_valid) && (LTE_RRC_DEDICATED_PRI_OWNER_NONE != curr_owner))
  {
    lte_rrc_dedicated_pri_set_owner(LTE_RRC_DEDICATED_PRI_OWNER_WCDMA);
  }
  else
  {
    lte_rrc_dedicated_pri_set_owner(LTE_RRC_DEDICATED_PRI_OWNER_NONE);
  }

  switch(curr_owner)
  {
    case LTE_RRC_DEDICATED_PRI_OWNER_GERAN:
      {
        rr_clear_dedicated_priorities_ind_type clear_ded_pri_ind;
        /* Send the RR_CLEAR_DEDICATED_PRIORITIES_IND message to RR */
        rr_send_rrc_message_to_rr_internal((void *)(&(clear_ded_pri_ind)), RR_CLEAR_DEDICATED_PRIORITIES_IND,
                        sizeof(rr_clear_dedicated_priorities_ind_type));

        WRRC_MSG0_HIGH("WTOG: RR_CLEAR_DEDICATED_PRIORITIES_IND sent to GSM RR");
      }
      break;
    default :
      WRRC_MSG1_HIGH("Invalid/Unsupported Owner %d",curr_owner);
      break;
  }
}

/*===========================================================================

FUNCTION   rrcmeas_send_get_dedicated_priority_req_to_gsm

DESCRIPTION 
  This function checks the current owner of dedicated priorities and send the get req to the owner
   
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_send_get_dedicated_priority_req_to_gsm
(
  void
)
{
  lte_rrc_dedicated_pri_owner_e owner =lte_rrc_dedicated_pri_get_owner();
  if(LTE_RRC_DEDICATED_PRI_OWNER_WCDMA != owner)
  {
    rrcmeas_invalidate_dedicated_priority_info();
  }
  else
  {
    WRRC_MSG0_HIGH("WCDMA is the owner of dedicated priorites");
    return;
  }
  switch(owner)
  {
    case LTE_RRC_DEDICATED_PRI_OWNER_GERAN:
      {
        rr_dedicated_priorities_req_type get_ded_pri_req;
        /* Send the RR_DEDICATED_PRIORITIES_REQ message to RR */
        rr_send_rrc_message_to_rr_internal((void *)(&(get_ded_pri_req)), RR_DEDICATED_PRIORITIES_REQ,
                     sizeof(rr_dedicated_priorities_req_type));

        WRRC_MSG0_HIGH("WTOG: RR_DEDICATED_PRIORITIES_REQ sent to GSM RR");
      }
      break;
    default:
      WRRC_MSG1_HIGH("Owner %d",owner);
      break;
  }
}
#endif

#endif
#ifdef FEATURE_EUTRA_DETECT
/*===========================================================================

FUNCTION   rrc_check_eutradetect_ie

DESCRIPTION 
  This function returns TRUE if eutra detection IE is set in SIB19 otherwise reruns FALSE
   
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/

boolean rrc_check_eutradetect_ie()
{
  return is_sib19_eutradetect_present;
}

#endif
#endif

#ifdef FEATURE_FEMTO_CSG
/*===========================================================================

FUNCTION   rrcmeas_send_csg_mes_info_to_l1

DESCRIPTION 
  Sends CSG meas request to wl1 after ASF
   
DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
void rrcmeas_send_csg_mes_info_to_l1(rrc_csp_temp_csg_cell_list *csg_info)
{
  rrc_cmd_type *rrc_meas_out_cmd_ptr;
  uint32 i;
  l1_req_cmd * llc_cmd_l1_req = NULL;

  rrc_meas_out_cmd_ptr = rrc_get_int_cmd_buf();

    
    RRC_GET_POINTER_L1_REQ_VALUE(rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.l1_req,llc_cmd_l1_req);

    /* Initialize the LLC command header first */

    rrc_meas_out_cmd_ptr->cmd_hdr.cmd_id= RRC_LLC_CMD_REQ;
    rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.procedure = RRC_PROCEDURE_MCMR;

    rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.cmd_dest = LAYER1_PHY;

    /* Now fill the L1 cmd header */
    rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.l1_cmd.cmd_id = CPHY_MEASUREMENT_REQ;

    /* act_time_type */
    rrc_meas_out_cmd_ptr->cmd.rrc_llc_req.l1_cmd.act_time_type =
      L1_ACTIVATION_TIME_NONE;

    /* Now allocate memory to the pointer inside the command */
    llc_cmd_l1_req->meas.meas_ptr =
          (l1_meas_parm_type *)rrc_malloc_interlayer_cmd(sizeof(l1_meas_parm_type));
    llc_cmd_l1_req->meas.meas_ptr->parm_type = L1_CSG_MEAS_INFO_PARAMS;
    llc_cmd_l1_req->meas.meas_ptr->u.csg_meas.num_csg_cells =  csg_info->num_entries;   
    llc_cmd_l1_req->meas.meas_ptr->u.csg_meas.interf_csg_cells_included = FALSE;
    llc_cmd_l1_req->meas.meas_ptr->u.csg_meas.intraf_csg_cells_included = FALSE;
    for(i=0; i < csg_info->num_entries; i++)
    {
      WCDMA_MEMCPY((void *)&(llc_cmd_l1_req->meas.meas_ptr->u.csg_meas.csg_info_list[i]),
                   sizeof(l1_meas_csg_list_type),
                   (void*)&(csg_info->csg_cell_info[i].csg_cell_l1_info),
                   sizeof(l1_meas_csg_list_type));

      if(csg_info->csg_cell_info[i].csg_cell_l1_info.rat == SYS_RAT_UMTS_RADIO_ACCESS)
      {
        if(csg_info->csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.freq == rrc_ccm_get_curr_camped_freq())
        {
          if(csg_info->csg_cell_info[i].csg_cell_l1_info.rat_u.wcell.csg_id != SYS_CSG_ID_INVALID)
          {
            llc_cmd_l1_req->meas.meas_ptr->u.csg_meas.intraf_csg_cells_included = TRUE;
          }
        }
        else
        {
          llc_cmd_l1_req->meas.meas_ptr->u.csg_meas.interf_csg_cells_included = TRUE;
        }
      }

    }


  /* Send the Internal RRC Command - LLC should directly handle it */
  rrc_put_int_cmd( rrc_meas_out_cmd_ptr );
  
}
#endif

#ifdef FEATURE_WCDMA_REL9


/*===========================================================================

FUNCTION   RRCMEAS_CHECK_MCM_FOR_SETUP_MODIFY_ADDITIONAL_EXTN

DESCRIPTION

  This function checks if the existing measurement already exists
  in the measurement database. If yes, then it deletes the
  additional measurement associated with it. Also for a modify
  it checks if UTRAN tries to add more than the maximum no of
  allowed measurements, then it rejects the configuration

DEPENDENCIES

  None

RETURN VALUE

  True/False

SIDE EFFECTS

  None
===========================================================================*/
boolean rrcmeas_check_mcm_for_setup_modify_additional_extn
(
 boolean addtl_meas_incl,
 rrcmeas_layer_e_type primary_meas_type,
 uint32 mid,
 rrc_AdditionalMeasurementID_List_r9 * local_addtl_meas_list_ptr
)
{

  uint8 count = 0, cnt = 0, addtl_meas_cnt = 0;

  if (((addtl_meas_incl == TRUE) && (local_addtl_meas_list_ptr == NULL)) || (addtl_meas_incl == FALSE))
  {
    MSG_LOW("Addtl Meas ptr NULL or addnl meas incl %d",addtl_meas_incl,0,0);
  }
  else
  {
    /* Count no of addtl meas specified by UTRAN */
    addtl_meas_cnt = local_addtl_meas_list_ptr->n;
    if (addtl_meas_cnt > MAX_ADDITIONAL_MEAS)
    {
      WRRC_MSG1_ERROR("Addtl Meas specified %d, Max is 4", addtl_meas_cnt);
      return FALSE;
    }
  }

  switch(primary_meas_type)
  {
  case INTRA_FREQ:
    /* Indicates that it is a setup-> Find if this meas already existed */
/* Only if that meas already existed, just delete the addtional meas */
    for (count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
    {
      if (intra_freq_meas_id_list[count].meas_id == mid)
      {
        /* Clear Addtl Meas */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          intra_freq_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;
        break; /* Come out of for of intra freq meas */
      }
    } /* End of for of Intra Freq */

    break; /* Come out of switch */


  case INTER_SYS:
    /* Indicates that it is a setup-> Find if this meas already existed */
      /* Only if that meas already existed, just delete the addtional meas */
    for (count = 0; count < MAX_INTER_RAT_MEAS; count++ )
    {
      if (inter_rat_meas_id_list[count].meas_id == mid)
      {
        /* Clear Addtl Meas */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          inter_rat_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;

        break; /* Come out of for of Inter RAT meas */
      }
    } /* End of for of Inter RAT */

    
    break;

  case MAC_MEAS:
    /* Indicates that it is a setup-> Find if this meas already existed */

      /* Only if that meas already existed, just delete the addtional meas */
    for (count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
    {
      if (tvm_meas_id_list[count].meas_id == mid)
      {
        /* Clear Addtl Meas */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          tvm_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;

        break; /* Come out of for of TVM */
      }
    } /* End of for of TVM */

    
    break;

  case INTERNAL_MEAS:
    /* Indicates that it is a setup-> Find if this meas already existed */
   
    /* Only if that meas already existed, just delete the addtional meas */
    for (count = 0; count < MAX_INTERNAL_MEAS; count++ )
    {
      if (ueim_meas_id_list[count].meas_id == mid)
      {
        /* Clear Addtl Meas */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          ueim_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;

        break; /* Come out of for of UEIM */
      }
    } /* End of for of UEIM */
  
    break;


  case INTER_FREQ:

    /* Indicates that it is a setup-> Find if this meas already existed */
    
      /* Only if that meas already existed, just delete the addtional meas */
    for (count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
    {
      if (inter_freq_meas_id_list[count].meas_id == mid)
      {
        /* Clear Addtl Meas */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          inter_freq_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;

        break; /* Come out of for of IFREQ */
      }
    } /* End of for of IFREQ */
    break;


  case QUALITY_MEAS:
    /* Indicates that it is a setup-> Find if this meas already existed */
    
      /* Only if that meas already existed, just delete the addtional meas */
    for (count = 0; count < MAX_QUALITY_MEAS; count++ )
    {
      if (quality_meas_id_list[count].meas_id == mid)
      {
        /* Clear Addtl Meas */
        for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          quality_meas_id_list[count].additional_meas[cnt] = INVALID_MEAS_ID;

        break; /* Come out of for of intra freq meas */
      }
    } /* End of for of Intra Freq */
    break; /* Come out of switch */

  default:
    return FALSE;

  } /* End of switch */

  WRRC_MSG1_HIGH("Overwrite Addnl Meas %d", mid);

  return TRUE;
}


/*===========================================================================

FUNCTION   RRCMEAS_CONFIG_INTRA_FREQ_DB_R9

DESCRIPTION

  Sets Intra Freq Reporting Criteria in RRC Measurement Database
  from Measurement Control Message for release 9 after the validation of
  the message has been completed

DEPENDENCIES

  None

RETURN VALUE

  None

SIDE EFFECTS

  None
===========================================================================*/

boolean rrcmeas_config_intra_freq_db_r9
(
 l1_meas_ctrl_parm_struct_type* l1_mcm_ptr,
 meas_validity_enum_type m_validity,
 rrc_MeasurementControl_r9 *mcm_r9
)
{
  uint16 count = 0;
  uint8 meas_id_val = 0;

  rrc_MeasurementControl_r9_IEs* rrc_mcm_ptr = NULL;

  rrc_mcm_ptr = &mcm_r9->measurementControl_r9;

  
  /* First check if the meas id already exists */

  /* SETUP existing & MODIFY scenario */
  for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
  {
    if (intra_freq_meas_id_list[count].meas_id == l1_mcm_ptr->meas_id)
    {
      MSG_HIGH("Meas id found...Before commiting Id %d, Val %d, Owner %d",intra_freq_meas_id_list[count].meas_id,
        intra_freq_meas_id_list[count].meas_validity,
        intra_freq_meas_id_list[count].mcm_owned);


      /* If a setup, always overwrite validity */
      if (l1_mcm_ptr->meas_cmd == L1_MEAS_SETUP)
      {
        /* Set Validity */
        intra_freq_meas_id_list[count].meas_validity = m_validity;
      }
      /* For MODIFY scenario, when validity not specified */
      else if ((l1_mcm_ptr->meas_cmd == L1_MEAS_MODIFY) &&
        (l1_mcm_ptr->meas_object_info_included == TRUE) &&
        (m_validity == NOT_PRESENT))
      {
        MSG_LOW("Retain Current Validity %d", intra_freq_meas_id_list[count].meas_validity,0,0);
      }
      /* UTRAN specified Meas Validity with a Modify */
      else if ((l1_mcm_ptr->meas_cmd == L1_MEAS_MODIFY) &&
        (l1_mcm_ptr->meas_object_info_included == TRUE) &&
        (m_validity != NOT_PRESENT))
      {
        MSG_LOW("Overwrite Current Validity %d with %d",
          intra_freq_meas_id_list[count].meas_validity,m_validity,0);

        intra_freq_meas_id_list[count].meas_validity = m_validity;
      }
      else /* To satisfy LINT */
      {
        /* Normal processing */
      }

      /* MCM is the owner of this meas */
      intra_freq_meas_id_list[count].mcm_owned = TRUE;

      /* This Meas can be reported */
      intra_freq_meas_id_list[count].meas_can_be_reported = TRUE;

      /* Set Report Criteria */
      /* Do not modify rpt_crit for RPT_MODE_NOT_PRESENT and NO_CHANGE */
      if ((l1_mcm_ptr->meas_object_info_included == TRUE) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[PRI_FREQ] != L1_RPT_MODE_NOT_PRESENT) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[PRI_FREQ] != L1_NO_CHANGE))
      {
         intra_freq_meas_id_list[count].rpt_crit[PRI_FREQ] =
          MEAS_RPT_CRIT(l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[PRI_FREQ]);

      }
      WRRC_MSG1_HIGH("Meas Crit for Primary freq %d",  intra_freq_meas_id_list[count].rpt_crit[PRI_FREQ]);

#ifdef FEATURE_WCDMA_DC_HSUPA
      /* Set Report Criteria */
      /* Do not modify rpt_crit for RPT_MODE_NOT_PRESENT and NO_CHANGE */
      if ((l1_mcm_ptr->meas_object_info_included == TRUE) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[SEC_FREQ] != L1_RPT_MODE_NOT_PRESENT) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[SEC_FREQ] != L1_NO_CHANGE))
      {
        intra_freq_meas_id_list[count].rpt_crit[SEC_FREQ] =
          MEAS_RPT_CRIT(l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[SEC_FREQ]);

      }
      WRRC_MSG1_HIGH("Meas Crit for secondary freq %d", intra_freq_meas_id_list[count].rpt_crit[SEC_FREQ]);
#endif

      MSG_HIGH("After commiting Id %d, Val %d, Owner %d",intra_freq_meas_id_list[count].meas_id,
        intra_freq_meas_id_list[count].meas_validity,
        intra_freq_meas_id_list[count].mcm_owned);

      return TRUE;
    }

  } /* End of for loop */
  WRRC_MSG1_HIGH("New Meas Id = %d configured. Set params",l1_mcm_ptr->meas_id);

  /* SETUP not existing scenario */
  for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
  {
    /* If Meas Id not found, then it is a new Meas. Set it in first available position */
    if (intra_freq_meas_id_list[count].meas_id == INVALID_MEAS_ID)
    {
      MSG_HIGH("Before commiting Id %d, Val %d, Owner %d",intra_freq_meas_id_list[count].meas_id,
               intra_freq_meas_id_list[count].meas_validity,
               intra_freq_meas_id_list[count].mcm_owned);

      if((rrc_meas_id_extn_support) && (TRUE == rrcmeas_check_if_meas_id_extn_is_given(mcm_r9,&meas_id_val)))
      {
        intra_freq_meas_id_list[count].meas_id = meas_id_val;

        /* Set this only if extended measurements is supported */
        /* This needs to be set while sending measurement report */
        intra_freq_meas_id_list[count].meas_id_legacy = rrc_mcm_ptr->measurementIdentity;

        WRRC_MSG1_HIGH("Setting Legacy Meas Id = %d in RRC db",rrc_mcm_ptr->measurementIdentity);
      }
      else
      {
        intra_freq_meas_id_list[count].meas_id = rrc_mcm_ptr->measurementIdentity;
      }

#ifdef FEATURE_WCDMA_DC_HSUPA	  
      intra_freq_meas_id_list[count].rpt_crit[SEC_FREQ] = NOT_AVAILABLE;
#endif
      intra_freq_meas_id_list[count].rpt_crit[PRI_FREQ] = NOT_AVAILABLE;

      intra_freq_meas_id_list[count].meas_validity = m_validity;

      intra_freq_meas_id_list[count].mcm_owned = TRUE;

      intra_freq_meas_id_list[count].meas_can_be_reported = TRUE;

      /* Set Report Criteria */
      /* Do not modify rpt_crit for RPT_MODE_NOT_PRESENT and NO_CHANGE */
      if ((l1_mcm_ptr->meas_object_info_included == TRUE) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[PRI_FREQ] != L1_RPT_MODE_NOT_PRESENT) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[PRI_FREQ] != L1_NO_CHANGE))

      {
         intra_freq_meas_id_list[count].rpt_crit[PRI_FREQ] =
         MEAS_RPT_CRIT(l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[PRI_FREQ]);

      }
      WRRC_MSG1_HIGH("Meas Crit for Primary freq %d saved in RRC",  intra_freq_meas_id_list[count].rpt_crit[PRI_FREQ]);

#ifdef FEATURE_WCDMA_DC_HSUPA
      /* Set Report Criteria */
      /* Do not modify rpt_crit for RPT_MODE_NOT_PRESENT and NO_CHANGE */
      if ((l1_mcm_ptr->meas_object_info_included == TRUE) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[SEC_FREQ] != L1_RPT_MODE_NOT_PRESENT) &&
          (l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[SEC_FREQ] != L1_NO_CHANGE))
      {
         intra_freq_meas_id_list[count].rpt_crit[SEC_FREQ] =
         MEAS_RPT_CRIT(l1_mcm_ptr->meas_object.u.intra_f.rpt_mode[SEC_FREQ]);

      }
      WRRC_MSG1_HIGH("Meas Crit for secondary freq %d", intra_freq_meas_id_list[count].rpt_crit[SEC_FREQ]);
#endif

      MSG_HIGH("After commiting Id %d, Val %d, Owner %d",intra_freq_meas_id_list[count].meas_id,
               intra_freq_meas_id_list[count].meas_validity,
               intra_freq_meas_id_list[count].mcm_owned);

      return TRUE;
    }
  } /* End of for loop */

  WRRC_MSG0_ERROR("RRC MeasDB for IntraFreq FULL!!");
  return FALSE;
}

/*===========================================================================

FUNCTION   RRCMEAS_VALIDATE_ADDITIONAL_MEAS

DESCRIPTION

    This function checks if additional measurements exists in RRC database and have the
    same validity as the primary measurement. If it
    exists, it returns its type else returns unknown Measurement which essentially
    implies that the additional measurement does not exist. The function also returns
    the reporting criteria as per the measurement type. The reporting criteria is used by
    the calling function to determine if UTRAN is trying to append an event triggered meas
    The function also sends Measurement Control Failure Message in case of error cond.
    This function is only used if primary measurement is other than Traffic Volume
    Measurements


DEPENDENCIES

    None.

RETURN VALUE

    True if additional measurement has been validated successfully
    False Otherwise

SIDE EFFECTS

    None

===========================================================================*/

boolean rrcmeas_validate_additional_meas_extn
(
  rrc_AdditionalMeasurementID_List_r9 * additional_list_ptr,
  uint32 tr_id,
  rrcmeas_layer_e_type* primary_meas_type_ptr,
  uint32 mid,
  meas_validity_enum_type* p_meas_validity  
)
{
  rrcmeas_layer_e_type additional_meas_type;

  rpt_crit_enum_type a_rpt_crit;

  uint16 additional_meas_id;
  uint32 idx =0;
  uint8 transaction_id = INVALID_TRANSACTION_ID;
  /* Set validity to default value */
  meas_validity_enum_type addtl_meas_validity = NOT_PRESENT;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;
  transaction_id = tr_id;

  switch (*primary_meas_type_ptr)
  {
  case INTRA_FREQ:
  case INTER_FREQ:
  case INTER_SYS:
  case QUALITY_MEAS:
  case INTERNAL_MEAS:


      while (additional_list_ptr->n > idx)
      {
        additional_meas_id = (uint16) additional_list_ptr->elem[idx];

        /* First check if additional measurement exists in RRC DB or not */

        additional_meas_type = rrcmeas_find_additional_meas_type(&additional_meas_id, &a_rpt_crit, &addtl_meas_validity);

        MSG_5(MSG_SSID_DIAG, MSG_LEGACY_HIGH,
          "Addtl Meas %d,PMeas %d, add_meas type %d rpt_crit %d meas_validity %d",additional_meas_id,
          mid,additional_meas_type,a_rpt_crit, addtl_meas_validity);

   
        if (additional_meas_type == UNKNOWN_MEAS)
        {
          /* Set transaction ID */
          rrcmeas_mcf.rrc_transaction_id = transaction_id;

          /* Set error t */
          rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

          /* Send MCF msg to UTRAN */
          rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

          return FALSE;
        } /* End of if of rrcmeas_find_additional_meas_type */

   
        if (additional_meas_type == QUALITY_MEAS)
        {
          /* Set transaction ID */
          rrcmeas_mcf.rrc_transaction_id = transaction_id;

          /* Set error t */
          rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_invalidConfiguration;

          /* Send MCF msg to UTRAN */
          rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

          return FALSE;
        }
        /* To Add check if more than one meas of same type would be include with Prim Meas */

        /* UTRAN might messup by making addtl meas as Event Triggered for
        Intra Freq, Inter Freq, Inter RAT */

        if (((additional_meas_type == INTER_FREQ) && (a_rpt_crit == EVENT)) ||
          ((additional_meas_type == INTRA_FREQ) && (a_rpt_crit == EVENT)) ||
          ((additional_meas_type == INTER_SYS)  && (a_rpt_crit == EVENT)))
        {
          /* Set transaction ID */
          rrcmeas_mcf.rrc_transaction_id = transaction_id;

          /* Set error t */
          rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

          /* Send MCF msg to UTRAN */
          rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

          return FALSE;
        }

        /* Get VALIDITY of primary measurement */

        /* Check validity of the additional and primary meas */
        /* Since Primary is an intra-freq meas, it is valid in CELL_DCH only */
        if (addtl_meas_validity == ALL_STATES_BUT_DCH)
        {
          /* Set transaction ID */
          rrcmeas_mcf.rrc_transaction_id = transaction_id;

          /* Set error t */
          rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_invalidConfiguration;

          /* Send MCF msg to UTRAN */
          rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

          return FALSE;
        }

        /* Go to the next addtl Meas to be appended */
        idx++;

      } /* End of while */

    break;

    case MAC_MEAS:
    while (additional_list_ptr->n > idx)
    {
      additional_meas_id = (uint16) additional_list_ptr->elem[idx];

      /* First check if additional measurement exists in RRC DB or not */

      additional_meas_type = rrcmeas_find_additional_meas_type(&additional_meas_id, &a_rpt_crit, &addtl_meas_validity);

      MSG_5(MSG_SSID_DIAG, MSG_LEGACY_HIGH,
        "Addtl Meas %d,PMeas %d, add_meas type %d rpt_crit %d meas_validity %d",additional_meas_id,
         mid,additional_meas_type,a_rpt_crit, addtl_meas_validity);

        if (additional_meas_type == QUALITY_MEAS)
      {
        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

        return FALSE;
        }
        if (additional_meas_type == UNKNOWN_MEAS)
      {
        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_invalidConfiguration;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

        return FALSE;
        } /* End of if of rrcmeas_find_additional_meas_type */

        /* Check if more than one meas of same type would be include with Prim Meas */
        if (additional_meas_type == MAC_MEAS)
      {
        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;
        /* Set error t */
          rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_invalidConfiguration;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

        return FALSE;
        } /* End of if of rrcmeas_find_additional_meas_type */


          /* UTRAN might messup by making addtl meas as Event Triggered for 
        Intra Freq, Inter Freq, Inter RAT */

        if (((additional_meas_type == INTER_FREQ) && (a_rpt_crit == EVENT)) || 
          ((additional_meas_type == INTER_SYS)  && (a_rpt_crit == EVENT)) ||
          ((additional_meas_type == INTERNAL_MEAS)  && (a_rpt_crit == EVENT)))
        {

        /* Set transaction ID */
        rrcmeas_mcf.rrc_transaction_id = transaction_id;

        /* Set error t */
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_invalidConfiguration;

        /* Send MCF msg to UTRAN */
        rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

        return FALSE;
      }
        /* Get VALIDITY of primary measurement */
        
        /* Check validity of the additional and primary meas */
        /* For now, since additional is non traffic volume, 
        it is valid in CELL_DCH only */
        if (addtl_meas_validity == *p_meas_validity)
        {
          MSG_LOW("TVM:Validity Addtl & Primary Meas Match",0,0,0);
        }
        /* Possible as Traffic Vol is ALL_STATES and addtl is CELL_DCH */
        else if ((*p_meas_validity == ALL_STATES) || ((*p_meas_validity == NOT_PRESENT) &&
          (rrcmeas_current_substate == RRCMEAS_CELL_DCH)))
        {
          MSG_LOW("TVM:P.Meas Validity is all states/Not Present",0,0,0);
        }
      else
      {
          WRRC_MSG2_ERROR("TVM:Validity Addtl Meas %d,P Meas %d Differ",
            additional_meas_id,tvm_meas_id_list[idx].meas_id);
        return FALSE;
      }

      /* Go to the next addtl Meas to be appended */
      idx++;

    } /* End of while */
    /* If we reach this stage, then additional meas are valid */
    break;

  default:
    /* Bail Out */
    rrcmeas_mcf.rrc_transaction_id = transaction_id;

    /* Set error t */
    rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

    /* Send MCF msg to UTRAN */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

    return FALSE;

  } /* End of switch */
  return TRUE;
}


/*===========================================================================

FUNCTION   RRCMEAS_SET_ADDITIONAL_MEAS_IN_DB

DESCRIPTION

  This function sets Additional Measurements in
  RRC database for the measurement type. This function is only called if
  it has been determined previously that the primary measurement exists
  and the new additional measurement does not conflict with the primary
  measurement validity and reporting criteria


DEPENDENCIES

  None

RETURN VALUE

  None

SIDE EFFECTS

  None

===========================================================================*/

void rrcmeas_set_additional_meas_extn_in_db
(
 rrcmeas_layer_e_type* meas_type_ptr,
 rrc_MeasurementControl_r9 *mcm_r9, 
 uint32 meas_id
)
{
  uint8 count = 0, cnt = 0;
  boolean adnl_meas_exist;
  uint32 idx=0;

  rrc_AdditionalMeasurementID_List_r9 * additional_list_ptr = NULL;

  additional_list_ptr = &mcm_r9->v970NonCriticalExtensions.measurementControl_v970ext.additionalMeasurementList;


  switch(*meas_type_ptr)
  {
  case INTRA_FREQ:
    /* Now Store Additional Meas in RRC DB */

    for (count = 0; count < MAX_INTRA_FREQ_MEAS; count++)
    {
      if (intra_freq_meas_id_list[count].meas_id == meas_id)
      {
        /* Store Additional Meas */
        while (additional_list_ptr->n > idx)
        {
          adnl_meas_exist = FALSE;
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          {
            if ((intra_freq_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID) &&
            (intra_freq_meas_id_list[count].additional_meas[cnt] == (uint8) additional_list_ptr->elem[idx]))
            {
              adnl_meas_exist= TRUE;
              idx++;
              break;
            }
          }
          if(!adnl_meas_exist)
          {
            for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            {
              if (intra_freq_meas_id_list[count].additional_meas[cnt] == INVALID_MEAS_ID)
              {
                /* Set additional Meas Identity in this place */
                WRRC_MSG1_HIGH("Addtl Meas %d stored", additional_list_ptr->elem[idx]);
                intra_freq_meas_id_list[count].additional_meas[cnt] = (uint8) additional_list_ptr->elem[idx];
                idx++;

                break; /* COME OUT OF FOR */
              }
            } /* End of for of cnt loop */
            if (cnt == MAX_ADDITIONAL_MEAS)
            {
              return;
            }
          }
        } /* End of while of additional_list_ptr */
        break; /* Come out of for loop */
      } /* End of if of measurement identity */
    } /* End of for loop */

    break; /* Come out of switch */


  case INTER_FREQ:

    idx=0;
    for (count = 0; count < MAX_INTER_FREQ_MEAS; count++)
    {
      if (inter_freq_meas_id_list[count].meas_id == meas_id)
      {
        /* Store Additional Meas */
        while (additional_list_ptr->n > idx)
        {
          adnl_meas_exist = FALSE;
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          {
            if ((inter_freq_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID) &&
               (inter_freq_meas_id_list[count].additional_meas[cnt] == (uint8) additional_list_ptr->elem[idx]))
            {
             //added
              adnl_meas_exist= TRUE;
              idx++;
              break;
            }
          }
          if(!adnl_meas_exist)
          {
            for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            {
              if (inter_freq_meas_id_list[count].additional_meas[cnt] == INVALID_MEAS_ID)
              {
                /* Set additional Meas Identity in this place */
                WRRC_MSG1_HIGH("IFreq:Addtl Meas %d stored", additional_list_ptr->elem[idx]);
                inter_freq_meas_id_list[count].additional_meas[cnt] = (uint8) additional_list_ptr->elem[idx];
                idx++;

                break; /* COME OUT OF FOR */
              }
            } /* End of for of cnt loop */
            if (cnt == MAX_ADDITIONAL_MEAS)
            {
              return;
            }
          }
        } /* End of while of additional_list_ptr */
        break; /* Come out of for loop */
      } /* End of if of measurement identity */
    } /* End of for loop */

    break;


  case INTER_SYS:
    /* Now Store Additional Meas in RRC DB */
    idx=0;
    for (count = 0; count < MAX_INTER_RAT_MEAS; count++)
    {
      if (inter_rat_meas_id_list[count].meas_id == meas_id)
      {
        /* Store Additional Meas */
        while (additional_list_ptr->n > idx)
        {
          adnl_meas_exist = FALSE;
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          {
            if ((inter_rat_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID) &&
               (inter_rat_meas_id_list[count].additional_meas[cnt] == (uint8) additional_list_ptr->elem[idx]))
            {
              //added
              adnl_meas_exist= TRUE;
              idx++;
              break;
            }
          }
          if(!adnl_meas_exist)
          {
            for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            {
              if (inter_rat_meas_id_list[count].additional_meas[cnt] == INVALID_MEAS_ID)
              {
                /* Set additional Meas Identity in this place */
                WRRC_MSG1_HIGH("Addtl Meas %d stored", additional_list_ptr->elem[idx]);
                inter_rat_meas_id_list[count].additional_meas[cnt] = (uint8) additional_list_ptr->elem[idx];
                idx++;

                break; /* COME OUT OF FOR */
              }
            } /* End of for of cnt loop */
            if (cnt == MAX_ADDITIONAL_MEAS)
            {
              return;
            }
          }
        } /* End of while of additional_list_ptr */
        break; /* Come out of for loop */
      } /* End of if of measurement identity */
    } /* End of for loop */

    break; /* Come out of switch */

  case INTERNAL_MEAS:
    /* Now Store Additional Meas in RRC DB */
    idx=0;
    for (count = 0; count < MAX_INTERNAL_MEAS; count++)
    {
      if (ueim_meas_id_list[count].meas_id == meas_id)
      {
        /* Store Additional Meas */
        while (additional_list_ptr->n > idx)
        {
          adnl_meas_exist = FALSE;
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          {
            if ((ueim_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID) &&
               (ueim_meas_id_list[count].additional_meas[cnt] == (uint8) additional_list_ptr->elem[idx]))
            {
              //added
              adnl_meas_exist= TRUE;
              idx++;
              break;
            }
          }
          if(!adnl_meas_exist)
          {
            for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            {
              if (ueim_meas_id_list[count].additional_meas[cnt] == INVALID_MEAS_ID)
              {
                /* Set additional Meas Identity in this place */
                WRRC_MSG1_HIGH("Addtl Meas %d stored", additional_list_ptr->elem[idx]);
                ueim_meas_id_list[count].additional_meas[cnt] = (uint8) additional_list_ptr->elem[idx];
                idx++;

                break; /* COME OUT OF FOR */
              }
            } /* End of for of cnt loop */
            if (cnt == MAX_ADDITIONAL_MEAS)
            {
              return;
            }
          }
        } /* End of while of additional_list_ptr */
        break; /* Come out of for loop */
      } /* End of if of measurement identity */
    } /* End of for loop */

    break; /* Come out of switch */

  case MAC_MEAS:
    idx=0;
    for (count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++)
    {
      if (tvm_meas_id_list[count].meas_id == meas_id)
      {
        /* Store Additional Meas */
        while (additional_list_ptr->n > idx)
        {
          adnl_meas_exist = FALSE;
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          {
            if ((tvm_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID) &&
               (tvm_meas_id_list[count].additional_meas[cnt] == (uint8) additional_list_ptr->elem[idx]))
            {
              //added
              adnl_meas_exist= TRUE;
              idx++;
              break;
            }
          }
          if(!adnl_meas_exist)
          {
            for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            {
              if (tvm_meas_id_list[count].additional_meas[cnt] == INVALID_MEAS_ID)
              {
                /* Set additional Meas Identity in this place */
                tvm_meas_id_list[count].additional_meas[cnt] = (uint8) additional_list_ptr->elem[idx];
                idx++;

                break;
              }
            } /* End of for of cnt loop */
            if (cnt == MAX_ADDITIONAL_MEAS)
            {
              return;
            }
          }
        } /* End of while of additional_list_ptr */
        break;  /* Come out of for loop */
      } /* End of if of  measurement identity */

    } /* End of for */
    break;

  case QUALITY_MEAS:
    /* Now Store Additional Meas in RRC DB */
    idx=0;
    for (count = 0; count < MAX_QUALITY_MEAS; count++)
    {
      if (quality_meas_id_list[count].meas_id == meas_id)
      {
        /* Store Additional Meas */
        while (additional_list_ptr->n > idx)
        {
          adnl_meas_exist = FALSE;
          for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
          {
            if ((quality_meas_id_list[count].additional_meas[cnt] != INVALID_MEAS_ID) &&
              (quality_meas_id_list[count].additional_meas[cnt] == (uint8) additional_list_ptr->elem[idx]))
            {
              //added
              adnl_meas_exist= TRUE;
              idx++;
              break;
            }
          }
          if(!adnl_meas_exist)
          {
            for (cnt = 0; cnt < MAX_ADDITIONAL_MEAS; cnt++)
            {
              if (quality_meas_id_list[count].additional_meas[cnt] == INVALID_MEAS_ID)
              {
                /* Set additional Meas Identity in this place */
                WRRC_MSG1_HIGH("Addtl Meas %d stored", additional_list_ptr->elem[idx]);
                quality_meas_id_list[count].additional_meas[cnt] = (uint8) additional_list_ptr->elem[idx];
                idx++;

                break; /* COME OUT OF FOR */
              }
            } /* End of for of cnt loop */
            if (cnt == MAX_ADDITIONAL_MEAS)
            {
              return;
            }
          }
        } /* End of while of additional_list_ptr */
        break; /* Come out of for loop */
      } /* End of if of measurement identity */
    } /* End of for loop */

    break; /* Come out of switch */


  default:
    break;
  } /* End of switch */
  return;
}

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

/*===========================================================================

FUNCTION   RRCMEAS_CONFIG_POS_DB

DESCRIPTION

 Sets Positioning Meas Information in RRC Measurement Database.

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/

boolean rrcmeas_config_pos_db_r9
(
 pos_info_struct_type* pos_info_ptr,
 meas_validity_enum_type* p_meas_validity,
 rpt_crit_enum_type* pos_rpt_crit,
 boolean modify_meas_params_incl ,/* Only applicable for MODIFY */
  rrc_MeasurementControl_r9 *mcm_r9
)
{
  uint8 count = 0;

  uint8 meas_id_val = 0;

  rrc_MeasurementControl_r9_IEs* rrc_mcm_ptr = NULL;

  rrc_mcm_ptr = &mcm_r9->measurementControl_r9;

  
  /* First check if the meas id already exists */

  /* SETUP existing & MODIFY scenario */
  for ( count = 0; count < MAX_POS_MEAS; count++ )
  {
    if (pos_meas_id_list[count].meas_id == pos_info_ptr->meas_id)
    {
      /* Check if it is a MODIFY cmd */
      if (pos_info_ptr->pos_meas_cmd == RRC_MEAS_MODIFY)
      {
        if (modify_meas_params_incl == TRUE)
        {
          /* Reporting Criteria for MODIFY */
          pos_meas_id_list[count].rpt_crit = *pos_rpt_crit;

          /* Store Method type */
          pos_meas_id_list[count].pos_method_type = pos_info_ptr->pos_method_type;
        }

        WRRC_MSG1_HIGH("Meas Crit %d saved in RRC", tvm_meas_id_list[count].rpt_crit);

        /* If for MODIFY, Validity is not present, then copy it from Meas DB */
        if (*p_meas_validity != NOT_PRESENT)
        {
          /* New validity specified. Lets copy it */
          pos_meas_id_list[count].meas_validity = *p_meas_validity;
        }
      } /* End of MODIFY */
      else /* SETUP Overwrite case */
      {
        WRRC_MSG1_HIGH("POS:Overwrite SETUP Meas = %d in RRC db",pos_info_ptr->meas_id);

        pos_meas_id_list[count].rpt_crit = *pos_rpt_crit;

        pos_meas_id_list[count].meas_validity = *p_meas_validity;

        pos_meas_id_list[count].pos_method_type = pos_info_ptr->pos_method_type;
      }

      return TRUE;
    } /* End of if of Meas Id found */

  } /* End of for loop */

  /* SETUP not existing scenario */
  for ( count = 0; count < MAX_POS_MEAS; count++ )
  {
    /* If Meas Id not found, then it is a new Meas. Set it in first available position */
    if (pos_meas_id_list[count].meas_id == INVALID_MEAS_ID)
    {
      pos_meas_id_list[count].meas_id = (uint8) pos_info_ptr->meas_id;

      if((rrc_meas_id_extn_support) && (TRUE == rrcmeas_check_if_meas_id_extn_is_given(mcm_r9,&meas_id_val)))
      {
        pos_meas_id_list[count].meas_id = meas_id_val;

        /* Set this only if extended measurements is supported */
        /* This needs to be set while sending measurement report */
        pos_meas_id_list[count].meas_id_legacy = rrc_mcm_ptr->measurementIdentity;
      }
      else
      {
        pos_meas_id_list[count].meas_id = rrc_mcm_ptr->measurementIdentity;
      }



      pos_meas_id_list[count].pos_method_type = pos_info_ptr->pos_method_type;

      pos_meas_id_list[count].meas_validity = *p_meas_validity;

      pos_meas_id_list[count].rpt_crit = *pos_rpt_crit;

      return TRUE;
    }

  } /* End of for loop */

  /* Not Possible */
  return FALSE;

}
#endif

/*===========================================================================

FUNCTION     RRCMEAS_FILL_INTRA_FREQ_EVENT_CRITERIA_R9

DESCRIPTION

 This function fills in intra-freq event criteria for a Non-HCS cell when
 Cell Selection Reselection Quality Measure is RCSP or ECNO for R7 Message
 The function processes intra-ftreq event criteria Info in ASN1 format
 and translates into the L1 RRC Interface format.

DEPENDENCIES

 The passed pointers must be valid.

RETURN VALUE

 No of events.

SIDE EFFECTS

 None

===========================================================================*/

uint16 rrcmeas_fill_intra_freq_event_criteria_r9
(
  rrc_IntraFreqReportingCriteria_r9  *rrc_intra_freq_reporting_criteria_ptr,
  l1_intra_freq_event_crit_struct_type *l1_intra_freq_event_crit_ptr
)
{
  /* To store cell list for 1a or 1b if present */
  rrc_ForbiddenAffectCellList_r4 *forbidden_affect_cell_list_ptr = NULL;

  /* Stores ptr to passed rrc_IntraFreqEventCriteriaList */
  rrc_IntraFreqEventCriteriaList_r7  *rrc_intra_freq_event_criteria_list_ptr = NULL;

  rrc_PeriodicReportingInfo_1b *periodicReportingInfo_1b;
  /* Counts forbidden cell count */
  uint16 forbidden_cell_list_count = 0;
  uint32 idx=0,idy=0;
  /* To satisfy LINT as e1a, e1b values would be stored here first */
  l1_intra_freq_event_enum_type event_type;

  /* Counts no of events */
  uint16 event_count = 0;

  /* Store event crit list ptr */
  rrc_intra_freq_event_criteria_list_ptr = &rrc_intra_freq_reporting_criteria_ptr->eventCriteriaList;

  if ( rrc_intra_freq_event_criteria_list_ptr->n == 0)
  {
    MSG_LOW("Intra-freq event criteria list is empty", 0,0,0);
    return event_count;
  }

  /* ReportingRange, Hystersis, W converted by L1 */
  /* Store now the first event reporting criteria value from the list */
  while ( (rrc_intra_freq_event_criteria_list_ptr->n > idx) &&
    (event_count < L1_INTRA_FREQ_MAX_NUM_EVENT) )
  {

    /* First get the event ID */
    switch ( rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.t )
    {
      case T_rrc_IntraFreqEvent_r7_e1a:
        event_type = L1_INTRA_FREQ_EVENT_1A;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store triggering condition */

        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->
          triggeringCondition);

        /* Store Reporting Range */
        l1_intra_freq_event_crit_ptr[event_count].rpt_range = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingRange;

        /* Store no of cells forbidden to affect reporting range */
        if (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->m.forbiddenAffectCellListPresent)
        {
          /* Now store the scrambling code for each cell */

          forbidden_affect_cell_list_ptr =
            &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->forbiddenAffectCellList;

          idy=0;
          forbidden_cell_list_count = 0;
          while ( (forbidden_affect_cell_list_ptr->n > idy) &&
            (forbidden_cell_list_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is non-NULL and forbidden cell count hasn't exceeded
            * the maximum. So keep on counting */

            if ( forbidden_affect_cell_list_ptr->elem[idy].t ==
              T_rrc_ForbiddenAffectCell_r4_tdd )
            {
              /* Set pointer value to next */
              idy++;

              continue;

            }
            else
            {
              /* Store scrambling code */
              l1_intra_freq_event_crit_ptr->forbidden_cell_scr_code[forbidden_cell_list_count] = (uint16)
                forbidden_affect_cell_list_ptr->elem[idy].u.fdd->primaryScramblingCode;

              /* Now increment count and store ptr to next value */
              forbidden_cell_list_count++;
              idy++;


              if ( (forbidden_cell_list_count == L1_MAX_CELL_MEAS) &&
                (forbidden_affect_cell_list_ptr->n > idy) )
              {

                MSG_LOW("Cannot include all forbidden cells", 0,0,0);
                break;
              }
            } /* End of else */

          } /* End of while of forbidden_affect_cell_list_ptr != NULL */

          /* Now store the number of forbidden affect cells in l1 struct */

          l1_intra_freq_event_crit_ptr->num_cell_forbidded = forbidden_cell_list_count;
        } /* End of if for forbidden_affect_cell_list actually present */

        else
        { /* forbidden_affect_cell_list actually absent */
          /* Set as per L1 req */
          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = 0;
        }

        /* Now store rest of the parameters of event 1a */

        /* Store WEIGHT */

        /* Use this to verify  rrc_intra_freq_event_criteria_list_ptr   */
        l1_intra_freq_event_crit_ptr[event_count].w = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->w;

        /* Store deactivation threshold */
        l1_intra_freq_event_crit_ptr[event_count].rpt_deact_thresh =
          RRCMEAS_RET_DEACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportDeactivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingInterval);

        MSG_HIGH("1A:RptAmt %d,RptIntvl %dms,Deacthresh %d",
         l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_deact_thresh);


        break; /* Come out of switch and return SUCCESS */

      case T_rrc_IntraFreqEvent_r7_e1b:
        event_type = L1_INTRA_FREQ_EVENT_1B;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store triggering condition 1 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_1(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->triggeringCondition);

        /* Store Reporting Range */
        l1_intra_freq_event_crit_ptr[event_count].rpt_range = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->reportingRange;

        /* Initialize reporting intvl to 0 */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl = 0;

        /* Initialize no of rpts to 0 */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt = 0;

        if (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->m.periodicReportingInfo_1bPresent)
        {
          periodicReportingInfo_1b = &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->periodicReportingInfo_1b;
          /* Store reporting interval */
          l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          periodicReportingInfo_1b->reportingInterval);

          l1_intra_freq_event_crit_ptr[event_count].num_rpt =
            RRCMEAS_RET_REPORTING_AMOUNT(periodicReportingInfo_1b->reportingAmount);
        }

        MSG_HIGH("Event 1B Periodic info incl %d RptIntvl %d ms, Num rpt %d",
                 rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->m.periodicReportingInfo_1bPresent,
                 l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt);

        if ( rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->m.forbiddenAffectCellListPresent )
        {
          /* Now store the scrambling code for each cell */

          forbidden_affect_cell_list_ptr =
            &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->
            forbiddenAffectCellList;

          idy=0;
          forbidden_cell_list_count = 0;
          while ( (forbidden_affect_cell_list_ptr->n > idy) &&
            (forbidden_cell_list_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is non-NULL and forbidden cell count hasn't exceeded
            the maximum. So keep on counting */

            if ( forbidden_affect_cell_list_ptr->elem[idy].t ==
              T_rrc_ForbiddenAffectCell_r4_tdd )
            {
              idy++;
              continue;

            }
            else
            {
              /* Store scrambling code */
              l1_intra_freq_event_crit_ptr[event_count].
                forbidden_cell_scr_code[forbidden_cell_list_count] = (uint16)
                forbidden_affect_cell_list_ptr->elem[idy].u.fdd->primaryScramblingCode;

              /* Now increment count and store ptr to next value */
              forbidden_cell_list_count++;

              idy++;

              if ( (forbidden_cell_list_count == L1_MAX_CELL_MEAS) &&
                (forbidden_affect_cell_list_ptr->n > idy) )
              {

                MSG_LOW("Cannot include all the forbidden cells", 0,0,0);
                break;
              }
            } /* End of else */

          } /* End of while of forbidden_affect_cell_list_ptr != NULL */

          /* Now store the number of forbidden affect cells in l1 struct */

          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
            forbidden_cell_list_count;
        } /* End of if for forbidden_affect_cell_list actually present */

        else
        { /* forbidden_affect_cell_list actually absent */
          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = 0;
        }

        /* Store WEIGHT */

        l1_intra_freq_event_crit_ptr[event_count].w = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->w;

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_r7_e1c:
        event_type = L1_INTRA_FREQ_EVENT_1C;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store replacement activation threshold */

        l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh =
          RRCMEAS_RET_REPLACEMENT_ACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          replacementActivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          reportingInterval);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;

        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        MSG_HIGH("1C:RptAmt %d,RptIntvl %dms,Deacthresh %d",
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh);

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_r7_e1d:
        event_type = L1_INTRA_FREQ_EVENT_1D;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        l1_intra_freq_event_crit_ptr[event_count].evt_1d_trig_cond_incl = FALSE;

        l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl = FALSE;

        if (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1d->m.
            triggeringConditionPresent)
        {
          l1_intra_freq_event_crit_ptr[event_count].evt_1d_trig_cond_incl = TRUE;

          l1_intra_freq_event_crit_ptr[event_count].trig_cond =
          (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1d->
                                             triggeringCondition);


        }
        if ((rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1d->m.useCIOPresent)
          && (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1d->useCIO == TRUE))
        {
          l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl = TRUE;

        }

        WRRC_MSG2_HIGH("Event 1D trig cond 0:ASET/1:MSET %d CIO incl %d",
          l1_intra_freq_event_crit_ptr[event_count].trig_cond,l1_intra_freq_event_crit_ptr[event_count].evt_1d_cio_incl);

        break; /* Come out of switch and return SUCCESS */

      case T_rrc_IntraFreqEvent_r7_e1e:
        event_type = L1_INTRA_FREQ_EVENT_1E;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store the threshold used frequency */
        l1_intra_freq_event_crit_ptr[event_count].freq_thresh = (int16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1e->thresholdUsedFrequency;

        /* Store triggering condition 2 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1e->
          triggeringCondition);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEvent_r7_e1f:
        event_type = L1_INTRA_FREQ_EVENT_1F;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store the threshold used frequency */
        l1_intra_freq_event_crit_ptr[event_count].freq_thresh = (int16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1f->thresholdUsedFrequency;

        /* Store triggering condition 1 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_1(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1f->
          triggeringCondition);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        break; /* Come out of switch  */

      case T_rrc_IntraFreqEvent_r7_e1j:
        event_type = L1_INTRA_FREQ_EVENT_1J;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store replacement activation threshold */

        l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh =
          RRCMEAS_RET_REPLACEMENT_ACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1j->
          replacementActivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1j->
          reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1j->
          reportingInterval);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;

        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        MSG_HIGH("1J:RptAmt %d,RptIntvl %dms,Deacthresh %d",
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh);

      
        break;

      default:
        MSG_LOW("Invalid event type",0,0,0);
    } /* End of switch */

    /* Now store hsyterisis */
    l1_intra_freq_event_crit_ptr[event_count].hyst = (uint16)
      rrc_intra_freq_event_criteria_list_ptr->elem[idx].hysteresis;

    /* Now store timeToTrigger */

    l1_intra_freq_event_crit_ptr[event_count].time_to_trig =
      RRCMEAS_RET_TIME_TO_TRIGGER(rrc_intra_freq_event_criteria_list_ptr->elem[idx].timeToTrigger);

    /* Now store reporting cell status which is optional */
    /* Initialize Cell status information to FALSE */
    l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status_incl = FALSE;


    if (RRC_MSG_LIST_BITMASK_IE(rrc_intra_freq_event_criteria_list_ptr,
      rrc_IntraFreqEventCriteria_r7,reportingCellStatus) )
    {
      MSG_LOW("Reporting cell status present", 0,0,0);

      /* Call a function which stores all the information. */
      if ( rrcmeas_fill_no_of_reporting_cells(
        & rrc_intra_freq_event_criteria_list_ptr->elem[idx].reportingCellStatus,
        & l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status) == SUCCESS )
      {
        l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status_incl = TRUE;
      }
    } /* End of rrc_IntraFreqEventCriteria_reportingCellStatus) present */

    /* Now increment the event count and the ptr to next value */
    event_count++;
    idx++;

    if ( (event_count == L1_INTRA_FREQ_MAX_NUM_EVENT) &&
      (rrc_intra_freq_event_criteria_list_ptr->n >idx) )
    {
      break; /* Come out of while */
    }

  } /* End of while intra_freq_event_criteria_list_ptr != NULL */

  return event_count;

}


#ifdef FEATURE_WCDMA_DC_HSUPA
/*===========================================================================

FUNCTION     RRCMEAS_FILL_INTRA_FREQ_EVENT_CRITERIA_SEC_FREQ

DESCRIPTION

 This function fills in intra-freq event criteria of secondary freq
 for a Non-HCS cell when  Cell Selection Reselection Quality Measure 
 is RCSP or ECNO for R9 Message.  The function processes intra-freq 
 event criteria Info in ASN1 format  and translates into the L1 RRC Interface format.

DEPENDENCIES

 The passed pointers must be valid.

RETURN VALUE

 No of events.

SIDE EFFECTS

 None

===========================================================================*/

uint16 rrcmeas_fill_intra_freq_event_criteria_sec_freq
(
  rrc_IntraFreqReportingCriteria_r9  *rrc_intra_freq_reporting_criteria_ptr,
  l1_intra_freq_event_crit_struct_type *l1_intra_freq_event_crit_ptr
)
{
  /* To store cell list for 1a or 1b if present */
  rrc_ForbiddenAffectCellListOnSecULFreq *forbidden_affect_cell_list_ptr = NULL;

  /* Stores ptr to passed rrc_IntraFreqEventCriteriaList */
  rrc_IntraFreqEventCriteriaListOnSecULFreq_intraFreqEventCriteria  *rrc_intra_freq_event_criteria_list_ptr = NULL;

  rrc_PeriodicReportingInfo_1b *periodicReportingInfo_1b;
  /* Counts forbidden cell count */
  uint16 forbidden_cell_list_count = 0;
  uint32 idx=0,idy=0;
  /* To satisfy LINT as e1a, e1b values would be stored here first */
  l1_intra_freq_event_enum_type event_type;

  /* Counts no of events */
  uint16 event_count = 0;

  /* Store event crit list ptr */
  rrc_intra_freq_event_criteria_list_ptr = &rrc_intra_freq_reporting_criteria_ptr->eventCriteriaListOnSecULFreq.intraFreqEventCriteria;


  if ( rrc_intra_freq_event_criteria_list_ptr->n == 0)
  {
    MSG_LOW("Intra-freq event criteria list is empty", 0,0,0);
    return event_count;
  }

  /* ReportingRange, Hystersis, W converted by L1 */
  /* Store now the first event reporting criteria value from the list */
  while ( (rrc_intra_freq_event_criteria_list_ptr->n > idx) &&
    (event_count < L1_INTRA_FREQ_MAX_NUM_EVENT) )
  {

    /* First get the event ID */
    switch ( rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.t )
    {
      case T_rrc_IntraFreqEventOnSecULFreq_e1a :
        event_type = L1_INTRA_FREQ_EVENT_1A;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store triggering condition */

        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->
          triggeringCondition);

        /* Store Reporting Range */
        l1_intra_freq_event_crit_ptr[event_count].rpt_range = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingRange;

        MSG_HIGH("Event id : %d TRIG COND : %d RPT RANGE : %d", l1_intra_freq_event_crit_ptr[event_count].evt_id,l1_intra_freq_event_crit_ptr[event_count].trig_cond,l1_intra_freq_event_crit_ptr[event_count].rpt_range);


        /* Store no of cells forbidden to affect reporting range */
        if (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->m.forbiddenAffectCellListOnSecULFreqPresent)
        {
          /* Now store the scrambling code for each cell */

          forbidden_affect_cell_list_ptr =
            &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->forbiddenAffectCellListOnSecULFreq;

          idy=0;
          forbidden_cell_list_count = 0;
          while ( (forbidden_affect_cell_list_ptr->n > idy) &&
            (forbidden_cell_list_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is non-NULL and forbidden cell count hasn't exceeded
            * the maximum. So keep on counting */

            /* Store scrambling code */
            l1_intra_freq_event_crit_ptr->forbidden_cell_scr_code[forbidden_cell_list_count] = (uint16)
              forbidden_affect_cell_list_ptr->elem[idy].primaryCPICH.primaryScramblingCode;

            /* Now increment count and store ptr to next value */
            forbidden_cell_list_count++;
            idy++;

            if ( (forbidden_cell_list_count == L1_MAX_CELL_MEAS) &&
              (forbidden_affect_cell_list_ptr->n > idy) )
            {
              MSG_LOW("Cannot include all forbidden cells", 0,0,0);
              break;
            }

          } /* End of while of forbidden_affect_cell_list_ptr != NULL */

          /* Now store the number of forbidden affect cells in l1 struct */

          l1_intra_freq_event_crit_ptr->num_cell_forbidded = forbidden_cell_list_count;
        } /* End of if for forbidden_affect_cell_list actually present */

        else
        { /* forbidden_affect_cell_list actually absent */
          /* Set as per L1 req */
          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = 0;
        }

        /* Now store rest of the parameters of event 1a */

        /* Store WEIGHT */

        /* Use this to verify  rrc_intra_freq_event_criteria_list_ptr   */
        l1_intra_freq_event_crit_ptr[event_count].w = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->w;

        /* Store deactivation threshold */
        l1_intra_freq_event_crit_ptr[event_count].rpt_deact_thresh =
          RRCMEAS_RET_DEACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportDeactivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1a->reportingInterval);

        MSG_HIGH("1A:RptAmt %d,RptIntvl %dms,Deacthresh %d",
         l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_deact_thresh);


        break; /* Come out of switch and return SUCCESS */

      case T_rrc_IntraFreqEventOnSecULFreq_e1b :
        event_type = L1_INTRA_FREQ_EVENT_1B;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store triggering condition 1 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_1(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->triggeringCondition);

        /* Store Reporting Range */
        l1_intra_freq_event_crit_ptr[event_count].rpt_range = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->reportingRange;

        /* Initialize reporting intvl to 0 */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl = 0;

        /* Initialize no of rpts to 0 */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt = 0;

        if (rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->m.periodicReportingInfo_1bPresent)
        {
          periodicReportingInfo_1b = &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->periodicReportingInfo_1b;
          /* Store reporting interval */
          l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          periodicReportingInfo_1b->reportingInterval);

          l1_intra_freq_event_crit_ptr[event_count].num_rpt =
            RRCMEAS_RET_REPORTING_AMOUNT(periodicReportingInfo_1b->reportingAmount);
        }


       MSG_5(MSG_SSID_DIAG, MSG_LEGACY_HIGH,
         "1B: Periodic info incl %d Event Id %d,Trig cond  %d RptIntvl %d ms, Num rpt %d",
         rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->m.periodicReportingInfo_1bPresent,
         l1_intra_freq_event_crit_ptr[event_count].evt_id,
         l1_intra_freq_event_crit_ptr[event_count].trig_cond,l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt);

        if ( rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->m.forbiddenAffectCellListOnSecULFreqPresent )
        {
          /* Now store the scrambling code for each cell */

          forbidden_affect_cell_list_ptr =
            &rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->
            forbiddenAffectCellListOnSecULFreq;

          idy=0;
          forbidden_cell_list_count = 0;
          while ( (forbidden_affect_cell_list_ptr->n > idy) &&
            (forbidden_cell_list_count < L1_MAX_CELL_MEAS) )
          {

          /* Pointer to next cell is non-NULL and forbidden cell count hasn't exceeded
            the maximum. So keep on counting */
          /* Store scrambling code */
            l1_intra_freq_event_crit_ptr[event_count].
              forbidden_cell_scr_code[forbidden_cell_list_count] = (uint16)
              forbidden_affect_cell_list_ptr->elem[idy].primaryCPICH.primaryScramblingCode;

            /* Now increment count and store ptr to next value */
            forbidden_cell_list_count++;

            idy++;

            if ( (forbidden_cell_list_count == L1_MAX_CELL_MEAS) &&
              (forbidden_affect_cell_list_ptr->n > idy) )
            {
              MSG_LOW("Cannot include all the forbidden cells", 0,0,0);
              break;
            }
          } /* End of while of forbidden_affect_cell_list_ptr != NULL */

          /* Now store the number of forbidden affect cells in l1 struct */

          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
            forbidden_cell_list_count;
        } /* End of if for forbidden_affect_cell_list actually present */

        else
        { /* forbidden_affect_cell_list actually absent */
          l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = 0;
        }

        /* Store WEIGHT */

        l1_intra_freq_event_crit_ptr[event_count].w = (uint16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1b->w;

        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEventOnSecULFreq_e1c :
        event_type = L1_INTRA_FREQ_EVENT_1C;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store replacement activation threshold */

        l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh =
          RRCMEAS_RET_REPLACEMENT_ACTIVATION_THRESHOLD(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          replacementActivationThreshold);

        /* Store reporting amount */
        l1_intra_freq_event_crit_ptr[event_count].num_rpt =
          RRCMEAS_RET_REPORTING_AMOUNT(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          reportingAmount);

        /* Store reporting interval */
        l1_intra_freq_event_crit_ptr[event_count].rpt_intvl =
          RRCMEAS_RET_REPORTING_INTERVAL(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1c->
          reportingInterval);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;

        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        MSG_HIGH("1C:RptAmt %d,RptIntvl %dms,Deacthresh %d",
                 l1_intra_freq_event_crit_ptr[event_count].num_rpt,
         l1_intra_freq_event_crit_ptr[event_count].rpt_intvl,
         l1_intra_freq_event_crit_ptr[event_count].rpt_act_thresh);

        break; /* Come out of switch and return SUCCESS */

      case T_rrc_IntraFreqEventOnSecULFreq_e1e :
        event_type = L1_INTRA_FREQ_EVENT_1E;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store the threshold used frequency */
        l1_intra_freq_event_crit_ptr[event_count].freq_thresh = (int16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1e->thresholdUsedFrequency;

        /* Store triggering condition 2 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_2(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1e->
          triggeringCondition);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded =
          NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        MSG_HIGH("1E:Freqthresh %d,Trigcond %d,W %d",
                 l1_intra_freq_event_crit_ptr[event_count].freq_thresh,
         l1_intra_freq_event_crit_ptr[event_count].trig_cond,
         l1_intra_freq_event_crit_ptr[event_count].w);


        break; /* Come out of switch and return SUCCESS */


      case T_rrc_IntraFreqEventOnSecULFreq_e1f :
        event_type = L1_INTRA_FREQ_EVENT_1F;
        l1_intra_freq_event_crit_ptr[event_count].evt_id = event_type; /*Store event ID */

        /* Store the threshold used frequency */
        l1_intra_freq_event_crit_ptr[event_count].freq_thresh = (int16)
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1f->thresholdUsedFrequency;

        /* Store triggering condition 1 */
        l1_intra_freq_event_crit_ptr[event_count].trig_cond = (l1_meas_event_trigger_enum_type)
          RRCMEAS_RET_TRIGGERING_CONDITION_1(
          rrc_intra_freq_event_criteria_list_ptr->elem[idx].event.u.e1f->
          triggeringCondition);

        /* Initialize W and no as per L1 request*/
        l1_intra_freq_event_crit_ptr[event_count].num_cell_forbidded = NO_FORBIDDEN_CELLS;
        l1_intra_freq_event_crit_ptr[event_count].w =  NO_W;

        MSG_HIGH("1F:Freqthresh %d,Trigcond %dms,W %d",
                 l1_intra_freq_event_crit_ptr[event_count].freq_thresh,
         l1_intra_freq_event_crit_ptr[event_count].trig_cond,
         l1_intra_freq_event_crit_ptr[event_count].w);


        break; /* Come out of switch  */

      default:
        WRRC_MSG0_HIGH("Invalid event type");
    } /* End of switch */

    /* Now store hsyterisis */
    l1_intra_freq_event_crit_ptr[event_count].hyst = (uint16)
      rrc_intra_freq_event_criteria_list_ptr->elem[idx].hysteresis;

    /* Now store timeToTrigger */

    l1_intra_freq_event_crit_ptr[event_count].time_to_trig =
      RRCMEAS_RET_TIME_TO_TRIGGER(rrc_intra_freq_event_criteria_list_ptr->elem[idx].timeToTrigger);

    /* Now store reporting cell status which is optional */
    /* Initialize Cell status information to FALSE */
    l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status_incl = FALSE;


    if (RRC_MSG_LIST_BITMASK_IE(rrc_intra_freq_event_criteria_list_ptr,
      rrc_IntraFreqEventCriteriaOnSecULFreq,reportingCellStatus) )
    {
      MSG_LOW("Reporting cell status present", 0,0,0);

      /* Call a function which stores all the information. */
      if ( rrcmeas_fill_no_of_reporting_cells(
        & rrc_intra_freq_event_criteria_list_ptr->elem[idx].reportingCellStatus,
        & l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status) == SUCCESS )
      {
        l1_intra_freq_event_crit_ptr[event_count].rpt_cell_status_incl = TRUE;
      }
    } /* End of rrc_IntraFreqEventCriteria_reportingCellStatus) present */

    /* Now increment the event count and the ptr to next value */
    event_count++;
    idx++;

    if ( (event_count == L1_INTRA_FREQ_MAX_NUM_EVENT) &&
      (rrc_intra_freq_event_criteria_list_ptr->n >idx) )
    {
      break; /* Come out of while */
    }

  } /* End of while intra_freq_event_criteria_list_ptr != NULL */

  return event_count;

}
#endif

/*===========================================================================

FUNCTION  RRCMEAS_FILL_MCM_CELL_INFO_R9

DESCRIPTION

 This function fills in Cell Info received from a R9
 Measurement Control Message. The function processes
 Cell Info in ASN1 format and translates into the L1
 RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill cell info correctly.
 SUCCESS: If cell info is filled correctly

SIDE EFFECTS

 None

===========================================================================*/

uecomdef_status_e_type rrcmeas_fill_mcm_cell_info_r9
(
rrc_CellInfo_r9* mcm_cell_info_ptr,
l1_cell_info_struct_type* l1_cell_info_ptr
)
{

  l1_cell_info_ptr->cell_offset =
    mcm_cell_info_ptr->cellIndividualOffset;
  

  /* Fill in Reference Time Difference to serving cell */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(mcm_cell_info_ptr,
    rrc_CellInfo_r9,referenceTimeDifferenceToCell))
  {
    /* Set reference time difference included to true */
    l1_cell_info_ptr->ref_tm_diff_incl = TRUE;

    /* Fill cell time difference */
    rrcmeas_fill_reference_time_difference(&mcm_cell_info_ptr->referenceTimeDifferenceToCell,
      l1_cell_info_ptr);

  }
  else
  {
  /* Reference time difference to cell absent
    * Set reference time difference included to false */

    l1_cell_info_ptr->ref_tm_diff_incl = FALSE;

    l1_cell_info_ptr->ref_tm_diff = 0;
    l1_cell_info_ptr->time_acc = L1_CELL_TIME_ACC_40_CHIPS;
  }

  /* Initialize the following 2 to FALSE */
  /* Primary CPICH info absent */
  l1_cell_info_ptr->pri_scr_code_incl = FALSE;

  /* Primary CPICH TX power present It is an optional parameter */
  l1_cell_info_ptr->pri_cpich_txpwr_incl = FALSE;


  /* Fill in Mode Specific Info */
  if ( mcm_cell_info_ptr->modeSpecificInfo.t ==
    T_rrc_CellInfo_r9_modeSpecificInfo_tdd )
  {

    /* Mode specific info is for TDD */
    MSG_LOW("Using default values",0,0,0);

    /* Read SFN indicator */
    l1_cell_info_ptr->rd_sfn_ind = FALSE;

    /* Read Tx Diversity indicator */
    l1_cell_info_ptr->tx_diver_ind = FALSE;

    /* Cell Select Reselect Info is absent */
    l1_cell_info_ptr->cell_sel_resel_info_incl = FALSE;

  }
  else
  {
  /* Mode specific info is for FDD
    * Pri CPICH Scrambling code and CPICH Tx Power */

    if (mcm_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_InfoPresent)
    {

      /* Primary CPICH info present */
      l1_cell_info_ptr->pri_scr_code_incl = TRUE;

      l1_cell_info_ptr->pri_scr_code = (uint16)
        mcm_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

    }

    if ( mcm_cell_info_ptr->modeSpecificInfo.u.fdd->m.primaryCPICH_TX_PowerPresent)
    {

      /* Primary CPICH TX power present It is an optional parameter */

      l1_cell_info_ptr->pri_cpich_txpwr_incl = TRUE;

      /* Set its value */
      l1_cell_info_ptr->pri_cpich_txpwr =
        mcm_cell_info_ptr->modeSpecificInfo.u.fdd->primaryCPICH_TX_Power;

    }

    /* Read SFN indicator */
    l1_cell_info_ptr->rd_sfn_ind =
      (boolean) mcm_cell_info_ptr->modeSpecificInfo.u.fdd->readSFN_Indicator;

    /* Read Tx Diversity indicator */
    l1_cell_info_ptr->tx_diver_ind =
      (boolean) mcm_cell_info_ptr->modeSpecificInfo.u.fdd->tx_DiversityIndicator;

    /* Cell Select Reselect Info is absent */
    l1_cell_info_ptr->cell_sel_resel_info_incl = FALSE;

  }

  return(SUCCESS);
}  /* rrcmeas_fill_mcm_cell_info_r9  */


/*===========================================================================

FUNCTION  RRCMEAS_PROCESS_MCM_INTRA_F_CELL_INFO_R9

DESCRIPTION

 This function processes the Cell Info for meas setup and
 meas modify command type in a Measurement Control Message.
 The function processes Cell Info in ASN1 format and translates
 into the L1RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill mcm cell info correctly
 SUCCESS: If common mcm info filled correctly

SIDE EFFECTS

 None

===========================================================================*/

rrcmeas_status_e_type rrcmeas_process_mcm_intra_f_cell_info_r9
(
rrc_IntraFreqCellInfoList_r9* intra_freq_cell_info_list_ptr,
l1_intra_freq_meas_ctrl_struct_type* l1_intra_f_mcm_ptr
)
{
  rrc_RemovedIntraFreqCellList_removeSomeIntraFreqCells *local_remove_some_intra_freq_cells;

  rrc_NewIntraFreqCellList_r9 *local_new_intra_freq_celllist = NULL;
  uint32 idx=0;
  uint16 cell_count = 0;
  uint32 i =0;
  uint16 temp_cell_count = INVALID_CELL_COUNT; /* Some impossible invalid value*/

  uint16 removed_cell_count = 0;

  /* Stores psc from intra_freq_cell_list */
  uint16 psc = INVALID_PSC;

  uint32 cell_position = 0;

  /* Stores intra freq cell id */
  uint32 intra_freq_cell_id = 0;

  /* A list of psc which is obtained as a result of UTRAN adding cells in the
  * intra_freq_cell_list where already a cell existed. So L1 needs to be told
  * to remove these cells */
  uint16 psc_to_be_removed[L1_MAX_CELL_MEAS];

  /* Counts the no of psc to be removed [Cascading Effect count] */
  uint16 psc_removed_count = 0;

  uint16 psc_to_measure = INVALID_PSC;

  /* Stores no of cells to be measured */
  uint16 meas_cells_list[L1_MAX_CELL_MEAS];

  /* To store cell id from "Cells for Measurement" */
  uint32 cell_id;

  /* Indicates which cells should be measured by L1 */
  rrc_CellsForIntraFreqMeasList* cells_to_measure_ptr = NULL;
    /* Set cell list present to TRUE */

  /* Initialize arrays to satusfy lint */
  memset(meas_cells_list, 0 , sizeof(uint16) * L1_MAX_CELL_MEAS);
  memset(psc_to_be_removed, 0 , sizeof(uint16) * L1_MAX_CELL_MEAS);

  l1_intra_f_mcm_ptr->cell_list_incl[PRI_FREQ] = TRUE;

  if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_cell_info_list_ptr,
    rrc_IntraFreqCellInfoList_r9,removedIntraFreqCellList)))
  {
    WRRC_MSG1_HIGH("PRI : Remove: %d [1/2/3 : all cells/some cells/no cells]",intra_freq_cell_info_list_ptr->removedIntraFreqCellList.t);
    switch (intra_freq_cell_info_list_ptr->removedIntraFreqCellList.t)
    {
    case T_rrc_RemovedIntraFreqCellList_removeAllIntraFreqCells:

      l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv = REMOVE_ALL_INTRA_FREQ_CELLS;

      /* Reinitialize cell count */
      cell_count = 0;
      /* Update Cell_info_list variable */
      for (cell_count = 0; cell_count < L1_MAX_CELL_MEAS; cell_count++)
      {
        intra_freq_cell_list[PRI_FREQ][cell_count].cell_position = VACANT;
        intra_freq_cell_list[PRI_FREQ][cell_count].psc = INVALID_PSC;
      }

      break;

    case T_rrc_RemovedIntraFreqCellList_removeSomeIntraFreqCells:

      if ( (intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.removeSomeIntraFreqCells== NULL)
        ||(intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.removeSomeIntraFreqCells->n == 0))
      {
        break;
      }
      /* Store head of Link list */
      local_remove_some_intra_freq_cells =  intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.
        removeSomeIntraFreqCells;
      do
      {
        intra_freq_cell_id = local_remove_some_intra_freq_cells->elem[idx];
        /* Find the psc as per given cell id. This psc is given to L1 */
        if ( rrcmeas_find_psc(
         PRI_FREQ,
          &intra_freq_cell_id,
          &psc) == PSC_ABSENT)
        {
          idx++;
          continue;
        }
        else
        {
          /* First remove cell from intra freq cell list */
          rrcmeas_remove_cellid(
          PRI_FREQ,
          &intra_freq_cell_id);

          /* Here one needs to put psc so that L1 can remove it */
          l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].rmv_cell[removed_cell_count].psc = (uint16) psc;

          removed_cell_count++; /* Increment count */
        }

        /*  Get next element in the list */

        idx++;

      } /* Continue if cond satisfied */

      while ( (local_remove_some_intra_freq_cells->n > idx) &&
        (removed_cell_count < L1_MAX_CELL_MEAS) );

      /* Restore the head of linked list pointer */
      //intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.
      //  removeSomeIntraFreqCells = local_remove_some_intra_freq_cells;

      /* Now store the number of actual cells sent by UTRAN */

      l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv =  removed_cell_count;
      WRRC_MSG1_HIGH("Remove: Delete %d cells", removed_cell_count);

      break;

    case T_rrc_RemovedIntraFreqCellList_removeNoIntraFreqCells:
      /* Already set removed cells to 0 */
      break;

    default:
      break;
    } /* End of switch */

  } /* End of else of removed intra freq cells present */

  /* Reinitialize these variables */
  cell_count = 0;
  psc = 0;

  /* Check if new cells present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_cell_info_list_ptr,
    rrc_IntraFreqCellInfoList_r9,newIntraFreqCellList))
  {
    WRRC_MSG0_HIGH("MCM:PRI : New cells to be added present");

    /* Do not check for cell order. If UTRAN messes up, its their problem */

    /* Save the Head pointer of inked List */
    local_new_intra_freq_celllist = &intra_freq_cell_info_list_ptr->newIntraFreqCellList;
    idx=0;
    while ( ( local_new_intra_freq_celllist->n > idx) &&
      (cell_count < L1_MAX_CELL_MEAS) )
    {
    /* Pointer to next cell is Non-NULL and cell count
      * hasn't exceeded the max. L1 can handle */

      if ( local_new_intra_freq_celllist->elem[idx].
        cellInfo.modeSpecificInfo.t ==
        T_rrc_CellInfo_r9_modeSpecificInfo_tdd)
      {
        /* Nothing doing with a TDD cell. Shun it ! */

        idx++;

        continue;

      }
      /* Fill in Cell Info */
      /* Fill the cell_info in current index of add_cell if intraFreqCellID corresponding to current index is not already used
         Otherwise, all the latest cell_info corresponding to new intraFreqCellID entry should be copied to cell_info in add_cell corresponding to earlier
         intraFreqCellID*/
      for(i=0;i<idx;i++)
      {
        if(intra_freq_cell_info_list_ptr->newIntraFreqCellList.elem[idx].intraFreqCellID == 
            intra_freq_cell_info_list_ptr->newIntraFreqCellList.elem[i].intraFreqCellID)
        {
          /*Here as there is a matching ID is found, cell_info at the earlier index will be 
            populated, so cell_count should be i. After operation on this index is done we should 
            resume from the index in cell_info which we are storing in temp_cell_count and will
            be retrieved later*/
          temp_cell_count = cell_count;
          cell_count = i;
          break;
        }
      }
      if (rrcmeas_fill_mcm_cell_info_r9(
        &local_new_intra_freq_celllist->elem[idx].cellInfo,
        &l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].
        cell_info) == FAILURE)
      {
        idx++;
        continue;

      }

      /* Check if cell id present */
      if (RRC_MSG_LIST_BITMASK_IE(local_new_intra_freq_celllist,
        rrc_NewIntraFreqCell,intraFreqCellID))
      {
        cell_position = local_new_intra_freq_celllist->elem[idx].
          intraFreqCellID;


        /* Set psc from l1_intra_f_mcm_ptr->cell_list.add_cell[cell_count].
        cell_info.pri_scr_code in the intra freq cell list at position given by
        intra_freq_cell_info_list_ptr->newIntraFreqCellList->value.
        intraFreqCellID. Call rrcmeas_update_intra_freq_cell_list to do that */

      } /*  End of if of intra-freq cell id present */
      else
      {
        WRRC_MSG0_HIGH("Add: Cell Id not present");
        cell_position = AVAILABLE_CELL_POSITION;
        /* Set psc from l1_intra_f_mcm_ptr->cell_list.add_cell[cell_count].
        cell_info.pri_scr_code in the first vacant position in intra freq cell list */
      }

      /* If psc contains INVALID_PSC value, then the position at which this cell
      * has been updated is empty. If it contains any other value, then this
      * psc has to be removed. This is CASCADING effect. UTRAN adds a cell at
      * a position which results in a cell which was originally at that position
      * getting deleted */

      if ( rrcmeas_update_intra_freq_cell_list_mcm(
        PRI_FREQ,
        &cell_position,
        &l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].
        cell_info.pri_scr_code, &psc) == RRCMEAS_SUCCESS)
      {
        /* PSC sucessfully stored in the cell info list variable */
        /* Now store psc in the mcm in add cell for layer1 to use psc */
        l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].psc =
          l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].add_cell[cell_count].
          cell_info.pri_scr_code;

        if ((psc != INVALID_PSC) && (psc_removed_count < L1_MAX_CELL_MEAS)
            && (l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv != REMOVE_ALL_INTRA_FREQ_CELLS))
        {
          /* UTRAN wants us to delete this psc. Result of CASCADING effect */
          psc_to_be_removed[psc_removed_count++] = psc;
        }
        if(temp_cell_count != INVALID_CELL_COUNT)
        {
          cell_count = temp_cell_count;
          temp_cell_count = INVALID_CELL_COUNT;
          /*cell_count should be decremented as valid temp_cell_count implies duplicate intraFreqCellID entry*/
          cell_count--;
        }
        cell_count ++;
      }  /* End of if of rrcmeas_update_intra_freq_cell_list */

      /* Read next element */
      idx++;

      if ( (cell_count == L1_MAX_CELL_MEAS) &&
        (local_new_intra_freq_celllist->n > idx) )
      {
      /* If there are more new cells than can be accomodated in L1
      * Cmd, print a message and hope L1 will change their capability
      * sometime. Just pass the number that L1 can handle.
        */
        break;
      }
    } /* End of while newIntraFreqCellList != NULL */
    /* Restore the head pointer */

    //intra_freq_cell_info_list_ptr->newIntraFreqCellList = local_new_intra_freq_celllist;

    /* Initialize no of added cells */
    WRRC_MSG1_HIGH("Number of new intraFreq cells added are %d", cell_count);
    l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_add = cell_count;

    /* Reinitialize cell_count */
    cell_count = 0;

    /* Add the psc's to be removed from psc_to_be_removed list
    * to l1_intra_f_mcm_ptr->cell_list.num_cell_rmv */

    for (cell_count=0; cell_count < psc_removed_count; cell_count++)
    {
      /* Add this removed cell to the already built removed cell list for L1 */
      WRRC_MSG1_HIGH("Cascading:L1 removed cell list updated with %d psc",
        psc_to_be_removed[cell_count]);
      l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].rmv_cell[removed_cell_count++].psc =
        psc_to_be_removed[cell_count];
    }
    /* Now update the number of removed cells */
    l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv += psc_removed_count;
    MSG_LOW("Thus, L1 should be removing %d cells",
      l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv,0,0);

  } /* End of if for new intra freq cells present */


  /* Initialize no fo cells to 0 */
  l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_meas = 0;
  cell_count = 0;
  l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].cells_for_meas_incl = FALSE;
  /* Check if cells for meas present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_cell_info_list_ptr,
    rrc_IntraFreqCellInfoList_r9,cellsForIntraFreqMeasList))
  {
    l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].cells_for_meas_incl = TRUE;
    idx=0;
    cells_to_measure_ptr = &intra_freq_cell_info_list_ptr->cellsForIntraFreqMeasList;
    while (cells_to_measure_ptr->n > idx)
    {

      cell_id = cells_to_measure_ptr->elem[idx];
      /* Check if the cell id is present in intra_freq_cell_list VARIABLE */
      if ( rrcmeas_find_psc(
           PRI_FREQ,
           &cell_id, &psc_to_measure) == PSC_ABSENT)
      {
        MSG_LOW("Invalid cell to measure with id = %d",
          cell_id,0,0);

      } /* End of if for psc not found */
      else
      {
        /* Store psc */
        if(cell_count < L1_MAX_CELL_MEAS)
        {
          meas_cells_list[cell_count++] = psc_to_measure;
        }
      }

      /* Increment Ptr */
      idx++;
    } /* End of while */

    l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_meas =  cell_count;
    /* Copy cells to measure list and also no of cells to measure */
    for (cell_count = 0; cell_count < l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_meas;
    cell_count++)
    {
      l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].meas_cells_list[cell_count] =
        meas_cells_list[cell_count];
    }

  } /* End of if of rrc_cellsForIntraFreqMeasList_present */
  return RRCMEAS_SUCCESS;
}



#ifdef FEATURE_WCDMA_DC_HSUPA
/*===========================================================================

FUNCTION  RRCMEAS_PROCESS_MCM_INTRA_F_CELL_INFO_SEC_FREQ_R9

DESCRIPTION

 This function processes the Cell Info list of secondary frequency
 for meas setup and  meas modify command type in a Measurement Control Message.
 The function processes Cell Info in ASN1 format and translates
 into the L1RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill mcm cell info correctly
 SUCCESS: If common mcm info filled correctly

SIDE EFFECTS

 None

===========================================================================*/

rrcmeas_status_e_type rrcmeas_process_mcm_intra_f_cell_info_sec_freq_r9
(
rrc_IntraFreqCellInfoListInfoOnSecULFreq* intra_freq_cell_info_list_ptr,
l1_intra_freq_meas_ctrl_struct_type* l1_intra_f_mcm_ptr
)
{
  rrc_RemovedIntraFreqCellListOnSecULFreq_removeSomeIntraFreqCells *local_remove_some_intra_freq_cells;

  rrc_NewIntraFreqCellListOnSecULFreq *local_new_intra_freq_celllist = NULL;
  uint32 idx=0;
  uint16 cell_count = 0;
  uint32 i =0;
  uint16 temp_cell_count = INVALID_CELL_COUNT; /* Some impossible invalid value*/

  uint16 removed_cell_count = 0;

  /* Stores psc from intra_freq_cell_list */
  uint16 psc = INVALID_PSC;

  uint32 cell_position = 0;

  /* Stores intra freq cell id */
  uint32 intra_freq_cell_id = 0;

  /* A list of psc which is obtained as a result of UTRAN adding cells in the
  * intra_freq_cell_list where already a cell existed. So L1 needs to be told
  * to remove these cells */
  uint16 psc_to_be_removed[L1_MAX_CELL_MEAS];

  /* Counts the no of psc to be removed [Cascading Effect count] */
  uint16 psc_removed_count = 0;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  uint16 psc_to_measure = INVALID_PSC;

  /* Stores no of cells to be measured */
  uint16 meas_cells_list[L1_MAX_CELL_MEAS];

  /* To store cell id from "Cells for Measurement" */
  uint32 cell_id;

  /* Indicates which cells should be measured by L1 */
  rrc_CellsForIntraFreqMeasListOnSecULFreq * cells_to_measure_ptr = NULL;
    /* Set cell list present to TRUE */

#if 0
  /* Initialize arrays to satusfy lint */
  for (cell_count = 0; cell_count < L1_MAX_CELL_MEAS; cell_count++)
  {
    meas_cells_list[cell_count] = 0;
    psc_to_be_removed[cell_count] = 0;
  }
#endif

  memset(meas_cells_list, 0 , sizeof(uint16) * L1_MAX_CELL_MEAS);
  memset(psc_to_be_removed, 0 , sizeof(uint16) * L1_MAX_CELL_MEAS);

  l1_intra_f_mcm_ptr->cell_list_incl[SEC_FREQ] = TRUE;

  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_cell_info_list_ptr,
    rrc_IntraFreqCellInfoListInfoOnSecULFreq,removedIntraFreqCellList))
  {
    WRRC_MSG1_HIGH("SEC : Remove: %d [0/1/2 : all cells/some cells/no cells]",intra_freq_cell_info_list_ptr->removedIntraFreqCellList.t);
    switch (intra_freq_cell_info_list_ptr->removedIntraFreqCellList.t)
    {
    case T_rrc_RemovedIntraFreqCellListOnSecULFreq_removeAllIntraFreqCells:
      l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].num_cell_rmv = REMOVE_ALL_INTRA_FREQ_CELLS;

      /* Reinitialize cell count */
      cell_count = 0;
      /* Update Cell_info_list variable */
      for (cell_count = 0; cell_count < L1_MAX_CELL_MEAS; cell_count++)
      {
        intra_freq_cell_list[SEC_FREQ][cell_count].cell_position = VACANT;
        intra_freq_cell_list[SEC_FREQ][cell_count].psc = INVALID_PSC;
      }

      break;

    case T_rrc_RemovedIntraFreqCellListOnSecULFreq_removeSomeIntraFreqCells:

      if ( (intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.removeSomeIntraFreqCells== NULL)
        ||(intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.removeSomeIntraFreqCells->n == 0))
      {
        break;
      }
      /* Store head of Link list */
      local_remove_some_intra_freq_cells =  intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.
        removeSomeIntraFreqCells;
      do
      {
        intra_freq_cell_id = local_remove_some_intra_freq_cells->elem[idx];
        /* Find the psc as per given cell id. This psc is given to L1 */
        if ( rrcmeas_find_psc(
          SEC_FREQ,
          &intra_freq_cell_id,
          &psc) == PSC_ABSENT)
        {
          idx++;
          continue;
        }
        else
        {
          /* First remove cell from intra freq cell list */
          rrcmeas_remove_cellid(SEC_FREQ,&intra_freq_cell_id);

          /* Here one needs to put psc so that L1 can remove it */
          l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].rmv_cell[removed_cell_count].psc = (uint16) psc;

          removed_cell_count++; /* Increment count */
        }

        /*  Get next element in the list */

        idx++;

      } /* Continue if cond satisfied */

      while ( (local_remove_some_intra_freq_cells->n > idx) &&
        (removed_cell_count < L1_MAX_CELL_MEAS) );

      /* Restore the head of linked list pointer */
      //intra_freq_cell_info_list_ptr->removedIntraFreqCellList.u.
      //  removeSomeIntraFreqCells = local_remove_some_intra_freq_cells;

      /* Now store the number of actual cells sent by UTRAN */

      l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].num_cell_rmv =  removed_cell_count;
      break;

    case T_rrc_RemovedIntraFreqCellListOnSecULFreq_removeNoIntraFreqCells:
      /* Already set removed cells to 0 */
      break;

    default:
      break;
    } /* End of switch */

  } /* End of else of removed intra freq cells present */

  /* Reinitialize these variables */
  cell_count = 0;
  psc = 0;

  /* Check if new cells present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_cell_info_list_ptr,
    rrc_IntraFreqCellInfoListInfoOnSecULFreq,newIntraFreqCellList))
  {
    /* Do not check for cell order. If UTRAN messes up, its their problem */

    /* Save the Head pointer of inked List */
    local_new_intra_freq_celllist = &intra_freq_cell_info_list_ptr->newIntraFreqCellList;
    idx=0;
    while ( ( local_new_intra_freq_celllist->n > idx) &&
      (cell_count < L1_MAX_CELL_MEAS) )
    {
    /* Pointer to next cell is Non-NULL and cell count
      * hasn't exceeded the max. L1 can handle */

      if ( local_new_intra_freq_celllist->elem[idx].
        cellInfo.modeSpecificInfo.t ==
        T_rrc_CellInfo_r9_modeSpecificInfo_tdd)
      {
        /* Nothing doing with a TDD cell. Shun it ! */

        idx++;

        continue;

      }
      /* Fill in Cell Info */
      /* Fill the cell_info in current index of add_cell if intraFreqCellID corresponding to current index is not already used
         Otherwise, all the latest cell_info corresponding to new intraFreqCellID entry should be copied to cell_info in add_cell corresponding to earlier
         intraFreqCellID*/
      for(i=0;i<idx;i++)
      {
        if(intra_freq_cell_info_list_ptr->newIntraFreqCellList.elem[idx].intraFreqCellIDOnSecULFreq == 
            intra_freq_cell_info_list_ptr->newIntraFreqCellList.elem[i].intraFreqCellIDOnSecULFreq)
        {
          /*Here as there is a matching ID is found, cell_info at the earlier index will be 
            populated, so cell_count should be i. After operation on this index is done we should 
            resume from the index in cell_info which we are storing in temp_cell_count and will
            be retrieved later*/
          temp_cell_count = cell_count;
          cell_count = i;
          break;
        }
      }
      if (rrcmeas_fill_mcm_cell_info_r5(
        &local_new_intra_freq_celllist->elem[idx].cellInfo,
        &l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].add_cell[cell_count].
        cell_info) == FAILURE)
      {
        idx++;
        continue;
      }

      /* Check if cell id present */
      if (RRC_MSG_LIST_BITMASK_IE(local_new_intra_freq_celllist,
        rrc_NewIntraFreqCell,intraFreqCellIDOnSecULFreq))
      {
        cell_position = local_new_intra_freq_celllist->elem[idx].intraFreqCellIDOnSecULFreq;

        WRRC_MSG1_MED("Add:Cell at pos %d to be added",cell_position);

        /* Set psc from l1_intra_f_mcm_ptr->cell_list.add_cell[cell_count].
        cell_info.pri_scr_code in the intra freq cell list at position given by
        intra_freq_cell_info_list_ptr->newIntraFreqCellList->value.
        intraFreqCellID. Call rrcmeas_update_intra_freq_cell_list to do that */

      } /*  End of if of intra-freq cell id present */
      else
      {
        WRRC_MSG0_HIGH("Add: Cell Id not present");
        cell_position = AVAILABLE_CELL_POSITION;
        /* Set psc from l1_intra_f_mcm_ptr->cell_list.add_cell[cell_count].
        cell_info.pri_scr_code in the first vacant position in intra freq cell list */
      }

      /* If psc contains INVALID_PSC value, then the position at which this cell
      * has been updated is empty. If it contains any other value, then this
      * psc has to be removed. This is CASCADING effect. UTRAN adds a cell at
      * a position which results in a cell which was originally at that position
      * getting deleted */

      if ( rrcmeas_update_intra_freq_cell_list_mcm(
        SEC_FREQ,
        &cell_position,
        &l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].add_cell[cell_count].
        cell_info.pri_scr_code, &psc) == RRCMEAS_SUCCESS)
      {
        /* PSC sucessfully stored in the cell info list variable */
        /* Now store psc in the mcm in add cell for layer1 to use psc */
        l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].add_cell[cell_count].psc =
          l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].add_cell[cell_count].
          cell_info.pri_scr_code;

        if ((psc != INVALID_PSC) && (psc_removed_count < L1_MAX_CELL_MEAS)
            && (l1_intra_f_mcm_ptr->cell_list[PRI_FREQ].num_cell_rmv != REMOVE_ALL_INTRA_FREQ_CELLS))
        {
          /* UTRAN wants us to delete this psc. Result of CASCADING effect */
          psc_to_be_removed[psc_removed_count++] = psc;
        }
        if(temp_cell_count != INVALID_CELL_COUNT)
        {
          cell_count = temp_cell_count;
          temp_cell_count = INVALID_CELL_COUNT;
          /*cell_count should be decremented as valid temp_cell_count implies duplicate intraFreqCellID entry*/
          cell_count--;
        }
        /* Increment cell count as add cell successfully stored */
        cell_count ++;
      }  /* End of if of rrcmeas_update_intra_freq_cell_list */

      /* Read next element */
      idx++;

      if ( (cell_count == L1_MAX_CELL_MEAS) &&
        (local_new_intra_freq_celllist->n > idx) )
      {
      /* If there are more new cells than can be accomodated in L1
      * Cmd, print a message and hope L1 will change their capability
      * sometime. Just pass the number that L1 can handle.
        */
        break;
      }
    } /* End of while newIntraFreqCellList != NULL */
    /* Restore the head pointer */

    //intra_freq_cell_info_list_ptr->newIntraFreqCellList = local_new_intra_freq_celllist;

    /* Initialize no of added cells */
    WRRC_MSG1_HIGH("Number of new intraFreq cells added are %d", cell_count);
    l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].num_cell_add = cell_count;

    /* Reinitialize cell_count */
    cell_count = 0;


    /* Add the psc's to be removed from psc_to_be_removed list
    * to l1_intra_f_mcm_ptr->cell_list.num_cell_rmv */


    for (removed_cell_count = 0;
    removed_cell_count < l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].num_cell_rmv; removed_cell_count++)
    {
      /* Verify if UTRAN does not mess up by telling UE to delete same cell TWICE */

      for (cell_count=0; cell_count < psc_removed_count; cell_count++)
      {
        if (l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].rmv_cell[removed_cell_count].psc ==
          psc_to_be_removed[cell_count])
        {
          WRRC_MSG0_ERROR("MCM: Same cell cannot be removed TWICE, Retain previous cell list before MCM rcved");
          /* If this happens, then UTRAN CELL_INFO_LIST is out of sync with
          * UE CELL_INFO_LIST */
          WCDMA_MEMCPY(intra_freq_cell_list, 
                       sizeof(intra_freq_cell_list_struct_type) * MAX_NUM_CARR * L1_MAX_CELL_MEAS,
                       intra_freq_cell_list_temp,
                       sizeof(intra_freq_cell_list_struct_type) * MAX_NUM_CARR * L1_MAX_CELL_MEAS);

          // SEND MEAS CTRL FAILURE MSG
          if (trans_id == INVALID_TRANSACTION_ID)
          {
            return RRCMEAS_FAIL;
          }
          rrcmeas_mcf.rrc_transaction_id = trans_id;

          // Set faliure t
          rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_invalidConfiguration;

          rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
          return RRCMEAS_FAIL;

        }

      } /* End of for of cell_count */


    } /* End of for of removed_cell_count */

    /* Reinitialize cell_count again */
    cell_count = 0;
    for (cell_count=0; cell_count < psc_removed_count; cell_count++)
    {
      /* Add this removed cell to the already built removed cell list for L1 */
      WRRC_MSG1_HIGH("Cascading:L1 removed cell list updated with %d psc",
        psc_to_be_removed[cell_count]);
      l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].rmv_cell[removed_cell_count++].psc =
        psc_to_be_removed[cell_count];
    }
    /* Now update the number of removed cells */
    l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].num_cell_rmv += psc_removed_count;
    MSG_LOW("Thus, L1 should be removing %d cells",
      l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].num_cell_rmv,0,0);

  } /* End of if for new intra freq cells present */


  /* Initialize no fo cells to 0 */
  l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].num_cell_meas = 0;
  cell_count = 0;
  l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].cells_for_meas_incl = FALSE;
  /* Check if cells for meas present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_freq_cell_info_list_ptr,
    rrc_IntraFreqCellInfoListInfoOnSecULFreq,cellsForIntraFreqMeasList))
  {
    l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].cells_for_meas_incl = TRUE;
    idx=0;
    cells_to_measure_ptr = &intra_freq_cell_info_list_ptr->cellsForIntraFreqMeasList;
    while (cells_to_measure_ptr->n > idx)
    {

      cell_id = cells_to_measure_ptr->elem[idx];
      /* Check if the cell id is present in intra_freq_cell_list VARIABLE */
      if ( rrcmeas_find_psc(SEC_FREQ,&cell_id, &psc_to_measure) == PSC_ABSENT)
      {
        MSG_LOW("Invalid cell to measure with id = %d",
          cell_id,0,0);

      } /* End of if for psc not found */
      else
      {
        /* Store psc */
        if(cell_count < L1_MAX_CELL_MEAS)
        {
          meas_cells_list[cell_count++] = psc_to_measure;
        }
      }

      /* Increment Ptr */
      idx++;
    } /* End of while */

    l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].num_cell_meas =  cell_count;
    /* Copy cells to measure list and also no of cells to measure */
    for (cell_count = 0; cell_count < l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].num_cell_meas;
    cell_count++)
    {
      l1_intra_f_mcm_ptr->cell_list[SEC_FREQ].meas_cells_list[cell_count] =
        meas_cells_list[cell_count];
  }

  } /* End of if of rrc_cellsForIntraFreqMeasList_present */
  return RRCMEAS_SUCCESS;
}

#endif

/*===========================================================================

FUNCTION  RRCMEAS_FILL_COMMON_MCM_INTRA_F_INFO_R9

DESCRIPTION

 This function fills in common Cell Info for meas setup and
 meas modify command type in a Measurement Control Message.
 The function processes Cell Info in ASN1 format and translates
 into the L1RRC Interface format.

DEPENDENCIES

 None

RETURN VALUE

 FAILURE: If unable to fill common mcm info correctly
 SUCCESS: If common mcm info filled correctly

SIDE EFFECTS

 None

===========================================================================*/
rrcmeas_status_e_type rrcmeas_fill_common_mcm_intra_f_info_r9
(
rrc_IntraFrequencyMeasurement_r9* intra_f_meas_ptr,
l1_intra_freq_meas_ctrl_struct_type* l1_intra_f_mcm_ptr,
l1_meas_ctrl_parm_struct_type *l1_mcm 
)
{
  uint16 cell_count = 0;
  uint8  freq_idx = 0;
  uint8  meas_id_idx = rrcmeas_find_meas_id_idx(l1_mcm->meas_id);
  WCDMA_MEMCPY(intra_freq_cell_list_temp, 
               sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
               intra_freq_cell_list,
               sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);

  /* Assign default values */
  l1_intra_f_mcm_ptr->meas_quan_incl = FALSE;
  l1_intra_f_mcm_ptr->meas_quan.quan_type = L1_MEAS_NONE;

  /* Assign Default value to filter coefficient 0 */
  l1_intra_f_mcm_ptr->meas_quan.filter_coef = 0;

  /* Store Meas Quantity */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr,
    rrc_IntraFrequencyMeasurement_r9,intraFreqMeasQuantity))
  {
    /* Check if meas quan is for fdd */
    if (RRC_CHECK_COMMON_MSG_TYPE(intra_f_meas_ptr->
      intraFreqMeasQuantity.modeSpecificInfo,
      rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd ))
    {
      /* Intra freq meas quantity for FDD mode is present */
      l1_intra_f_mcm_ptr->meas_quan_incl = TRUE;

      /* So read the value of meas quantity and filter coefficient */
      l1_intra_f_mcm_ptr->meas_quan.quan_type =
        RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN(
        intra_f_meas_ptr->
        intraFreqMeasQuantity.modeSpecificInfo.u.fdd->intraFreqMeasQuantity_FDD);

        /* Check if rrc_IntraFreqMeasQuantity_filterCoefficient) */
    
        /* Store filter coefficient */
        l1_intra_f_mcm_ptr->meas_quan.filter_coef = (uint16)
          RRCMEAS_RET_INTRA_FREQ_MEAS_QUAN_FILTER_COEFFICIENT(intra_f_meas_ptr->
          intraFreqMeasQuantity.filterCoefficient);
    

    } /* End of if for rrc_IntraFreqMeasQuantity_modeSpecificInfo_fdd  */

  } /* End of if of intra freq meas quantity not present */


   for(freq_idx = 0; freq_idx < MAX_NUM_CARR; freq_idx++)
  {
  /* Initialize no of added, removed cells to 0, cell_incl to FALSE */
    l1_intra_f_mcm_ptr->cell_list_incl[freq_idx] = FALSE;
    l1_intra_f_mcm_ptr->cell_list[freq_idx].num_cell_add = 0;
    l1_intra_f_mcm_ptr->cell_list[freq_idx].num_cell_rmv = 0;

    cell_count = 0;
  }


  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr,
      rrc_IntraFrequencyMeasurement_r9,intraFreqCellInfoList))
  {
    if(RRCMEAS_FAIL == rrcmeas_process_mcm_intra_f_cell_info_r9(&intra_f_meas_ptr->intraFreqCellInfoList, l1_intra_f_mcm_ptr))
    {
      return RRCMEAS_FAIL;
    }
  } /* End of intra freq cell info list present */

#ifdef FEATURE_WCDMA_DC_HSUPA
  /* Cell Info List for secondary frequency */
  if (intra_f_meas_ptr->m.intraFreqCellInfoListOnSecULFreqPresent)
  {
    if(RRCMEAS_FAIL == rrcmeas_process_mcm_intra_f_cell_info_sec_freq_r9(&intra_f_meas_ptr->intraFreqCellInfoListOnSecULFreq.intraFreqCellInfoListOnSecULFreq, l1_intra_f_mcm_ptr))
    {
      return RRCMEAS_FAIL;
    }
  } /* End of intra freq cell info list present */
#endif

  /* Assign default values for intra-f reporting quantity */
  l1_intra_f_mcm_ptr->intra_f_rpt_quan_incl = FALSE;

  /* Check if intra-f reporting quantity present */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr, rrc_IntraFrequencyMeasurement_r9,intraFreqReportingQuantity))
  {
    if ( (rrcmeas_fill_intra_freq_rep_quan(&intra_f_meas_ptr->intraFreqReportingQuantity,
      l1_intra_f_mcm_ptr)) == SUCCESS )
      l1_intra_f_mcm_ptr->intra_f_rpt_quan_incl = TRUE;
  }

  /* Initialize rpt_mode to no change */
   l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_NO_CHANGE;

  /* Set reporting cell status to FALSE */
   l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = FALSE;
   l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[PRI_FREQ] = FALSE;

#ifdef FEATURE_WCDMA_DC_HSUPA
  l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_NO_CHANGE;

  /* Set reporting cell status to FALSE */
  l1_intra_f_mcm_ptr->rpt_cell_status_incl[SEC_FREQ] = FALSE;

  /* Set reporting crit incl to FALSE */
  l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[SEC_FREQ] = FALSE;
#endif

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr, rrc_IntraFrequencyMeasurement_r9,reportCriteria))
  {
    
    /* Check report criteeria type */
    switch (intra_f_meas_ptr->reportCriteria.t)
    {
    case T_rrc_IntraFreqReportCriteria_r9_intraFreqReportingCriteria:
  
      /* Set rpt mode criteria */
  
      /* Check if Event triggered intraFreqReportingCriteria list present */
  
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.
        intraFreqReportingCriteria,rrc_IntraFreqReportingCriteria_r9,eventCriteriaList))
      {
        /* Set event parameters */
        /* Set reporting crit incl to FALSE */
         l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].num_event =
          rrcmeas_fill_intra_freq_event_criteria_r9(
           intra_f_meas_ptr->reportCriteria.u.intraFreqReportingCriteria, l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].evt);
         l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_EVENT_TRIGGER_RPT;
  
      } /* End of if for event criteria list present */
      else
      {
        MSG_LOW("Setting num_event to 0", 0,0,0);
        /* So set num_event in L1 structure to 0 */
  
         l1_intra_f_mcm_ptr->rpt_crit[PRI_FREQ].num_event = 0;

         /* If meas id is not found or rpt crit is set to NOT AVAILABLE set rpt mode as RPT MODE NOT PRESENT */
         /* If MCM is setup then remove previously active MCM config Spec : 8.4.1.3 */
        if(CHECK_RPT_CRIT_NOT_PRESENT(PRI_FREQ))
         {
           if(meas_id_idx < MAX_INTRA_FREQ_MEAS)
           {
             intra_freq_meas_id_list[meas_id_idx].rpt_crit[PRI_FREQ] = NOT_AVAILABLE;
           }
           l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_RPT_MODE_NOT_PRESENT;		
         } 
}


#ifdef FEATURE_WCDMA_DC_HSUPA
      /* Filling event reporting criteria for secondary frequency */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.
        intraFreqReportingCriteria,rrc_IntraFreqReportingCriteria_r9,eventCriteriaListOnSecULFreq))
      {
        /* Filling the frequency information IE */
        l1_intra_f_mcm_ptr->freq_info[SEC_FREQ].uarfcn_ul_incl = FALSE;

        if (intra_f_meas_ptr->reportCriteria.u.
          intraFreqReportingCriteria->eventCriteriaListOnSecULFreq.frequencyInfo.modeSpecificInfo.u.fdd->m.uarfcn_ULPresent == TRUE)
        {
          l1_intra_f_mcm_ptr->freq_info[SEC_FREQ].uarfcn_ul_incl = TRUE;

          l1_intra_f_mcm_ptr->freq_info[SEC_FREQ].uarfcn_ul = intra_f_meas_ptr->reportCriteria.u.
            intraFreqReportingCriteria->eventCriteriaListOnSecULFreq.frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_UL ;
      }
  
         l1_intra_f_mcm_ptr->freq_info[SEC_FREQ].uarfcn_dl = intra_f_meas_ptr->reportCriteria.u.
           intraFreqReportingCriteria->eventCriteriaListOnSecULFreq.frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL ;

        /* Set event parameters */
        l1_intra_f_mcm_ptr->rpt_crit[SEC_FREQ].num_event =
          rrcmeas_fill_intra_freq_event_criteria_sec_freq(
           intra_f_meas_ptr->reportCriteria.u.intraFreqReportingCriteria,l1_intra_f_mcm_ptr->rpt_crit[SEC_FREQ].evt);
        l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_EVENT_TRIGGER_RPT;
  
      } /* End of if for event criteria list present */
      else
      {
        MSG_LOW("Setting num_event to 0", 0,0,0);
        /* So set num_event in L1 structure to 0 */
  
        l1_intra_f_mcm_ptr->rpt_crit[SEC_FREQ].num_event = 0;

         /* If meas id is not found or rpt crit is set to NOT AVAILABLE set rpt mode as RPT MODE NOT PRESENT */
         /* If MCM is setup then remove previously active MCM config Spec : 8.4.1.3 */        
        if(CHECK_RPT_CRIT_NOT_PRESENT(SEC_FREQ))
        {
          if(meas_id_idx != MAX_INTRA_FREQ_MEAS)
          {
            intra_freq_meas_id_list[meas_id_idx].rpt_crit[SEC_FREQ] = NOT_AVAILABLE;
          }
          l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_RPT_MODE_NOT_PRESENT; 	   
        }
  
      }
#endif  
      break; /* Come out of switch */
  
    case T_rrc_IntraFreqReportCriteria_r9_periodicalReportingCriteria:
  
      /* Set rpt mode criteria */
       l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_PERIODIC_RPT;
	  

  
  
      /* Set reporting cells */
      if (RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria,
        rrc_PeriodicalWithReportingCellStatus,reportingCellStatus))
      {
        if (rrcmeas_fill_no_of_reporting_cells(&intra_f_meas_ptr->reportCriteria.u.
          periodicalReportingCriteria->reportingCellStatus,
          & l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ]) == SUCCESS)
        {
           l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = TRUE;
        }
      }
  
      l1_intra_f_mcm_ptr->periodic_rpt_crit_incl[PRI_FREQ] = TRUE;
      /* Store reporting amount */
        l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_amount=
        RRCMEAS_RET_REPORTING_AMOUNT(
        intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->
        periodicalReportingCriteria.reportingAmount);
     

      /* Store reporting interval */
      l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_interval =
        RRCMEAS_RET_PERIODIC_REPORTING_INTERVAL
        (intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->periodicalReportingCriteria.reportingInterval);

      if (intra_f_meas_ptr->reportCriteria.u.periodicalReportingCriteria->
        periodicalReportingCriteria.reportingInterval == rrc_ReportingIntervalLong_ril0)
      {
        l1_intra_f_mcm_ptr->periodic_rpt_crit[PRI_FREQ].rpt_interval = 250;
      }
#ifdef FEATURE_WCDMA_DC_HSUPA
      if(CHECK_RPT_CRIT_NOT_PRESENT(SEC_FREQ))
      {
         if(meas_id_idx != MAX_INTRA_FREQ_MEAS)
         {
             intra_freq_meas_id_list[meas_id_idx].rpt_crit[SEC_FREQ] = NOT_AVAILABLE;
         }
         l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_RPT_MODE_NOT_PRESENT; 
      }
  
#endif
  
      break; /* Come out of switch */
  
  
    case T_rrc_IntraFreqReportCriteria_r9_noReporting:
  
       l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_NO_RPT;
  
      /* Set reporting cell status to FALSE */
       l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = FALSE;
  
      if ((RRC_MSG_COMMON_BITMASK_IE_PTR(intra_f_meas_ptr->reportCriteria.u.noReporting,
        rrc_ReportingCellStatusOpt,reportingCellStatus))  &&
        ( rrcmeas_fill_no_of_reporting_cells(&intra_f_meas_ptr->reportCriteria.u.noReporting->reportingCellStatus,
        & l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ]) == SUCCESS ))
      {
         l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] = TRUE;
#ifdef FEATURE_WCDMA_DC_HSUPA
         l1_intra_f_mcm_ptr->rpt_cell_status_incl[SEC_FREQ] = TRUE;
#endif
      }
  
#ifdef FEATURE_WCDMA_DC_HSUPA

      /* If secondary frequency is already configured, set meas action as L1 NO RPT else RPT MODE NOT PRESENT */
      l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_NO_RPT;

      if((meas_id_idx == MAX_INTRA_FREQ_MEAS) || (intra_freq_meas_id_list[meas_id_idx].rpt_crit[SEC_FREQ] == NOT_AVAILABLE))
      {
        l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_RPT_MODE_NOT_PRESENT;
        l1_intra_f_mcm_ptr->rpt_cell_status_incl[SEC_FREQ] = FALSE;
      }
#endif

      break;
  
    default:
      return RRCMEAS_FAIL;
  
    } /* End of switch */
  
  
    if (( l1_intra_f_mcm_ptr->rpt_cell_status_incl[PRI_FREQ] == TRUE) &&
      (( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_VASET) ||
      ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_MSET_NUSED_FREQ) ||
      ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_ASET_MSET_NUSED_FREQ) ||
      ( l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat == L1_RPT_ALL_VASET_AND_MSET_NUSED_FREQ))) 
    {
      WRRC_MSG1_ERROR("Rpt Cell Status invalid %d",  l1_intra_f_mcm_ptr->rpt_cell_status[PRI_FREQ].rpt_cell_stat);
      /* Retain the old CELL_INFO_LIST */
      WCDMA_MEMCPY(intra_freq_cell_list,
                   sizeof(intra_freq_cell_list_struct_type) * MAX_NUM_CARR * L1_MAX_CELL_MEAS,
                   intra_freq_cell_list_temp,
                   sizeof(intra_freq_cell_list_struct_type) * MAX_NUM_CARR * L1_MAX_CELL_MEAS);

      return RRCMEAS_FAIL;
    }
  }
  else
  {
    /* MCM setup condition check is not needed here as RPT CRIT is mandatory for SETUP */
     if((meas_id_idx == MAX_INTRA_FREQ_MEAS) || (intra_freq_meas_id_list[meas_id_idx].rpt_crit[PRI_FREQ] == NOT_AVAILABLE))
     {
       l1_intra_f_mcm_ptr->rpt_mode[PRI_FREQ] = L1_RPT_MODE_NOT_PRESENT;		
     }
#ifdef  FEATURE_WCDMA_DC_HSUPA
    if((meas_id_idx == MAX_INTRA_FREQ_MEAS) || (intra_freq_meas_id_list[meas_id_idx].rpt_crit[SEC_FREQ] == NOT_AVAILABLE))
    {
       l1_intra_f_mcm_ptr->rpt_mode[SEC_FREQ] = L1_RPT_MODE_NOT_PRESENT;		
    }
#endif
  }
  return RRCMEAS_SUCCESS;
}


/*===========================================================================
FUNCTION   RRCMEAS_CHECK_ADDNL_MEAS_IN_DB

DESCRIPTION

 Set the additional measurement information in DB based on measurement id
 extension is present or not

DEPENDENCIES

 None

RETURN VALUE
 None

SIDE EFFECTS

 None
===========================================================================*/
void rrcmeas_check_addtl_meas_in_db
(
  rrcmeas_layer_e_type *primary_meas_type,
  rrc_MeasurementControl_r9 *mcm_r9, 
  uint8 meas_id)
{
  if((rrc_meas_id_extn_support) && (TRUE == rrcmeas_check_if_addnl_meas_id_extn_is_given(mcm_r9)))
  {
    rrcmeas_set_additional_meas_extn_in_db(primary_meas_type,
      mcm_r9,meas_id);
  }
  else if(mcm_r9->measurementControl_r9.m.additionalMeasurementListPresent)
  {
    rrcmeas_set_additional_meas_in_db(primary_meas_type,
      &mcm_r9->measurementControl_r9.additionalMeasurementList,meas_id);
  }
  else
  {
    WRRC_MSG0_MED("REL9:Additional Meas not present");
  }
}


/*===========================================================================
FUNCTION   RRCMEAS_PROCESS_MCM_ADDNL_MEAS

DESCRIPTION

 Processed the additional measurements IE received in Rel 9 Measurement control message

DEPENDENCIES

 None

RETURN VALUE
 boolean

SIDE EFFECTS

 None
===========================================================================*/
boolean rrcmeas_process_mcm_addnl_meas
(
  rrc_MeasurementControl_r9 *mcm_r9,
  uint8 transaction_id,
  boolean *addtl_meas_validation,
  rrcmeas_layer_e_type primary_meas_type,
  uint8 meas_id,
  meas_validity_enum_type* p_meas_validity
)
{

  rrc_MeasurementControl_r9_IEs* rrc_mcm_ptr = NULL;

  rrc_AdditionalMeasurementID_List_r9 *addnl_meas_ptr_r9 = NULL;

  rrc_mcm_ptr = &mcm_r9->measurementControl_r9;

  if((rrc_meas_id_extn_support) && (TRUE == rrcmeas_check_if_addnl_meas_id_extn_is_given(mcm_r9)))
  {
    addnl_meas_ptr_r9 = &mcm_r9->v970NonCriticalExtensions.measurementControl_v970ext.additionalMeasurementList;

    /* Call fn which makes check for additional measurements */
    if (rrcmeas_validate_additional_meas_extn(addnl_meas_ptr_r9, transaction_id, &primary_meas_type,
        meas_id, p_meas_validity) == FALSE)
    {
      return FAILURE;
    }
    
    /* This means additional meas has been successfully validated */
    *addtl_meas_validation = TRUE;
    
    if (rrcmeas_check_mcm_for_setup_modify_additional_extn(
      *addtl_meas_validation, primary_meas_type, meas_id,
      addnl_meas_ptr_r9) == FALSE)
    {
      return FAILURE;
    }
  }
  else if(rrc_mcm_ptr->m.additionalMeasurementListPresent)
  {

    if(primary_meas_type == MAC_MEAS)
    {
      if (rrctvm_validate_additional_meas(p_meas_validity, &rrc_mcm_ptr->additionalMeasurementList,
        transaction_id, rrc_mcm_ptr->measurementIdentity) == FALSE)
      {
        return FAILURE;
      }  
    }
    else
    {
      /* Call fn which makes check for additional measurements */
      if (rrcmeas_validate_additional_meas(&rrc_mcm_ptr->additionalMeasurementList, transaction_id, &primary_meas_type,
        rrc_mcm_ptr->measurementIdentity) == FALSE)
      {
        return FAILURE;
      }
    }
    
    /* This means additional meas has been successfully validated */
    *addtl_meas_validation = TRUE;
   
    if (rrcmeas_check_mcm_for_setup_modify_additional(
      *addtl_meas_validation,primary_meas_type, meas_id,
      &rrc_mcm_ptr->additionalMeasurementList) == FALSE)
    {
      return FAILURE;
    }
  }
  else
  {
    WRRC_MSG0_MED("REL9:Additional Meas not present");
  }
  
  return SUCCESS;
}



/*===========================================================================
FUNCTION   RRCMEAS_PROCESS_INTRAFREQ_R9

DESCRIPTION

 Processed Intra Freq Meas in Rel9 Meas Ctrl Message

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/
uecomdef_status_e_type rrcmeas_process_intrafreq_r9
(
  rrc_cmd_type* cmd_ptr,
  uint8 transaction_id
)
{
  /* Stores Meas parameters to be sent to L1 */
  l1_meas_ctrl_parm_struct_type *l1_mcm = rrc_malloc(sizeof(l1_meas_ctrl_parm_struct_type));

  /* Meas Validity */
  meas_validity_enum_type meas_validity = NOT_PRESENT;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  rrcmeas_layer_e_type primary_meas_type = INTRA_FREQ;
  
  rrc_MeasurementControl_r9_IEs* rrc_mcm_ptr = NULL;

  rrc_MeasurementControl_r9 *mcm_r9 = NULL;

  rrc_DL_DCCH_Message* dcch_msg_ptr = NULL;


  uint8 meas_id_val = 0;

  boolean addtl_meas_validation = FALSE;

  uint8 alloc_idx = MAXIMUM_TRANSACTIONS;
  dcch_msg_ptr = (rrc_DL_DCCH_Message *)cmd_ptr->cmd.
    downlink_sdu_ind.decoded_msg;
  
  mcm_r9 = &dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
    u.later_r8_criticalExtensions.u.r9;

  rrc_mcm_ptr = &mcm_r9->measurementControl_r9;


    /* Set trans Id in var trans_id */
  trans_id = l1_mcm->trans_id = transaction_id;


  /* Make Compressed Mode Status Information as invalid so that L1 is O.K. */
  l1_mcm->dpch_cm_status_incl = FALSE;
  /* Set Compressed Mode Information */
  if ((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r9_IEs,dpch_CompressedModeStatusInfo)) &&
    (rrc_mcm_ptr->dpch_CompressedModeStatusInfo.tgp_SequenceShortList.n != 0))
  {

    if (rrcmeas_process_compressed_mode_status(&rrc_mcm_ptr->dpch_CompressedModeStatusInfo,
      &l1_mcm->cm_status_info) == FAILURE)
    {
      /* Send Meas Ctrl Failure Message */

      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;

    }
    /* Set compressed Mode as TRUE */
    l1_mcm->dpch_cm_status_incl = TRUE;

  } /* End of if of compressed mode processing */

  /* Store MCM contents in a Local Ptr */
  /* Assign default value to Primary Meas Type */
  primary_meas_type = INTRA_FREQ;

  /* Set meas id in L1 struct */

  /* Check if extended measurement is supported. If meas id extension is given then
     override the meas id given in legacy IE */

  if((rrc_meas_id_extn_support) && (TRUE == rrcmeas_check_if_meas_id_extn_is_given(mcm_r9,&meas_id_val)))
  {
    l1_mcm->meas_id = meas_id_val;
  }
  else
  {
    l1_mcm->meas_id = (uint16) rrc_mcm_ptr->measurementIdentity;
  }

  switch ( rrc_mcm_ptr->measurementCommand.t )
  {
  case T_rrc_MeasurementCommand_r9_setup:

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r9_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

    }
    else
    {
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;
    }


    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_SETUP;

    /* Store meas type */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    l1_mcm->meas_object_info_included = TRUE;

    /* Check if meas quantity not present */
    /* Store Meas Quantity */
    if (!((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
      intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r9,intraFreqMeasQuantity)) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
      intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r9,intraFreqReportingQuantity)) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.
      intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r9,reportCriteria))))
    {
      WRRC_MSG0_ERROR("REL9:Mandatory parameter for SETUP missing");
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;

    }

    if((RRC_CHECK_COMMON_MSG_TYPE(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
      reportCriteria,rrc_IntraFreqReportCriteria_r9_intraFreqReportingCriteria) )&&
      !((RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
      reportCriteria.u.intraFreqReportingCriteria,
      rrc_IntraFreqReportingCriteria_r9,eventCriteriaList)) 
#ifdef FEATURE_WCDMA_DC_HSUPA
     || (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement->
      reportCriteria.u.intraFreqReportingCriteria,
      rrc_IntraFreqReportingCriteria_r9,eventCriteriaListOnSecULFreq))
#endif
      ))
      {
       WRRC_MSG0_ERROR("REL9:event criteria for SETUP missing");
      /* Set transaction ID */
      rrcmeas_mcf.rrc_transaction_id = transaction_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
      rrc_free(l1_mcm);
      return FAILURE;
    }

    /* Fill intra-freq meas quantity, meas validity, cell list, cell info */
    if ( (rrcmeas_fill_common_mcm_intra_f_info_r9(
      rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement, 
      &l1_mcm->meas_object.u.intra_f,  l1_mcm)
      == RRCMEAS_FAIL))

    {
      rrc_free(l1_mcm);
      return FAILURE;
    }

    /* Process Additional Meas */
    if(rrcmeas_process_mcm_addnl_meas(mcm_r9,transaction_id,&addtl_meas_validation,primary_meas_type,l1_mcm->meas_id,&meas_validity) == FAILURE)
    {
      WCDMA_MEMCPY(intra_freq_cell_list, 
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                   intra_freq_cell_list_temp,
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);
      rrc_free(l1_mcm);
      return FAILURE;
    }

    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.setup->u.intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r9,measurementValidity))
    {
      /* Set it to CELL_DCH */
      meas_validity = STATE_DCH;
    }

    /* Time to store the Meas Id, validty, rpt criteria in RRC DB */
    if (rrcmeas_config_intra_freq_db_r9(l1_mcm,meas_validity,mcm_r9) == FALSE)
      {
      rrc_free(l1_mcm);
      return FAILURE;

    }

    /* If we reached this stage, that means Meas Ctrl Msg is valid */

    /* Check if Additional Meas has been validated successfully. */
    /* If yes, then store all additional meas in RRC DB */
    if (addtl_meas_validation == TRUE)
    {
      rrcmeas_check_addtl_meas_in_db(&primary_meas_type, mcm_r9,
        l1_mcm->meas_id);
    }

    /* Time to store this in Accepted transaction list after break */

    break; /* Come out of switch */


  case T_rrc_MeasurementCommand_r9_modify:
    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r9_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);
    }
    else
    {
      /* Store reporting mode to FALSE */
      l1_mcm->rpt_mode_incl = FALSE;
    }

    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_MODIFY;

    /* Set meas type to Intra-freq Meas */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.modify,
        rrc_MeasurementCommand_r9_modify,measurementType)))
    {
      l1_mcm->meas_object_info_included = FALSE;
    }
    else
    {
      l1_mcm->meas_object_info_included = TRUE;

      /* Fill intra-freq meas quantity, meas validity, cell list, cell info */
      if ((rrcmeas_fill_common_mcm_intra_f_info_r9(
        rrc_mcm_ptr->measurementCommand.u.modify->measurementType.u.intraFrequencyMeasurement,
        &l1_mcm->meas_object.u.intra_f,l1_mcm) == RRCMEAS_FAIL))
      {
        rrc_free(l1_mcm);
        return FAILURE;
      }

    } /* End of else of Meas Type Present */

    if(rrcmeas_process_mcm_addnl_meas(mcm_r9,transaction_id,&addtl_meas_validation,primary_meas_type,l1_mcm->meas_id,&meas_validity) == FAILURE)
    {
      WCDMA_MEMCPY(intra_freq_cell_list, 
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR,
                   intra_freq_cell_list_temp,
                   sizeof(intra_freq_cell_list_struct_type) * L1_MAX_CELL_MEAS * MAX_NUM_CARR);
      rrc_free(l1_mcm);
      return FAILURE;
    }

    if ((l1_mcm->meas_object_info_included == TRUE) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr->measurementCommand.u.modify->measurementType.u.intraFrequencyMeasurement,
      rrc_IntraFrequencyMeasurement_r9,measurementValidity)))

    {
      /* No need to check value as by default validity is CELL_DCH and if it is not CELL_DCH,
      then assume it to be CELL_DCH so that it could be resumed on next trans to CELL_DCH */
      meas_validity = STATE_DCH;
    }

    if (rrcmeas_config_intra_freq_db_r9(l1_mcm,meas_validity,mcm_r9) == FALSE)
    {
      rrc_free(l1_mcm);
      return FAILURE;

    }

    /* If we reached this stage, that means Meas Ctrl Msg is valid */

    /* Check if Additional Meas has been validated successfully. */
    /* If yes, then store all additional meas in RRC DB */
    if (addtl_meas_validation == TRUE)
    {
      rrcmeas_check_addtl_meas_in_db(&primary_meas_type, mcm_r9,
        l1_mcm->meas_id);
    }

    break; /* Come out of switch */

  case T_rrc_MeasurementCommand_r9_release:

    /* Check if rpt mode present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_mcm_ptr, rrc_MeasurementControl_r9_IEs,measurementReportingMode))
    {
      MSG_LOW("Reporting Mode present", 0,0,0);

      /* Store reporting mode to TRUE */
      l1_mcm->rpt_mode_incl = TRUE;

      l1_mcm->rpt_trans_mode = RRCMEAS_RET_MEAS_RLC_TRANSFER_MODE(
        rrc_mcm_ptr->measurementReportingMode.measurementReportTransferMode);

    }
    else
    {
      /* Store reporting mode to FALSE */
      l1_mcm->rpt_mode_incl = FALSE;
    }

    /* Set command type in L1 struct */
    l1_mcm->meas_cmd = L1_MEAS_RELEASE;

    /* Store meas type */
    l1_mcm->meas_object.meas_type = L1_INTRA_FREQ;

    /* Delete Meas Id from Intra Freq Meas Id List */
    rrcmeas_delete_meas(&l1_mcm->meas_id);

    /* Delete additional meas */
    rrcmeas_delete_addtl_meas(&l1_mcm->meas_id);

    break;

  default:
    rrc_free(l1_mcm);
    return FAILURE;

  }
  
  alloc_idx = rrcmeas_get_int_trans_index_for_trans_id(transaction_id);
  l1_mcm->trans_id = alloc_idx;
  /* Print first 5 elements of the list for debugging purposes */
  
  rrcmeas_send_l1_cmd(NULL, l1_mcm, NULL, L1_MEAS_CTRL_PARMS);
  rrc_free(l1_mcm);
  return SUCCESS;
}




/*===========================================================================
FUNCTION   RRCMEAS_RETRIEVE_MEAS_OWNER_R9

DESCRIPTION

 Finds the owner of measurement identity given in a MCM Rel 9 Msg

DEPENDENCIES

 None

RETURN VALUE

 None

SIDE EFFECTS

 None
===========================================================================*/

rrcmeas_layer_e_type rrcmeas_retrieve_meas_owner_r9
(
rrc_MeasurementCommand_r9* mcm_ptr,
uint32 meas_id
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
,pos_info_struct_type* pos_info_ptr
#endif
)
{
  uint8 count = 0;

  boolean meas_found = FALSE;
  /* First find if Meas is Setup/Modify/Delete */
  switch(mcm_ptr->t)
  {
  case T_rrc_MeasurementCommand_r9_setup:
    WRRC_MSG1_HIGH("REL9:MCM Setup: Meas ==> %d",mcm_ptr->u.setup->t);

    if (mcm_ptr->u.setup->t ==
      T_rrc_MeasurementType_r9_trafficVolumeMeasurement)
    {
      return MAC_MEAS;
    }
    else
    {
      /* Find the actual L1 owner */

      if (mcm_ptr->u.setup->t ==
          T_rrc_MeasurementType_r9_intraFrequencyMeasurement)
      {
        return INTRA_FREQ;
      }
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r9_interRATMeasurement)
      {
        return INTER_SYS;
      }

      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r9_interFrequencyMeasurement)
      {
        return INTER_FREQ;
      }
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r9_ue_InternalMeasurement)
      {
        return INTERNAL_MEAS;
      }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r9_up_Measurement)
      {
        /* Also check in reporting quantity what type of meas is that */
        if ((mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.
          positioningMethod == rrc_PositioningMethod_otdoa) ||
          (mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.
          positioningMethod == rrc_PositioningMethod_cellID))
        {
          WRRC_MSG1_ERROR("REL9:PosMethod=%d unsupported 0/1/2/3 OTD/G/Both/Id",
            mcm_ptr->u.setup->u.up_Measurement->ue_positioning_ReportingQuantity.positioningMethod);
          return UNKNOWN_MEAS;
        }
        /* Store position method and pos cmd */
        pos_info_ptr->pos_meas_cmd = RRC_MEAS_SETUP;
        pos_info_ptr->pos_method_type = RET_POS_METHOD
          (mcm_ptr->u.setup->u.up_Measurement->
          ue_positioning_ReportingQuantity.positioningMethod);

        return POSITION_MEAS;
      }
#endif

      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r9_qualityMeasurement)
      {
        return QUALITY_MEAS;
      }
      else if (mcm_ptr->u.setup->t ==
        T_rrc_MeasurementType_r9_csgProximityDetection)
      {
          /* Else some other Meas */
          return UNKNOWN_MEAS;
      }
      else
      {
        /* Else some other Meas */
        return UNKNOWN_MEAS;
      }
    }

  case T_rrc_MeasurementCommand_r9_modify:
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(mcm_ptr->u.modify,
      rrc_MeasurementCommand_r9_modify,measurementType))
    {
      WRRC_MSG1_HIGH("REL9:MCM:Modify, Meas Type included %d",mcm_ptr->u.modify->measurementType.t);

      if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r9_trafficVolumeMeasurement)
      {
        for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
        {
          if (tvm_meas_id_list[count].meas_id == meas_id)
          {
            return MAC_MEAS;
          } /* End of if of meas_identity found */

        } /* End of for loop  */

        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      } /* End of if of Traffic Volume Meas */

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r9_interRATMeasurement)
      {
        for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
        {
          if (inter_rat_meas_id_list[count].meas_id == meas_id)
          {
            return INTER_SYS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r9_ue_InternalMeasurement)
      {
        for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
        {
          if (ueim_meas_id_list[count].meas_id == meas_id)
          {
            return INTERNAL_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r9_interFrequencyMeasurement)
      {
        for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
        {
          if (inter_freq_meas_id_list[count].meas_id == meas_id)
          {
            return INTER_FREQ;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }

      else if (mcm_ptr->u.modify->measurementType.t ==
        T_rrc_MeasurementType_r9_intraFrequencyMeasurement)
      {
        for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
        {
          if (intra_freq_meas_id_list[count].meas_id == meas_id)
          {
            return INTRA_FREQ;
          }

        } /* End of for loop */
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }

      } /* End of else if */

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      else if (mcm_ptr->u.modify->
        measurementType.t ==
        T_rrc_MeasurementType_r9_up_Measurement)
      {
        for ( count = 0; count < MAX_POS_MEAS; count++ )
        {
          if (pos_meas_id_list[count].meas_id == meas_id)
          {
            /* Store position method and pos cmd */
            pos_info_ptr->pos_meas_cmd = RRC_MEAS_MODIFY;
            pos_info_ptr->pos_method_type =
              RET_POS_METHOD(mcm_ptr->u.modify->measurementType.u.up_Measurement->
              ue_positioning_ReportingQuantity.positioningMethod);

            return POSITION_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
#endif

      else if (mcm_ptr->u.modify->
        measurementType.t ==
        T_rrc_MeasurementType_r9_qualityMeasurement)
      {
        for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
        {
          if (quality_meas_id_list[count].meas_id == meas_id)
          {
            return QUALITY_MEAS;
          }

        }
        if (meas_found == FALSE)
        {
          return NOT_EXIST;
        }
      }
      else if (mcm_ptr->u.modify->
        measurementType.t ==
        T_rrc_MeasurementType_r9_csgProximityDetection)
      {
        return UNKNOWN_MEAS;
      }
      else
      {
        return UNKNOWN_MEAS;
      }

    } /* End of if of modify  rrc_measurementType_present */
    else
    { /* Since Meas Type is not given. It must exist at UE.
      If not then send an error msg indicating
      unsupported measurement */

      /* First search in L1 Measurement ID List */

      for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
      {
        if (intra_freq_meas_id_list[count].meas_id == meas_id)
        {
          return INTRA_FREQ;
        }

      } /* End of for loop */

      /* Search in Traffic Volume List */

      for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
      {
        if (tvm_meas_id_list[count].meas_id == meas_id)
        {
          return MAC_MEAS;
        } /* End of if of meas_identity found */

      } /* End of for loop */


      for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
      {
        if (inter_rat_meas_id_list[count].meas_id == meas_id)
        {
          return INTER_SYS;
        }

      }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
      for ( count = 0; count < MAX_POS_MEAS; count++ )
      {
        if (pos_meas_id_list[count].meas_id == meas_id)
        {
          pos_info_ptr->pos_meas_cmd = RRC_MEAS_MODIFY;
          pos_info_ptr->pos_method_type = pos_meas_id_list[count].pos_method_type;
          return POSITION_MEAS;
        }

      }
#endif
      for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
      {
        if (inter_freq_meas_id_list[count].meas_id == meas_id)
        {
          return INTER_FREQ;
        }
      }

      for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
      {
        if (ueim_meas_id_list[count].meas_id == meas_id)
        {
          return INTERNAL_MEAS;
        }

      }

      for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
      {
        if (quality_meas_id_list[count].meas_id == meas_id)
        {
          return QUALITY_MEAS;
        }
      }
      WRRC_MSG1_ERROR("REL9:Modify: Meas Id %d not present in UE",meas_id);
      return UNKNOWN_MEAS;

    } /* End of else of meas_type not present */


  case T_rrc_MeasurementCommand_r9_release:
    WRRC_MSG0_HIGH("REL9:MCM Release");

    /* First search in L1 Measurement ID List */

    for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
    {
      if (intra_freq_meas_id_list[count].meas_id == meas_id)
      {
        return INTRA_FREQ;
      }

    } /* End of for loop */

    /* Search in Traffic Volume List */

    for ( count = 0; count < MAX_TRAFFIC_VOLUME_MEASUREMENTS; count++ )
    {
      if (tvm_meas_id_list[count].meas_id == meas_id)
      {
        return MAC_MEAS;
      } /* End of if of meas_identity found */

    } /* End of for loop */


    for ( count = 0; count < MAX_INTER_RAT_MEAS; count++ )
    {
      if (inter_rat_meas_id_list[count].meas_id == meas_id)
      {
        return INTER_SYS;
      }
    }

    for ( count = 0; count < MAX_INTER_FREQ_MEAS; count++ )
    {
      if (inter_freq_meas_id_list[count].meas_id == meas_id)
      {
        return INTER_FREQ;
      }
    }

    for ( count = 0; count < MAX_INTERNAL_MEAS; count++ )
    {
      if (ueim_meas_id_list[count].meas_id == meas_id)
      {
        return INTERNAL_MEAS;
      }

    }

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
    for ( count = 0; count < MAX_POS_MEAS; count++ )
    {
      if (pos_meas_id_list[count].meas_id == meas_id)
      {
        pos_info_ptr->pos_meas_cmd = RRC_MEAS_DELETE;
        return POSITION_MEAS;
      }

    }
#endif

    for ( count = 0; count < MAX_QUALITY_MEAS; count++ )
    {
      if (quality_meas_id_list[count].meas_id == meas_id)
      {
        return QUALITY_MEAS;
      }
    }

    return NOT_EXIST;


  default:
    return UNKNOWN_MEAS;

  } /* End of switch */

}

/*===========================================================================

FUNCTION   RRCMEAS_CHECK_IF_MEAS_ID_EXTN_IS_GIVEN

DESCRIPTION

    This function is used to check if measurement id extension is given

DEPENDENCIES

    None

RETURN VALUE
   Void


SIDE EFFECTS

    None

===========================================================================*/
boolean rrcmeas_check_if_meas_id_extn_is_given
(
rrc_MeasurementControl_r9 *mcm_r9, 
uint8 *meas_id
)
{
  uint8 ret_sts = FALSE;
  
  if((mcm_r9->m.v970NonCriticalExtensionsPresent) && (mcm_r9->v970NonCriticalExtensions.measurementControl_v970ext.m.measurementIdentityPresent))
  {
    *meas_id = (uint8)mcm_r9->v970NonCriticalExtensions.measurementControl_v970ext.measurementIdentity;
    WRRC_MSG1_HIGH("REL9: Extended Meas Id is present %d", *meas_id);  
    ret_sts = TRUE;
  }

  return ret_sts;
}

/*===========================================================================

FUNCTION   RRCMEAS_CHECK_IF_ADDNL_MEAS_ID_EXTN_IS_GIVEN

DESCRIPTION

  This function is used to check if additional measurement id extension is given

DEPENDENCIES

    None

RETURN VALUE
   Void


SIDE EFFECTS

    None

===========================================================================*/
boolean rrcmeas_check_if_addnl_meas_id_extn_is_given
(
  rrc_MeasurementControl_r9 *mcm_r9
)
{
  uint8 ret_sts = FALSE;
  
  if((mcm_r9->m.v970NonCriticalExtensionsPresent) &&
     (mcm_r9->v970NonCriticalExtensions.measurementControl_v970ext.m.additionalMeasurementListPresent))
  {
    WRRC_MSG0_HIGH("REL9: Extd Addnl Meas Id is present ");    
    ret_sts = TRUE;
  }

  return ret_sts;
}



/*===========================================================================

FUNCTION   rrcmeas_process_mcm_r9

DESCRIPTION

    This function processed the Release 9 Meas Ctrl Message

DEPENDENCIES

    None

RETURN VALUE
   Void


SIDE EFFECTS

    None

===========================================================================*/

void rrcmeas_process_mcm_r9
(
  rrc_cmd_type *cmd_ptr,
  uint8 meas_ctrl_tr_id
)
{
  rrc_MeasurementControl_r9_IEs* mcm_ptr = NULL;
  rrc_MeasurementControl_r9 *mcm_r9 = NULL;

  rrc_DL_DCCH_Message* dcch_msg_ptr = NULL;

  /* Local var to store meas variable */
  rrcmeas_layer_e_type meas_owner;

  /* To store OC SET Status */
  rrcllc_oc_set_status_e_type oc_set_state;

  /* Stores meas ctrl failure parameters */
  rrcmeas_mcf_struct_type rrcmeas_mcf;

  /* Local Variable to store meas id */
  uint32 meas_id = 0;
  uint8 meas_id_val = 0;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  pos_info_struct_type pos_info;
#endif /*FEATURE_CGPS_UMTS_CP_WCDMA*/

  /* Store the message. No need to check again */
  dcch_msg_ptr = (rrc_DL_DCCH_Message *)cmd_ptr->cmd.
    downlink_sdu_ind.decoded_msg;

  /* Store actual mcm ptr in a local variable */
  mcm_ptr = &dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.
    later_r8_criticalExtensions.u.r9.measurementControl_r9;

  mcm_r9 = &dcch_msg_ptr->message.u.measurementControl.u.
    later_than_r3.criticalExtensions.u.later_than_r4.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.
    later_r8_criticalExtensions.u.r9;

  /* Check if extended measurement is supported. If meas id extension is given then
     override the meas id given in legacy IE */

  if((rrc_meas_id_extn_support) && (TRUE == rrcmeas_check_if_meas_id_extn_is_given(mcm_r9,&meas_id_val)))
  {
    meas_id = meas_id_val;
  }
  else
  {
    meas_id = mcm_ptr->measurementIdentity;
  }

  /* Retrieve the Meas Owner */
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  meas_owner = rrcmeas_retrieve_meas_owner_r9(&mcm_ptr->measurementCommand,
    meas_id, &pos_info);
#else /*FEATURE_CGPS_UMTS_CP_WCDMA*/
  meas_owner = rrcmeas_retrieve_meas_owner_r9(&mcm_ptr->measurementCommand,
    meas_id);
#endif /*FEATURE_CGPS_UMTS_CP_WCDMA*/

  /* Get OC status */
  oc_set_state = rrcllc_get_ordered_config_status();

  MSG_HIGH("REL9: meas id %d, meas owner %d, oc_state %d",meas_id, meas_owner, oc_set_state);

  if ((((meas_owner == INTRA_FREQ) || (meas_owner == INTERNAL_MEAS)|| (meas_owner == INTER_FREQ) ||
    (meas_owner == INTER_SYS)) && (rrcmeas_current_substate != RRCMEAS_CELL_DCH))
    || ((oc_set_state == OC_SET_FOR_DCH_CELL_PCH_TRANS) || (oc_set_state == OC_SET_FOR_DCH_URA_PCH_TRANS)))
  {
    return;
  }

  if((meas_owner != UNKNOWN_MEAS)&& (meas_owner != NOT_EXIST))
  {
    rrcmeas_check_meas_id_used_for_different_meas_type(meas_owner, meas_id);
  }
  if (meas_owner == UNKNOWN_MEAS)
  {
    /* Send Meas Ctrl Failure Message */

    rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

    /* Set error t */
    rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

    if (pos_meas_failure == TRUE)
    {
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
      pos_meas_failure = FALSE;
    }

#endif

    /* Send MCF msg to UTRAN */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);

    return;
  }

  if (meas_owner == NOT_EXIST)
  { 
    if(mcm_ptr->measurementCommand.t != T_rrc_MeasurementCommand_r9_release)
    {
      /* Send Meas Ctrl Failure Message */

      rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

      /* Set error t */
      rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;

#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)

      if (pos_meas_failure == TRUE)
      {
        rrcmeas_mcf.error_choice = T_rrc_FailureCauseWithProtErr_configurationIncomplete;
        pos_meas_failure = FALSE;
      }

#endif

      /* Send MCF msg to UTRAN */
      rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
    }
    else
    {
      WRRC_MSG0_HIGH("Ignore MCM release for an nonexistent measurement, do not send MCM failure");
    }
    return;
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == INTRA_FREQ)
  {
    if (rrcmeas_process_intrafreq_r9(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      return;
    }
    else
    {
      return;
    }
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == INTER_FREQ)
  {
    if (rrcifreq_process_mcm_r9(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if((!process_interfreq_interrat_meas_rel7) && (!process_interfreq_uei_meas_rel7))
      {
        return;
      }
      return;
    }
    else
    {
      return;
    }
  }
  else if (meas_owner == MAC_MEAS)
  {
    if (rrctvm_process_traffic_vol_info_r9(cmd_ptr, meas_ctrl_tr_id) == TVM_SUCCESS)
    {
      return;
    }
    else
    {

      return;
    }
  }
  else if (meas_owner == INTER_SYS)
  {
    if (rrcirat_process_mcm_r9(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if(!process_interfreq_interrat_meas_rel7)
      {
        return;
      }
      return;
    }
    else
    {
      return;
    }
  }
  else if (meas_owner == INTERNAL_MEAS)
  {
    if (rrcueim_process_mcm_r9(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      if((!process_interfreq_interrat_meas_rel7) && (!process_interfreq_uei_meas_rel7))
      {
        return;
      }

      return;
    }
    else
    {
      return;
    }
  }
  /* Check if it is Inter-Freq Meas */
  if (meas_owner == QUALITY_MEAS)
  {
    if (rrcqm_process_mcm_r9(cmd_ptr, meas_ctrl_tr_id) == SUCCESS)
    {
      return;
    }
    else
    {
      return;
    }
  }
#if defined (FEATURE_CGPS_UMTS_CP_WCDMA)
  else if ( meas_owner ==  POSITION_MEAS)
  {
    if (rrcmeas_process_pos_mcm_r9(cmd_ptr->cmd.
      downlink_sdu_ind.decoded_msg, &pos_info, meas_ctrl_tr_id) == SUCCESS)
    {
      MSG_LOW("REL9:POS: MCM successfully processed",0,0,0);
    }
    else
    {
      MSG_LOW("REL9:POS: MCM not processed successfully",0,0,0);
    }
    return;
  } /* End of if of Positioning Measurements */
#endif
  else
  {
    /* Set transaction ID */

    rrcmeas_mcf.rrc_transaction_id = meas_ctrl_tr_id;

    /* Set error t */
    rrcmeas_mcf.error_choice =
      T_rrc_FailureCauseWithProtErr_unsupportedMeasurement;

    /* Send RRC Meas Ctrl Failure msg to UTRAN */
    rrcmeas_send_meas_ctrl_failure_msg(&rrcmeas_mcf);
  }

}

#endif /* FEATURE_WCDMA_REL9 */

#ifdef FEATURE_WCDMA_REL10
#error code not present
#endif /* FEATURE_WCDMA_REL10 */
/*===========================================================================

FUNCTION   rrcmeas_get_substate

DESCRIPTION

  This function retrieves the RRC MEAS SUBSTATE.
        
DEPENDENCIES

  None.
 
RETURN VALUE

  Returns rrc meas substate in uint8

SIDE EFFECTS

  None.

===========================================================================*/

uint8 rrcmeas_get_substate( void )
{
  return ((uint8)rrcmeas_current_substate);
}

/*===========================================================================

FUNCTION  rrcmeas_process_sib18_filtering

DESCRIPTION
This function does a one to one comparison on cell list 
passed with the SIB18 elements and determines if the cell 
needs to be measured in non-DCH states..

DEPENDENCIES
 None

RETURN VALUE

SIDE EFFECTS
 None
===========================================================================*/
void rrcmeas_process_sib18_filtering(
  rrc_MultiplePLMNsOfIntraFreqCellsList *tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr,
  rrc_PLMNsOfIntraFreqCellsList *tmp_rrc_PLMNsOfIntraFreqCellsList_ptr,
  rrc_plmn_identity_type *tmp_plmn_identity_ptr,
  uint16   cell_count,
  boolean *measure_in_idle_pch_fach_ptr,
  boolean previous_measure_in_idle_pch_fach /* Previous cell value if exists*/
)
{
  uint32 MulPlmnIdx=0;
  rrc_PLMN_Identity tmp_ext_plmn;
  rrc_int_cell_id_type  tmp_cell_id;
  rrc_plmn_identity_type selected_plmn_identity;
  if(rrc_ccm_get_serv_plmn_cellid(&tmp_cell_id, &selected_plmn_identity) == RRC_CELL_LOSS_NO_NEW_CELL)
  {
    WRRC_MSG0_HIGH("Function rrcmeas_process_sib18_filtering() is called without proper validation");
    return;
  }
  if((tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr != NULL) && (tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr->n > cell_count))
  {
    if(tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr->elem[cell_count].m.multiplePLMN_listPresent)
    {
      for(MulPlmnIdx=0; MulPlmnIdx < tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr->elem[cell_count].multiplePLMN_list.n; MulPlmnIdx++)
      {
         if(tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr->elem[cell_count].multiplePLMN_list.elem[MulPlmnIdx].m.mccPresent)
         {
           tmp_ext_plmn.mcc = tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr->elem[cell_count].multiplePLMN_list.elem[MulPlmnIdx].mcc;
         }
         else
         {
             /*3> if the MCC is not present when reading a IE "PLMN identity with Optional MCC" in the IE "MultiplePLMN List":
                                    4> set the MCC of this PLMN identity equal to the MCC of the closest preceding "PLMN identity with
                                         Optional MCC" in the "Multiple PLMN List" that includes an MCC;
                                    4> or, if no such "PLMN identity with Optional MCC" exists, the UE shall set the MCC of this PLMN
                                         identity to the MCC of the "PLMN identity" IE in the Master Information Block irrespective of the
                                         value of the IE "MIB PLMN Identity". */
  
           /*Retaining the OldValue of MCC in 'tmp_plmn_identity_ptr' (Note: For the first Element, tmp_plmn_identity_ptr points to same as selected_plmn_identity)*/
           tmp_ext_plmn.mcc.n = 3;
           tmp_ext_plmn.mcc.elem = &(tmp_plmn_identity_ptr->mcc[0]);  //No memAlloc,memCopy required
         }
         tmp_ext_plmn.mnc = tmp_rrc_MultiplePLMNsOfIntraFreqCellsList_ptr->elem[cell_count].multiplePLMN_list.elem[MulPlmnIdx].mnc;
         rrc_translate_gsm_map_plmn_id(&tmp_ext_plmn, tmp_plmn_identity_ptr);

        
         *measure_in_idle_pch_fach_ptr = FALSE;
  
         if((rrc_bcch_and_nas_plmns_match(*tmp_plmn_identity_ptr, selected_plmn_identity) == TRUE) || 
           ((rrccsp_check_for_eplmn(mmumts_convert_rrc_plmn_id_to_nas_plmn_id(*tmp_plmn_identity_ptr))) == TRUE))
         {
            WRRC_MSG0_HIGH("measure in IDLE,FACH,PCH,DCH");
            /* set the flag to TRUE */
            *measure_in_idle_pch_fach_ptr = TRUE;
            break;
         }
      }
    }
    else
    {
      /* use the previous value of the flag if PLMN id is not selected PLMN */
      if(rrc_bcch_and_nas_plmns_match(*tmp_plmn_identity_ptr, selected_plmn_identity) == FALSE)
      {
        /* Add code to set the flag meas_pch_fach_idle to the flag value of the previous cell */
        if(cell_count > 0)
        {
          *measure_in_idle_pch_fach_ptr = previous_measure_in_idle_pch_fach;
        }
      }
    }
  }

  else if((tmp_rrc_PLMNsOfIntraFreqCellsList_ptr != NULL) && (tmp_rrc_PLMNsOfIntraFreqCellsList_ptr->n > cell_count))
  {
    if(tmp_rrc_PLMNsOfIntraFreqCellsList_ptr->elem[cell_count].m.plmn_IdentityPresent)
    {
      rrc_translate_gsm_map_plmn_id(&tmp_rrc_PLMNsOfIntraFreqCellsList_ptr->elem[cell_count].plmn_Identity,
        tmp_plmn_identity_ptr);
      if(rrc_bcch_and_nas_plmns_match(*tmp_plmn_identity_ptr, selected_plmn_identity) == FALSE)
      {
        if((rrccsp_check_for_eplmn(
          mmumts_convert_rrc_plmn_id_to_nas_plmn_id(
          *tmp_plmn_identity_ptr))) == FALSE)
        {
          WRRC_MSG0_HIGH("Non eq PLMN measure only in DCH");
          /* set the flag to FALSE */
          *measure_in_idle_pch_fach_ptr = FALSE;
        }
      }
    }
    else
    {
      /* use the previous value of the flag if PLMN id is not selected PLMN */
      if(rrc_bcch_and_nas_plmns_match(*tmp_plmn_identity_ptr, selected_plmn_identity) == FALSE)
      {
        /* Add code to set the flag meas_pch_fach_idle to the flag value of the previous cell */
        if(cell_count > 0)
        {
          *measure_in_idle_pch_fach_ptr = previous_measure_in_idle_pch_fach;
        }
      }
    }
  }
  else
  {
    /* 1> if the number of identities in a PLMN list (if any) is lower than the number of neighbour cells in the paired list, 
          the missing PLMN identities are replaced by the PLMN configuration for the last cell in the list. */

    if((cell_count > 0) && (previous_measure_in_idle_pch_fach == FALSE))
    {
      *measure_in_idle_pch_fach_ptr = FALSE;
      WRRC_MSG0_HIGH("PLMN list < Cell list. measure only in DCH");
    }
    else
    {
      /*Flag 'measure_in_idle_pch_fach' already set to TRUE before this function call*/
      WRRC_MSG0_HIGH("PLMN list < Cell list. measure in IDLE,FACH,PCH,DCH");
    }
  }
}/*===========================================================================
FUNCTION   rrcmeas_return_substate

DESCRIPTION
return current substate

DEPENDENCIES
None

RETURN VALUE
rrcmeas_substate_e_type

SIDE EFFECTS
None
===========================================================================*/
#ifdef FEATURE_QSH_DUMP
  __attribute__((section(".uncompressible.text")))
#endif
uint8 rrcmeas_return_substate(void)
{
  return (uint8)rrcmeas_current_substate;
}

/*===========================================================================
FUNCTION   rrcmeas_get_meas_id_bitmask

DESCRIPTION
return meas id bit mask
DEPENDENCIES
None

RETURN VALUE
rrcmeas_substate_e_type

SIDE EFFECTS
None
===========================================================================*/

#ifdef FEATURE_QSH_DUMP
  __attribute__((section(".uncompressible.text")))
#endif

uint32 rrcmeas_get_meas_id_bitmask(void)
{
  uint8 count = 0;
  uint32 meas_id_bmask = 0;

  for ( count = 0; count < MAX_INTRA_FREQ_MEAS; count++ )
  {
    if (intra_freq_meas_id_list[count].meas_id != INVALID_MEAS_ID)
    {
	      	meas_id_bmask |= 1<<intra_freq_meas_id_list[count].meas_id;		
    }
  }
  return meas_id_bmask;
}  
