/*===========================================================================

                L3 - RRC Lower Layer Controller Physical Channel IEs

DESCRIPTION
  This file contains functions necessary for the RRC Lower Layer Controller
  Ordered Config Physical Channel Information Element Processing.

Copyright (c) 2000-2009 Qualcomm Technologies, Inc.  All Rights Reserved.
QUALCOMM Proprietary.  Export of this technology or software is regulated
by the U.S. Government. Diversion contrary to U.S. law prohibited.
===========================================================================*/


/*===========================================================================
                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

$PVCSPath:  L:/src/asw/MSM5200/RRC/vcs/rrcllcpcie.c_v   1.41   21 Jun 2002 13:46:46   jhicks  $
$Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/wcdma/rrc/src/rrcllcpcie.c#1 $ $DateTime: 2016/12/13 08:00:12 $ $Author: mplcsds1 $

when        who     what, where, why
--------    ---     --------------------------------------------------------
06/20/16   sg      Made changes to reduce F3s
05/11/16   vs      Changes to remove irrelevant f3s
06/12/15   sp      Made changes to reject configuration if n/w signals dchsupa continue when dchsupa is not active.
03/18/15   ad      Made changes to pick to ac to asc info from sib5 if missing in sib6.
01/21/15   sa      Made changes for QTF with CRM
12/24/14   sp      Made changes not to include AGCH add mask for non-serving RLs
11/05/14   aa      Added Message Highs for validation failures
10/11/14   sg      Made changes to add validations for 3C window size
09/16/14   sg      Made changes to fix compilation errors if REL 10
                   feature flag is disabled
07/18/14   ad      Made changes to reduce F3s
06/26/14   sn      WRRC changes for FR20484
06/26/14   ad      Made changes to implement IE "E-DCH reconfiguration information same serving cell" in ASU
06/20/14   sa      Made changes to update the UL 16QAM
05/23/14   db      Made changes to update OC when mac_InactivityThreshold is 256 in DTX info 
05/20/14   sp      Made changes to retain the predef_po3_status
05/20/14   sp      Made changes to set the number of prachs as 8 when network indicates more than 8 in the SIB-5
05/16/14   sp      Made changes to update proper data base when getting serving rl idx for DCHSUPA
05/16/14   sp      Made changes to appropriately featurize DCHSUPA code to avoid compilation errors
05/14/14   ymu     Feature name FEATURE_WCDMA_DC_HSUPA_FRAME replacement with FEATURE_WCDMA_DC_HSUPA 
05/06/14   sp      Made changes to add a check to avoid accessing out of bound values for array- sec_hs_carrier_info
05/01/14   as      Made changes to get the correct first secondary DL HS carrier index during DC-HSUPA processing
04/10/14   db      Made changes to enable/disable feature support in DSDS/DSDA/TSTS modes through NV
04/07/14   sp      Made changes to update secondary req mask if primary HS action is RECFG 
03/27/14   sa      Made changes to disable only when “E-DPDCH power interpolation” is absent
04/02/14   vg      Made changes to Systematically log all the internal and external primitive handled in RRC and corresponding top level action.
02/04/14   sg      Made code changes for latest 3C interface
02/10/14   sg      Made changes to provide AGCH ADD for new serving RL and DROP for 
                   old serving RL if there is a serving RL change on seconday.
03/13/14   db      Made changes to delay PCCPCH drop for HSRACH to DCH(FDPCH)
02/13/14   ad      Made changes to remove redundant F3s
01/28/14   sp      Fixed KW errors.
01/17/14   sp      Made changes to set secondary l1 req mask to drop and add for intra frequency HHO cases
10/12/13   sa      Made changes for reseting ETFCI boost values
12/09/13   sp      Made changes for OSYS 6.6.5 migration
12/03/13   sg      Made changes to update review comments for 3C 
11/20/13   ad      Made changes to not reset predefined preset status flag after GtoWHO until 
                   PO3 is explicitly indicated by NW
11/20/13   sp      Made changes to stop HSDPA if HS RL is removed and Serving HSDSCH params are 
                   reconfigured without repointing HS
11/20/13   db      Made changes to delay PCCPCH drop upon HSRACH to DCH transition
11/18/13   bc      Checked in REL 10 spec crs changes.
11/15/13   sp      Added Nv support for boost feature
11/14/13   sa      DC feature support will be controlled thru UE Cat
11/12/13   sa      Made changes to reject the configuration, if DPCH is configured on primary and FDPCH is on sec
11/05/13   as      Made changes to pass correct 3C action if sec hs params are abscent
10/30/13   as      Made changes to add feature code for FEATURE_WCDMA_3C_HSDPA
10/21/13   vg      Made changed to Accept reconfiguration which asks UE to use (MACi/is, DCH) and reject reconfiguration only with (MACi/is, MAChs).
10/18/13   ad      Made changes to check for HRNTI when serving cell repointing happens through ASU
10/17/13   ad      Changes for DC HSDPA feature with 3C interface
09/23/13   sp      Made changes to stop HSDPA if HS RL is removed and Serving HSDSCH params are reconfigured without repointing HS
09/16/13   mp      Added code for REL10 signalling under feature FEATURE_WCDMA_REL10
08/26/13   ad      Made changes to provide CTCH indicator on the correct FACH index to MAC
08/27/13   sp      Made changes to rename r9 function rrcllcpcie_process_dc_hsupa_params_r9
08/26/13   sp      Made changes to replace secapi_get_random() instead of ran_next() and rand()
08/22/13   ad      Made changes to check the current camped freqeucny when destination freq 
                   is not provided in OTA
07/31/13   sa      Made changes not to check mac-hs reset indicator IE for connection setup
07/30/13   ad      Added code changes to support DB-DC feature
07/08/13   ad      Made changes to remove redundant F3s
06/21/13  sg       Fixed KW error
06/17/13   sg      Fixed KW errors
06/06/13   as      Made changes to validate fdcph offset for dc-hsupa only if DC is active
06/04/13   sg      Made changes to fix the dchsupa code rejecting the ASU
                   if sec_num_rl=0 even if dchsupa is not configured in OTA
06/04/13   ag      Fixed KW errors
05/22/13   sa      Added code changes to support FEATURE_WCDMA_DC_HSUPA
05/15/13   as      Made changes to pass whether PO3 is signalled or pre-set
05/10/13   sg      Made changes to fix the compilation errors
04/25/13   sg       Added code for REL9 under FEATURE_WCDMA_REL9
04/03/13   sr      Made changes to remove redundant MSG_HIGHs
03/21/13   mp      Made changes to process and validate the three index step threshold
                   instead of two index step threshold.
03/06/13   ad       Added prints to print CRNTI on PCH->FACH and FACH->PCH transition
                    Removed redundant F3s
02/28/13   ad       Made changes to update num_tfci for rach configuration
01/18/13   md       Made changes to correct the logic of filling gaps 
03/01/13   as      Made changes to handle cell-id for Rel7 and Rel8
01/03/13   ad      Made changes to reduce the redundant F3s
12/18/12   sg      Made changes to return FAILURE if "Timing indication" is set to "initialise" 
                   and the message is not used to perform hho.
10/26/12   db      EFACH Redesign changes
10/25/12   ad      Made changes to deactivate the CM patterns which are not configured
                   in the message which does a timing re-initialized HHO
09/28/12   mp      Made the changes to detected the duplicate RL entry
08/13/12   md      Made changes to take the SCCPCH config from SIB5 for CTCH setup if not present in SIB6
07/24/12   geg      Upmerge WCDMA.MPSS.1.0 to WCDMA.MPSS.2.0
04/06/12   ad      Changes for HS-RACH feature
04/28/12    db     Added NULL pointer check in rrc_is_eul_active 
04/13/12   pm      removing FEATURE_BAND_PRIORITY_ORDER_THROUGH_NV feature flag and reverting some #ifdef
                   changes
04/10/12   pm      Added code to support the band priority nv
03/18/12   db       Fixed Compiler error
03/16/12   as       Corrected Persistence formula syntax
01/19/12   md       Made changes to reject DC-HSDPA config if UE capability doesn't support DC.
01/16/12   mn       Made changes to configure bit aligned when Downlink 
                    HS-PDSCH information IE is present for R5/R6
01/02/12   pm       Added rrc_wtol_cm_support_nv to put FEATURE_WCDMA_CM_LTE_SEARCH feature under nv check 
12/05/11   pm       Added code to support cell id request by CM in DCH state"
10/31/11   db       Updated persistence value formula
09/28/11   gv       Moved macros for WCDMA frequency bands to header file
09/13/11   ad       Made changes to have the same the persistance value for ASC0 and ASC1
08/16/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.104.00
07/29/11   ad       Added code to move F-DPCH code under condition check for IHO and 
                    non-dch transition in get_dl_info_per_rl_r7 and get_dl_info_per_rl_r8 functions
07/14/11   ad       Added code to handle minReduced_E_DPDCH_GainFactorPresent IE
07/06/11   gv       Fixed KW errors
06/17/11   sks      Made changes to correct the UARFCN to freq (in 100KHz) coversion equation.
06/10/11   kp       Bug fix to correct the TDD bit mask check in rrcllc_check_if_hsscch_changed
06/07/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.99.50
05/31/11   as       Added code to skip the check for timing init indication if FDPCH is enabled
05/27/11   ad       Fixed bug in rrcllcpcie_process_rl_addition_info_list_r6 function
05/27/11   as       Fixed osys bugs
05/17/11   ad       Fixed wrong macro usage bugs in rrcllc_get_predefined_dl_common_info, 
                    rrcllcpcie_is_hho_r8 and set_compressed_mode_info_r8 
05/17/11   ad       Made changes to handle the return type of rrcllcpcie_process_e_dpcch_info_r7
                    in rrcllcpcie_process_ul_e_dch_information_r8 and rrcllcpcie_process_ul_e_dch_information_r7
05/16/11   as       Made changes to allocate memory in handover to utran preconfig functions
05/16/11   as       Bug fix in accessing restricted_trch_list in get_dl_rm_restriction_info
05/16/11   kp       Bug fix in accessing rrc_additional_prach_TF_list in get_prach_sys_info
                    and get_prach_sys_info_list.
05/16/11   as       Added code to correct the looping trhough fach pch info list
05/10/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.97.50
05/05/11   vg       added channal locking feature support under rrccsp_channel_locking_nv_status
                    condition
05/06/11   ad       Added code to reject the CPC configuration when IE "DTX-DRX timing information"
                    is present and IE "DTX–DRX information" is not present and 
                    there is a EDCH TTI change.
05/06/11   ad       Fixed the bug of wrong pointer access in get_dl_info_per_rl_r8 fn
05/03/11   rl       Fixed the lint error
04/29/11   ad       Fixed a bug which allows processing of DCCH message 
                    in cell update confirm critical extensions
04/25/11   rl       Fixed the KW error
04/12/11   kp       Made changes to pass predefined config for G2W IRAT-HO
04/11/11   ad       Fixed the bug of wrong pointer access in get_dl_info_per_rl_r7 fn
03/23/11   rl       Fixed compiler error on enabling CPC_DRX feature
03/18/11   ad       Fixed the bug to check the no of elements in the list 
                    in set_compressed_mode_info_r8 function
03/17/11   rl       Fixed the compiler errors/warning after enabling 
                    FEATURE_WCDMA_CM_LTE_SEARCH
03/11/11   as       Fixed bug to increment loop variable correctly
                    in dl_info_per_rl for objsys
03/04/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.92.50
03/02/11   ad       Added changes to check if DC-HSDPA is active 
                    if DL_SecondaryCellInfoFDD config is chosen as continue.
02/07/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.90.50
01/27/11   rm       Added code to support BC19 under FEATURE_WCDMA_BC19
01/28/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.89.57
01/12/11   ad       Added changes for RRC SW decoupling
01/04/11   su       Made changes to configure mac-hs with bit aligned on Mac-ehs to Mac-hs 
                    transition when Downlink HS-PDSCH information IE is missing
12/31/10   rl       Merged with VU_MODEM_WCDMA_RRC.01.86.50
12/11/10   rl       Fixed compiler errors for FEATURE_WCDMA_CPC_DTX
11/11/10   as       Fixed compiler errors and ASN 9.3 Migration changes for MIMO
11/09/10   rl       Merged with VU_MODEM_WCDMA_RRC.01.84.50
11/02/10   su       Fixed Klocwork warnings.
11/02/10   rm       Added code to support W2L measurements in DCH state under
                    FEATURE_WCDMA_CM_LTE_SEARCH
10/28/10   prk      Fixed KW warnings. 
10/14/10   su       Fixed compiler errors.
10/11/10   ss       ASN.1 migration to ASN1 9.3.0
10/11/10   su       Made changes to retain the older TFRI table if 
                    whole Downlink HS-PDSCH information IE is missing.
10/07/10   rm       Added code to fail the OTA if TDD HS-SCCH info is included
10/06/10   kp       Added code to loop at UE_MAX_TRCH for restricted_trch_list as per ASN.1 
                    this list can be as big as 32 & our internal structure is of size 12.
                    This change is to avoid buffer over flow issue.
10/04/10   prk      Merging latest e-fach fixes.
10/01/10   su       Fixed compiler warnings
11/03/10   rl       Fixed review comments
10/30/10   rl       Objective systems migration changes check in 
                    on code base VU_MODEM_WCDMA_RRC.01.80.00
09/01/10   prk      Fixed compiler warnings.
08/30/10   su       Fixed Klocwork errors.
08/17/10   kp       Made changes for clearing CLT when OTA doesnt give CLT info
                    currently RRC use old value of CLT which is incorrect.    
08/02/10   prk      Made changes to skip re-initializing DOFF bitmask in L1 
                    opt_parm_presence_bitmask when RRC is in DCH state.
06/29/10   rm       Added code to support LTE<->WCDMA Inter RAT
06/18/10   dm       Fixed compilation warnings.
06/15/10   kp       Bug fix in condition check "if the IE "UE DTX long preamble length" is set to 4 or 15 
                    slots and the value of the IE "Inactivity Threshold for UE DTX cycle 2" is 
                    less than 4 TTIs (for 10ms E-DCH TTI) or 8 TTIs (for 2ms E-DCH TTI)"
                    in rrcllcpcie_validate_dtx_params.
05/24/10   kp       Added code for feature CPC-DRX under feature flag FEATURE_WCDMA_CPC_DRX
05/12/10   gkg      Made changes to send RECFG to WL1 for MIMO in case HS-Repointing
                    happens and MIMO is continued on the target cell as well.
05/07/10   prk      Fixed compiler warnings.
05/04/10   gkg      Made changes to initialize DL CTFC properly.
04/15/10   gkg      Made changes for processing MIMO Codebook Restriction.
04/07/10   gkg      ASN.1 migration to 8.a.0
04/23/10   as       Fixed Klocwork issues
04/14/10   rm       Corrected the UARFCN range for BC11
04/12/10   rm       Added code to support BC11
03/17/10   gkg      Made changes to populate Secondary C-PICH Power Offset 
                    from R7 and R8 OTAs for MIMO UEs.
03/17/10   as       Resolved Errors due to ASN.1 8.9 Migration
03/15/10   as       Updated RRC Code to support ASN.1 8.9 version
03/04/10   gkg      Made changes to handle the scenario when "Serving HS-DSCH cell information"
                    IE is provided in ASU but not used for HS-Repointing. This handling is done
                    for GCF[8.2.6.58].
02/09/10   sup      Fixed featurization where s_cpich_po was used outside the feature
                     FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT 
01/22/10   gkg      To comply with Spec CR 3478, if F-DPCH SlotFormat isn't given for an RL,
                    we need to default it to 0. Therefore, made the changes for R6 as well (for
                    the case when E F-DPCH is turned off for an RL using R6 Signaling OTA).
01/18/10   kp       Added code to reject the config if the IE "UE DTX long preamble length" 
                    is set to 4 or 15 slots and the value of the IE "Inactivity Threshold for UE DTX 
                    cycle 2" is less than 4 TTIs (for 10ms E-DCH TTI) or 8 TTIs (for 2ms E-DCH TTI).
01/18/10   kp       Added code to reject the config if the values of the IE 
                    "UE DTX DRX Offset" that doesn't fulfill the equation UE DTX DRX 
                    Offset mod 5=0 for 10ms E-DCH TTI.
01/18/10   kp       Added code to reject config if cqi_feedback_cycle is zero & 
                    DTX config is provided by N/W. 
12/17/09   as       if E-FDPCH slot format is absent then set default value as Zero
12/07/09   dm       Fixed lint errors
11/09/09   kp       Fixed bug in rrcllcpcie_process_rl_addition_info_list_r6 to not
                    fail config if there is no e-hich reconfig /rgch info no presnt,as 
                    this is valid condition where N/W is setting up e_rl with only e-hich & there is no RGCH.      
11/09/09   gkg      Made changes to set S-CPICH Power Offset to zero for MIMO.
10/28/09   kp       Added code to support Rel-8 minReduced E_DPDCH GainFactor under FEATURE_WCDMA_REL8
10/22/09   gkg      When feature FEATURE_WCDMA_FDPCH_STTD is enabled, fixed the LINT issues.
10/05/09   ps       Fixed Klockwork warnings
10/12/09   kp       If N/W is providing AGCH info for non EUL serving RL then don’t 
                    indicate add/reconfig action to L1, since AGCH makes sense 
                    only for serving RL.
10/07/09   gkg/kp   Changes for REL8 under FEATURE_WCDMA_REL8 and CPC-DTX
09/24/09   ps       Made changes to correct the typo error in R7 code
                    path to check the DEFAULT F-DPCH Offset Value & F-DPCH Frame Offset only
                    for Timing initialised case.
09/03/09   ps       Made changes for EDPCCH power Boost under 
                    FEATURE_WCDMA_REL7_EDPCCH_POWER_BOOST
07/21/09   ps       Fixed a featurisation issue with FEATURE WCDMA 64QAM
07/16/09   kp       Added code to change the enum member name CM_NONE to RRC_CM_NONE in 
                    rrcllc_cm_status_e_type as it was conflicting with MS VS 2005.NET 
                    which is needed for RRC UTF.
07/14/09   dm       Fixed lint errors
06/17/09   ps       Made changes to not send a CTCH drop/ADD if CTCH is not
                    supported in the cell
06/12/09   ps       Add the the missing code in r6 and R7 path to support SSC 
                    on HS
06/10/09   ps       Made changes to set MIMO action as Reconfig even 
                    if only HSDSCH changes
05/26/09   rm       Fixed compilation error
05/25/09   ps       Made changes for EDPCH interpolation support
05/25/09   ps       Made changes to correct the file formatting
05/21/09   ps       Made changes to not start BMC if BPLMN is ongoing
05/18/09  gkg       Fixed compile warnings by moving the def of functios
                    rrcllcpcie_update_uldpch_mode_specific_info() and 
                    rrcllcpcie_dl_common_mode_specific_info() under Release6.
                    Also moved prach processing related functions.
05/11/09   ps       Feature to dynamically allocate OC, CC and TOC ptr
05/06/09   gkg      Made changes for ZI memory optimization for global prach_sel_info.
                    If feature FEATURE MODEM HEAP is defined and FEATURE_WCDMA_ZI_OPT_DISABLED
                    is not defined, then global prach_sel_info is initialized using modem heap,
                    otherwise it's initialized statically.
05/08/09   ss       Updated Copyright Information
05/04/09   ps       Made changes to update the TFRI table status for Non-R7 OTA 
                    also
04/29/09   ss       Made changes to compiler warnings on gcc compilers.
04/20/09   ps       Made changes to ignore the rgch info when hich info is
                    not provided. Do not reject this ota.
04/13/09   ps       Made changes to reject an OTA, if MAC-HS reset Ind is 
                    not included for MAC-EHS<-> MAC HS transition
03/31/09   ps       Removed the break statement if SCCH code matches
03/31/09   ps       Made changes to even check if the order of 
                    HS-SCCH codes are changed
03/16/09   ps       corrected incorrect checks for dpdchPresence bitmasks
03/18/09   av       Made changes to check invalid RGCH removal 
03/12/09   ps       Solved compiler warning  by including rrcrce.h
03/12/09   ps       Made changes under FEATURE_WCDMA_RRC_APPLY_WEIGHT_FOR_ASC0_PVAL
                    to apply weight for calculation of persistance value for ASCO 
03/11/09   ps       Made changes to select ASC 0 for RACH for  emergency calls
02/12/09   gkg      Made changes towards optimizing PRACH working DB. 
                    Basically the data type of PRACH working DB is changed from 
                    ordered_config_type to prach_config_type.
02/10/09   gkg      Made changes such that RRC doesn't go in infinite loop while
                    processing multiple PRACH sets from SIB5 and at least one
                    of the PRACH set is invalid.
01/27/09   ps       Made changes to set the HS-DPCCH bitmask for MIMO 
                    Start/Stop/Reconfig bitmask
01/20/09   ps       Made changes to reject an ASU if Disjoint ASET is received.
01/19/09   ps       Made changes for ASn1 migration 25.331v7.9  
                    i.e.May 2008 version  (2008-05) 
12/18/08   ps       Made changes to send an add and drop for DPCH , if the tau DPCH
                    changes by 1 under FEATURE WCDMA REL7 HACK CHG TAU DPCH
12/05/08   ps       Made changes to set HSDSCH bitmask if there is a change
                    in 64QAM status
11/25/08   ps       Made changes to reject OTA if N\W configures 64 QAM, but
                    NV indicates that 64 QAm is not supported by UE.
                    Also changes to set the MIMO bitmask CPHY_HS_MIMO_CFG_INCL
                    even if MIMO action is stop.
                    Also made changes to set HS action as RECONFIG, if MIMO 
                    is stopped but HS is continued, and set CPHY_HS_DSCH_CFG_INCL
                    also in this case.
11/06/08   ps       Added check to reject OTA if 64QAM is configured with 
                    MAC-HS
10/16/08   ps       Fixed merge issue for R7 coding. Need to check for 
                    UE_MAX_RL if RL is not present in the list for R6 path
10/10/08   ps       Removal of feature FEATURE_GTOW_HO_TO_UTRAN_SPOOF_ENABLE
                    As the Spoof  is no longer required for Anritsu
09/25/08   ps       Added code to indicate that secondary cpich info is not
                    present, if the the Secondar CPICH IE is not present for an
                    existing RL in R5/R6/R7 code path
09/12/08   ps       Added code for REl7 under FEATURE_WCDMA_REL7
07/25/08   ps       Do not send failure if HICH Rel indicator is recieved for
                    an RL not present in EDCH Active set
07/14/08   gkg      Corrected get_rl_remove_info() for Cell_Id changes.
                    When a RL is removed through ASU, the cell_id_per_rl list
                    is shifted so that RL list and Cell Id list are in sync.
07/03/08   ps       Corrected get_e_rl_index_for_a_given_psc() to use config_ptr
                    insted of OC ptr to get no. of RLs
06/27/08   ps       Added code to sort the Reference E-TFCI in ascending order
                    before sending it to L1
06/23/08   ps       Added changes for FEATURE_HSDPA_PERFORMANCE_OPTIMIZATION 
                    which was missing in R6 path
06/16/08   ps       Corrected featurisation issues for FEATURE HSDPA
06/13/08   gkg      Added code for notification of Cell_Id change through OTAs
                    in Cell_DCH state. 
06/02/08   ps       Made changes to not send a FAILURE to N\W, if HICH info is not
                    present for Serving RL, just STOP EUL in this case
05/14/08   ps       Made changes to reject an OTA if timing Initialised is
                    mentioned without HHO in case of FDPCH
05/07/08   ps       Made changes to reject an OTA message if the no. of RL
                    in EDCh Active set exceeds 4.
04/25/08   ps       Made changes to pass num_trch and num_tfci as 0 to L1
                    when num_dpdch in UL is 0
04/18/08   gkg      Fixed Klockwork errors.
03/19/08   da       Added support to reconfig RGCH if OVSF code for HICH has changed, 
                    then RGCH needs to be reconfigured also as RGCH uses  same OVSF 
                    code as HIGH.
03/06/08   da       Changed FEATURE_MBMS to FEATURE_MODEM_MBMS
03/06/07   da       Corrected DOFF validation check in R6 path.
02/22/07   ps       Made changes to set default value of "NO_GRANT" timer
                    as 100 ms for 2 ms TTI
21/02/08   gkg      Fixed array index out-of-bound warnings reported by Klocwork.
02/04/08   kp       Added support to set all E-DCH active set DL RL's bit mask
                    to reconfig when TTI reconfiguration happens as L1 needs to reconfigure
                    all DL RL's in E-DCH active set.
02/04/08   kp       Added support to ignore HICH Rel Ind & RGCH Rel Ind from OTA 
                    message, If the received message performs HHO. Since in case 
                    of HHO, All active Rl's are moved to Release list    .
01/25/08   kp       Added support for spec cr-2725, which added SF128 & SF256 
                    to E-DPDCH MaxChannelisationCodes.
01/24/08   kp       Made correction to check correct bit mask for numberOfFBI bits
                    in function get_ul_dpch_info_r6() in leg for dpdchPresence 
                    choice is notPresent.
01/11/08   ps       Made correction to call functions which use RACH Trch idx,
                    only when the RACH Trch idx is valid.
12/28/07   ps       Added support for timingMaintainedSynchInd IE received 
                    REL6 OTA messages for FDPCH
12/21/07   da       Support for FEATURE_MBMS
12/03/07   ps       Made changes to support Additional Transport format for CCCH
                    received in SIB5/SIB6.Changes are made under feature 
                    flag FEATURE_CCCH_IE_ENH.
11/07/07   vk       Added code to set the default DPCH Offset value based on
                    F-DPCH Frame Offset. Also added conditions to ensure their
                    relationship as defined by specs is respected. Changes have been
                    featurized under FEATURE_WCDMA_FDPCH
10/30/07   ps       Added support for Dc 14. Also added support to extract 
                    SRB5 contents received in Rel6 Handover to utran message.
09/24/07   da       Made change not reject entire cfg when RGCH and\or AGCH info
                    is provided without HICH.  UE should ignore the AGCH\RGCH info but 
                    apply the rest of the configuration.
09/14/07   vm       Modified a msg high.
09/10/07   ps       Added support for Frequency redirection received in 
                    FACH->FACH and FACH->PCH cases under feature flag
                    FEATURE_RRC_FREQ_REDIRECTION_THRU_RB_AND_CU
08/24/07   vk       Set HARQ Information in Ordered Config in function 
                    rrcllc_process_serving_hsdsch_cell_info()
                    when network specifies R6 ASU Repointing Message under
                                        FEATURE_HSDPA_ASU_REPOINTING
07/13/07   da       Added support for HSPA call status indication.
05/23/07   ps       Moved the changes for default config through RB-setup msg under
                    feature flag FEATURE_DEFAULT_CONFIG_IN_RB_SETUP.
05/22/07   sm       Added function rrcllcpcie_validate_hich_rgch_info() under 
                    FEATURE WCDMA HSUPA
04/20/07   da       Made changes needed to update ASN.1 version to R6 sept R6 2006
04/10/07   ps       Added support for default configs sent through Rb-Setup msg
04/03/07   da       Fix for SYNC-A + EUL.  RRC needs to drop and add EUL channels
                    as well as set the e-dl masks to ADD.
                    Also added check to reject message if TPC idx for HICH is not
                    found in R99 RL as this means that NW is adding a RL that 
                    is not present in R99 ASET to E-DCH ASET 
03/08/07   da       Lint warning fix.
02/28/07   sgk      Added FDPCH support under FEATURE_WCDMA_FDPCH. 
02/28/07   sgk      Added support for HSDPA ASU repointing with function 
                    rrcllc_process_serving_hsdsch_cell_info under 
                    FEATURE_HSDPA_ASU_REPOINTING. 
02/26/07   sm       Added code to reject EUL+CM configuration for early R6 UEs
02/05/07   da       Fix for NULL pointer derefences reported by Klocwork. 
01/29/07   ps       Added changes to ignore timingMaintainedSynchInd IE when 
                    Frequency info IE is not present or in Timing Initialised case
01/22/07   da       Calling fn rrcllc_init_rach_info before processing 
                    RACH info in fn get_prach_sys_info.
01/08/07   vk       Used the variable hsdpa_cm_enabled to check if network
                    is trying to activate HSDPA + CM in fn 
                    rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params. 
                    Code under feature FEATURE_RRC_ENABLE_CM_HSDPA has been
                    removed
12/22/06   sm       Set Mandatory defaults as per spec for EUL IEs
12/22/06   ps       Made changes to handle postVerificationPeriod and the
                           timingMaintainedSynchInd IE received in OTA messages
12/21/06   sm       Fixed 7200 compiler warning
12/21/06   sm       Fixed 7200 lint error
12/18/06   sm       Made changes to set default value of NO_GRANT timer to 500
                    if its omitted in the received reconfig message. Also, added
                    function rrcllcpcie_validate_hich_rgch_info().
12/18/06   da       Made change to reset seving_rl_idx to L1_MAX_EDCH_RL when 
                    servingEDCH_RL_indicator for the current serving EDCH RL is set to FALSE.
11/16/06   vm       Added MCCs 442 and 443 to Japan MCCs and defined two new constants 
                    JAPAN_MCC3 and JAPAN_MCC4.
11/15/06   sm       Added EUL HHO and reverting back to old config support.
                    Also added support to ignore the IE serving greant/selector 
                    if E-RNTI is not configured.
10/31/06   vm       Added fix for CR 105216. The var "i" was not initialized
                    to 0 due to which freq validity check was failing for AWS 
                    band additional channels. The fix is to initialize var
                    "i" to 0.
10/27/06   vk       Fixed a LINT indentation error
10/23/06   vk       In fn get_ul_dpch_pwr_ctrl_info_r5(), use the OC value
                    of ack/nack repitition factor to compare if the value has
                    changed
10/17/06   sgk      Fixed lint errors. 
09/15/06   vm       Added support for the feature FEATURE_UI_RF_ENABLED_BANDS_SUPPORT.
09/12/06   sm/da    Fix code review comments and general clean-up for REL6 and HSUPA
08/29/06   sm/da    Made changes required for R6 ASN.1 migration.  Also merged
                    FEATURE_WCDMA_REL6 and FEATURE WCDMA HSUPA.
08/02/06    tkk     Added PRACH code to optimize global memory usage.
07/25/06    da      Fixed Compilation Error.
07/13/06    da      Added function rrcllcpcie_is_hho and rrcllcpcie_is_hho_r5 to set 
                    ordered_config_ptr->is_hho flag when OTA msg is rcvd.  First 
                    time into DCH or DCH->DCH with disjoint set is considered HHO.
                    removed change made a while back to allow Tdpch difference > 1 when 
                    CFN handling is indicated as timing init in reconfig msgs.  Tdpch greater
                    than 1 is only allowed for HHO scenarios.
06/08/06    vm      Added support for new feature FEATURE_MCC_AND_850_800_BAND_COMBINATION.
                    1. Included header file rrccspi.h
                    2. Added definition of the new function 
                       is_freq_in_overlapping_850_and_800_bands().
                    3. The function rrc_get_frequency_band() now takes plmn_id as a second
                       argument and returns the band based on UARFCN and PLMN_ID combination.
                    4. Added definition of new function 
                       rrccsp_is_mcc_and_supported_band_comb_valid() 
                    5. Added another definition of the function validate_dl_arfcn() under the
                       feature flag, that takes plmn_id as a second argument and returns the
                       band based on the UARFCN and plmn_id combination.
                    6. Updated the function validate_fdd_frequency() to return the band to which a 
                       particular UARFCN belongs to, if the UARFCN is in the overlapping region of 850 
                       and 800 bands, based on the MCC.
06/06/06    vk      If HS-SCCH Info does not provide any Secondary Scrambling Code
                    for HSDPA Repointing and the old configuration indicated
                    secondary scrmabling code to be used with HSDPA, then indicate
                    to L1 that HS-SCCH information has changed
06/05/06   sgk      Made changes to include rel5 non HSDPA functionality under 
                    FEATURE REL5 while retaining the HSDPA specifc processing 
                    under FEATURE HSDPA.
05/18/06    vk      Added support for handling HSDPA with Secondary Scrambling Code
05/01/06    vk      Implemented new functions rrcllc_check_if_hsscch_changed()
                    and rrcllc_check_if_meas_feedback_changed. These functions help
                    in determining if L1 needs to be reconfigured for HSDPA
                    for beta table, measurement feedback info and scch information
                    change. Changes have been featurized under 
                    FEATURE_HSDPA_PERFORMANCE_OPTIMZATION
04/25/05    da      Removed function rrcllc_new_sccpch_selection_required as
                    it's not used anymore.
04/20/06    vk      Changed the type of global variable hsdpa_cm_enabled from
                    boolean to uint8
04/18/06    vk      Used global variable hsdpa_cm_enabled to determine if
                    HSDPA+CM activation needs to be rejected while processing
                    compressed mode patterns specified in Reconfiguration Message
04/18/06    da      Modified code to support migration to Mar-06 Rel-5 ASN1 +
                    R6 Hacks
04/13/06    vk      Initialized global variable cm_status_from_ota_msg to CM_NONE
                    by default. In fn set_compressed_mode_info(), added more logic
                    to determine if network is trying to activate/deactivate
                    CM in the new configuration and accordingly set the value
                    in global variable cm_status_from_ota_msg
04/07/06    da      Backed out changes made to treat timing_init and no freq info
                    as HHO.  Need more discussion as ciphering issues could result.
03/28/06    vk      Added implementation of fn rrcllc_is_cm_active(). Also removed
                    code under FEATURE_RRC_ENABLE_CM_HSDPA as it is no longer
                    required
03/22/06    da      Added change to include freq info and set dest_freq_present flag
                    to true when cfn handling is timing init and freq info is
                    not present
03/14/06    tkk     Lint warnings/errors cleanup
03/07/06   tkk/sk   Fixed a bug to correct calculation of paging occasion 
                    calculation in "get_sccpch_index" function for Cell_PCH state.
02/28/06  da/sm     Modified code to support migration to Dec-05 Rel-6 ASN1
02/21/06    vm      Added support for 1700_2100 AWS Band (IV) under feature name
                    FEATURE_WCDMA_BC4.
02/17/06    vm      Added support for 1700 band under feature name FEATURE_WCDMA_BC9.
01/25/06    bd      Lint clean-up
12/18/05    da      Added function rrcllc_new_sccpch_selection_required().  This 
                    func determines whether fresh SCCPCH selection is required
                    or not. Also storing current sccpch index in var curr_sccpch_index.
                    Bug fixes in get_sccpch_index()
11/28/05    bu      Added initial support for 900 MHz band under FEATURE_WCDMA_900.
11/10/05    da      Removed extern definition of nv_rel_ind; 
11/10/05    da      Checking global flag rrc_nv_rel_indicator before doing R5 related
                    processing.
11/03/05    vk      Added initialization of HSDPA scrambling code in fn 
                    rrcllc_init_hspdsch_info()
10/27/05    da      Made change to not block transition to DCH with SHO in REL5 part
                    of code.
09/26/05    ss      added the functions get_mac_d_hfn and 
                    mac_d_hfn_cucnf
09/26/05    da      Fixed featurization issues in Rel 5 for support of 
                    inter-freq HHO into SHO
09/21/05    da      Corrected check that was made when getting tx_div info from dl
                    common info for all rl in R5 code.  Check should see if  
                    rrc_modeSpecificInfo_fdd_tx_DiversityMode_1_present
                    is set in bitmask.
09/16/05    bu      Changed one of the 850 band additional channel number from 1035 to
                    1032. This based on the latest 25.101 specifications.
09/14/05    da      Corrected check that was made when getting tx_div info from dl
                    common info for all rl in R5 code.  Check should see if  
                    rrc_modeSpecificInfo_fdd_tx_DiversityMode_1_present
                    is set in bitmask.
08/25/05    vk      If network makes existing HSDPA link inactive, configure lower
                    layers to stop HSDPA
08/25/05   vk       Featurized the code for rejecting CM Activation when HSDPA is already 
                    active under FEATURE_RRC_ENABLE_CM_HSDPA
08/12/05    vk      If reconfiguration message tries to activate CM and
                    HSDPA is already ACTIVE, then reject the configuration
08/10/05    vk      Set hsdpa_msg_params.hs_dpcch_info_present to TRUE if only
                    Delta ACK/NACK or Repitition Factor changes. Also if R99
                    message tries a Intra Freq/Inter Freq Hard Handover, then
                    stop HSDPA
07/29/05    vk      If DL DPCH Info per RL is absent for the first link, but is
                    present for the second link then act upon the information
                    that is specified in the second link
07/25/05    vk      Added the check to see if "Default DPCH Offset Value" and
                    "DPCH frame offset" relationship is respected on entry to
                    DCH state as well as on Timing Reinitialized Hard Handover
07/12/05    vk      In fn get_dl_info_per_rl_r5(), if network specifies tdd, then
                    ignore the element. Also, Moved the check for HSDPA radio link
                    count greater than 1 inside the fdd loop.
06/17/05    kc      Changed from rrc_pich_Info_present to rrc_SCCPCH_SystemInformation_pich_Info_present
                    for ASN1 R5 support
06/14/05    kc      Added implementation to check and see if the received PRACH/SCCPCH info 
                    has atleast one AICH/PICH info respectively
06/08/05    da      Changed from rrc_pich_Info_present to rrc_SCCPCH_SystemInformation_pich_Info_present
                    for ASN1 R5 support
05/12/05    da      Added change to allow Tdpch difference > 1 when CFN handling is 
                    indicated as timing init in reconfig msgs
                    Passing down tti info for ctch-fach to L1 for BMC sleep opt.
06/05/05    vk      In Function set_hsscch_info(), if network indicates Secondary
                    Scrambling Code to be used, then reject that configuration
                    as L1 does not support it
05/05/05    svk     Added some MSG_LOW to get_prach_partitioning.
05/03/05    vk      Use the correct bit mask for setting PSC in Ordered Config DB while
                    processing the downlink information per radio link for Release 5
04/29/05    da      Added support to read TFCS and fach_PCH_informationList from previous
                    sccpch if these IEs are ommitted from current sccpch in use.
04/27/05    bu      Defaulted the return status to FAILURE in validate_dl_arfcn() and
                    validate_fdd_frequency().
04/22/05    vk      Reject the configuration if network tries to activate CM
                    when HSDPA is Active. Defined fn rrcllc_init_hspdsch_info()
                    to initialize HSPDSCH Info
04/15/05    da      commented out code where flag check_hho_cfn_handling was being
                    set to true in func get_dl_info_per_rl.  This is not needed and
                    was causing a doff validation error during the next OTA reconfig msg.
04/14/05    bu      Added changes for Hard handover search optimizations. Changes are
                    under FEATURE OPTIMIZE SEARCH FOR HHO.
04/06/05    da      Added Initial support for BMC.  Handling of CTCH  and
                    a second SCCPCH in IDLE, CELL_PCH and URA_PCH states
                    are now supported.  CTCH is not present in CONNECTING, CELL_FACH
                    and CELL_DCH states.
03/22/05    da      Added a check to validate DOFF and DPCH frame offset value
                    according to 8.6.6.14 of 25.331.  This is only applied for when
                    first entering DCH or timing initialized HHO
03/11/05    vk      Merged HSDPA code in Mainline from RRC_MSM6275 branch under FEATURE HSDPA
03/03/05    vn      Compiled out Doff- Tdpch check.
03/02/05    ttl     Support RRC ASN1 Release 5.
02/02/05    da      Added a fix to compare (DPCH frame offset * 256) when validating
                    the relation between DOFF and DPCH frame offset.
01/31/05    da      Added a check to validate DOFF and DPCH frame offset value
                    according to 8.6.6.14 of 25.331
01/14/05    sk      set bitmask properly if secondary cpich info is not present
                    in the message.
12/22/04    svk     Fixed lint errors.
12/21/04   vm/da    Fixed lint error.
12/15/04    bu      Set the band mask appropriately for additional channels in
                    rrc_get_frequency_band().
12/2/04    svk      Copied the parameters for contant value and cpich tc power from that
                    particular prach.
12/22/04    svk     Added support for multiple PRACH's and PRACH selection in the
                    system information message.
10/20/04    vk      Set CM patterns to 0 for FACH->DCH transition specified
                    by reconfig message if no. of existing patterns in TOC is 0
                    and network specifies a pattern to be deactivated
                    without specifying the pattern parameters
10/05/04    bu      Defined validate_dl_arfcn().
10/01/04    sk      While processing dl_dpch_info_per_rl if secondary scrambling code
                    is not present then modify bitmask in oc accordingly. So when
                    cmd is sent to configure l1 it will read this bitmask and stops using
                    secondary scr if that was present before.
09/16/04    vk      For the purpose of returning the first available index,
                    check with tgp_seq_info_count from ordered config instead
                    of the Max TGPSI count
09/02/04    jh      Allow TauDPCH change to wrap around from max to min
                    or min to max.
09/01/04    bu      Added support for WCDMA 1800 band.
08/31/04    bu      Added rrc_get_frequency_band() that returns the appropriate
                    frequency band based on the frequency. Changes to use
                    band_class_type instead of band_class_e_type.
08/27/04    jh      Added check to reject timing-initialized HHOs that do
                    not include Doff.
08/26/04    jh      Updated to use new L1 tx_div_ind interface.
08/25/04    bu      Added validate_fdd_frequency() that validates the
                    rrc_fddFrequency IE. Update validate_frequency_info() to use
                    validate_fdd_frequency().
08/13/04    bu      Updated rrc_validate_frequency_info() for WCDMA multiband
                    support. Added valid frequency band ranges and additional
                    channels for 800 and 850 MHz bands.
08/03/04    vn      Fix to check for FACH->DCH Intra freq HHO only when it is
                    not a case of Inter freq HHO.
08/02/04    vn      Ensure freq info is passed to L1 on a FACH->DCH transition
                    to a non-serving cell.
07/21/04    vn      Changes to fix Intra frequency HHOs, FACH to DCH HHOs
                    and handling of the special case when CPICH Info is
                    present in DL Info per RL but DPCH Info per RL is
                    not present. Re-organized code in get_dl_info_per_rl()
                    to match with logic.
07/15/04    jh      Added new functions validate_frequency_info(),
                    get_frequency_info(), and get_dl_per_rl_info() as part
                    of hard handover cleanup.
07/09/04    jh      ASN.1 field name changes.
06/16/04    jh      Modifications to reject TauDPCH difference > 1 outright.
06/01/04    jh      Fixed error in TauDPCH difference detection on initial
                    radio link setup.
05/25/04    jh      Force a drop and add if the TauDPCH difference is greater
                    than one by sending frequency info to L1.  Pass Closed
                    Loop Timing Adjust parameter if diversity is turned on
                    at all, regardless of mode.
05/06/04    jh      Changes to force timing initialized hard handover when
                    a state change is involved.
02/27/04    jh/sk   Merged fixes from Sanjay: Corrected SCCPCH selection
                    algorithm for PCH states.
02/26/03    vk      If a TGPSI is indicated to be modfied, then reinitialize the
                    TGPSI change variable to FALSE so that next time a new
                    TGPSI could be incremented
02/14/04    sk      Added a check for possible divisible by zero error.
02/06/04    jh      Augmented get_sccpch_index() to work for CELL_PCH and
                    URA_PCH states, using the PCH count instead of the FACH
                    count to calculate the index.
12/17/03    vn      If CloseLoopTimingAdjMode is present when Tx Diversity is
                    not activated or is STTD, indicate the absence of
                    CloseLoopTimingAdjMode to L1.
12/11/03    jh      Added validation of closedLoopTimingAdjMode in
                    dl-DPCH-InfoPerRL so that bad values never get to L1, where
                    they would cause the call to drop.
11/06/03    vk      Removed the check to ignore FDD patterns as they are now supported
                    These comments were missing in the previous chekin
09/11/03    jh      Added code to reject Secondary CPICH Info
08/04/03    jh      Added QXDM messages for ASU failure cases.
07/15/03    jh      Changes to allow resetting L1 optional parameter masks
                    only on new radio link additions. Added function
                    get_dl_rl_idx_to_update() to search for an existing radio
                    link to update with DL Information per RL info.
07/24/03    vk      Removed unused variable tgpsi_count in
                    set_compressed_mode_info(..). Fixed other lint errors
06/04/03    vn      Added checks in get_sccpch_index to prevent a div by 0
                    if number of SCCPCHs with FACH/PCH is 0. Added a new fn
                    verify_sccpch_exists to verify if an SCCPCH with correct
                    type of TrCH exists for a given RRC state and SCCPCH Info.
05/29/03    vk      Put code under FEATURE_CM_BY_HLS while checking compressed
                    mode method type
04/29/03    vn      Made functions generic to populate the config database, a
                    pointer to which is passed as a parameter. Functions that
                    deal only with DPCH still are hard-coded for Ordered Config.
04/11/03    sk      Return unsupported configuration if CM method is other than
                    sf/2
04/11/03    vn      Set PO3 power offset between DPDCH and DPCCH in downlink.
02/05/03    sk      March2002Rel specific changes
                    Modification in SecondaryCCPCHInfo IE
                    Change rrc_DL_DPCH_InfoPerRL_fdd__secondaryCPICH_Info_present
                    to rrc_secondaryCPICH_Info_present
02/05/03    vn      Merged in changes dropped during linting.
01/08/03    vn      If Doff is not signalled when moving from any other state
                    to Cell_DCH state, treat it as an error and return a Failure.
01/17/03    jh      Changed get_rl_add_info() to first search through current
                    radio links and immediately return SUCCESS if it finds that
                    the radio link to be added is already there.
01/07/02    vk      Ignore gap pattern for tgmp=fdd till it is implemented to make
                    sure that L1 does not get the fdd gap pattern
01/03/02    vn      Set "use_pich" to FALSE to indicate to L1 not to allocate
                    HW channel for PICH for any state other than Disconnected,
                    Cell_PCH or URA_PCH.
12/20/02    vk      Removed the incorerct initialisation of tgp_seq_info from
                    function set_compressed_mode_info(..)
11/22/02    jh      Augmented get_rl_add_info() to report duplicate RL adds.
11/21/02    xfg     Changes from Dave to resolve multiple call CM activation issue
11/15/02    jh      Changed get_prach_partitioning() to copy the data from the
                    last received PRACH Partitioning IE into the remainder of
                    the ASC positions is fewer than the maximum number of ASCs
                    are specified.
11/07/02    jh      Fixed array out-of-bounds condition in get_prach_sys_info()
08/21/02    vk      Implemented function set_tgpsi_location(..) that sets the
                    variable action_needed to indicate to L1 if the TGPSI given
                    has to be added or modified. Also added more check in
                    set_compressed_mode_info(...) fn. Changes have been put under
                    FEATURE CM SUPPORTED
08/20/02    jh      Corrected persistence value calculation to include a scaling
                    factor of 1 for ASC 1.  Added processing on persistence
                    value to map it into a uint16.
08/01/02    vn      Process the Downlink Info per Radio Link only if that
                    contains DL DPCH Info per RL. Otherwise ignore the RL Info.
07/31/02    vk      Defined set_compressed_mode_info(..) & find_tgpsi_index(..) to
                    process compressed mode parameters. Also declared compressed
                    mode constants. Changes have been put under FEATURE CM SUPPORTED.
06/21/02    jh      Changed get_rl_add_info() to harmlessly ignore dupilcate
                    radio links.
06/20/02    jh      Corrected two typos in select_asc_from_ac(). The function
                    now works as advertised.
05/16/02    jh      Added calculation of Persistence Values from information
                    contained in SIB 7 and SIB 5/6.
05/03/02    vn      Reconfigure DL MAC whenever DL L1 is reconfigured.
04/23/02    vn      Changed get_max_allow_ul_tx_pwr to not read Max UL Power
                    from SIB3 when not present in message. Update
                    reconfig_needed indicators for UL and DL L1 when processing
                    corresponding Phychan IEs.
04/22/02    vn      Removed rrcllc_semi_permanent_data from ordered_config_type
04/18/02    jh      Fixed CR#19683 - The function get_prach_partitioning was
                    misbehaving if ASC setting entries were not present in the
                    PRACH partitioning IE.  Previously, the full range of
                    signatures was being reported to L1 as available instead of
                    reporting only the signatures marked as available in the
                    Available Signature mask.  See 10.3.6.53 for a discussion
                    of the default value for ASC Setting and 8.6.6.29 for a
                    discussion of how to derive start and end indices from the
                    Available Signature mask.
03/04/02    vn      Added Cell_FACH support and Cleanup/Restructuring.
                    In get_prach_sys_info, allocate TrCH index by passing
                    RACH ID in get_ul_rach_trch_idx. In general, no need to
                    update counts and CCTrCH type explicitly as that is
                    automatically done by get_xxx_trch_idx functions. Call
                    RRCLLC_UPLINK_TRCH_COUNT to get total number of UL TrCHs.
                    Changes due to moving of local structures to ordered_config
                    No need to pass num_of_sccpch to get_sccpch_index. In
                    get_sccpch_sys_info, get_dl_tfcs_info is called before
                    calling get_sccpch_info to ensure correct updating of
                    "tfci_exists". Calls to RRCLLC_DOWNLINK_TRCH_COUNT.
                    Invalidate RM Restriction info before calling update_
                    rm_restriction_info as that doesn't apply to SCCPCH.
                    In get_sccpch_index, do not care which SIB is being used.
                    Use URNTI in OC to calculate SCCPCH index. Return invalid
                    SCCPCH index in place of calling ERR_FATAL. In get_sccpch_
                    info, if any one of optional parameters not present, update
                    bitmask. New function set_dl_rm_restriction_info_to_invalid
                    to invalidate DL RM Restriction info. Changed MSG_ERRORs to
                    ERRs and counters to types having deterministic # bits.
12/12/01    vn      IMSI is converted to a 64 bit integer for calculating
                    imsi_div_pch_cnt.
12/07/01    rj      Removed feature FEATURE_DRX_CHANGES since it is no
                    longer required. Modified code to update PCP length and
                    added code to update SRB_Delay and Paging Occasion for
                    June Specification.
12/04/01    kc      Changes for June Spec conversion.  Mostly ASN1 changes
11/13/01    vn      Uncommented out fix for supplying 0 FBI bits if FBI bits
                    are not included in the IE.
11/10/01    vn      Compare TPC step size against valid values of 0 and 1.
11/07/01    vn      Handle the following Mandatory default IEs correctly:
                    For PRACH: TFS, TFCS, Prach Partitioning, Persistence
                    scaling factor, AC to ASC mapping. CPICH power, constant
                    value, power offset, RACH Xmit parameters, AICH Info.
                    For SCCPCH: DL TFCS, PCH-FACH Info.
                    In get_ul_dpch_pwr_ctrl_info, correctly compare chosen
                    algorithm to ASN1 defined values. In get_ul_dpch_info set
                    number of DPDCH to the default value. In
                    get_persist_scaling_factors supply default values if absent.
                    for 1st PRACH. Set CCCH ASC for use in MAC during initial
                    access. Multiply Doff received in ASN1 with multiplication
                    factor before sending it to L1. In get_prach_partitioning,
                    if PRACH data is absent for ASC0, assign default values.
                    For other ASCs, copy data from previous ASC.
11/03/01    vn      Added check for min and max values of transport channel ID.
11/01/01    vn      Corrected logic in get_prach_sys_info to ignore Persistence
                    Scaling factors data if number of Access service classes
                    is 2 or less.
10/29/01    vn      Commented out imsi_div_pch_cnt in PICH parameters till new
                    L1 DRX changes are brought in. Used FEATURE_DRX_CHANGE.
10/11/01    xfg     Fixed a bug in get_rl_remove_info, using direct assignment
                    instead of memory copy.
09/25/01    kmp     Removed get_pich_pwr_offset() and get_drx_cycle().
                    Updated get_sccpch_index() to temporarily set the
                    imsi_div_pch_cnt.
09/18/01    kmp     Comment out the the setting of the FBI bits if not
                    included in the message in get_ul_dpch_info().
09/13/01    xg/kmp  Updated get_rl_remove_info() to remove RL by CPICH instead
                    of by index. Also added support to compress the array gaps
                    created by these removals. In get_ul_dpch_info() correctly
                    featurized the FBI bits around SSDT.
07/17/01    kmp     Updated to support multiple SCCPCHs, with any combination
                    of PCH and FACH in get_sccpch_sys_info() and
                    get_sccpch_index(). Added get_rl_remove_info() and
                    get_rl_add_info(). Changed all occurences of L1_MAX_RL to
                    UE_MAX_RL. Changed all occurences of MAX_DPCH to
                    UE_MAX_DPCH.
06/28/01    kmp     Fix a stupid error in get_ul_dpch_info().
06/28/01    kmp     Updated get_dl_dpch_info_for_each_rl() and
                    get_dl_info_common_for_all_rl() to initialize one more
                    optional parameter mask. In get_dl_dpch_common_info()
                    fixed a bug to correctly update the DL CTFC data
                    structures TFCI existence field. In get_prach_rach_info()
                    fixed compiler warnings.
06/26/01    kmp     Updated get_sccpch_sys_info() to handle more than one FACH
                    on an SCCPCH.
06/20/01    kmp     Updated get_prach_rach_info() and get_prach_partitioning()
                    to fix more bugs in processing the bit strings.
06/19/01    kmp     Updated get_prach_rach_info() to fix bugs in processing
                    the bit strings.
06/13/01    kmp     Updated to make ul_trch_cnt and dl_trch_cnt part of
                    the ordered_config_data structure. Fixed bugs in
                    get_sccpch_sys_info(), get_sccpch_info(),
                    get_dl_dpch_common_info(), get_dl_dpch_info_for_each_rl().
                    Init optional parameter bit masks in get_sccpch_info(),
                    get_dl_dpch_common_info(), get_dl_dpch_info_for_each_rl().
06/07/01    kmp     Fixed Arm compiler warnings in get_ac_to_asc_mapping(),
                    get_rach_xmit_parms(), get_aich_info(), get_ul_dpch_info().
06/06/01    kmp     Added debug information. Fixed a bug while reading PICH info
                    in get_sccpch_sys_info().
06/05/01    kmp     Fixed a bug in get_prach_partitioning() when initializing
                    the assigned subchannel number. In get_dl_dpch_common_info()
                    fixed a bug to correctly check for FDD mode instead of DPCH
                    present. In get_ul_dpch_info() corrected range checking for
                    the number of DPDCHes. In get_ul_dpch_pwr_ctrl_info fixed a
                    bug by not doubling the rcv'd value.
05/24/01    kmp     In get_prach_partitioning() updated to use the new L1 I/F
                    for Access Service Class Information. In get_aich_info()
                    moved the AICH parameters from the UL to the downlink
                    channel structures inb L1.
05/24/01    vn      Replaced pcch.fach_included with a call to
                    rrcllc_set_fach_included().
05/18/01    kmp     Updated get_prach_sys_info() to indicate that RACH is now
                    the CCTrCH Type, and to calcuate the TFCS after setting the
                    number of TrCH's taht are active in MAC. Fill in TrCH
                    reference type for DL TrCHs in get_sccpch_sys_info().
05/17/01    kmp     Modified get_sccpch_sys_info() to correctly get FACH info.
                    Fixed another bug which incorrectly overwrote PCH data
                    with FACH data in the DL CCTrCH database. In
                    get_prach_sys_info() update to count the number of TrCH
                    per physical channel, and the active UL channel is a PRACH.
                    In get_prach_sys_info() indicate that the AICH and PRACH
                    configurations are valid.
05/16/01    kmp     Made the following changes: added #include rrcscrmgr.h,
                    added a MSG_MED indicating reading PRACH Sys Info,
                    modified get_prach_rach-info() and get_ul_dpch_info()
                    to correct boundary conditions for Puncturing Limit,
                    in get_sccpch_sys_info() updated the DL TrCH count in L1
                    data structure, as well as saving the TrCH ID for PCH and
                    FACH, fixed a typo in update_rm_restriction_info(), and
                    fixed numerous compiler warnings.
05/15/01    jrs     Changed the return type of get_sccpch_index() to int.
                    Renamed pri_scr_code to pri_cpich_scr_code to match an L1
                    interface change.
05/09/01    kmp     Added support for Maximum Allowed Uplink Tx Power, and
                    counting of Transport Channels. Added downlink Rate
                    matching code. Added support for DL TFS and TFCS info.
04/13/01    kmp     Merged in all of the Phychan changes. Still need the
                    Transport Channel ones.
03/02/01    kmp     Initial release, just as a holding in case something
                    happened while on vacation.
===========================================================================*/


/*===========================================================================
                           INCLUDE FILES
===========================================================================*/
#include "wcdma_variation.h"
#include "comdef.h"
#include "err.h"
#include "l1dlcctrchcfg.h"
#include "l1dlphychancfg.h"
#include "l1sapcommon.h"
#include "l1rrcif.h"
#include "l1task_v.h"
#include "l1ulcfg.h"
#include "l1mathutil.h"
#include "macrrcif_v.h"
#include "msg.h"
#include "rlcrrcif_v.h"
#include "rrcasn1.h"
#include "rrcdata_v.h"
#include "rrcllc.h"
#include "rrcllcoc.h"
#include "rrcsibdb.h"
#include "rrcscmgr.h"
#include "rrcccm.h"
#include "uecomdef.h"
#include "rrccsp.h"
#include "rrccspi.h"
#include "rrcsmc.h"
#include "rrcrbcommon.h"
#include "rrcrce.h"
#include "ran.h"

#include "rrcnv.h"
#include "secapi.h"
#ifdef FEATURE_WCDMA_DB_DC_HSDPA
#include "rfm.h"
#endif
/*===================================================================
                        DATA DECLARATIONS
=====================================================================*/

/*===================================================================
                        CONSTANTS
=====================================================================*/

#ifdef FEATURE_WCDMA_MIMO
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
int8 rrc_mimo_s_cpich_po = 0;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/
#endif /*FEATURE_WCDMA_MIMO*/


/* Meas Purpose for Compressed Mode */
#define RET_COMPRESSED_MODE_MEAS_PURPOSE(meas_purpose) \
((meas_purpose == rrc_TGMP_fdd_Measurement) ? L1_CM_TGMP_WCDMA_INTERF : \
((meas_purpose == rrc_TGMP_gsm_initialBSICIdentification) ? L1_CM_TGMP_GSM_BSIC_IDENTIFY : \
((meas_purpose == rrc_TGMP_gsm_CarrierRSSIMeasurement) ? L1_CM_TGMP_GSM_RSSI_SCAN : \
L1_CM_TGMP_GSM_BSIC_RECONF )))

#ifdef FEATURE_WCDMA_CM_LTE_SEARCH
#define RET_COMPRESSED_MODE_MEAS_PURPOSE_R8(meas_purpose) \
((meas_purpose == rrc_TGMP_r8_e_UTRA) ? L1_CM_TGMP_LTE : \
((meas_purpose == rrc_TGMP_r8_fdd_Measurement) ? L1_CM_TGMP_WCDMA_INTERF : \
((meas_purpose == rrc_TGMP_r8_gsm_initialBSICIdentification) ? L1_CM_TGMP_GSM_BSIC_IDENTIFY : \
((meas_purpose == rrc_TGMP_r8_gsm_CarrierRSSIMeasurement) ? L1_CM_TGMP_GSM_RSSI_SCAN : \
L1_CM_TGMP_GSM_BSIC_RECONF ))))
#else
#define RET_COMPRESSED_MODE_MEAS_PURPOSE_R8(meas_purpose) \
((meas_purpose == rrc_TGMP_r8_fdd_Measurement) ? L1_CM_TGMP_WCDMA_INTERF : \
((meas_purpose == rrc_TGMP_r8_gsm_initialBSICIdentification) ? L1_CM_TGMP_GSM_BSIC_IDENTIFY : \
((meas_purpose == rrc_TGMP_r8_gsm_CarrierRSSIMeasurement) ? L1_CM_TGMP_GSM_RSSI_SCAN : \
L1_CM_TGMP_GSM_BSIC_RECONF )))
#endif

/* Downlink method type for CM */
#define RET_DL_COMPRESSED_MODE_METHOD_TYPE(method_type) \
((method_type == rrc_DL_CompressedModeMethod_dummy) ? L1_CM_BY_PUNCT : \
((method_type == rrc_DL_CompressedModeMethod_sf_2) ? L1_CM_BY_SF_RED : \
L1_CM_BY_HIGHER_LAYER_SCHD))


/* Uplink method type for CM */
#define RET_UL_COMPRESSED_MODE_METHOD_TYPE(method_type) \
((method_type == rrc_UL_CompressedModeMethod_sf_2) ? L1_CM_BY_SF_RED : \
L1_CM_BY_HIGHER_LAYER_SCHD)


/* Downling frame type */

#define RET_DL_FRAME_TYPE(frame_type) \
((frame_type == rrc_DL_FrameType_dl_FrameTypeA) ? L1_CM_DL_FR_TYPE_A : L1_CM_DL_FR_TYPE_B)


/* Power Control */
#define RET_RECOVERY_POWER_CONTROL(rpp) \
((rpp == rrc_RPP_mode0) ? L1_CM_NORMAL_PC_MODE : \
L1_CM_COMPRESSED_PC_MODE)

/* Transmit Power */
#define RET_INITIAL_TRANSMIT_POWER(itp) \
((itp == rrc_ITP_mode0) ? L1_CM_ITP_MODE_0 : \
L1_CM_ITP_MODE_1)

/* Max Value of Slot Number */
#define TGSN_MAX 14

/* Minimum Gap Length */
#define TGL_MIN 1

/* Txion Gap1 Length */
#define TGL1_MAX 14

/* Txion Gap2 Length*/
#define TGL2_MAX 14

/* Minimum Gap Pattern Length */
#define TGPL_MIN 1

/* Txion Gap1 Pattern Length */
#define TGPL1_MAX 144

/* Txion Gap2 Pattern Length */
#define TGPL2_MAX 144

/* deltaSIR, deltaSIRafter1, deltaSIR2, deltaSIRafter2 */
#define SIR_MAX 30

#define N_IDENTIFY_ABORT_MAX 128

#define N_IDENTIFY_ABORT_MIN 1

#define T_RECONFIRM_ABORT_MIN 1

#define T_RECONFIRM_ABORT_MAX 20

/* TGD [15...269], 270 specifies undefined. RRC sets it to 0 for l1 for undefined case */
#define TGD_MAX 270
#define TGD_MIN 15

/* Valid additional channels for 1900 MHz band */
/* NOTE: These arrays must be zero-terminated. */
rrc_UARFCN rrc_ul_band_b_addl_channels[] = { 12, 37, 62, 87, 112, 137,
  162, 187, 212, 237, 262, 287, 0 };
rrc_UARFCN rrc_dl_band_b_addl_channels[] = { 412, 437, 462, 487, 512,
  537, 562, 587, 612, 637, 662, 687, 0 };

/* Valid additional channels for 850 MHz band */
/* NOTE: These arrays must be zero-terminated. */
rrc_UARFCN rrc_ul_band_c_addl_channels[] = { 782, 787, 807,
812, 837, 862, 0 };
rrc_UARFCN rrc_dl_band_c_addl_channels[] = { 1007, 1012, 1032,
1037, 1062, 1087, 0 };

/* Valid additional channels for 800 MHz band */
/* NOTE: These arrays must be zero-terminated. */
rrc_UARFCN rrc_ul_band_d_addl_channels[] = { 812, 837, 0 };
rrc_UARFCN rrc_dl_band_d_addl_channels[] = { 1037, 1062, 0 };

/* Valid additional channels for 1700_2100 AWS MHz band (band IV) */
/* NOTE: These arrays must be zero-terminated. */
/*lint -esym(714,rrc_ul_band_h_addl_channels) */
/*lint -esym(714,rrc_dl_band_h_addl_channels) */
rrc_UARFCN rrc_ul_band_h_addl_channels[] = { 1662, 1687, 1712, 1737, 1762, 
  1787, 1812, 1837, 1862, 0 };
rrc_UARFCN rrc_dl_band_h_addl_channels[] = { 1887, 1912, 1937, 1962, 1987,
  2012, 2037, 2062, 2087, 0 };

rrc_UARFCN rrc_ul_band_j_addl_channels[] = { 387, 412, 437, 0 };
rrc_UARFCN rrc_dl_band_j_addl_channels[] = { 787, 812, 837, 0 };

extern uint32 curr_sccpch_index;
extern rrcllc_cm_status_e_type cm_status_from_ota_msg;
/* HSDPA + CM is enabled by default */
extern uint8 hsdpa_cm_enabled;

extern rrcueci_db_dc_band_storage_type db_dc_band_comb_list;
uint32 DEBUG_EUL_SI_ONLY_POWER_OFFSET = 0;
uint32 RRCEUL_SET_NO_GRANT_DEFAULT_PERIODICITY = TRUE;
uint32 RRCEUL_NO_GRANT_PERIODICITY_DEFAULT_VALUE = 500;
boolean DEBUG_EUL_RRC_VALIDATE_STEP_INDEX_THRESHOLD = TRUE;

#if defined (FEATURE_WCDMA_TO_LTE) || defined (FEATURE_LTE_TO_WCDMA)
/*Definitions of FDL offset in 100KHz, used for deriving frequency from ARFCN*/
#define RRC_DEFAULT_FDL_OFFSET 0
#define RRC_FDL_OFFSET_BAND2_ADDL 18501
#define RRC_FDL_OFFSET_BAND3 15750
#define RRC_FDL_OFFSET_BAND4 18050
#define RRC_FDL_OFFSET_BAND4_ADDL 17351
#define RRC_FDL_OFFSET_BAND5_BAND6_ADDL 6701
#define RRC_FDL_OFFSET_BAND8 3400
#define RRC_FDL_OFFSET_BAND11 7360
#define RRC_FDL_OFFSET_BAND19 7350
#define RRC_FDL_OFFSET_BAND19_ADDL 7201
#endif

prach_config_type   prach_working_db;

rrcllc_prach_sel_info_type   *  prach_sel_info[UE_MAX_PRACH];

/*--------------------------------------------------------------------
Index 0 to (UE_MAX_PRACH/2-1) will store the 10ms tti PRACH's indices
Index UE_MAX_PRACH/2 - UE_MAX_PRACH-1 will store the 20ms tti PRACH's
indices.
This will aid in Random selection of PRACH once the TTI is selected.
-------------------------------------------------------------------*/
uint8               prach_10ms_tti_index_array[UE_MAX_PRACH];
uint8               prach_20ms_tti_index_array[UE_MAX_PRACH];

typedef struct
{
  uint8                   num_valid_prachs_found;
  /*----------------------------------------------------------------
  current_10ms_tti_prach_index will advance beginning from 0.
  ----------------------------------------------------------------*/
  uint8               current_10ms_tti_prach_index;
  /*----------------------------------------------------------------
  current_20ms_tti_prach_index would start from last index in the
  prach_tti_index_array and move downwards.
  ----------------------------------------------------------------*/
  uint8               current_20ms_tti_prach_index;

}prach_sys_info_list_status_type;

prach_sys_info_list_status_type       prach_status_info;


typedef rrc_DL_CommonInformation_r6_fdd rrc_dlcommon_modespecific_info;

/*===================================================================
                        STATIC VARIABLES
=====================================================================*/

static boolean check_hho_cfn_handling = FALSE;
extern boolean rrc_predef_po3_not_needed;
/*===================================================================
                        FORWARD DECLARATIONS
=====================================================================*/

/*===================================================================
*                       FUNCTION PROTOTYPES
====================================================================*/

/*===================================================================
*                           FUNCTIONS
====================================================================*/
/*============================================================================
FUNCTION: rrcllcpcie_update_uldpch_mode_specific_info()

DESCRIPTION:
 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS or FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_update_uldpch_mode_specific_info
(
 rrc_UL_DPCH_Info_r6_fdd * ul_dpch_info
)
{
    /* Get the Uplink DPCH Scrambling Code Type */
    switch (ul_dpch_info->scramblingCodeType)
    {
      case rrc_ScramblingCodeType_shortSC:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code_type = L1_UL_SC_SHORT;
        break;
      case rrc_ScramblingCodeType_longSC:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code_type = L1_UL_SC_LONG;
        break;
      default:
        WRRC_MSG1_ERROR("UL DPCH Scrambling Code Type %d is invalid",
          ul_dpch_info->scramblingCodeType);
        return FAILURE;
    }

      
    /* Get the scrambling code */
    if(ul_dpch_info->scramblingCode <= RRCLLC_MAX_UL_SCR_CODE)
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code = (uint32)
        ul_dpch_info->scramblingCode;
    }
    else
    {
      WRRC_MSG1_ERROR("UL Scrambling Code %d is out of range",
        ul_dpch_info->scramblingCode);
      return FAILURE;
    }

    /* with Rel-6 it is possible that DPDCH may or maynot be present */
    if (RRC_CHECK_MSG_TYPE(ul_dpch_info->dpdchPresence,
           T_rrc_UL_DPCH_Info_r6_dpdchPresence_present))
    {

        if ((ul_dpch_info->dpdchPresence.u.present->numberOfDPDCH <= MAX_DPDCH) &&
            (ul_dpch_info->dpdchPresence.u.present->numberOfDPDCH >= 
             RRCLLC_DEFAULT_NUM_DPDCH_ALLOWED))
        {
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.num_dpdch = (uint8)
            ul_dpch_info->dpdchPresence.u.present->numberOfDPDCH;
        }
        else
        {
          WRRC_MSG1_ERROR("# of UL DPDCHs %d is out of range",
            ul_dpch_info->dpdchPresence.u.present->numberOfDPDCH);
          return FAILURE;
        }
      /* Get the spreading factor */
      switch(ul_dpch_info->dpdchPresence.u.present->spreadingFactor)
      {
        case rrc_SpreadingFactor_sf4:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_4;
          break;
        case rrc_SpreadingFactor_sf8:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_8;
          break;
        case rrc_SpreadingFactor_sf16:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_16;
          break;
        case rrc_SpreadingFactor_sf32:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_32;
          break;
        case rrc_SpreadingFactor_sf64:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_64;
          break;
        case rrc_SpreadingFactor_sf128:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_128;
          break;
        case rrc_SpreadingFactor_sf256:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_256;
          break;
        default:
          WRRC_MSG1_ERROR("Invalid Spreading Factor %d received",
            ul_dpch_info->dpdchPresence.u.present->spreadingFactor);
          return FAILURE;
      } /* end spreading factor switch */
  
      /* get the TFCI existence */
      if(ul_dpch_info->dpdchPresence.u.present->tfci_Existence)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = TRUE;
      }
      else
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = FALSE;
      }
  
      /* get the FBI bits if necessary */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ul_dpch_info->dpdchPresence.u.present,
        numberOfFBI_BitsPresent))
      {
        switch(ul_dpch_info->dpdchPresence.u.present->numberOfFBI_Bits)
        {
          case 1:
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_1;
            break;
          default:
            WRRC_MSG1_ERROR("Invalid # of FBI bits %d received",
              ul_dpch_info->dpdchPresence.u.present->numberOfFBI_Bits);
            return FAILURE;
        }
      }
      else
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_0;
      }
  
      /*
      * Get the UL DPCH Puncturing Limit. The OTA Msg receives this value as an enum.
      * The puncturing limit is a real number between 0.4 and 1.0 in steps of 0.04.
      * L1 expects this value to be from 40 to 100; in other words, L1 expects
      * l1_puncturing_limit = puncturing_limit * 100;
      * Therefore in the ASN.1 enum type the first enum value 0 corresponds to 0.4,
      * 1 corresponds to 0.44, etc... . Hence the following equation is derived:
      * l1_puncturing_limit = (ASN.1_enum_type * 4) + 40;
      * If this enum changes, this equation may need tweaking or else, this can
      * be broken into a switch with multiple cases.
      */
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim = (uint8)
        (((uint8)(ul_dpch_info->dpdchPresence.u.present->puncturingLimit) * 4) + 40);
  
      if((ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim < RRCLLC_MIN_PUNCTURING_LIMIT)
        || (ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim > RRCLLC_MAX_PUNCTURING_LIMIT))
      {
        WRRC_MSG1_ERROR("UL DPCH puncturing limit %d is out of range",
          ordered_config_ptr->l1_ul_chan_parms.prach_cfg.punct_lim);
        return FAILURE;
      }
#ifdef FEATURE_WCDMA_CPC_DTX
     /*Intialize numtpc to 2 as this I.E can come only in Rel7 OTA message*/
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.numtpc = L1_UL_NUM_TPC_BITS_2;
#endif
    }
    else /* rrc_notPresent_chosen */
    {

      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.num_dpdch = 0;
      
      /* get the TFCI existence */
      if(ul_dpch_info->dpdchPresence.u.notPresent->tfci_Existence)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = TRUE;
      }
      else
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = FALSE;
      }
  
      /* get the FBI bits if necessary */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ul_dpch_info->dpdchPresence.u.notPresent,
          numberOfFBI_BitsPresent))
      {
        switch(ul_dpch_info->dpdchPresence.u.notPresent->numberOfFBI_Bits)
        {
          case 1:
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_1;
            break;
          default:
            WRRC_MSG1_ERROR("RRCEUL: Invalid # of FBI bits %d received",
              ul_dpch_info->dpdchPresence.u.notPresent->numberOfFBI_Bits);
            return FAILURE;
        }
      }
      else
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_0;
      }
#ifdef FEATURE_WCDMA_CPC_DTX
     /*Intialize numtpc to 2 as this I.E can come only in Rel7 OTA message*/
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.numtpc = L1_UL_NUM_TPC_BITS_2;
#endif
    }
    return SUCCESS;
  }

/*============================================================================
FUNCTION: rrcllcpcie_dl_common_mode_specific_info()

DESCRIPTION:
 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS or FAILURE

SIDE EFFECTS:
=============================================================================*/

static uecomdef_status_e_type
rrcllcpcie_dl_common_mode_specific_info
(
  rrc_dlcommon_modespecific_info * ie_ptr,
  l1_dl_common_info_struct_type *dl_common
)
{
  struct rrc_TGP_SequenceList* local_tgp_SequenceList_ptr = NULL;
  uint32 n_value, n_index;
  
   rrc_state_e_type rrc_state = rrc_get_state();
  boolean compressed_mode_config_ignore = FALSE;
  
  /* Get the DPCH compressed mode info. To be completed */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
          dpch_CompressedModeInfoPresent))
    {
      if ((ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
        (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH) &&
        (transition_config.toc_ptr->cm_info.tgp_seq_info_count == 0) 

        )
      {
        /* Check if network tries to deactivate without specifying the config parameters */
        local_tgp_SequenceList_ptr =
          &(ie_ptr->dpch_CompressedModeInfo.tgp_SequenceList);

        n_value = local_tgp_SequenceList_ptr->n;
        n_index = 0;
        while (n_value != 0)
        {
          if ((RRC_CHECK_MSG_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_Status, 
                    T_rrc_TGP_Sequence_tgps_Status_deactivate)) &&
              (!(RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index], 
                    tgps_ConfigurationParamsPresent)))
          )
          {
            /* Set forcibly the bit mask for CM to 0. No need to check others */
            compressed_mode_config_ignore = TRUE;
            break;
          }
          else
          {
            n_value--;
            n_index++;
          }
        }
      }

      if (compressed_mode_config_ignore == TRUE)
      {
        WRRC_MSG0_HIGH("Deactivate TGPSI.CM config ignored");
      }
      else
      {
        if (set_compressed_mode_info(
          &ie_ptr->dpch_CompressedModeInfo) == FAILURE)
        {
          return FAILURE;
        }

        dl_common->opt_parm_presence_bitmask |=
          DL_COMMON_INFO_COMPRESSED_MODE_INFO_PRESENT;
      }
    }

    /* Get the TX Diversity Mode info. */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
              tx_DiversityModePresent))
    {
      if(get_tx_diversity_mode_info(ie_ptr->tx_DiversityMode,
                                    dl_common) == FAILURE)
      {
        return FAILURE;
      }
    } /* end Tx Diversity Prescence */

      /* Get the default DPCH offset if present */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
              defaultDPCH_OffsetValuePresent))
    {
      dl_common->default_dpch_offset =
        (uint16) ie_ptr->defaultDPCH_OffsetValue;

      if(dl_common->default_dpch_offset > RRCLLC_ASN1_DOFF_MAX_VAL)
      {
        WRRC_MSG0_ERROR("Doff ASN1 value out of range");
        return(FAILURE);
      }
      /* Multiply the ASN1 value with multiplication factor before sending
       * it to L1.
       */
      dl_common->default_dpch_offset  *= RRCLLC_DOFF_MULTIPLICATION_FACTOR;
      dl_common->opt_parm_presence_bitmask |=
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    }
    else
    {
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_CELL_DCH)
      {
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          /* This is an error case since we are going to Cell_DCH from
           * another state and Doff is not signalled
           */
          WRRC_MSG2_ERROR("Doff absent RRC state curr%d next%d",
              rrc_state, ordered_config_ptr->rrc_state_indicator);
          return(FAILURE);
        }
      }
      if(dl_common->dpch_common.timing_ind == L1_TIMING_IND_INIT &&
          check_hho_cfn_handling)
      {
        /* This is an error case since we are doing a timing initialized
         * hard handover and Doff is not signalled
         */
        WRRC_MSG0_ERROR("Doff absent during timing-init HHO");
        return FAILURE;
      }
    }  /* Doff is absent */

    /* We're done with this flag now. */
    check_hho_cfn_handling = FALSE;

    /* SSDT information if present NOT supported in this version of spec */
    return SUCCESS;
  }

/*====================================================================
FUNCTION      get_dl_fdpch_info_for_each_rl_r7()

FILE NAME     This function gets the DL FDPCH info for each RL

DESCRIPTION   This function translates the Downlink FDPCH info for each
              RL IE to the RRC config database.  Note that it is assumed
              that a higher level routine is doing the translation from
              the linked list present in the ASN.1 decoder output to
              the array present in the RRC config database.  The radio
              link index is passed into this function and must be
              generated by that higher level routine.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if everything is ok, FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all of the parameters
              that are present in the IE.  For those parameters not
              present the values currently existing are untouched.  For
              each optional parameter that is present the corresponding
              bit in the optional parameters presence bitmask is set.
====================================================================*/
static uecomdef_status_e_type get_dl_fdpch_info_for_each_rl_r7
(
 /* pointer to the IE */
 rrc_DL_FDPCH_InfoPerRL_r7 *ie_ptr,
 
 /* pointer to the desired DL PhyChan parameter structure */
 l1_dl_phychan_db_struct_type *dl_phychan,
 
 /* radio link index */
 uint8 rl_idx,
 
 /* are we setting up a new radio link? */
 boolean is_new_rl
#ifdef FEATURE_WCDMA_DC_HSUPA
, boolean is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
 )
{
  l1_dl_info_per_rl_struct_type *rl_info;
  
  uint16 new_tau_dpch;
  
  if (rl_idx < UE_MAX_RL)
  {
    rl_info = &dl_phychan->dl_per_rl[rl_idx];
#ifdef FEATURE_WCDMA_DC_HSUPA
    if (TRUE == is_sec_eul )
    {
      if (FALSE == ordered_config_ptr->l1_dl_chan_parms.use_fdpch)
      {
         WRRC_MSG0_ERROR("FDPCH not configured in downlink"); /* 25.319 : for each Configured Uplink Frequency, F-DPCH, E-HICH, E-RGCH and E-AGCH are configured on the corresponding downlink frequency*/
         return FAILURE;
      }
      rl_info = &dl_phychan->sec_dl_per_rl[rl_idx];
    }
#endif /* FEATURE_WCDMA_DC_HSUPA */
  }
  else
  {
    /* rl_idx too large for supported number of radio links */
    WRRC_MSG0_HIGH("rl_idx out of range");
    return FAILURE;
  }
  
  /* initialize the optional field bit mask */
  if(is_new_rl)
  {
    rl_info->dpch_per_rl.opt_parms_present_mask = 0;
    rl_info->dpch_per_rl.efdpch_slot_format = 0;

  }
  
  /* Get the DPCH frame offset (TauDPCH) */
  new_tau_dpch = (uint16)ie_ptr->fdpch_FrameOffset;
  
  /* This validation should be done by the ASN.1 encoder on the
  * network side, but better not to make any assumptions here.
  */
  if(new_tau_dpch > 149)
  {
    WRRC_MSG1_HIGH("Invalid Tau_DPCH: %s", new_tau_dpch);
    return FAILURE;
  }
  
  /* An existing radio link cannot have its TauDPCH changed by more
  * than 1.
  */
  if(!is_new_rl &&
    ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind != L1_TIMING_IND_INIT &&
    ABS((new_tau_dpch - rl_info->dpch_per_rl.frame_offset)) > 1 &&
    ABS((new_tau_dpch - rl_info->dpch_per_rl.frame_offset)) != 149)
  {
    WRRC_MSG2_HIGH("Tau_DPCH difference > 1: %d (old) %d (new)",
      rl_info->dpch_per_rl.frame_offset, new_tau_dpch);
    return FAILURE;
  }
  rl_info->dpch_per_rl.frame_offset = new_tau_dpch;
  
  /* Get the CPICH usage for channel estimation */
  switch (ie_ptr->pCPICH_UsageForChannelEst)
  {
  case rrc_PCPICH_UsageForChannelEst_mayBeUsed:
    rl_info->dpch_per_rl.use_pri_cpich = L1_USE_PRI_CPICH;
    break;
    
  case rrc_PCPICH_UsageForChannelEst_shallNotBeUsed:
    rl_info->dpch_per_rl.use_pri_cpich = L1_DO_NOT_USE_PRI_CPICH;
    break;
    
  default:
    /* bad enum value, return FALSE immediately */
    WRRC_MSG0_HIGH("Bad CPICH usage enum");
    return FAILURE;
  }
  
  /* Get the TPC Combination index */
  rl_info->dpch_per_rl.tpc_idx =
    (uint8) ie_ptr->tpc_CombinationIndex;
  
  /* Get the secondary CPICH information */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                secondaryCPICH_InfoPresent))
  {
    /* set the secondary CPICH channelisation code */
    rl_info->dpch_per_rl.sec_cpich_ch_code =
      (uint16) ie_ptr->secondaryCPICH_Info.channelisationCode;
    
    if (RRC_CHECK_MSG_TYPE_IE(ie_ptr->secondaryCPICH_Info,
                secondaryDL_ScramblingCodePresent))
    {
      /* set the secondary CPICH secondary scrambling code */
      rl_info->dpch_per_rl.sec_cpich_sec_scr_code =
        (uint16) ie_ptr->secondaryCPICH_Info.secondaryDL_ScramblingCode;
      
      rl_info->dpch_per_rl.opt_parms_present_mask |=
        DL_DPCH_INFO_PER_RL_SEC_CPICH_SEC_SCR_CODE_PRESENT;
    }
    
    /* mark the secondary CPICH information as present */
    rl_info->dpch_per_rl.opt_parms_present_mask |=
      DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT;
  }
  /* secondary cpich info is not present. It might have been present
    for the same radiolink before. Make sure that L1 gets
    correct bit masks */
  else
  {
    if (rl_info->dpch_per_rl.opt_parms_present_mask &
        DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT)
    {
      WRRC_MSG1_HIGH("Sec CPICH was present before rl_id:%d",
                 rl_idx);

      /* mark the secondary CPICH information as present */
      rl_info->dpch_per_rl.opt_parms_present_mask &=
         ~DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT;
    }
  }
  /* Get all of the DPCH code channel list information */
  /* Initialize the optional parameters for code channel */
  if(is_new_rl)
  {
    rl_info->dpch_per_rl.dl_chan_code[0].opt_parm_present_mask = 0;
  }
  rl_info->dpch_per_rl.dl_chan_code[0].code_number = (uint16) ie_ptr->dl_ChannelisationCode;
  
  /* Get the secondary scrambling code if present */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                secondaryScramblingCodePresent))
  {
    rl_info->dpch_per_rl.dl_chan_code[0].sec_scr_code =
      (uint16) ie_ptr->secondaryScramblingCode;
    
    rl_info->dpch_per_rl.dl_chan_code[0].opt_parm_present_mask |=
      DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT;
  }
  /* Get the secondary scrambling code if present */
  else
  {
    if (rl_info->dpch_per_rl.dl_chan_code[0].opt_parm_present_mask &
      DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT)
    {
      WRRC_MSG1_HIGH("Sec SCR was present before %d",
        rl_info->dpch_per_rl.dl_chan_code[0].sec_scr_code);
    }
    rl_info->dpch_per_rl.dl_chan_code[0].opt_parm_present_mask &=
      ~DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT;
  }

  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
               sttdIndicationPresent))
  {
    rl_info->dpch_per_rl.fdpch_sttd_ind  = TRUE;
  }
  else
  {
    rl_info->dpch_per_rl.fdpch_sttd_ind = FALSE;
  }

  /*As per spec CR 3478, we should assume 0 if IE is not present*/
  rl_info->dpch_per_rl.efdpch_slot_format = 0;
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
               fdpch_SlotFormatPresent))
  {
    rl_info->dpch_per_rl.efdpch_slot_format = ie_ptr->fdpch_SlotFormat;
  }
  
  WRRC_MSG2_MED("FDPCH: STTD %d for RL  efdpch_slot_format %d",
    rl_info->dpch_per_rl.fdpch_sttd_ind,rl_info->dpch_per_rl.efdpch_slot_format);
      
  /* set the number of DPCH code channels used for this radio link */
  rl_info->dpch_per_rl.num_dpch = 1;
  
  /* everything went ok */
  return SUCCESS;
} /* get_dl_dpch_info_for_each_rl_r7() */


/*====================================================================
FUNCTION: validate_fdpch_information_r7()

DESCRIPTION:
  This function verifies that there are no mixed RLs with DPCH and FDPCH
  after ASU is processed.

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if validation is successful.
  FAILURE if there are mixed RLs with FDPCH and DPCH

SIDE EFFECTS:
  None.
====================================================================*/

static uecomdef_status_e_type validate_fdpch_information_r7
(
  rrc_RL_AdditionInformationList_r7 *rl_AdditionInformationList_ptr
)
{
  uint32  n_index = 0;
  
  while(n_index < rl_AdditionInformationList_ptr->n)
  {
    if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch)
    {
      if(RRC_CHECK_MSG_TYPE(rl_AdditionInformationList_ptr->elem[n_index].dl_dpchInfo,
                  T_rrc_RL_AdditionInformation_r7_dl_dpchInfo_dl_DPCH_InfoPerRL))
      {
        WRRC_MSG0_ERROR("Mixed RLs with DPCH and FDPCH");
        return FAILURE;
      }
    }
    else
    {
      if(RRC_CHECK_MSG_TYPE(rl_AdditionInformationList_ptr->elem[n_index].dl_dpchInfo,
                              T_rrc_RL_AdditionInformation_r7_dl_dpchInfo_dl_FDPCH_InfoPerRL))
      {
        WRRC_MSG0_ERROR("Mixed RLs with DPCH and FDPCH");
        return FAILURE;
      }
    }
    n_index++;
  }
  return SUCCESS;
}


/*====================================================================
FUNCTION      rrcllc_check_if_meas_feedback_changed_r7()

DESCRIPTION   This function checks if Meas Feedback Info has changed.

DEPENDENCIES  None

RETURN VALUE  True if FDD specifed in Meas Feedback Cycle. False otherwise

SIDE EFFECTS  None.
====================================================================*/
void rrcllc_check_if_meas_feedback_changed_r7
(
  rrc_Measurement_Feedback_Info_r7* meas_feedback_ptr,
  boolean* beta_table_changed,
  boolean* dpcch_changed
)
{
  uint8 tmp_meas_feedback_cycle = 0;

  if (RRC_CHECK_MSG_TYPE(meas_feedback_ptr->modeSpecificInfo,
                    T_rrc_Measurement_Feedback_Info_r7_modeSpecificInfo_tdd))
  {
    return;
  }
  if (((uint8)meas_feedback_ptr->modeSpecificInfo.u.fdd->cqi_RepetitionFactor) != 
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_rep_factor)
  {
    WRRC_MSG2_HIGH("RRCHS:Existing CQI.RepFac %d, New %d", 
             ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_rep_factor,
             (uint8)meas_feedback_ptr->modeSpecificInfo.u.fdd->cqi_RepetitionFactor);
    *dpcch_changed = TRUE;
    
  }
  if (((uint8)meas_feedback_ptr->modeSpecificInfo.u.fdd->deltaCQI) != 
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_cqi)
  {
    WRRC_MSG2_HIGH("RRCHS:Existing DeltaCQI %d, New %d", 
             ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_cqi,
             (uint8)meas_feedback_ptr->modeSpecificInfo.u.fdd->deltaCQI);
    *beta_table_changed = TRUE;

  }

    
  tmp_meas_feedback_cycle = 
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_r7_fc0) ? 0 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_r7_fc2) ? 2 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_r7_fc4) ? 4 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_r7_fc8) ? 8 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_r7_fc10) ? 10 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_r7_fc20) ? 20 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_r7_fc40) ? 40 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_r7_fc80) ? 80 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_r7_fc16) ? 16:
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_r7_fc32) ? 32:
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_r7_fc64) ? 64:160;

  if (tmp_meas_feedback_cycle != ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle)
  {
    WRRC_MSG2_HIGH("RRCHS:Existing CQI FC %d, New %d", 
           ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle,
           tmp_meas_feedback_cycle);
   *dpcch_changed = TRUE;
  }

  /* Meas Power Offset */
  if (((int8)meas_feedback_ptr->modeSpecificInfo.u.fdd->measurementPowerOffset) !=
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.po_hs_dsch)
  {
    WRRC_MSG2_HIGH("RRCHS:Existing PowerOffset %d, New %d", 
           ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.po_hs_dsch,
           (int8)meas_feedback_ptr->modeSpecificInfo.u.fdd->measurementPowerOffset);
    *dpcch_changed = TRUE;
  }

  return;
}
/*============================================================================
FUNCTION: rrcllc_process_serving_hsdsch_cell_info_r7()

DESCRIPTION:
  This function updates IE "rrc_Serving_HSDSCH_CellInformation " in ordered config
  and update e_dch parameters

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/

uecomdef_status_e_type rrcllc_process_serving_hsdsch_cell_info_r7
(
  rrc_ActiveSetUpdate_r7_IEs *msg_ptr 
)
{

  rrc_Serving_HSDSCH_CellInformation_r7 *hs_srv_cell_ptr = &msg_ptr->serving_HSDSCH_CellInformation;

  uint8 rl_count;

  if((RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr,
            primaryCPICH_InfoPresent))
    && (hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode !=
            ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc)
    && (!(RRC_CHECK_MSG_TYPE_IE_PTR(msg_ptr, 
            newH_RNTIPresent))))

  {
    WRRC_MSG0_ERROR("ASU repointing without new HRNTI");
    return FAILURE;
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr,
            primaryCPICH_InfoPresent))
  {
    for (rl_count = 0; rl_count < ordered_config_ptr->l1_dl_chan_parms.num_rl; rl_count++)
    {
      if(hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode == 
         ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[rl_count].pri_cpich_scr_code)
      {
        WRRC_MSG0_HIGH("New HS serving cell psc found in AS");
        break;
      }
    }
    if(rl_count == ordered_config_ptr->l1_dl_chan_parms.num_rl)
    {
      WRRC_MSG0_ERROR("New HS srv cell PSC not found in rls of AS");
      return FAILURE;
    }

    if(hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode
      != ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc)
    {
      WRRC_MSG1_HIGH("ASU HS repointing to psc %d", hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode);
      hsdpa_msg_params.msg_params_present = TRUE;
      hsdpa_msg_params.rl_link_present = TRUE;
      hsdpa_msg_params.new_rl_link = hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode;
    }
  }


  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr,
              deltaACKPresent))
  {
    if(ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack != hs_srv_cell_ptr->deltaACK)
    {
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack = hs_srv_cell_ptr->deltaACK;
      hsdpa_msg_params.beta_table_present = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr,
             deltaNACKPresent))
  {
    if(ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack != hs_srv_cell_ptr->deltaNACK)
    {
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack = hs_srv_cell_ptr->deltaNACK;
      hsdpa_msg_params.beta_table_present = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr,
               mac_hsResetIndicatorPresent))
  {
    ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = TRUE;
    hsdpa_msg_params.msg_params_present = TRUE;
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr,
              harqInfoPresent))
  {    
    /* Process HARQ Info */
    if (set_harq_information_r7(&hs_srv_cell_ptr->harqInfo) == FAILURE)
    {
      return FAILURE;
    }
    hsdpa_msg_params.msg_params_present = TRUE;
    hsdpa_msg_params.hsdsch_info_present = TRUE;
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr,
            dl_hspdsch_InformationPresent))
  {
    hsdpa_msg_params.msg_params_present = TRUE;
    hsdpa_msg_params.hspdsch_info_present = TRUE;
      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = FALSE;
      if(RRC_CHECK_MSG_TYPE(hs_srv_cell_ptr->dl_hspdsch_Information.modeSpecificInfo,
                                   T_rrc_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd))
      {
        if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr->dl_hspdsch_Information.modeSpecificInfo.u.fdd,
                  dl_64QAM_ConfiguredPresent))
        {
          ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = TRUE;
        }
      }
      else if(RRC_CHECK_MSG_TYPE(hs_srv_cell_ptr->dl_hspdsch_Information.modeSpecificInfo,
                          T_rrc_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd))
      {
         return FAILURE;
      }


  }
  else
  {
    if(rrc_get_hsdpa_status() == HSDPA_INACTIVE)
    {
      /* Action has already been set to NOOP be default */
      WRRC_MSG0_HIGH("RRCHS:HSDPA Action NOOP");
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP; 
      ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
    }
  }



  if(rrcllc_determine_hsdpa_action_r7(&hs_srv_cell_ptr->dl_hspdsch_Information) == SUCCESS)
  {
     rrc_set_hsdpa_action_in_machs_macehs();

    if((ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE)
      &&((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
             (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
             ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
              (rrc_get_hsdpa_status() == HSDPA_ACTIVE))))
    {
      if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS )
      {
          WRRC_MSG0_ERROR("64 QAm cannot be started on MAC-HS");
          return FAILURE;
      }
    }

  }
  else
  {
    return FAILURE;
  }
  return SUCCESS;
}
/*============================================================================
FUNCTION: rrcllcpcie_update_uldpch_mode_specific_info_r7()

DESCRIPTION:
 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS or FAILURE

SIDE EFFECTS:
=============================================================================*/

static uecomdef_status_e_type rrcllcpcie_update_uldpch_mode_specific_info_r7
(
 struct rrc_UL_DPCH_Info_r7_fdd * ul_dpch_info
)
{
    /* Get the Uplink DPCH Scrambling Code Type */
    switch (ul_dpch_info->scramblingCodeType)
    {
      case rrc_ScramblingCodeType_shortSC:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code_type = L1_UL_SC_SHORT;
        break;
      case rrc_ScramblingCodeType_longSC:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code_type = L1_UL_SC_LONG;
        break;
      default:
        WRRC_MSG1_ERROR("UL DPCH Scrambling Code Type %d is invalid",
          ul_dpch_info->scramblingCodeType);
        return FAILURE;
    }

    /* Get the scrambling code */
    if(ul_dpch_info->scramblingCode <= RRCLLC_MAX_UL_SCR_CODE)
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code = (uint32)
        ul_dpch_info->scramblingCode;
    }
    else
    {
      WRRC_MSG1_ERROR("UL Scrambling Code %d is out of range",
        ul_dpch_info->scramblingCode);
      return FAILURE;
    }

    /* with Rel-6 it is possible that DPDCH may or maynot be present */
    if (RRC_CHECK_MSG_TYPE(ul_dpch_info->dpdchPresence,
                           T_rrc_UL_DPCH_Info_r7_dpdchPresence_present))
    {
   
        if ((ul_dpch_info->dpdchPresence.u.present->numberOfDPDCH <= MAX_DPDCH) &&
            (ul_dpch_info->dpdchPresence.u.present->numberOfDPDCH >= 
             RRCLLC_DEFAULT_NUM_DPDCH_ALLOWED))
        {
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.num_dpdch = (uint8)
            ul_dpch_info->dpdchPresence.u.present->numberOfDPDCH;
        }
        else
        {
          WRRC_MSG1_ERROR("# of UL DPDCHs %d is out of range",
            ul_dpch_info->dpdchPresence.u.present->numberOfDPDCH);
          return FAILURE;
        }

      /* Get the spreading factor */
      switch(ul_dpch_info->dpdchPresence.u.present->spreadingFactor)
      {
        case rrc_SpreadingFactor_sf4:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_4;
          break;
        case rrc_SpreadingFactor_sf8:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_8;
          break;
        case rrc_SpreadingFactor_sf16:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_16;
          break;
        case rrc_SpreadingFactor_sf32:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_32;
          break;
        case rrc_SpreadingFactor_sf64:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_64;
          break;
        case rrc_SpreadingFactor_sf128:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_128;
          break;
        case rrc_SpreadingFactor_sf256:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_256;
          break;
        default:
          WRRC_MSG1_ERROR("Invalid Spreading Factor %d received",
            ul_dpch_info->dpdchPresence.u.present->spreadingFactor);
          return FAILURE;
      } /* end spreading factor switch */
  
      /* get the TFCI existence */
      if(ul_dpch_info->dpdchPresence.u.present->tfci_Existence)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = TRUE;
      }
      else
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = FALSE;
      }
  
      /* get the FBI bits if necessary */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ul_dpch_info->dpdchPresence.u.present,
                 numberOfFBI_BitsPresent))
      {
        switch(ul_dpch_info->dpdchPresence.u.present->numberOfFBI_Bits)
        {
          case 1:
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_1;
            break;
          default:
            WRRC_MSG1_ERROR("Invalid # of FBI bits %d received",
              ul_dpch_info->dpdchPresence.u.present->numberOfFBI_Bits);
            return FAILURE;
        }
      }
      else
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_0;
      }
  
      /*
      * Get the UL DPCH Puncturing Limit. The OTA Msg receives this value as an enum.
      * The puncturing limit is a real number between 0.4 and 1.0 in steps of 0.04.
      * L1 expects this value to be from 40 to 100; in other words, L1 expects
      * l1_puncturing_limit = puncturing_limit * 100;
      * Therefore in the ASN.1 enum type the first enum value 0 corresponds to 0.4,
      * 1 corresponds to 0.44, etc... . Hence the following equation is derived:
      * l1_puncturing_limit = (ASN.1_enum_type * 4) + 40;
      * If this enum changes, this equation may need tweaking or else, this can
      * be broken into a switch with multiple cases.
      */
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim = (uint8)
        (((uint8)(ul_dpch_info->dpdchPresence.u.present->puncturingLimit) * 4) + 40);
  
      if((ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim < RRCLLC_MIN_PUNCTURING_LIMIT)
        || (ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim > RRCLLC_MAX_PUNCTURING_LIMIT))
      {
        WRRC_MSG1_ERROR("UL DPCH puncturing limit %d is out of range",
          ordered_config_ptr->l1_ul_chan_parms.prach_cfg.punct_lim);
        return FAILURE;
      }
#ifdef FEATURE_WCDMA_CPC_DTX
      /*Get number of TPC bits*/
      if(ul_dpch_info->dpdchPresence.u.present->m.numberOfTPC_BitsPresent)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.numtpc = L1_UL_NUM_TPC_BITS_4;
      }
      else
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.numtpc = L1_UL_NUM_TPC_BITS_2;
      }

#endif
    }
    else /* rrc_notPresent_chosen */
    {

      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.num_dpdch = 0;
      
      /* get the TFCI existence */
      if(ul_dpch_info->dpdchPresence.u.notPresent->tfci_Existence)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = TRUE;
      }
      else
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = FALSE;
      }
  
      /* get the FBI bits if necessary */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ul_dpch_info->dpdchPresence.u.notPresent,
                 numberOfFBI_BitsPresent))
      {
        switch(ul_dpch_info->dpdchPresence.u.notPresent->numberOfFBI_Bits)
        {
          case 1:
            ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_1;
            break;
          default:
            WRRC_MSG1_ERROR("RRCEUL: Invalid # of FBI bits %d received",
              ul_dpch_info->dpdchPresence.u.notPresent->numberOfFBI_Bits);
            return FAILURE;
        }
      }
      else
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_0;
      }
#ifdef FEATURE_WCDMA_CPC_DTX
      /*Get number of TPC bits*/
      if(ul_dpch_info->dpdchPresence.u.notPresent->m.numberOfTPC_BitsPresent)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.numtpc = L1_UL_NUM_TPC_BITS_4;
      }
      else
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.numtpc = L1_UL_NUM_TPC_BITS_2;
      }
#endif
    }
    return SUCCESS;
  }


/*============================================================================
FUNCTION: rrcllcpcie_validate_hich_rgch_info()

DESCRIPTION:
  This function validates HICH and RGCH information in all E-DCH capable RLs.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS or FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_validate_hich_rgch_info
(
  ordered_config_type *config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
  ,  boolean is_sel_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
)
{
  uint32 e_rl_idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr = &config_ptr->l1_e_info.e_dl_info;
#ifdef FEATURE_WCDMA_DC_HSUPA
  if (is_sel_eul == TRUE)
  {
    e_dl_info_ptr = &config_ptr->l1_sec_e_info.e_dl_info;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* reject configuration if HICH and RGCH signature index is
     for a given RL is same */
  for (e_rl_idx=0; e_rl_idx<e_dl_info_ptr->num_e_dl_rl_add_recfg_info;e_rl_idx++)
  {
    if ((e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
         L1_E_HICH_INFO_PRESENT) &&
         (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
         L1_E_RGCH_INFO_PRESENT))
    {
      if (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_hich_info.signature_idx ==
        e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_rgch_info.signature_idx)
      {
        WRRC_MSG2_ERROR("RRCEUL: HICH & RGCH signature idx(%d) is same for psc: %d, hence reject config",
          e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_hich_info.signature_idx, 
          e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_rl_psc);
        return(FAILURE);
      }
    }
  }
  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_get_tpc_index_for_a_given_psc()

DESCRIPTION:
  This function gets the tpc-index of a given psc. If psc is not found then
  this function will return 0xFF.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  tpc_index or 0xFF/RRC_INVALID_TPC_INDEX

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_get_tpc_index_for_a_given_psc
(
uint32 psc,
uint8 *tpc_idx
#ifdef FEATURE_WCDMA_DC_HSUPA
, boolean is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
)
{
  uint32 index;
#ifdef FEATURE_WCDMA_DC_HSUPA  
if(is_sec_eul == FALSE)
#endif /* FEATURE_WCDMA_DC_HSUPA */
{
  for (index=0; index < ordered_config_ptr->l1_dl_chan_parms.num_rl; index++)
  {
    if (psc == 
      (uint32)ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[index].pri_cpich_scr_code)
    {
      WRRC_MSG2_MED("RRCEUL: returning tpcIdx: %d for psc: %d", 
        ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[index].dpch_per_rl.tpc_idx, psc);
      *tpc_idx = ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[index].dpch_per_rl.tpc_idx;
      break;
    }
  }

  if (index == ordered_config_ptr->l1_dl_chan_parms.num_rl)
  {
    /* Return FAILURE if unable to find TPC idx */
    WRRC_MSG2_ERROR("RRCEUL: psc: %d not found in OC (numrl: %d), returning tpcIdx: 0xFF",
      psc, ordered_config_ptr->l1_dl_chan_parms.num_rl);
    return FAILURE;
  }
}
#ifdef FEATURE_WCDMA_DC_HSUPA
else
{
  for (index=0; index < ordered_config_ptr->l1_dl_chan_parms.sec_num_rl; index++)
  {
    if (psc == 
      (uint32)ordered_config_ptr->l1_dl_chan_parms.sec_dl_per_rl[index].pri_cpich_scr_code)
    {
      WRRC_MSG2_HIGH("DC_HSUPA: returning tpcIdx: %d for psc: %d", 
        ordered_config_ptr->l1_dl_chan_parms.sec_dl_per_rl[index].dpch_per_rl.tpc_idx, psc);
      *tpc_idx = ordered_config_ptr->l1_dl_chan_parms.sec_dl_per_rl[index].dpch_per_rl.tpc_idx;
      break;
    }
  }

  if (index == ordered_config_ptr->l1_dl_chan_parms.sec_num_rl)
  {
    /* Return FAILURE if unable to find TPC idx */
    WRRC_MSG2_ERROR("DC_HSUPA: psc: %d not found in OC (numrl: %d), returning tpcIdx: 0xFF",
      psc, ordered_config_ptr->l1_dl_chan_parms.sec_num_rl);
    return FAILURE;
  }
}
#endif /* FEATURE_WCDMA_DC_HSUPA */
  return SUCCESS;
}

/*============================================================================
FUNCTION: rrcllc_clean_eul_info_on_non_r6_hho()

DESCRIPTION:
  This function cleans up any stored L1 EUL related info when non-R6 HHO msg
  is received.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
static void rrcllc_clean_l1_e_info_on_non_r6_hho( void )
{
  WRRC_MSG0_HIGH("RRCEUL: Cleaning up EUL info due to non-r6 HHO msg");

  rrcllc_init_l1_e_dl_info(FALSE, TRUE, ordered_config_ptr);

}

/*============================================================================
FUNCTION: get_e_rl_index_for_a_given_psc()

DESCRIPTION:
  This function find and returns the rl index for a given psc in e-dch active
  set database
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uint32 get_e_rl_index_for_a_given_psc
(
 uint32 psc ,
 ordered_config_type *config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
, boolean is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
)
{
  uint32 e_rl_idx = L1_MAX_EDCH_RL;

  l1_e_dl_info_struct_type *e_dl_info_ptr = &config_ptr->l1_e_info.e_dl_info;
#ifdef FEATURE_WCDMA_DC_HSUPA
  if(is_sec_eul == TRUE)
  {
    e_dl_info_ptr = &config_ptr->l1_sec_e_info.e_dl_info;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */
  for (e_rl_idx=0;e_rl_idx < e_dl_info_ptr->num_e_dl_rl_add_recfg_info; e_rl_idx++)
  {
    if (psc == e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_rl_psc)
    {
      break;
    }
  }
  return(e_rl_idx);
}

/*============================================================================
FUNCTION: rrcllcpcie_check_for_e_dch_repointing_and_set_agch_mask()

DESCRIPTION:
  This function checks whether its a serving e-dch rl repointing scenario or not.
  If needed, it sets the AGCH channel mask accordingly for L1.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static void rrcllcpcie_check_for_e_dch_repointing_and_set_agch_mask
(
  uint32 old_e_serving_rl_idx, /* current_config */
  uint32 new_e_serving_rl_idx /* ordered config */
)
{
  uint32 old_e_serving_rl_idx_new = 0;
  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_e_info.e_dl_info;
  
  /* check if E-DCH transmission was up or not */
  if (TRUE == current_config_ptr->e_dch_transmission)
  {
    /* check whether the serving cell is same or not */
    if (e_dl_info_ptr->e_dl_rl_add_recfg_info[new_e_serving_rl_idx].e_rl_psc !=
        current_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[
        old_e_serving_rl_idx].e_rl_psc)
    {
      WRRC_MSG2_HIGH("RRCEUL: Serving Cell Re-pointing detected from psc: %d, to psc: %d", 
        current_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[
        old_e_serving_rl_idx].e_rl_psc, 
        e_dl_info_ptr->e_dl_rl_add_recfg_info[new_e_serving_rl_idx].e_rl_psc);

    
      /* in case AGCH is already present in database(NOT PER SPEC), 
         so set this bit again to make sure */
      e_dl_info_ptr->e_dl_rl_add_recfg_info[new_e_serving_rl_idx].e_dl_channel_mask |= 
        L1_E_AGCH_INFO_ADD;
  
      /* if it is already present and NW provides this info again, then reset
         L1_E_AGCH_INFO_RECFG bit because its a serving rl repointing scenario */
      e_dl_info_ptr->e_dl_rl_add_recfg_info[new_e_serving_rl_idx].e_dl_channel_mask  &= 
        ~L1_E_AGCH_INFO_RECFG;
  
      /* recompute the old serving rl index in ordered config again because there
         is a possibility that RL might have been removed from e-dch active set
         by the config message */
      old_e_serving_rl_idx_new = get_e_rl_index_for_a_given_psc(
        current_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[
        old_e_serving_rl_idx].e_rl_psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );
  
      /* check whether old serving RL is already removed or not */
      if ((old_e_serving_rl_idx_new < e_dl_info_ptr->num_e_dl_rl_add_recfg_info) &&
          (old_e_serving_rl_idx_new < L1_MAX_EDCH_RL))
      {
        /* indicate AGCH drop in the bit-mask */
        e_dl_info_ptr->e_dl_rl_add_recfg_info[old_e_serving_rl_idx_new].e_dl_channel_mask |= 
          L1_E_AGCH_INFO_DROP;

        /*Reset L1_E_AGCH_INFO_RECFG bit because AGCH is getting dropped.
          consider this AGCH info as obsolete i.e. set as not present. 
          For re-pointing cases, clear off AGCH present flag for non-serving 
          cell so that AGCH info doesn't get carried forward. */
        e_dl_info_ptr->e_dl_rl_add_recfg_info[old_e_serving_rl_idx_new].e_dl_channel_mask &= 
          ~(L1_E_AGCH_INFO_RECFG|L1_E_AGCH_INFO_ADD|L1_E_AGCH_INFO_PRESENT);

      }

      /* since its a re-pointing scneario - remove stored e-rnti's */
      ordered_config_ptr->l1_e_info.e_dl_info.primary_e_rnti_present = FALSE;
      ordered_config_ptr->l1_e_info.e_dl_info.secondary_e_rnti_present = FALSE;      
    }
  }
  else /* if E-DCH was not up prior to this reconfig message */
  {
    /* in case AGCH is already present in database(NOT PER SPEC), 
       so set this bit again to be on safer side */
    e_dl_info_ptr->e_dl_rl_add_recfg_info[new_e_serving_rl_idx].e_dl_channel_mask |= 
      L1_E_AGCH_INFO_ADD;
    
    e_dl_info_ptr->e_dl_rl_add_recfg_info[new_e_serving_rl_idx].e_dl_channel_mask &= 
      ~L1_E_AGCH_INFO_RECFG;
  }
}

/*============================================================================
FUNCTION: rrcllcpcie_remove_rl_from_e_dch_active_set()

DESCRIPTION:
  This function removes RL from E-DCH RL set database. 
  If RL/psc is not present in E-DCH RL set database then it returns FAILURE.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_remove_rl_from_e_dch_active_set
(
  uint32 e_rl_idx,
  uint32 psc
#ifdef FEATURE_WCDMA_DC_HSUPA
  ,  boolean is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
)
{
  uint32 idx;
  uint32 serving_rl_psc;
  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_e_info.e_dl_info;
#ifdef FEATURE_WCDMA_DC_HSUPA

  if(is_sec_eul == TRUE)
  {
    e_dl_info_ptr = &ordered_config_ptr->l1_sec_e_info.e_dl_info;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */


  /* store the serving RL psc to re-compute the rl-index after deletion of RL from
     E-DCH active set */
  serving_rl_psc = e_dl_info_ptr->e_dl_rl_add_recfg_info[
    e_dl_info_ptr->e_serving_rl_idx].e_rl_psc;

  /* if e-rl-index is not valid then calculate e-rl-index for a given psc */
  if (e_rl_idx >= e_dl_info_ptr->num_e_dl_rl_add_recfg_info)
  {
    e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );
  }

  if (e_rl_idx >= e_dl_info_ptr->num_e_dl_rl_add_recfg_info)
  {
    /* Just a error print would suffice, no need to send a failure */
    WRRC_MSG0_ERROR("RRCEUL: NW trying to remove E-RL when it is not part of E-DCH active set");
    return(FAILURE);
  }
  /* add this RL to release list */
  e_dl_info_ptr->e_rl_release_info[
    e_dl_info_ptr->num_e_rl_release_info].psc = 
      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_rl_psc;

  /* increment the number of RL in release list */
  e_dl_info_ptr->num_e_rl_release_info++;

  if (e_rl_idx == e_dl_info_ptr->e_serving_rl_idx)
  {
    e_dl_info_ptr->e_serving_rl_idx = L1_MAX_EDCH_RL;
  }
  
  /* remove the entry of the RL from the E-DCH RL database and remove the gap.
    Since num_e_dl_rl_add_recfg_info is always less than or equal to 4 and
    e_dl_rl_add_recfg_info[] is array of 6, so no need to add any special 
    protection for last element copy */
  for (idx = e_rl_idx; idx < 
    e_dl_info_ptr->num_e_dl_rl_add_recfg_info; idx++)
  {
    e_dl_info_ptr->e_dl_rl_add_recfg_info[idx] =
      e_dl_info_ptr->e_dl_rl_add_recfg_info[idx+1];
  }

  /* reset the bit mask for the removed RL */
  e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask = 0;

  /* decrement the number of E-DCH active set RL */
  e_dl_info_ptr->num_e_dl_rl_add_recfg_info--;

  /* re-compute serving-rl-index and set the e_serving_rl_idx to appropritate value */
  e_dl_info_ptr->e_serving_rl_idx = 
    (uint8)get_e_rl_index_for_a_given_psc(serving_rl_psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

  if (e_dl_info_ptr->e_serving_rl_idx == 
      e_dl_info_ptr->num_e_dl_rl_add_recfg_info)
  {
    /* serving psc is no longer in e-dch active set */
    e_dl_info_ptr->e_serving_rl_idx = L1_MAX_EDCH_RL;
  }
    
  WRRC_MSG2_HIGH("RRCEUL: Successfully removed psc:%d from E-DCH active set(new num-e-rl: %d)",
    psc, e_dl_info_ptr->num_e_dl_rl_add_recfg_info);
  
  return(SUCCESS);
}


/*============================================================================
FUNCTION: rrcllcpcie_check_and_update_e_active_set_and_remove_info()

DESCRIPTION:
  This function find and returns the rl index for a given psc in e-dch active
  set database
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static void rrcllcpcie_check_and_update_e_active_set_and_remove_info
(
  uint32 removed_psc
)
{
  uint32 e_rl_idx;

  for (e_rl_idx = 0; e_rl_idx < ordered_config_ptr->l1_e_info.e_dl_info.
    num_e_dl_rl_add_recfg_info; e_rl_idx++)
  {
    if ((e_rl_idx < L1_MAX_EDCH_RL) && (ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[e_rl_idx].
       e_rl_psc == removed_psc)/* && 
       (ordered_config_ptr->e_dch_transmission == TRUE) - even if E-DCH is not up we need to maintain the database */)
    {
      /* no need to check for returned value because we dont expect this function
         call to fail from this point */
      (void) rrcllcpcie_remove_rl_from_e_dch_active_set(e_rl_idx, removed_psc
#ifdef FEATURE_WCDMA_DC_HSUPA
      ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
      );

      /* update the l1_e_req_mask */
      rrcllc_update_l1_e_req_mask_for_e_dl_info(TRUE);
      break;
    }
  }
} /* rrcllcpcie_update_e_active_set_and_e_removal_list */

/*============================================================================
FUNCTION: rrcllcpcie_update_e_hich_info_and_mask()

DESCRIPTION:
  This function updates e-HICH information in a given rl index of e-dch active set
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_update_e_hich_info_and_mask
(
  uint32 e_rl_idx,
  rrc_E_HICH_Information *e_hich_info_ptr,
  uint32 psc
#ifdef FEATURE_WCDMA_DC_HSUPA
  ,  boolean is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */

)
{
  uint32 old_e_rl_idx = 0;

  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_e_info.e_dl_info;
  
#ifdef FEATURE_WCDMA_DC_HSUPA
  if(is_sec_eul == TRUE)
  {
    e_dl_info_ptr =&ordered_config_ptr->l1_sec_e_info.e_dl_info; 
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */
  if(e_rl_idx >= L1_MAX_EDCH_RL)
  {
    WRRC_MSG1_ERROR("e_rl_idx more than L1_MAX_EDCH_RL  %d",e_rl_idx);
    return FAILURE;
  }
  /* If we are inside this funtion it indicates that E-HICH information is
     provided by the NW */
  e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |= 
    L1_E_HICH_INFO_PRESENT;


  if (FAILURE == rrcllcpcie_get_tpc_index_for_a_given_psc(psc, 
                                                          &e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].tpc_idx
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                          , is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                         ))
  {
    return FAILURE;
  }

  if (e_rl_idx >= e_dl_info_ptr->num_e_dl_rl_add_recfg_info)
  {
    e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |= 
      L1_E_HICH_INFO_ADD;

    e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_rl_psc = (uint16)psc;
    
    /* increment the num_e_dl_rl_add_recfg_info */
    e_dl_info_ptr->num_e_dl_rl_add_recfg_info++;
  }
  else
  {
    /* get the old e-rl-index from CC */
    old_e_rl_idx = get_e_rl_index_for_a_given_psc(psc, current_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );
    if(old_e_rl_idx >= L1_MAX_EDCH_RL)
    {
      WRRC_MSG1_ERROR("old_e_rl_idx more than L1_MAX_EDCH_RL  %d",old_e_rl_idx);
      return FAILURE;
    }
#ifdef FEATURE_WCDMA_DC_HSUPA
    if(is_sec_eul == FALSE)
#endif /* FEATURE_WCDMA_DC_HSUPA */
    {
    if ((old_e_rl_idx < current_config_ptr->l1_e_info.e_dl_info.num_e_dl_rl_add_recfg_info) &&
        (current_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[old_e_rl_idx].
         e_hich_info.ch_code == e_hich_info_ptr->channelisationCode) && 
        (current_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[old_e_rl_idx].
         e_hich_info.signature_idx == e_hich_info_ptr->signatureSequence))
    {
      WRRC_MSG2_HIGH("RRCEUL: Received E-HICH Info same as stored info (chCode:%d, sigSeq:%d)", 
               e_hich_info_ptr->channelisationCode, e_hich_info_ptr->signatureSequence);
      /* no need to reconfig HICH again */
    }
    else
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |= 
        L1_E_HICH_INFO_RECFG;
    }
  }
#ifdef FEATURE_WCDMA_DC_HSUPA
    else
    {
      if ((old_e_rl_idx < current_config_ptr->l1_sec_e_info.e_dl_info.num_e_dl_rl_add_recfg_info) &&
          (current_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[old_e_rl_idx].
           e_hich_info.ch_code == e_hich_info_ptr->channelisationCode) && 
          (current_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[old_e_rl_idx].
           e_hich_info.signature_idx == e_hich_info_ptr->signatureSequence))
      {
        WRRC_MSG2_HIGH("DC_HSUPA: Received E-HICH Info same as stored info (chCode:%d, sigSeq:%d)", 
                 e_hich_info_ptr->channelisationCode, e_hich_info_ptr->signatureSequence);
        /* no need to reconfig HICH again */
      }
      else
      {
        e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |= 
          L1_E_HICH_INFO_RECFG;
      }
    }
#endif /* FEATURE_WCDMA_DC_HSUPA */
  }
  e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_hich_info.ch_code = 
    e_hich_info_ptr->channelisationCode;
  e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_hich_info.signature_idx = 
    e_hich_info_ptr->signatureSequence;

  return SUCCESS;
}

/*============================================================================
FUNCTION: rrcllcpcie_process_e_hich_info()

DESCRIPTION:
  This function processes e-HICH information and updates the information
  in a given e_rl_index
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_e_hich_info
(
  OSS_UINT32 e_hich_info_present,
  rrc_E_HICH_Information *e_hich_info_ptr,
  uint32 psc,
  /*This falg is used to honor HICH Rel Ind from OTA message,
   *TRUE: Indicate honor HICH Rel Ind from OTA message
   *FALSE: Indicate dont honor HICH Rel Ind from OTA message
   */
  boolean is_need_to_honor_e_rl_rel_ind
#ifdef FEATURE_WCDMA_DC_HSUPA
  ,  boolean is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
  
)
{
  uint32 e_rl_idx;
  e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

  if (e_hich_info_present && (e_rl_idx < L1_MAX_EDCH_RL))
  {
    if (e_hich_info_ptr != NULL )
    {
      if (FAILURE == rrcllcpcie_update_e_hich_info_and_mask(e_rl_idx, 
                                                            e_hich_info_ptr, psc
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                            ,is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                            ))
      {
        return FAILURE;
      }
    }
    else /* rrc_e_HICH_Info_releaseIndicator_chosen */
    {
#ifdef FEATURE_WCDMA_DC_HSUPA
      /*for secondary EUL we dont enter this condition. Because this function will be called only if ehich info ptr is not NULL. For primary EUL there
              is something called EHICH release indicator  thats the reason we require the below conditions and code*/
#endif /* FEATURE_WCDMA_DC_HSUPA */
      if(is_need_to_honor_e_rl_rel_ind == FALSE)
      {
        WRRC_MSG0_HIGH("RRCEUL: No need to honor e_hich_rel_ind,as We have moved all RL's to e_rl_release_info");
      }
      else
      {
        /*Ignore failure of HICH Rel indicator for a RL not present in EDCH Active set*/
        if (e_rl_idx <  ordered_config_ptr->l1_e_info.e_dl_info.num_e_dl_rl_add_recfg_info)
        {
          if(rrcllcpcie_remove_rl_from_e_dch_active_set(e_rl_idx, psc
#ifdef FEATURE_WCDMA_DC_HSUPA
      ,is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
      ) == FAILURE)
          {
            return FAILURE;
          }
        }
      }
    }
  }

  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_process_e_rgch_information()

DESCRIPTION:
  This function processes e-RGCH information and updates the information
  in a given e_rl_index
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_e_rgch_information
(
  uint32 psc,
  rrc_E_RGCH_Information *e_rgch_Information_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
  , boolean is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */

)
{
  uint32 e_rl_idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_e_info.e_dl_info;
#ifdef FEATURE_WCDMA_DC_HSUPA
  if(is_sec_eul == TRUE)
    {
      e_dl_info_ptr = &ordered_config_ptr->l1_sec_e_info.e_dl_info;
    }
#endif /* FEATURE_WCDMA_DC_HSUPA */

  e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );
  if (( e_rl_idx == e_dl_info_ptr->num_e_dl_rl_add_recfg_info)|| (e_rl_idx >= L1_MAX_EDCH_RL))
  {
    // retrurn failure because the index is not found with the give psc
    WRRC_MSG0_ERROR("Index not found with the given psc in e_dl_rl_add_recfg_info");
    return SUCCESS;
  }

  /* store RGCH info only if E-HICH info is already stored */
  if (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
    L1_E_HICH_INFO_PRESENT)
  {
    if (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
      L1_E_RGCH_INFO_PRESENT)
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |=
        L1_E_RGCH_INFO_RECFG;
    }
    else
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |=
        L1_E_RGCH_INFO_ADD|L1_E_RGCH_INFO_PRESENT;
    }

    e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_rgch_info.rg_idx = 
      e_rgch_Information_ptr->rg_CombinationIndex;

    e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_rgch_info.signature_idx = 
      e_rgch_Information_ptr->signatureSequence;
  }
  else
  {
    /* as per our current understanding NW should not provide E-RGCH info
       unless E-HICH is provided in config message or already stored in UE */
    WRRC_MSG0_ERROR("RRCEUL: NW trying to provide E-RGCH info without E-HICH Info.  Ignore");
  }

  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_process_e_rgch_info()

DESCRIPTION:
  This function processes e-RGCH information and updates the information
  in a given e_rl_index
      
DEPENDENCIES:
  This function needs to be called only after calling function to process E-HICH info.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_e_rgch_info
(
  OSS_UINT32 e_rgch_info_present,
  rrc_E_RGCH_Information *e_rgch_info_ptr,
  uint32 psc,
  /*This falg is used to honor RGCH Rel Ind from OTA message,
   *TRUE: Indicate honor RGCH Rel Ind from OTA message
   *FALSE: Indicate dont honor RGCH Rel Ind from OTA message
   */
  boolean is_need_to_honor_e_rl_rel_ind
#ifdef FEATURE_WCDMA_DC_HSUPA
  ,  boolean is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
)
{
  uint32 e_rl_idx;
  uint32 prev_e_rl_idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_e_info.e_dl_info;
#ifdef FEATURE_WCDMA_DC_HSUPA

  if (is_sec_eul == TRUE)
  {
    e_dl_info_ptr = &ordered_config_ptr->l1_sec_e_info.e_dl_info;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */


  if (e_rgch_info_present)
  {
    e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );
    if(e_rl_idx >= L1_MAX_EDCH_RL)
    {
      WRRC_MSG1_ERROR("Invalid idx %d",e_rl_idx);
      return FAILURE;
    }
    if (e_rl_idx == e_dl_info_ptr->num_e_dl_rl_add_recfg_info)
    {

        MSG_HIGH("RRCEUL: psc:%d (idx: %d) not found in E-DCH RL database i.e. E-RGCH without E-HICH Info. Ignore is_need_to_honor_e_rl_rel_ind%d ",
          psc, e_rl_idx,is_need_to_honor_e_rl_rel_ind);
    }
    else
    {
      if (e_rgch_info_ptr != NULL)
      {
        if (FAILURE == rrcllcpcie_process_e_rgch_information(
          psc, e_rgch_info_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
          ,is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ))
        {
          return(FAILURE);
        }
      }
      else /* rrc_e_RGCH_Info_releaseIndicator_chosen */
      {
       
        if(( e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask &
            L1_E_RGCH_INFO_PRESENT )!= L1_E_RGCH_INFO_PRESENT) 
        {
          WRRC_MSG0_ERROR("Attempt to remove RGCH that is not present");
          return FAILURE;
        }

        e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |=
          L1_E_RGCH_INFO_DROP;
        
        /*Re-set RGCH reconfig bit, as RGCH is getting dropped*/
        e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask &=
          ~L1_E_RGCH_INFO_RECFG;

        /* clear RGCH present field */
        e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask &= 
          ~L1_E_RGCH_INFO_PRESENT;
      }
    }
  }
  else
  {
    /* if OVSF code for HICH has changed, then RGCH needs to be reconfigured also as RGCH uses
       same OVSF code as HIGH
     */
    e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );
  
    if(e_rl_idx >= L1_MAX_EDCH_RL)
    {
      WRRC_MSG1_ERROR("Invalid idx %d",e_rl_idx);
      return FAILURE;
    }
    if(e_rl_idx >=  e_dl_info_ptr->num_e_dl_rl_add_recfg_info)
    {
      /* e_rl_idx is equal to num_e_dl_rl_add_recfg_info, then there is no valid entry 
        * for E-HICH, So dont do any thing here 
      */
    }
    else
    {
      if((e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
         (L1_E_HICH_INFO_PRESENT|L1_E_HICH_INFO_RECFG|L1_E_RGCH_INFO_PRESENT)) ==
         (L1_E_HICH_INFO_PRESENT|L1_E_HICH_INFO_RECFG|L1_E_RGCH_INFO_PRESENT))
      {
        prev_e_rl_idx = get_e_rl_index_for_a_given_psc(psc, current_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , is_sec_eul
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );
#ifdef FEATURE_WCDMA_DC_HSUPA
        if(is_sec_eul == FALSE)
#endif /* FEATURE_WCDMA_DC_HSUPA */
        {
        if ((prev_e_rl_idx <  L1_MAX_EDCH_RL) && 
            (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_hich_info.ch_code !=
            current_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[prev_e_rl_idx].e_hich_info.ch_code))
        {
          WRRC_MSG0_HIGH("RRCEUL: Reconfig RGCH due to OVSF change in HICH");
          e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask  |= L1_E_RGCH_INFO_RECFG;
        }
      }
#ifdef FEATURE_WCDMA_DC_HSUPA
        else
        {
          if ((prev_e_rl_idx <  L1_MAX_EDCH_RL) && 
          (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_hich_info.ch_code !=
              current_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[prev_e_rl_idx].e_hich_info.ch_code))
          {
            WRRC_MSG0_HIGH("DC_HSUPA: Reconfig RGCH due to OVSF change in HICH");
            e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask  |= L1_E_RGCH_INFO_RECFG;
          }
        }
#endif /* FEATURE_WCDMA_DC_HSUPA */
      }
    }
  }

  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_process_e_agch_info()

DESCRIPTION:
  This function processes e-AGCH information and updates the information
  in a given e_rl_index
      
DEPENDENCIES:
  This function needs to be called only after calling function to process E-HICH info.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_e_agch_info
(
  OSS_UINT32 e_agch_info_present,
  rrc_E_AGCH_Information *e_agch_info_ptr,
  uint32 psc
)
{
  uint32 e_rl_idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_e_info.e_dl_info;

  if (e_agch_info_present)
  {
    e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

    if ((e_rl_idx == e_dl_info_ptr->num_e_dl_rl_add_recfg_info) || (e_rl_idx >= L1_MAX_EDCH_RL))
    {
      WRRC_MSG2_ERROR("RRCEUL: psc:%d(idx: %d) not found in E-DCH RL database i.e. E-AGCH without E-HICH Info.  Ignore ",
        psc, e_rl_idx);
      return(SUCCESS);
    }

    /* store AGCH info only if E-HICH info is already stored */
    if (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
      L1_E_HICH_INFO_PRESENT)
    {

      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_agch_info.ch_code = 
        e_agch_info_ptr->e_AGCH_ChannelisationCode;
    }
    else
    {
      /* as per our current understanding NW should not provide E-AGCH info
         unless E-HICH is provided in config message or already stored in UE */
      WRRC_MSG0_ERROR("RRCEUL: NW trying to provide E-AGCH info without E-HICH Info - Ignore");
      return(SUCCESS);
    }

    if (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
      L1_E_AGCH_INFO_PRESENT)
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |=
        L1_E_AGCH_INFO_RECFG;
    }
    else
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |=
        L1_E_AGCH_INFO_ADD|L1_E_AGCH_INFO_PRESENT;
    }
  }

  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_process_e_agch_info()

DESCRIPTION:
  This function processes e-AGCH information and updates the information
  in a given e_rl_index
      
DEPENDENCIES:
  This function needs to be called only after calling function to process E-HICH info.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_serving_e_dch_rl_indicator
(
  boolean serving_e_dch_rl_indicator,
  uint32 psc
)
{
  uint32 e_rl_idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_e_info.e_dl_info;

  e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

  if (serving_e_dch_rl_indicator && (e_rl_idx < L1_MAX_EDCH_RL))
  {
    /* checking for E-AGCH should be sufficient because AGCH is stored only
       if HICH is provided by the NW, but to be on safer side it may be worth
       checking for both the channels (just in case someone removes the check
       for presence of HICH while storing AGCH) */
    if ((e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
      L1_E_AGCH_INFO_PRESENT) && 
      (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
       L1_E_HICH_INFO_PRESENT))
    {
      e_dl_info_ptr->e_serving_rl_idx = (uint8) e_rl_idx;
      rrcllcpcie_check_for_e_dch_repointing_and_set_agch_mask(
        current_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx,
        e_rl_idx);
    }
    else
    {
      /* as per our current understanding NW should not provide E-RGCH info
         unless E-HICH is provided in config message or already stored in UE */
      WRRC_MSG0_ERROR("RRCEUL: NW trying to set Serving E-RL without providing AGCH and/or HICH");
      
    }
  }

  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_release_and_clear_all_e_dch_active_set_rl()

DESCRIPTION:
  This function moves all e-dch active set RLs to e_rl_release_list.
  This function also clears the stored information about these release active
  set RLs
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static void rrcllcpcie_release_and_clear_all_e_dch_active_set_rl
(
#ifdef FEATURE_WCDMA_DC_HSUPA
  boolean is_sec_eul
#else
  void
#endif /* FEATURE_WCDMA_DC_HSUPA */

)
{
  uint32 idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr = 
                                      &ordered_config_ptr->l1_e_info.e_dl_info;
#ifdef FEATURE_WCDMA_DC_HSUPA

  if(is_sec_eul == TRUE)
  {
    e_dl_info_ptr = &ordered_config_ptr->l1_sec_e_info.e_dl_info;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */

  for (idx = 0; idx<e_dl_info_ptr->num_e_dl_rl_add_recfg_info; idx++)
  {
    e_dl_info_ptr->e_rl_release_info[e_dl_info_ptr->num_e_rl_release_info].psc =
      e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_rl_psc;

    e_dl_info_ptr->num_e_rl_release_info++;

    e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask = 0;
  }

  WRRC_MSG2_HIGH("RRCEUL: all e-dch activeSet RLs(%d) moved to e_rl_release_list(%d)",
    e_dl_info_ptr->num_e_dl_rl_add_recfg_info,
    e_dl_info_ptr->num_e_rl_release_info);

  e_dl_info_ptr->num_e_dl_rl_add_recfg_info = 0;
  e_dl_info_ptr->e_serving_rl_idx = L1_MAX_EDCH_RL;
}

/*============================================================================
FUNCTION: rrcllcpcie_indicate_drop_and_add_of_e_dch_active_set_rl()

DESCRIPTION:
  This function takes care of setting the e_dl_Channel_mask for all RLs in
  the add_reconfig list to ADD.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_indicate_drop_and_add_of_e_dch_active_set_rl(
#ifdef FEATURE_WCDMA_DC_HSUPA
boolean is_sec_eul
#else
void
#endif /* FEATURE_WCDMA_DC_HSUPA */

)
{
  uint32 idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr = 
                                      &ordered_config_ptr->l1_e_info.e_dl_info;
#ifdef FEATURE_WCDMA_DC_HSUPA
  if(is_sec_eul == TRUE)
  {
    e_dl_info_ptr = &ordered_config_ptr->l1_sec_e_info.e_dl_info;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */
  for (idx = 0; idx<e_dl_info_ptr->num_e_dl_rl_add_recfg_info; idx++)
  {
    e_dl_info_ptr->e_rl_release_info[e_dl_info_ptr->num_e_rl_release_info].psc =
      e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_rl_psc;

    e_dl_info_ptr->num_e_rl_release_info++;

    if(e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask & L1_E_AGCH_INFO_PRESENT)
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask |= L1_E_AGCH_INFO_ADD;
      /*clean up the reconfig bit*/
      e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask &= ~L1_E_AGCH_INFO_RECFG;
    }
    if(e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask & L1_E_RGCH_INFO_PRESENT)
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask |= L1_E_RGCH_INFO_ADD;
      /*clean up the reconfig bit*/
      e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask &= ~L1_E_RGCH_INFO_RECFG;
    }
    e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask |= L1_E_HICH_INFO_ADD;
    /*clean up the reconfig bit*/
    e_dl_info_ptr->e_dl_rl_add_recfg_info[idx].e_dl_channel_mask &= ~L1_E_HICH_INFO_RECFG;
  }

  WRRC_MSG0_HIGH("RRCEUL: updated e-rl info for drop and add");

}
/*============================================================================
FUNCTION: rrcllcpcie_process_e_info_in_dl_info_per_rl_list_r6()

DESCRIPTION:
  This function updates IE "dl per rl info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_e_info_in_dl_info_per_rl_list_r6
(
  OSS_UINT32 dl_info_per_rl_list_present,
  rrc_DL_InformationPerRL_List_r6 *dl_info_per_rl_list_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  uint32 e_rl_idx = 0;

  /* Look into this IE only if next UE state is DCH */
  if (dl_info_per_rl_list_present && 
      (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
     )
  {
    uint32 num_serv_e_dch_rl_true = 0;
    uint32 psc = 0;
    boolean is_e_dl_info_present = FALSE;
    rrc_DL_InformationPerRL_List_r6 *tmp_ie_ptr = dl_info_per_rl_list_ptr;
    /*is_need_to_honor_e_rl_rel_ind set this to TRUE as default value*/
    boolean is_need_to_honor_e_rl_rel_ind = TRUE;
    uint32 n_index, n_value;
    rrc_E_RGCH_Information * e_rgch_ptr= NULL;
    rrc_E_HICH_Information * e_hich_info_ptr =NULL;
    /* Firt time into DCH is also considered a HHO.  So only populate the release list of 
     * EDCH in the case of DCH->DCH only
     */
    if (ordered_config_ptr->is_hho && (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      /* if its inter-freq handover then clear any stored E-Channel information.
         Also indicate layer1 about the release psc's */
      rrcllcpcie_release_and_clear_all_e_dch_active_set_rl(
#ifdef FEATURE_WCDMA_DC_HSUPA
      FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
      );
      /*Set is_need_to_honor_e_rl_rel_ind to FALSE here, as we have moved all
       *rl to e_rl_release_info from e_dl_rl_add_recfg_info*/
      is_need_to_honor_e_rl_rel_ind = FALSE;
    }

    /* loop through all the rls informations to extract e-dch related info */
    n_index = 0;
    n_value = tmp_ie_ptr->n;
    
    while (n_value != 0)
    {
      if (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo,
                  T_rrc_DL_InformationPerRL_r6_modeSpecificInfo_fdd))
      {
        psc = tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

        /* check if any E-Channel related info is present in this RL Info */
        if ((RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index],
                      e_HICH_InfoPresent)) ||
            (RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index],
                       e_RGCH_InfoPresent)) ||
            (RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index],
                       e_AGCH_InformationPresent)) 
           )
        {
          /* if we are inside this if check then it means that RRC needs to indicate
             to L1 that some of the parameters in DL has changed */
          is_e_dl_info_present = TRUE;
          if((RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index],
                      e_HICH_InfoPresent))&&
          (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].e_HICH_Info,
                          T_rrc_DL_InformationPerRL_r6_e_HICH_Info_e_HICH_Information)))
          {
            e_hich_info_ptr=tmp_ie_ptr->elem[n_index].e_HICH_Info.u.e_HICH_Information;
          }
          else
          {
            e_hich_info_ptr=NULL;
          }
          if (FAILURE == rrcllcpcie_process_e_hich_info(
            RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index],
                      e_HICH_InfoPresent),
            e_hich_info_ptr,
            psc,
            is_need_to_honor_e_rl_rel_ind
#ifdef FEATURE_WCDMA_DC_HSUPA
            , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
            ))
          {
            return(FAILURE);
          }

          if((RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index],
                      e_RGCH_InfoPresent)) && 
            (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].e_RGCH_Info,
             T_rrc_DL_InformationPerRL_r6_e_RGCH_Info_e_RGCH_Information))
            )
          {
            e_rgch_ptr = tmp_ie_ptr->elem[n_index].e_RGCH_Info.u.e_RGCH_Information;
          }
          else
          {
            /* This means that the E-RGCH Info IE is not present*/
            e_rgch_ptr = NULL;
          }
          if (FAILURE == rrcllcpcie_process_e_rgch_info(
               RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index],
                      e_RGCH_InfoPresent),
               e_rgch_ptr,
               psc,
               is_need_to_honor_e_rl_rel_ind
#ifdef FEATURE_WCDMA_DC_HSUPA
               ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
               ))
          {
            return(FAILURE);
          }
            
          if (FAILURE == rrcllcpcie_process_e_agch_info(
            RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index],
                      e_AGCH_InformationPresent),
            &tmp_ie_ptr->elem[n_index].e_AGCH_Information,
            psc))
          {
            return(FAILURE);
          }
        }/* if any E-info IE is present */

        if (TRUE == tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->servingEDCH_RL_indicator)
        {
          if (FAILURE == rrcllcpcie_process_serving_e_dch_rl_indicator(
            TRUE,
            psc))
          {
            return(FAILURE);
          }
          num_serv_e_dch_rl_true++;
        }        
        else
        {
          e_rl_idx = ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx;
          /* If the current serving RL becomes non-serving, need to reset the flag*/
          if((e_rl_idx < L1_MAX_EDCH_RL) &&
             (ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[e_rl_idx].e_rl_psc == psc))
          {
            WRRC_MSG1_HIGH("RRCEUL: Serving cell ind for %d set to false",psc);
            ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx = L1_MAX_EDCH_RL;
          }
        }
      }/* mode-FDD */
      n_value--;
      n_index++;
    }/* while */

    if (num_serv_e_dch_rl_true > 1)
    {
      WRRC_MSG0_ERROR("Serving E-DCH RL set to TRUE in more than one RL");
      return(FAILURE);
    }

    if (FAILURE == rrcllcpcie_validate_hich_rgch_info(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
      , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */

      ))
    {
      return(FAILURE);
    }
    
    if( ordered_config_ptr->l1_e_info.e_dl_info.num_e_dl_rl_add_recfg_info 
         > RRC_EUL_MAX_RL)
    {
      WRRC_MSG1_ERROR("No of EDCh RL %d is more than 4 in Active set",
        ordered_config_ptr->l1_e_info.e_dl_info.num_e_dl_rl_add_recfg_info);
      return FAILURE;
    }
    /* update the l1_e_req_mask */
    rrcllc_update_l1_e_req_mask_for_e_dl_info(is_e_dl_info_present);
  }/* dl_info_per_rl_list_present */
  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_convert_asn1_periodicity_of_sched_info_grant()

DESCRIPTION:
  This function converts the ENUM type of rrc_E_DPDCH_PeriodicyOfSchedInfo in the 
  received in reconfig message to actual 'ms'.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  happy bit delay condition in ms

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_convert_asn1_periodicity_of_sched_info_grant
(
  rrc_E_DPDCH_PeriodicyOfSchedInfo rcvd_periodicity_of_sched_info,
  uint16 *periodicity_in_ms_ptr
)
{
  uint16 computed_periodicity_in_ms = 0;
  
  switch (rcvd_periodicity_of_sched_info)
  {
    case rrc_E_DPDCH_PeriodicyOfSchedInfo_everyEDCHTTI:
      if (E_TTI_10MS == ordered_config_ptr->mac_e_config.e_tti)
      {
        computed_periodicity_in_ms = 10;
      }
      else /* E_TTI_2MS */
      {
        computed_periodicity_in_ms = 2;
      }
      break;


    case rrc_E_DPDCH_PeriodicyOfSchedInfo_ms4:
      if (E_TTI_10MS == ordered_config_ptr->mac_e_config.e_tti)
      {
        computed_periodicity_in_ms = 10;
      }
      else
      {
        computed_periodicity_in_ms = 4;
      }
      break;

    case rrc_E_DPDCH_PeriodicyOfSchedInfo_ms10:
      computed_periodicity_in_ms = 10;
      break;

    case rrc_E_DPDCH_PeriodicyOfSchedInfo_ms20:
      computed_periodicity_in_ms = 20;
      break;

    case rrc_E_DPDCH_PeriodicyOfSchedInfo_ms50:
      computed_periodicity_in_ms = 50;
      break;

    case rrc_E_DPDCH_PeriodicyOfSchedInfo_ms100:
      computed_periodicity_in_ms = 100;
      break;

    case rrc_E_DPDCH_PeriodicyOfSchedInfo_ms200:
      computed_periodicity_in_ms = 200;
      break;

    case rrc_E_DPDCH_PeriodicyOfSchedInfo_ms500:
      computed_periodicity_in_ms = 500;
      break;

    case rrc_E_DPDCH_PeriodicyOfSchedInfo_ms1000:
      computed_periodicity_in_ms = 1000;
      break;

    default:
      WRRC_MSG1_ERROR("RRCEUL: received wrong periodicity of sched info: %d",
        rcvd_periodicity_of_sched_info);
      return(FAILURE);
  }

  *periodicity_in_ms_ptr = computed_periodicity_in_ms;
  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_convert_asn1_e_dch_max_ch_codes()

DESCRIPTION:
  This function converts the ENUM type of max-channelisation codes in the 
  received in reconfig message to actual internally defined enumration.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  happy bit delay condition in ms

SIDE EFFECTS:
=============================================================================*/
 uecomdef_status_e_type rrcllcpcie_convert_asn1_e_dch_max_ch_codes
(
  rrc_E_DPDCH_MaxChannelisationCodes rcvd_max_ch_codes,
  l1_e_dpdch_info_struct_type *e_dpdch_info_ptr    
)
{
  l1_e_max_ch_codes_enum_type converted_max_ch_codes = L1_NUM_L1_E_MAX_CH_CODES_SF;

  switch(rcvd_max_ch_codes)
  {
    case rrc_E_DPDCH_MaxChannelisationCodes_sf256:
      converted_max_ch_codes = L1_E_MAX_CH_CODES_SF_256;
      break;
      
    case rrc_E_DPDCH_MaxChannelisationCodes_sf128:
      converted_max_ch_codes = L1_E_MAX_CH_CODES_SF_128;
      break;
      
    case rrc_E_DPDCH_MaxChannelisationCodes_sf64:
      converted_max_ch_codes = L1_E_MAX_CH_CODES_SF_64;
      break;

    case rrc_E_DPDCH_MaxChannelisationCodes_sf32:
      converted_max_ch_codes = L1_E_MAX_CH_CODES_SF_32;
      break;

    case rrc_E_DPDCH_MaxChannelisationCodes_sf16:
      converted_max_ch_codes = L1_E_MAX_CH_CODES_SF_16;
      break;

    case rrc_E_DPDCH_MaxChannelisationCodes_sf8:
      converted_max_ch_codes = L1_E_MAX_CH_CODES_SF_8;
      break;

    case rrc_E_DPDCH_MaxChannelisationCodes_sf4:
      converted_max_ch_codes = L1_E_MAX_CH_CODES_SF_4;
      break;

    case rrc_E_DPDCH_MaxChannelisationCodes_sf4x2:
      converted_max_ch_codes = L1_E_MAX_CH_CODES_SF4X2;
      break;

    case rrc_E_DPDCH_MaxChannelisationCodes_sf2x2:
      converted_max_ch_codes = L1_E_MAX_CH_CODES_SF2X2;
      break;

    case rrc_E_DPDCH_MaxChannelisationCodes_sf4x2_and_sf2x2:
      converted_max_ch_codes = L1_E_MAX_CH_CODES_SF4X2_SF2X2;
      break;

    default:
      WRRC_MSG1_ERROR("MaxChannelisationCodes out of range: %d", rcvd_max_ch_codes);
      e_dpdch_info_ptr->e_max_ch_codes = converted_max_ch_codes;
      return(FAILURE);
  }
  
  e_dpdch_info_ptr->e_max_ch_codes = converted_max_ch_codes;
  return(SUCCESS);
}
/*============================================================================
FUNCTION: rrcllcpcie_convert_asn1_minreduced_e_dpdch_gainfactor()

DESCRIPTION:
  This function converts the ENUM type of minReduced_E_DPDCH_GainFactor 
  received in reconfig message to actual internally defined enumration.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  minReduced_E_DPDCH_GainFactor
  
SIDE EFFECTS:
=============================================================================*/
l1_e_min_bed_enum_type rrcllcpcie_convert_asn1_minreduced_e_dpdch_gainfactor
(
  rrc_MinReduced_E_DPDCH_GainFactor minReduced_E_DPDCH_GainFactor
)
{
  /*Set it to the default value 8/15 */
  l1_e_min_bed_enum_type converted_e_min_bed = L1_E_MIN_BED_08;

  switch(minReduced_E_DPDCH_GainFactor)
  {
    case rrc_MinReduced_E_DPDCH_GainFactor_m8_15:
      converted_e_min_bed = L1_E_MIN_BED_08;
      break;
      
    case rrc_MinReduced_E_DPDCH_GainFactor_m11_15:
      converted_e_min_bed = L1_E_MIN_BED_11;
      break;
      
    case rrc_MinReduced_E_DPDCH_GainFactor_m15_15:
      converted_e_min_bed = L1_E_MIN_BED_15;
      break;

    case rrc_MinReduced_E_DPDCH_GainFactor_m21_15:
      converted_e_min_bed = L1_E_MIN_BED_21;
      break;

    case rrc_MinReduced_E_DPDCH_GainFactor_m30_15:
      converted_e_min_bed = L1_E_MIN_BED_30;
      break;

    case rrc_MinReduced_E_DPDCH_GainFactor_m42_15:
      converted_e_min_bed = L1_E_MIN_BED_42;
      break;

    case rrc_MinReduced_E_DPDCH_GainFactor_m60_15:
      converted_e_min_bed = L1_E_MIN_BED_60;
      break;

    case rrc_MinReduced_E_DPDCH_GainFactor_m84_15:
      converted_e_min_bed = L1_E_MIN_BED_84;
      break;

    default:
      WRRC_MSG1_ERROR("minReduced_E_DPDCH_GainFactor out of range: %d", minReduced_E_DPDCH_GainFactor);
      converted_e_min_bed = L1_E_MIN_BED_08;
      break;
  }
  
  return(converted_e_min_bed);
}
/*============================================================================
FUNCTION: rrcllcpcie_convert_asn1_happy_bit_delay_condn_to_ms()

DESCRIPTION:
  This function converts the ENUM type received in reconfig message to actual ms
  delay in happyBitDelayCondition.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  happy bit delay condition in ms

SIDE EFFECTS:
=============================================================================*/
 uint16 rrcllcpcie_convert_asn1_happy_bit_delay_condn_to_ms
(
    rrc_HappyBit_DelayCondition happy_bit_delay_condn
)
{
  uint16 happy_bit_delay_condn_in_ms = 0;

  switch(happy_bit_delay_condn)
  {
    case rrc_HappyBit_DelayCondition_ms2:
      happy_bit_delay_condn_in_ms = 2;
      break;

    case rrc_HappyBit_DelayCondition_ms10:
      happy_bit_delay_condn_in_ms = 10;
      break;

    case rrc_HappyBit_DelayCondition_ms20:
      happy_bit_delay_condn_in_ms = 20;
      break;

    case rrc_HappyBit_DelayCondition_ms50:
      happy_bit_delay_condn_in_ms = 50;
      break;

    case rrc_HappyBit_DelayCondition_ms100:
      happy_bit_delay_condn_in_ms = 100;
      break;

    case rrc_HappyBit_DelayCondition_ms200:
      happy_bit_delay_condn_in_ms = 200;
      break;

    case rrc_HappyBit_DelayCondition_ms500:
      happy_bit_delay_condn_in_ms = 500;
      break;

    case rrc_HappyBit_DelayCondition_ms1000:
      happy_bit_delay_condn_in_ms = 1000;
      break;

    default:
      WRRC_MSG1_ERROR("UnKnown Happy bit delay condition: %d", happy_bit_delay_condn);
      break;
  }

  return(happy_bit_delay_condn_in_ms);
}

/*===========================================================================

FUNCTION          rrcllcpcie_convert_asn1_oss_bitstring_to_uint8

DESCRIPTION       
  This function translates oss-bitstring to uint8 and retruned the computed uint8 value. 

DEPENDENCIES
  None

RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
uint8 rrcllcpcie_convert_asn1_oss_bitstring_to_uint8
(
  ASN1BitStr32  *bitstring_ptr
)
{
  if (bitstring_ptr->numbits != 8)
  {
    WRRC_MSG1_ERROR("Received BITSTRING Length: %d is invalid(expected 8)",
               bitstring_ptr->numbits);
  }

  return((uint8) *(bitstring_ptr->data));
}

/*============================================================================
FUNCTION: rrcllcpcie_process_two_and_three_step_threshold_info()

DESCRIPTION:
  This function process rcvd two and three step threshold and store the same in 
  e_dl_info for L1
      
DEPENDENCIES:
  NONE

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_two_and_three_step_threshold_info
(
  OSS_UINT32 three_index_step_threshold_present,
  OSS_UINT32 three_index_step_threshold,
  OSS_UINT32 two_index_step_threshold_present,
  OSS_UINT32 two_index_step_threshold  
)
{
  if (three_index_step_threshold_present || two_index_step_threshold_present)
  {
    if (three_index_step_threshold_present)
    {
      ordered_config_ptr->l1_e_info.e_dl_info.grant_config.three_index_step_threshold = 
        three_index_step_threshold;
    }

    if (two_index_step_threshold_present)
    {
      ordered_config_ptr->l1_e_info.e_dl_info.grant_config.two_index_step_threshold = 
        two_index_step_threshold;
    }

    if (TRUE == DEBUG_EUL_RRC_VALIDATE_STEP_INDEX_THRESHOLD)
    {
      /* 
         As per 25.321:
         -     if SGLUPR < "3-index-step threshold":
           -     Serving_Grant = SG[MIN(SGLUPR + 3 , 37)].
         -     if "3-index-step threshold" <= SGLUPR < "2-index-step threshold":
           -     Serving_Grant = SG[MIN(SGLUPR + 2 , 37)].
         -     if "2-index-step threshold" <= SGLUPR::
           -     Serving_Grant = SG[MIN(SGLUPR + 1 , 37)].
         From above algorithm, 3-index has to be less than 2-index step threshold
      */
      if ((ordered_config_ptr->l1_e_info.e_dl_info.grant_config.three_index_step_threshold >= 
           ordered_config_ptr->l1_e_info.e_dl_info.grant_config.two_index_step_threshold) &&
          /* 2-index or 3-index step threshold value range is 0..37. 0 is the default value 
             hence ignore this value as well. Below check is only for 3-index because we
             are concenred about 3-index step threshold only */
          (ordered_config_ptr->l1_e_info.e_dl_info.grant_config.three_index_step_threshold < 38) &&
          (ordered_config_ptr->l1_e_info.e_dl_info.grant_config.three_index_step_threshold > 0) &&
          /* there is a possibility that 3-index is received and 2-index is not received from the NW */
          (ordered_config_ptr->l1_e_info.e_dl_info.grant_config.two_index_step_threshold > 0))
      {
        WRRC_MSG2_ERROR("RRCEUL: Invalid 3-Index(%d) and 2-IndexStep(%d) combination. 3-index should be less than 2-index",
          ordered_config_ptr->l1_e_info.e_dl_info.grant_config.three_index_step_threshold,
          ordered_config_ptr->l1_e_info.e_dl_info.grant_config.two_index_step_threshold
          );
        return(FAILURE);
      }
    }

    /* since DL info is modified, hence set the DL-RECFG to indicate L1 */
    rrcllc_update_l1_e_req_mask_for_e_dl_info(TRUE);
  }

  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_process_sched_txn_config()

DESCRIPTION:
  This function process scheduling transmission config and store the same in 
  L1 and MAC database accordingly
      
DEPENDENCIES:
  NONE

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static void rrcllcpcie_process_sched_tx_config
(
  OSS_UINT32 sched_tx_config_present,
  rrc_E_DPDCH_SchedulingTransmConfiguration *sched_txn_config_ptr,
  l1_e_dl_info_struct_type *e_dl_info_ptr,
  mac_e_dpdch_info_s_type *mac_e_dpdch_info_ptr
)
{
  if (!sched_tx_config_present)
  {
    return;
  }

  if (RRC_CHECK_MSG_TYPE_IE_PTR(sched_txn_config_ptr,
            ms2_SchedTransmGrantHARQAllocPresent))
  {
    mac_e_dpdch_info_ptr->sched_tx_config.sched_tx_grant_harq_allocation_2ms = 
      rrcllcpcie_convert_asn1_oss_bitstring_to_uint8(
      &sched_txn_config_ptr->ms2_SchedTransmGrantHARQAlloc);

    WRRC_MSG1_HIGH("RRCEUL: Received ms2_SchedTransmGrantHARQAlloc: 0x%x", 
      mac_e_dpdch_info_ptr->sched_tx_config.sched_tx_grant_harq_allocation_2ms);

    rrcllc_update_mac_eul_action(TRUE);
  }
  else
  {
    rrcllc_update_mac_eul_action(TRUE);
    mac_e_dpdch_info_ptr->sched_tx_config.sched_tx_grant_harq_allocation_2ms = 0xFF;
    WRRC_MSG1_MED("RRCEUL: not received ms2_SchedTransmGrantHARQAlloc -set default: 0x%x", 
      mac_e_dpdch_info_ptr->sched_tx_config.sched_tx_grant_harq_allocation_2ms);
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(sched_txn_config_ptr,
             servingGrantPresent))
  {
    if (rrc_E_DPDCH_SchedulingTransmConfiguration_primary_Secondary_GrantSelector_primary == 
      sched_txn_config_ptr->servingGrant.primary_Secondary_GrantSelector)
    {
      e_dl_info_ptr->grant_config.grant_selector = L1_E_PRIMARY_GRANT;
    }
    else
    {
      e_dl_info_ptr->grant_config.grant_selector = L1_E_SECONDARY_GRANT;
    }

    /* make sure that E-RNTI is present when grant selector is incuded in config msg.
       Below check is based on the assumption that E-RNTI database is updated
       before this function will be called. Hence, ordered-config database is checked
       for presence of E-RNTI */
    if (((L1_E_PRIMARY_GRANT == e_dl_info_ptr->grant_config.grant_selector) &&
      (FALSE != e_dl_info_ptr->primary_e_rnti_present)) ||
      ((L1_E_SECONDARY_GRANT == e_dl_info_ptr->grant_config.grant_selector) &&
      (FALSE != e_dl_info_ptr->secondary_e_rnti_present)))
    {
      e_dl_info_ptr->grant_config.serving_grant = 
        sched_txn_config_ptr->servingGrant.value;

      rrcllc_update_l1_e_req_mask_for_e_dl_info(TRUE);
    }
    else
    {
      /* currently we dont want to reject message just because grant selector is
         included and corresponding E-RNTI is not present. Currently, RRC will 
         ignore the grant selector and behave as if grant selector/serving gratn is
         not present at all */
      e_dl_info_ptr->grant_config.grant_selector = L1_E_GRANT_SELECTOR_NOT_PRESENT;

      WRRC_MSG1_ERROR("RRCEUL: NW provided grant-selector: %d(Pri: 1, Sec:2), when corres. E-RNTI is not present. Ignoring IE.",
        e_dl_info_ptr->grant_config.grant_selector);
    }
  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_sched_info_config()

DESCRIPTION:
  This function process scheduling information config and store the same in e_mac_info for MAC
      
DEPENDENCIES:
  NONE

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_sched_info_config
(
  rrc_E_DPDCH_SchedulingInfoConfiguration *sched_info_config_ptr,
  mac_e_dpdch_info_s_type *mac_e_dpdch_info_ptr
)
{
  if (DEBUG_EUL_SI_ONLY_POWER_OFFSET != 0)
  {
    mac_e_dpdch_info_ptr->sched_info_config.power_offset_of_si = (uint8)
      DEBUG_EUL_SI_ONLY_POWER_OFFSET;
  }
  else
  {
    mac_e_dpdch_info_ptr->sched_info_config.power_offset_of_si = 
      sched_info_config_ptr->powerOffsetForSchedInfo;
  }

  /* its a MD IE */
  mac_e_dpdch_info_ptr->sched_info_config.no_grant_periodicity_of_si = 0;
  mac_e_dpdch_info_ptr->sched_info_config.grant_periodicity_of_si = 0;

  if (RRC_CHECK_MSG_TYPE_IE_PTR(sched_info_config_ptr,
            periodicityOfSchedInfo_NoGrantPresent))
  {
    if (FAILURE == rrcllcpcie_convert_asn1_periodicity_of_sched_info_grant(
      sched_info_config_ptr->periodicityOfSchedInfo_NoGrant,
      &mac_e_dpdch_info_ptr->sched_info_config.no_grant_periodicity_of_si))
    {
      return(FAILURE);
    }

  }
  else
  {
    if (RRCEUL_SET_NO_GRANT_DEFAULT_PERIODICITY == TRUE)
    {
      if(E_TTI_2MS == ordered_config_ptr->mac_e_config.e_tti)
      {
        mac_e_dpdch_info_ptr->sched_info_config.no_grant_periodicity_of_si = (uint16)
            RRCEUL_NO_GRANT_PERIODICITY_DEFAULT_VALUE_2MS;
      }
      else
      {
        mac_e_dpdch_info_ptr->sched_info_config.no_grant_periodicity_of_si = (uint16)
          RRCEUL_NO_GRANT_PERIODICITY_DEFAULT_VALUE;
      }
    }
  }

  if (RRC_CHECK_MSG_TYPE_IE_PTR(sched_info_config_ptr,
               periodicityOfSchedInfo_GrantPresent))
  {
    if (FAILURE == rrcllcpcie_convert_asn1_periodicity_of_sched_info_grant(
      sched_info_config_ptr->periodicityOfSchedInfo_Grant,
      &mac_e_dpdch_info_ptr->sched_info_config.grant_periodicity_of_si))
    {
      return(FAILURE);
    }
  }

  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllc_sort_ref_e_tfci_list()

DESCRIPTION:
  This function sort reference E-TFCIs in ascending order
      
DEPENDENCIES:
  NONE

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
 void  rrcllc_sort_ref_e_tfci_list(
   l1_e_dpdch_info_struct_type *e_dpdch_info_ptr
)
{
  uint32  idx,cnt;
  uint32 swap_cnt;
  l1_ref_e_tfci_struct_type temp_ref_e_tfci;

  for(idx = e_dpdch_info_ptr->num_ref_e_tfci -1; idx >0; idx--)
  {
    swap_cnt = 0;
    
    for(cnt = 0; ((cnt < idx ) && (cnt < L1_MAX_REF_E_TFCI_LIST -1 )); cnt ++)
    {
      if(e_dpdch_info_ptr->ref_e_tfci_list[cnt +1].ref_e_tfci < 
          e_dpdch_info_ptr->ref_e_tfci_list[cnt].ref_e_tfci)
      {
        temp_ref_e_tfci= e_dpdch_info_ptr->ref_e_tfci_list[cnt];
        e_dpdch_info_ptr->ref_e_tfci_list[cnt] = e_dpdch_info_ptr->ref_e_tfci_list[cnt+1];
        e_dpdch_info_ptr->ref_e_tfci_list[cnt+1] = temp_ref_e_tfci;
        swap_cnt++;
      }
    } 
    if(swap_cnt == 0)
    {
       /* The list already sorted */
       break;
    }
  }
}


/*============================================================================
FUNCTION: rrcllcpcie_process_reference_e_tfcis()

DESCRIPTION:
  This function processes reference E-TFCIs and store the same in e_ul_info for L1
      
DEPENDENCIES:
  NONE

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_reference_e_tfcis
(
  rrc_E_DPDCH_Reference_E_TFCIList *reference_etfcis_ptr,
  l1_e_dpdch_info_struct_type *e_dpdch_info_ptr
)
{
  rrc_E_DPDCH_Reference_E_TFCIList *temp_ref_etfci_ptr;
  boolean sort_ref_tfci_list = FALSE;
  uint32 n_index, n_value;
  
  temp_ref_etfci_ptr = reference_etfcis_ptr;
  n_value = reference_etfcis_ptr->n;
  n_index = 0;

  /* reset the number of reference e-tfci's to 0 */
  e_dpdch_info_ptr->num_ref_e_tfci = 0;

  while (n_value != 0)
  {
    if (L1_MAX_REF_E_TFCI_LIST <= e_dpdch_info_ptr->num_ref_e_tfci)
    {
      return(FAILURE);
    }
    
    e_dpdch_info_ptr->ref_e_tfci_list[
      e_dpdch_info_ptr->num_ref_e_tfci].ref_e_tfci = 
      temp_ref_etfci_ptr->elem[n_index].reference_E_TFCI;

    e_dpdch_info_ptr->ref_e_tfci_list[
      e_dpdch_info_ptr->num_ref_e_tfci].ref_e_tfci_pwr_offset = 
      temp_ref_etfci_ptr->elem[n_index].reference_E_TFCI_PO;

    if(e_dpdch_info_ptr->num_ref_e_tfci > 0 )
    {
      if( e_dpdch_info_ptr->ref_e_tfci_list[e_dpdch_info_ptr->num_ref_e_tfci].ref_e_tfci < 
         e_dpdch_info_ptr->ref_e_tfci_list[e_dpdch_info_ptr->num_ref_e_tfci-1].ref_e_tfci)
      {
        MSG_ERROR("Ref ETFCI not in ascending order in OTA RefTFCI %d <  Next RefTFCI %d num ETFCI %d",
             e_dpdch_info_ptr->ref_e_tfci_list[e_dpdch_info_ptr->num_ref_e_tfci-1].ref_e_tfci,
             e_dpdch_info_ptr->ref_e_tfci_list[e_dpdch_info_ptr->num_ref_e_tfci].ref_e_tfci,
             e_dpdch_info_ptr->num_ref_e_tfci);
        sort_ref_tfci_list = TRUE;
      }
    }
    
    e_dpdch_info_ptr->num_ref_e_tfci++;

    //temp_ref_etfci_ptr = temp_ref_etfci_ptr->next;
    n_value--;
    n_index++;
  }
  
  if(sort_ref_tfci_list == TRUE )
  {
    rrcllc_sort_ref_e_tfci_list(e_dpdch_info_ptr);
  }
  
  return(SUCCESS);
}
  
/*============================================================================
FUNCTION: rrcllcpcie_process_e_dpcch_info()

DESCRIPTION:
  This function updates IE "dl per rl info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static void rrcllcpcie_process_e_dpcch_info
(
  OSS_UINT32 e_dpcch_info_present,
  rrc_E_DPCCH_Info *e_dpcch_info_ptr
)
{
  if (e_dpcch_info_present)
  {
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpcch_pwr_offset = 
      e_dpcch_info_ptr->e_DPCCH_DPCCH_PowerOffset;
    /* Since L1 parameters are present hence update the bit mask to indicate the same */
    rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);

    ordered_config_ptr->mac_e_config.e_dch_info.e_dpcch_info.happy_bit_delay_in_ms = 
      rrcllcpcie_convert_asn1_happy_bit_delay_condn_to_ms(
      e_dpcch_info_ptr->happyBit_DelayCondition);

    rrcllc_update_mac_eul_action(TRUE);
  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_e_dpdch_info()

DESCRIPTION:
  This function updates IE "dl per rl info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_e_dpdch_info
(
  OSS_UINT32 e_dpdch_info_present,
  rrc_E_DPDCH_Info *e_dpdch_info_ptr
)
{
  if (e_dpdch_info_present)
  {
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_tfci_table_idx = 
      e_dpdch_info_ptr->e_TFCI_TableIndex;

    ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_table_index = 
      e_dpdch_info_ptr->e_TFCI_TableIndex;    

    if (FAILURE == rrcllcpcie_convert_asn1_e_dch_max_ch_codes(
      e_dpdch_info_ptr->maxChannelisationCodes,
      &ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info))
    {
      return(FAILURE);
    }

    /* multiply received value by 4 - as per rrc-l1 interface requirements */
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_dpdch_pl_non_max = 
      e_dpdch_info_ptr->pl_NonMax << 2;

    if (FAILURE == rrcllcpcie_process_reference_e_tfcis(
        &e_dpdch_info_ptr->reference_E_TFCIs,
        &ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info))
    {
      return(FAILURE);
    }

    if (FAILURE == rrcllcpcie_process_sched_info_config(
        &e_dpdch_info_ptr->schedulingInfoConfiguration,
        &ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info))
    {
      return(FAILURE);
    }

    if (RRC_CHECK_MSG_TYPE_IE_PTR(e_dpdch_info_ptr,
                 e_DCH_MinimumSet_E_TFCIPresent))
    {
      ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_min_set =
        e_dpdch_info_ptr->e_DCH_MinimumSet_E_TFCI;
    }
    else
    {
      ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_min_set = 
        MAC_E_TFCI_MIN_SET_NOT_PRESENT;
    }

    /* reset the threshold because its a MD IE */
    ordered_config_ptr->l1_e_info.e_dl_info.grant_config.three_index_step_threshold = 
      L1_SG_STEP_THRESHOLD_NOT_PRESENT;
    ordered_config_ptr->l1_e_info.e_dl_info.grant_config.two_index_step_threshold = 
      L1_SG_STEP_THRESHOLD_NOT_PRESENT;
    if (FAILURE == rrcllcpcie_process_two_and_three_step_threshold_info(
        RRC_CHECK_MSG_TYPE_IE_PTR(e_dpdch_info_ptr, 
                  threeIndexStepThresholdPresent),
        e_dpdch_info_ptr->threeIndexStepThreshold,
        RRC_CHECK_MSG_TYPE_IE_PTR(e_dpdch_info_ptr,
                  twoIndexStepThresholdPresent),
        e_dpdch_info_ptr->twoIndexStepThreshold)
       )
    {
      return(FAILURE);
    }

    WRRC_MSG0_HIGH("RRCEUL:Init min_beta_ed");
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.min_beta_ed = NUM_L1_E_MIN_BED; /* invalid */

    /* set bit-mask to indicate L1 that UL info is received */
    rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);    
    rrcllc_update_mac_eul_action(TRUE);
    
  }

  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_process_ul_e_dch_information()

DESCRIPTION:
  This function updates IE "ul e dch information" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_ul_e_dch_information
(
  OSS_UINT32 e_dch_info_present,
  rrc_UL_EDCH_Information_r6 *e_dch_info_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  /* Look into this IE only if next UE state is DCH */
  if (e_dch_info_present && 
      (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
     )
  {
    if ((e_dch_info_ptr->m.mac_es_e_resetIndicatorPresent) &&
        (e_dch_info_ptr->mac_es_e_resetIndicator == rrc_UL_EDCH_Information_r6_mac_es_e_resetIndicator_true))
    {
      ordered_config_ptr->mac_e_reset_indicator = TRUE;
    }
    else
    {
      ordered_config_ptr->mac_e_reset_indicator = FALSE;
    }

    rrcllcpcie_process_e_dpcch_info(
      RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr,
                  e_DPCCH_InfoPresent),
      &e_dch_info_ptr->e_DPCCH_Info);

    if (FAILURE == rrcllcpcie_process_e_dpdch_info(
        RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr,
                  e_DPDCH_InfoPresent),
        &e_dch_info_ptr->e_DPDCH_Info))
    {
      return(FAILURE);
    }

    rrcllcpcie_process_sched_tx_config(
      RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr,
                   schedulingTransmConfigurationPresent),
      &e_dch_info_ptr->schedulingTransmConfiguration,
      &ordered_config_ptr->l1_e_info.e_dl_info,
      &ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info
      );    
  }
  /* If rel 6 OTA is received, power interpolation is set to FALSE*/
  ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpdch_pwr_interpolation = FALSE;
  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_process_e_dch_reconfig_info()

DESCRIPTION:
  This function processes rl removal list and updates e_dch active set information
  and adds removed rl to e_rl_removed list
      
RE-USABILITY: R99/R5/R6

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_e_dch_reconfig_info
(
  OSS_UINT32 e_dch_reconfig_info_present,
  rrc_E_DCH_ReconfigurationInfo *e_dch_reconfig_info_ptr
)
{
  uint32 psc, e_rl_idx;
  rrc_E_RGCH_Information * e_rgch_ptr= NULL;
    rrc_E_HICH_Information * e_hich_info_ptr =NULL;
  boolean is_e_dl_info_present = FALSE;
  
  l1_e_ul_info_struct_type *e_ul_info_ptr =
    &ordered_config_ptr->l1_e_info.e_ul_info;

  l1_e_dl_info_struct_type *e_dl_info_ptr =
    &ordered_config_ptr->l1_e_info.e_dl_info;

  mac_e_dpdch_info_s_type *mac_e_dpdch_info_ptr = 
    &ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info;

  rrc_E_DCH_ReconfigurationInfo_e_DCH_RL_InfoOtherCellList *e_rl_info_other_cell_ptr = NULL; 
  uint32 n_index, n_value;

  if (e_dch_reconfig_info_present)
  {
    if(RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_reconfig_info_ptr,
                e_DCH_RL_InfoNewServingCellPresent)
    )
    {
      /* store serving grant */
      if(RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
                 servingGrantPresent)
      )
      {
        if (rrc_E_DCH_RL_InfoNewServingCell_primary_Secondary_GrantSelector_primary == 
              e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.servingGrant.primary_Secondary_GrantSelector)
        {
          e_dl_info_ptr->grant_config.grant_selector = L1_E_PRIMARY_GRANT;
        }
        else
        {
          e_dl_info_ptr->grant_config.grant_selector = L1_E_SECONDARY_GRANT;
        }

        if (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.servingGrant,
                    valuePresent)
        )
        {
          e_dl_info_ptr->grant_config.serving_grant = 
            e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.servingGrant.value;
        }

        WRRC_MSG2_HIGH("RRCEUL: ASU - grantSelector(P:1, S:2): %d, servingGrant: %d", 
          e_dl_info_ptr->grant_config.grant_selector, 
          e_dl_info_ptr->grant_config.serving_grant);

        rrcllc_update_l1_e_req_mask_for_e_dl_info(TRUE);
      }

      /* store beta-ec */
      if (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
            e_DPCCH_DPCCH_PowerOffsetPresent)
      )
      {
        e_ul_info_ptr->e_dpcch_info.e_dpcch_pwr_offset = 
          e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.e_DPCCH_DPCCH_PowerOffset;
        /* Since L1 parameters are present hence update the bit mask to indicate the same */
        rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);
      }

      /* store reference e-tfci's */
      if (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
                   reference_E_TFCIsPresent)
      )
      {
        /* store reference e-tfci's */
        if (FAILURE == rrcllcpcie_process_reference_e_tfcis(
            &e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.reference_E_TFCIs,
            &e_ul_info_ptr->e_dpdch_info))
        {
          return(FAILURE);
        }
        /* set bit-mask to indicate L1 that UL info is received */
        rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);
      }

      /* store po_sched_info */
      if (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
                     powerOffsetForSchedInfoPresent)
      )
      {
        mac_e_dpdch_info_ptr->sched_info_config.power_offset_of_si = 
            e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.powerOffsetForSchedInfo;

        rrcllc_update_mac_eul_action(TRUE);
      }

      /* store two and/or three index threshold */
      if ((RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
                  threeIndexStepThresholdPresent)) &&
          (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
                twoIndexStepThresholdPresent))      
      )
      {
        if (FAILURE == rrcllcpcie_process_two_and_three_step_threshold_info(
            RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
                threeIndexStepThresholdPresent),
            e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.threeIndexStepThreshold,
            RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
               twoIndexStepThresholdPresent),
            e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.twoIndexStepThreshold)
           )
        {
          return(FAILURE);
        }
      }

      psc = e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.
        primaryCPICH_Info.primaryScramblingCode;
  
      WRRC_MSG1_HIGH("RRCEUL: ASU- serving e-dch repointing to psc: %d", 
        psc);

      e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

      /* store hich info */
      if ((e_rl_idx < L1_MAX_EDCH_RL) && (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
                e_HICH_InformationPresent))
      )
      {
        if (FAILURE == rrcllcpcie_update_e_hich_info_and_mask(e_rl_idx, 
                                                              &e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.e_HICH_Information,
                                                              psc
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                            ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                            ))
        {
          return FAILURE;
        }
      }
      if((RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
                      e_RGCH_InfoPresent)) && 
            (RRC_CHECK_MSG_TYPE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.e_RGCH_Info,
        T_rrc_E_DCH_RL_InfoNewServingCell_e_RGCH_Info_e_RGCH_Information))
           )
        {
          e_rgch_ptr = e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.e_RGCH_Info.u.e_RGCH_Information;
        }
      else
        {
          /* This means that the E-RGCH Info IE is not present*/
          e_rgch_ptr = NULL;
        }
      /* store rgch info */
      if (FAILURE == rrcllcpcie_process_e_rgch_info(
        RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
               e_RGCH_InfoPresent),
        e_rgch_ptr,
        psc,
        /*We need to honor RGCH Rel Ind from OTA message, So pass TRUE*/
        TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
        ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
               ))
      {
        return(FAILURE);
      }

      /* store agch info */
      if (FAILURE == rrcllcpcie_process_e_agch_info(
        TRUE, 
        &e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.e_AGCH_Information,
        psc))
      {
        return(FAILURE);
      }

      if (FAILURE == rrcllcpcie_process_serving_e_dch_rl_indicator(
        TRUE,
        psc))
      {
        return(FAILURE);
      }

      if (FAILURE == rrcllcpcie_validate_hich_rgch_info(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
      , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */

      ))
      {
        return(FAILURE);
      }

      /* since AGCH is mandatory in this IE, hence minimum e_dl_info is reconfigured */
      rrcllc_update_l1_e_req_mask_for_e_dl_info(TRUE);

    }/* rrc_E_DCH_ReconfigurationInfo_e_DCH_RL_InfoNewServingCell_present */

    if (RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_reconfig_info_ptr,
                e_DCH_RL_InfoOtherCellListPresent)
    )
    {
      e_rl_info_other_cell_ptr = &(e_dch_reconfig_info_ptr->e_DCH_RL_InfoOtherCellList);
      n_value = e_rl_info_other_cell_ptr->n;
      n_index = 0;
      while(0 != n_value)
      {
        psc = e_rl_info_other_cell_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode;

        MSG_HIGH("RRCEUL: e-dch info -HICH: 0x%x, RGCH: 0x%x, updated for psc: %d", 
            (RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                    e_HICH_InfoPresent)), 
            (RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                   e_RGCH_InfoPresent)), 
             psc);

        if ((RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                    e_HICH_InfoPresent)) &&
            (RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                     e_RGCH_InfoPresent))
        )
        {
          is_e_dl_info_present = TRUE;
        }

        if((RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index],
                        e_HICH_InfoPresent))&&
            (RRC_CHECK_MSG_TYPE(e_rl_info_other_cell_ptr->elem[n_index].e_HICH_Info,
                            T_rrc_E_DCH_RL_InfoOtherCell_e_HICH_Info_e_HICH_Information)))
        {
          e_hich_info_ptr=e_rl_info_other_cell_ptr->elem[n_index].e_HICH_Info.u.e_HICH_Information;
        }
        else
        {
          e_hich_info_ptr=NULL;
        }

        if (FAILURE == rrcllcpcie_process_e_hich_info(
          RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                 e_HICH_InfoPresent),
          e_hich_info_ptr,
          psc,
        /*We need to honor HICH Rel Ind from OTA message, So pass TRUE*/
          TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
            , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
            ))
        {
          return(FAILURE);
        }

        if((RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index],
                     e_RGCH_InfoPresent)) && 
           (RRC_CHECK_MSG_TYPE(e_rl_info_other_cell_ptr->elem[n_index].e_RGCH_Info,
            T_rrc_E_DCH_RL_InfoOtherCell_e_RGCH_Info_e_RGCH_Information))
          )
        {
          e_rgch_ptr = e_rl_info_other_cell_ptr->elem[n_index].e_RGCH_Info.u.e_RGCH_Information;
        }
        else
        {
          /* This means that the E-RGCH Info IE is not present*/
          e_rgch_ptr = NULL;
        }
        if (FAILURE == rrcllcpcie_process_e_rgch_info(
          RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                  e_RGCH_InfoPresent), 
          e_rgch_ptr,
          psc,
        /*We need to honor RGCH Rel Ind from OTA message, So pass TRUE*/
          TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
          ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
           ))
        {
          return(FAILURE);
        }

        n_value--;
        n_index++;
      }
      
      if( ordered_config_ptr->l1_e_info.e_dl_info.num_e_dl_rl_add_recfg_info
            > RRC_EUL_MAX_RL)
      {
        WRRC_MSG1_ERROR("No of EDCh RL %d is more than 4 in Active set",
            ordered_config_ptr->l1_e_info.e_dl_info.num_e_dl_rl_add_recfg_info);
        return FAILURE;
      }
      /* update the l1_e_req_mask */
      rrcllc_update_l1_e_req_mask_for_e_dl_info(is_e_dl_info_present);
    } /* rrc_e_DCH_RL_InfoOtherCellList_present */
  }

  return(SUCCESS);
}

/*====================================================================
FUNCTION       get_mac_d_hfn_cucnf()

DESCRIPTION    This function takes a pointer to the cu_confirm_ptr for R5
                         and extract mac_d_hfn field.

DEPENDENCIES   None

RETURN VALUE   value of mac_d_hfn if present else, invalid value

====================================================================*/
uint32 get_mac_d_hfn_cucnf(rrc_CellUpdateConfirm_r5_IEs *cu_confirm_ptr)
{

  uint32 mac_d_hfn = RRCSMC_INVALID_HFN_VALUE;
  if (RRC_CHECK_MSG_TYPE_IE_PTR(cu_confirm_ptr,
              dl_CommonInformationPresent))
  {
    if(RRC_CHECK_MSG_TYPE_IE(cu_confirm_ptr->dl_CommonInformation,
               dl_DPCH_InfoCommonPresent))
    {
       (void)rrcrb_get_mac_d_hfn(
                RRC_CHECK_MSG_TYPE_IE(cu_confirm_ptr->dl_CommonInformation.dl_DPCH_InfoCommon,
                    mac_d_HFN_initial_valuePresent),
                &cu_confirm_ptr->dl_CommonInformation.dl_DPCH_InfoCommon.mac_d_HFN_initial_value,
                &mac_d_hfn);
    }
  }
  return (mac_d_hfn);
}

/*====================================================================
FUNCTION       get_prach_sys_info_list()

DESCRIPTION    This function takes a pointer to the PRACH system
               information list and copies all applicable IEs for
               MAC, RLC, and L1 into the ORDERED_CONFIG database
               (internal format).

DEPENDENCIES   None

RETURN VALUE   SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS   The current contents of ORDERED_CONFIG will be
               overwritten.
====================================================================*/

/*====================================================================
FUNCTION: RRCLLC_INIT_PRACH_IE_PTRS

DESCRIPTION:
  This function initializes fields of PRACH Config DB & adjusts the 
  embedded pointers.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_init_prach_ie_ptrs
(
  uint8 rrc_num_of_prach
)
{
  uint32 i = 0;
  uint8  ix = 0;

  for(; i < rrc_num_of_prach; i++)
  {

    if(prach_sel_info[i] == NULL)
    {
      ERR_FATAL("PRACH_OPT: Null Pointer for %d PRACH in prach_sel_info",i,0,0);
    }

    memset((void *)prach_sel_info[i], 0, sizeof(rrcllc_prach_sel_info_type)); 

    for(; ix < UE_MAX_TRCH; ix++)
    {
      /* L1 UL Semi static parameter data pointers */
      prach_sel_info[i]->l1_ul_cctrch_parms.semi_static_parms_ptr[ix] =
          &prach_sel_info[i]->semi_static_parms[ix];
    } 

    for(ix = 0; ix < L1_UL_TFC_MAX; ix++)
    {
      /* Init the UL Gain Factors that are TFC specific */
      prach_sel_info[i]->l1_ul_cctrch_parms.gain_factor_parms_ptr[ix] =
          &prach_sel_info[i]->gain_factor_parms[ix];
    } /* end TFC initialization */
  }

  WRRC_MSG0_HIGH("Initialized internal PRACH dB");
} /* rrcllc_init_prach_ie_ptrs */

/*====================================================================
FUNCTION: RRCLLC_UPDATE_OC_WITH_PRACH_INFO

DESCRIPTION:
  This function updates OC with PRACH data.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_update_oc_with_prach_info
(
  ordered_config_type *config_ptr,
  rrcllc_prach_sel_info_type *prach_sel_info_ptr
)
{
  uint8   ix;  
  uint8   trch_idx;
  uint8   num_of_asc = 1;
  uint8   asc_idx;
  uint32  pval = 0;
#ifdef FEATURE_WCDMA_RRC_APPLY_WEIGHT_FOR_ASC0_PVAL
  uint32 weight = 0xFFFF / 10;
#endif
  /* Indicate to uplink that the current channel is a PRACH */
  config_ptr->l1_ul_cctrch_parms.chan = L1_UL_PHYCHAN_PRACH;

  /* Though some IE contents were extracted
     for L1 PRACH TTI selection earlier, all the 
     IEs are again extracted to OC for convenience */

  if(prach_sel_info_ptr->persistence_scaling_factor_list == NULL)
  {
    (void)get_persist_scaling_default_factors(config_ptr);
  }

  if(prach_sel_info_ptr->aich_info != NULL &&
     prach_sel_info_ptr->ac_to_asc_mapping_table != NULL && 
     prach_sel_info_ptr->tfcs != NULL &&
     prach_sel_info_ptr->rach_info != NULL &&
     prach_sel_info_ptr->rach_tfs != NULL &&  
     prach_sel_info_ptr->prach_partitioning != NULL &&
     prach_sel_info_ptr->primary_cpich_tx_power != NULL && 
     prach_sel_info_ptr->prach_pow_offset != NULL && 
     prach_sel_info_ptr->rach_transmission_parms != NULL)  
  {
    (void)get_prach_rach_info(&config_ptr->l1_ul_chan_parms.prach_cfg, prach_sel_info_ptr->rach_info);
    trch_idx = rrcllc_get_ul_rach_trch_idx(config_ptr, (tr_ch_id_type)(prach_sel_info_ptr->transport_channel_id));
    if(trch_idx < UE_MAX_TRCH)
    {
      (void)get_ul_transport_format_set(config_ptr, prach_sel_info_ptr->rach_tfs, trch_idx);
    }
    else
    {
      WRRC_MSG1_ERROR(" Invalid Trch index for Trch id %d",prach_sel_info_ptr->transport_channel_id);
    }
    (void)get_ul_tfcs_info(config_ptr, prach_sel_info_ptr->tfcs); 

    WRRC_MSG2_MED("Update l1 with UL Trch info num tfci in L1 %d, numtfci in RRC DB %d",
        config_ptr->l1_ul_cctrch_parms.num_tfci,
        config_ptr->rrc_ul_cctrch_params.num_tfci);
    
    config_ptr->l1_ul_cctrch_parms.num_tfci = config_ptr->rrc_ul_cctrch_params.num_tfci;
      
    (void)get_prach_partitioning(config_ptr->asc_info, &config_ptr->l1_ul_chan_parms.prach_cfg, 
        prach_sel_info_ptr->prach_partitioning, &num_of_asc);

    if(prach_sel_info_ptr->persistence_scaling_factor_list != NULL)
    {
      (void)get_persist_scaling_factors(config_ptr, prach_sel_info_ptr->persistence_scaling_factor_list);
    }

    (void)get_ac_to_asc_mapping(config_ptr, prach_sel_info_ptr->ac_to_asc_mapping_table); 
    (void)get_primary_cpich_tx_pwr(&config_ptr->rrc_ul_pwr_init_parms, prach_sel_info_ptr->primary_cpich_tx_power);
    (void)get_constant_value(&config_ptr->rrc_ul_pwr_init_parms, prach_sel_info_ptr->constant_value);
    (void)get_prach_pwr_offset(config_ptr, prach_sel_info_ptr->prach_pow_offset);
    (void)get_rach_xmit_parms(config_ptr, prach_sel_info_ptr->rach_transmission_parms);
    (void)get_aich_info(config_ptr, prach_sel_info_ptr->aich_info);
    
    /* Give L1 the number of ASCs rcv'd over the air */
    config_ptr->l1_ul_chan_parms.prach_cfg.asc_cfg.num_asc = (uint8)num_of_asc;

    /* Setup the Persistence values for all ASCs */
    /*ASC_IDX ranges from 0 to 7 which needs to be mapped to persitence
      value Pi(1 to 0) according to spec: 8.5.12. Pi is maintained internally
      as (0xFFFF to 0) so ASC_IDX(0 to 7) -> pval(0xFFFF to 0)*/
    for(asc_idx = 0; ((asc_idx < num_of_asc)&& (asc_idx < MAX_ASC)); asc_idx++)
    {
      switch(asc_idx)
      {
        case 0:
#ifndef FEATURE_WCDMA_RRC_APPLY_SAME_WEIGHT_FOR_ASC0_ASC1
          pval = RRCLLC_PVAL_MULTIPLICATION_FACTOR;
          break;
#endif
        case 1:
          pval = RRCLLC_PVAL_MULTIPLICATION_FACTOR>>(config_ptr->dpl - 1);
          break;
        default:
          /*psf from spec goes from 0.9..0.2, we have scaled it to 9...2(factor of 10), this is why we 
              divide by RRCLLC_DEFAULT_PERSISTENCE_SCALING_FACTOR_VAL*/
          pval = ((RRCLLC_PVAL_MULTIPLICATION_FACTOR >>(config_ptr->dpl - 1)) *
                  config_ptr->psf[asc_idx - 2])/
                  RRCLLC_DEFAULT_PERSISTENCE_SCALING_FACTOR_VAL; 
          break;
      }
      config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[asc_idx].pval = pval;
#ifdef FEATURE_WCDMA_RRC_APPLY_WEIGHT_FOR_ASC0_PVAL
      if (asc_idx == 0)
      {
        /*Apply weight for ASC0 also*/
        config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[asc_idx].pval =
          0xFFFF - weight + (weight / (1 << (config_ptr->dpl - 1)));
      }
#endif
    }

    /* Indicate the number of Access Service Classes supported */
    config_ptr->mac_ul_parms.rach_tx_cntl_info.nASC = num_of_asc;
    MSG_9(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"Num of Asc: %d  ASC0-pval: %d ASC1-pval: %d ASC2-pval: %d ASC3-pval: %d ASC4-pval: %d ASC5-pval: %d ASC6-pval: %d ASC7-pval: %d ",
                                         num_of_asc,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[0].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[1].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[2].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[3].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[4].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[5].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[6].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[7].pval
                                         );

    (void)select_asc_from_ac(config_ptr);
    if((prach_sel_info_ptr->rrc_additional_prach_TF_list != NULL)
      && (trch_idx < UE_MAX_TRCH ) )
    {
      rrcllc_compute_additional_prach_tf(prach_sel_info_ptr->rrc_additional_prach_TF_list ,config_ptr,trch_idx);
    }

    /* Calculate the UL TFCS for the RACH */
    compute_ul_tfis_from_ctfc(&config_ptr->ul_tfcs);

    config_ptr->mac_ul_parms.tfcs_ptr = &config_ptr->ul_tfcs;
    config_ptr->mac_ul_parms.cctrch_ptr = &config_ptr->ul_cctrch;
    
    for(ix = 0 ; ix < UE_MAX_TRCH; ix++)
    {
      /* L1 UL Semi static parameter data pointers */
      config_ptr->l1_ul_cctrch_parms.semi_static_parms_ptr[ix] =
        &config_ptr->rrc_ul_cctrch_params.semi_static_parms[ix];
    }

    for(ix = 0; ix < L1_UL_TFC_MAX; ix++)
    {
      /* Init the UL Gain Factors that are TFC specific */
      config_ptr->l1_ul_cctrch_parms.gain_factor_parms_ptr[ix] =
        &config_ptr->rrc_ul_cctrch_params.gain_factor_parms[ix];

    } /* end TFC initialization */

    /* Init the ASC data pointers */
    for(ix = 0; ix < MAX_ASC; ix ++)
    { 
      config_ptr->l1_ul_chan_parms.prach_cfg.asc_cfg.asc_info_ptr[ix] =
        &config_ptr->asc_info[ix];
    } /* end ASC initialization */
  }
  else 
  { 
    ERR_FATAL("This shouldn't happen .. something fishy in extracting PRACH Info from SIB5/6", 0,0,0);
  } 

  WRRC_MSG0_HIGH("Updated OC with PRACH specific info");
}/* rrcllc_update_oc_with_prach_info */

/*====================================================================
FUNCTION: rrcllcpcie_copy_to_prach_type

DESCRIPTION:
  This function copies PRACH info from OC to new PRACH working DB.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllcpcie_copy_to_prach_type
(
  prach_config_type *prach_ptr,
  ordered_config_type *oc_ptr
)
{
  uint8 ix;

  for(ix=0; ix < UE_MAX_TRCH; ix++)
  {
    prach_ptr->ul_rach_trch_info[ix] = oc_ptr->ul_rach_trch_info[ix];
      prach_ptr->ul_rach_trch_idx_in_use[ix] = oc_ptr->ul_rach_trch_idx_in_use[ix];
  }
  
  prach_ptr->prach_cfg = oc_ptr->l1_ul_chan_parms.prach_cfg;
  
  for(ix = 0; ix < MAX_ASC; ix++)
  {
    prach_ptr->asc_info[ix] = oc_ptr->asc_info[ix];
      prach_ptr->prach_cfg.asc_cfg.asc_info_ptr[ix] = &prach_ptr->asc_info[ix];
  }
  
  return;
}

/*====================================================================
FUNCTION: rrcllc_update_prach_l1_selection_info_for_prach_db

DESCRIPTION:
  This function updates PRACH specific DB with fields of interest
  that are used for choosing PRACH 10 msecs or 20 msecs TTI.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
LOCAL void rrcllc_update_prach_l1_selection_info_for_prach_db
(
  rrcllc_prach_sel_info_type *prach_sel_info_ptr,
  rrcllcoc_l1_ul_init_pwr_type    * rrc_ul_pwr_init_parms
)
{
  uint8  ix = 0;

  prach_sel_info_ptr->rrc_ul_pwr_init_parms.ul_interference = (int8)rrc_ul_pwr_init_parms->ul_interference;

  WRRC_MSG1_HIGH("UL interference in new PRACH DB = %d",rrc_ul_pwr_init_parms->ul_interference);

  for(; ix < UE_MAX_TRCH; ix++)
  {
   /* L1 UL Semi static parameter data pointers */
    prach_sel_info_ptr->l1_ul_cctrch_parms.semi_static_parms_ptr[ix] =
      &prach_sel_info_ptr->semi_static_parms[ix];
  }

  for(ix = 0; ix < L1_UL_TFC_MAX; ix++)
  {
    /* Init the UL Gain Factors that are TFC specific */
    prach_sel_info_ptr->l1_ul_cctrch_parms.gain_factor_parms_ptr[ix] =
      &prach_sel_info_ptr->gain_factor_parms[ix];
  } /* end TFC initialization */

} /* rrcllc_update_prach_l1_selection_info */

/*====================================================================
FUNCTION: get_prach_sys_info_list

DESCRIPTION:
  This function populates the prach system information from the SIB5/6

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type get_prach_sys_info_list
(
  rrc_PRACH_SystemInformationList   *prach_sys_info_ptr,
  ordered_config_type               *oc_config_ptr,
  uint8  rrc_num_of_prach
  ,rrc_AdditionalPRACH_TF_and_TFCS_CCCH_List * rrc_additional_prach_TF_list   
  ,boolean is_sib6_in_use
)
{
  uint8  trch_idx;   /* Local TrCH index */
  uint8  num_of_prach = 1;   /* count of the number of PRACHs included */
  uint8  num_of_asc = 1; /* count of the number of Access Service Classes (ASC) included */
  rrc_TransportFormatSet              *prev_prach_tfs_ie_ptr=NULL;
  rrc_TFCS                            *prev_prach_tfcs_ie_ptr = NULL;
  rrc_PRACH_Partitioning              *prev_prach_partitioning_ie_ptr = NULL;
  struct rrc_AC_To_ASC_MappingTable   *prev_ac_to_asc_mapping_ie_ptr = NULL;
  struct rrc_PersistenceScalingFactorList *prev_prach_persistencesf_list_ie_ptr = NULL;
  rrc_PrimaryCPICH_TX_Power           prev_prach_primary_cpich_tx_pwr = -1;
  rrc_ConstantValue                   prev_prach_constant_value = -1;
  rrc_PRACH_PowerOffset               *prev_prach_power_offset_ie_ptr = NULL;
  rrc_RACH_TransmissionParameters     *prev_prach_tx_params_ie_ptr = NULL;
  rrc_AICH_Info                       *prev_prach_aich_info_ie_ptr = NULL;
  rrc_PRACH_SystemInformationList   *ie_ptr = prach_sys_info_ptr;   /* local PRACH System Info pointer */
  uint32 n_index, n_value;
  uint32 n_value_prach_TF_list;

  if(ie_ptr == NULL)
  {
    WRRC_MSG0_ERROR("PRACH System Info not present");
    return(FAILURE);
  }

  MSG_MED("Reading SIB PRACH Sys Info",0,0,0);

  /*---------------------------------------------------------------
  * Initialize the values of where the PRACH's index would be
  * stored
  ----------------------------------------------------------------*/
  prach_status_info.current_10ms_tti_prach_index = 0;
  prach_status_info.current_20ms_tti_prach_index = 0;
  prach_status_info.num_valid_prachs_found = 0;

  rrcllc_init_prach_ie_ptrs(rrc_num_of_prach);

  /*
  * Note that the ASN.1 generates a Linked List. Hence, loop until the
  * the end of the list. Also make sure that not more than UE_MAX_PRACH
  * linked elements are included.
  */
  if(rrc_additional_prach_TF_list == NULL)
    n_value_prach_TF_list = 0;
  else
    n_value_prach_TF_list = rrc_additional_prach_TF_list->n;

  n_value = ie_ptr->n;
  n_index = 0;
  
  for(; ((n_value != 0) && (num_of_prach <= rrc_num_of_prach) && (num_of_prach <= UE_MAX_PRACH)); n_value--, n_index++)
  {

    if(prach_sel_info[num_of_prach-1] == NULL)
    {
      ERR_FATAL("PRACH_OPT: Null Pointer for %d PRACH in prach_sel_info",num_of_prach,0,0);
    }

    num_of_asc = 1;

    /* Save copies of this Transport Channel ID and Index to Ordered Config */
    if(((tr_ch_id_type)ie_ptr->elem[n_index].transportChannelIdentity >
        RRCLLC_TRCH_ID_MAX_VALUE) ||
       ((tr_ch_id_type)ie_ptr->elem[n_index].transportChannelIdentity <
        RRCLLC_TRCH_ID_MIN_VALUE))
    {
      WRRC_MSG1_ERROR("invalid TrCH ID %d",
          (tr_ch_id_type)ie_ptr->elem[n_index].transportChannelIdentity);
      continue;
    }

    memset(&prach_working_db, 0x0, sizeof(prach_config_type));
    rrcllcpcie_copy_to_prach_type(&prach_working_db, oc_config_ptr);
    prach_sel_info[num_of_prach-1]->l1_ul_cctrch_parms.chan = L1_UL_PHYCHAN_PRACH;  

    /* Only need FDD for PRACH to RACH info */
    if(get_prach_rach_info(&prach_working_db.prach_cfg, &ie_ptr->elem[n_index].prach_RACH_Info) == FAILURE)
    {
      continue;
    }    
 
    /* Get the transport channel Index */
    if((trch_idx = rrcllc_get_ul_rach_trch_idx_for_prach_db(&prach_working_db, prach_sel_info[num_of_prach-1], 
          (tr_ch_id_type)ie_ptr->elem[n_index].transportChannelIdentity)) >= UE_MAX_TRCH)
    {
      continue;
    }    

    /* Only need FDD for TFS */
    if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index], 
              rach_TransportFormatSetPresent))
    {
      /* Get all the RACH TFS data */
      MSG_MED("Get UL TFS for TrCH ID %d", ie_ptr->elem[n_index].transportChannelIdentity,0,0);
    
      if(get_ul_transport_format_set_for_prach_db(prach_sel_info[num_of_prach-1], 
        &ie_ptr->elem[n_index].rach_TransportFormatSet, trch_idx) == FAILURE)
      {
        continue;
      }

      /* Store the value of this ie*/
      prev_prach_tfs_ie_ptr = &ie_ptr->elem[n_index].rach_TransportFormatSet;
    }
    else  /* RACH TFS not present */
    {
      /* For the first PRACH it is MP, for the next, pick it from the
       * previous one.
       */
      if(num_of_prach == 1)
      {
        WRRC_MSG0_ERROR("RACH TFS absent for 1st PRACH");
        continue;
      }
      else
      {
        if (prev_prach_tfs_ie_ptr != NULL)
        {
          if(get_ul_transport_format_set_for_prach_db(prach_sel_info[num_of_prach-1], prev_prach_tfs_ie_ptr, trch_idx)
              == FAILURE)
          {
            /* The IE was not included, copy from the previous IE */
            WRRC_MSG0_ERROR("Copy from Previous PRACH TFS data failed");
            continue;
          }
        }
        else
        {
            /* The IE was not included, copy from the previous IE */
            WRRC_MSG0_ERROR("Previous PRACH TFS data not available");
            continue; 
        }
      }
    } /* RACH TFS not present */    

    /* Only need FDD for TFCS */
    if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
            rach_TFCSPresent))
    {
      /* Get all the RACH TFCS data */
      MSG_MED("Get UL TFCS",0,0,0);
      
      if(get_ul_tfcs_info_for_prach_db(prach_sel_info[num_of_prach-1], &ie_ptr->elem[n_index].rach_TFCS)
          == FAILURE)
      {
        continue;
      }
      prev_prach_tfcs_ie_ptr = &ie_ptr->elem[n_index].rach_TFCS;
    }
    else
    {
      /* For the first PRACH it is MP, for the next, pick it from the
       * previous one.
       */
      if(num_of_prach == 1)
      {
        WRRC_MSG0_ERROR("RACH TFCS absent for 1st PRACH");
        continue;
      }
      else
      {
        if (prev_prach_tfcs_ie_ptr != NULL)
        {
            if(get_ul_tfcs_info_for_prach_db(prach_sel_info[num_of_prach-1], prev_prach_tfcs_ie_ptr)
              == FAILURE)
            {
              /* The IE was not included, copy from the previous IE */
              WRRC_MSG0_ERROR("Copy from previous PRACH TFCS data failed");
              continue;
            }
        }
        else
        {
            /* The IE was not included, copy from the previous IE */
            WRRC_MSG0_ERROR("Previous PRACH TFCS data not available");
            continue;
        }
      }
    }    

    /* Get the PRACH partioning information, as this is per ASC */
    if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
             prach_PartitioningPresent))
    {
      /* We now have the number of ASCs supported. */
      if(get_prach_partitioning(prach_working_db.asc_info, &prach_working_db.prach_cfg, 
        &ie_ptr->elem[n_index].prach_Partitioning, &num_of_asc) == FAILURE)
      {
        /* Bad values in this IE */
        continue;
      }
      prev_prach_partitioning_ie_ptr = &ie_ptr->elem[n_index].prach_Partitioning;
    } /* end if IE present and FDD mode chosen */
    else
    {
      if(num_of_prach == 1)
      {
        WRRC_MSG0_ERROR("PRACH partitioning data absent for 1st PRACH");
        continue;
      }
      else
      {
        if (prev_prach_partitioning_ie_ptr != NULL)
        {
              /* We now have the number of ASCs supported. */
              if(get_prach_partitioning(prach_working_db.asc_info, &prach_working_db.prach_cfg, 
                prev_prach_partitioning_ie_ptr, &num_of_asc) == FAILURE)
              {
                /* The IE was not included, copy from the previous IE */
                WRRC_MSG0_ERROR("Copy from previous PRACH PARTITIONING data failed");
                continue;
              }
        }
        else
        {
            WRRC_MSG0_ERROR("Previous PRACH PARTITIONING data not available");
            continue;
        }
      }
    }
    /* end Partitioning data */    

    prach_working_db.prach_cfg.asc_cfg.num_asc = (uint8)num_of_asc;

    /*
    * If there are more than 2 access service classes, then we get all
    * the Persistence value stuff.
    */
    if(num_of_asc > 2)
    {
      if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                  persistenceScalingFactorListPresent))
      {
        prev_prach_persistencesf_list_ie_ptr = &ie_ptr->elem[n_index].persistenceScalingFactorList;
      } /* persistence scaling factor is present */
      else
      {
        if(num_of_prach == 1)
        {
          WRRC_MSG0_HIGH("Ignoring absence of Persistence sclng factor");
        }
        else
        {
          if (prev_prach_persistencesf_list_ie_ptr == NULL)
          {
            WRRC_MSG0_ERROR("Previous PRACH persistence scaling factors not available");
            continue;
          }
        }
      } /* Persistence scaling factor list is not present */
    }  /* Number of ASC > 2 */

    /* get the AC to ASC Mapping info */
    if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                ac_To_ASC_MappingTablePresent))
    {
      prev_ac_to_asc_mapping_ie_ptr = &ie_ptr->elem[n_index].ac_To_ASC_MappingTable;
    }
    else
    {
      if(num_of_prach == 1)
      {
        if(is_sib6_in_use)		
        {
          rrc_SysInfoType5	*sib5_ptr = NULL;
        	
          sib5_ptr = (rrc_SysInfoType5 *)rrc_sibdb_return_sib_for_srv_cell(rrc_SIB5);
            
          if (sib5_ptr == NULL)
          {
             WRRC_MSG0_ERROR("SIB 5 not yet in SIB data base");
             return FAILURE;
          }
    
          /*In connected mode we always need to get the ASC info from SIB5
            But to make our design as close as legacy we are trying to pick the asc info from SIB6 if present
            else pick from sib5 first index.
            spec section 10.3.6.55 AC-to-ASC mapping CV-SIB5-MD Only present in SIB 5 and in SIB 5bis*/
          if(RRC_CHECK_MSG_TYPE_IE(sib5_ptr->prach_SystemInformationList.elem[0],ac_To_ASC_MappingTablePresent))
          {
            prev_ac_to_asc_mapping_ie_ptr = &(sib5_ptr->prach_SystemInformationList.elem[0].ac_To_ASC_MappingTable);
          }
          else
          {
            WRRC_MSG0_ERROR("ASC-to-AC mapping not present in in first prach of SIB5 not expected configuration");
            continue;
          }
        }
        else
        {
          /* Ignore at this point if ASC to AC mapping is absent.
           * It is not used at present. Need to change spec to make it an MP for
           * 1st PRACH.
           */
          WRRC_MSG0_HIGH("Ignoring absence of ASC-to-AC mapping");
        }
      }
      else
      {
        if (prev_ac_to_asc_mapping_ie_ptr == NULL)
        {
          /* The IE was not included, copy from the previous IE */
          WRRC_MSG0_ERROR("No previous ACCESS SERVICE CLASS MAPPING data to get");
          continue;
        }
      }
    }
    /* end AC to ASC mapping */    

    /* Make sure we have FDD parameters or else report a failure */
    if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index].modeSpecificInfo,
                             T_rrc_PRACH_SystemInformation_modeSpecificInfo_fdd))
    {
      /* Get the Primary CPICH TX power */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->elem[n_index].modeSpecificInfo.u.fdd,
                 primaryCPICH_TX_PowerPresent))
      {
        if(get_primary_cpich_tx_pwr(&prach_sel_info[num_of_prach-1]->rrc_ul_pwr_init_parms, 
          ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_TX_Power)
          == FAILURE)
        {
          continue;
        }
        prev_prach_primary_cpich_tx_pwr = ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_TX_Power;
      }
      else  /* Primary CPICH power data not present */
      {
        if(num_of_prach == 1)
        {
          WRRC_MSG0_ERROR("Pri CPICH Tx Power absent for 1st PRACH");
          continue;
        }
        else
        {
          if (prev_prach_primary_cpich_tx_pwr != -1)
          {
            prach_sel_info[num_of_prach-1]->rrc_ul_pwr_init_parms.primary_cpich_tx_power = 
              (int) prev_prach_primary_cpich_tx_pwr;
          /* get from the previous element */
            WRRC_MSG0_HIGH("Copy from previous Pri CPICH TX power");
          }
          else
          {
            WRRC_MSG0_ERROR("Previous CPICH Tx power value not found");
            continue;
          }
        }
      }

      /* Get the Constant Value */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->elem[n_index].modeSpecificInfo.u.fdd,
                    constantValuePresent))
      {
        if(get_constant_value(&prach_sel_info[num_of_prach-1]->rrc_ul_pwr_init_parms, 
          ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->constantValue)
          == FAILURE)
        {
          continue;
        }
        prev_prach_constant_value = ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->constantValue;
      }
      else
      {
        if(num_of_prach == 1)
        {
          WRRC_MSG0_ERROR("Constant value absent for 1st PRACH");
          continue;
        }
        else
        {
          if (prev_prach_constant_value != -1)
          {
            prach_sel_info[num_of_prach-1]->rrc_ul_pwr_init_parms.constant_value = (int)prev_prach_constant_value;
          /* get from the previous element */
            WRRC_MSG0_HIGH("Copy from previous constant value");
          }
          else
          {
            WRRC_MSG0_ERROR("Previous PRACH does not have constant value");
          }
        }
      }

      /* Get the PRACH Power Offset Info */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->elem[n_index].modeSpecificInfo.u.fdd,
                    prach_PowerOffsetPresent))
      {
        prev_prach_power_offset_ie_ptr = &ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->prach_PowerOffset;
      }
      else
      {
        if(num_of_prach == 1)
        {
          /* MP element is absent */
          WRRC_MSG0_ERROR("PRACH Power Offset data absent for 1st PRACH");
          continue;
        }
        else
        {
          if (prev_prach_power_offset_ie_ptr == NULL)
          {
            /* get from the previous element */
            WRRC_MSG0_ERROR("Previous PRACH Power Offset data is not available");
            continue;
          }
        }
      }
     

      /* Get the PRACH Transmission Parameters */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->elem[n_index].modeSpecificInfo.u.fdd,
                    rach_TransmissionParametersPresent))
      {
        prev_prach_tx_params_ie_ptr = &ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->rach_TransmissionParameters;
      }
      else
      {
        if(num_of_prach == 1)
        {
          /* MP element is absent */
          WRRC_MSG0_ERROR("RACH Xmit parms absent for 1st PRACH");
          continue;
        }
        else
        {
          if (prev_prach_tx_params_ie_ptr == NULL)
          {
            /* get from the previous element */
            WRRC_MSG0_ERROR("Previous RACH Xmit parms not available");
            continue;
          }
        }
      }
      

      /* Get the AICH information */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->elem[n_index].modeSpecificInfo.u.fdd,
                  aich_InfoPresent))
      {
        MSG_MED("Get AICH Info",0,0,0);
        prev_prach_aich_info_ie_ptr = &ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->aich_Info;
      }
      else  /* AICH Info not present */
      {
        if(num_of_prach == 1)
        {
          WRRC_MSG0_ERROR("AICH info absent for 1st PRACH");
          continue;
        }
        else
        {
          if (prev_prach_aich_info_ie_ptr == NULL)
          {
          
            // get from the previous element
            WRRC_MSG0_ERROR("Previous AICH Info not available");
            continue;
          }
        }
      }
    } /* end fdd mode specific info check */
    else /* must be TDD */
    {
      continue;
    }
    
    if (prach_sel_info[num_of_prach-1]->ul_tfcs.tfs_info[0].tti_info
          == L1_TTI_10MS)
    {
      if(prach_status_info.current_10ms_tti_prach_index < UE_MAX_PRACH)
      {
        WRRC_MSG2_HIGH("Found 10ms PRACH, putting %d prach in index %d",
               (num_of_prach-1),prach_status_info.current_10ms_tti_prach_index);
        prach_10ms_tti_index_array[prach_status_info.current_10ms_tti_prach_index++] =
          num_of_prach-1;
      }
    }
    else
    {
      if(prach_status_info.current_20ms_tti_prach_index < UE_MAX_PRACH)
      {
        WRRC_MSG2_HIGH("Found 20ms PRACH, putting %d prach in index %d",
               (num_of_prach-1),prach_status_info.current_20ms_tti_prach_index);
        prach_20ms_tti_index_array[prach_status_info.current_20ms_tti_prach_index++] =
        num_of_prach-1;
      }
    }

    rrcllc_update_prach_l1_selection_info_for_prach_db(prach_sel_info[num_of_prach-1], 
      &oc_config_ptr->rrc_ul_pwr_init_parms);    
    
    /* Record sub-IE pointers */
    prach_sel_info[num_of_prach-1]->rach_info = &ie_ptr->elem[n_index].prach_RACH_Info;
    prach_sel_info[num_of_prach-1]->transport_channel_id = ie_ptr->elem[n_index].transportChannelIdentity;
    prach_sel_info[num_of_prach-1]->rach_tfs = prev_prach_tfs_ie_ptr;
    prach_sel_info[num_of_prach-1]->tfcs = prev_prach_tfcs_ie_ptr;
    prach_sel_info[num_of_prach-1]->prach_partitioning = prev_prach_partitioning_ie_ptr;
    prach_sel_info[num_of_prach-1]->persistence_scaling_factor_list = prev_prach_persistencesf_list_ie_ptr;
    prach_sel_info[num_of_prach-1]->ac_to_asc_mapping_table = prev_ac_to_asc_mapping_ie_ptr;
    prach_sel_info[num_of_prach-1]->primary_cpich_tx_power =   prev_prach_primary_cpich_tx_pwr;
    prach_sel_info[num_of_prach-1]->constant_value =   prev_prach_constant_value;
    prach_sel_info[num_of_prach-1]->prach_pow_offset =   prev_prach_power_offset_ie_ptr;
    prach_sel_info[num_of_prach-1]->rach_transmission_parms = prev_prach_tx_params_ie_ptr;
    prach_sel_info[num_of_prach-1]->aich_info = prev_prach_aich_info_ie_ptr;
    if(n_index < n_value_prach_TF_list ) 
    {
      if (RRC_CHECK_MSG_TYPE_IE(rrc_additional_prach_TF_list->elem[n_index],
                  additionalPRACH_TF_and_TFCS_CCCH_IEsPresent))
      {
        WRRC_MSG1_HIGH("ATF: ATF info present for prach %d", num_of_prach);
         prach_sel_info[num_of_prach -1]->rrc_additional_prach_TF_list = &rrc_additional_prach_TF_list->elem[n_index].
            additionalPRACH_TF_and_TFCS_CCCH_IEs;
      }
      else
      {
         prach_sel_info[num_of_prach -1]->rrc_additional_prach_TF_list = NULL;
      }
    }
    else
    {
      prach_sel_info[num_of_prach -1]->rrc_additional_prach_TF_list = NULL;
    }

    /* get the next element in the linked list */
    num_of_prach++;
  } 
  /* end while loop processing PRACH System Information IEs */

  if (num_of_prach == 1)
  {
    WRRC_MSG0_ERROR("Could not find any valid PRACH for this cell");
    return(FAILURE);
  }

  prach_status_info.num_valid_prachs_found = num_of_prach - 1;
  WRRC_MSG1_HIGH("Number of PRACH's populated for this cell %d", num_of_prach-1);

  return SUCCESS;

} /* end get_prach_sys_info_list() */


/*============================================================================
FUNCTION: rrcllc_validate_t_barred_criteria_for_aich_info

DESCRIPTION:
  This validates PRACH info from SIB5/6 and checks to see if it meets
  T-Barred criteria.

DEPENDENCIES:
  None.

RETURN VALUE:
SUCCESS: Indicates that Cell contains atleast AICH info hence don't bar it
FAILURE: Indicates that none of Prach info contains AICH.  Hence bar the cell

SIDE EFFECTS:
  None.
==============================================================================*/
uecomdef_status_e_type rrcllc_validate_t_barred_criteria_for_aich_info
(
  rrc_PRACH_SystemInformationList   *prach_sys_info_ptr
)
{
  /* local PRACH System Info pointer */
  rrc_PRACH_SystemInformationList   *ie_ptr = prach_sys_info_ptr;

  /* count of the number of PRACHs included */
  uint8                               num_of_prach = 1;
  uint32 n_index, n_value;

  if(ie_ptr == NULL)
  {
    WRRC_MSG0_ERROR("PRACH System Info not present");
    return(FAILURE);
  }

  n_value = ie_ptr->n;
  n_index = 0;
  
  while((n_value != 0) && (num_of_prach <= UE_MAX_PRACH))
  {

    if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index].modeSpecificInfo,
                T_rrc_PRACH_SystemInformation_modeSpecificInfo_fdd))
    {
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->elem[n_index].modeSpecificInfo.u.fdd,
                aich_InfoPresent))
      {
        return SUCCESS;
      }
    }

    /* get the next element in the linked list */
    num_of_prach++;
    n_value--;
    n_index++;
  }

  /* if we come this far, then we did not have a single Prach-Sys-Info-List with AICH info.
     hence this cell is a prime candidate to be barred
   */ 
  WRRC_MSG0_HIGH("AICH System Info not present");
  return FAILURE;
}
/*============================================================================
FUNCTION: rrcllc_validate_t_barred_criteria_for_pich_info

DESCRIPTION:
  This validates SCCPCH info from SIB5/6 and checks to see if it meets
  T-Barred criteria.

DEPENDENCIES:
  None.

RETURN VALUE:
SUCCESS: Indicates that Cell contains atleast PICH info hence don't bar it
FAILURE: Indicates that none of SCCPCH info contains PICH. Hence bar the cell

SIDE EFFECTS:
  None.
==============================================================================*/
uecomdef_status_e_type rrcllc_validate_t_barred_criteria_for_pich_info
(
  rrc_SCCPCH_SystemInformationList *sccpch_sys_info_ptr
)
{
  /* local PRACH System Info pointer */
  rrc_SCCPCH_SystemInformationList *ie_ptr = sccpch_sys_info_ptr;
  uint32 n_index, n_value;

  /* count of the number of SCCPCH included */
  uint8                               num_of_sccpch = 1;

  if(ie_ptr == NULL)
  {
    WRRC_MSG0_ERROR("SCCPCH System Info not present");
    return(FAILURE);
  }

  n_value = ie_ptr->n;
  n_index = 0;
    
  while((n_value != 0) && (num_of_sccpch <= UE_MAX_SCCPCH))
  {

    if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                pich_InfoPresent))
    {
      return SUCCESS;
    }
    
    /* get the next element in the linked list */
    num_of_sccpch++;
    n_value--;
    n_index++;
  }

  /* if we come this far, then we did not have a single Prach-Sys-Info-List with AICH info.
     hence this cell is a prime candidate to be barred
   */ 
  WRRC_MSG0_HIGH("PICH System Info not present");
  return FAILURE;
}
/*====================================================================
FUNCTION       get_prach_sys_info()

DESCRIPTION    This function takes a pointer to the PRACH system
               information list and copies all applicable IEs for
               MAC, RLC, and L1 into the ORDERED_CONFIG database
               (internal format).

DEPENDENCIES   None

RETURN VALUE   SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS   The current contents of ORDERED_CONFIG will be
               overwritten.
====================================================================*/

static uecomdef_status_e_type get_prach_sys_info_for_one_prach
(
  ordered_config_type *config_ptr,
  rrc_PRACH_SystemInformationList *prach_sys_info_ptr
  ,rrc_AdditionalPRACH_TF_and_TFCS_CCCH_List * rrc_additional_prach_TF_list 
  ,boolean is_sib6_in_use
)
{

  /* Local TrCH index */
  uint8                             trch_idx;

  /* count of the number of PRACHs included */
  uint8                               num_of_prach = 1;

  /* count of the number of Access Service Classes (ASC) included */
  uint8                               num_of_asc = 1;

  /* index of ASCs for calculation of Persistence values */
  uint8                               asc_idx;

  /* calculated Persistence value */
  uint32                              pval = 0;
#ifdef FEATURE_WCDMA_RRC_APPLY_WEIGHT_FOR_ASC0_PVAL
  uint32 weight = 0xFFFF / 10;
#endif
  /* local PRACH System Info pointer */
  rrc_PRACH_SystemInformationList   *ie_ptr = prach_sys_info_ptr;
  uint32 n_index, n_value;
  uint32 n_value_prach_TF_list;

  if(ie_ptr == NULL)
  {
    WRRC_MSG0_ERROR("PRACH System Info not present");
    return(FAILURE);
  }

  if(rrc_additional_prach_TF_list == NULL)
    n_value_prach_TF_list = 0;
  else
    n_value_prach_TF_list = rrc_additional_prach_TF_list->n;

  /*
  * To fill up the PRACH array the following algorithm is used as defined
  * in the RRC  spec. Note that from 1 to MAX_PRACH IEs can be included
  * in the PRACH system information list. The algorithm is:
  *
  *   int num_of_prach = 1;
  *
  *   while ((PRACH_ptr != NULL) && (num_of_prach <= MAX_PRACH))
  *
  *     PRACH_Info[num_of_prach - 1] = PRACH_Info(num_of_prach)
  *
  *     TrCh_Id[num_of_prach - 1]    = TrCH_Id(num_of_prach)
  *
  *     if(rrc_PRACH_SystemInformation_rach_TransportFormatSet_present) || num_of_prach == 1)
  *       RACH_TFS[num_of_prach - 1] = RACH_TFS(num_of_prach)
  *     else
  *       RACH_TFS[num_of_prach - 1] = RACH_TFS[num_of_prach - 2]
  *
  *     if(rrc_PRACH_SystemInformation_rach_TFCS_present) || num_of_prach == 1)
  *       RACH_TFCS[num_of_prach - 1] = RACH_TFCS(num_of_prach)
  *     else
  *       RACH_TFCS[num_of_prach - 1] = RACH_TFCS[num_of_prach - 2]
  *
  *     if(rrc_PRACH_SystemInformation_prach_Partitioning_present) || num_of_prach == 1)
  *       PRACH_PARTITIONING[num_of_prach - 1] =
  *         PRACH_PARTITIONING(num_of_prach)
  *     else
  *       PRACH_PARTITIONING[num_of_prach - 1] =
  *         PRACH_PARTITIONING[num_of_prach - 2]
  *
  *     ... And so on for the remaing IEs for FDD mode ...
  *
  *  end while loop.
  */

  MSG_MED("Reading SIB PRACH Sys Info",0,0,0);

  /*
  * Note that the ASN.1 generates a Linked List. Hence, loop until the
  * the end of the list. Also make sure that not more than MAX_PRACH
  * linked elements are included.
  */
  n_value = ie_ptr->n;
  n_index = 0;

  while((n_value != 0) && (num_of_prach <= UE_MAX_PRACH))
  {
    /* Indicate to uplink that the current channel is a PRACH */
    config_ptr->l1_ul_cctrch_parms.chan = L1_UL_PHYCHAN_PRACH;

    /* Only need FDD for PRACH to RACH info */
    if(get_prach_rach_info(&config_ptr->l1_ul_chan_parms.prach_cfg, &ie_ptr->elem[n_index].prach_RACH_Info) == FAILURE)
    {
      return FAILURE;
    }

    /* Save copies of this Transport Channel ID and Index to Ordered Config */
    if(((tr_ch_id_type)ie_ptr->elem[n_index].transportChannelIdentity >
        RRCLLC_TRCH_ID_MAX_VALUE) ||
       ((tr_ch_id_type)ie_ptr->elem[n_index].transportChannelIdentity <
        RRCLLC_TRCH_ID_MIN_VALUE))
    {
      WRRC_MSG1_ERROR("invalid TrCH ID %d",
          (tr_ch_id_type)ie_ptr->elem[n_index].transportChannelIdentity);
      return(FAILURE);
    }

    /* Get the transport channel Index */
    if((trch_idx = rrcllc_get_ul_rach_trch_idx(
                     config_ptr,
                    (tr_ch_id_type)ie_ptr->elem[n_index].transportChannelIdentity))
        >= UE_MAX_TRCH)
    {
      return FAILURE;
    }

    /* ... and make sure we have not exceeded UE capaabilities for UL TRCH's */
    if((RRCLLC_UPLINK_TRCH_COUNT(config_ptr)) >= UE_MAX_TRCH)
    {
      WRRC_MSG0_ERROR("Exceeded maximum number of UL TRCHs");
      return FAILURE;
    }

    /* Only need FDD for TFS */
    if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                rach_TransportFormatSetPresent))
    {
      /* Get all the RACH TFS data */
      MSG_MED("Get UL TFS for TrCH ID %d", ie_ptr->elem[n_index].transportChannelIdentity,0,0);
      if(get_ul_transport_format_set(config_ptr, &ie_ptr->elem[n_index].rach_TransportFormatSet, trch_idx)
        == FAILURE)
      {
        return FAILURE;
      }
    }
    else  /* RACH TFS not present */
    {
      /* For the first PRACH it is MP, for the next, pick it from the
       * previous one.
       */
      if(num_of_prach == 1)
      {
        WRRC_MSG0_ERROR("RACH TFS absent for 1st PRACH");
        return(FAILURE);
      }
      else
      {
        /* The IE was not included, copy from the previous IE */
        WRRC_MSG0_ERROR("Copy from Previous PRACH TFS data not supported");
        return (FAILURE);
      }
    } /* RACH TFS not present */

    /* Only need FDD for TFCS */
    if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                rach_TFCSPresent))
    {
      /* Get all the RACH TFCS data */
      MSG_MED("Get UL TFCS",0,0,0);
      if(get_ul_tfcs_info(config_ptr, &ie_ptr->elem[n_index].rach_TFCS) == FAILURE)
      {
        return FAILURE;
      }
      
      WRRC_MSG2_MED("Update l1 with UL Trch info num tfci in L1 %d, numtfci in RRC DB %d",
        config_ptr->l1_ul_cctrch_parms.num_tfci,
        config_ptr->rrc_ul_cctrch_params.num_tfci);
    
      config_ptr->l1_ul_cctrch_parms.num_tfci = config_ptr->rrc_ul_cctrch_params.num_tfci;
      
    }
    else
    {
      /* For the first PRACH it is MP, for the next, pick it from the
       * previous one.
       */
      if(num_of_prach == 1)
      {
        WRRC_MSG0_ERROR("RACH TFCS absent for 1st PRACH");
        return(FAILURE);
      }
      else
      {
        /* The IE was not included, copy from the previous IE */
        WRRC_MSG0_ERROR("Copy from previous PRACH TFCS data not supported");
        return (FAILURE);
      }
    }

    /* Get the PRACH partioning information, as this is per ASC */
    if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                prach_PartitioningPresent))
    {
      /* We now have the number of ASCs supported. */
      if(get_prach_partitioning(config_ptr->asc_info, &config_ptr->l1_ul_chan_parms.prach_cfg, 
        &ie_ptr->elem[n_index].prach_Partitioning, &num_of_asc) == FAILURE)
      {
        /* Bad values in this IE */
        return FAILURE;
      }
    } /* end if IE present and FDD mode chosen */
    else
    {
      if(num_of_prach == 1)
      {
        WRRC_MSG0_ERROR("PRACH partitioning data absent for 1st PRACH");
        return(FAILURE);
      }
      else
      {
        /* The IE was not included, copy from the previous IE */
        WRRC_MSG0_ERROR("Copy from previous PRACH PARTITIONING data not supported");
        return (FAILURE);
      }
    }
    /* end Partitioning data */

    /* Give L1 the number of ASCs rcv'd over the air */
    config_ptr->l1_ul_chan_parms.prach_cfg.asc_cfg.num_asc = (uint8)num_of_asc;

    /*
    * Get the Persistence scaling factors. Since the number of ASC's was
    * determined by the prach partitioning info, and the Dynamic Persistance
    * value, N, was taken from Sib 7. P(N) = 2e-(N-1), the following
    * table holds per ASC where SX equals the persistence scaling factor
    * which is up tp. If only ASC 0 and 1 are sent, no Persistence
    * scaling factor is present. However, if more than 2 ASC's are included
    * the following holds:
    *
    * -----------------------------------------------------------------------
    * | ASC idx |    2    |    3    |    4    |    5    |    6    |    7    |
    * -----------------------------------------------------------------------
    * |  P2     | S2*P(N) | S3*P(N) | S4*P(N) | S5*P(N) | S6*P(N) | S7*P(N) |
    * |  P3     | S2*P(N) | S3*P(N) | S4*P(N) | S5*P(N) | S6*P(N) | S7*P(N) |
    * |  P4     | S2*P(N) | S3*P(N) | S4*P(N) | S5*P(N) | S6*P(N) | S7*P(N) |
    * |  P5     | S2*P(N) | S3*P(N) | S4*P(N) | S5*P(N) | S6*P(N) | S7*P(N) |
    * |  P6     | S2*P(N) | S3*P(N) | S4*P(N) | S5*P(N) | S6*P(N) | S7*P(N) |
    * |  P7     | S2*P(N) | S3*P(N) | S4*P(N) | S5*P(N) | S6*P(N) | S7*P(N) |
    * -----------------------------------------------------------------------
    *
    * For P2 - P7 ASC 0, the table value is 1.
    * For P2 - P7 ASC 1, the table value is just P(N) without a scaling factor.
    *
    * If only ASC 0, and ASC 1 are sent, the Persistence Scaling Factors are
    * not to be included in SIB 5, and only 1 Dynamic Persistence Value should
    * be present in SIB 7 for ASC 1. The assumption is that if more than 1
    * Dynamic Persistence Value is included, then the remaining are ignored.
    * If any Persistence Scaling Factors are included, then they too are
    * ignored.
    *
    * NOTE: for ASC 0 and ASC 1, the above table does not hold.
    *
    */

    /*
    * If there are more than 2 access service classes, then we get all
    * the Persistence value stuff.
    */
    if(num_of_asc > 2)
    {
      if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                   persistenceScalingFactorListPresent))
      {
        /* Get persistence values */
        if(get_persist_scaling_factors(config_ptr, &ie_ptr->elem[n_index].persistenceScalingFactorList)
          == FAILURE)
        {
          return FAILURE;
        }
      } /* persistence scaling factor is present */
      else
      {
        if(num_of_prach == 1)
        {
          /* Set default value of 1 to all ASCs as per spec */
          get_persist_scaling_default_factors(config_ptr);
          WRRC_MSG0_HIGH("Ignoring absence of Persistence sclng factor");
        }
        else
        {
          /* Persistence scaling factor data not present AND this is NOT the
           * 1st PRACH. Get the persistence value from previous PRACH
           */
          WRRC_MSG0_ERROR("Previous PERSISTENCE SCALING FACTOR data not supported");
          return FAILURE;
        }
      } /* Persistence scaling factor list is not present */
    }  /* Number of ASC > 2 */

    /* Setup the Persistence values for all ASCs */
    /*ASC_IDX ranges from 0 to 7 which needs to be mapped to persitence
      value Pi(1 to 0) according to spec: 8.5.12. Pi is maintained internally
      as (0xFFFF to 0) so ASC_IDX(0 to 7) -> pval(0xFFFF to 0)*/
    for(asc_idx = 0; ((asc_idx < num_of_asc)&& (asc_idx < MAX_ASC)); asc_idx++)
    {
      switch(asc_idx)
      {
        case 0:
#ifndef FEATURE_WCDMA_RRC_APPLY_SAME_WEIGHT_FOR_ASC0_ASC1
          pval = RRCLLC_PVAL_MULTIPLICATION_FACTOR;
          break;
#endif
        case 1:
          pval = RRCLLC_PVAL_MULTIPLICATION_FACTOR>>(config_ptr->dpl - 1);
          break;
        default:
          /*psf from spec goes from 0.9..0.2, we have scaled it to 9...2(factor of 10), this is why we 
              divide by RRCLLC_DEFAULT_PERSISTENCE_SCALING_FACTOR_VAL*/
          pval = ((RRCLLC_PVAL_MULTIPLICATION_FACTOR>>(config_ptr->dpl - 1)) * config_ptr->psf[asc_idx - 2])/
                  RRCLLC_DEFAULT_PERSISTENCE_SCALING_FACTOR_VAL; 
          break;
      }
      config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[asc_idx].pval = pval;
#ifdef FEATURE_WCDMA_RRC_APPLY_WEIGHT_FOR_ASC0_PVAL
      if (asc_idx == 0)
      {
        /*Apply weight for ASC0 also*/
        config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[asc_idx].pval =
          0xFFFF - weight + (weight / (1 << (config_ptr->dpl - 1)));
      }
#endif
    }

    /* Indicate the number of Access Service Classes supported */
    config_ptr->mac_ul_parms.rach_tx_cntl_info.nASC = num_of_asc;
    MSG_9(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"Num of Asc: %d  ASC0-pval: %d ASC1-pval: %d ASC2-pval: %d ASC3-pval: %d ASC4-pval: %d ASC5-pval: %d ASC6-pval: %d ASC7-pval: %d ",
                                         num_of_asc,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[0].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[1].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[2].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[3].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[4].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[5].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[6].pval,
                                         config_ptr->mac_ul_parms.rach_tx_cntl_info.asc[7].pval
                                         );

    /* get the AC to ASC Mapping info */
    if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                ac_To_ASC_MappingTablePresent))
    {
      if(get_ac_to_asc_mapping(config_ptr, &ie_ptr->elem[n_index].ac_To_ASC_MappingTable) == FAILURE)
      {
        return FAILURE;
      }
    }
    else
    {
      if(num_of_prach == 1)
      {
        if(is_sib6_in_use)		
        {
    
          rrc_SysInfoType5 *sib5_ptr = NULL;
    
          /*In connected mode we always need to get the ASC info from SIB5
            But to make our design as close as legacy we are trying to pick the asc info from SIB6 if present
            else pick from sib5 first index.
            spec section 10.3.6.55 AC-to-ASC mapping CV-SIB5-MD Only present in SIB 5 and in SIB 5bis*/
          sib5_ptr = (rrc_SysInfoType5 *)rrc_sibdb_return_sib_for_srv_cell(rrc_SIB5);
        	
          if (sib5_ptr == NULL)
          {
             WRRC_MSG0_ERROR("SIB 5 not yet in SIB data base");
             return FAILURE;
          }
    
          if(RRC_CHECK_MSG_TYPE_IE(sib5_ptr->prach_SystemInformationList.elem[0],ac_To_ASC_MappingTablePresent))
          {
            if(get_ac_to_asc_mapping(config_ptr,&(sib5_ptr->prach_SystemInformationList.elem[0].ac_To_ASC_MappingTable)) == FAILURE)
            {
              return FAILURE;
            }
          }
          else
          {
            WRRC_MSG0_ERROR("ASC-to-AC mapping not present in in first prach of SIB5 not expected configuration");
            return FAILURE;
          }
        }
        else
        {
      /* Ignore at this point if ASC to AC mapping is absent.
       * It is not used at present. Need to change spec to make it an MP for
       * 1st PRACH.
       */
          WRRC_MSG0_HIGH("Ignoring absence of ASC-to-AC mapping");
        }
      }
      else
      {
        /* The IE was not included, copy from the previous IE */
        WRRC_MSG0_ERROR("No previous ACCESS SERVICE CLASS MAPPING data to get");
        return FAILURE;
      }
    }
    /* end AC to ASC mapping */

    /* Now select the ASC for CCCH. This is for initial access
     * for RRC Connection Setup message on CCCH.
     */
    select_asc_from_ac(config_ptr);

    /* Make sure we have FDD parameters or else report a failure */
    if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index].modeSpecificInfo,
                T_rrc_PRACH_SystemInformation_modeSpecificInfo_fdd))
    {
      /* Get the Primary CPICH TX power */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->elem[n_index].modeSpecificInfo.u.fdd,
                primaryCPICH_TX_PowerPresent))
      {
        if(get_primary_cpich_tx_pwr(&config_ptr->rrc_ul_pwr_init_parms, 
          ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_TX_Power) == FAILURE)
        {
          return FAILURE;
        }
      }
      else  /* Primary CPICH power data not present */
      {
        if(num_of_prach == 1)
        {
          WRRC_MSG0_ERROR("Pri CPICH Tx Power absent for 1st PRACH");
          return(FAILURE);
        }
        else
        {
          /* get from the previous element */
          WRRC_MSG0_ERROR("Copy from previous Pri CPICH TX power not supported");
          return FAILURE;
        }
      }

      /* Get the Constant Value */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->elem[n_index].modeSpecificInfo.u.fdd,
                 constantValuePresent))
      {
        if(get_constant_value(&config_ptr->rrc_ul_pwr_init_parms,ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->constantValue)
          == FAILURE)
        {
          return FAILURE;
        }
      }
      else
      {
        if(num_of_prach == 1)
        {
          WRRC_MSG0_ERROR("Constant value absent for 1st PRACH");
          return(FAILURE);
        }
        else
        {
          /* get from the previous element */
          WRRC_MSG0_ERROR("Copy from previous constant value not supported");
          return(FAILURE);
        }
      }

      /* Get the PRACH Power Offset Info */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->elem[n_index].modeSpecificInfo.u.fdd,
                    prach_PowerOffsetPresent))
      {
        if(get_prach_pwr_offset(config_ptr, &ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->prach_PowerOffset)
          == FAILURE)
        {
          return (FAILURE);
        }
      }
      else
      {
        if(num_of_prach == 1)
        {
          /* MP element is absent */
          WRRC_MSG0_ERROR("PRACH Power Offset data absent for 1st PRACH");
          return (FAILURE);
        }
        else
        {
          /* get from the previous element */
          WRRC_MSG0_ERROR("Copy from previous PRACH Power Offset data not supported");
          return (FAILURE);
        }
      }

      /* Get the PRACH Transmission Parameters */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->elem[n_index].modeSpecificInfo.u.fdd,
                rach_TransmissionParametersPresent))
      {
        if(get_rach_xmit_parms(config_ptr, &ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->rach_TransmissionParameters)
          == FAILURE)
        {
          return FAILURE;
        }
      }
      else
      {
        if(num_of_prach == 1)
        {
          /* MP element is absent */
          WRRC_MSG0_ERROR("RACH Xmit parms absent for 1st PRACH");
          return (FAILURE);
        }
        else
        {
          /* get from the previous element */
          WRRC_MSG0_ERROR("Copy from previous RACH Xmit parms not supported");
          return FAILURE;
        }
      }

      /* Get the AICH information */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->elem[n_index].modeSpecificInfo.u.fdd,
                aich_InfoPresent))
      {
        MSG_MED("Get AICH Info",0,0,0);
        if(get_aich_info(config_ptr, &ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->aich_Info)
          == FAILURE)
        {
          return FAILURE;
        }
      }
      else  /* AICH Info not present */
      {
        if(num_of_prach == 1)
        {
          WRRC_MSG0_ERROR("AICH info absent for 1st PRACH");
          return(FAILURE);
        }
        else
        {
          // get from the previous element
          WRRC_MSG0_ERROR("Copy from previous AICH Info not supported");
          return (FAILURE);
        }
      }
    } /* end fdd mode specific info check */
    else /* must be TDD */
    {
      return FAILURE;
    }
    if((n_value_prach_TF_list != 0 ) && 
       (RRC_CHECK_MSG_TYPE_IE(rrc_additional_prach_TF_list->elem[n_index],
                additionalPRACH_TF_and_TFCS_CCCH_IEsPresent)))
    {
      WRRC_MSG0_HIGH("ATF: ATF info present for prach one ");
      rrcllc_compute_additional_prach_tf(&rrc_additional_prach_TF_list->elem[n_index].additionalPRACH_TF_and_TFCS_CCCH_IEs,config_ptr,trch_idx);
    }
    if(n_value_prach_TF_list != 0)
    {
      n_value_prach_TF_list--;
    }

    /* get the next element in the  list */
    num_of_prach++;
    n_value--;
    n_index++;
  } /* end while loop processing PRACH System Information IEs */

  /* Calculate the UL TFCS for the RACH */
  compute_ul_tfis_from_ctfc(&config_ptr->ul_tfcs);

  /* Indicate that L1 UL needs to be reconfigured */
  config_ptr->reconfig_needed.uplink_l1 = TRUE;

  return SUCCESS;

}

/*====================================================================
FUNCTION       get_prach_sys_info()

DESCRIPTION    This function takes a pointer to the PRACH system
               information list and copies all applicable IEs for
               MAC, RLC, and L1 into the ORDERED_CONFIG database
               (internal format).

DEPENDENCIES   None

RETURN VALUE   SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS   The current contents of ORDERED_CONFIG will be
               overwritten.
====================================================================*/
uecomdef_status_e_type get_prach_sys_info
(
  ordered_config_type *config_ptr,
  rrc_PRACH_SystemInformationList *prach_sys_info_ptr
  ,rrc_AdditionalPRACH_TF_and_TFCS_CCCH_List * rrc_additional_prach_TF_list
  ,boolean is_sib6_in_use
)
{
  l1_prach_selection_info_struct_type   l1_prach_sys_info;
  uint8                                 index_10ms_tti = 0;
  uint8                                 i, ntfc, tfi; // loop index
  rrcllc_prach_sel_info_type                   *selected_config_ptr = NULL;
  mac_ul_tfcs_type                      *tfcs_ptr;
  uint32                                ntblks, tb_size;
  uint32                                max_tb_size = 0;
  uint8                                 selected_tfci = 0;
  l1_rach_tti_allowed_enum_type         allowed_tti = L1_PRACH_INVALID;
  dword                                 random_num;
  uint8                                 selected_index = 0;
  #ifndef T_WINNT
    uint16                              start_index, end_index;
  #endif
  uint8  rrc_num_of_prach = 0;    
  
  /* local PRACH System Info pointer */
  rrc_PRACH_SystemInformationList   *ie_ptr = prach_sys_info_ptr;
  
  if(ie_ptr == NULL)
  {
    WRRC_MSG0_ERROR("PRACH System Info not present");
    return(FAILURE);
  }
  
  /* Init some PRACH info before starting to process new IEs */
  rrcllc_init_rach_info(config_ptr, FALSE);

  rrc_num_of_prach = ie_ptr->n;


  if(rrc_num_of_prach > UE_MAX_PRACH)
  {
    WRRC_MSG1_ERROR("PRACH_OPT: Invalid no. of prachs %d, setting to UE_MAX_PRACH ",rrc_num_of_prach);
    rrc_num_of_prach = UE_MAX_PRACH;
  }

  if (rrc_num_of_prach == 1)
  {
    WRRC_MSG0_MED("There is only one PRACH in sys information message");
    return (get_prach_sys_info_for_one_prach(config_ptr, ie_ptr
             ,rrc_additional_prach_TF_list,is_sib6_in_use
        ));
  }
  
  // Initialize the PRACH status info fields
  prach_status_info.current_10ms_tti_prach_index = 0;
  prach_status_info.current_20ms_tti_prach_index = 0;
  prach_status_info.num_valid_prachs_found = 0;

  WRRC_MSG1_HIGH("PRACH_OPT: Total no. of PRACHs in SIB = %d",rrc_num_of_prach);

  rrcllc_allocate_mem_for_prach_sel_info(rrc_num_of_prach);  
  
  // Populate the number of PRACH's from the sys info message
  if (get_prach_sys_info_list(ie_ptr, config_ptr, rrc_num_of_prach
             ,rrc_additional_prach_TF_list,is_sib6_in_use
  ) == FAILURE)
  {
    WRRC_MSG0_ERROR("Could not read the system info pointer");
    rrcllc_deallocate_mem_for_prach_sel_info(rrc_num_of_prach);
    return (FAILURE);
  }
  

    WRRC_MSG2_HIGH("PRACH's in SysInfoMsg has %d 10ms TTI & %d 20ms TTI length",
      prach_status_info.current_10ms_tti_prach_index ,prach_status_info.current_20ms_tti_prach_index);

        
  /* There is atleast one 10ms tti PRACH available */
  if (prach_status_info.current_10ms_tti_prach_index > 0)
  {
    /* This implies both 10ms and 20ms PRACH are found */
    if (prach_status_info.current_20ms_tti_prach_index > 0)
    {
    /* PRACH's from both 10ms tti length and 20ms tti length is supplied.
    Hence get the transmit power margin on the 10ms tti length PRACH's
    If for all PRACH's the value comes above 6dBm then select the 10ms TTI
      length. Else choose the 20ms tti length */
      
      for (i=0;i<prach_status_info.current_10ms_tti_prach_index; i++)
      {
        index_10ms_tti = prach_10ms_tti_index_array[i];
        
        selected_config_ptr = prach_sel_info[index_10ms_tti];
        
        tfcs_ptr = &selected_config_ptr->ul_tfcs;
        
        max_tb_size = 0;
        
        for (ntfc = 0; ntfc < tfcs_ptr->ntfc; ntfc++ )
        {
          tfi = tfcs_ptr->tfc_info[ntfc].tfi[0];
          tb_size = tfcs_ptr->tfs_info[0].tf_info[tfi].tb_size;
          ntblks = tfcs_ptr->tfs_info[0].tf_info[tfi].ntblks;
          
          if ((ntblks == 1) && (tb_size > max_tb_size))
          {
            max_tb_size = tb_size;
            selected_tfci = ntfc;
          }
        }
        
        l1_prach_sys_info.rach_cctrch_cfg_ptr = &selected_config_ptr->l1_ul_cctrch_parms;
        l1_prach_sys_info.rach_ul_tfcs_ptr = &selected_config_ptr->ul_tfcs;
        l1_prach_sys_info.tfci = selected_tfci;
        l1_prach_sys_info.pr_cpich_tx_pwr = (int8)selected_config_ptr->rrc_ul_pwr_init_parms.primary_cpich_tx_power;
        l1_prach_sys_info.const_val = (int8)selected_config_ptr->rrc_ul_pwr_init_parms.constant_value;
        
        l1_prach_sys_info.max_tx_pwr = config_ptr->l1_ul_chan_parms.max_tx_pwr;
        l1_prach_sys_info.ul_if = (int8)config_ptr->rrc_ul_pwr_init_parms.ul_interference;
        
        allowed_tti = l1_compute_rach_tx_pwr_margin(&l1_prach_sys_info);
        
        if (allowed_tti == L1_PRACH_20MS_ALLOWED)
        {
          WRRC_MSG2_HIGH("10ms TTI could not meet the power margin criteria %d %d",
            i,index_10ms_tti);
          
          break;
        }
      }
    }
    else
    {
    /* All PRACH's supplied in the sys info message has 10ms tti length
      * Hence no TTI selection is necessary. Only random selection is needed*/
      allowed_tti = L1_PRACH_10MS_ALLOWED;
    }
  }
  else if (prach_status_info.current_20ms_tti_prach_index > 0)
  {
  /* All PRACH's supplied in the sys info message has 20ms tti length
    Hence no tti selction is necessary. Only random selection is needed */
    allowed_tti = L1_PRACH_20MS_ALLOWED;
  }
  else
  {
    WRRC_MSG0_ERROR("Error while populating PRACH sys information msg");
    rrcllc_deallocate_mem_for_prach_sel_info(rrc_num_of_prach);
    return FAILURE;
  }
  
  /* Don't need the random selection part since there is only 1 PRACH in the
  sys info message */

  WRRC_MSG2_HIGH("Number of valid PRACH's found is %d allowed_tti%d",prach_status_info.num_valid_prachs_found,allowed_tti);
  
  if (prach_status_info.num_valid_prachs_found == 1)
  {
    selected_config_ptr = prach_sel_info[0];
  }
  else if (prach_status_info.num_valid_prachs_found > 1)
  {
    /* Switch on the type of the TTI selected */
    switch (allowed_tti)
    {
    case  L1_PRACH_10MS_ALLOWED:
      
#ifndef T_WINNT
      if(E_SUCCESS != secapi_get_random(SECAPI_SECURE_RANDOM, (uint8*)&random_num, sizeof(random_num)))
      {
        ERR_FATAL("Random number generation failed",0,0,0);
      }
      else
      {
        /* Normalize this random number to a value between 0 & 65535 */
      
        start_index = 0;
        end_index = prach_status_info.current_10ms_tti_prach_index;
        random_num = ran_dist(random_num, start_index, end_index  );
        MSG_HIGH("Random number generated is %d in range %d to %d", random_num,
          start_index,end_index);
      }
#else
      #error code not present
#endif
      selected_index = prach_10ms_tti_index_array[random_num];
      WRRC_MSG1_HIGH("Selected PRACH index %d", selected_index);
      
      selected_config_ptr = prach_sel_info[selected_index];
      break;
      
    case L1_PRACH_20MS_ALLOWED:
#ifndef T_WINNT
      if(E_SUCCESS != secapi_get_random(SECAPI_SECURE_RANDOM, (uint8*)&random_num, sizeof(random_num)))
      {
        ERR_FATAL("Random number generation failed",0,0,0);
      }
      else
      {
      
        start_index = 0;
        end_index = prach_status_info.current_20ms_tti_prach_index;
      
        /* Normalize this random number to a value between 20ms tti prach
        index to UE_MAX_PRACH */
        random_num = ran_dist(random_num, start_index, end_index);
      
        MSG_HIGH("Random number generated is %d in range %d to %d", random_num,
        start_index, end_index);
      }
#else
      #error code not present
#endif
      selected_index = prach_20ms_tti_index_array[random_num];
      WRRC_MSG1_HIGH("Selected index is %d", selected_index);
      
      selected_config_ptr = prach_sel_info[selected_index];
      break;
    default:
      
      WRRC_MSG0_ERROR("No PRACH was selected");
      rrcllc_deallocate_mem_for_prach_sel_info(rrc_num_of_prach);
      return FAILURE;
    }
  }
  else // 0 PRACH's were found
  {
    WRRC_MSG0_ERROR ("No PRACH was found !");
      rrcllc_deallocate_mem_for_prach_sel_info(rrc_num_of_prach);
    return FAILURE;
  }
  
  /* Copy the valid parameters of the PRACH to the oc_config_ptr. */
  rrcllc_update_oc_with_prach_info(config_ptr, selected_config_ptr);
  rrcllc_deallocate_mem_for_prach_sel_info(rrc_num_of_prach);
  return SUCCESS;
  

} /* end get_prach_sys_info() */

/*====================================================================
FUNCTION        get_prach_rach_info()

DESCRIPITON     This function takes a pointer to the PRACH to RACH
                info IE and copies it to ORDERED_CONFIG.

DEPENDENCIES    None

RETURN VALUE    SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS    The current Ordered Config data is overwritten.
====================================================================*/
uecomdef_status_e_type get_prach_rach_info
(
  l1_ul_prach_cfg_struct_type * prach_cfg_ptr,
  rrc_PRACH_RACH_Info *ie_ptr
)
{
  /* local variables for processing of bit strings */
  uint16 available_signature   = 0;
  uint16 available_subchannels = 0;

  /* Get the PRACH Available Signature */
  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
              T_rrc_PRACH_RACH_Info_modeSpecificInfo_fdd))
  {
    if(ie_ptr->modeSpecificInfo.u.fdd->availableSignatures.numbits != RRCLLC_MAX_AVAILABLE_SIGNATURE)
    {
      WRRC_MSG1_ERROR("Available Sig Size is %d, S/B 16",
                ie_ptr->modeSpecificInfo.u.fdd->availableSignatures.numbits);
      return FAILURE;
    }

    available_signature = (uint16)((*ie_ptr->modeSpecificInfo.u.fdd->availableSignatures.data) << 8);
    available_signature |= (uint16)(*(ie_ptr->modeSpecificInfo.u.fdd->availableSignatures.data + 1));

    if(available_signature > 0)
    {
      prach_cfg_ptr->avail_sig_mask = available_signature;
    }
    else
    {
      WRRC_MSG1_ERROR("Available Signature = 0x%x", available_signature);
      return FAILURE;
    }
  } /* end PRACH_RACH Info FDD chosen */
  else
  {
    WRRC_MSG0_ERROR("No FDD PRACH_RACH_INFO IE is included");
    return FAILURE;
  }

  /*
  * Get the PRACH Available Spreading Factor. Convert from the ASN.1
  * enum type to the L1 enum type
  */
  switch(ie_ptr->modeSpecificInfo.u.fdd->availableSF)
  {
    case rrc_SF_PRACH_sfpr32:
      prach_cfg_ptr->sf_min = L1_SF_32;
      break;

    case rrc_SF_PRACH_sfpr64:
      prach_cfg_ptr->sf_min = L1_SF_64;
      break;

    case rrc_SF_PRACH_sfpr128:
      prach_cfg_ptr->sf_min = L1_SF_128;
      break;

    case rrc_SF_PRACH_sfpr256:
      prach_cfg_ptr->sf_min = L1_SF_256;
      break;

    default:
      WRRC_MSG1_ERROR("No Spreading Factor for PRACH: Received %d",
        ie_ptr->modeSpecificInfo.u.fdd->availableSF);
      return FAILURE;
  } /* end switch on prach spreading factor */

  /* Get the Preamble scrambling code */
  if (ie_ptr->modeSpecificInfo.u.fdd->preambleScramblingCodeWordNumber
    <= RRCLLC_MAX_PREAMBLE_SCRAMBLING_CODE)
  {
    prach_cfg_ptr->sc_num = (uint8)
      ie_ptr->modeSpecificInfo.u.fdd->preambleScramblingCodeWordNumber;
  }
  else
  {
    WRRC_MSG1_ERROR("PRACH preamble scrambling code %d is out of range",
     ie_ptr->modeSpecificInfo.u.fdd->preambleScramblingCodeWordNumber);
    return FAILURE;
  }

  /*
  * Get the Puncturing Limit. The OTA Msg receives this value as an enum.
  * The puncturing limit is a real number between 0.4 and 1.0 in steps of 0.04.
  * L1 expects this value to be from 40 to 100; in other words, L1 expects
  * l1_puncturing_limit = puncturing_limit * 100;
  * Therefore in the ASN.1 enum type the first enum value 0 corresponds to 0.4,
  * 1 corresponds to 0.44, etc... . Hence the following equation is derived:
  * l1_puncturing_limit = (ASN.1_enum_type * 4) + 40;
  * If this enum changes, this equation may need tweaking or else, this can
  * be broken into a switch with multiple cases.
  */
  prach_cfg_ptr->punct_lim = (uint8)
    (((uint8)(ie_ptr->modeSpecificInfo.u.fdd->puncturingLimit) * 4) + 40);

  if((prach_cfg_ptr->punct_lim < RRCLLC_MIN_PUNCTURING_LIMIT)
    || (prach_cfg_ptr->punct_lim > RRCLLC_MAX_PUNCTURING_LIMIT))
  {
    WRRC_MSG1_ERROR("PRACH puncturing limit %d is out of range",
          prach_cfg_ptr->punct_lim);
    return FAILURE;
  }

  /* Get the Available Sub-Channel */
  if(ie_ptr->modeSpecificInfo.u.fdd->availableSubChannelNumbers.numbits != RRCLLC_MAX_AVAILABLE_SUBCHAN)
  {
    WRRC_MSG1_ERROR("Available Sub-Channel # is %d, S/B 12",
              ie_ptr->modeSpecificInfo.u.fdd->availableSubChannelNumbers.numbits);
    return FAILURE;
  }

  available_subchannels = (uint16)((*ie_ptr->modeSpecificInfo.u.fdd->availableSubChannelNumbers.data) << 8);
  available_subchannels |= (uint16)(*(ie_ptr->modeSpecificInfo.u.fdd->availableSubChannelNumbers.data + 1));
  available_subchannels = (uint16) (available_subchannels >> 4);

  if(available_subchannels > 0)
  {
    prach_cfg_ptr->avail_sub_chan_mask = available_subchannels;
  }
  else
  {
    WRRC_MSG1_ERROR("Available SubChannel #s = 0x%x", available_subchannels);
    return FAILURE;
  }

  /* finished copying all IEs successfully */
  return SUCCESS;

} /* end prach_rach_info() */

/*====================================================================
FUNCTION        get_prach_partitioning()

DESCRIPITON     This function takes a pointer to the PRACH Partitioning
                info IE and copies it to ORDERED_CONFIG.

DEPENDENCIES    None

RETURN VALUE    SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS    The current Ordered Config data is overwritten.
                The num_of_asc is updated to reflect the number of
                asc's rcv'd over the air.
====================================================================*/
uecomdef_status_e_type get_prach_partitioning
(
  l1_ul_asc_struct_type  *asc_info,
  l1_ul_prach_cfg_struct_type * prach_cfg_ptr,
  rrc_PRACH_Partitioning   *ie_ptr,
  uint8                    *num_of_asc
)
{
  /* Loop counter */
  uint32 i, n_index, n_value;

  /* Pointer to the ASC data when extracting Partitioning Info */
  struct rrc_PRACH_Partitioning_fdd     *asc_ptr;

  if(RRC_CHECK_COMMON_MSG_TYPE_PTR(ie_ptr,
              rrc_PRACH_Partitioning_fdd))
  {
    /* Assign pointer to FDD values */
    asc_ptr = ie_ptr->u.fdd;
  }
  else
  {
    /* Don't support TDD */
    return(FAILURE);
  }
  
  /* Get all the Partitioning Data */
  if(asc_ptr == NULL)
  {
    WRRC_MSG0_ERROR("Invalid ASC PTR received");
    return(FAILURE);
  }
  //Added check to fix the KW error
  if(*num_of_asc == 0)
  {
    WRRC_MSG0_ERROR("Invalid num of ASC received");
    return(FAILURE);
  }

  n_index = 0;
  n_value = asc_ptr->n;
  
  while((n_value != 0) && (*num_of_asc <= MAX_ASC))
  {
    /* save the pointer */
      prach_cfg_ptr->asc_cfg.asc_info_ptr[(*num_of_asc)-1] =
        &asc_info[(*num_of_asc)-1];

    if (RRC_CHECK_MSG_TYPE_IE(asc_ptr->elem[n_index], 
                accessServiceClass_FDDPresent))
    {
      /* get all of the signature and sub-channel indicies */
      asc_info[(*num_of_asc)-1].avail_sig_end_idx = (uint8)
        asc_ptr->elem[n_index].accessServiceClass_FDD.availableSignatureEndIndex;

      asc_info[(*num_of_asc)-1].avail_sig_start_idx = (uint8)
        asc_ptr->elem[n_index].accessServiceClass_FDD.availableSignatureStartIndex;

      /* get the assigned subchannel number. L1 will do some magic
         to get the correct value */
      asc_info[(*num_of_asc)-1].assigned_sub_chan_num = (uint8)
       ((*asc_ptr->elem[n_index].accessServiceClass_FDD.assignedSubChannelNumber.data) >> 4);

      MSG_LOW("num_of_asc %d, start %d, end %d", (*num_of_asc),
      asc_info[(*num_of_asc)-1].avail_sig_start_idx,
      asc_info[(*num_of_asc)-1].avail_sig_end_idx);

      MSG_LOW("Assigned sub_chan_number for ASC %d is %d",
      (*num_of_asc),asc_info[(*num_of_asc)-1].assigned_sub_chan_num,0);
    
    } /* end if ASC present */
    else
    {
      /* Access Service Class data is absent for this ASC */
      /* Set default values for the 1st Access Service Class */
      if(*num_of_asc == 1)
      {
        /* For the 1st ASC, set it to default value based on the available
         * signatures listed in PRACH info (for RACH).  This is done by simply
         * counting the bits in the available signature mask.  The low
         * available signature index in this case is always zero, and the high
         * available signature index is the count of available indices minus
         * one.
         */
        uint16 sig_index;
        uint8 avail_sig_count = 0;
        uint16 avail_sig_mask =
          prach_cfg_ptr->avail_sig_mask;

        for(sig_index = 0; sig_index < RRCLLC_MAX_AVAILABLE_SIGNATURE; sig_index++)
        {
          if (avail_sig_mask & (1 << sig_index)) {
            avail_sig_count++;
          }
        }

        /* Complain and fail if there were no signatures available. */
        if(avail_sig_count == 0)
        {
          WRRC_MSG0_ERROR("No signatures available for default processing.");
          return(FAILURE);
        }

        /* Indicate availability of signatures as represented by the bit string
         * above.
         */
        asc_info[(*num_of_asc)-1].avail_sig_end_idx =
                          avail_sig_count - 1;
        asc_info[(*num_of_asc)-1].avail_sig_start_idx =
                          0;

        /* Set the mask for assigned subchannels to default value of
         * all available sub-channels.
         */
        asc_info[(*num_of_asc)-1].assigned_sub_chan_num =
                          RRCLLC_ASC0_DEFAULT_ASSIGNED_SUBCHAN_MASK;

        MSG_LOW("num_of_asc %d, start %d, end %d", (*num_of_asc),
                      asc_info[(*num_of_asc)-1].avail_sig_start_idx,
                      asc_info[(*num_of_asc)-1].avail_sig_end_idx);

        MSG_LOW("Assigned sub_chan_number for ASC %d is %d",
                             (*num_of_asc),asc_info[(*num_of_asc)-1].assigned_sub_chan_num,0);
      }
      else
      {
        /* For any ASC other than ASC0, copy data from previous Access
         * Service Class */
        asc_info[(*num_of_asc)-1].avail_sig_end_idx =
                asc_info[(*num_of_asc)-2].avail_sig_end_idx;
        asc_info[(*num_of_asc)-1].avail_sig_start_idx =
                asc_info[(*num_of_asc)-2].avail_sig_start_idx;
        asc_info[(*num_of_asc)-1].assigned_sub_chan_num =
                asc_info[(*num_of_asc)-2].assigned_sub_chan_num;

        MSG_LOW("num_of_asc %d, start %d, end %d", (*num_of_asc),
                     asc_info[(*num_of_asc)-1].avail_sig_start_idx,
                     asc_info[(*num_of_asc)-1].avail_sig_end_idx);

        MSG_LOW("Assigned sub_chan_number for ASC %d is %d",
                             (*num_of_asc), asc_info[(*num_of_asc)-1].assigned_sub_chan_num,0);
      }
    }

    /* get the next element */
    (*num_of_asc)++;
    n_value--;
    n_index++;
  } /* end while getting all Partioning Mode info */

  /* Reset the number of Access Service class back to correct value */
  (*num_of_asc)--;

  /* Fill out to the end of the array with copies of the last value */
  for(i = *num_of_asc; i < MAX_ASC; i++)
  {
    asc_info[i].avail_sig_end_idx =
            asc_info[(*num_of_asc)-1].avail_sig_end_idx;
    asc_info[i].avail_sig_start_idx =
            asc_info[(*num_of_asc)-1].avail_sig_start_idx;
    asc_info[i].assigned_sub_chan_num =
            asc_info[(*num_of_asc)-1].assigned_sub_chan_num;

    MSG_LOW("num_of_asc %d, start %d, end %d", (*num_of_asc),
                         asc_info[(*num_of_asc)-1].avail_sig_start_idx,
                         asc_info[(*num_of_asc)-1].avail_sig_end_idx);

    MSG_LOW("Assigned sub_chan_number for ASC %d, %d",
                              (*num_of_asc), asc_info[(*num_of_asc)-1].assigned_sub_chan_num,0);
  }

  /* We now have the number of ASCs supported in num_of_asc */
  return SUCCESS;

} /* end get_prach_partitioning */

/*====================================================================
FUNCTION        get_persist_scaling_default_factors()

DESCRIPITON     This function sets default values of persistence
                scaling factors for all ASCs.

DEPENDENCIES    None

RETURN VALUE    None

SIDE EFFECTS    None
====================================================================*/
void  get_persist_scaling_default_factors(ordered_config_type *config_ptr)
{
  uint8 index = 0;
  do
  {
    config_ptr->psf[index] = RRCLLC_DEFAULT_PERSISTENCE_SCALING_FACTOR_VAL;
    index++;
  }while(index < MAX_ASC_PERSIST);
} /*  get_persist_scaling_default_factors */

/*====================================================================
FUNCTION        get_persist_scaling_factors()

DESCRIPITON     This function takes a pointer to the Persistence Scaling
                Factor info IE and copies it to ORDERED_CONFIG.

DEPENDENCIES    None

RETURN VALUE    SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS    Dynamic Persistence Values from SIB 7 are then needed
                to correctly calculate the Persistence Value needed
                by MAC.
====================================================================*/
uecomdef_status_e_type get_persist_scaling_factors
(
  ordered_config_type  *config_ptr,
  rrc_PersistenceScalingFactorList  *ie_ptr
)
{
  /* local variables */
  uint32 index = 0, n_index = 0, n_value = 0;
  rrc_PersistenceScalingFactorList  *psflist_ptr = ie_ptr;

  if(psflist_ptr == NULL)
  {
    WRRC_MSG0_ERROR("Null pointer received");
    return FAILURE;
  }
  
  n_value = psflist_ptr->n;
  n_index = 0;
  while((n_value !=0) && (index < MAX_ASC_PERSIST))
  {
    /*
    * All the Persistence scaling factors a real numbers in the range
    * from 0.2 to 0.9. The stored values are stored in the ordered config
    * data base according to the following equation:
    *
    * ordered_config psf values = (rcv'd values * 10).
    *
    */
    /* Since this is sent as an enumerated type, time to do the mapping */
    switch(psflist_ptr->elem[n_index])
    {
      case rrc_PersistenceScalingFactor_psf0_2:
        config_ptr->psf[index] = (uint32) 2;
        break;
      case rrc_PersistenceScalingFactor_psf0_3:
        config_ptr->psf[index] = (uint32) 3;
        break;
      case rrc_PersistenceScalingFactor_psf0_4:
        config_ptr->psf[index] = (uint32) 4;
        break;
      case rrc_PersistenceScalingFactor_psf0_5:
        config_ptr->psf[index] = (uint32) 5;
        break;
      case rrc_PersistenceScalingFactor_psf0_6:
        config_ptr->psf[index] = (uint32) 6;
        break;
      case rrc_PersistenceScalingFactor_psf0_7:
        config_ptr->psf[index] = (uint32) 7;
        break;
      case rrc_PersistenceScalingFactor_psf0_8:
        config_ptr->psf[index] = (uint32) 8;
        break;
      case rrc_PersistenceScalingFactor_psf0_9:
        config_ptr->psf[index] = (uint32) 9;
        break;
      default:
        WRRC_MSG1_ERROR("Invalid Persistance Scaling Factor enum %d",psflist_ptr->elem[n_index]);
        return FAILURE;
    } /* end switch */

    /*
    * Note that the first 2 values are calculated outside of this loop, since they
    * are known values.
    */
    /* get the next element */
    n_value--;
    n_index++;
    index++;
  } /* end while MAX_ASC_PERSIST */

  /* Set the default value for the rest of ASCs */
  if(index < MAX_ASC_PERSIST)
  {
    do
    {
      config_ptr->psf[index] = RRCLLC_DEFAULT_PERSISTENCE_SCALING_FACTOR_VAL;
      index++;
    }while(index < MAX_ASC_PERSIST);
  }

  return SUCCESS;
} /* end get_persist_scaling_factors() */

/*====================================================================
FUNCTION        get_ac_to_asc_mapping()

DESCRIPITON     This function takes a pointer to the AC to ASC mapping
                info IE and copies it to ORDERED_CONFIG.

DEPENDENCIES    None

RETURN VALUE    SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS    Previous values in Ordered Config are overwritten.
====================================================================*/
uecomdef_status_e_type get_ac_to_asc_mapping
(
  ordered_config_type  *config_ptr,
  rrc_AC_To_ASC_MappingTable        *ie_ptr
)
{
  /* local variables */
  uint32 index = 0, n_value = 0, n_index = 0;
  rrc_AC_To_ASC_MappingTable   *ascmplist_ptr = ie_ptr;

  /**********************************************************************/
  /* The Access service class mapping follows the table below:          */
  /* ------------------------------------------------------------------ */
  /* |   AC   | 0 - 9 |   10  |   11  |   12  |   13  |   14  |   15  | */
  /* |--------|-------|-------|-------|-------|-------|-------|-------| */
  /* |  ASC   | 1stIE | 2ndIE | 3rdIE | 4thIE | 5thIE | 6thIE | 7thIE | */
  /* ------------------------------------------------------------------ */
  /**********************************************************************/
  /* In other words if the UE supports only AC 0-9 then it selects the  */
  /* Access Service Class given in the first array element.             */
  /* If the UE only supports Access Class 15, then the UE selects the   */
  /* Access Service Class given in the last array element.              */
  /* The IE values are just stored here, and the RRC Connection         */
  /* Establishment procedure must do this mapping correctly.            */
  /**********************************************************************/
  if(ascmplist_ptr == NULL)
  {
    WRRC_MSG0_ERROR("NULL pointer received");
   return(FAILURE);
  } 

  n_value = ascmplist_ptr->n;
  n_index = 0;
  
  while((n_value != 0) && (index < MAX_ASC_MAP))
  {
    if(ascmplist_ptr->elem[n_index] <= RRCLLC_MAX_AC_TO_ASC_MAPPING)
    {
      config_ptr->ac_to_asc_mapping[index] = (uint8)ascmplist_ptr->elem[n_index];
    }
    else
    {
      WRRC_MSG1_ERROR("AC to ASC Mapping value %d is out of range",ascmplist_ptr->elem[n_index]);
      return(FAILURE);
    }

    /* Get the next element */
    n_value--;
    n_index++;
    index++;
  } /* end while */

  return SUCCESS;
} /* end get_ac_to_asc_mapping() */

/*====================================================================
FUNCTION        select_asc_from_ac()

DESCRIPITON     This function selects the ASC from the UE's access
                service class. It uses the AC to ASC mapping to come up
                with the chosen ASC.

DEPENDENCIES    AC to ASC mapping should be present.
                UE's Access class should be available.

RETURN VALUE    None

SIDE EFFECTS    None
====================================================================*/
void  select_asc_from_ac(ordered_config_type *config_ptr)
{
  /* loop index variables */
  uint8 ac_map_index;
  uint8 ac_index;

  /* mask to test which hi access classes are set */
  rrc_hi_access_class_type ac_mask;

  if(rrcrce_get_rrc_est_cause() == RRC_EST_EMERGENCY_CALL) 
  {
    config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_asc =
      0;
  }
  /* If we have no low access class, then we use the second mapping in the
     table.  This is the special "Access Class 10" case referred to in
     section 4.4 of 22.011. */
  else if(rrc_lo_access_class == RRC_LO_ACCESS_CLASS_ABSENT)
  {
    config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_asc =
      config_ptr->ac_to_asc_mapping[1];
  }
  /* If we only have a low access class (0-9), then we always use the first
     mapping in the table, as per section 8.5.13 of 25.331. */
  else if(rrc_hi_access_class == RRC_HI_ACCESS_CLASS_ABSENT)
  {
    config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_asc =
      config_ptr->ac_to_asc_mapping[0];
  }
  /* Otherwise, we use the mapping for the highest-numbered access class, as
     per section 8.5.13 of 25.331. */
  else
  {
    ac_map_index = MAX_ASC_MAP - 1;
    ac_mask = RRC_ACCESS_CLASS_15_BIT;
    for(ac_index = (uint8)RRC_INT_ACCESS_CLASS_15_INDEX;
        ac_index >= (uint8)RRC_INT_ACCESS_CLASS_11_INDEX;
        ac_index--, ac_map_index--, ac_mask >>= 1)
    {
      if(rrc_hi_access_class & ac_mask)
      {
        config_ptr->mac_ul_parms.cctrch_ptr->rach_info.ccch_asc =
          config_ptr->ac_to_asc_mapping[ac_map_index];
        break;
      }
    }
  }
}

/*====================================================================
FUNCTION        get_primary_cpich_tx_pwr()

DESCRIPITON     This function takes a pointer to the primary CPICH Tx
                Power info IE and copies it to ORDERED_CONFIG.

DEPENDENCIES    None

RETURN VALUE    SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS    Previous values in Ordered Config are overwritten.
====================================================================*/
uecomdef_status_e_type get_primary_cpich_tx_pwr
(
  rrcllcoc_l1_ul_init_pwr_type  *  rrc_ul_pwr_init_parms_ptr,
  rrc_PrimaryCPICH_TX_Power pri_cpich_tx_pwr
)
{
  if((pri_cpich_tx_pwr >= RRCLLC_MIN_PRI_CPICH_TX_PWR) &&
     (pri_cpich_tx_pwr <= RRCLLC_MAX_PRI_CPICH_TX_PWR)
    )
  {
    rrc_ul_pwr_init_parms_ptr->primary_cpich_tx_power =
      (int) pri_cpich_tx_pwr;
    return SUCCESS;
  }
  else
  {
    WRRC_MSG1_ERROR("Primary CPICH TX Power %d is out of range", pri_cpich_tx_pwr);
    return FAILURE;
  }
} /* end get_primary_cpich_tx_pwr() */

/*====================================================================
FUNCTION        get_constant_value()

DESCRIPITON     This function takes a pointer to the Constant Value
                info IE and copies it to ORDERED_CONFIG.

DEPENDENCIES    None

RETURN VALUE    SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS    Previous values in Ordered Config are overwritten.
====================================================================*/
uecomdef_status_e_type get_constant_value
(
  rrcllcoc_l1_ul_init_pwr_type  *  rrc_ul_pwr_init_parms_ptr,
  rrc_ConstantValue const_val
)
{
  if((const_val >= RRCLLC_MIN_CONSTANT_VALUE) &&
     (const_val <= RRCLLC_MAX_CONSTANT_VALUE)
    )
  {
    rrc_ul_pwr_init_parms_ptr->constant_value = (int) const_val;
    return (SUCCESS);
  }
  else
  {
    WRRC_MSG1_ERROR("Constant Value %d is out of range", const_val);
    return (FAILURE);
  }
} /* end get_constant_value() */

/*====================================================================
FUNCTION        get_prach_pwr_offset()

DESCRIPITON     This function takes a pointer to the PRACH Power Offset
                info IE and copies it to ORDERED_CONFIG.

DEPENDENCIES    None

RETURN VALUE    SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS    Previous values in Ordered Config are overwritten.
====================================================================*/
uecomdef_status_e_type get_prach_pwr_offset
(
  ordered_config_type  *config_ptr,
  rrc_PRACH_PowerOffset *prach_pwr_offset
)
{
  /* Get the Power Ramp Step */
  if((prach_pwr_offset->powerRampStep >= RRCLLC_MIN_PWR_RAMP_STEP) &&
     (prach_pwr_offset->powerRampStep <= RRCLLC_MAX_PWR_RAMP_STEP)
    )
  {

    config_ptr->l1_ul_chan_parms.prach_cfg.pwr_offset_P0 = (int8)
      prach_pwr_offset->powerRampStep;
  }
  else
  {
    WRRC_MSG1_ERROR("Power Ramp Step %d is out of range", prach_pwr_offset->powerRampStep);
    return FAILURE;
  }

  /* Get the Preamble Retrans Max */
  if((prach_pwr_offset->preambleRetransMax >= RRCLLC_MIN_PREAMBLE_RETRANS_MAX) &&
     (prach_pwr_offset->preambleRetransMax <= RRCLLC_MAX_PREAMBLE_RETRANS_MAX)
    )
  {
    config_ptr->l1_ul_chan_parms.prach_cfg.max_preamble_tx = (uint8)
      prach_pwr_offset->preambleRetransMax;
  }
  else
  {
    WRRC_MSG1_ERROR("PRACH Preamble Retrans Max %d is out of range",
      prach_pwr_offset->preambleRetransMax);
    return FAILURE;
  }

  return SUCCESS;
} /* end get_get_prach_pwr_offset() */

/*====================================================================
FUNCTION        get_rach_xmit_parms()

DESCRIPITON     This function takes a pointer to the RACH Xmit parms
                info IE and copies it to ORDERED_CONFIG.

DEPENDENCIES    None

RETURN VALUE    SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS    Previous values in Ordered Config are overwritten.
====================================================================*/
uecomdef_status_e_type get_rach_xmit_parms
(
  ordered_config_type  *config_ptr,
  rrc_RACH_TransmissionParameters *rach_xmit_parms
)
{
  /* Get the Max # of RACH preamble ramping cycles */
  if((rach_xmit_parms->mmax >= RRCLLC_MIN_MMAX) &&
     (rach_xmit_parms->mmax <= RRCLLC_MAX_MMAX)
    )
  {
    config_ptr->mac_ul_parms.rach_tx_cntl_info.mmax = (uint8)
      rach_xmit_parms->mmax;
  }
  else
  {
    WRRC_MSG1_ERROR("Max # of Preamble Cyles %d is out of range", rach_xmit_parms->mmax);
    return FAILURE;
  }

  /* Get the lower bound of backoff time (units of 10ms) */
  if(rach_xmit_parms->nb01Min <= RRCLLC_MAX_NB01)
  {
    config_ptr->mac_ul_parms.rach_tx_cntl_info.nbo1min = (uint8)
      rach_xmit_parms->nb01Min;
  }
  else
  {
    WRRC_MSG1_ERROR("Backoff Time lower bound %d is out of range", rach_xmit_parms->nb01Min);
    return FAILURE;
  }

  /* Get the upper bound of backoff time (units of 10ms) */
  if(rach_xmit_parms->nb01Max <= RRCLLC_MAX_NB01)
  {
    config_ptr->mac_ul_parms.rach_tx_cntl_info.nbo1max = (uint8)
      rach_xmit_parms->nb01Max;
  }
  else
  {
    WRRC_MSG1_ERROR("Backoff Time upper bound %d is out of range", rach_xmit_parms->nb01Max);
    return FAILURE;
  }

  return SUCCESS;
} /* end get_rach_xmit_parms() */

/*====================================================================
FUNCTION        get_aich_info()

DESCRIPITON     This function takes a pointer to the AICH
                info IE and copies it to ORDERED_CONFIG.

DEPENDENCIES    None

RETURN VALUE    SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS    Previous values in Ordered Config are overwritten.
====================================================================*/
uecomdef_status_e_type get_aich_info
(
  ordered_config_type  *config_ptr,
  rrc_AICH_Info *aich_info_ptr
)
{
  /* Get the channelization code, same as orthoganol variable spreading factor (ovsf)  */
  config_ptr->l1_dl_chan_parms.aich.ovsf = (uint8)
  aich_info_ptr->channelisationCode256;

  /* Get the Standard tranmist Time Diversity (STTD) indicator status */
  config_ptr->l1_dl_chan_parms.aich.tx_div_ind = aich_info_ptr->sttd_Indicator;

  /* Get AICH Transmission Timing */
  switch(aich_info_ptr->aich_TransmissionTiming)
  {
    case rrc_AICH_TransmissionTiming_e0:
      config_ptr->l1_dl_chan_parms.aich.tt = L1_DL_AICH_TT_0;
      break;

    case rrc_AICH_TransmissionTiming_e1:
      config_ptr->l1_dl_chan_parms.aich.tt = L1_DL_AICH_TT_1;
      break;

    default:
      WRRC_MSG1_ERROR("AICH Transmission Time %d is out of range",
        aich_info_ptr->aich_TransmissionTiming);
      return FAILURE;
  } /* end switch AICH Transmission Timing */

  return SUCCESS;
} /* end get_aich_info() */

/*====================================================================
FUNCTION      get_max_allow_ul_tx_pwr()

DESCRIPTION   This function stores the maximum allowed Uplink Tx Power,
              and stores it in ORDERED_CONFIG
              It checks to make sure it is in range.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  None
====================================================================*/
uecomdef_status_e_type get_max_allow_ul_tx_pwr
(
  rrc_MaxAllowedUL_TX_Power max_ul_tx_pwr
)
{

  MSG_MED("Get Max Allowed UL Tx Pwr",0,0,0);

  if((max_ul_tx_pwr >= RRCLLC_MIN_ALLOW_UL_TX_PWR) &&
     (max_ul_tx_pwr <= RRCLLC_MAX_ALLOW_UL_TX_PWR)
    )
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr = (int8) max_ul_tx_pwr;
  }
  else
  {
    WRRC_MSG1_ERROR("Rcv'd invalid UL TX PWR %d",max_ul_tx_pwr);
    return FAILURE;
  }

  /* The presence of a valid value for MAX UL Power implies L1 needs to
   * be reconfigured.
   */
  /*RRC_GKG: If Physical channel IE "maxAllowedUL-TX-Power" is give in the OTA, 
  it means L1 UL needs to be configured.*/
  ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;

  return SUCCESS;
} /* end get_max_allow_ul_tx_pwr() */

/*====================================================================
FUNCTION      get_ul_dpch_info()

DESCRIPTION   This function translates the Uplink DPCH info common for
              all RL (radio links) IE into the RRC config database.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
uecomdef_status_e_type get_ul_dpch_info
(
  rrc_UL_DPCH_Info *ie_ptr
)
{
  MSG_MED("Get UL DPCH Info",0,0,0);

  /* Get the UL DPCH power control information if present */
  if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
             ul_DPCH_PowerControlInfoPresent))
  {
    if(get_ul_dpch_pwr_ctrl_info(&ie_ptr->ul_DPCH_PowerControlInfo) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Make sure of FDD and get the right parameters */
  if(RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
              T_rrc_UL_DPCH_Info_modeSpecificInfo_fdd))
  {
    /* Get the Uplink DPCH Scrambling Code Type */
    switch (ie_ptr->modeSpecificInfo.u.fdd->scramblingCodeType)
    {
      case rrc_ScramblingCodeType_shortSC:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code_type = L1_UL_SC_SHORT;
        break;
      case rrc_ScramblingCodeType_longSC:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code_type = L1_UL_SC_LONG;
        break;
      default:
        WRRC_MSG1_ERROR("UL DPCH Scrambling Code Type %d is invalid",
          ie_ptr->modeSpecificInfo.u.fdd->scramblingCodeType);
        return FAILURE;
    }

    /* Get the scrambling code */
    if(ie_ptr->modeSpecificInfo.u.fdd->scramblingCode <= RRCLLC_MAX_UL_SCR_CODE)
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code = (uint32)
        ie_ptr->modeSpecificInfo.u.fdd->scramblingCode;
    }
    else
    {
      WRRC_MSG1_ERROR("UL Scrambling Code %d is out of range",
        ie_ptr->modeSpecificInfo.u.fdd->scramblingCode);
      return FAILURE;
    }

    /* Get the number of DPDCHs allowed */
    /* There is a mandatory default value of 1; therefore, the need to check for
       it's presence */

    if((ie_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH <= MAX_DPDCH) &&
       (ie_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH >= RRCLLC_DEFAULT_NUM_DPDCH_ALLOWED))
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.num_dpdch = (uint8)
        ie_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH;
    }
    else
    {
      WRRC_MSG1_ERROR("# of UL DPDCHs %d is out of range",
        ie_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH);
      return FAILURE;
    }


    /* Get the spreading factor */
    switch(ie_ptr->modeSpecificInfo.u.fdd->spreadingFactor)
    {
      case rrc_SpreadingFactor_sf4:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_4;
        break;
      case rrc_SpreadingFactor_sf8:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_8;
        break;
      case rrc_SpreadingFactor_sf16:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_16;
        break;
      case rrc_SpreadingFactor_sf32:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_32;
        break;
      case rrc_SpreadingFactor_sf64:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_64;
        break;
      case rrc_SpreadingFactor_sf128:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_128;
        break;
      case rrc_SpreadingFactor_sf256:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_256;
        break;
      default:
        WRRC_MSG1_ERROR("Invalid Spreading Factor %d received",
          ie_ptr->modeSpecificInfo.u.fdd->spreadingFactor);
        return FAILURE;
    } /* end spreading factor switch */

    /* get the TFCI existence */
    if(ie_ptr->modeSpecificInfo.u.fdd->tfci_Existence)
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = TRUE;
    }
    else
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = FALSE;
    }

    /* get the FBI bits if necessary */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
               numberOfFBI_BitsPresent))
    {
      switch(ie_ptr->modeSpecificInfo.u.fdd->numberOfFBI_Bits)
      {
        case 1:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_1;
          break;
        default:
          WRRC_MSG1_ERROR("Invalid # of FBI bits %d received",
            ie_ptr->modeSpecificInfo.u.fdd->numberOfFBI_Bits);
          return FAILURE;
      }
    }
    else
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_0;
    }

    /*
    * Get the UL DPCH Puncturing Limit. The OTA Msg receives this value as an enum.
    * The puncturing limit is a real number between 0.4 and 1.0 in steps of 0.04.
    * L1 expects this value to be from 40 to 100; in other words, L1 expects
    * l1_puncturing_limit = puncturing_limit * 100;
    * Therefore in the ASN.1 enum type the first enum value 0 corresponds to 0.4,
    * 1 corresponds to 0.44, etc... . Hence the following equation is derived:
    * l1_puncturing_limit = (ASN.1_enum_type * 4) + 40;
    * If this enum changes, this equation may need tweaking or else, this can
    * be broken into a switch with multiple cases.
    */
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim = (uint8)
      (((uint8)(ie_ptr->modeSpecificInfo.u.fdd->puncturingLimit) * 4) + 40);

    if((ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim < RRCLLC_MIN_PUNCTURING_LIMIT)
      || (ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim > RRCLLC_MAX_PUNCTURING_LIMIT))
    {
      WRRC_MSG1_ERROR("UL DPCH puncturing limit %d is out of range",
        ordered_config_ptr->l1_ul_chan_parms.prach_cfg.punct_lim);
      return FAILURE;
    }

#ifdef FEATURE_WCDMA_CPC_DTX
    /*Intialize numtpc to 2 Since this  I.E will only come as part of Rel-7 OTA message*/
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.numtpc = L1_UL_NUM_TPC_BITS_2;
#endif

  } /* end FDD if */
  else
  {
    return FAILURE;
  }

  /* If made it here, all is well */
  /* Indicate that Uplink L1 needs to be reconfigured */
  ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
  return SUCCESS;
} /* end get_ul_dpch_info() */


/*============================================================================
FUNCTION: rrcllcpcie_is_hho()

DESCRIPTION:
  This function returns boolean value based on whether inter-freq or intra-freq
  HHO is ongoing. 

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE - HHO in progress
  FALSE - No HHO

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_is_hho
(
  OSS_UINT32 dl_info_per_rl_list_present,
  rrc_DL_InformationPerRL_List *dl_info_per_rl_list_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  boolean is_hho = FALSE, old_rl_seen = FALSE, new_rl_seen = FALSE;
  rrc_freq_type rrc_freq = rrc_ccm_get_curr_camped_freq();
  rrc_DL_InformationPerRL_List *tmp_ie_ptr = dl_info_per_rl_list_ptr;
  rrc_state_e_type curr_rrc_state = rrc_get_state();
  uint32 n_index, n_value;

  if ((rcvd_state_indicator == rrc_RRC_StateIndicator_cell_DCH) && 
      (dl_info_per_rl_list_present))
  {
    /* Consider the following conditions as HHO:  
                   - Inter freq 
                   - Itra freq with disjoint ASET
                   - First time into CELL_DCH
    */
    is_hho = ((ordered_config_ptr->dest_freq_present &&
               ordered_config_ptr->dest_freq != rrc_freq) || 
              (curr_rrc_state != RRC_STATE_CELL_DCH));
    
    if (FALSE == is_hho)
    {
      n_value = tmp_ie_ptr->n;
      n_index = 0;
      while(n_value != 0)
      {
       if(get_dl_rl_idx_to_update(
           tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode,
           RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo,
                             T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd),
          &ordered_config_ptr->l1_dl_chan_parms) <
          ordered_config_ptr->l1_dl_chan_parms.num_rl)
        {
          old_rl_seen = TRUE;
        }
        else
        {
          new_rl_seen = TRUE;
        }
  
        /* We can bail out early if we detect a mixed active set. */
        if(old_rl_seen && new_rl_seen)
        {
          WRRC_MSG0_ERROR("Mixed ASET detected, rejecting");
          return FAILURE;
        }
        n_value--;
        n_index++;
      }
      /* if new RL seen is true then it means its a dis-joint set and hence its
         value will indicate whether its HHO or not. */
      is_hho = new_rl_seen;
      
    }
  
    if (TRUE == is_hho)
    {
      MSG_HIGH("HHO detected DCH trans %d intra-freq %d inter-freq %d ",
               (curr_rrc_state != RRC_STATE_CELL_DCH), 
               new_rl_seen,
               (ordered_config_ptr->dest_freq_present &&
                ordered_config_ptr->dest_freq != rrc_freq));
    }
  }

  ordered_config_ptr->is_hho = is_hho;
  return(SUCCESS);
}


/*====================================================================
FUNCTION        get_dl_rl_idx_to_update_r5()

DESCRIPTION     This function retrieves the RL index for a given
                scrambling code in a Downlink information for each
                radio link IE

DEPENDENCIES    NONE

RETURN VALUE    RL index if found, UE_MAX_RL otherwise.

SIDE EFFECTS
====================================================================*/
static uint8 get_dl_rl_idx_to_update_r5
(
  rrc_DL_InformationPerRL_r5 *ie_ptr,
  l1_dl_phychan_db_struct_type *dl_phychan
)
{
  uint8 idx;

  for(idx = 0; idx < UE_MAX_RL; idx++)
  {
    if(RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
       T_rrc_DL_InformationPerRL_r5_modeSpecificInfo_fdd))
    {
      if(dl_phychan->dl_per_rl[idx].pri_cpich_scr_code ==
         ie_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode)
      {
        return idx;
      }

    }
    else
    {
      /* No FDD info.  We don't support TDD so return indicating an error */
      WRRC_MSG0_ERROR("No FDD info present in DL_INFO_FOR_EACH_RL");
      return UE_MAX_RL;
    }
  }

  /* If we got all the way here, idx will be set to UE_MAX_RL. */
  return idx;
}


/*============================================================================
FUNCTION: rrcllcpcie_is_hho_r5()

DESCRIPTION:
  This function returns boolean value based on whether inter-freq or intra-freq
  HHO is ongoing. 

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE - HHO in progress
  FALSE - No HHO

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_is_hho_r5
(
  OSS_UINT32 dl_info_per_rl_list_present,
  rrc_DL_InformationPerRL_List_r5 *dl_info_per_rl_list_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  boolean is_hho = FALSE, old_rl_seen = FALSE, new_rl_seen = FALSE;
  rrc_freq_type rrc_freq = rrc_ccm_get_curr_camped_freq();
  rrc_DL_InformationPerRL_List_r5 *tmp_ie_ptr = dl_info_per_rl_list_ptr;
  rrc_state_e_type curr_rrc_state = rrc_get_state();
  uint32 n_index, n_value;

  if ((rcvd_state_indicator == rrc_RRC_StateIndicator_cell_DCH) && 
      (dl_info_per_rl_list_present))
  {
    /* Consider the following conditions as HHO:  
                   - Inter freq 
                   - Itra freq with disjoint ASET
                   - First time into CELL_DCH
    */
    is_hho = ((ordered_config_ptr->dest_freq_present &&
               ordered_config_ptr->dest_freq != rrc_freq) || 
              (curr_rrc_state != RRC_STATE_CELL_DCH));
    
    if (FALSE == is_hho)
    {
      n_value = tmp_ie_ptr->n;
      n_index = 0;
      while(n_value != 0)
      {
        if(get_dl_rl_idx_to_update_r5(&tmp_ie_ptr->elem[n_index],
          &ordered_config_ptr->l1_dl_chan_parms) <
          ordered_config_ptr->l1_dl_chan_parms.num_rl)
        {
          old_rl_seen = TRUE;
        }
        else
        {
          new_rl_seen = TRUE;
        }
  
        /* We can bail out early if we detect a mixed active set. */
        if(old_rl_seen && new_rl_seen)
        {
          WRRC_MSG0_ERROR("Mixed ASET detected, rejecting");
          return (FAILURE);
        }
        n_value--;
        n_index++;
      }
      /* if new RL seen is true then it means its a dis-joint set and hence its
         value will indicate whether its HHO or not. */
      is_hho = new_rl_seen;
      
    }
  
    if (TRUE == is_hho)
    {
      MSG_HIGH("HHO detected DCH trans %d intra-freq %d inter-freq %d ",
               (curr_rrc_state != RRC_STATE_CELL_DCH), 
               (ordered_config_ptr->dest_freq_present &&
               ordered_config_ptr->dest_freq != rrc_freq), 
               new_rl_seen);
    }
  }

  ordered_config_ptr->is_hho = is_hho;

  return(SUCCESS);
}


/*====================================================================
FUNCTION: rrcllc_is_cm_active()

DESCRIPTION:
  Determines if Compressed Mode is Active

DEPENDENCIES:
  None.

RETURN VALUE:
  True if CM is active/going to be active
  False if CM is inactive/going to be inactive

SIDE EFFECTS:
====================================================================*/
boolean rrcllc_is_cm_active(ordered_config_type  *config_ptr)
{
  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    uint8 cnt = 0;
    /* Check if the TGPSI is active */
    for (cnt =0; cnt < config_ptr->cm_info.tgp_seq_info_count; cnt++)
    {
      if ((config_ptr->tgp_seq_info[cnt].tgp_seq_id != 0) &&
        (config_ptr->tgp_seq_info[cnt].active == TRUE))
      {
        WRRC_MSG1_HIGH("RRCHS:CM Pattern %d, ACTIVE", 
          config_ptr->tgp_seq_info[cnt].tgp_seq_id);
        return TRUE;
      }
    }
    return FALSE;
  }
  return FALSE;
}



/*===========================================================================

FUNCTION          rrc_is_eul_active


DESCRIPTION       

  This function returns whether HSUPA / EUL is active or not at a given moment.
  for input, if OC is not set then use current_config_ptr, else use ordered_config_ptr.

DEPENDENCIES


RETURN VALUE
                  
  TRUE/FALSE

SIDE EFFECTS
                  
  None

===========================================================================*/
boolean rrc_is_eul_active
(
  void
)
{

  ordered_config_type *config_ptr;

  if( config_ptr_in_use == CURRENT_CONFIG)
  {
    config_ptr = current_config_ptr;
    WRRC_MSG0_MED("Using cc to get edch transmission");
  }
  else 
  {
    WRRC_MSG0_MED("Using oc to get edch transmission");
    config_ptr = ordered_config_ptr;
  }

  if(config_ptr == NULL )
    return FALSE;

  return(config_ptr->e_dch_transmission);
}

/*===========================================================================

FUNCTION          rrc_is_cm_active_with_eul


DESCRIPTION       

  This function returns whether EUL is active with compressed mode of not.
  This function doesnt checks the condition when CM is going to de-activate before
  activation time is reached. Its a known limitation from the design phase.

DEPENDENCIES


RETURN VALUE
                  
  TRUE/FALSE

SIDE EFFECTS
                  
  None

===========================================================================*/
boolean rrc_is_cm_active_with_eul
(
  ordered_config_type *config_ptr
)
{
  uint8 num_cm_patterns_active = l1_cm_query_num_of_cm_patterns_active();
  boolean timing_init_in_progress_flag = rrcllc_timing_init_in_progress();

  MSG_HIGH("RRCEUL: cmStatusFomOTA: %d(0: N, 9: A, 1..8:D), numCM-patternActive: %d, TI-HHO: %d", 
    cm_status_from_ota_msg, num_cm_patterns_active, timing_init_in_progress_flag);
  return(
    (rrc_is_eul_active()) && 
    ((ACTIVATE_CM == cm_status_from_ota_msg) ||

     ((num_cm_patterns_active != 0) && 
    /*  if CM is active then we need to check whether received message deactivates
        all the configured CM patters or not */
    /* <= because we need to cover cases for CM patterns which gets de-activated just
       before reconfig message is precessed */
      !((num_cm_patterns_active <= cm_status_from_ota_msg) || 
    /* check for TI hho because TI hho results in implicit deactivation of all
       activated CM patters */
       (TRUE  == timing_init_in_progress_flag)
      )
     )
    )
   );
}


/*====================================================================
FUNCTION      get_ul_dpch_pwr_ctrl_info_per_r4_rrc_connection()

DESCRIPTION   This function translates the Uplink DPCH Power Control
              info common for all RL (radio links) IE into the RRC
              config database for RRC Connection Setup Message for Rel 5
              whihc is different from other Reconfig Message for Rel 5


DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
static uecomdef_status_e_type get_ul_dpch_pwr_ctrl_info_per_r4_rrc_connection
(
  rrc_UL_DPCH_PowerControlInfo_r4 *ie_ptr
)
{
  if(RRC_CHECK_COMMON_MSG_TYPE_PTR(ie_ptr,
              rrc_UL_DPCH_PowerControlInfo_r4_fdd))
  {
    /* Set the valid bit if made it this far */
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid = TRUE;

    /* Get the DPCCH Power Offset (value in dB) */
    if((ie_ptr->u.fdd->dpcch_PowerOffset <= RRCLLC_UL_DPCCH_PWR_OFFSET_MAX) &&
      (ie_ptr->u.fdd->dpcch_PowerOffset >= RRCLLC_UL_DPCCH_PWR_OFFSET_MIN))
    {
      /* The value sent over the air needs to be doubled */
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset =
        (int16) (ie_ptr->u.fdd->dpcch_PowerOffset * 2);
    }
    else
    {
      WRRC_MSG1_ERROR("UL DPCCH Power Offset %d is out of range",
        ie_ptr->u.fdd->dpcch_PowerOffset);
      return FAILURE;
    }

    /* Get the PC Preamble */

    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len
      = (uint8)ie_ptr->u.fdd->pc_Preamble;

    /* Get SRB_Delay */
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay
      = (uint8)ie_ptr->u.fdd->sRB_delay;

    /* Get the Power Control Algorithm */
    if(RRC_CHECK_MSG_TYPE(ie_ptr->u.fdd->powerControlAlgorithm,
                T_rrc_PowerControlAlgorithm_algorithm1))
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pca =
        L1_UL_PCA_ONE;
      if(ie_ptr->u.fdd->powerControlAlgorithm.u.algorithm1 == 0)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.tpc_step_size =
          L1_UL_TPC_STEP_ONE;
      }
      else if(ie_ptr->u.fdd->powerControlAlgorithm.u.algorithm1 == 1)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.tpc_step_size =
          L1_UL_TPC_STEP_TWO;
      }
      else
      {
        WRRC_MSG1_ERROR("TPC Step size %d is out of range",
          ie_ptr->u.fdd->powerControlAlgorithm.u.algorithm1);
        return FAILURE;
      } /* end if-else check for Algorithm 1 and TPC step size */
    }
    else if (RRC_CHECK_MSG_TYPE(ie_ptr->u.fdd->powerControlAlgorithm,
                  T_rrc_PowerControlAlgorithm_algorithm2))
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pca =
        L1_UL_PCA_TWO;
    }
    else
    {
      WRRC_MSG0_ERROR("Invalid UL Power Control Algorithm specified");
      return FAILURE;
    } /* end if-else check for UL power control algorithm check */
  } /* end FDD check */

  else /* only TDD */
  {
    return FAILURE;
  }

  return SUCCESS;
} /* end get_ul_dpch_pwr_ctrl_info_per_r4_rrc_connection() */


/*====================================================================
FUNCTION      get_ul_dpch_info_per_r4_rrc_connection()

DESCRIPTION   This function translates the Uplink DPCH info common for
              all RL (radio links) IE into the RRC config database
              for RRC Connection Setup Message.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
uecomdef_status_e_type get_ul_dpch_info_per_r4_rrc_connection
(
  rrc_UL_DPCH_Info_r4 *ie_ptr
)
{
  MSG_MED("Get UL DPCH Info",0,0,0);

  /* Get the UL DPCH power control information if present */
  if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr, 
               ul_DPCH_PowerControlInfoPresent)
    )
  {
    if(get_ul_dpch_pwr_ctrl_info_per_r4_rrc_connection(&ie_ptr->ul_DPCH_PowerControlInfo) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Make sure of FDD and get the right parameters */
  if(RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
              T_rrc_UL_DPCH_Info_r4_modeSpecificInfo_fdd))
  {
    /* Get the Uplink DPCH Scrambling Code Type */
    switch (ie_ptr->modeSpecificInfo.u.fdd->scramblingCodeType)
    {
      case rrc_ScramblingCodeType_shortSC:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code_type = L1_UL_SC_SHORT;
        break;
      case rrc_ScramblingCodeType_longSC:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code_type = L1_UL_SC_LONG;
        break;
      default:
        WRRC_MSG1_ERROR("UL DPCH Scrambling Code Type %d is invalid",
          ie_ptr->modeSpecificInfo.u.fdd->scramblingCodeType);
        return FAILURE;
    }

    /* Get the scrambling code */
    if(ie_ptr->modeSpecificInfo.u.fdd->scramblingCode <= RRCLLC_MAX_UL_SCR_CODE)
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code = (uint32)
        ie_ptr->modeSpecificInfo.u.fdd->scramblingCode;
    }
    else
    {
      WRRC_MSG1_ERROR("UL Scrambling Code %d is out of range",
        ie_ptr->modeSpecificInfo.u.fdd->scramblingCode);
      return FAILURE;
    }


    if((ie_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH <= MAX_DPDCH) &&
       (ie_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH >= RRCLLC_DEFAULT_NUM_DPDCH_ALLOWED))
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.num_dpdch = (uint8)
        ie_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH;
    }
    else
    {
      WRRC_MSG1_ERROR("# of UL DPDCHs %d is out of range",
        ie_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH);
      return FAILURE;
    }


    /* Get the spreading factor */
    switch(ie_ptr->modeSpecificInfo.u.fdd->spreadingFactor)
    {
      case rrc_SpreadingFactor_sf4:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_4;
        break;
      case rrc_SpreadingFactor_sf8:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_8;
        break;
      case rrc_SpreadingFactor_sf16:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_16;
        break;
      case rrc_SpreadingFactor_sf32:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_32;
        break;
      case rrc_SpreadingFactor_sf64:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_64;
        break;
      case rrc_SpreadingFactor_sf128:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_128;
        break;
      case rrc_SpreadingFactor_sf256:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_256;
        break;
      default:
        WRRC_MSG1_ERROR("Invalid Spreading Factor %d received",
          ie_ptr->modeSpecificInfo.u.fdd->spreadingFactor);
        return FAILURE;
    } /* end spreading factor switch */

    /* get the TFCI existence */
    if(ie_ptr->modeSpecificInfo.u.fdd->tfci_Existence)
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = TRUE;
    }
    else
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = FALSE;
    }

    /* get the FBI bits if necessary */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                 numberOfFBI_BitsPresent))
    {
      switch(ie_ptr->modeSpecificInfo.u.fdd->numberOfFBI_Bits)
      {
        case 1:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_1;
          break;
        default:
          WRRC_MSG1_ERROR("Invalid # of FBI bits %d received",
            ie_ptr->modeSpecificInfo.u.fdd->numberOfFBI_Bits);
          return FAILURE;
      }
    }
    else
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_0;
    }

    /*
    * Get the UL DPCH Puncturing Limit. The OTA Msg receives this value as an enum.
    * The puncturing limit is a real number between 0.4 and 1.0 in steps of 0.04.
    * L1 expects this value to be from 40 to 100; in other words, L1 expects
    * l1_puncturing_limit = puncturing_limit * 100;
    * Therefore in the ASN.1 enum type the first enum value 0 corresponds to 0.4,
    * 1 corresponds to 0.44, etc... . Hence the following equation is derived:
    * l1_puncturing_limit = (ASN.1_enum_type * 4) + 40;
    * If this enum changes, this equation may need tweaking or else, this can
    * be broken into a switch with multiple cases.
    */
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim = (uint8)
      (((uint8)(ie_ptr->modeSpecificInfo.u.fdd->puncturingLimit) * 4) + 40);

    if((ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim < RRCLLC_MIN_PUNCTURING_LIMIT)
      || (ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim > RRCLLC_MAX_PUNCTURING_LIMIT))
    {
      WRRC_MSG1_ERROR("UL DPCH puncturing limit %d is out of range",
        ordered_config_ptr->l1_ul_chan_parms.prach_cfg.punct_lim);
      return FAILURE;
    }

#ifdef FEATURE_WCDMA_CPC_DTX
    /*Intialize numtpc to 2 Since this  I.E will only come as part of Rel-7 OTA message*/
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.numtpc = L1_UL_NUM_TPC_BITS_2;
#endif
  } /* end FDD if */
  else
  {
    return FAILURE;
  }

  /* If made it here, all is well */
  /* Indicate that Uplink L1 needs to be reconfigured */
  ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
  return SUCCESS;
} /* end get_ul_dpch_info_per_r4_rrc_connection() */

/*====================================================================
FUNCTION      set_meas_feedback_info()

DESCRIPTION   This function sets the Meas Feedback Information in
              L1 structure in OC.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire operation is successful,
              FAILURE otherwise

SIDE EFFECTS  None.
====================================================================*/

uecomdef_status_e_type set_meas_feedback_info
(
  rrc_Measurement_Feedback_Info* meas_feedback_ptr
)
{
  if (RRC_CHECK_MSG_TYPE(meas_feedback_ptr->modeSpecificInfo,
              T_rrc_Measurement_Feedback_Info_modeSpecificInfo_fdd))
  {
    if ((meas_feedback_ptr->modeSpecificInfo.u.fdd->cqi_RepetitionFactor <
      RRCLLC_CQI_MIN_REP_FACTOR) && (meas_feedback_ptr->modeSpecificInfo.
      u.fdd->cqi_RepetitionFactor > RRCLLC_CQI_MAX_REP_FACTOR))
    {
      WRRC_MSG1_ERROR("RRCHS:Invalid CQI Rfactor %d, 1..4",
        meas_feedback_ptr->modeSpecificInfo.u.fdd->cqi_RepetitionFactor);
      return FAILURE;
    }


    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_rep_factor =
      (uint8) meas_feedback_ptr->modeSpecificInfo.u.fdd->cqi_RepetitionFactor;

    if (meas_feedback_ptr->modeSpecificInfo.u.fdd->deltaCQI > RRCLLC_DELTA_CQI_MAX)
    {
      WRRC_MSG1_ERROR("RRCHS:Invalid DELTA CQI %d, 0..8",
        meas_feedback_ptr->modeSpecificInfo.u.fdd->deltaCQI);
      return FAILURE;
    }
    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_cqi = (uint8)
      meas_feedback_ptr->modeSpecificInfo.u.fdd->deltaCQI;


    

    switch(meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle)
    {
    case rrc_Feedback_cycle_fc0:
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 0;
      break;

    case rrc_Feedback_cycle_fc2:
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 2;
      break;

    case rrc_Feedback_cycle_fc4:
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 4;
      break;

    case rrc_Feedback_cycle_fc8:
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 8;
      break;

    case rrc_Feedback_cycle_fc10:
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 10;
      break;

    case rrc_Feedback_cycle_fc20:
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 20;
      break;

    case rrc_Feedback_cycle_fc40:
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 40;
      break;

    case rrc_Feedback_cycle_fc80:
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 80;
      break;

    case rrc_Feedback_cycle_fc160:
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 160;
      break;

    default:
      WRRC_MSG1_ERROR("RRCHS:Incorrect Value",
        meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle);
      return FAILURE;

    }




    if ((meas_feedback_ptr->modeSpecificInfo.u.fdd->measurementPowerOffset <
      RRCLLC_MIN_MEAS_POWER_OFFSET) &&
      (meas_feedback_ptr->modeSpecificInfo.u.fdd->measurementPowerOffset >
      RRCLLC_MAX_MEAS_POWER_OFFSET))

    {
      WRRC_MSG1_ERROR("RRCHS:Invalid MeasPowerOffset %d, -12..26",
        meas_feedback_ptr->modeSpecificInfo.u.fdd->measurementPowerOffset);
      return FAILURE;
    }


    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.po_hs_dsch = (int8)
      meas_feedback_ptr->modeSpecificInfo.u.fdd->measurementPowerOffset;
    /* rrc_UL_DPCH_PowerControlInfo_r5 : ACK/NACK/REPITITON factor from Power Control */
  }
  else
  {
    WRRC_MSG0_ERROR("RRCHS:Invalid Meas Feedback Info");
    return FAILURE;
  }
  return SUCCESS;

}


/*====================================================================
FUNCTION      rrcllc_check_if_hsscch_changed()

DESCRIPTION   This function checks if HS-SCCH Info has changed.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire operation is successful,
              FAILURE otherwise

SIDE EFFECTS  None.
====================================================================*/
boolean rrcllc_check_if_hsscch_changed
(
  void* scch_info_ptr,
  rrc_msg_ver_enum_type msg_version
)
{
  
  uint8 cnt = 0;
  rrc_HS_SCCH_Info_hS_SCCHChannelisationCodeInfo   *local_scch_ptr = NULL;
  rrc_HS_SCCH_Info_fdd     *local_scch_fdd_ptr;
#if defined(FEATURE_WCDMA_REL9) || defined(FEATURE_WCDMA_REL10)
  if(msg_version == MSG_REL9 || msg_version == MSG_REL10)
  {
   /* Typecasting local_scch_ptr to R5 struct as OSS uses the same struct type for R5 and R9
    * OB uses the different struct for R5 and R9 but same struct for internal I.E's */
   rrc_HS_SCCH_Info_r9* scch_info_r9_ptr=(rrc_HS_SCCH_Info_r9*) scch_info_ptr ;
   if (RRC_CHECK_MSG_TYPE(scch_info_r9_ptr->modeSpecificInfo,
                T_rrc_HS_SCCH_Info_r9_modeSpecificInfo_tdd))
   {
     MSG_MED("RRCHS:TDD selected. Bail out",0,0,0);
     return FALSE;
   }
   local_scch_ptr = (rrc_HS_SCCH_Info_hS_SCCHChannelisationCodeInfo*)
                      &scch_info_r9_ptr->modeSpecificInfo.u.fdd->hS_SCCHChannelisationCodeInfo;
   local_scch_fdd_ptr = (rrc_HS_SCCH_Info_fdd*)scch_info_r9_ptr->modeSpecificInfo.u.fdd;
  }
  else
#endif
  if((msg_version == MSG_REL7)
    ||(msg_version == MSG_REL8)
  )
  {
   /* Typecasting local_scch_ptr to R5 struct as OSS uses the same struct type for R5 and R7.
    * OB uses the different struct for R5 and R7 but same struct for internal I.E's */
   rrc_HS_SCCH_Info_r7* scch_info_r7_ptr=(rrc_HS_SCCH_Info_r7*) scch_info_ptr ;
   if (RRC_CHECK_MSG_TYPE(scch_info_r7_ptr->modeSpecificInfo,
                T_rrc_HS_SCCH_Info_r7_modeSpecificInfo_tdd))
   {
     MSG_MED("RRCHS:TDD selected. Bail out",0,0,0);
     return FALSE;
   }
   local_scch_ptr = (rrc_HS_SCCH_Info_hS_SCCHChannelisationCodeInfo*)
                      &scch_info_r7_ptr->modeSpecificInfo.u.fdd->hS_SCCHChannelisationCodeInfo;
   local_scch_fdd_ptr = (rrc_HS_SCCH_Info_fdd*)scch_info_r7_ptr->modeSpecificInfo.u.fdd;
  }
  else 
  if(msg_version == MSG_REL6)
  {
    rrc_HS_SCCH_Info_r6* scch_info_r6_ptr=(rrc_HS_SCCH_Info_r6*) scch_info_ptr ;
    if (RRC_CHECK_MSG_TYPE(scch_info_r6_ptr->modeSpecificInfo,
                  T_rrc_HS_SCCH_Info_r6_modeSpecificInfo_tdd))
    {
      MSG_MED("RRCHS:TDD selected. Bail out",0,0,0);
      return FALSE;
    }
    local_scch_ptr = (rrc_HS_SCCH_Info_hS_SCCHChannelisationCodeInfo*)
                        &scch_info_r6_ptr->modeSpecificInfo.u.fdd->hS_SCCHChannelisationCodeInfo;
    local_scch_fdd_ptr = (rrc_HS_SCCH_Info_fdd*)scch_info_r6_ptr->modeSpecificInfo.u.fdd;
  }
  else if(msg_version == MSG_REL5) 
  {
    rrc_HS_SCCH_Info* scch_info_r5_ptr=(rrc_HS_SCCH_Info *) scch_info_ptr ;
    if (RRC_CHECK_MSG_TYPE(scch_info_r5_ptr->modeSpecificInfo,
                T_rrc_HS_SCCH_Info_modeSpecificInfo_tdd))
    {
      MSG_MED("RRCHS:TDD selected. Bail out",0,0,0);
      return FALSE;
    }
    local_scch_ptr = &scch_info_r5_ptr->modeSpecificInfo.u.fdd->hS_SCCHChannelisationCodeInfo;
    local_scch_fdd_ptr = scch_info_r5_ptr->modeSpecificInfo.u.fdd;
  }
  else
  {
    WRRC_MSG1_ERROR("Invalid MSG version %d",msg_version);
    return FALSE;
  }

  
  /* Check if Sec Scr Code present */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(local_scch_fdd_ptr,
                 dl_ScramblingCodePresent))
  {
    if (ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code_valid == FALSE)
    {
      WRRC_MSG0_HIGH("RRCHS:SSC changed in new config");
      return TRUE;
    }
    else
    {
      /* SSC Present. Check if it is the same as old one */
      if (ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code != 
          (uint8) local_scch_fdd_ptr->dl_ScramblingCode)
      {
        WRRC_MSG2_HIGH("RRCHS:SSC changed Old %d, New %d",
                 ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code,
                 local_scch_fdd_ptr->dl_ScramblingCode);
        return TRUE;
      }

    }
  }
  else
  {
    /* Check if SSC was present in old config and network did not specify in new config */
    if (ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code_valid == TRUE)
    {
      WRRC_MSG0_HIGH("RRCHS:SSC changed in new config");
      return TRUE;
    }
  }
  cnt = 0; 
  while (local_scch_ptr->n > cnt)
  {
    
    if(!(( cnt < ordered_config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code)
		&&(ordered_config_ptr->l1_hsdpa_info.hs_scch_info.ch_code[cnt] == local_scch_ptr->elem[cnt])))
    {
      WRRC_MSG2_HIGH("RRCHS:New SCCH Ch Code %d not present at idx %d",local_scch_ptr->elem[cnt],cnt);
      return TRUE;
    }
    /* Re-Initialize Match found to FALSE */
    cnt++;
  }
  
  if((cnt !=0) && (ordered_config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code != cnt )  )
  {
    WRRC_MSG2_HIGH("RRCHS:New SCCH Ch Codes totoal num %d not equal to existing in OC %d",
         cnt,ordered_config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code);
    return TRUE;
  }
  WRRC_MSG0_MED("RRCHS:SCCH CH Code not changed");

  return FALSE;
}

/*====================================================================
FUNCTION      rrcllc_check_if_meas_feedback_changed()

DESCRIPTION   This function checks if Meas Feedback Info has changed.

DEPENDENCIES  None

RETURN VALUE  True if FDD specifed in Meas Feedback Cycle. False otherwise

SIDE EFFECTS  None.
====================================================================*/
void rrcllc_check_if_meas_feedback_changed
(
  rrc_Measurement_Feedback_Info* meas_feedback_ptr,
  boolean* beta_table_changed,
  boolean* dpcch_changed
)
{
  uint8 tmp_meas_feedback_cycle = 0;

  if (RRC_CHECK_MSG_TYPE(meas_feedback_ptr->modeSpecificInfo,
                T_rrc_Measurement_Feedback_Info_modeSpecificInfo_tdd))
  {
    return;
  }

  if (((uint8)meas_feedback_ptr->modeSpecificInfo.u.fdd->cqi_RepetitionFactor) != 
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_rep_factor)
  {
    WRRC_MSG2_HIGH("RRCHS:Existing CQI.RepFac %d, New %d", 
             ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_rep_factor,
             (uint8)meas_feedback_ptr->modeSpecificInfo.u.fdd->cqi_RepetitionFactor);
    *dpcch_changed = TRUE;
    
  }
  if (((uint8)meas_feedback_ptr->modeSpecificInfo.u.fdd->deltaCQI) != 
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_cqi)
  {
    WRRC_MSG2_HIGH("RRCHS:Existing DeltaCQI %d, New %d", 
             ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_cqi,
             (uint8)meas_feedback_ptr->modeSpecificInfo.u.fdd->deltaCQI);
    *beta_table_changed = TRUE;

  }
  tmp_meas_feedback_cycle = 
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_fc0) ? 0 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_fc2) ? 2 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_fc4) ? 4 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_fc8) ? 8 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_fc10) ? 10 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_fc20) ? 20 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_fc40) ? 40 :
    (meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle == rrc_Feedback_cycle_fc80) ? 80 : 160;

  if (tmp_meas_feedback_cycle != ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle)
  {
    WRRC_MSG2_HIGH("RRCHS:Existing CQI FC %d, New %d", 
           ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle,
           tmp_meas_feedback_cycle);
   *dpcch_changed = TRUE;
  }

  /* Meas Power Offset */
  if (((int8)meas_feedback_ptr->modeSpecificInfo.u.fdd->measurementPowerOffset) !=
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.po_hs_dsch)
  {
    WRRC_MSG2_HIGH("RRCHS:Existing PowerOffset %d, New %d", 
           ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.po_hs_dsch,
           (int8)meas_feedback_ptr->modeSpecificInfo.u.fdd->measurementPowerOffset);
    *dpcch_changed = TRUE;
  }

  return;
}

/*====================================================================
FUNCTION      set_hsscch_info()

DESCRIPTION   This function sets the Channelization code required
              for HSPDSCH in L1 structure in OC.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire operation is successful,
              FAILURE otherwise

SIDE EFFECTS  None.
====================================================================*/
uecomdef_status_e_type set_hsscch_info
(
  rrc_HS_SCCH_Info* hsscch_info_ptr
)
{
  struct rrc_HS_SCCH_Info_hS_SCCHChannelisationCodeInfo *hsscch_list_ptr = NULL;

  uint8 cnt = 0;
  uint32 n_index, n_value;

  ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code_valid = FALSE;
  if(hsscch_info_ptr->modeSpecificInfo.t == T_rrc_HS_SCCH_Info_modeSpecificInfo_tdd)
  {
    return FAILURE;
  }

  /* Sec Scr Code unsupported by L1 */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(hsscch_info_ptr->modeSpecificInfo.u.fdd,
                dl_ScramblingCodePresent))
  {

    if ((hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode == 0) ||
        (hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode > 15))
    {
      WRRC_MSG1_ERROR("RRCHS:Incorrect Sec Scr Code %d",
          hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode);
      return FAILURE;
    }

    ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code_valid = TRUE;

    ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code = (uint8)
      hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode;
  }

  /* Channelization Codes always need to be a cummulative sum that network needs to specify.
  So initilize the number to 0 */


  ordered_config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code = 0;

  hsscch_list_ptr = &hsscch_info_ptr->modeSpecificInfo.u.fdd->hS_SCCHChannelisationCodeInfo;

  n_index = 0;
  n_value = hsscch_list_ptr->n;
  
  while ((n_value != 0) && (cnt < L1_DL_HS_SCCH_CODES_MAX))
  {
    /* Spec allows allows channelisation code 0 also but since MSM6275 will
    not support secondary scrambling code, it will collide with OVSF 0 and 1
    on SF 256 for CPICH and PCCPCH channels. */
    if ((hsscch_list_ptr->elem[n_index] > RRCLLC_MAX_SCCH_CHAN_CODE) || (hsscch_list_ptr->elem[n_index] == 0))
    {
      WRRC_MSG1_ERROR("RRCHS:Invalid Channelization code %d", hsscch_list_ptr->elem[n_index]);
      return FAILURE;
    }
    ordered_config_ptr->l1_hsdpa_info.hs_scch_info.ch_code[cnt++] = (uint8) hsscch_list_ptr->elem[n_index];

    n_value--;
    n_index++;
  }

  ordered_config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code = cnt;



  return SUCCESS;

}


/*====================================================================
FUNCTION      get_ul_dpch_pwr_ctrl_info_r5()

DESCRIPTION   This function translates the Uplink DPCH Power Control
              info common for all RL (radio links) IE into the RRC
              config database.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
static uecomdef_status_e_type get_ul_dpch_pwr_ctrl_info_r5
(
  rrc_UL_DPCH_PowerControlInfo_r5 *ie_ptr
)
{
  if(RRC_CHECK_COMMON_MSG_TYPE_PTR(ie_ptr,
              rrc_UL_DPCH_PowerControlInfo_r5_fdd))
  {
    /* Set the valid bit if made it this far */
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid = TRUE;

    /* Get the DPCCH Power Offset (value in dB) */
    if((ie_ptr->u.fdd->dpcch_PowerOffset <= RRCLLC_UL_DPCCH_PWR_OFFSET_MAX) &&
      (ie_ptr->u.fdd->dpcch_PowerOffset >= RRCLLC_UL_DPCCH_PWR_OFFSET_MIN))
    {
      /* The value sent over the air needs to be doubled */
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset =
        (int16) (ie_ptr->u.fdd->dpcch_PowerOffset * 2);
    }
    else
    {
      WRRC_MSG1_ERROR("UL DPCCH Power Offset %d is out of range",
        ie_ptr->u.fdd->dpcch_PowerOffset);
      return FAILURE;
    }

    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->u.fdd,
                   deltaACKPresent))
    {

      /* Check the value of Delta ACK */
      if (ie_ptr->u.fdd->deltaACK > RRCLLC_DELTA_ACK_MAX)
      {
        WRRC_MSG1_ERROR("RRCHS:UL Delta ACK [0..8] %d out of range",
          ie_ptr->u.fdd->deltaACK);
        return FAILURE;
      }
      

      if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
      {
        /* Check if delta ack has changed */
        if (((uint8)ie_ptr->u.fdd->deltaACK) != ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack)
        {
          WRRC_MSG2_HIGH("RRCHS:DPCCH Info changed New DeltaACK %d, Previous %d ", (uint8)ie_ptr->u.fdd->deltaACK,
                   ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack);

          hsdpa_msg_params.msg_params_present = hsdpa_msg_params.beta_table_present = TRUE;

        }
      }

      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack = (uint8)
        ie_ptr->u.fdd->deltaACK;
      
    }

    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->u.fdd,
                 deltaNACKPresent))
    {
      /* Check the value of Delta NACK */
      if (ie_ptr->u.fdd->deltaNACK > RRCLLC_DELTA_NACK_MAX)
      {
        WRRC_MSG1_ERROR("RRCHS:UL Delta ACK [0..8] %d out of range",
          ie_ptr->u.fdd->deltaNACK);
        return FAILURE;
      }


      /* Check if delta nack has changed */
      if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
      {
        /* Check if delta nack has changed */
        if (((uint8)ie_ptr->u.fdd->deltaNACK) != ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack)
        {
          WRRC_MSG2_HIGH("RRCHS:DPCCH Info changed New DeltaNACK %d, Previous %d", (uint8)ie_ptr->u.fdd->deltaNACK,
                   ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack);

          hsdpa_msg_params.msg_params_present = hsdpa_msg_params.beta_table_present = TRUE;
        }
      }
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack = (uint8)
        ie_ptr->u.fdd->deltaNACK;
      
    }

    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->u.fdd,
                 ack_NACK_repetition_factorPresent))
    {

      /* Check the value of ACK/NACK Repition Factor */
      if (!((ie_ptr->u.fdd->ack_NACK_repetition_factor >= RRCLLC_DELTA_ACK_NACK_REPITITION_FACTOR_MIN) &&
        (ie_ptr->u.fdd->ack_NACK_repetition_factor <= RRCLLC_DELTA_ACK_NACK_REPITITION_FACTOR_MAX)))
      {
        WRRC_MSG1_ERROR("RRCHS:UL ACK/NACK Rep Factor [1..4] %d out of range",
          ie_ptr->u.fdd->ack_NACK_repetition_factor);
        return FAILURE;
      }


      if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
      {
        /* Check if delta ack has changed */
        if (((uint8)ie_ptr->u.fdd->ack_NACK_repetition_factor) != ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.ack_nack_rep_factor)
        {
          WRRC_MSG2_HIGH("RRCHS:DPCCH Info changed New ACKNACKRepFactor %d, Previous %d", (uint8)ie_ptr->u.fdd->ack_NACK_repetition_factor,
            ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.ack_nack_rep_factor);
          
          ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.ack_nack_rep_factor = (uint8)
            ie_ptr->u.fdd->ack_NACK_repetition_factor;
          
          hsdpa_msg_params.msg_params_present = hsdpa_msg_params.hs_dpcch_info_present = TRUE;
        }
      }
      else
      {
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.ack_nack_rep_factor = (uint8)
          ie_ptr->u.fdd->ack_NACK_repetition_factor;
        
        hsdpa_msg_params.msg_params_present = hsdpa_msg_params.hs_dpcch_info_present = TRUE;
        
      }
      
    }

    /* Get the PC Preamble */

    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len
      = (uint8)ie_ptr->u.fdd->pc_Preamble;

    /* Get SRB_Delay */
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay
      = (uint8)ie_ptr->u.fdd->sRB_delay;

    /* Get the Power Control Algorithm */
    if(RRC_CHECK_MSG_TYPE(ie_ptr->u.fdd->powerControlAlgorithm,
                  T_rrc_PowerControlAlgorithm_algorithm1))
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pca =
        L1_UL_PCA_ONE;
      if(ie_ptr->u.fdd->powerControlAlgorithm.u.algorithm1 == 0)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.tpc_step_size =
          L1_UL_TPC_STEP_ONE;
      }
      else if(ie_ptr->u.fdd->powerControlAlgorithm.u.algorithm1 == 1)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.tpc_step_size =
          L1_UL_TPC_STEP_TWO;
      }
      else
      {
        WRRC_MSG1_ERROR("TPC Step size %d is out of range",
          ie_ptr->u.fdd->powerControlAlgorithm.u.algorithm1);
        return FAILURE;
      } /* end if-else check for Algorithm 1 and TPC step size */
    }
    else if(RRC_CHECK_MSG_TYPE(ie_ptr->u.fdd->powerControlAlgorithm,
              T_rrc_PowerControlAlgorithm_algorithm2))
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pca =
        L1_UL_PCA_TWO;
    }
    else
    {
      WRRC_MSG0_ERROR("Invalid UL Power Control Algorithm specified");
      return FAILURE;
    } /* end if-else check for UL power control algorithm check */
  } /* end FDD check */

  else /* only TDD */
  {
    return FAILURE;
  }

  return SUCCESS;
} /* end get_ul_dpch_pwr_ctrl_info_r5() */


/*====================================================================
FUNCTION      get_ul_dpch_info_r5()

DESCRIPTION   This function translates the Uplink DPCH info common for
              all RL (radio links) IE into the RRC config database.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
uecomdef_status_e_type get_ul_dpch_info_r5
(
  rrc_UL_DPCH_Info_r5 *ie_ptr
)
{
  MSG_MED("Get UL DPCH Info",0,0,0);

  /* Get the UL DPCH power control information if present */
  if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                 ul_DPCH_PowerControlInfoPresent))
  {
    if(get_ul_dpch_pwr_ctrl_info_r5(&ie_ptr->ul_DPCH_PowerControlInfo) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Make sure of FDD and get the right parameters */
  if(RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                T_rrc_UL_DPCH_Info_r5_modeSpecificInfo_fdd))
  {
    /* Get the Uplink DPCH Scrambling Code Type */
    switch (ie_ptr->modeSpecificInfo.u.fdd->scramblingCodeType)
    {
      case rrc_ScramblingCodeType_shortSC:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code_type = L1_UL_SC_SHORT;
        break;
      case rrc_ScramblingCodeType_longSC:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code_type = L1_UL_SC_LONG;
        break;
      default:
        WRRC_MSG1_ERROR("UL DPCH Scrambling Code Type %d is invalid",
          ie_ptr->modeSpecificInfo.u.fdd->scramblingCodeType);
        return FAILURE;
    }

    /* Get the scrambling code */
    if(ie_ptr->modeSpecificInfo.u.fdd->scramblingCode <= RRCLLC_MAX_UL_SCR_CODE)
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.scrambling_code = (uint32)
        ie_ptr->modeSpecificInfo.u.fdd->scramblingCode;
    }
    else
    {
      WRRC_MSG1_ERROR("UL Scrambling Code %d is out of range",
        ie_ptr->modeSpecificInfo.u.fdd->scramblingCode);
      return FAILURE;
    }

   
    if((ie_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH <= MAX_DPDCH) &&
       (ie_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH >= RRCLLC_DEFAULT_NUM_DPDCH_ALLOWED))
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.num_dpdch = (uint8)
        ie_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH;
    }
    else
    {
      WRRC_MSG1_ERROR("# of UL DPDCHs %d is out of range",
        ie_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH);
      return FAILURE;
    }

    /* Get the spreading factor */
    switch(ie_ptr->modeSpecificInfo.u.fdd->spreadingFactor)
    {
      case rrc_SpreadingFactor_sf4:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_4;
        break;
      case rrc_SpreadingFactor_sf8:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_8;
        break;
      case rrc_SpreadingFactor_sf16:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_16;
        break;
      case rrc_SpreadingFactor_sf32:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_32;
        break;
      case rrc_SpreadingFactor_sf64:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_64;
        break;
      case rrc_SpreadingFactor_sf128:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_128;
        break;
      case rrc_SpreadingFactor_sf256:
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.sf_min = L1_SF_256;
        break;
      default:
        WRRC_MSG1_ERROR("Invalid Spreading Factor %d received",
          ie_ptr->modeSpecificInfo.u.fdd->spreadingFactor);
        return FAILURE;
    } /* end spreading factor switch */

    /* get the TFCI existence */
    if(ie_ptr->modeSpecificInfo.u.fdd->tfci_Existence)
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = TRUE;
    }
    else
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present = FALSE;
    }

    /* get the FBI bits if necessary */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                numberOfFBI_BitsPresent))
    {
      switch(ie_ptr->modeSpecificInfo.u.fdd->numberOfFBI_Bits)
      {
        case 1:
          ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_1;
          break;
        default:
          WRRC_MSG1_ERROR("Invalid # of FBI bits %d received",
            ie_ptr->modeSpecificInfo.u.fdd->numberOfFBI_Bits);
          return FAILURE;
      }
    }
    else
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len = L1_UL_FBI_LEN_0;
    }

    /*
    * Get the UL DPCH Puncturing Limit. The OTA Msg receives this value as an enum.
    * The puncturing limit is a real number between 0.4 and 1.0 in steps of 0.04.
    * L1 expects this value to be from 40 to 100; in other words, L1 expects
    * l1_puncturing_limit = puncturing_limit * 100;
    * Therefore in the ASN.1 enum type the first enum value 0 corresponds to 0.4,
    * 1 corresponds to 0.44, etc... . Hence the following equation is derived:
    * l1_puncturing_limit = (ASN.1_enum_type * 4) + 40;
    * If this enum changes, this equation may need tweaking or else, this can
    * be broken into a switch with multiple cases.
    */
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim = (uint8)
      (((uint8)(ie_ptr->modeSpecificInfo.u.fdd->puncturingLimit) * 4) + 40);

    if((ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim < RRCLLC_MIN_PUNCTURING_LIMIT)
      || (ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.punct_lim > RRCLLC_MAX_PUNCTURING_LIMIT))
    {
      WRRC_MSG1_ERROR("UL DPCH puncturing limit %d is out of range",
        ordered_config_ptr->l1_ul_chan_parms.prach_cfg.punct_lim);
      return FAILURE;
    }

#ifdef FEATURE_WCDMA_CPC_DTX
  /*Intialize numtpc to 2 */
  ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.numtpc = L1_UL_NUM_TPC_BITS_2;
#endif
  } /* end FDD if */
  else
  {
    return FAILURE;
  }

  /* If made it here, all is well */
  /* Indicate that Uplink L1 needs to be reconfigured */
  ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
  return SUCCESS;
} /* end get_ul_dpch_info_r5() */


/*====================================================================
FUNCTION      get_ul_dpch_pwr_ctrl_info()

DESCRIPTION   This function translates the Uplink DPCH Power Control
              info common for all RL (radio links) IE into the RRC
              config database.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
uecomdef_status_e_type get_ul_dpch_pwr_ctrl_info
(
  rrc_UL_DPCH_PowerControlInfo *ie_ptr
)
{
  if(RRC_CHECK_COMMON_MSG_TYPE_PTR(ie_ptr,
              rrc_UL_DPCH_PowerControlInfo_fdd))
  {
    /* Set the valid bit if made it this far */
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid = TRUE;

    /* Get the DPCCH Power Offset (value in dB) */
    if((ie_ptr->u.fdd->dpcch_PowerOffset <= RRCLLC_UL_DPCCH_PWR_OFFSET_MAX) &&
       (ie_ptr->u.fdd->dpcch_PowerOffset >= RRCLLC_UL_DPCCH_PWR_OFFSET_MIN))
    {
      /* The value sent over the air needs to be doubled */
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset =
        (int16) (ie_ptr->u.fdd->dpcch_PowerOffset * 2);
    }
    else
    {
      WRRC_MSG1_ERROR("UL DPCCH Power Offset %d is out of range",
        ie_ptr->u.fdd->dpcch_PowerOffset);
      return FAILURE;
    }

    /* Get the PC Preamble */

    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len
      = (uint8)ie_ptr->u.fdd->pc_Preamble;

    /* Get SRB_Delay */
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay
      = (uint8)ie_ptr->u.fdd->sRB_delay;

    /* Get the Power Control Algorithm */
    if(RRC_CHECK_MSG_TYPE(ie_ptr->u.fdd->powerControlAlgorithm, 
                  T_rrc_PowerControlAlgorithm_algorithm1))
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pca =
        L1_UL_PCA_ONE;
      if(ie_ptr->u.fdd->powerControlAlgorithm.u.algorithm1 == 0)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.tpc_step_size =
          L1_UL_TPC_STEP_ONE;
      }
      else if(ie_ptr->u.fdd->powerControlAlgorithm.u.algorithm1 == 1)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.tpc_step_size =
          L1_UL_TPC_STEP_TWO;
      }
      else
      {
        WRRC_MSG1_ERROR("TPC Step size %d is out of range",
          ie_ptr->u.fdd->powerControlAlgorithm.u.algorithm1);
        return FAILURE;
      } /* end if-else check for Algorithm 1 and TPC step size */
    }
    else if (RRC_CHECK_MSG_TYPE(ie_ptr->u.fdd->powerControlAlgorithm,
                    T_rrc_PowerControlAlgorithm_algorithm2))
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pca =
        L1_UL_PCA_TWO;
    }
    else
    {
      WRRC_MSG0_ERROR("Invalid UL Power Control Algorithm specified");
      return FAILURE;
    } /* end if-else check for UL power control algorithm check */
  } /* end FDD check */

  else /* only TDD */
  {
    return FAILURE;
  }

  return SUCCESS;
} /* end get_ul_dpch_pwr_ctrl_info() */

/*====================================================================
FUNCTION       verify_sccpch_exists()

DESCRIPTION    This function takes a pointer to the SCCPCH system
               information list and RRC state, checks
               to see if at least one SCCPCH exists that has a FACH
               (for RRC states CELL_FACH and CONNECTING) or a PCH
               (for RRC states DISCONNECTED, CELL_PCH or URA_PCH)
               mapped to it.

DEPENDENCIES   None

RETURN VALUE   TRUE: SCCPCH with right type of TrCH exists.
               FALSE: SCCPCH with right kind of TrCH does NOT exist.

SIDE EFFECTS   None
====================================================================*/
boolean verify_sccpch_exists
(
  rrc_SCCPCH_SystemInformationList *sccpch_sys_info_ptr,
  rrc_state_e_type  next_rrc_state
)
{
  uint8 num_of_sccpch        = 1;

  uint8 sccpch_sib_fach_cnt = 0;  /* count of SIB 5/6 SCCPCH->PCH mappings */
  uint8 sccpch_sib_pch_cnt  = 0;  /* count of SIB 5/6 SCCPCH->PCH mappings */

  rrc_SCCPCH_SystemInformationList  *passed_ie_ptr;
  boolean ret_val;
  uint32  n_index = 0;

  /* Store the passed IE pointer for later use */
  passed_ie_ptr = sccpch_sys_info_ptr;

  
  if((passed_ie_ptr == NULL ) || (passed_ie_ptr->n == 0))
  {
    /* Something went wrong reading the SCCPCH_SYS_INFO IE from SIB5 or SIB6. */
    return FALSE;
  }

  while((passed_ie_ptr->n >  n_index) && (num_of_sccpch <= UE_MAX_SCCPCH))
  {
    /* Checking for PCH in a given SCCPCH */
    if(RRC_CHECK_MSG_TYPE_IE(passed_ie_ptr->elem[n_index],
                 pich_InfoPresent))
    {
      sccpch_sib_pch_cnt++;

      /* Now also check for a FACH on the same SCCPCH */
      /*
      * Note that this is a linked list and only one PCH can
      * can be present for a given SCCPCH, so if there is more
      * than one Transport channel per SCCPCH, the second one
      * has to be a FACH, i.e. the next pointer is not NULL.
      */
      if(RRC_CHECK_MSG_TYPE_IE(passed_ie_ptr->elem[n_index],
                  fach_PCH_InformationListPresent))
      {
        if (passed_ie_ptr->elem[n_index].fach_PCH_InformationList.n > 1)
        {
          sccpch_sib_fach_cnt++;
        }
      }
    }
    /* FACH only SCCPCH case */
    else
    {
      sccpch_sib_fach_cnt++;
    }

    /* get the next element in the linked list */
    num_of_sccpch++;
    n_index++;
  } /* end SIB SCCPCH check while */

  /* Now check if FACH/PCH count exists for the given RRC state */
  switch(next_rrc_state)
  {
    case RRC_STATE_CELL_FACH:
    case RRC_STATE_CONNECTING:
      if(sccpch_sib_fach_cnt)
      {
        ret_val = TRUE;
      }
      else
      {
        ret_val = FALSE;
      }
      break;

    case RRC_STATE_DISCONNECTED:
    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH:
      if(sccpch_sib_pch_cnt)
      {
        ret_val = TRUE;
      }
      else
      {
        ret_val = FALSE;
      }
      break;

    default:
      ret_val = FALSE;
      break;
  }

  return(ret_val);
} /* verify_sccpch_exists */

/*====================================================================
FUNCTION       get_sys_info_for_sccpch_with_ctch()

DESCRIPTION    This function takes a pointer to the SCCPCH system
               information list for SIB 5, determines the state, checks
               to see if SIB 6 is also available, and selects the
               applicable SCCPCH information to use, and copies all
               applicable IEs for MAC, RLC, and L1 into the
               ORDERED_CONFIG database (internal format).

               SIB 5 must be there or else the UE cannot get pages or
               enter connected mode. This SIB contains the Inormation
               necessary to setup the SCCPCH an PRACH physical channels,
               and the PCH, FACH and RACH transport channels.

               SIB 6 is optional, and if present is only used to get
               SCCPCH information while in connected mode, i.e.
               CELL_FACH, CELL_PCH and URA_PCH.

DEPENDENCIES   rrcllc_init_ordered_config should always be called
               before a call to this function.

RETURN VALUE   SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS   This function presumes that Ordered Config is initialized
               before a call to this function. It updates all ordered
               config structures based on this assumption.
====================================================================*/
uecomdef_status_e_type get_sys_info_for_sccpch_with_ctch
(
  ordered_config_type  *config_ptr,
  rrc_SCCPCH_SystemInformationList *sccpch_sys_info_ptr,
  rrc_state_e_type  next_rrc_state
)
{
  /* local pointer */
  rrc_SCCPCH_SystemInformationList *ie_ptr = NULL;

  /* Pointer for the FACH info */
  rrc_FACH_PCH_InformationList     *fach_ptr = NULL;


  /* local ptr to the fach_pch_infomationlist and tfcs to use for
   * the selected sccpch
   */
  rrc_FACH_PCH_InformationList *fach_pch_infolist_to_use = NULL;
  rrc_TFCS tfcs_to_use = {0};


  /* Local variables */
  uint8 num_of_sccpch = 1;  /* number of total SCCPCHs */
  uint8 sccpch_index_with_ctch = 0;
  boolean ctch_present = FALSE;

  /* local TrCH Index var */
  uint8 pch_trch_idx = 0;
  uint8 fach_trch_idx = 0;

  
  uint32 n_index = 0;
  uint32 fach_n_value = 0;
  uint32 fach_n_index = 0;
  
  /* make a local copy of the IE pointer */
  ie_ptr = sccpch_sys_info_ptr;

  if(ie_ptr == NULL)
  {
    WRRC_MSG0_ERROR("NULL pointer passed for SCCPCH system Info");
    return(FAILURE);
  }

  /*
  * Initialize the FACH Pointer. If there is a PCH, the new FACH pointer will be
  * Updated after processing the PCH information.
  */
  fach_ptr = NULL;

  ctch_present =  is_ctch_present_in_serving_cell(next_rrc_state);

  if (ctch_present)
  {
    sccpch_index_with_ctch = get_sccpch_index_for_sccpch_with_ctch(ie_ptr);
    if (!sccpch_index_with_ctch)
    {
      WRRC_MSG0_HIGH("Could not find sccpch index for CTCH");
      return(FAILURE);
    }
  }


  /*
  * Make sure that the SCCPCH to use is valid, i.e. does not exceed the maximum
  * number of supported SCCPCHs
  */
  if ((sccpch_index_with_ctch == RRCLLC_INVALID_SCCPCH_IDX) || (sccpch_index_with_ctch > UE_MAX_SCCPCH))
  {
    WRRC_MSG1_ERROR("Invalid SCCPCH selected, SCCPCH index %d",sccpch_index_with_ctch);
    return FAILURE;
  }

  /*
  * Select which SIB to read the SCCPCH from if in connected mode. If in
  * Idle mode, always use SIB5.
  */
  num_of_sccpch = 1;

  n_index = 0;
  

  /* Look for the SCCPCH Info for the SCCPCH that has been selected */

  
    n_index = sccpch_index_with_ctch -1;
    num_of_sccpch = sccpch_index_with_ctch;
  if(n_index >= ie_ptr->n)
  {
    WRRC_MSG1_ERROR("SCCPCH not found for idx %d", sccpch_index_with_ctch);
    return FAILURE;
  }

  
  /* Get the TFCS & fach_pch_info to use for current sccpch */
  if( (RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
              tfcsPresent)) &&
      (RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
              fach_PCH_InformationListPresent))
    )
  {
    WRRC_MSG0_HIGH("TFCS and FACH_PCH info present in sccpch");

    fach_pch_infolist_to_use = &(ie_ptr->elem[n_index].fach_PCH_InformationList);
    tfcs_to_use = ie_ptr->elem[n_index].tfcs;
  }
  else
  {
    if(num_of_sccpch == 1)
    {
      WRRC_MSG0_ERROR("TFCS & PCH/FACH data needed for 1st SCCPCH");
      return FAILURE;
    }

    if (SUCCESS == get_tfcs_and_fach_pch_info(sccpch_sys_info_ptr,
                                              &fach_pch_infolist_to_use,
                                              &tfcs_to_use,
                                              sccpch_index_with_ctch ))
    {
      WRRC_MSG0_HIGH("retrieved tfcs and fach_pch_info_list");
    }
    else
    {
      WRRC_MSG0_ERROR("Failed to get tfcs and fach_pch_info");
      return(FAILURE);
    }
  }

  fach_n_value = fach_pch_infolist_to_use->n;
  fach_n_index = 0;

  /* Get the TFCS */
  /* NOTE: Always get the TFCS info first, before getting the SCCPCH info. This
   * is because TFCS info may initialize the CTFC info that includes the "TFCI
   * exits" field. That field is set by get_sccpch_info().
   */
  WRRC_MSG0_HIGH("Get DL TFCS");
  if(get_dl_tfcs_info(config_ptr,
                      &tfcs_to_use,
                      TRUE,
                      &config_ptr->dl_ctfc_for_sccpch_with_ctch)
     == FAILURE)
    {
      return FAILURE;
    }

  /* Must now have the correct SCCPCH index, lets get the IEs */
  /* Get the SCCPCH info, only support 1 SCCPCH for now */
  if (get_sccpch_info(&ie_ptr->elem[n_index].secondaryCCPCH_Info,
                      &config_ptr->l1_dl_chan_parms.sccpch[1],
                      &config_ptr->l1_dl_ctfc_parms_for_sccpch_with_ctch,
                      &config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch
                     ) == FAILURE)
  {
    /* Error getting SCCPCH information.  Return FAILURE to indicate
       error and bail out of routine */
    WRRC_MSG0_ERROR("Error getting SCCPCCH info from SCCPCH sys info");
    return FAILURE;
  }

  /* Get the TrCH data for this SCCPCH - PCH is first, if present */
  if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                pich_InfoPresent))
  {
    /* Got SCCPCH Info, lets get the TrCH channel Index for the PCH */
    pch_trch_idx =
        rrcllc_get_dl_pch_trch_idx_for_sccpch_with_ctch(config_ptr,
                                 (tr_ch_id_type)fach_pch_infolist_to_use->elem[fach_n_index].transportChannelIdentity);

    /* Let LLC know that there is a PCH on this SCCPCH */
    rrcllc_set_pch_included_for_sccpch_with_ctch(TRUE);

    /* ... and make sure we have not exceeded UE capaabilities for DL TRCH's */
    if((RRCLLC_DOWNLINK_TRCH_COUNT(config_ptr)) > UE_MAX_TRCH)
    {
      WRRC_MSG0_ERROR("Exceeded maximum number of DL TRCHs");
      return FAILURE;
    }

    /* Get the TFS info for this TrCH */
    WRRC_MSG1_MED("Get TFS for DL TrCH Id %d",
            fach_pch_infolist_to_use->elem[fach_n_index].transportChannelIdentity);

    if(get_dl_transport_format_set( &fach_pch_infolist_to_use->elem[fach_n_index].transportFormatSet,
                                    (l1_dl_trch_info_struct_type *) NULL,  /* dedicated trch */
                                    FALSE, /* mulitple logical channels not supported */
                                    config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.
                                      trch_info_array[pch_trch_idx]
                                   ) == FAILURE)
    {
      return FAILURE;
    }

    /* Increment the pch_trch_idx to index correctly into the common TrCH array */
    /* And get the FACH TrCH Pointer */
    pch_trch_idx++;
    //fach_ptr = fach_pch_infolist_to_use->next;
    fach_n_index++;
    fach_n_value --;
  } /* end PCH */
  else
  {
    /* The SCCPCH selected does not have a PCH */
    /* Let LLC know that there is no PCH on this SCCPCH */
    rrcllc_set_pch_included_for_sccpch_with_ctch(FALSE);
    /* Set the fach_ptr to point to the fach TrCH info */
    //fach_ptr = fach_pch_infolist_to_use;
    fach_n_index = 0;
  }

  /*
  * Get the Transport channel data for this SCCPCH - FACH is next, if it is there
  * since there can only be one PCH per SCCPCH.
  */
  if(fach_n_value == 0)
  {
    /* The selected SCCPCH does not have a FACH */
    /* Let LLC know that there is no FACH on this SCCPCH */
    WRRC_MSG0_ERROR("NO fach info for CTCH");
    return FAILURE;
  }
  else
  {
    /* If there is only 1 fach and there is no pich info present, then ctch must be the only
       fach on this sccpch */

    fach_ptr = fach_pch_infolist_to_use;
    
    while(((RRCLLC_DOWNLINK_TRCH_COUNT(config_ptr)) <= UE_MAX_TRCH)
           && (fach_n_value != 0))
    {
      /* Got SCCPCH Info, lets get the TrCH channel ID for the PCH */
      /* If PCH is present, pch_trch_idx is 1. Else when PCH is not present,
       * pch_trch_idx is 0. So we can always add pch_trch_idx while updating
       * TrCH info in L1 data structure.
       */
      fach_trch_idx = rrcllc_get_dl_fach_trch_idx_for_sccpch_with_ctch(
                              config_ptr,
                              (tr_ch_id_type)fach_ptr->elem[fach_n_index].transportChannelIdentity,
                               pch_trch_idx,
                               fach_ptr->elem[fach_n_index].ctch_Indicator
                               );

      if(fach_trch_idx >= UE_MAX_TRCH)
      {
        WRRC_MSG1_ERROR("Invalid TrCH index %d for FACH", fach_ptr->elem[fach_n_index].transportChannelIdentity);/* return an error here */
        return FAILURE;
      }

      /* ... and make sure we have not exceeded UE capabilities for DL TRCH's */
      if((RRCLLC_DOWNLINK_TRCH_COUNT(config_ptr)) > UE_MAX_TRCH)
      {
        WRRC_MSG0_ERROR("Exceeded maximum number of DL TRCHs");
        return FAILURE;
      }

      /* Get the TFS info for this TrCH */
      MSG_MED("Get TFS for DL TrCH Id %d",
              fach_ptr->elem[fach_n_index].transportChannelIdentity, 0,0);
   
      if(get_dl_transport_format_set(&fach_ptr->elem[fach_n_index].transportFormatSet,
                                      (l1_dl_trch_info_struct_type *) NULL,  /* dedicated trch */
                                      FALSE, /* mulitple logical channels not supported */
                                      config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.
                                        trch_info_array[pch_trch_idx + fach_trch_idx]   /* common trch */
                                     ) == FAILURE)
      {
        return FAILURE;
      }
    
      if (fach_ptr->elem[fach_n_index].ctch_Indicator == TRUE)
        {
          WRRC_MSG1_HIGH("TTI for CTCH is %d",
                   config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.trch_info_array[pch_trch_idx + fach_trch_idx]->tti_value);
          config_ptr->l1_dl_chan_parms.sccpch[1].cbs_sched.ctch_fach_tti =
            config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch.trch_info_array[pch_trch_idx + fach_trch_idx]->tti_value;
        }
      /* Next FACH ptr */
      fach_n_value--;
      fach_n_index++;
    } /* end FACH */
  } /* end else */

  /* Set the RM restriction info to Invalid since it is not present for
   * Common Physical Channels.
   */
  set_dl_rm_restriction_info_to_invalid(&config_ptr->rm_restrict_for_sccpch_with_ctch);

  /* Calculate the DL TFCS */
  update_rm_restriction_info(&config_ptr->l1_dl_cctrch_parms_for_sccpch_with_ctch,
                             &config_ptr->dl_ctfc_for_sccpch_with_ctch,
                             &config_ptr->rm_restrict_for_sccpch_with_ctch,
                             &config_ptr->l1_dl_ctfc_parms_for_sccpch_with_ctch
                            );

  /* Indicate that L1 DL needs to be reconfigured */
  config_ptr->reconfig_needed.downlink_l1 = TRUE;
  /* Although no new parameters for MAC have been received, MAC
   * still needs to be reconfigured so as to get the new CCTrCH
   * ID whenever Downlink L1 is reconfigured. This is due to the
   * interface requirements.
   */
  config_ptr->reconfig_needed.downlink_mac = TRUE;

  return SUCCESS;
} /* end get_sys_info_for_sccpch_with_ctch() */

/*====================================================================
FUNCTION       get_sccpch_sys_info()

DESCRIPTION    This function takes a pointer to the SCCPCH system
               information list for SIB 5, determines the state, checks
               to see if SIB 6 is also available, and selects the
               applicable SCCPCH information to use, and copies all
               applicable IEs for MAC, RLC, and L1 into the
               ORDERED_CONFIG database (internal format).

               SIB 5 must be there or else the UE cannot get pages or
               enter connected mode. This SIB contains the Inormation
               necessary to setup the SCCPCH an PRACH physical channels,
               and the PCH, FACH and RACH transport channels.

               SIB 6 is optional, and if present is only used to get
               SCCPCH information while in connected mode, i.e.
               CELL_FACH, CELL_PCH and URA_PCH.

DEPENDENCIES   rrcllc_init_ordered_config should always be called
               before a call to this function.

RETURN VALUE   SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS   This function presumes that Ordered Config is initialized
               before a call to this function. It updates all ordered
               config structures based on this assumption.
====================================================================*/
uecomdef_status_e_type get_sccpch_sys_info
(
  ordered_config_type  *config_ptr,
  rrc_SCCPCH_SystemInformationList *sccpch_sys_info_ptr,
  rrc_state_e_type  next_rrc_state,
  boolean is_sib6_in_use
)
{
  /* local pointer */
  rrc_SCCPCH_SystemInformationList *ie_ptr;


  /* local ptr to the fach_pch_infomationlist and tfcs to use for
   * the selected sccpch
   */
  rrc_FACH_PCH_InformationList *fach_pch_infolist_to_use = NULL;
  rrc_TFCS tfcs_to_use;


  /* Pointer for the FACH info */
  rrc_FACH_PCH_InformationList     *fach_ptr = NULL;

  /* Local variables */
  uint8 num_of_sccpch = 1;  /* number of total SCCPCHs */
  uint8 sccpch_index = 1;

  /* index of sccpch that carries ctch*/
  uint8 sccpch_index_with_ctch = RRCLLC_INVALID_SCCPCH_IDX;

  /* Boolean to indicate if CTCH is present in serving cell*/
  boolean ctch_present = FALSE;

  /* local TrCH Index var */
  uint8 pch_trch_idx = 0;
  uint8 fach_trch_idx = 0;

  uint32 n_index = 0;
  uint32 fach_n_index = 0;

  rrc_SysInfoType5    *sib5_ptr = NULL;

  memset(&(tfcs_to_use),0,sizeof(rrc_TFCS));  

  /* make a local copy of the IE pointer */
  ie_ptr = sccpch_sys_info_ptr;

  if(ie_ptr == NULL)
  {
    WRRC_MSG0_ERROR("NULL pointer passed for SCCPCH system Info");
    return(FAILURE);
  }

  /*
  * Initialize the FACH Pointer. If there is a PCH, the new FACH pointer will be
  * Updated after processing the PCH information.
  */
  fach_ptr = NULL;

  /*
  * Determine which SCCPCH to use and set Ordered Config with
  * those values.
  */
  sccpch_index = (uint8)get_sccpch_index(config_ptr, ie_ptr, next_rrc_state);

  if((next_rrc_state == RRC_STATE_DISCONNECTED) ||
     (next_rrc_state == RRC_STATE_CELL_PCH) ||
     (next_rrc_state == RRC_STATE_URA_PCH))
  {
    ctch_present =  is_ctch_present_in_serving_cell(next_rrc_state);
    if (ctch_present)
    {
      sccpch_index_with_ctch = get_sccpch_index_for_sccpch_with_ctch(ie_ptr);
      if (!sccpch_index_with_ctch)
      {
        WRRC_MSG0_HIGH("Could not find sccpch index for CTCH");
        ctch_present = FALSE;
        rrcllc_set_ctch_included(RRCLLC_NO_CTCH);

        if(is_sib6_in_use)
        {
          sib5_ptr = (rrc_SysInfoType5 *)
                     rrc_sibdb_return_sib_for_srv_cell(rrc_SIB5);
          
          if (sib5_ptr != NULL)
          {
            sccpch_index_with_ctch = get_sccpch_index_for_sccpch_with_ctch(&sib5_ptr->sCCPCH_SystemInformationList);
        
            if(sccpch_index_with_ctch)
            {
              WRRC_MSG0_HIGH("Found sccpch index for CTCH in SIB5 not in SIB6 ");
              /* HACK to make UE take the SCCPCH from SIB5 for CTCH is not present in SIB6*/
              rrcllc_set_ctch_included(RRCLLC_CTCH_ON_DIF_SCCPCH);
            }
            else
            {
              WRRC_MSG0_HIGH("Could not find sccpch index for CTCH in SIB5 also");
            }
          }
        }                               
      }
      else
      {
        if (sccpch_index == sccpch_index_with_ctch)
        {
          rrcllc_set_ctch_included(RRCLLC_CTCH_WITH_PCCH);
        }
        else
        {
          /* ctch and pcch are on two different SCCPCH */
          rrcllc_set_ctch_included(RRCLLC_CTCH_ON_DIF_SCCPCH);
        }
      }
    }
    else
    {
      WRRC_MSG1_HIGH("CTCH not present in this CELL %d",ctch_present);
      rrcllc_set_ctch_included(RRCLLC_NO_CTCH);
    }
  }
  WRRC_MSG2_HIGH("sccpch_index %d sccpch_index_with_ctch %d",sccpch_index, sccpch_index_with_ctch );

  /*
  * Make sure that the SCCPCH to use is valid, i.e. does not exceed the maximum
  * number of supported SCCPCHs
  */
  if ((sccpch_index == RRCLLC_INVALID_SCCPCH_IDX) || (sccpch_index > UE_MAX_SCCPCH))
  {
    WRRC_MSG1_ERROR("Invalid SCCPCH selected, SCCPCH index %d",sccpch_index);
    return FAILURE;
  }

  /* Update curr sccpch index */
  curr_sccpch_index = sccpch_index;

  /*
  * Select which SIB to read the SCCPCH from if in connected mode. If in
  * Idle mode, always use SIB5.
  */
  num_of_sccpch = 1;
 
  n_index = 0;


  /* Look for the SCCPCH Info for the SCCPCH that has been selected */
 
    n_index = sccpch_index -1;
    num_of_sccpch = sccpch_index;
  
  if(n_index >= ie_ptr->n)
  {
    WRRC_MSG1_ERROR("SCCPCH not found for idx %d", sccpch_index);
    return FAILURE;
  }

  

  /* Get the TFCS & fach_pch_info to use for current sccpch */
  if( (RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
               tfcsPresent)) &&
      (RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
               fach_PCH_InformationListPresent))
    )
  {
    WRRC_MSG0_MED("TFCS and FACH_PCH info present in sccpch");

    fach_pch_infolist_to_use = &(ie_ptr->elem[n_index].fach_PCH_InformationList);

    fach_n_index = 0;
    tfcs_to_use = ie_ptr->elem[n_index].tfcs;
  }
  else
  {
    if(num_of_sccpch == 1)
    {
      WRRC_MSG0_ERROR("TFCS & PCH/FACH data needed for 1st SCCPCH");
      return FAILURE;
    }
    if (SUCCESS == get_tfcs_and_fach_pch_info(sccpch_sys_info_ptr,
                                              &fach_pch_infolist_to_use,
                                              &tfcs_to_use,
                                              sccpch_index ))
    {
      WRRC_MSG0_HIGH("retrieved tfcs and fach_pch_info_list");
    }
    else
    {
      WRRC_MSG0_ERROR("Failed to get tfcs and fach_pch_info");
      return(FAILURE);
    }
  }


  /* NOTE: Always get the TFCS info first, before getting the SCCPCH info. This
   * is because TFCS info may initialize the CTFC info that includes the "TFCI
   * exits" field. That field is set by get_sccpch_info().
   */
  WRRC_MSG0_MED("Get DL TFCS");
  if(get_dl_tfcs_info(config_ptr,
                      &tfcs_to_use,
                      FALSE,
                      &config_ptr->dl_ctfc)
     == FAILURE)
  {
    return FAILURE;
  }

  /* Must now have the correct SCCPCH index, lets get the IEs */
  /* Get the SCCPCH info, only support 1 SCCPCH for now */
  if (get_sccpch_info(&ie_ptr->elem[n_index].secondaryCCPCH_Info,
                      &config_ptr->l1_dl_chan_parms.sccpch[0],
                      &config_ptr->l1_dl_ctfc_parms,
                      &config_ptr->l1_dl_cctrch_parms
                     ) == FAILURE)
  {
    /* Error getting SCCPCH information.  Return FAILURE to indicate
       error and bail out of routine */
    WRRC_MSG0_ERROR("Error getting SCCPCCH info from SCCPCH sys info");
    return FAILURE;
  }


  WRRC_MSG0_MED("Getting PCH TRCH_IDX");

  /* Get the TrCH data for this SCCPCH - PCH is first, if present */
  if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                 pich_InfoPresent))
  {
    /* Got SCCPCH Info, lets get the TrCH channel Index for the PCH */
    pch_trch_idx =
        rrcllc_get_dl_pch_trch_idx(config_ptr,
                                   (tr_ch_id_type)fach_pch_infolist_to_use->elem[fach_n_index].transportChannelIdentity);

    /* Let LLC know that there is a PCH on this SCCPCH */
    rrcllc_set_pch_included(TRUE);

    /* ... and make sure we have not exceeded UE capaabilities for DL TRCH's */
    if((RRCLLC_DOWNLINK_TRCH_COUNT(config_ptr)) > UE_MAX_TRCH)
    {
      WRRC_MSG0_ERROR("Exceeded maximum number of DL TRCHs");
      return FAILURE;
    }

    /* Get the TFS info for this TrCH */
    WRRC_MSG1_MED("Get TFS for DL TrCH Id %d",
            fach_pch_infolist_to_use->elem[fach_n_index].transportChannelIdentity);

    if(get_dl_transport_format_set( &fach_pch_infolist_to_use->elem[fach_n_index].transportFormatSet,
                                    (l1_dl_trch_info_struct_type *) NULL,  /* dedicated trch */
                                    FALSE, /* mulitple logical channels not supported */
                                    config_ptr->l1_dl_cctrch_parms.
                                      trch_info_array[pch_trch_idx]
                                   ) == FAILURE)
    {
      return FAILURE;
    }

    /* Increment the pch_trch_idx to index correctly into the common TrCH array */
    /* And get the FACH TrCH Pointer */
    
    pch_trch_idx++;
    fach_n_index++;

  } /* end PCH */
  else
  {
    /* The SCCPCH selected does not have a PCH */
    /* Let LLC know that there is no PCH on this SCCPCH */
    rrcllc_set_pch_included(FALSE);
    /* Set the fach_ptr to point to the fach TrCH info */
    
    fach_n_index = 0;
  }

  /*
  * Get the Transport channel data for this SCCPCH - FACH is next, if it is there
  * since there can only be one PCH per SCCPCH.
  */
  if(fach_n_index >= fach_pch_infolist_to_use->n)
  {
    /* The selected SCCPCH does not have a FACH */
    /* Let LLC know that there is no FACH on this SCCPCH */
    rrcllc_set_fach_included(FALSE);
  }
  else
  {
    fach_ptr =fach_pch_infolist_to_use;
    WRRC_MSG0_MED("Getting fach_trch_idx");
    while(((RRCLLC_DOWNLINK_TRCH_COUNT(config_ptr)) <= UE_MAX_TRCH)
           && (fach_n_index < fach_pch_infolist_to_use->n))
    {
      /* Got SCCPCH Info, lets get the TrCH channel ID for the PCH */
      /* If PCH is present, pch_trch_idx is 1. Else when PCH is not present,
       * pch_trch_idx is 0. So we can always add pch_trch_idx while updating
       * TrCH info in L1 data structure.
       */
      fach_trch_idx = rrcllc_get_dl_fach_trch_idx(
                              config_ptr,
                              (tr_ch_id_type)fach_ptr->elem[fach_n_index].transportChannelIdentity,
                               pch_trch_idx);

      if(fach_trch_idx >= UE_MAX_TRCH)
      {
        WRRC_MSG1_ERROR("Invalid TrCh index %d for FACH",fach_ptr->elem[fach_n_index].transportChannelIdentity);/* return an error here */
        return FAILURE;
      }

      if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
      {
        if (fach_ptr->elem[fach_n_index].ctch_Indicator == TRUE)
        {
          config_ptr->mac_dl_parms.fach_info[fach_trch_idx]->ctch_enable = TRUE;
        }
      }
      /* ... and make sure we have not exceeded UE capabilities for DL TRCH's */
      if((RRCLLC_DOWNLINK_TRCH_COUNT(config_ptr)) > UE_MAX_TRCH)
      {
        WRRC_MSG0_ERROR("Exceeded maximum number of DL TRCHs");
        return FAILURE;
      }
      //Added the check for KW error
      if((pch_trch_idx + fach_trch_idx) >= MCALWCDMA_DEC_MAX_TRCH)
      {
        WRRC_MSG0_ERROR("Exceeded maximum number of MCALWCDMA_DEC_MAX_TRCH TRCHs");
        return FAILURE;
      }

      /* Let LLC know that there is a FACH on this SCCPCH */
      rrcllc_set_fach_included(TRUE);

      /* Get the TFS info for this TrCH */
      WRRC_MSG1_MED("Get TFS for DL TrCH Id %d",
              fach_ptr->elem[fach_n_index].transportChannelIdentity);

      if(get_dl_transport_format_set(&fach_ptr->elem[fach_n_index].transportFormatSet,
                                      (l1_dl_trch_info_struct_type *) NULL,  /* dedicated trch */
                                      FALSE, /* mulitple logical channels not supported */
                                      config_ptr->l1_dl_cctrch_parms.
                                        trch_info_array[pch_trch_idx + fach_trch_idx]   /* common trch */
                                     ) == FAILURE)
      {
        return FAILURE;
      }

      if (rrcllc_semi_permanent_data.dl_phy_chan.ctch_status == RRCLLC_CTCH_WITH_PCCH)
      {
        if (fach_ptr->elem[fach_n_index].ctch_Indicator == TRUE)
        {
          WRRC_MSG1_HIGH("TTI for CTCH is %d",
                   config_ptr->l1_dl_cctrch_parms.trch_info_array[pch_trch_idx + fach_trch_idx]->tti_value);
          config_ptr->l1_dl_chan_parms.sccpch[0].cbs_sched.ctch_fach_tti =
            config_ptr->l1_dl_cctrch_parms.trch_info_array[pch_trch_idx + fach_trch_idx]->tti_value;
        }
      }
      /* Next FACH ptr */
      fach_n_index++;

    } /* end FACH */
  } /* end else */

  /* Set the RM restriction info to Invalid since it is not present for
   * Common Physical Channels.
   */
  set_dl_rm_restriction_info_to_invalid(&config_ptr->rm_restrict);

  /* Calculate the DL TFCS */
  update_rm_restriction_info(&config_ptr->l1_dl_cctrch_parms,
                             &config_ptr->dl_ctfc,
                             &config_ptr->rm_restrict,
                             &config_ptr->l1_dl_ctfc_parms
                            );

  /* Get PICH information from SCCPCH sys information IE */
  if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                 pich_InfoPresent))
  {
    MSG_MED("Get PICH Info",0,0,0);
    if (get_pich_info(&ie_ptr->elem[n_index].pich_Info, &config_ptr->l1_dl_chan_parms.pich)
      == FAILURE )
    {
      /* Error getting PICH information.  Return FAILURE to indicate
         error and bail out of routine */
      WRRC_MSG0_ERROR("Error getting PICH info from SCCPCH sys info");
      return FAILURE;
    }
    /* Tell L1 to use the PICH */
    if((next_rrc_state == RRC_STATE_DISCONNECTED) ||
       (next_rrc_state == RRC_STATE_CELL_PCH) ||
       (next_rrc_state == RRC_STATE_URA_PCH))
    {
      config_ptr->l1_dl_chan_parms.use_pich = TRUE;
    }
    else
    {
      WRRC_MSG1_MED("Use PICH FALSE for st %d", next_rrc_state);
      config_ptr->l1_dl_chan_parms.use_pich = FALSE;
    }

  } /* end PICH check */
  else
  {
    config_ptr->l1_dl_chan_parms.use_pich = FALSE;
  }
  /* Indicate that L1 DL needs to be reconfigured */
  config_ptr->reconfig_needed.downlink_l1 = TRUE;
  /* Although no new parameters for MAC have been received, MAC
   * still needs to be reconfigured so as to get the new CCTrCH
   * ID whenever Downlink L1 is reconfigured. This is due to the
   * interface requirements.
   */
  config_ptr->reconfig_needed.downlink_mac = TRUE;

  return SUCCESS;
} /* end get_sccpch_sys_info() */

/*====================================================================
FUNCTION        get_tfcs_and_fach_pch_info()

DESCRIPTION     This function will return the tfcs and fach_pch
                info list to use for the sccpch identitfied by the
                index.

RETURN VALUE    SUCCESS or FAILURE

====================================================================*/
uecomdef_status_e_type get_tfcs_and_fach_pch_info
(
  rrc_SCCPCH_SystemInformationList *sccpch_sys_info_ptr,
  rrc_FACH_PCH_InformationList **fach_pch_infolist_to_use,
  rrc_TFCS *tfcs_to_use,
  uint8 index
)
{

  /* local pointer */
  rrc_SCCPCH_SystemInformationList *ie_ptr = sccpch_sys_info_ptr;

  /* boolean to indicate whether SCCPCH includes PICH*/
  boolean pich_included = FALSE;

  rrc_TFCS prv_tfcs_and_pich;
  rrc_TFCS prv_tfcs_and_no_pich;

  /* Local copy of the previous SCCPCH with fach_pch_infolist present that has PICH INFO as well */
  rrc_FACH_PCH_InformationList *prv_fach_pch_list_and_pich = NULL;
  rrc_FACH_PCH_InformationList *prv_fach_pch_list_and_no_pich = NULL;

  uint8 count_sccpch = 0;
  uint32 n_value = 0;
  uint32 n_index = 0;

  memset(&(prv_tfcs_and_pich),0,sizeof(rrc_TFCS));
  memset(&(prv_tfcs_and_no_pich),0,sizeof(rrc_TFCS));


  /* Look if SCCPCH included PCH or not*/
  if(ie_ptr != NULL)
  {
    n_value = ie_ptr->n;
  }

  while((n_value > n_index) && (count_sccpch != index))
  {
    count_sccpch++;

    /* Maintain the TFCS from previous SCCPCH with PICH and the previous SCCPCH with No PICH */
    if((RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                tfcsPresent)) && 
        (RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                 pich_InfoPresent)))
    {
      WRRC_MSG1_HIGH("Saving TFCS from sccpch %d with PICH",count_sccpch);
      prv_tfcs_and_pich = ie_ptr->elem[n_index].tfcs;
    }
    else if (RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                tfcsPresent))
    {
      WRRC_MSG1_HIGH("Saving TFCS from sccpch %d without PICH",count_sccpch);
      prv_tfcs_and_no_pich = ie_ptr->elem[n_index].tfcs;
    }
    /* Maintain the fach_pch list from previous SCCPCH with PICH and the previous SCCPCH with No PICH */
    if((RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                fach_PCH_InformationListPresent)) && 
       (RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                 pich_InfoPresent)))
    {
      WRRC_MSG1_HIGH("Saving fach_pch_infolist from sccpch %d with PICH",count_sccpch);
      prv_fach_pch_list_and_pich = &(ie_ptr->elem[n_index].fach_PCH_InformationList);
    }
    else if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                fach_PCH_InformationListPresent))
    {
      WRRC_MSG1_HIGH("Saving fach_pch_infolist from sccpch %d without PICH",count_sccpch);
      prv_fach_pch_list_and_no_pich = &(ie_ptr->elem[n_index].fach_PCH_InformationList);
    }

     /* IF SCCPCH selected by UE includes PCH, the UE should use TFCS and fach/pch info list
    * from the previous sccpch carrying PCH */
    if (count_sccpch == index)
    {
      if(RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index],
                  pich_InfoPresent))
      {
        pich_included = TRUE;
      }
      break;
    }

    n_index++;
  } /*while */

  if((n_value == n_index) || count_sccpch != index)
  {
      WRRC_MSG0_HIGH("failed to get tfcs and fach/pch info list");
      return (FAILURE);
  }


  WRRC_MSG1_HIGH("PICH INFO included %d",pich_included);
    
  if (pich_included)
  {
    *fach_pch_infolist_to_use = prv_fach_pch_list_and_pich;
    *tfcs_to_use = prv_tfcs_and_pich;
  }
  else
  {
    *fach_pch_infolist_to_use = prv_fach_pch_list_and_no_pich;
    *tfcs_to_use = prv_tfcs_and_no_pich;
  }

  if (*fach_pch_infolist_to_use == NULL || (tfcs_to_use->t ==0))
  {
    WRRC_MSG0_ERROR("Error: No fach_pch_infolist or tfcs to use");
    return (FAILURE);
  }

  return SUCCESS;
}

/*====================================================================
FUNCTION        get_sccpch_index()

DESCRIPTION     This function will determine which SCCPCH to read from
                SIB 5, and returns this index.

DEPENDENCIES    The U-RNTI should have been read and filled in
                Ordered Config

RETURN VALUE    The index (starting at 1) of the SCCPCH to read. An
                index of zero indicates a problem reading the
                SCCPCH_SYS_INFO IE from Sib 5 or Sib 6.

SIDE EFFECTS    This function also sets the imsi_div_pch_cnt(IMSI/K)
                parameter for L1 to perform the DRX calculations.
====================================================================*/
int get_sccpch_index
(
  ordered_config_type  *config_ptr,
  rrc_SCCPCH_SystemInformationList *ie_ptr,
  rrc_state_e_type                next_rrc_state
)
{
  /* local variables */
  uint32 tmp_sccpch_index = RRCLLC_INVALID_SCCPCH_IDX;  /* This index is 1 based, not zero based */
  uint32 sccpch_pch_count  = 0;
  uint32 sccpch_fach_count = 0;
  uint64 imsi;

  uint8 sccpch_index         = 1;
  uint8 num_of_sccpch        = 1;

  uint8 sccpch_sib_fach_cnt = 0;  /* count of SIB 5/6 SCCPCH->PCH mappings */
  uint8 sccpch_sib_pch_cnt  = 0;  /* count of SIB 5/6 SCCPCH->PCH mappings */

  rrc_SCCPCH_SystemInformationList  *passed_ie_ptr;

  /* Local copy of the previous fach_pch_infolist from an SCCPCH that has PICH INFO.
   * default can be the fach_pch_infolist from the first sccpch since it is MP for the 1st sccpch
   */
  rrc_FACH_PCH_InformationList *prvs_fach_pch_list_with_pich = NULL;

  /* This indicates if an SCCPCH index was found successfully */
  boolean  sccpch_index_found = FALSE;


  uint32 n_index = 0;
  /* Figure out how many SCCPCHs contain a PCH or a FACH.
   * Just loop through all the SCCPCH entries and count PCH and FACH.
   */

  /* Store the passed IE pointer for later use */
  passed_ie_ptr = ie_ptr;
  /* Below are several places where lint error 414 is suppressed.  This is a
     "possible division by zero" warning.  The part of the expression that lint
     thinks might be zero is the count of elements in the ie_ptr list.  Since
     we check this pointer for NULLness below, this count is never zero, but
     lint isn't quite that clever. */

   
  if((passed_ie_ptr == NULL )||(passed_ie_ptr->n == 0))
  {
    /* Something went wrong reading the SCCPCH_SYS_INFO IE from SIB5 or SIB6. */
    return 0;
  }

  prvs_fach_pch_list_with_pich = &(ie_ptr->elem[n_index].fach_PCH_InformationList);

  while((passed_ie_ptr->n > n_index) && (num_of_sccpch <= UE_MAX_SCCPCH))
  {
    /* Checking for PCH in a given SCCPCH */
    if(RRC_CHECK_MSG_TYPE_IE(passed_ie_ptr->elem[n_index],
                pich_InfoPresent))
    {
      sccpch_sib_pch_cnt++;

      /* Now also check for a FACH on the same SCCPCH */
      /*
      * Note that this is a linked list and only one PCH can
      * can be present for a given SCCPCH, so if there is more
      * than one Transport channel per SCCPCH, the second one
      * has to be a FACH, i.e. the next pointer is not NULL.
      */

      if(RRC_CHECK_MSG_TYPE_IE(passed_ie_ptr->elem[n_index],
                  fach_PCH_InformationListPresent))
      {
        /* store fach_pch_informationList. */
        prvs_fach_pch_list_with_pich = &(passed_ie_ptr->elem[n_index].fach_PCH_InformationList);
        if (passed_ie_ptr->elem[n_index].fach_PCH_InformationList.n > 1)
        {
          sccpch_sib_fach_cnt++;
        }
      }
      else
      {
        WRRC_MSG0_HIGH("Checking previous SCCPCH to inc fach_cnt");
        if (prvs_fach_pch_list_with_pich->n > 1)
        {
          sccpch_sib_fach_cnt++;
        }
      }
    }
    /* FACH only SCCPCH case */
    else
    {
      sccpch_sib_fach_cnt++;
    }

    /* get the next element in the linked list */
    num_of_sccpch++;
    n_index++;
  } /* end SIB SCCPCH check while */

  /* Get a local copy of the imsi */
  imsi = rrc_convert_gsm_map_imsi_into_int_value(rrc_imsi);

  /*
  * Use the current state to determine which SCCPCH to use. Note that
  * everytime an SCCPCH is needed to be configured, the current state
  * is needed to ensure that the right SCCPCH is selected. The selection
  * algorithm is this (taken from 25.304 for Idle Mode, and 25.331 for
  * Connected Mode):
  */
  switch (next_rrc_state)
  {
    case RRC_STATE_DISCONNECTED:
    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH:

      /* save imsi div K, where k = # SCCPCH that contain a PCH, for L1 */
      if(sccpch_sib_pch_cnt == 0)
      {
        sccpch_index = RRCLLC_INVALID_SCCPCH_IDX;
      }
      else
      {
        if (next_rrc_state == RRC_STATE_DISCONNECTED)
        {
          /* Get the SCCPCH that contains PCH to listen to based on equation below */
          tmp_sccpch_index = (uint32)imsi % sccpch_sib_pch_cnt;
        }
        else
        {
          tmp_sccpch_index = config_ptr->mac_dl_parms.rnti_info.urnti
                                 % sccpch_sib_pch_cnt;
        }

        config_ptr->l1_dl_chan_parms.pich.imsi_div_pch_cnt =
          imsi / sccpch_sib_pch_cnt;
        
        /* Save IMSI divided by 8192, it is used in calculating Paging Occasion. */
        config_ptr->l1_dl_chan_parms.pich.imsi_div_8192 =
          imsi / 8192;
        
        WRRC_MSG2_HIGH("imsi_div_pch_cnt=%d;imsi_div_8192=%d", config_ptr->l1_dl_chan_parms.pich.imsi_div_pch_cnt, 
                                                         config_ptr->l1_dl_chan_parms.pich.imsi_div_8192);

        tmp_sccpch_index++; /* since 1 based index, not zero based */

        /* Now get the real index that is based on all SCCPCHs */
        //passed_ie_ptr = ie_ptr;
        for(n_index=0;
            passed_ie_ptr->n > n_index;
             n_index++ , sccpch_index++)
        {
          if(RRC_CHECK_MSG_TYPE_IE(passed_ie_ptr->elem[n_index],
                      pich_InfoPresent))
          {
            sccpch_pch_count++;
            if(sccpch_pch_count == tmp_sccpch_index)
            {
              sccpch_index_found = TRUE;
              break;
            }
          }
        }
      } /* sccpch_sib_pch_cnt != 0*/
      break;

    case RRC_STATE_CONNECTING:
    case RRC_STATE_CELL_FACH:
      /* Get the SCCPCH that contains FACH to listen to based on equation below */
      if(sccpch_sib_fach_cnt == 0)
      {
        sccpch_index = RRCLLC_INVALID_SCCPCH_IDX;
      }
      else
      {
        if(next_rrc_state == RRC_STATE_CONNECTING)
        {
          tmp_sccpch_index = (uint32)(rrc_convert_initial_ue_identity_into_int_value()
                    % sccpch_sib_fach_cnt);
        }
        else if(next_rrc_state == RRC_STATE_CELL_FACH)
        {
          tmp_sccpch_index = config_ptr->mac_dl_parms.rnti_info.urnti
                                 % sccpch_sib_fach_cnt;
        }
        else /* State is Cell_PCH or URA_PCH*/
        {
          if (sccpch_sib_pch_cnt == 0)
          {
            sccpch_index = RRCLLC_INVALID_SCCPCH_IDX;
          }
          else
          {
            tmp_sccpch_index = config_ptr->mac_dl_parms.rnti_info.urnti
                       % sccpch_sib_pch_cnt;
          }
        }

        tmp_sccpch_index++; /* since 1 based index, not zero based */

        /* Now get the real index that is based on all SCCPCHs */
        //passed_ie_ptr = ie_ptr;
     
        for(n_index = 0;
            n_index < passed_ie_ptr->n;
            n_index++ , sccpch_index++)
        {
          if(RRC_CHECK_MSG_TYPE_IE(passed_ie_ptr->elem[n_index],
                      pich_InfoPresent))
          {
            if(RRC_CHECK_MSG_TYPE_IE(passed_ie_ptr->elem[n_index],
                      fach_PCH_InformationListPresent))
            {
              /* store fach_pch_informationList. */
              prvs_fach_pch_list_with_pich = &(passed_ie_ptr->elem[n_index].fach_PCH_InformationList);
              if (passed_ie_ptr->elem[n_index].fach_PCH_InformationList.n >1 )
              {
                sccpch_fach_count++;
              }
            }
            else
            {
              WRRC_MSG0_HIGH("Checking previous SCCPCH to inc fach_cnt");
              if (prvs_fach_pch_list_with_pich->n > 1)
              {
                sccpch_fach_count++;
              }
            }
          }
          else
          {
            sccpch_fach_count++;
          }

          if(sccpch_fach_count == tmp_sccpch_index)
          {
            sccpch_index_found = TRUE;
            break;
          }
        }
      } /* sccpch_sib_fach_cnt != 0*/
      break;

    default:
      WRRC_MSG1_ERROR("Unknown RRC State %d when picking an SCCPCH",next_rrc_state);
      sccpch_index = RRCLLC_INVALID_SCCPCH_IDX;
      break;

  } /* end switch */

  if(sccpch_index_found == FALSE)
  {
    sccpch_index = RRCLLC_INVALID_SCCPCH_IDX;
  }

  return sccpch_index;
} /* end get_sccpch_index */

/*====================================================================
FUNCTION        get_sccpch_index_for_sccpch_with_ctch()

DESCRIPTION     This function will determine which SCCPCH to read for
                ctch from SIB 5/6, and returns this index.

DEPENDENCIES
RETURN VALUE    The index (starting at 1) of the SCCPCH to read. An
                index of zero indicates a problem reading the
                SCCPCH_SYS_INFO IE from Sib 5 or Sib 6.

SIDE EFFECTS
====================================================================*/
uint8 get_sccpch_index_for_sccpch_with_ctch
(
  rrc_SCCPCH_SystemInformationList *ie_ptr
)
{
  /* local variables */
  uint8 sccpch_index = RRCLLC_INVALID_SCCPCH_IDX;  /* This index is 1 based, not zero based */

  uint8 num_of_sccpch        = 1;


  rrc_SCCPCH_SystemInformationList  *passed_ie_ptr;
  rrc_FACH_PCH_InformationList *fach_pch_info_list;
  /* This indicates if an SCCPCH index was found successfully */
  boolean  sccpch_index_found = FALSE;
  uint32 n_value = 0;
  uint32 n_index = 0;
  uint32 fach_n_value = 0;
  uint32 fach_n_index = 0;

  /* Store the passed IE pointer for later use */
  passed_ie_ptr = ie_ptr;
  /* Below are several places where lint error 414 is suppressed.  This is a
     "possible division by zero" warning.  The part of the expression that lint
     thinks might be zero is the count of elements in the ie_ptr list.  Since
     we check this pointer for NULLness below, this count is never zero, but
     lint isn't quite that clever. */

  n_value = passed_ie_ptr->n;
  if(n_value == 0)
  {
    /* Something went wrong reading the SCCPCH_SYS_INFO IE from SIB5 or SIB6. */
    return 0;
  }

  while((n_value != 0) && (num_of_sccpch <= UE_MAX_SCCPCH) && (sccpch_index_found == FALSE) )
  {
    /* Checking for fach info if CTCH is present */
    if(RRC_CHECK_MSG_TYPE_IE(passed_ie_ptr->elem[n_index],
              fach_PCH_InformationListPresent))
    {
      fach_pch_info_list = &(passed_ie_ptr->elem[n_index].fach_PCH_InformationList);

      fach_n_value = fach_pch_info_list->n;
      fach_n_index = 0;
      while ( (fach_n_value != 0) && (sccpch_index_found == FALSE) )
      {
        if (TRUE == fach_pch_info_list->elem[fach_n_index].ctch_Indicator)
        {
          sccpch_index = num_of_sccpch;
          sccpch_index_found = TRUE;
        }
        fach_n_value--;
        fach_n_index++;
      }
    }
    /* get the next element in the linked list */
    num_of_sccpch++;
    n_value--;
    n_index++;

  } /* end SIB SCCPCH check while */

  WRRC_MSG1_HIGH("SCCPCH index %d carries CTCH",sccpch_index);
  return sccpch_index;
} /* end get_sccpch_index_for_sccpch_with_ctch */


/*====================================================================
FUNCTION        get_sccpch_info()

DESCRIPTION     This function transfers information from ASN.1
                output to the RRC config database for the SCCPCH

DEPENDENCIES    None

RETURN VALUE    SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS    The config structure pointed to by the input
                parameter *ord_cfg is overwritten.
====================================================================*/
uecomdef_status_e_type get_sccpch_info
(
  /* pointer to the SCCPCH info in the ASN.1 decoder output */
  rrc_SecondaryCCPCH_Info *ie_ptr,

  /* pointer to the SCCPCH parameters structure */
  l1_sccpch_parms_struct_type *psccpch,

  /* pointer to the CTFC info struture */
  l1_dl_ctfc_info_struct_type *ctfc_info,

  /* pointer to the CCTrCH info structure */
  l1_dl_cctrch_info_struct_type *cctrch_info
)
{
  uint16 sf_choice;

  /* initiliaze the optional field bit mask */
  psccpch->opt_parm_present_mask = 0;

  if(ie_ptr == NULL)
  {
    WRRC_MSG0_ERROR("NULL SCCPCH info pointer passed");
    return(FAILURE);
  }
  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                T_rrc_SecondaryCCPCH_Info_modeSpecificInfo_fdd))
  {
    /* FDD was chosen so let's rock */
    /* decode the Spreading factor and OVSF code */
    sf_choice = (uint16)ie_ptr->modeSpecificInfo.u.fdd->sf_AndCodeNumber.t;

    switch (sf_choice)
    {
      case T_rrc_SF256_AndCodeNumber_sf4:
        psccpch->code_num = (uint16)ie_ptr->modeSpecificInfo.u.fdd->sf_AndCodeNumber.u.sf4;
        psccpch->sf = L1_SF_4;
        break;

      case T_rrc_SF256_AndCodeNumber_sf8:
        psccpch->code_num = (uint16)ie_ptr->modeSpecificInfo.u.fdd->sf_AndCodeNumber.u.sf8;
        psccpch->sf = L1_SF_8;
        break;

      case T_rrc_SF256_AndCodeNumber_sf16:
        psccpch->code_num = (uint16)ie_ptr->modeSpecificInfo.u.fdd->sf_AndCodeNumber.u.sf16;
        psccpch->sf = L1_SF_16;
        break;

      case T_rrc_SF256_AndCodeNumber_sf32:
        psccpch->code_num = (uint16)ie_ptr->modeSpecificInfo.u.fdd->sf_AndCodeNumber.u.sf32;
        psccpch->sf = L1_SF_32;
        break;

      case T_rrc_SF256_AndCodeNumber_sf64:
        psccpch->code_num = (uint16)ie_ptr->modeSpecificInfo.u.fdd->sf_AndCodeNumber.u.sf64;
        psccpch->sf = L1_SF_64;
        break;

      case T_rrc_SF256_AndCodeNumber_sf128:
        psccpch->code_num = (uint16)ie_ptr->modeSpecificInfo.u.fdd->sf_AndCodeNumber.u.sf128;
        psccpch->sf = L1_SF_128;
        break;

      case T_rrc_SF256_AndCodeNumber_sf256:
        psccpch->code_num = (uint16)ie_ptr->modeSpecificInfo.u.fdd->sf_AndCodeNumber.u.sf256;
        psccpch->sf = L1_SF_256;
        break;

      default:
        WRRC_MSG1_ERROR("Bad SF & OVSF code for SCCPCH %u",
                  RRC_GET_MSG_TYPE(ie_ptr->modeSpecificInfo.u.fdd->sf_AndCodeNumber));
        return FAILURE;
    }

    /* Get Pilot Bits Existence */
    psccpch->pilot_exists =
      (boolean) ie_ptr->modeSpecificInfo.u.fdd->pilotSymbolExistence;

    /* Get TFCI Existence */
    psccpch->tfci_exists =
      (boolean) ie_ptr->modeSpecificInfo.u.fdd->tfci_Existence;

    /* and update the TFCI existence in the CTFC info structure as well */
    ctfc_info->tfci_existence = psccpch->tfci_exists;

    /* Get the Rate Matching restriction */
    switch(ie_ptr->modeSpecificInfo.u.fdd->positionFixedOrFlexible)
    {
      case rrc_PositionFixedOrFlexible_fixed:
        cctrch_info->rm_method = L1_DL_RM_FIXED_POS;
        break;

      case rrc_PositionFixedOrFlexible_flexible:
        cctrch_info->rm_method = L1_DL_RM_FLEX_POS;
        break;

      default:
        WRRC_MSG1_ERROR("Bad rate matching method %u",
                  ie_ptr->modeSpecificInfo.u.fdd->positionFixedOrFlexible);
        return FAILURE;
    } /* end Rate Matching restriction switch */

    /* Get Timing Offset */
    /* If check not required as OB fills default value = 0 if timing offset is not present */
    psccpch->timing_offset = (uint16)ie_ptr->modeSpecificInfo.u.fdd->timingOffset;


    /* Get STTD Usage */
    psccpch->tx_div_ind = (boolean) ie_ptr->modeSpecificInfo.u.fdd->sttd_Indicator;

    /* Get PCPICH for channel estimation info */
    switch(ie_ptr->modeSpecificInfo.u.fdd->dummy1)
    {
      case rrc_PCPICH_UsageForChannelEst_mayBeUsed:
        psccpch->use_pri_cpich = L1_USE_PRI_CPICH;
        break;

      case rrc_PCPICH_UsageForChannelEst_shallNotBeUsed:
        psccpch->use_pri_cpich = L1_DO_NOT_USE_PRI_CPICH;
        break;

      default:
        WRRC_MSG1_ERROR("Bad enum %u for PCPICH usage for chan est",
                  ie_ptr->modeSpecificInfo.u.fdd->dummy1);
        return FAILURE;
    }

    /* Get Secondary CPICH info */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                dummy2Present))
    {
      WRRC_MSG0_ERROR("SecondaryCPICHinfo not expected");
      /* reset the bit in the optional parameters bitmask indicating the absence
         of the secondary CPICH information */
      psccpch->opt_parm_present_mask &= ~SCCPCH_INFO_SEC_CPICH_INFO_PRESENT;
    }

    /* Get Secondary scrambling code info */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                   secondaryScramblingCodePresent))
    {
      /* set the value of the secondary scrambling code */
      psccpch->sec_scr_code = (uint8)
        ie_ptr->modeSpecificInfo.u.fdd->secondaryScramblingCode;

      /* set the bit in the optional parameters mask indicating the presence
         of the secondary scrambling code information */
      psccpch->opt_parm_present_mask |= SCCPCH_INFO_SEC_SCR_CODE_PRESENT;
    }
    else
    {
      /* reset the bit in the optional parameters mask indicating the absence
         of the secondary scrambling code information */
      psccpch->opt_parm_present_mask &= ~SCCPCH_INFO_SEC_SCR_CODE_PRESENT;
    }

    psccpch->pri_cpich_scr_code = rrc_ccm_get_curr_camped_psc();
  }
  else
  {
    return FAILURE;
  }

  return SUCCESS;
} /* get_sccpch_info() */

/*====================================================================
FUNCTION        get_pich_info()

DESCRIPTION     This function copies PICH information from ASN.1
                output to the RRC config database

DEPENDENCIES    None

RETURN VALUE    SUCCESS if everything is valid, FAILURE otherwise

SIDE EFFECTS
====================================================================*/
uecomdef_status_e_type get_pich_info
(
  /* pointer to the PICH info in the ASN.1 decoder output */
  rrc_PICH_Info *ie_ptr,

  /* pointer to the PICH parameters structure */
  l1_pich_parms_struct_type *ppich
)
{

  if(ie_ptr == NULL)
  {
    WRRC_MSG0_ERROR("rrc_PICH_Info pointer is NULL");
    return (FAILURE);
  }
    
  if(RRC_CHECK_COMMON_MSG_TYPE_PTR(ie_ptr,
            rrc_PICH_Info_fdd))
  {
    /* Get the OVSF channelisation code */
    ppich->ch_code = (uint8)ie_ptr->u.fdd->channelisationCode256;

    /* Get the number of PI bits per frame */
    switch (ie_ptr->u.fdd->pi_CountPerFrame)
    {
      case rrc_PI_CountPerFrame_e18:
        ppich->pi_per_frame = PICH_PI_PER_FRAME_18;
        break;

      case rrc_PI_CountPerFrame_e36:
        ppich->pi_per_frame = PICH_PI_PER_FRAME_36;
        break;

      case rrc_PI_CountPerFrame_e72:
        ppich->pi_per_frame = PICH_PI_PER_FRAME_72;
        break;

      case rrc_PI_CountPerFrame_e144:
        ppich->pi_per_frame = PICH_PI_PER_FRAME_144;
        break;

      default:
        WRRC_MSG1_ERROR("Invalid #PI bits per frame %u",
                  ie_ptr->u.fdd->pi_CountPerFrame);
        return FAILURE;
    }

    /* Get the STTD usage indicator */
    ppich->tx_div_ind = (boolean) ie_ptr->u.fdd->sttd_Indicator;
 }
  else
  {
    return FAILURE;
  }

  return SUCCESS;
} /* get_pich_info() */

/*====================================================================
FUNCTION        get_tx_diverity_mode_info()

DESCRIPTION     This function gets the TX Diversity Mode Info
                appearing in the TX Diversity Mode Information IE

DEPENDENCIES    None

RETURN VALUE    SUCCESS if all is OK, FAILURE otherwise

SIDE EFFECTS    The RRC config page portion pointed to by the input
                parameter dl_common is overwritten
====================================================================*/
uecomdef_status_e_type get_tx_diversity_mode_info
(
  rrc_TX_DiversityMode           tx_div_mode,

  l1_dl_common_info_struct_type *dl_common
)
{
  switch(tx_div_mode)
  {
    case rrc_TX_DiversityMode_noDiversity:
      dl_common->tx_div_mode = L1_TX_DIV_NONE;
      dl_common->opt_parm_presence_bitmask |= DL_COMMON_INFO_TX_DIV_MODE_PRESENT;
      break;

    case rrc_TX_DiversityMode_sttd:
      dl_common->tx_div_mode = L1_TX_DIV_STTD;
      dl_common->opt_parm_presence_bitmask |= DL_COMMON_INFO_TX_DIV_MODE_PRESENT;
      break;

    case rrc_TX_DiversityMode_closedLoopMode1:
      dl_common->tx_div_mode = L1_TX_DIV_CLOSED_LOOP_1;
      dl_common->opt_parm_presence_bitmask |= DL_COMMON_INFO_TX_DIV_MODE_PRESENT;
      break;

    case rrc_TX_DiversityMode_dummy:
      dl_common->tx_div_mode = L1_TX_DIV_CLOSED_LOOP_2;
      dl_common->opt_parm_presence_bitmask |= DL_COMMON_INFO_TX_DIV_MODE_PRESENT;
      break;

    default:
      WRRC_MSG1_ERROR("Bad TX Diversity Mode %u", tx_div_mode);
      return FAILURE;
  } /* end switch on Diversity Mode */

  /* Update Ordered Config to indicate L1 Downlink Reconfig is needed */
  ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
  /* Although no new parameters for MAC have been received, MAC
   * still needs to be reconfigured so as to get the new CCTrCH
   * ID whenever Downlink L1 is reconfigured. This is due to the
   * interface requirements.
   */
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;

  return SUCCESS;
} /* end get_tx_diversity_mode_info() */


/*====================================================================
FUNCTION      get_dl_dpch_common_info()

DESCRIPTION   This function translates the Downlink DPCH info common for
              all RL (radio links) IE into the RRC config database.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
uecomdef_status_e_type get_dl_dpch_common_info
(
  /* pointer to the IE */
  rrc_DL_DPCH_InfoCommon *ie_ptr,

  /* pointer to the desired config page */
  l1_dl_dpch_common_info_struct_type *common_info,

  /* pointer to the CCTrCH info structure */
  l1_dl_cctrch_info_struct_type *cctrch_info,

  l1_dl_ctfc_info_struct_type *l1_dl_ctfc_info
)
{
  rrc_state_e_type rrc_state;

  if(ie_ptr == NULL)
  {
    WRRC_MSG0_ERROR("rrc_DL_DPCH_InfoCommon pointer is NULL");
    return (FAILURE);
  }
  
  /* initialize the optional field bit mask */
  common_info->opt_parm_present_mask = 0;

  /* Get the timing indication maintenance elem[n_index]. */
  switch (RRC_GET_MSG_TYPE(ie_ptr->cfnHandling))
  {
    case T_rrc_DL_DPCH_InfoCommon_cfnHandling_initialise:
      /* As per section 8.6.6.28, if NW indicates timing init indication without 
       * HHO, UE behavior is unspecified.  So reject msg
       */
      if (!ordered_config_ptr->is_hho) 
      {
        WRRC_MSG0_ERROR("Timing init indication without HHO: invalid");
        return (FAILURE);
      }

      common_info->timing_ind = L1_TIMING_IND_INIT;

      /* Get the CFN-targetSFN frame offset change if present */
      if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->cfnHandling.u.initialise,
                  dummyPresent))
      {
        /* set the target CFN/SFN frame offset value */
        common_info->targ_frame_offset =
          (uint8) ie_ptr->cfnHandling.u.initialise->dummy;

        /* Indicate the presence of this parameter in the bitmask */
        common_info->opt_parm_present_mask |=
          DL_DPCH_COMMON_INFO_TARG_FRAME_OFFSET_PRESENT;
      }
      if(TRUE == rrcsmc_tm_ciph_active())
      {
        rrc_state = rrc_get_state();
        if( (rrc_state == RRC_STATE_CELL_FACH) &&
             (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
        {
          /* It will be called in the procedure itself */
        }
        else
        {
          (void)rrcsmc_process_cipher_config_for_hho(RRCSMC_INVALID_HFN_VALUE);
          
        }
      }

      break;

    case T_rrc_DL_DPCH_InfoCommon_cfnHandling_maintain:
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_CELL_DCH &&
          ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
      {
        WRRC_MSG0_HIGH("Ignoring TM HHO on state transition");
        common_info->timing_ind = L1_TIMING_IND_INIT;
      }
      else
      {
        common_info->timing_ind = L1_TIMING_IND_MAINTAIN;
        /* timingMaintainedSynchInd  IE is valid only 
         * if the IE "Timing Indication" is set to "Maintained". 
         */
        ordered_config_ptr->tm_sync_ind_applicable = 
                             ordered_config_ptr->tm_sync_ind_applicable |
                                                RRCLLC_TIMING_MAINTAIN_IND_PRESENT_OTA;

      }
      break;

    default:
      WRRC_MSG1_ERROR("Bad CFN handling choice %u", RRC_GET_MSG_TYPE(ie_ptr->cfnHandling));
      return FAILURE;
  }

  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                T_rrc_DL_DPCH_InfoCommon_modeSpecificInfo_fdd))
  {
    /* Get the TFCI existence */
    common_info->tfci_exists =
      (boolean) ie_ptr->modeSpecificInfo.u.fdd->tfci_Existence;

    /* and update the TFCI existence in the CTFC info as well */
    l1_dl_ctfc_info->tfci_existence = common_info->tfci_exists;

    /* Get the spreading factor and number of pilot bits in the DPCCH */
    switch (RRC_GET_MSG_TYPE(ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot))
    {
      case T_rrc_SF512_AndPilot_sfd4:
        common_info->sf = L1_SF_4;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd8:
        common_info->sf = L1_SF_8;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd16:
        common_info->sf = L1_SF_16;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd32:
        common_info->sf = L1_SF_32;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd64:
        common_info->sf = L1_SF_64;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd128:
        common_info->sf = L1_SF_128;
        switch (ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot.u.sfd128)
        {
          case rrc_PilotBits128_pb4:
            common_info->num_pilot_bits = 4;
            break;

          case rrc_PilotBits128_pb8:
            common_info->num_pilot_bits = 8;
            break;

          default:
            WRRC_MSG1_ERROR("Bad pilot bits enum %u for SF128", ie_ptr->
                      modeSpecificInfo.u.fdd->spreadingFactorAndPilot.u.sfd128);
            return FAILURE;
        }
        break;

      case T_rrc_SF512_AndPilot_sfd256:
        common_info->sf = L1_SF_256;
        switch (ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot.u.sfd256)
        {
          case rrc_PilotBits256_pb2:
            common_info->num_pilot_bits = 2;
            break;

          case rrc_PilotBits256_pb4:
            common_info->num_pilot_bits = 4;
            break;

          case rrc_PilotBits256_pb8:
            common_info->num_pilot_bits = 8;
            break;

          default:
            WRRC_MSG1_ERROR("Bad pilot bits enum %u for SF256", ie_ptr->
                      modeSpecificInfo.u.fdd->spreadingFactorAndPilot.u.sfd256);
            return FAILURE;
        }
        break;

      case T_rrc_SF512_AndPilot_sfd512:
        common_info->sf = L1_SF_512;
        common_info->num_pilot_bits = 0;
        break;

      default:
        WRRC_MSG1_ERROR("Bad spreading factor enum %u",
          RRC_GET_MSG_TYPE(ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot));
        return FAILURE;
    }

    /* Get the Rate Matching type parameter. */
    switch (ie_ptr->modeSpecificInfo.u.fdd->positionFixedOrFlexible)
    {
      case rrc_PositionFixedOrFlexible_fixed:
        cctrch_info->rm_method = L1_DL_RM_FIXED_POS;
        break;

      case rrc_PositionFixedOrFlexible_flexible:
        cctrch_info->rm_method = L1_DL_RM_FLEX_POS;
        break;

      default:
        WRRC_MSG1_ERROR("Bad rate matching method %u",
                  ie_ptr->modeSpecificInfo.u.fdd->positionFixedOrFlexible);
        return FAILURE;
    }

    /* Get the Power control info if present */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                  dl_DPCH_PowerControlInfoPresent))
    {
      if(RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo.u.fdd->dl_DPCH_PowerControlInfo.modeSpecificInfo,
                            T_rrc_DL_DPCH_PowerControlInfo_modeSpecificInfo_fdd))
      {
        /* set the DPC elem[n_index]. */
        switch (ie_ptr->modeSpecificInfo.u.fdd->dl_DPCH_PowerControlInfo.modeSpecificInfo.u.fdd->dpc_Mode)
        {
          case rrc_DPC_Mode_singleTPC:
            common_info->dpc_info = L1_DPC_MODE_SINGLE_TPC;
            break;

          case rrc_DPC_Mode_tpcTripletInSoft:
            common_info->dpc_info = L1_DPC_MODE_TPC_TRIPLE_IN_SOFT;
            break;

          default:
            WRRC_MSG1_ERROR("Bad DPC Mode %u",
                      ie_ptr->modeSpecificInfo.u.fdd->
                      dl_DPCH_PowerControlInfo.modeSpecificInfo.u.fdd->dpc_Mode);
            return FAILURE;
        }

        /* Indicate the DPCH Pwr Ctrl presence in the bitmask */
        common_info->opt_parm_present_mask |=
          DL_DPCH_COMMON_INFO_DPCH_PWR_CTRL_INFO_PRESENT;
      }
      else
      {
        /* bad news.  we're in the FDD portion of the DL Common info IE
           but the DPCH power control info IE hasn't selected FDD, instead
           it selected TDD */
        return FAILURE;
      }
    }

    /* Set PO3 power offset between DPDCH and DPCCH in downlink
     * This is mandatory present in Downlink Common Info
     */
    common_info->po3 = (uint8)ie_ptr->modeSpecificInfo.u.fdd->powerOffsetPilot_pdpdch;
    if (FALSE == rrc_predef_po3_not_needed)
    {
    rrc_set_predefined_po3_status(FALSE);
    }

    /* Get the rate matching restriction information if present */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                  dl_rate_matching_restrictionPresent))
    {
      if(get_dl_rm_restriction_info(
           &ie_ptr->modeSpecificInfo.u.fdd->dl_rate_matching_restriction,
           &ordered_config_ptr->rm_restrict)
         == FAILURE)
      {
        return FAILURE;
      }
    }
  } /* end DPCH FDD chsoen */
  else
  {
    /* we don't support TDD, return FALSE indicating an error */
    return FAILURE;
  }

  /* if we made it here all is well */
  return SUCCESS;
} /* get_dl_dpch_common_info() */


/*====================================================================
FUNCTION      get_dl_dpch_common_info_r5()

DESCRIPTION   This function translates the Downlink DPCH info common for
              all RL (radio links) IE into the RRC config database.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
static uecomdef_status_e_type get_dl_dpch_common_info_r5
(
  /* pointer to the IE */
  rrc_DL_DPCH_InfoCommon_r4 *ie_ptr,

  /* pointer to the desired config page */
  l1_dl_dpch_common_info_struct_type *common_info,

  /* pointer to the CCTrCH info structure */
  l1_dl_cctrch_info_struct_type *cctrch_info,

  l1_dl_ctfc_info_struct_type *l1_dl_ctfc_info
)
{
  rrc_state_e_type rrc_state;

  /* initialize the optional field bit mask */
  common_info->opt_parm_present_mask = 0;

  /* TBD: rrc_mac_d_HFN_initial_value_present to be used LATER */

  /* Get the timing indication maintenance elem[n_index]. */
  switch (RRC_GET_MSG_TYPE(ie_ptr->cfnHandling))
  {
    case T_rrc_DL_DPCH_InfoCommon_r4_cfnHandling_initialise:
    {
      uint32 mac_d_hfn_l = RRCSMC_INVALID_HFN_VALUE;

      /* As per section 8.6.6.28, if NW indicates timing init indication without 
       * HHO, UE behavior is unspecified.  So reject msg
       */
      if (!ordered_config_ptr->is_hho) 
      {
        WRRC_MSG0_ERROR("Timing init indication without HHO: invalid");
        return (FAILURE);
      }

      common_info->timing_ind = L1_TIMING_IND_INIT;

      /* Get the CFN-targetSFN frame offset change if present */
      if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->cfnHandling.u.initialise,
                   dummyPresent))
      {
        /* set the target CFN/SFN frame offset value */
        common_info->targ_frame_offset =
          (uint8) ie_ptr->cfnHandling.u.initialise->dummy;

        /* Indicate the presence of this parameter in the bitmask */
        common_info->opt_parm_present_mask |=
          DL_DPCH_COMMON_INFO_TARG_FRAME_OFFSET_PRESENT;
      }
       /* From Spec, NW should include mac-d-hfn only when TM bearers are
            present. */
      if(TRUE == rrcsmc_tm_ciph_active())
      {
        rrc_state = rrc_get_state();
        if( (rrc_state == RRC_STATE_CELL_FACH) &&
           (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
        {
          /* It will be called in the procedure itself */
        }
        else
        {
          if(FAILURE == rrcrb_get_mac_d_hfn(
             (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                      mac_d_HFN_initial_valuePresent)),
             &ie_ptr->mac_d_HFN_initial_value,
             &mac_d_hfn_l))
          {
            return FAILURE;
          }
          (void)rrcsmc_process_cipher_config_for_hho(mac_d_hfn_l);
        }
      }
          
    }

      break;

    case T_rrc_DL_DPCH_InfoCommon_r4_cfnHandling_maintain:
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_CELL_DCH &&
          ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
      {
        WRRC_MSG0_HIGH("Ignoring TM HHO on state transition");
        common_info->timing_ind = L1_TIMING_IND_INIT;
      }
      else
      {
        common_info->timing_ind = L1_TIMING_IND_MAINTAIN;
        /* timingMaintainedSynchInd  IE is valid only 
         * if the IE "Timing Indication" is set to "Maintained". 
         */
        ordered_config_ptr->tm_sync_ind_applicable = 
                             ordered_config_ptr->tm_sync_ind_applicable |
                                                RRCLLC_TIMING_MAINTAIN_IND_PRESENT_OTA;

      }
      break;

    default:
      WRRC_MSG1_ERROR("Bad CFN handling choice %u", RRC_GET_MSG_TYPE(ie_ptr->cfnHandling));
      return FAILURE;
  }

  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                T_rrc_DL_DPCH_InfoCommon_r4_modeSpecificInfo_fdd))
  {
    /* Get the TFCI existence */
    common_info->tfci_exists =
      (boolean) ie_ptr->modeSpecificInfo.u.fdd->tfci_Existence;

    /* and update the TFCI existence in the CTFC info as well */
    l1_dl_ctfc_info->tfci_existence = common_info->tfci_exists;

    /* Get the spreading factor and number of pilot bits in the DPCCH */
    switch (RRC_GET_MSG_TYPE(ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot))
    {
      case T_rrc_SF512_AndPilot_sfd4:
        common_info->sf = L1_SF_4;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd8:
        common_info->sf = L1_SF_8;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd16:
        common_info->sf = L1_SF_16;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd32:
        common_info->sf = L1_SF_32;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd64:
        common_info->sf = L1_SF_64;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd128:
        common_info->sf = L1_SF_128;
        switch (ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot.u.sfd128)
        {
          case rrc_PilotBits128_pb4:
            common_info->num_pilot_bits = 4;
            break;

          case rrc_PilotBits128_pb8:
            common_info->num_pilot_bits = 8;
            break;

          default:
            WRRC_MSG1_ERROR("Bad pilot bits enum %u for SF128",
              ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot.u.sfd128);
            return FAILURE;
        }
        break;

      case T_rrc_SF512_AndPilot_sfd256:
        common_info->sf = L1_SF_256;
        switch (ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot.u.sfd256)
        {
          case rrc_PilotBits256_pb2:
            common_info->num_pilot_bits = 2;
            break;

          case rrc_PilotBits256_pb4:
            common_info->num_pilot_bits = 4;
            break;

          case rrc_PilotBits256_pb8:
            common_info->num_pilot_bits = 8;
            break;

          default:
            WRRC_MSG1_ERROR("Bad pilot bits enum %u for SF256",
              ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot.u.sfd256);
            return FAILURE;
        }
        break;

      case T_rrc_SF512_AndPilot_sfd512:
        common_info->sf = L1_SF_512;
        common_info->num_pilot_bits = 0;
        break;

      default:
        WRRC_MSG1_ERROR("Bad spreading factor enum %u",
          RRC_GET_MSG_TYPE(ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot));
        return FAILURE;
    }

    /* Get the Rate Matching type parameter. */
    switch (ie_ptr->modeSpecificInfo.u.fdd->positionFixedOrFlexible)
    {
      case rrc_PositionFixedOrFlexible_fixed:
        cctrch_info->rm_method = L1_DL_RM_FIXED_POS;
        break;

      case rrc_PositionFixedOrFlexible_flexible:
        cctrch_info->rm_method = L1_DL_RM_FLEX_POS;
        break;

      default:
        WRRC_MSG1_ERROR("Bad rate matching method %u",
                  ie_ptr->modeSpecificInfo.u.fdd->positionFixedOrFlexible);
        return FAILURE;
    }

    /* Get the Power control info if present */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                  dl_DPCH_PowerControlInfoPresent))
    {
      if(RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo.u.fdd->
                            dl_DPCH_PowerControlInfo.modeSpecificInfo,
                  T_rrc_DL_DPCH_PowerControlInfo_modeSpecificInfo_fdd))
      {
        /* set the DPC elem[n_index]. */
        switch (ie_ptr->modeSpecificInfo.u.fdd->
                dl_DPCH_PowerControlInfo.modeSpecificInfo.u.fdd->dpc_Mode)
        {
          case rrc_DPC_Mode_singleTPC:
            common_info->dpc_info = L1_DPC_MODE_SINGLE_TPC;
            break;

          case rrc_DPC_Mode_tpcTripletInSoft:
            common_info->dpc_info = L1_DPC_MODE_TPC_TRIPLE_IN_SOFT;
            break;

          default:
            WRRC_MSG1_ERROR("Bad DPC Mode %u",
                      ie_ptr->modeSpecificInfo.u.fdd->
                      dl_DPCH_PowerControlInfo.modeSpecificInfo.u.fdd->dpc_Mode);
            return FAILURE;
        }

        /* Indicate the DPCH Pwr Ctrl presence in the bitmask */
        common_info->opt_parm_present_mask |=
          DL_DPCH_COMMON_INFO_DPCH_PWR_CTRL_INFO_PRESENT;
      }
      else
      {
        /* bad news.  we're in the FDD portion of the DL Common info IE
           but the DPCH power control info IE hasn't selected FDD, instead
           it selected TDD */
        return FAILURE;
      }
    }

    /* Set PO3 power offset between DPDCH and DPCCH in downlink
     * This is mandatory present in Downlink Common Info
     */
    common_info->po3 = (uint8)ie_ptr->modeSpecificInfo.u.fdd->powerOffsetPilot_pdpdch;
    if (FALSE == rrc_predef_po3_not_needed)
    {
    rrc_set_predefined_po3_status(FALSE);
    }	

    /* Get the rate matching restriction information if present */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                  dl_rate_matching_restrictionPresent))
    {
      if(get_dl_rm_restriction_info(
           &ie_ptr->modeSpecificInfo.u.fdd->dl_rate_matching_restriction,
           &ordered_config_ptr->rm_restrict)
         == FAILURE)
      {
        return FAILURE;
      }
    }
  } /* end DPCH FDD chsoen */
  else
  {
    /* we don't support TDD, return FALSE indicating an error */
    return FAILURE;
  }

  /* if we made it here all is well */
  return SUCCESS;
} /* get_dl_dpch_common_info_r5() */


/*====================================================================
FUNCTION      get_dl_dpch_info_for_each_rl_r5()

FILE NAME     This function gets the DL DPCH info for each RL

DESCRIPTION   This function translates the Downlink DPCH info for each
              RL IE to the RRC config database.  Note that it is assumed
              that a higher level routine is doing the translation from
              the linked list present in the ASN.1 decoder output to
              the array present in the RRC config database.  The radio
              link index is passed into this function and must be
              generated by that higher level routine.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if everything is ok, FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all of the parameters
              that are present in the IE.  For those parameters not
              present the values currently existing are untouched.  For
              each optional parameter that is present the corresponding
              bit in the optional parameters presence bitmask is set.
====================================================================*/
static uecomdef_status_e_type get_dl_dpch_info_for_each_rl_r5
(
  /* pointer to the IE */
  rrc_DL_DPCH_InfoPerRL_r5 *ie_ptr,

  /* pointer to the desired DL PhyChan parameter structure */
  l1_dl_phychan_db_struct_type *dl_phychan,

  /* radio link index */
  uint8 rl_idx,

  /* are we setting up a new radio link? */
  boolean is_new_rl
)
{
  l1_dl_info_per_rl_struct_type *rl_info;

  rrc_DL_ChannelisationCodeList *code_list_ptr;
  uint16 code_ch = 0;
  uint16 new_tau_dpch = 0;
  uint32 n_value = 0;
  uint32 n_index = 0;

  rrc_SF512_AndCodeNumber sf_choice;

  if (RRC_CHECK_COMMON_MSG_TYPE_PTR(ie_ptr,
              rrc_DL_DPCH_InfoPerRL_r5_fdd))
  {
    if (rl_idx < UE_MAX_RL)
    {
      rl_info = &dl_phychan->dl_per_rl[rl_idx];
    }
    else
    {
      /* rl_idx too large for supported number of radio links */
      WRRC_MSG0_HIGH("rl_idx out of range");
      return FAILURE;
    }

    /* initialize the optional field bit mask */
    if(is_new_rl)
    {
      rl_info->dpch_per_rl.opt_parms_present_mask = 0;
    }

    /* Get the DPCH frame offset (TauDPCH) */
    new_tau_dpch = (uint16)ie_ptr->u.fdd->dpch_FrameOffset;

    /* This validation should be done by the ASN.1 encoder on the
     * network side, but better not to make any assumptions here.
     */
    if(new_tau_dpch > 149)
    {
      WRRC_MSG1_HIGH("Invalid Tau_DPCH: %s", new_tau_dpch);
      return FAILURE;
    }

    /* An existing radio link cannot have its TauDPCH changed by more
     * than 1.
     */
    if(!is_new_rl &&
        ABS((new_tau_dpch - rl_info->dpch_per_rl.frame_offset)) > 1 &&
        ABS((new_tau_dpch - rl_info->dpch_per_rl.frame_offset)) != 149)
    {
      WRRC_MSG2_HIGH("Tau_DPCH difference > 1: %d (old) %d (new)",
          rl_info->dpch_per_rl.frame_offset, new_tau_dpch);
      return FAILURE;
    }
    rl_info->dpch_per_rl.frame_offset = new_tau_dpch;

    /* Get the CPICH usage for channel estimation */
    switch (ie_ptr->u.fdd->pCPICH_UsageForChannelEst)
    {
      case rrc_PCPICH_UsageForChannelEst_mayBeUsed:
        rl_info->dpch_per_rl.use_pri_cpich = L1_USE_PRI_CPICH;
        break;

      case rrc_PCPICH_UsageForChannelEst_shallNotBeUsed:
        rl_info->dpch_per_rl.use_pri_cpich = L1_DO_NOT_USE_PRI_CPICH;
        break;

      default:
        /* bad enum value, return FALSE immediately */
        WRRC_MSG0_HIGH("Bad CPICH usage enum");
        return FAILURE;
    }

    /* Get the TPC Combination index */
    rl_info->dpch_per_rl.tpc_idx =
      (uint8) ie_ptr->u.fdd->tpc_CombinationIndex;

    /* Get the closed loop timing adjustment type */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->u.fdd,
                closedLoopTimingAdjModePresent))
    {
        WRRC_MSG1_HIGH("Indicate CLT info in %d TXDivMode", dl_phychan->dl_common.tx_div_mode);
            
      if (dl_phychan->dl_common.tx_div_mode != L1_TX_DIV_NONE)
      {
        /* a cast here is ok as the mapping is as expected */
        rl_info->dpch_per_rl.closed_loop_timing_adj_mode =
          (uint8) ie_ptr->u.fdd->closedLoopTimingAdjMode;

        /* mark the Closed loop timing adjustment info as present */
        rl_info->dpch_per_rl.opt_parms_present_mask |=
          DL_DPCH_INFO_PER_CLOSED_LOOP_TIMING_ADJ_PRESENT;
      }
    }
    else
    {
      if(rl_info->dpch_per_rl.opt_parms_present_mask & DL_DPCH_INFO_PER_CLOSED_LOOP_TIMING_ADJ_PRESENT)
      {
	  WRRC_MSG0_HIGH("clearing CLT ");
    	  rl_info->dpch_per_rl.opt_parms_present_mask &=
  	     ~DL_DPCH_INFO_PER_CLOSED_LOOP_TIMING_ADJ_PRESENT;
      }
    }

    /* Get the secondary CPICH information */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->u.fdd,
                secondaryCPICH_InfoPresent))
    {

      /* set the secondary CPICH channelisation code */
      rl_info->dpch_per_rl.sec_cpich_ch_code =
        (uint16) ie_ptr->u.fdd->secondaryCPICH_Info.channelisationCode;

      if (RRC_CHECK_MSG_TYPE_IE(ie_ptr->u.fdd->secondaryCPICH_Info,
                secondaryDL_ScramblingCodePresent))
      {
        /* set the secondary CPICH secondary scrambling code */
        rl_info->dpch_per_rl.sec_cpich_sec_scr_code =
          (uint16) ie_ptr->u.fdd->secondaryCPICH_Info.secondaryDL_ScramblingCode;

        rl_info->dpch_per_rl.opt_parms_present_mask |=
          DL_DPCH_INFO_PER_RL_SEC_CPICH_SEC_SCR_CODE_PRESENT;
      }

      /* mark the secondary CPICH information as present */
      rl_info->dpch_per_rl.opt_parms_present_mask |=
        DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT;
    }
   /* secondary cpich info is not present. It might have been present
    for the same radiolink before. Make sure that L1 gets
    correct bit masks */
    else
    {
      if (rl_info->dpch_per_rl.opt_parms_present_mask &
        DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT)
      {
        WRRC_MSG1_HIGH("Sec CPICH was present before rl_id:%d",
                 rl_idx);

        /* mark the secondary CPICH information as present */
        rl_info->dpch_per_rl.opt_parms_present_mask &=
          ~DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT;
      }
    }

    /* Get all of the DPCH code channel list information */
    code_list_ptr = &(ie_ptr->u.fdd->dl_ChannelisationCodeList);
    code_ch = 0;
    n_value = code_list_ptr->n;
    n_index = 0;
    
    while ((n_value != 0) && (code_ch < UE_MAX_DPCH))
    {
      /* Initialize the optional parameters for each code channel */
      if(is_new_rl)
      {
        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask = 0;
      }

      /* decode the Spreading factor and OVSF code */
      sf_choice = code_list_ptr->elem[n_index].sf_AndCodeNumber;
      switch (RRC_GET_MSG_TYPE(sf_choice))
      {
        case T_rrc_SF512_AndCodeNumber_sf4:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf4;
          break;

        case T_rrc_SF512_AndCodeNumber_sf8:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf8;
          break;

        case T_rrc_SF512_AndCodeNumber_sf16:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf16;
          break;

        case T_rrc_SF512_AndCodeNumber_sf32:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf32;
          break;

        case T_rrc_SF512_AndCodeNumber_sf64:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf64;
          break;

        case T_rrc_SF512_AndCodeNumber_sf128:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf128;
          break;

        case T_rrc_SF512_AndCodeNumber_sf256:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf256;
          break;

        case T_rrc_SF512_AndCodeNumber_sf512:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf512;
          break;

        default:
          ERR("Bad SF code %u for RL #%u, DPCH #%u",
                    RRC_GET_MSG_TYPE(sf_choice), rl_idx, code_ch);
          return FAILURE;
      }

      /* Get the secondary scrambling code if present */
      if (RRC_CHECK_MSG_TYPE_IE(code_list_ptr->elem[n_index],
                   secondaryScramblingCodePresent))
      {
        rl_info->dpch_per_rl.dl_chan_code[code_ch].sec_scr_code =
          (uint16) code_list_ptr->elem[n_index].secondaryScramblingCode;

        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask |=
          DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT;
      }
      /* Get the secondary scrambling code if present */
      else
      {
        if (rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask &
          DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT)
        {
          WRRC_MSG1_HIGH("Sec SCR was present before %d",
                   rl_info->dpch_per_rl.dl_chan_code[code_ch].sec_scr_code);
        }
        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask &=
          ~DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT;
      }

      /* Get the secondary scrambling code change if present */
      if (RRC_CHECK_MSG_TYPE_IE(code_list_ptr->elem[n_index],
                  scramblingCodeChangePresent))
      {
        switch (code_list_ptr->elem[n_index].scramblingCodeChange)
        {
          case rrc_ScramblingCodeChange_codeChange:
            rl_info->dpch_per_rl.dl_chan_code[code_ch].scr_code_change =
              TRUE;
            break;

          case rrc_ScramblingCodeChange_noCodeChange:
            rl_info->dpch_per_rl.dl_chan_code[code_ch].scr_code_change =
              FALSE;
            break;

          default:
            WRRC_MSG1_ERROR("Bad sec scr code change parameter %u",
                       code_list_ptr->elem[n_index].scramblingCodeChange);
            return FAILURE;
        }

        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask |=
          DL_DPCH_CODE_CH_SCR_CODE_CHG_PRESENT;
      }

      /* point to the next code channel and increment the code channel
         index variable */
      n_value--;
      n_index++;
      code_ch++;
    }

    /* set the number of DPCH code channels used for this radio link */
    rl_info->dpch_per_rl.num_dpch = code_ch;
  }
  else
  {
    /* FDD choice not selected, TDD not supported */
    return FAILURE;
  }

  /* everything went ok */
  return SUCCESS;
} /* get_dl_dpch_info_for_each_rl_r5() */



/*====================================================================
FUNCTION      get_dl_dpch_info_for_each_rl()

FILE NAME     This function gets the DL DPCH info for each RL

DESCRIPTION   This function translates the Downlink DPCH info for each
              RL IE to the RRC config database.  Note that it is assumed
              that a higher level routine is doing the translation from
              the linked list present in the ASN.1 decoder output to
              the array present in the RRC config database.  The radio
              link index is passed into this function and must be
              generated by that higher level routine.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if everything is ok, FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all of the parameters
              that are present in the IE.  For those parameters not
              present the values currently existing are untouched.  For
              each optional parameter that is present the corresponding
              bit in the optional parameters presence bitmask is set.
====================================================================*/
uecomdef_status_e_type get_dl_dpch_info_for_each_rl
(
  /* pointer to the IE */
  rrc_DL_DPCH_InfoPerRL *ie_ptr,

  /* pointer to the desired DL PhyChan parameter structure */
  l1_dl_phychan_db_struct_type *dl_phychan,

  /* radio link index */
  uint8 rl_idx,

  /* are we setting up a new radio link? */
  boolean is_new_rl
)
{
  l1_dl_info_per_rl_struct_type *rl_info;

  rrc_DL_ChannelisationCodeList *code_list_ptr;
  uint16 code_ch;
  uint16 new_tau_dpch;
  uint32 n_value = 0;
  uint32 n_index = 0;

  rrc_SF512_AndCodeNumber sf_choice;

  if (RRC_CHECK_COMMON_MSG_TYPE_PTR(ie_ptr,
              rrc_DL_DPCH_InfoPerRL_fdd))
  {
    if (rl_idx < UE_MAX_RL)
    {
      rl_info = &dl_phychan->dl_per_rl[rl_idx];
    }
    else
    {
      /* rl_idx too large for supported number of radio links */
      WRRC_MSG0_HIGH("rl_idx out of range");
      return FAILURE;
    }

    /* initialize the optional field bit mask */
    if(is_new_rl)
    {
      rl_info->dpch_per_rl.opt_parms_present_mask = 0;
    }

    /* Get the DPCH frame offset (TauDPCH) */
    new_tau_dpch = (uint16)ie_ptr->u.fdd->dpch_FrameOffset;

    /* This validation should be done by the ASN.1 encoder on the
     * network side, but better not to make any assumptions here.
     */
    if(new_tau_dpch > 149)
    {
      WRRC_MSG1_HIGH("Invalid Tau_DPCH: %s", new_tau_dpch);
      return FAILURE;
    }

    /* An existing radio link cannot have its TauDPCH changed by more
     * than 1.
     */
    if(!is_new_rl &&
        ABS((new_tau_dpch - rl_info->dpch_per_rl.frame_offset)) > 1 &&
        ABS((new_tau_dpch - rl_info->dpch_per_rl.frame_offset)) != 149)
    {
      WRRC_MSG2_HIGH("Tau_DPCH difference > 1: %d (old) %d (new)",
          rl_info->dpch_per_rl.frame_offset, new_tau_dpch);
      return FAILURE;
    }
    rl_info->dpch_per_rl.frame_offset = new_tau_dpch;

    /* Get the CPICH usage for channel estimation */
    switch (ie_ptr->u.fdd->pCPICH_UsageForChannelEst)
    {
      case rrc_PCPICH_UsageForChannelEst_mayBeUsed:
        rl_info->dpch_per_rl.use_pri_cpich = L1_USE_PRI_CPICH;
        break;

      case rrc_PCPICH_UsageForChannelEst_shallNotBeUsed:
        rl_info->dpch_per_rl.use_pri_cpich = L1_DO_NOT_USE_PRI_CPICH;
        break;

      default:
        /* bad enum value, return FALSE immediately */
        WRRC_MSG0_HIGH("Bad CPICH usage enum");
        return FAILURE;
    }

    /* Get the TPC Combination index */
    rl_info->dpch_per_rl.tpc_idx =
      (uint8) ie_ptr->u.fdd->tpc_CombinationIndex;

    /* Get the closed loop timing adjustment type */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->u.fdd,
closedLoopTimingAdjModePresent))
    {

        WRRC_MSG1_HIGH("Indicate CLT info in %d TXDivMode", dl_phychan->dl_common.tx_div_mode);
            
      if (dl_phychan->dl_common.tx_div_mode != L1_TX_DIV_NONE)
      {
        /* a cast here is ok as the mapping is as expected */
        rl_info->dpch_per_rl.closed_loop_timing_adj_mode =
          (uint8) ie_ptr->u.fdd->closedLoopTimingAdjMode;

        /* mark the Closed loop timing adjustment info as present */
        rl_info->dpch_per_rl.opt_parms_present_mask |=
          DL_DPCH_INFO_PER_CLOSED_LOOP_TIMING_ADJ_PRESENT;
      }
    }
    else
    {
      if(rl_info->dpch_per_rl.opt_parms_present_mask & DL_DPCH_INFO_PER_CLOSED_LOOP_TIMING_ADJ_PRESENT)
      {
	  WRRC_MSG0_HIGH("clearing CLT ");
    	  rl_info->dpch_per_rl.opt_parms_present_mask &=
  	     ~DL_DPCH_INFO_PER_CLOSED_LOOP_TIMING_ADJ_PRESENT;
      }
    }

    /* Get the secondary CPICH information */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->u.fdd,
                secondaryCPICH_InfoPresent))
    {
      /* set the secondary CPICH channelisation code */
      rl_info->dpch_per_rl.sec_cpich_ch_code =
        (uint16) ie_ptr->u.fdd->secondaryCPICH_Info.channelisationCode;

      if (RRC_CHECK_MSG_TYPE_IE(ie_ptr->u.fdd->secondaryCPICH_Info,
                  secondaryDL_ScramblingCodePresent))
      {
        /* set the secondary CPICH secondary scrambling code */
        rl_info->dpch_per_rl.sec_cpich_sec_scr_code =
          (uint16) ie_ptr->u.fdd->secondaryCPICH_Info.secondaryDL_ScramblingCode;

        rl_info->dpch_per_rl.opt_parms_present_mask |=
          DL_DPCH_INFO_PER_RL_SEC_CPICH_SEC_SCR_CODE_PRESENT;
      }

      /* mark the secondary CPICH information as present */
      rl_info->dpch_per_rl.opt_parms_present_mask |=
        DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT;
    }
    /* secondary cpich info is not present. It might have been present
    for the same radiolink before. Make sure that L1 gets
    correct bit masks */
    else
    {
      if (rl_info->dpch_per_rl.opt_parms_present_mask &
        DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT)
      {
        WRRC_MSG1_HIGH("Sec CPICH was present before rl_id:%d",
                 rl_idx);

        /* mark the secondary CPICH information as present */
        rl_info->dpch_per_rl.opt_parms_present_mask &=
          ~DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT;
      }
    }

    /* Get all of the DPCH code channel list information */
    code_list_ptr = &(ie_ptr->u.fdd->dl_ChannelisationCodeList);
    code_ch = 0;
    n_value = code_list_ptr->n;
    
    while ((n_value != 0) && (code_ch < UE_MAX_DPCH))
    {
      /* Initialize the optional parameters for each code channel */
      if(is_new_rl)
      {
        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask = 0;
      }

      /* decode the Spreading factor and OVSF code */
      sf_choice = code_list_ptr->elem[n_index].sf_AndCodeNumber;
      switch (RRC_GET_MSG_TYPE(sf_choice))
      {
        case T_rrc_SF512_AndCodeNumber_sf4:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf4;
          break;

        case T_rrc_SF512_AndCodeNumber_sf8:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf8;
          break;

        case T_rrc_SF512_AndCodeNumber_sf16:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf16;
          break;

        case T_rrc_SF512_AndCodeNumber_sf32:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf32;
          break;

        case T_rrc_SF512_AndCodeNumber_sf64:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf64;
          break;

        case T_rrc_SF512_AndCodeNumber_sf128:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf128;
          break;

        case T_rrc_SF512_AndCodeNumber_sf256:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf256;
          break;

        case T_rrc_SF512_AndCodeNumber_sf512:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf512;
          break;

        default:
          ERR("Bad SF code %u for RL #%u, DPCH #%u",
                    RRC_GET_MSG_TYPE(sf_choice), rl_idx, code_ch);
          return FAILURE;
      }

      /* Get the secondary scrambling code if present */
      if (RRC_CHECK_MSG_TYPE_IE(code_list_ptr->elem[n_index],
                     secondaryScramblingCodePresent))
      {
        rl_info->dpch_per_rl.dl_chan_code[code_ch].sec_scr_code =
          (uint16) code_list_ptr->elem[n_index].secondaryScramblingCode;

        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask |=
          DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT;
      }
      /* Get the secondary scrambling code if present */
      else
      {
        if (rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask &
          DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT)
        {
          WRRC_MSG1_HIGH("Sec SCR was present before %d",
                   rl_info->dpch_per_rl.dl_chan_code[code_ch].sec_scr_code);
        }
        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask &=
          ~DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT;
      }

      /* Get the secondary scrambling code change if present */
      if (RRC_CHECK_MSG_TYPE_IE(code_list_ptr->elem[n_index],
                  scramblingCodeChangePresent))
      {
        switch (code_list_ptr->elem[n_index].scramblingCodeChange)
        {
          case rrc_ScramblingCodeChange_codeChange:
            rl_info->dpch_per_rl.dl_chan_code[code_ch].scr_code_change =
              TRUE;
            break;

          case rrc_ScramblingCodeChange_noCodeChange:
            rl_info->dpch_per_rl.dl_chan_code[code_ch].scr_code_change =
              FALSE;
            break;

          default:
            WRRC_MSG1_ERROR("Bad sec scr code change parameter %u",
                       code_list_ptr->elem[n_index].scramblingCodeChange);
            return FAILURE;
        }

        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask |=
          DL_DPCH_CODE_CH_SCR_CODE_CHG_PRESENT;
      }

      /* point to the next code channel and increment the code channel
         index variable */
      n_value--;
      n_index++;
      code_ch++;
    }

    /* set the number of DPCH code channels used for this radio link */
    rl_info->dpch_per_rl.num_dpch = code_ch;
  }
  else
  {
    /* FDD choice not selected, TDD not supported */
    return FAILURE;
  }

  /* everything went ok */
  return SUCCESS;
} /* get_dl_dpch_info_for_each_rl() */

/*====================================================================
FUNCTION        get_dl_info_common_for_all_rl()

DESCRIPTION     This function translates the Downlink information common
                for all radio links IE into the RRC config database.

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
uecomdef_status_e_type get_dl_info_common_for_all_rl
(
  /* Pointer to the DL CommonInformation IE */
  rrc_DL_CommonInformation *ie_ptr,

  /* Pointer to the desirec DL PhyChan common information structure */
  l1_dl_common_info_struct_type *dl_common,

  /* Pointer to the DL CCTRCH parameters structure */
  l1_dl_cctrch_info_struct_type *l1_dl_cctrch_parms,

  /* Pointer to the DL CTFC parameters structure */
  l1_dl_ctfc_info_struct_type *l1_dl_ctfc_info
)
{
  rrc_state_e_type   rrc_state;
  boolean compressed_mode_config_ignore = FALSE;
  uint32 n_value = 0;
  uint32 n_index = 0;
  
  struct rrc_TGP_SequenceList *local_tgp_SequenceList_ptr = NULL;

  MSG_MED("Get DL Info Common for all RL",0,0,0);

  /* initialize the optional field bit mask */
   /* Don't reset DOFF bitmask in DCH state.*/
  dl_common->opt_parm_presence_bitmask = 
      dl_common->opt_parm_presence_bitmask & DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;

  /* Get the info common for all DL DPCH if present */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
               dl_DPCH_InfoCommonPresent))
  {
    if(get_dl_dpch_common_info(&ie_ptr->dl_DPCH_InfoCommon,
                               &dl_common->dpch_common,
                               l1_dl_cctrch_parms,
                               l1_dl_ctfc_info
                              ) == FAILURE
      )
    {
      return FAILURE;
    }
  } /* end if dl dpch common info present */

  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                T_rrc_DL_CommonInformation_modeSpecificInfo_fdd))
  {

  /* Get the DPCH compressed mode info. To be completed */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
        dpch_CompressedModeInfoPresent))
    {
      if ((ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
        (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH) &&
        (transition_config.toc_ptr->cm_info.tgp_seq_info_count == 0) &&
        (ie_ptr->modeSpecificInfo.u.fdd->dpch_CompressedModeInfo.tgp_SequenceList.n != 0)
        )
      {
        /* Check if network tries to deactivate without specifying the config parameters */
        local_tgp_SequenceList_ptr =
          &(ie_ptr->modeSpecificInfo.u.fdd->dpch_CompressedModeInfo.tgp_SequenceList);

        n_value = local_tgp_SequenceList_ptr->n;
        n_index = 0;
        while (n_value != 0)
        {
          if((RRC_CHECK_MSG_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_Status,
                                        T_rrc_TGP_Sequence_tgps_Status_deactivate)) &&
            (!(RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index],
                                        tgps_ConfigurationParamsPresent))))
          {
            /* Set forcibly the bit mask for CM to 0. No need to check others */
            compressed_mode_config_ignore = TRUE;
            break;
          }
          else
          {
            n_value--;
            n_index++;
          }

        }
      }

      if (compressed_mode_config_ignore == TRUE)
      {
        WRRC_MSG0_HIGH("Deactivate TGPSI.CM config ignored");
      }
      else
      {
        if (set_compressed_mode_info(
          &ie_ptr->modeSpecificInfo.u.fdd->dpch_CompressedModeInfo) == FAILURE)
        {
          return FAILURE;
        }

        dl_common->opt_parm_presence_bitmask |=
          DL_COMMON_INFO_COMPRESSED_MODE_INFO_PRESENT;
      }
    }

    /* Get the TX Diversity Mode info. */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                  tx_DiversityModePresent))
    {
      if(get_tx_diversity_mode_info(ie_ptr->modeSpecificInfo.u.fdd->tx_DiversityMode,
                                    dl_common) == FAILURE)
      {
        return FAILURE;
      }
    } /* end Tx Diversity Prescence */

      /* Get the default DPCH offset if present */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                    defaultDPCH_OffsetValuePresent))
    {
      dl_common->default_dpch_offset =
        (uint16) ie_ptr->modeSpecificInfo.u.fdd->defaultDPCH_OffsetValue;

      if(dl_common->default_dpch_offset > RRCLLC_ASN1_DOFF_MAX_VAL)
      {
        WRRC_MSG0_ERROR("Doff ASN1 value out of range");
        return(FAILURE);
      }
      /* Multiply the ASN1 value with multiplication factor before sending
       * it to L1.
       */
      dl_common->default_dpch_offset  *= RRCLLC_DOFF_MULTIPLICATION_FACTOR;
      dl_common->opt_parm_presence_bitmask |=
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    }
    else
    {
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_CELL_DCH)
      {
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          /* This is an error case since we are going to Cell_DCH from
           * another state and Doff is not signalled
           */
          WRRC_MSG2_ERROR("Doff absent RRC state curr%d next%d",
              rrc_state, ordered_config_ptr->rrc_state_indicator);
          return(FAILURE);
        }
      }

      if(dl_common->dpch_common.timing_ind == L1_TIMING_IND_INIT &&
          check_hho_cfn_handling)
      {
        /* This is an error case since we are doing a timing initialized
         * hard handover and Doff is not signalled
         */
        WRRC_MSG0_ERROR("Doff absent during timing-init HHO");
        return FAILURE;
      }
    }  /* Doff is absent */

    /* We're done with this flag now. */
    check_hho_cfn_handling = FALSE;

  } /* end if common FDD */
  else
  {
    /* FDD not selected.  Error as TDD not supported */
    return FAILURE;
  }
  /* Indicate that Downlink L1 needs to be reconfigured */
  ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
 /* Although no new parameters for MAC have been received, MAC
  * still needs to be reconfigured so as to get the new CCTrCH
  * ID whenever Downlink L1 is reconfigured. This is due to the
  * interface requirements.
  */
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
  return SUCCESS;
} /* get_dl_info_common_for_all_rl() */



/*====================================================================
FUNCTION        get_dl_info_common_for_all_rl_r5()

DESCRIPTION     This function translates the Downlink information common
                for all radio links IE into the RRC config database.

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
uecomdef_status_e_type get_dl_info_common_for_all_rl_r5
(
  /* Pointer to the DL CommonInformation IE */
  rrc_DL_CommonInformation_r5 *ie_ptr,

  /* Pointer to the desirec DL PhyChan common information structure */
  l1_dl_common_info_struct_type *dl_common,

  /* Pointer to the DL CCTRCH parameters structure */
  l1_dl_cctrch_info_struct_type *l1_dl_cctrch_parms,

  /* Pointer to the DL CTFC parameters structure */
  l1_dl_ctfc_info_struct_type *l1_dl_ctfc_info
)
{
  struct rrc_TGP_SequenceList *local_tgp_SequenceList_ptr = NULL;

  boolean compressed_mode_config_ignore = FALSE;
  uint32 n_value = 0;
  uint32 n_index = 0;
  rrc_state_e_type   rrc_state;
  MSG_MED("Get DL Info Common for all RL",0,0,0);

  /* initialize the optional field bit mask */
  /* Don't reset DOFF bitmask in DCH state.*/
  dl_common->opt_parm_presence_bitmask = 
      dl_common->opt_parm_presence_bitmask & DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;

  /* Check if HS Reset is indicated */
  /* TBD Why only one value in HSRESET is specified */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                mac_hsResetIndicatorPresent))
  {
    /* Set it in MAC params */
    ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = TRUE;
    hsdpa_msg_params.msg_params_present = TRUE;
  }

  /* Get the info common for all DL DPCH if present */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                dl_DPCH_InfoCommonPresent))
  {
    if(get_dl_dpch_common_info_r5(&ie_ptr->dl_DPCH_InfoCommon,
                               &dl_common->dpch_common,
                               l1_dl_cctrch_parms,
                               l1_dl_ctfc_info
                              ) == FAILURE
      )
    {
      return FAILURE;
    }
  } /* end if dl dpch common info present */

  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                T_rrc_DL_CommonInformation_r5_modeSpecificInfo_fdd))
  {

  /* Get the DPCH compressed mode info. To be completed */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                    dpch_CompressedModeInfoPresent))
    {
      if ((ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
        (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH) &&
        (transition_config.toc_ptr->cm_info.tgp_seq_info_count == 0) &&
        (ie_ptr->modeSpecificInfo.u.fdd->dpch_CompressedModeInfo.tgp_SequenceList.n != 0)
        )
      {
        /* Check if network tries to deactivate without specifying the config parameters */
        local_tgp_SequenceList_ptr =
          &(ie_ptr->modeSpecificInfo.u.fdd->dpch_CompressedModeInfo.tgp_SequenceList);

        n_value = local_tgp_SequenceList_ptr->n;
        n_index = 0;
        while (n_value != 0)
        {
          if((RRC_CHECK_MSG_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_Status,
                                  T_rrc_TGP_Sequence_tgps_Status_deactivate)) &&
            (!(RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index],
                                 tgps_ConfigurationParamsPresent))))
          {
            /* Set forcibly the bit mask for CM to 0. No need to check others */
            WRRC_MSG0_HIGH("Deactivate TGPSI.No CM params");
            compressed_mode_config_ignore = TRUE;
            break;
          }
          else
          {
            n_value--;
            n_index++;
          }

        }
      }

      if (compressed_mode_config_ignore == TRUE)
      {
        WRRC_MSG0_HIGH("CM Config Ignored");
      }
      else
      {
        if (set_compressed_mode_info(
          &ie_ptr->modeSpecificInfo.u.fdd->dpch_CompressedModeInfo) == FAILURE)
        {
          return FAILURE;
        }

        dl_common->opt_parm_presence_bitmask |=
          DL_COMMON_INFO_COMPRESSED_MODE_INFO_PRESENT;
      }
    }

    /* Get the TX Diversity Mode info. */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                     tx_DiversityModePresent))
    {
      if(get_tx_diversity_mode_info(ie_ptr->modeSpecificInfo.u.fdd->tx_DiversityMode,
                                    dl_common) == FAILURE)
      {
        return FAILURE;
      }
    } /* end Tx Diversity Prescence */

      /* Get the default DPCH offset if present */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                    defaultDPCH_OffsetValuePresent))
    {
      dl_common->default_dpch_offset =
        (uint16) ie_ptr->modeSpecificInfo.u.fdd->defaultDPCH_OffsetValue;

      if(dl_common->default_dpch_offset > RRCLLC_ASN1_DOFF_MAX_VAL)
      {
        WRRC_MSG0_ERROR("Doff ASN1 value out of range");
        return(FAILURE);
      }
      /* Multiply the ASN1 value with multiplication factor before sending
       * it to L1.
       */
      dl_common->default_dpch_offset  *= RRCLLC_DOFF_MULTIPLICATION_FACTOR;
      dl_common->opt_parm_presence_bitmask |=
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    }
    else
    {
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_CELL_DCH)
      {
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          /* This is an error case since we are going to Cell_DCH from
           * another state and Doff is not signalled
           */
          WRRC_MSG2_ERROR("Doff absent RRC state curr%d next%d",
              rrc_state, ordered_config_ptr->rrc_state_indicator);
          return(FAILURE);
        }
      }
      if(dl_common->dpch_common.timing_ind == L1_TIMING_IND_INIT &&
          check_hho_cfn_handling)
      {
        /* This is an error case since we are doing a timing initialized
         * hard handover and Doff is not signalled
         */
        WRRC_MSG0_ERROR("Doff absent during timing-init HHO");
        return FAILURE;
      }
    }  /* Doff is absent */

    /* We're done with this flag now. */
    check_hho_cfn_handling = FALSE;

  } /* end if common FDD */
  else
  {
    /* FDD not selected.  Error as TDD not supported */
    return FAILURE;
  }
  /* Indicate that Downlink L1 needs to be reconfigured */
  ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
 /* Although no new parameters for MAC have been received, MAC
  * still needs to be reconfigured so as to get the new CCTrCH
  * ID whenever Downlink L1 is reconfigured. This is due to the
  * interface requirements.
  */
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
  return SUCCESS;
} /* get_dl_info_common_for_all_rl_r5() */


/*====================================================================
FUNCTION        get_dl_info_common_for_all_rl_per_r4_rrc_connection()

DESCRIPTION     This function translates the Downlink information common
                for all radio links IE into the RRC config database.

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
uecomdef_status_e_type get_dl_info_common_for_all_rl_per_r4_rrc_connection
(
  /* Pointer to the DL CommonInformation IE */
  rrc_DL_CommonInformation_r4 *ie_ptr,

  /* Pointer to the desirec DL PhyChan common information structure */
  l1_dl_common_info_struct_type *dl_common,

  /* Pointer to the DL CCTRCH parameters structure */
  l1_dl_cctrch_info_struct_type *l1_dl_cctrch_parms,

  /* Pointer to the DL CTFC parameters structure */
  l1_dl_ctfc_info_struct_type *l1_dl_ctfc_info
)
{
  struct rrc_TGP_SequenceList *local_tgp_SequenceList_ptr = NULL;
  boolean compressed_mode_config_ignore = FALSE;
  uint32 n_value = 0;
  uint32 n_index = 0;
  rrc_state_e_type   rrc_state;
  MSG_MED("Get DL Info Common for all RL",0,0,0);

  /* initialize the optional field bit mask */
  /* Don't reset DOFF bitmask in DCH state.*/
  dl_common->opt_parm_presence_bitmask = 
      dl_common->opt_parm_presence_bitmask & DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;

  /* Get the info common for all DL DPCH if present */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
              dl_DPCH_InfoCommonPresent))
  {
    if(get_dl_dpch_common_info_r5(&ie_ptr->dl_DPCH_InfoCommon,
                               &dl_common->dpch_common,
                               l1_dl_cctrch_parms,
                               l1_dl_ctfc_info
                              ) == FAILURE
      )
    {
      return FAILURE;
    }
  } /* end if dl dpch common info present */

  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                T_rrc_DL_CommonInformation_r4_modeSpecificInfo_fdd))
  {

  /* Get the DPCH compressed mode info. To be completed */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                dpch_CompressedModeInfoPresent))
    {
      if ((ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
        (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH) &&
        (transition_config.toc_ptr->cm_info.tgp_seq_info_count == 0) &&
        (ie_ptr->modeSpecificInfo.u.fdd->dpch_CompressedModeInfo.tgp_SequenceList.n != 0)
        )
      {
        /* Check if network tries to deactivate without specifying the config parameters */
        local_tgp_SequenceList_ptr =
          &(ie_ptr->modeSpecificInfo.u.fdd->dpch_CompressedModeInfo.tgp_SequenceList);

        n_value = local_tgp_SequenceList_ptr->n;
        while (n_value != 0)
        {
          if((RRC_CHECK_MSG_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_Status,
                                  T_rrc_TGP_Sequence_tgps_Status_deactivate)) &&
            (!(RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index],
                                  tgps_ConfigurationParamsPresent))))
          {
            /* Set forcibly the bit mask for CM to 0. No need to check others */
            WRRC_MSG0_HIGH("Deactivate TGPSI.No CM params");
            compressed_mode_config_ignore = TRUE;
            break;
          }
          else
          {
            n_value--;
            n_index++;
          }

        }
      }

      if (compressed_mode_config_ignore == TRUE)
      {
        WRRC_MSG0_HIGH("CM Config Ignored");
      }
      else
      {
        if (set_compressed_mode_info(
          &ie_ptr->modeSpecificInfo.u.fdd->dpch_CompressedModeInfo) == FAILURE)
        {
          return FAILURE;
        }

        dl_common->opt_parm_presence_bitmask |=
          DL_COMMON_INFO_COMPRESSED_MODE_INFO_PRESENT;
      }
    }

    /* Get the TX Diversity Mode info. */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                     tx_DiversityModePresent))
    {
      if(get_tx_diversity_mode_info(ie_ptr->modeSpecificInfo.u.fdd->tx_DiversityMode,
                                    dl_common) == FAILURE)
      {
        return FAILURE;
      }
    } /* end Tx Diversity Prescence */

      /* Get the default DPCH offset if present */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
       defaultDPCH_OffsetValuePresent))
    {
      dl_common->default_dpch_offset =
        (uint16) ie_ptr->modeSpecificInfo.u.fdd->defaultDPCH_OffsetValue;

      if(dl_common->default_dpch_offset > RRCLLC_ASN1_DOFF_MAX_VAL)
      {
        WRRC_MSG0_ERROR("Doff ASN1 value out of range");
        return(FAILURE);
      }
      /* Multiply the ASN1 value with multiplication factor before sending
       * it to L1.
       */
      dl_common->default_dpch_offset  *= RRCLLC_DOFF_MULTIPLICATION_FACTOR;
      dl_common->opt_parm_presence_bitmask |=
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    }
    else
    {
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_CELL_DCH)
      {
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          /* This is an error case since we are going to Cell_DCH from
           * another state and Doff is not signalled
           */
          WRRC_MSG2_ERROR("Doff absent RRC state curr%d next%d",
              rrc_state, ordered_config_ptr->rrc_state_indicator);
          return(FAILURE);
        }
      }
      if(dl_common->dpch_common.timing_ind == L1_TIMING_IND_INIT &&
          check_hho_cfn_handling)
      {
        /* This is an error case since we are doing a timing initialized
         * hard handover and Doff is not signalled
         */
        WRRC_MSG0_ERROR("Doff absent during timing-init HHO");
        return FAILURE;
      }
    }  /* Doff is absent */

    /* We're done with this flag now. */
    check_hho_cfn_handling = FALSE;

  } /* end if common FDD */
  else
  {
    /* FDD not selected.  Error as TDD not supported */
    return FAILURE;
  }
  /* Indicate that Downlink L1 needs to be reconfigured */
  ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
 /* Although no new parameters for MAC have been received, MAC
  * still needs to be reconfigured so as to get the new CCTrCH
  * ID whenever Downlink L1 is reconfigured. This is due to the
  * interface requirements.
  */
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
  return SUCCESS;
} /* get_dl_info_common_for_all_rl_per_r4_rrc_connection() */


static boolean is_current_camped_psc_in_rl_info_r5(rrc_DL_InformationPerRL_List_r5 *ie_ptr)
{
  rrc_scr_code_type current_psc;

  current_psc = rrc_ccm_get_curr_camped_psc();
  
  if(ie_ptr->n != 0)
  {
    /*Removed the DPCH presence check to allow detection of semless reconfiguration, this covers 
     scenarios like FACH to DCH(R99), FACH to DCH(FDPCH/EUL), R99<->EUL reconfig in DCH. 
     Introduced during HSRACH to DCH seamless reconfig optimization where PCCPCH can be dropped
     Impact:
     1. new_freq is filled in L1 cmd pointer for non-seamless reconfig cases
     2. With the new change we may not send add/drop of DPCH(unlike legacy), if DPCH to FDPCH reconfig happens
        Verified with L1 for this case and they are OK to not send add/drop for such reconfig 
    */
    if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[0].modeSpecificInfo,
                  T_rrc_DL_InformationPerRL_r5_modeSpecificInfo_fdd))
    {
      if(current_psc == (rrc_scr_code_type)ie_ptr->elem[0].modeSpecificInfo.u.fdd->
                                           primaryCPICH_Info.primaryScramblingCode)
      {
        return (TRUE);
      }
    }
  }
  return(FALSE);
}

static boolean is_current_camped_psc_in_rl_info_r5_per_rrc_connection(rrc_DL_InformationPerRL_List_r5bis *ie_ptr)
{
  rrc_scr_code_type current_psc;

  current_psc = rrc_ccm_get_curr_camped_psc();

  if(ie_ptr->n != 0)
  {
    /*Removed the DPCH presence check to allow detection of semless reconfiguration, this covers 
     scenarios like FACH to DCH(R99), FACH to DCH(FDPCH/EUL), R99<->EUL reconfig in DCH. 
     Introduced during HSRACH to DCH seamless reconfig optimization where PCCPCH can be dropped
     Impact:
     1. new_freq is filled in L1 cmd pointer for non-seamless reconfig cases
     2. With the new change we may not send add/drop of DPCH(unlike legacy), if DPCH to FDPCH reconfig happens
        Verified with L1 for this case and they are OK to not send add/drop for such reconfig 
    */
    if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[0].modeSpecificInfo,
                T_rrc_DL_InformationPerRL_r5bis_modeSpecificInfo_fdd))
    {
      if(current_psc == (rrc_scr_code_type)ie_ptr->elem[0].modeSpecificInfo.u.fdd->
                                           primaryCPICH_Info.primaryScramblingCode)
      {
        return (TRUE);
      }
    }
  }
  return(FALSE);
}

/*====================================================================
FUNCTION        get_dl_rl_idx_to_update_r5_per_rrc_connection()

DESCRIPTION     This function retrieves the RL index for a given
                scrambling code in a Downlink information for each
                radio link IE

DEPENDENCIES    NONE

RETURN VALUE    RL index if found, UE_MAX_RL otherwise.

SIDE EFFECTS
====================================================================*/
static uint8 get_dl_rl_idx_to_update_r5_per_rrc_connection
(
  rrc_DL_InformationPerRL_r5bis *ie_ptr,
  l1_dl_phychan_db_struct_type *dl_phychan
)
{
  uint8 idx;

  for(idx = 0; idx < UE_MAX_RL; idx++)
  {
    if(RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                 T_rrc_DL_InformationPerRL_r5bis_modeSpecificInfo_fdd))
    {
      if(dl_phychan->dl_per_rl[idx].pri_cpich_scr_code ==
         ie_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode)
      {
        return idx;
      }

    }
    else
    {
      /* No FDD info.  We don't support TDD so return indicating an error */
      return UE_MAX_RL;
    }
  }

  /* If we got all the way here, idx will be set to UE_MAX_RL. */
  return idx;
}


/*====================================================================
FUNCTION        get_dl_info_for_each_rl_r5()

DESCRIPTION     This function translates the Downlink information for
                each radio link IE to the RRC config database

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
rrcllcoc_dl_info_per_rl_status_e_type get_dl_info_for_each_rl_r5
(
  rrc_DL_InformationPerRL_r5 *ie_ptr,

  l1_dl_phychan_db_struct_type *dl_phychan,

  uint8 rl_idx,

  boolean is_new_rl
)
{
  l1_dl_info_per_rl_struct_type *rl_info;

  if (rl_idx >= UE_MAX_RL)
  {
    /* radio link index too large, bail */
    WRRC_MSG1_ERROR("Too many Radio Links %d", rl_idx);
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }

  MSG_MED("RRCHS:Get Dl Info per RL",0,0,0);
  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
              T_rrc_DL_InformationPerRL_r5_modeSpecificInfo_fdd))
  {
    /* First check if the DL DPCH Info per RL is included. If not,
    * this is NOT a valid Radio link - ignore it.
    */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
              dl_DPCH_InfoPerRLPresent))
    {
    /* snap a local pointer to the proper radio link element in the
      RRC config page */
      rl_info = &dl_phychan->dl_per_rl[rl_idx];

      /* Get the Primary CPICH scrambling code */
      rl_info->pri_cpich_scr_code =
        (uint16) ie_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

      /*If Cell_id is present for this RL, store it in cell_id_per_rl */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                cell_idPresent))
      {
        cell_id_per_rl[rl_idx] = (uint32) rrc_translate_cell_id(&(ie_ptr->cell_id));
      }       


      /* Get the DL DPCH info for this radio link */
      MSG_MED("Get DL DPCH Info for RL %d", (rl_idx + 1), 0, 0);

      if (get_dl_dpch_info_for_each_rl_r5(&ie_ptr->dl_DPCH_InfoPerRL,
        dl_phychan, rl_idx,
        is_new_rl) == FAILURE)
      {
        return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
      }
      /* if we made it here we must be ok */
      /* Indicate that Downlink L1 needs to be configured */
      ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
      /* Although no new parameters for MAC have been received, MAC
      * still needs to be reconfigured so as to get the new CCTrCH
      * ID whenever Downlink L1 is reconfigured. This is due to the
      * interface requirements.
      */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      return RRCLLCOC_DL_INFO_PER_RL_SUCCESS;
    }  /* DL DPCH Info is present */
    else
    {
      /* DL DPCH Info per RL is NOT present - ignore this IE */
      return RRCLLCOC_DL_INFO_PER_RL_IGNORED;
    }
  }
  else
  {
    /* No FDD info.  We don't support TDD so return indicating an error */
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }
} /* get_dl_info_for_each_rl_r5() */


/*====================================================================
FUNCTION        get_dl_info_for_each_rl_r5_per_rrc_connection()

DESCRIPTION     This function translates the Downlink information for
                each radio link IE to the RRC config database

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
rrcllcoc_dl_info_per_rl_status_e_type get_dl_info_for_each_rl_r5_per_rrc_connection
(
  rrc_DL_InformationPerRL_r5bis *ie_ptr,

  l1_dl_phychan_db_struct_type *dl_phychan,

  uint8 rl_idx,

  boolean is_new_rl
)
{
  l1_dl_info_per_rl_struct_type *rl_info;

  if (rl_idx >= UE_MAX_RL)
  {
    /* radio link index too large, bail */
    WRRC_MSG1_ERROR("Too many Radio Links %d", rl_idx);
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }

  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
              T_rrc_DL_InformationPerRL_r5bis_modeSpecificInfo_fdd))
  {
    /* First check if the DL DPCH Info per RL is included. If not,
    * this is NOT a valid Radio link - ignore it.
    */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
              dl_DPCH_InfoPerRLPresent))
    {
    /* snap a local pointer to the proper radio link element in the
      RRC config page */
      rl_info = &dl_phychan->dl_per_rl[rl_idx];

      /* Get the Primary CPICH scrambling code */
      rl_info->pri_cpich_scr_code =
        (uint16) ie_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

      /*If Cell_id is present for this RL, store it in cell_id_per_rl */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
cell_idPresent))
      {
        cell_id_per_rl[rl_idx] = (uint32) rrc_translate_cell_id(&(ie_ptr->cell_id));
      }  

      /* Get the DL DPCH info for this radio link */
      MSG_MED("Get DL DPCH Info for RL %d", (rl_idx + 1), 0, 0);

      if (get_dl_dpch_info_for_each_rl_r5(&ie_ptr->dl_DPCH_InfoPerRL,
        dl_phychan, rl_idx,
        is_new_rl) == FAILURE)
      {
        return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
      }
      /* if we made it here we must be ok */
      /* Indicate that Downlink L1 needs to be configured */
      ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
      /* Although no new parameters for MAC have been received, MAC
      * still needs to be reconfigured so as to get the new CCTrCH
      * ID whenever Downlink L1 is reconfigured. This is due to the
      * interface requirements.
      */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      return RRCLLCOC_DL_INFO_PER_RL_SUCCESS;
    }  /* DL DPCH Info is present */
    else
    {
      /* DL DPCH Info per RL is NOT present - ignore this IE */
      return RRCLLCOC_DL_INFO_PER_RL_IGNORED;
    }
  }
  else
  {
    /* No FDD info.  We don't support TDD so return indicating an error */
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }
} /* get_dl_info_for_each_rl_r5_per_rrc_connection() */





/*============================================================================
FUNCTION: rrcllc_get_predefined_dl_rl_list

DESCRIPTION:

      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
#if 0
uecomdef_status_e_type rrcllc_get_predefined_dl_rl_list
(
  struct rrc_DL_InformationPerRL_List   *dl_rl_ptr,
  rrc_DL_InformationPerRL_ListPostFDD  *dl_rl_post_ptr,
  rrc_DL_CommonInformation        dl_common_info
)  
{
  uint8 idx = 0;
  struct rrc_DL_ChannelisationCodeList *tmp_dl_chan_code;
  uint32 n_value = 0;
  uint32 n_index = 0;

  n_value = dl_rl_post_ptr->n;
  
  while(n_value != 0 && idx < UE_MAX_RL)
  {
    RRC_RESET_MSG_IE_PRESENT(dl_rl_ptr[idx].elem[n_index]);
    dl_rl_ptr[idx].elem[n_index].bit_mask |= rrc_DL_InformationPerRL_dl_DPCH_InfoPerRL_present;
    dl_rl_ptr[idx].elem[n_index].modeSpecificInfo.u.fdd->bit_mask = 0;
    dl_rl_ptr[idx].elem[n_index].modeSpecificInfo.choice =
      rrc_DL_InformationPerRL_modeSpecificInfo_fdd_chosen;
    dl_rl_ptr[idx].elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_Info =
      dl_rl_post_ptr->elem[n_index].primaryCPICH_Info;
    dl_rl_ptr[idx].elem[n_index].dl_DPCH_InfoPerRL.u.fdd->bit_mask = 0;
    dl_rl_ptr[idx].elem[n_index].dl_DPCH_InfoPerRL.choice =
      rrc_DL_DPCH_InfoPerRL_fdd_chosen;
    dl_rl_ptr[idx].elem[n_index].dl_DPCH_InfoPerRL.u.fdd->pCPICH_UsageForChannelEst =
      dl_rl_post_ptr->elem[n_index].dl_DPCH_InfoPerRL.pCPICH_UsageForChannelEst;
    dl_rl_ptr[idx].elem[n_index].dl_DPCH_InfoPerRL.u.fdd->pCPICH_UsageForChannelEst =
       rrc_PCPICH_UsageForChannelEst_mayBeUsed;
    dl_rl_ptr[idx].elem[n_index].dl_DPCH_InfoPerRL.u.fdd->dpch_FrameOffset = 
     ((dl_common_info.modeSpecificInfo.u.fdd->defaultDPCH_OffsetValue * 512)
       % 38400) / 256; /* 25.331, clause 8.3.5.1.2 */


    tmp_dl_chan_code.next = NULL;
    tmp_dl_chan_code.value =
      dl_rl_post_ptr->elem[n_index].dl_DPCH_InfoPerRL.dl_ChannelisationCode;
    dl_rl_ptr[idx].elem[n_index].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList =
      &tmp_dl_chan_code;
    dl_rl_ptr[idx].elem[n_index].dl_DPCH_InfoPerRL.u.fdd->tpc_CombinationIndex =
      dl_rl_post_ptr->elem[n_index].dl_DPCH_InfoPerRL.tpc_CombinationIndex;
    
    n_value--;
    n_index++;
    idx++;
  }
  dl_rl_ptr[idx > 0 ? idx - 1 : 0].next = NULL;

  return SUCCESS;
}
#endif

/*============================================================================
FUNCTION: rrcllc_get_predefined_dl_common_info

DESCRIPTION:

      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllc_get_predefined_dl_common_info
(
  rrc_DL_CommonInformation        *dl_common_info_ptr,
  rrc_DL_CommonInformationPost    *dl_common_info_post_ptr,
  rrc_PreDefPhyChConfiguration *predef_phych,
  rrc_U_RNTI_Short *new_urnti_ptr
)  
{
  uint16     srnti2  = 0; /* S-RNTI 2 portion of the U-RNTI in the message,
                             used later to calculate the default DPCH offset
                             value in preconfigured mode */

  RRC_RESET_MSG_IE_PRESENT_PTR(dl_common_info_ptr);
  RRCSET_MSG_TYPE(dl_common_info_ptr->dl_DPCH_InfoCommon.cfnHandling,
               T_rrc_DL_DPCH_InfoCommon_cfnHandling_maintain);
  RRCSET_MSG_TYPE(dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo,
              T_rrc_DL_DPCH_InfoCommon_modeSpecificInfo_fdd);

  RRC_RESET_MSG_IE_PRESENT_PTR(dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd);
  dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->dl_DPCH_PowerControlInfo =
  dl_common_info_post_ptr->dl_DPCH_InfoCommon.dl_DPCH_PowerControlInfo;
  RRCSET_MSG_TYPE_IE_PTR(dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd,
              dl_DPCH_PowerControlInfoPresent);
  dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->powerOffsetPilot_pdpdch = 0; /* 25.331, clause 8.3.6.3 */
  rrc_set_predefined_po3_status(TRUE);
  rrc_predef_po3_not_needed = TRUE;
  dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->spreadingFactorAndPilot =
      predef_phych->dl_CommonInformationPredef.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->spreadingFactorAndPilot;
  dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->positionFixedOrFlexible =
      predef_phych->dl_CommonInformationPredef.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->positionFixedOrFlexible;
  dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->tfci_Existence =
      predef_phych->dl_CommonInformationPredef.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->tfci_Existence;
  RRCSET_MSG_TYPE_IE_PTR(dl_common_info_ptr,
              dl_DPCH_InfoCommonPresent);
  RRCSET_MSG_TYPE(dl_common_info_ptr->modeSpecificInfo,
              T_rrc_DL_CommonInformation_modeSpecificInfo_fdd);
  RRC_RESET_MSG_IE_PRESENT_PTR(dl_common_info_ptr->modeSpecificInfo.u.fdd);

  srnti2 = *(new_urnti_ptr->s_RNTI_2.data) << 8;
  srnti2 |= *(new_urnti_ptr->s_RNTI_2.data + 1);
  srnti2 >>= 6;

  dl_common_info_ptr->modeSpecificInfo.u.fdd->defaultDPCH_OffsetValue =
    (srnti2 % 600); /* 25.331, clause 8.3.6.3 */


  RRCSET_MSG_TYPE_IE_PTR(dl_common_info_ptr->modeSpecificInfo.u.fdd,
               defaultDPCH_OffsetValuePresent);

  return SUCCESS;
}
/*============================================================================
FUNCTION: rrcllc_get_predefined_ul_dpch_info

DESCRIPTION:

      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllc_get_predefined_ul_dpch_info
(
  rrc_UL_DPCH_Info *ul_dpch_info_ptr,
  rrc_UL_DPCH_InfoPostFDD *ul_dpch_info_post_ptr,
  rrc_PreDefPhyChConfiguration *predef_phych
)  
{


  RRC_RESET_MSG_IE_PRESENT_PTR(ul_dpch_info_ptr);
  RRCSET_MSG_TYPE(ul_dpch_info_ptr->ul_DPCH_PowerControlInfo,
                T_rrc_UL_DPCH_PowerControlInfo_fdd);
  /* This value is provided as an rrc_DPCCH_PowerOffset2 type, which must be converted to the actual elem[n_index].
     * See ASN.1 definition for details.  Then, we must divide by 2 to make the value compatible with existing RRC functions. 
     */ 
  ul_dpch_info_ptr->ul_DPCH_PowerControlInfo.u.fdd->dpcch_PowerOffset =
      (2 + (ul_dpch_info_post_ptr->ul_DPCH_PowerControlInfo.dpcch_PowerOffset * 4)) / 2; 
  ul_dpch_info_ptr->ul_DPCH_PowerControlInfo.u.fdd->pc_Preamble =
    ul_dpch_info_post_ptr->ul_DPCH_PowerControlInfo.pc_Preamble;
  ul_dpch_info_ptr->ul_DPCH_PowerControlInfo.u.fdd->sRB_delay =
    ul_dpch_info_post_ptr->ul_DPCH_PowerControlInfo.sRB_delay;
  ul_dpch_info_ptr->ul_DPCH_PowerControlInfo.u.fdd->powerControlAlgorithm =
      predef_phych->ul_DPCH_InfoPredef.ul_DPCH_PowerControlInfo.u.fdd->powerControlAlgorithm;
  RRCSET_MSG_TYPE_IE_PTR(ul_dpch_info_ptr,
                 ul_DPCH_PowerControlInfoPresent);
  RRCSET_MSG_TYPE(ul_dpch_info_ptr->modeSpecificInfo,
T_rrc_UL_DPCH_Info_modeSpecificInfo_fdd);
  RRC_RESET_MSG_IE_PRESENT_PTR(ul_dpch_info_ptr->modeSpecificInfo.u.fdd);
  ul_dpch_info_ptr->modeSpecificInfo.u.fdd->scramblingCodeType =
    ul_dpch_info_post_ptr->scramblingCodeType;
  /*numberOfDPDCH has a madatory default value, rrc_UL_DPCH_InfoPostFDD doesnt have it so set to default value*/
  ul_dpch_info_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH =
              RRCLLC_DEFAULT_NUM_DPDCH_ALLOWED;
  ul_dpch_info_ptr->modeSpecificInfo.u.fdd->scramblingCode =
    ul_dpch_info_post_ptr->reducedScramblingCodeNumber;
  ul_dpch_info_ptr->modeSpecificInfo.u.fdd->spreadingFactor =
    ul_dpch_info_post_ptr->spreadingFactor;
  ul_dpch_info_ptr->modeSpecificInfo.u.fdd->tfci_Existence =
      predef_phych->ul_DPCH_InfoPredef.modeSpecificInfo.u.fdd->tfci_Existence;
  ul_dpch_info_ptr->modeSpecificInfo.u.fdd->puncturingLimit =
      predef_phych->ul_DPCH_InfoPredef.modeSpecificInfo.u.fdd->puncturingLimit;
  
  return SUCCESS;
}   
/*============================================================================
FUNCTION: rrcllc_get_predefined_dl_common_info_srb5

DESCRIPTION: This function updates the DL common info received in Handover to 
             Utran message and the SRB5 Default config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllc_get_predefined_dl_common_info_srb5
(
  rrc_DL_CommonInformation        *dl_common_info_ptr,
  rrc_DL_CommonInformationPost    *dl_common_info_post_ptr,
  rrc_DL_DPCH_InfoCommon_r4 *predef_phych,
  rrc_U_RNTI_Short *new_urnti_ptr
)  
{
  uint16     srnti2  = 0; /* S-RNTI 2 portion of the U-RNTI in the message,
                             used later to calculate the default DPCH offset
                             value in preconfigured mode */


  RRC_RESET_MSG_IE_PRESENT_PTR(dl_common_info_ptr);
  
  RRCSET_MSG_TYPE(dl_common_info_ptr->dl_DPCH_InfoCommon.cfnHandling,
              T_rrc_DL_DPCH_InfoCommon_cfnHandling_maintain);
  
  RRCSET_MSG_TYPE(dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo,
              T_rrc_DL_DPCH_InfoCommon_modeSpecificInfo_fdd);
  
  RRC_RESET_MSG_IE_PRESENT_PTR(dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd);
  
  dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->dl_DPCH_PowerControlInfo =
  dl_common_info_post_ptr->dl_DPCH_InfoCommon.dl_DPCH_PowerControlInfo;
  
  RRCSET_MSG_TYPE_IE_PTR(dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd,
              dl_DPCH_PowerControlInfoPresent);
  dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->powerOffsetPilot_pdpdch = 0; /* 25.331, clause 8.3.6.3 */
  rrc_set_predefined_po3_status(TRUE);
  rrc_predef_po3_not_needed = TRUE;  
  if(RRC_CHECK_MSG_TYPE(predef_phych->modeSpecificInfo,
              T_rrc_DL_DPCH_InfoCommon_r4_modeSpecificInfo_fdd))
    {
    dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->spreadingFactorAndPilot =
        predef_phych->modeSpecificInfo.u.fdd->spreadingFactorAndPilot;
    dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->positionFixedOrFlexible =
        predef_phych->modeSpecificInfo.u.fdd->positionFixedOrFlexible;
    dl_common_info_ptr->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->tfci_Existence =
        predef_phych->modeSpecificInfo.u.fdd->tfci_Existence;
  }
  else
  {
    return FAILURE;
  }
  RRCSET_MSG_TYPE_IE_PTR(dl_common_info_ptr,
              dl_DPCH_InfoCommonPresent);
  
  RRCSET_MSG_TYPE(dl_common_info_ptr->modeSpecificInfo,
              T_rrc_DL_CommonInformation_modeSpecificInfo_fdd);
  
  RRC_RESET_MSG_IE_PRESENT_PTR(dl_common_info_ptr->modeSpecificInfo.u.fdd);

  srnti2 = *(new_urnti_ptr->s_RNTI_2.data) << 8;
  srnti2 |= *(new_urnti_ptr->s_RNTI_2.data + 1);
  srnti2 >>= 6;

  dl_common_info_ptr->modeSpecificInfo.u.fdd->defaultDPCH_OffsetValue =
    (srnti2 % 600); /* 25.331, clause 8.3.6.3 */


  RRCSET_MSG_TYPE_IE_PTR(dl_common_info_ptr->modeSpecificInfo.u.fdd,
             defaultDPCH_OffsetValuePresent);

  return SUCCESS;
}
/*============================================================================
FUNCTION: rrcllc_get_predefined_ul_dpch_info_srb5

DESCRIPTION: This function updates the UL DPCH info received in Handover to 
             Utran message and the SRB5 Default config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllc_get_predefined_ul_dpch_info_srb5
(
  rrc_UL_DPCH_Info *ul_dpch_info_ptr,
  rrc_UL_DPCH_InfoPostFDD *ul_dpch_info_post_ptr,
  rrc_UL_DPCH_Info_r5 *predef_phych
)  
{

  RRC_RESET_MSG_IE_PRESENT_PTR(ul_dpch_info_ptr);
  RRCSET_MSG_TYPE(ul_dpch_info_ptr->ul_DPCH_PowerControlInfo,
                T_rrc_UL_DPCH_PowerControlInfo_fdd);
  
  /* This value is provided as an rrc_DPCCH_PowerOffset2 type, which must be converted to the actual elem[n_index].
     * See ASN.1 definition for details.  Then, we must divide by 2 to make the value compatible with existing RRC functions. 
     */ 
     
  ul_dpch_info_ptr->ul_DPCH_PowerControlInfo.u.fdd->dpcch_PowerOffset =
      (2 + (ul_dpch_info_post_ptr->ul_DPCH_PowerControlInfo.dpcch_PowerOffset * 4)) / 2; 
  ul_dpch_info_ptr->ul_DPCH_PowerControlInfo.u.fdd->pc_Preamble =
    ul_dpch_info_post_ptr->ul_DPCH_PowerControlInfo.pc_Preamble;
  ul_dpch_info_ptr->ul_DPCH_PowerControlInfo.u.fdd->sRB_delay =
    ul_dpch_info_post_ptr->ul_DPCH_PowerControlInfo.sRB_delay;
  if((RRC_CHECK_MSG_TYPE_IE_PTR(predef_phych,
                ul_DPCH_PowerControlInfoPresent)) && 
      (RRC_CHECK_MSG_TYPE(predef_phych->ul_DPCH_PowerControlInfo,
                T_rrc_UL_DPCH_PowerControlInfo_r5_fdd)))
  {
    ul_dpch_info_ptr->ul_DPCH_PowerControlInfo.u.fdd->powerControlAlgorithm =
      predef_phych->ul_DPCH_PowerControlInfo.u.fdd->powerControlAlgorithm;
  }
  else
  {
    WRRC_MSG0_ERROR("ul_DPCH_PowerControlInfo_present not present ");
    return FAILURE;
  }
  RRCSET_MSG_TYPE_IE_PTR(ul_dpch_info_ptr,
              ul_DPCH_PowerControlInfoPresent);
  
  RRCSET_MSG_TYPE(ul_dpch_info_ptr->modeSpecificInfo,
              T_rrc_UL_DPCH_Info_modeSpecificInfo_fdd);
  
  RRC_RESET_MSG_IE_PRESENT_PTR(ul_dpch_info_ptr->modeSpecificInfo.u.fdd);
  ul_dpch_info_ptr->modeSpecificInfo.u.fdd->scramblingCodeType =
    ul_dpch_info_post_ptr->scramblingCodeType;
  ul_dpch_info_ptr->modeSpecificInfo.u.fdd->scramblingCode =
    ul_dpch_info_post_ptr->reducedScramblingCodeNumber;
  ul_dpch_info_ptr->modeSpecificInfo.u.fdd->spreadingFactor =
    ul_dpch_info_post_ptr->spreadingFactor;
    /*numberOfDPDCH has a madatory default value, rrc_UL_DPCH_InfoPostFDD doesnt have it so set to default value*/
  ul_dpch_info_ptr->modeSpecificInfo.u.fdd->numberOfDPDCH =
              RRCLLC_DEFAULT_NUM_DPDCH_ALLOWED;
  if(RRC_CHECK_MSG_TYPE(predef_phych->modeSpecificInfo,
              T_rrc_UL_DPCH_Info_r5_modeSpecificInfo_fdd))
  {
    ul_dpch_info_ptr->modeSpecificInfo.u.fdd->tfci_Existence =
      predef_phych->modeSpecificInfo.u.fdd->tfci_Existence;
    ul_dpch_info_ptr->modeSpecificInfo.u.fdd->puncturingLimit =
      predef_phych->modeSpecificInfo.u.fdd->puncturingLimit;
  }
  
  return SUCCESS;
}

/*====================================================================
FUNCTION      set_hsscch_info_r6()

DESCRIPTION   This function sets the Channelization code required
              for HSPDSCH in L1 structure in OC.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire operation is successful,
              FAILURE otherwise

SIDE EFFECTS  None.
====================================================================*/
uecomdef_status_e_type set_hsscch_info_r6
(
  rrc_HS_SCCH_Info_r6* hsscch_info_ptr
)
{
  struct rrc_HS_SCCH_Info_r6_hS_SCCHChannelisationCodeInfo   *hsscch_list_ptr = NULL;

  uint8 cnt = 0;
  uint32 n_value = 0;
  uint32 n_index = 0;

  ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code_valid = FALSE;

  if(hsscch_info_ptr->modeSpecificInfo.t == T_rrc_HS_SCCH_Info_r6_modeSpecificInfo_tdd)
  {
    return FAILURE;
  }
  

  /* Sec Scr Code unsupported by L1 */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(hsscch_info_ptr->modeSpecificInfo.u.fdd,
               dl_ScramblingCodePresent))
  {
    if ((hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode == 0) ||
        (hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode > 15))
    {
      WRRC_MSG1_ERROR("RRCHS:Incorrect Sec Scr Code %d", 
          hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode);
      return FAILURE;
    }

    ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code_valid = TRUE;

    ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code = (uint8)
      hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode;
  }

  /* Channelization Codes always need to be a cummulative sum that network needs to specify.
  So initilize the number to 0 */


  ordered_config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code = 0;

  hsscch_list_ptr = &(hsscch_info_ptr->modeSpecificInfo.u.fdd->hS_SCCHChannelisationCodeInfo);

  n_value = hsscch_list_ptr->n;
  while ((n_value != 0) && (cnt < L1_DL_HS_SCCH_CODES_MAX))
  {
    /* Spec allows allows channelisation code 0 also but since MSM6275 will
    not support secondary scrambling code, it will collide with OVSF 0 and 1
    on SF 256 for CPICH and PCCPCH channels. */
    if ((hsscch_list_ptr->elem[n_index] > RRCLLC_MAX_SCCH_CHAN_CODE) || (hsscch_list_ptr->elem[n_index] == 0))
    {
      WRRC_MSG1_ERROR("RRCHS:Invalid Channelization code %d", hsscch_list_ptr->elem[n_index]);
      return FAILURE;
    }
    ordered_config_ptr->l1_hsdpa_info.hs_scch_info.ch_code[cnt++] = (uint8) hsscch_list_ptr->elem[n_index];
    n_value--;
    n_index++;
  }

  ordered_config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code = cnt;



  return SUCCESS;

}

/*====================================================================
FUNCTION      get_ul_dpch_pwr_ctrl_info_r6()

DESCRIPTION   This function translates the Uplink DPCH Power Control
              info common for all RL (radio links) IE into the RRC
              config database.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
uecomdef_status_e_type get_ul_dpch_pwr_ctrl_info_r6
(
 rrc_UL_DPCH_PowerControlInfo_r6_fdd *fdd_ul_pwrcntrl_info
)
{

  rrc_hsdpa_status_enum_type hsdpa_status = rrc_get_hsdpa_status();
  
    /* Set the valid bit if made it this far */
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.valid = TRUE;

    /* Get the DPCCH Power Offset (value in dB) */
    if((fdd_ul_pwrcntrl_info->dpcch_PowerOffset <= RRCLLC_UL_DPCCH_PWR_OFFSET_MAX) &&
      (fdd_ul_pwrcntrl_info->dpcch_PowerOffset >= RRCLLC_UL_DPCCH_PWR_OFFSET_MIN))
    {
      /* The value sent over the air needs to be doubled */
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.dpcch_pwr_offset =
        (int16) (fdd_ul_pwrcntrl_info->dpcch_PowerOffset * 2);
    }
    else
    {
      WRRC_MSG1_ERROR("UL DPCCH Power Offset %d is out of range",
        fdd_ul_pwrcntrl_info->dpcch_PowerOffset);
      return FAILURE;
    }

    if (RRC_CHECK_MSG_TYPE_IE_PTR(fdd_ul_pwrcntrl_info,
                  deltaACKPresent))
    {

      /* Check the value of Delta ACK */
      if (fdd_ul_pwrcntrl_info->deltaACK > RRCLLC_DELTA_ACK_MAX)
      {
        WRRC_MSG1_ERROR("RRCHS:UL Delta ACK [0..8] %d out of range",
          fdd_ul_pwrcntrl_info->deltaACK);
        return FAILURE;
      }


      if (hsdpa_status == HSDPA_ACTIVE)
      {
        /* Check if delta ack has changed */
        if (((uint8)fdd_ul_pwrcntrl_info->deltaACK) != ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack)
        {
          WRRC_MSG2_HIGH("RRCHS:New DeltaACK %d, Previous %d", (uint8)fdd_ul_pwrcntrl_info->deltaACK,
                   ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack);

          hsdpa_msg_params.msg_params_present = hsdpa_msg_params.beta_table_present = TRUE;

        }
      }

      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack = (uint8)
        fdd_ul_pwrcntrl_info->deltaACK;
      

    }
    if (RRC_CHECK_MSG_TYPE_IE_PTR(fdd_ul_pwrcntrl_info,
                  deltaNACKPresent))
    {
      /* Check the value of Delta NACK */
      if (fdd_ul_pwrcntrl_info->deltaACK > RRCLLC_DELTA_NACK_MAX)
      {
        WRRC_MSG1_ERROR("RRCHS:UL Delta ACK [0..8] %d out of range",
          fdd_ul_pwrcntrl_info->deltaNACK);
        return FAILURE;
      }




      /* Check if delta nack has changed */
      if (hsdpa_status == HSDPA_ACTIVE)
      {
        /* Check if delta nack has changed */
        if (((uint8)fdd_ul_pwrcntrl_info->deltaNACK) != ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack)
        {
          WRRC_MSG2_HIGH("RRCHS:New DeltaNACK %d, Previous %d", (uint8)fdd_ul_pwrcntrl_info->deltaNACK,
                   ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack);
          
          hsdpa_msg_params.msg_params_present = hsdpa_msg_params.beta_table_present = TRUE;
        }
      }
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack = (uint8)
      fdd_ul_pwrcntrl_info->deltaNACK;
      

    }
    if (RRC_CHECK_MSG_TYPE_IE_PTR(fdd_ul_pwrcntrl_info,
                  ack_NACK_repetition_factorPresent))
    {

      /* Check the value of ACK/NACK Repition Factor */
      if (!((fdd_ul_pwrcntrl_info->ack_NACK_repetition_factor >= RRCLLC_DELTA_ACK_NACK_REPITITION_FACTOR_MIN) &&
        (fdd_ul_pwrcntrl_info->ack_NACK_repetition_factor <= RRCLLC_DELTA_ACK_NACK_REPITITION_FACTOR_MAX)))
      {
        WRRC_MSG1_ERROR("RRCHS:UL ACK/NACK Rep Factor [1..4] %d out of range",
          fdd_ul_pwrcntrl_info->ack_NACK_repetition_factor);
        return FAILURE;
      }


      if (hsdpa_status == HSDPA_ACTIVE)
      {
        /* Check if delta ack has changed */
        if ((fdd_ul_pwrcntrl_info->ack_NACK_repetition_factor) != ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.ack_nack_rep_factor)
        {
          WRRC_MSG2_HIGH("RRCHS:DPCCH Info changed New ACKNACKRepFactor %d, Previous %d", (uint8)fdd_ul_pwrcntrl_info->ack_NACK_repetition_factor,
            ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.ack_nack_rep_factor);
          
          ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.ack_nack_rep_factor = (uint8)
            fdd_ul_pwrcntrl_info->ack_NACK_repetition_factor;
          
          hsdpa_msg_params.msg_params_present = hsdpa_msg_params.hs_dpcch_info_present = TRUE;
        }
      }
      else
      {
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.ack_nack_rep_factor = (uint8)
         fdd_ul_pwrcntrl_info->ack_NACK_repetition_factor;
        
        hsdpa_msg_params.msg_params_present = hsdpa_msg_params.hs_dpcch_info_present = TRUE;
        
      }
      
    }
    /* Get the PC Preamble */

    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pcp_len
      = (uint8)fdd_ul_pwrcntrl_info->pc_Preamble;

    /* Get SRB_Delay */
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.srb_delay
      = (uint8)fdd_ul_pwrcntrl_info->sRB_delay;

    /* Get the Power Control Algorithm */
    if(RRC_CHECK_MSG_TYPE(fdd_ul_pwrcntrl_info->powerControlAlgorithm,
                T_rrc_PowerControlAlgorithm_algorithm1))
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pca =
        L1_UL_PCA_ONE;
      if(fdd_ul_pwrcntrl_info->powerControlAlgorithm.u.algorithm1 == 0)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.tpc_step_size =
          L1_UL_TPC_STEP_ONE;
      }
      else if(fdd_ul_pwrcntrl_info->powerControlAlgorithm.u.algorithm1 == 1)
      {
        ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.tpc_step_size =
          L1_UL_TPC_STEP_TWO;
      }
      else
      {
        WRRC_MSG1_ERROR("TPC Step size %d is out of range",
          fdd_ul_pwrcntrl_info->powerControlAlgorithm.u.algorithm1);
        return FAILURE;
      } /* end if-else check for Algorithm 1 and TPC step size */
    }
    else if (RRC_CHECK_MSG_TYPE(fdd_ul_pwrcntrl_info->powerControlAlgorithm,
                T_rrc_PowerControlAlgorithm_algorithm2))
    {
      ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.dpch_pwr_ctrl_info.pca =
        L1_UL_PCA_TWO;
    }
    else
    {
      WRRC_MSG0_ERROR("Invalid UL Power Control Algorithm specified");
      return FAILURE;
    } /* end if-else check for UL power control algorithm check */

    /* Value 1 indicates that preamble and postamble are used on the HS-DPCCH  
        RRCEUL: Ignore received HARQ Preamble: %d. Not supported yet.*/

  return SUCCESS;
} /* end get_ul_dpch_pwr_ctrl_info_r6() */


/*====================================================================
FUNCTION      get_ul_dpch_info_r6()

DESCRIPTION   This function translates the Uplink DPCH info IE into the RRC config database.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
uecomdef_status_e_type get_ul_dpch_info_r6
(
  rrc_UL_DPCH_Info_r6 *ie_ptr
)
{
  MSG_MED("Get UL DPCH Info",0,0,0);

  /* Get the UL DPCH power control information if present */
  if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
              ul_DPCH_PowerControlInfoPresent))
  {
    if(RRC_CHECK_MSG_TYPE(ie_ptr->ul_DPCH_PowerControlInfo,
              T_rrc_UL_DPCH_PowerControlInfo_r6_fdd))
    {
      if(get_ul_dpch_pwr_ctrl_info_r6(ie_ptr->ul_DPCH_PowerControlInfo.u.fdd) == FAILURE)
      {
        return FAILURE;
      }
    }
    else /* only TDD */
    {
      return FAILURE;
    }
  }

  /* Make sure of FDD and get the right parameters */
  if(RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
              T_rrc_UL_DPCH_Info_r6_modeSpecificInfo_fdd))
  {
    if(rrcllcpcie_update_uldpch_mode_specific_info(ie_ptr->modeSpecificInfo.u.fdd)
        == FAILURE)
    {
      return FAILURE;
    }
  } /* end FDD if */
  else
  {
    return FAILURE;
  }

  /* If made it here, all is well */
  /* Indicate that Uplink L1 needs to be reconfigured */
  ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
  return SUCCESS;
} /* end get_ul_dpch_info_r5() */

/*============================================================================
FUNCTION: rrcllcpcie_process_ul_dpch_info_r6()

DESCRIPTION:
  This function updates IE "ul dpch info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_ul_dpch_info_r6
(
  OSS_UINT32 ul_dpch_info_present,
  rrc_UL_DPCH_Info_r6 *ul_dpch_info_ptr,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if (ul_dpch_info_present)
  {
    if (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
    {
      if(get_ul_dpch_info_r6(ul_dpch_info_ptr) == FAILURE)
      {
        return FAILURE;
      }
    }
    else
    {
      WRRC_MSG0_HIGH("RRCEUL: Ignoring rcvd ulDpchInfo when state-indicator is NOT set to DCH");
    }
  }
  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_validate_transition_to_cell_dch()

DESCRIPTION:
  This function validates whether DL common Info and DL per RL info is present or not,
  when UE is transitioned from non-cell DCH to cell-DCH in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_validate_transition_to_cell_dch
(
  OSS_UINT32 ul_dpch_info_present,
  OSS_UINT32 dl_common_info_present,
  OSS_UINT32 dl_per_rl_info_list_present,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((rcvd_state_indicator == rrc_RRC_StateIndicator_cell_DCH) &&
     (current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH) &&
     (!((dl_common_info_present) && (dl_per_rl_info_list_present) && 
        (ul_dpch_info_present))))
  {
    ERR("Incomplete Physical ChInfo for DCH. dlCommonInfo: %d, dlPerRl_info: %d, ulDpchInfo: %d",
      (dl_common_info_present != 0), (dl_per_rl_info_list_present !=0), 
      (ul_dpch_info_present != 0));
    return FAILURE;
  }

  return(SUCCESS);
}

/*====================================================================
FUNCTION      get_dl_fdpch_common_info_r6()

DESCRIPTION   This function translates the Downlink FDPCH info common for
              all RL (radio links) IE into the RRC config database.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
static uecomdef_status_e_type get_dl_fdpch_common_info_r6
(
  /* pointer to the IE */
  rrc_DL_FDPCH_InfoCommon_r6 *ie_ptr,

  /* pointer to the desired config page */
  l1_dl_dpch_common_info_struct_type *common_info

)
{
  rrc_state_e_type rrc_state;
  
  /* initialize the optional field bit mask */
  common_info->opt_parm_present_mask = 0;
  
  /* TBD: rrc_mac_d_HFN_initial_value_present to be used LATER */
  
  /* Get the timing indication maintenance elem[n_index]. */
  switch (RRC_GET_MSG_TYPE(ie_ptr->cfnHandling))
  {
  case  T_rrc_DL_FDPCH_InfoCommon_r6_cfnHandling_initialise:
    {

      /* As per section 8.6.6.28.a, if NW indicates timing init indication without 
       * HHO and FDPCH, UE behavior is unspecified.  So reject msg. 
       */
      if (!ordered_config_ptr->is_hho) 
      {
        WRRC_MSG0_ERROR("FDPCH Timing init indication without HHO: invalid");
        return (FAILURE);
      }      
      common_info->timing_ind = L1_TIMING_IND_INIT;
      
      /* From Spec, NW should include mac-d-hfn only when TM bearers are
      present. */
    }
    
    break;
    
  case T_rrc_DL_FDPCH_InfoCommon_r6_cfnHandling_maintain:
    rrc_state = rrc_get_state();
    if(rrc_state != RRC_STATE_CELL_DCH &&
      ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      WRRC_MSG0_HIGH("Ignoring TM HHO on state transition");
      common_info->timing_ind = L1_TIMING_IND_INIT;
    }
    else
    {
      common_info->timing_ind = L1_TIMING_IND_MAINTAIN;
      /* timingMaintainedSynchInd  IE is valid only 
       * if the IE "Timing Indication" is set to "Maintained". 
       */
      ordered_config_ptr->tm_sync_ind_applicable = 
                           ordered_config_ptr->tm_sync_ind_applicable |
                                              RRCLLC_TIMING_MAINTAIN_IND_PRESENT_OTA;
  
      common_info->skip_sync_a_procedure = FALSE;
      /* timingMaintainedSynchInd  IE is valid only 
       * if the IE "Timing Indication" is set to "Maintained". & the
       * frequency info is present in OTA 
       */
       
      if((ordered_config_ptr->tm_sync_ind_applicable & 
                       RRCLLC_FREQ_INFO_PRESENT_IN_OTA) &&
         (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->cfnHandling.u.maintain,
                    timingmaintainedsynchindPresent)))
      {
        common_info->skip_sync_a_procedure = TRUE;
        WRRC_MSG0_HIGH("skip_sync_a_procedure received in msg for FDPCH ");
      }

    }
    break;
    
  default:
    WRRC_MSG1_ERROR("Bad CFN handling choice %u", RRC_GET_MSG_TYPE(ie_ptr->cfnHandling));
    return FAILURE;
  }
  
  /* Get the Power control info if present */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
              dl_FDPCH_PowerControlInfoPresent))
  {
    if(RRC_CHECK_MSG_TYPE(ie_ptr->dl_FDPCH_PowerControlInfo.modeSpecificInfo,
                T_rrc_DL_DPCH_PowerControlInfo_modeSpecificInfo_fdd))
    {
      /* set the DPC elem[n_index]. */
      switch (ie_ptr->dl_FDPCH_PowerControlInfo.modeSpecificInfo.u.fdd->dpc_Mode)
      {
      case rrc_DPC_Mode_singleTPC:
        common_info->dpc_info = L1_DPC_MODE_SINGLE_TPC;
        break;
        
      case rrc_DPC_Mode_tpcTripletInSoft:
        common_info->dpc_info = L1_DPC_MODE_TPC_TRIPLE_IN_SOFT;
        break;
        
      default:
        WRRC_MSG1_ERROR("Bad DPC Mode %u",
          ie_ptr->dl_FDPCH_PowerControlInfo.modeSpecificInfo.u.fdd->dpc_Mode
          );
        return FAILURE;
      }
      
      /* Indicate the DPCH Pwr Ctrl presence in the bitmask */
      common_info->opt_parm_present_mask |=
        DL_DPCH_COMMON_INFO_DPCH_PWR_CTRL_INFO_PRESENT;
    }
    else
    {
    /* bad news.  we're in the FDD portion of the DL Common info IE
    but the DPCH power control info IE hasn't selected FDD, instead
      it selected TDD */
      return FAILURE;
    }
  }
  
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
              dl_FDPCH_TPCcommandErrorRatePresent))
  {
    common_info->tpc_cmd_err_rate_target =  ie_ptr->dl_FDPCH_TPCcommandErrorRate;
  }
  else
  {
    WRRC_MSG0_ERROR("FDPCH_TPCcommandErrorRate shld have been present");
  }  
  /* if we made it here all is well */
  return SUCCESS;
} /* get_dl_fdpch_common_info_r6() */

/*====================================================================
FUNCTION      get_dl_dpch_common_info_r6()

DESCRIPTION   This function translates the Downlink DPCH info common for
              all RL (radio links) IE into the RRC config database.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
uecomdef_status_e_type get_dl_dpch_common_info_r6
(
  /* pointer to the IE */
  rrc_DL_DPCH_InfoCommon_r6 *ie_ptr,

  /* pointer to the desired config page */
  l1_dl_dpch_common_info_struct_type *common_info,

  /* pointer to the CCTrCH info structure */
  l1_dl_cctrch_info_struct_type *cctrch_info,

  l1_dl_ctfc_info_struct_type *l1_dl_ctfc_info
)
{
  rrc_state_e_type rrc_state;

  /* initialize the optional field bit mask */
  common_info->opt_parm_present_mask = 0;

  /* TBD: rrc_mac_d_HFN_initial_value_present to be used LATER */

  /* Get the timing indication maintenance elem[n_index]. */
  switch (RRC_GET_MSG_TYPE(ie_ptr->cfnHandling))
  {
    case  T_rrc_DL_DPCH_InfoCommon_r6_cfnHandling_initialise:
    {
      uint32 mac_d_hfn_l = RRCSMC_INVALID_HFN_VALUE;

      /* As per section 8.6.6.28, if NW indicates timing init indication without 
       * HHO, UE behavior is unspecified.  So reject msg
       */
      if (!ordered_config_ptr->is_hho) 
      {
        WRRC_MSG0_ERROR("Timing init indication without HHO: invalid");
        return (FAILURE);
      }

      common_info->timing_ind = L1_TIMING_IND_INIT;

       /* From Spec, NW should include mac-d-hfn only when TM bearers are
            present. */
      if(TRUE == rrcsmc_tm_ciph_active())
      {
        rrc_state = rrc_get_state();
        if( (rrc_state == RRC_STATE_CELL_FACH) &&
           (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
        {
          /* It will be called in the procedure itself */
        }
        else
        {
          if (FAILURE == rrcrb_get_mac_d_hfn(
              (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                        mac_d_HFN_initial_valuePresent)), 
              &ie_ptr->mac_d_HFN_initial_value, &mac_d_hfn_l))
          {
            return FAILURE;
          }
          (void)rrcsmc_process_cipher_config_for_hho(mac_d_hfn_l);
        }
      }
    }

    break;

    case T_rrc_DL_DPCH_InfoCommon_r6_cfnHandling_maintain:
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_CELL_DCH &&
          ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
      {
        WRRC_MSG0_HIGH("Ignoring TM HHO on state transition");
        common_info->timing_ind = L1_TIMING_IND_INIT;
      }
      else
      {
        common_info->timing_ind = L1_TIMING_IND_MAINTAIN;
        /* timingMaintainedSynchInd  IE is valid only 
         * if the IE "Timing Indication" is set to "Maintained". 
         */
        ordered_config_ptr->tm_sync_ind_applicable = 
                             ordered_config_ptr->tm_sync_ind_applicable |
                                                RRCLLC_TIMING_MAINTAIN_IND_PRESENT_OTA;

        common_info->skip_sync_a_procedure = FALSE;
        /* timingMaintainedSynchInd  IE is valid only 
         * if the IE "Timing Indication" is set to "Maintained". & the
         * frequency info is present in OTA 
         */
        if((ordered_config_ptr->tm_sync_ind_applicable & 
                         RRCLLC_FREQ_INFO_PRESENT_IN_OTA)  &&
           (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->cfnHandling.u.maintain,
                          timingmaintainedsynchindPresent)))
        {
          common_info->skip_sync_a_procedure = TRUE;
          WRRC_MSG0_HIGH("skip_sync_a_procedure received in msg");
        }

      }
      break;

    default:
      WRRC_MSG1_ERROR("Bad CFN handling choice %u", RRC_GET_MSG_TYPE(ie_ptr->cfnHandling));
      return FAILURE;
  }

  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                T_rrc_DL_DPCH_InfoCommon_r6_modeSpecificInfo_fdd))
  {
    /* Get the TFCI existence */
    common_info->tfci_exists =
      (boolean) ie_ptr->modeSpecificInfo.u.fdd->tfci_Existence;

    /* and update the TFCI existence in the CTFC info as well */
    l1_dl_ctfc_info->tfci_existence = common_info->tfci_exists;

    /* Get the spreading factor and number of pilot bits in the DPCCH */
    switch (RRC_GET_MSG_TYPE(ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot))
    {
      case T_rrc_SF512_AndPilot_sfd4:
        common_info->sf = L1_SF_4;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd8:
        common_info->sf = L1_SF_8;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd16:
        common_info->sf = L1_SF_16;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd32:
        common_info->sf = L1_SF_32;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd64:
        common_info->sf = L1_SF_64;
        common_info->num_pilot_bits = 0;
        break;

      case T_rrc_SF512_AndPilot_sfd128:
        common_info->sf = L1_SF_128;
        switch (ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot.u.sfd128)
        {
          case rrc_PilotBits128_pb4:
            common_info->num_pilot_bits = 4;
            break;

          case rrc_PilotBits128_pb8:
            common_info->num_pilot_bits = 8;
            break;

          default:
            WRRC_MSG1_ERROR("Bad pilot bits enum %u for SF128",
              ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot.u.sfd128);
            return FAILURE;
        }
        break;

      case T_rrc_SF512_AndPilot_sfd256:
        common_info->sf = L1_SF_256;
        switch (ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot.u.sfd256)
        {
          case rrc_PilotBits256_pb2:
            common_info->num_pilot_bits = 2;
            break;

          case rrc_PilotBits256_pb4:
            common_info->num_pilot_bits = 4;
            break;

          case rrc_PilotBits256_pb8:
            common_info->num_pilot_bits = 8;
            break;

          default:
            WRRC_MSG1_ERROR("Bad pilot bits enum %u for SF256",
              ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot.u.sfd256);
            return FAILURE;
        }
        break;

      case T_rrc_SF512_AndPilot_sfd512:
        common_info->sf = L1_SF_512;
        common_info->num_pilot_bits = 0;
        break;

      default:
        WRRC_MSG1_ERROR("Bad spreading factor enum %u",
          RRC_GET_MSG_TYPE(ie_ptr->modeSpecificInfo.u.fdd->spreadingFactorAndPilot));
        return FAILURE;
    }

    /* Get the Rate Matching type parameter. */
    switch (ie_ptr->modeSpecificInfo.u.fdd->positionFixedOrFlexible)
    {
      case rrc_PositionFixedOrFlexible_fixed:
        cctrch_info->rm_method = L1_DL_RM_FIXED_POS;
        break;

      case rrc_PositionFixedOrFlexible_flexible:
        cctrch_info->rm_method = L1_DL_RM_FLEX_POS;
        break;

      default:
        WRRC_MSG1_ERROR("Bad rate matching method %u",
                  ie_ptr->modeSpecificInfo.u.fdd->positionFixedOrFlexible);
        return FAILURE;
    }

    /* Get the Power control info if present */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                  dl_DPCH_PowerControlInfoPresent))
    {
      if(RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo.u.fdd->dl_DPCH_PowerControlInfo.modeSpecificInfo,
                  T_rrc_DL_DPCH_PowerControlInfo_modeSpecificInfo_fdd))
      {
        /* set the DPC elem[n_index]. */
        switch (ie_ptr->modeSpecificInfo.u.fdd->
                dl_DPCH_PowerControlInfo.modeSpecificInfo.u.fdd->dpc_Mode)
        {
          case rrc_DPC_Mode_singleTPC:
            common_info->dpc_info = L1_DPC_MODE_SINGLE_TPC;
            break;

          case rrc_DPC_Mode_tpcTripletInSoft:
            common_info->dpc_info = L1_DPC_MODE_TPC_TRIPLE_IN_SOFT;
            break;

          default:
            WRRC_MSG1_ERROR("Bad DPC Mode %u",
                      ie_ptr->modeSpecificInfo.u.fdd->
                      dl_DPCH_PowerControlInfo.modeSpecificInfo.u.fdd->dpc_Mode);
            return FAILURE;
        }

        /* Indicate the DPCH Pwr Ctrl presence in the bitmask */
        common_info->opt_parm_present_mask |=
          DL_DPCH_COMMON_INFO_DPCH_PWR_CTRL_INFO_PRESENT;
      }
      else
      {
        /* bad news.  we're in the FDD portion of the DL Common info IE
           but the DPCH power control info IE hasn't selected FDD, instead
           it selected TDD */
        return FAILURE;
      }
    }

    /* Set PO3 power offset between DPDCH and DPCCH in downlink
     * This is mandatory present in Downlink Common Info
     */
    common_info->po3 = (uint8)ie_ptr->modeSpecificInfo.u.fdd->powerOffsetPilot_pdpdch;
    if (FALSE == rrc_predef_po3_not_needed)
    {
    rrc_set_predefined_po3_status(FALSE);
    }

    /* Get the rate matching restriction information if present */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->modeSpecificInfo.u.fdd,
                   dl_rate_matching_restrictionPresent))
    {
      if(get_dl_rm_restriction_info(
           &ie_ptr->modeSpecificInfo.u.fdd->dl_rate_matching_restriction,
           &ordered_config_ptr->rm_restrict)
         == FAILURE)
      {
        return FAILURE;
      }
    }
  } /* end DPCH FDD chsoen */
  else
  {
    /* we don't support TDD, return FALSE indicating an error */
    return FAILURE;
  }
#ifdef FEATURE_WCDMA_CPC_DTX
  if(rrcllcpcie_calculate_dpcch_slot_format() == 4)
  {
    WRRC_MSG0_ERROR("RRCCPC:Slot format#4 config not valid for DL-DPCH");
    return FAILURE;
  }
#endif
  /* if we made it here all is well */
  return SUCCESS;
} /* get_dl_dpch_common_info_r6() */

/*====================================================================
FUNCTION        get_dl_info_common_for_all_rl_r6()

DESCRIPTION     This function translates the Downlink information common
                for all radio links IE into the RRC config database.

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
uecomdef_status_e_type get_dl_info_common_for_all_rl_r6
(
  /* Pointer to the DL CommonInformation IE */
  rrc_DL_CommonInformation_r6 *ie_ptr,

  /* Pointer to the desirec DL PhyChan common information structure */
  l1_dl_common_info_struct_type *dl_common,

  /* Pointer to the DL CCTRCH parameters structure */
  l1_dl_cctrch_info_struct_type *l1_dl_cctrch_parms,

  /* Pointer to the DL CTFC parameters structure */
  l1_dl_ctfc_info_struct_type *l1_dl_ctfc_info
)
{
  MSG_MED("Get DL Info Common for all RL",0,0,0);

  /* initialize the optional field bit mask */
  /* Don't reset DOFF bitmask in DCH state.*/
  dl_common->opt_parm_presence_bitmask = 
      dl_common->opt_parm_presence_bitmask & DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
  /* Check if HS Reset is indicated */
  /* TBD Why only one value in HSRESET is specified */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                mac_hsResetIndicatorPresent))
  {
    /* Set it in MAC params */
    ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = TRUE;
    hsdpa_msg_params.msg_params_present = TRUE;
  }
  dl_common->post_verification_valid = FALSE;
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                 postVerificationPeriodPresent))
  {
    /* Set it in MAC params */
    dl_common->post_verification_valid = TRUE;
  }

  /* Get the info common for all DL DPCH if present */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                dl_dpchInfoCommonPresent))
  {
    if (RRC_CHECK_MSG_TYPE(ie_ptr->dl_dpchInfoCommon,
                T_rrc_DL_CommonInformation_r6_dl_dpchInfoCommon_dl_DPCH_InfoCommon))
    {
      if(get_dl_dpch_common_info_r6(ie_ptr->dl_dpchInfoCommon.u.dl_DPCH_InfoCommon,
                                 &dl_common->dpch_common,
                                 l1_dl_cctrch_parms,
                                 l1_dl_ctfc_info
                                ) == FAILURE
        )
      {
        return FAILURE;
      }
      ordered_config_ptr->l1_dl_chan_parms.use_fdpch = FALSE;
    }
    else /* rrc_dl_FDPCH_InfoCommon_chosen */
    {
      if(get_dl_fdpch_common_info_r6(ie_ptr->dl_dpchInfoCommon.u.dl_FDPCH_InfoCommon,
        &dl_common->dpch_common
        ) == FAILURE)
      {
        return FAILURE;
      }
      else
      {
        ordered_config_ptr->l1_dl_chan_parms.use_fdpch = TRUE;
      }
    }
  } /* end if dl dpch common info present */

  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                T_rrc_DL_CommonInformation_r6_modeSpecificInfo_fdd))
  {
    if(rrcllcpcie_dl_common_mode_specific_info(
        (rrc_dlcommon_modespecific_info *)ie_ptr->modeSpecificInfo.u.fdd, dl_common)
        == FAILURE)
    {
      return FAILURE;
    }
  } /* end if common FDD */
  else
  {
    /* FDD not selected.  Error as TDD not supported */
    return FAILURE;
  }
  /* Indicate that Downlink L1 needs to be reconfigured */
  ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
 /* Although no new parameters for MAC have been received, MAC
  * still needs to be reconfigured so as to get the new CCTrCH
  * ID whenever Downlink L1 is reconfigured. This is due to the
  * interface requirements.
  */
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
  return SUCCESS;
} /* get_dl_info_common_for_all_rl_r6() */


/*============================================================================
FUNCTION: rrcllcpcie_process_dl_common_info_r6()

DESCRIPTION:
  This function updates IE "dl common info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_dl_common_info_r6
(
  OSS_UINT32 dl_common_info_present,
  rrc_DL_CommonInformation_r6 *dl_common_info_ptr,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  /* Get the DL information for all Radio Links */
  if (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
  {
  /* Initialize the L1 bitmask for the parameters in the "Downlink
  * information for all radio links" IE.  Since the IE is optional,
  * we want to make sure we don't signal L1 erroneously that we have
  * received information when we haven't.
    */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);
    
    if (dl_common_info_present)
    {
      if(get_dl_info_common_for_all_rl_r6(dl_common_info_ptr,
        &ordered_config_ptr->l1_dl_chan_parms.dl_common,
        &ordered_config_ptr->l1_dl_cctrch_parms,
        &ordered_config_ptr->l1_dl_ctfc_parms
        )
        == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
    
  } /* If next state is Cell_DCH */
  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
    &ordered_config_ptr->dl_ctfc,
    &ordered_config_ptr->rm_restrict,
    &ordered_config_ptr->l1_dl_ctfc_parms
    );
   
  return(SUCCESS);
}

/*====================================================================
FUNCTION      get_dl_fdpch_info_for_each_rl_r6()

FILE NAME     This function gets the DL FDPCH info for each RL

DESCRIPTION   This function translates the Downlink FDPCH info for each
              RL IE to the RRC config database.  Note that it is assumed
              that a higher level routine is doing the translation from
              the linked list present in the ASN.1 decoder output to
              the array present in the RRC config database.  The radio
              link index is passed into this function and must be
              generated by that higher level routine.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if everything is ok, FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all of the parameters
              that are present in the IE.  For those parameters not
              present the values currently existing are untouched.  For
              each optional parameter that is present the corresponding
              bit in the optional parameters presence bitmask is set.
====================================================================*/
static uecomdef_status_e_type get_dl_fdpch_info_for_each_rl_r6
(
 /* pointer to the IE */
 rrc_DL_FDPCH_InfoPerRL_r6 *ie_ptr,
 
 /* pointer to the desired DL PhyChan parameter structure */
 l1_dl_phychan_db_struct_type *dl_phychan,
 
 /* radio link index */
 uint8 rl_idx,
 
 /* are we setting up a new radio link? */
 boolean is_new_rl
 )
{
  l1_dl_info_per_rl_struct_type *rl_info;
  
  uint16 new_tau_dpch;
  
  if (rl_idx < UE_MAX_RL)
  {
    rl_info = &dl_phychan->dl_per_rl[rl_idx];
  }
  else
  {
    /* rl_idx too large for supported number of radio links */
    WRRC_MSG0_HIGH("rl_idx out of range");
    return FAILURE;
  }
  
  /* initialize the optional field bit mask */
  if(is_new_rl)
  {
    rl_info->dpch_per_rl.opt_parms_present_mask = 0;
  }

  rl_info->dpch_per_rl.efdpch_slot_format = 0;
  
  /* Get the DPCH frame offset (TauDPCH) */
  new_tau_dpch = (uint16)ie_ptr->fdpch_FrameOffset;
  
  /* This validation should be done by the ASN.1 encoder on the
  * network side, but better not to make any assumptions here.
  */
  if(new_tau_dpch > 149)
  {
    WRRC_MSG1_HIGH("Invalid Tau_DPCH: %s", new_tau_dpch);
    return FAILURE;
  }
  
  /* An existing radio link cannot have its TauDPCH changed by more
  * than 1.
  */
  if(!is_new_rl &&
    ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind != L1_TIMING_IND_INIT &&
    ABS((new_tau_dpch - rl_info->dpch_per_rl.frame_offset)) > 1 &&
    ABS((new_tau_dpch - rl_info->dpch_per_rl.frame_offset)) != 149)
  {
    WRRC_MSG2_HIGH("Tau_DPCH difference > 1: %d (old) %d (new)",
      rl_info->dpch_per_rl.frame_offset, new_tau_dpch);
    return FAILURE;
  }
  rl_info->dpch_per_rl.frame_offset = new_tau_dpch;
  
  /* Get the CPICH usage for channel estimation */
  switch (ie_ptr->pCPICH_UsageForChannelEst)
  {
  case rrc_PCPICH_UsageForChannelEst_mayBeUsed:
    rl_info->dpch_per_rl.use_pri_cpich = L1_USE_PRI_CPICH;
    break;
    
  case rrc_PCPICH_UsageForChannelEst_shallNotBeUsed:
    rl_info->dpch_per_rl.use_pri_cpich = L1_DO_NOT_USE_PRI_CPICH;
    break;
    
  default:
    /* bad enum value, return FALSE immediately */
    WRRC_MSG0_HIGH("Bad CPICH usage enum");
    return FAILURE;
  }
  
  /* Get the TPC Combination index */
  rl_info->dpch_per_rl.tpc_idx =
    (uint8) ie_ptr->tpc_CombinationIndex;
  
  /* Get the secondary CPICH information */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
              secondaryCPICH_InfoPresent))
  {
    /* set the secondary CPICH channelisation code */
    rl_info->dpch_per_rl.sec_cpich_ch_code =
      (uint16) ie_ptr->secondaryCPICH_Info.channelisationCode;
    
    if (RRC_CHECK_MSG_TYPE_IE(ie_ptr->secondaryCPICH_Info,
              secondaryDL_ScramblingCodePresent))
    {
      /* set the secondary CPICH secondary scrambling code */
      rl_info->dpch_per_rl.sec_cpich_sec_scr_code =
        (uint16) ie_ptr->secondaryCPICH_Info.secondaryDL_ScramblingCode;
      
      rl_info->dpch_per_rl.opt_parms_present_mask |=
        DL_DPCH_INFO_PER_RL_SEC_CPICH_SEC_SCR_CODE_PRESENT;
    }
    
    /* mark the secondary CPICH information as present */
    rl_info->dpch_per_rl.opt_parms_present_mask |=
      DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT;
  }
   /* secondary cpich info is not present. It might have been present
  for the same radiolink before. Make sure that L1 gets
  correct bit masks */
  else
  {
    if (rl_info->dpch_per_rl.opt_parms_present_mask &
      DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT)
    {
      WRRC_MSG1_HIGH("Sec CPICH was present before rl_id:%d",
               rl_idx);
  
      /* mark the secondary CPICH information as present */
      rl_info->dpch_per_rl.opt_parms_present_mask &=
        ~DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT;
    }
  }

  /* Get all of the DPCH code channel list information */
  /* Initialize the optional parameters for code channel */
  if(is_new_rl)
  {
    rl_info->dpch_per_rl.dl_chan_code[0].opt_parm_present_mask = 0;
  }
  rl_info->dpch_per_rl.dl_chan_code[0].code_number = (uint16) ie_ptr->dl_ChannelisationCode;
  
  /* Get the secondary scrambling code if present */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
              secondaryScramblingCodePresent))
  {
    rl_info->dpch_per_rl.dl_chan_code[0].sec_scr_code =
      (uint16) ie_ptr->secondaryScramblingCode;
    
    rl_info->dpch_per_rl.dl_chan_code[0].opt_parm_present_mask |=
      DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT;
  }
  /* Get the secondary scrambling code if present */
  else
  {
    if (rl_info->dpch_per_rl.dl_chan_code[0].opt_parm_present_mask &
      DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT)
    {
      WRRC_MSG1_HIGH("Sec SCR was present before %d",
        rl_info->dpch_per_rl.dl_chan_code[0].sec_scr_code);
    }
    rl_info->dpch_per_rl.dl_chan_code[0].opt_parm_present_mask &=
      ~DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT;
  }
  
  /* set the number of DPCH code channels used for this radio link */
  rl_info->dpch_per_rl.num_dpch = 1;
  
  /* everything went ok */
  return SUCCESS;
} /* get_dl_dpch_info_for_each_rl_r6() */

/*====================================================================
FUNCTION      get_dl_dpch_info_for_each_rl_r6()

FILE NAME     This function gets the DL DPCH info for each RL

DESCRIPTION   This function translates the Downlink DPCH info for each
              RL IE to the RRC config database.  Note that it is assumed
              that a higher level routine is doing the translation from
              the linked list present in the ASN.1 decoder output to
              the array present in the RRC config database.  The radio
              link index is passed into this function and must be
              generated by that higher level routine.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if everything is ok, FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all of the parameters
              that are present in the IE.  For those parameters not
              present the values currently existing are untouched.  For
              each optional parameter that is present the corresponding
              bit in the optional parameters presence bitmask is set.
====================================================================*/
static uecomdef_status_e_type get_dl_dpch_info_for_each_rl_r6
(
  /* pointer to the IE */
  rrc_DL_DPCH_InfoPerRL_r6 *ie_ptr,

  /* pointer to the desired DL PhyChan parameter structure */
  l1_dl_phychan_db_struct_type *dl_phychan,

  /* radio link index */
  uint8 rl_idx,

  /* are we setting up a new radio link? */
  boolean is_new_rl
)
{
  l1_dl_info_per_rl_struct_type *rl_info;

  rrc_DL_ChannelisationCodeList *code_list_ptr;
  uint16 code_ch;
  uint16 new_tau_dpch;
  uint32 n_value = 0;
  uint32 n_index = 0;

  rrc_SF512_AndCodeNumber sf_choice;

  if (RRC_CHECK_COMMON_MSG_TYPE_PTR(ie_ptr, 
              rrc_DL_DPCH_InfoPerRL_r6_fdd))
  {
    if (rl_idx < UE_MAX_RL)
    {
      rl_info = &dl_phychan->dl_per_rl[rl_idx];
    }
    else
    {
      /* rl_idx too large for supported number of radio links */
      WRRC_MSG0_HIGH("rl_idx out of range");
      return FAILURE;
    }

    /* initialize the optional field bit mask */
    if(is_new_rl)
    {
      rl_info->dpch_per_rl.opt_parms_present_mask = 0;
    }

    /* Get the DPCH frame offset (TauDPCH) */
    new_tau_dpch = (uint16)ie_ptr->u.fdd->dpch_FrameOffset;

    /* This validation should be done by the ASN.1 encoder on the
     * network side, but better not to make any assumptions here.
     */
    if(new_tau_dpch > 149)
    {
      WRRC_MSG1_HIGH("Invalid Tau_DPCH: %s", new_tau_dpch);
      return FAILURE;
    }

    /* An existing radio link cannot have its TauDPCH changed by more
     * than 1.
     */
    if(!is_new_rl &&
       ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind != L1_TIMING_IND_INIT &&
        ABS((new_tau_dpch - rl_info->dpch_per_rl.frame_offset)) > 1 &&
        ABS((new_tau_dpch - rl_info->dpch_per_rl.frame_offset)) != 149)
    {
      WRRC_MSG2_HIGH("Tau_DPCH difference > 1: %d (old) %d (new)",
          rl_info->dpch_per_rl.frame_offset, new_tau_dpch);
      return FAILURE;
    }
    rl_info->dpch_per_rl.frame_offset = new_tau_dpch;

    /* Get the CPICH usage for channel estimation */
    switch (ie_ptr->u.fdd->pCPICH_UsageForChannelEst)
    {
      case rrc_PCPICH_UsageForChannelEst_mayBeUsed:
        rl_info->dpch_per_rl.use_pri_cpich = L1_USE_PRI_CPICH;
        break;

      case rrc_PCPICH_UsageForChannelEst_shallNotBeUsed:
        rl_info->dpch_per_rl.use_pri_cpich = L1_DO_NOT_USE_PRI_CPICH;
        break;

      default:
        /* bad enum value, return FALSE immediately */
        WRRC_MSG0_HIGH("Bad CPICH usage enum");
        return FAILURE;
    }

    /* Get the TPC Combination index */
    rl_info->dpch_per_rl.tpc_idx =
      (uint8) ie_ptr->u.fdd->tpc_CombinationIndex;

    /* Get the closed loop timing adjustment type */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->u.fdd,  
                closedLoopTimingAdjModePresent))
    {

      WRRC_MSG1_HIGH("CLT info in %d TXDivMode", dl_phychan->dl_common.tx_div_mode);
            
      if (dl_phychan->dl_common.tx_div_mode != L1_TX_DIV_NONE)
      {
        /* a cast here is ok as the mapping is as expected */
        rl_info->dpch_per_rl.closed_loop_timing_adj_mode =
          (uint8) ie_ptr->u.fdd->closedLoopTimingAdjMode;

        /* mark the Closed loop timing adjustment info as present */
        rl_info->dpch_per_rl.opt_parms_present_mask |=
          DL_DPCH_INFO_PER_CLOSED_LOOP_TIMING_ADJ_PRESENT;
      }
    }
    else
    {
      if(rl_info->dpch_per_rl.opt_parms_present_mask & DL_DPCH_INFO_PER_CLOSED_LOOP_TIMING_ADJ_PRESENT)
      {
	  WRRC_MSG0_HIGH("clearing CLT ");
    	  rl_info->dpch_per_rl.opt_parms_present_mask &=
  	     ~DL_DPCH_INFO_PER_CLOSED_LOOP_TIMING_ADJ_PRESENT;
      }
    }

    /* Get the secondary CPICH information */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->u.fdd,  
                secondaryCPICH_InfoPresent))
    {
      /* set the secondary CPICH channelisation code */
      rl_info->dpch_per_rl.sec_cpich_ch_code =
        (uint16) ie_ptr->u.fdd->secondaryCPICH_Info.channelisationCode;

      if (RRC_CHECK_MSG_TYPE_IE(ie_ptr->u.fdd->secondaryCPICH_Info,
          secondaryDL_ScramblingCodePresent))
      {
        /* set the secondary CPICH secondary scrambling code */
        rl_info->dpch_per_rl.sec_cpich_sec_scr_code =
          (uint16) ie_ptr->u.fdd->secondaryCPICH_Info.secondaryDL_ScramblingCode;

        rl_info->dpch_per_rl.opt_parms_present_mask |=
          DL_DPCH_INFO_PER_RL_SEC_CPICH_SEC_SCR_CODE_PRESENT;
      }

      /* mark the secondary CPICH information as present */
      rl_info->dpch_per_rl.opt_parms_present_mask |=
        DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT;
    }
   /* secondary cpich info is not present. It might have been present
    for the same radiolink before. Make sure that L1 gets
    correct bit masks */
    else
    {
      if (rl_info->dpch_per_rl.opt_parms_present_mask &
        DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT)
      {
        WRRC_MSG1_HIGH("Sec CPICH was present before rl_id:%d",
                 rl_idx);

        /* mark the secondary CPICH information as present */
        rl_info->dpch_per_rl.opt_parms_present_mask &=
          ~DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT;
      }
    }

    /* Get all of the DPCH code channel list information */
    code_list_ptr = &(ie_ptr->u.fdd->dl_ChannelisationCodeList);
    n_value = code_list_ptr->n;
    code_ch = 0;
    while ((n_value != 0) && (code_ch < UE_MAX_DPCH))
    {
      /* Initialize the optional parameters for each code channel */
      if(is_new_rl)
      {
        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask = 0;
      }

      /* decode the Spreading factor and OVSF code */
      sf_choice = code_list_ptr->elem[n_index].sf_AndCodeNumber;
      switch (RRC_GET_MSG_TYPE(sf_choice))
      {
        case T_rrc_SF512_AndCodeNumber_sf4:  
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf4;
          break;

        case T_rrc_SF512_AndCodeNumber_sf8:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf8;
          break;

        case T_rrc_SF512_AndCodeNumber_sf16:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf16;
          break;

        case T_rrc_SF512_AndCodeNumber_sf32:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf32;
          break;

        case T_rrc_SF512_AndCodeNumber_sf64:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf64;
          break;

        case T_rrc_SF512_AndCodeNumber_sf128:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf128;
          break;

        case T_rrc_SF512_AndCodeNumber_sf256:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf256;
          break;

        case T_rrc_SF512_AndCodeNumber_sf512:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf512;
          break;

        default:
          ERR("Bad SF code %u for RL #%u, DPCH #%u",
                    RRC_GET_MSG_TYPE(sf_choice), rl_idx, code_ch);
          return FAILURE;
      }

      /* Get the secondary scrambling code if present */
      if (RRC_CHECK_MSG_TYPE_IE(code_list_ptr->elem[n_index],
            secondaryScramblingCodePresent))
      {
        rl_info->dpch_per_rl.dl_chan_code[code_ch].sec_scr_code =
          (uint16) code_list_ptr->elem[n_index].secondaryScramblingCode;

        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask |=
          DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT;
      }
      /* Get the secondary scrambling code if present */
      else
      {
        if (rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask &
          DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT)
        {
          WRRC_MSG1_HIGH("Sec SCR was present before %d",
                   rl_info->dpch_per_rl.dl_chan_code[code_ch].sec_scr_code);
        }
        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask &=
          ~DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT;
      }

      /* Get the secondary scrambling code change if present */
      if (RRC_CHECK_MSG_TYPE_IE(code_list_ptr->elem[n_index], 
                    scramblingCodeChangePresent))
      {
        switch (code_list_ptr->elem[n_index].scramblingCodeChange)
        {
          case rrc_ScramblingCodeChange_codeChange:
            rl_info->dpch_per_rl.dl_chan_code[code_ch].scr_code_change =
              TRUE;
            break;

          case rrc_ScramblingCodeChange_noCodeChange:
            rl_info->dpch_per_rl.dl_chan_code[code_ch].scr_code_change =
              FALSE;
            break;

          default:
            WRRC_MSG1_ERROR("Bad sec scr code change parameter %u",
                       code_list_ptr->elem[n_index].scramblingCodeChange);
            return FAILURE;
        }

        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask |=
          DL_DPCH_CODE_CH_SCR_CODE_CHG_PRESENT;
      }

      /* point to the next code channel and increment the code channel
         index variable */
      n_value--;
      n_index++;
      code_ch++;
    }

    /* set the number of DPCH code channels used for this radio link */
    rl_info->dpch_per_rl.num_dpch = code_ch;
  }
  else
  {
    /* FDD choice not selected, TDD not supported */
    return FAILURE;
  }

  /* everything went ok */
  return SUCCESS;
} /* get_dl_dpch_info_for_each_rl_r6() */

/*====================================================================
FUNCTION        get_dl_info_for_each_rl_r6()

DESCRIPTION     This function translates the Downlink information for
                each radio link IE to the RRC config database

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
static rrcllcoc_dl_info_per_rl_status_e_type get_dl_info_for_each_rl_r6
(
  rrc_DL_InformationPerRL_r6 *ie_ptr,

  l1_dl_phychan_db_struct_type *dl_phychan,

  uint8 rl_idx,

  boolean is_new_rl
  ,rrc_DL_InformationPerRL_v6b0ext *rrc_fdpch_sttd_ind_info_per_rl
)
{
  l1_dl_info_per_rl_struct_type *rl_info;

  if (rl_idx >= UE_MAX_RL)
  {
    /* radio link index too large, bail */
    WRRC_MSG1_ERROR("Too many Radio Links %d", rl_idx);
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }

  MSG_MED("RRCHS:Get Dl Info per RL",0,0,0);
  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                T_rrc_DL_InformationPerRL_r6_modeSpecificInfo_fdd))
  {
    /* First check if the DL DPCH Info per RL is included. If not,
    * this is NOT a valid Radio link - ignore it.
    */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
                dl_dpchInfoPresent))
    {
    /* snap a local pointer to the proper radio link element in the
      RRC config page */
      rl_info = &dl_phychan->dl_per_rl[rl_idx];

      /* Get the Primary CPICH scrambling code */
      rl_info->pri_cpich_scr_code =
        (uint16) ie_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

      /*If Cell_id is present for this RL, store it in cell_id_per_rl */
      if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
cell_idPresent))
      {
        cell_id_per_rl[rl_idx] = (uint32) rrc_translate_cell_id(&(ie_ptr->cell_id));
      }


      /* Get the DL DPCH info for this radio link */
      MSG_MED("Get DL DPCH Info for RL %d", (rl_idx + 1), 0, 0);

      if(RRC_CHECK_MSG_TYPE(ie_ptr->dl_dpchInfo, 
                    T_rrc_DL_InformationPerRL_r6_dl_dpchInfo_dl_DPCH_InfoPerRL))
      {
        if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch == TRUE)
        {
           WRRC_MSG0_ERROR("FDPCH common params mixed with DPCH per RL"); 
          return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
        }
        if (get_dl_dpch_info_for_each_rl_r6(ie_ptr->dl_dpchInfo.u.dl_DPCH_InfoPerRL,
          dl_phychan, rl_idx,
          is_new_rl) == FAILURE)
        {
          return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
        }
      }
      else
      {
        if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch == FALSE)
        {
           WRRC_MSG0_ERROR("DPCH common params mixed with FDPCH per RL"); 
          return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
        }
        /* If the TX diverisity is None in Common info, it means that TX diversity is off
        * for all RL, 
        * else 
        * For backward compatibility if the UTRAN has not yet implemented 
        * rrc_DL_InformationPerRL_v6b0ext_sttdIndication_present, then let it be TRUE
        * by default if TX diversity is to be applied according to Common info
        */
        if(is_new_rl)
        {
          if(dl_phychan->dl_common.tx_div_mode == L1_TX_DIV_NONE )
          {
            rl_info->dpch_per_rl.fdpch_sttd_ind = FALSE;
          }
          else
          {
            rl_info->dpch_per_rl.fdpch_sttd_ind = TRUE;
          }
        }

        if(rrc_fdpch_sttd_ind_info_per_rl != NULL)
        {
    
          /* If rrc_DL_InformationPerRL_v6b0ext_sttdIndication_present is not present */
          rl_info->dpch_per_rl.fdpch_sttd_ind = FALSE;
        if(RRC_CHECK_MSG_TYPE_IE_PTR(rrc_fdpch_sttd_ind_info_per_rl, 
                    sttdIndicationPresent))
          {
            rl_info->dpch_per_rl.fdpch_sttd_ind = TRUE;
          }
          WRRC_MSG1_HIGH("FDPCH: STTD %d for RL  ",rl_info->dpch_per_rl.fdpch_sttd_ind);
        }
        if (get_dl_fdpch_info_for_each_rl_r6(ie_ptr->dl_dpchInfo.u.dl_FDPCH_InfoPerRL,
          dl_phychan, rl_idx,
          is_new_rl) == FAILURE)
        {
          return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
        }
      }

      /* if we made it here we must be ok */
      /* Indicate that Downlink L1 needs to be configured */
      ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
      /* Although no new parameters for MAC have been received, MAC
      * still needs to be reconfigured so as to get the new CCTrCH
      * ID whenever Downlink L1 is reconfigured. This is due to the
      * interface requirements.
      */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      return RRCLLCOC_DL_INFO_PER_RL_SUCCESS;
    }  /* DL DPCH Info is present */
    else
    {
      /* DL DPCH Info per RL is NOT present - ignore this IE */
      return RRCLLCOC_DL_INFO_PER_RL_IGNORED;
    }
  }
  else
  {
    /* No FDD info.  We don't support TDD so return indicating an error */
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }
} /* get_dl_info_for_each_rl_r5() */
/*===========================================================================
FUNCTION        is_current_camped_psc_in_rl_info_r6()

DESCRIPTION     This function determines whether the current camped psc is
                included in the dl-per-rl-list or not.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    Ordered config is updated with the new RL info.
===========================================================================*/
static boolean is_current_camped_psc_in_rl_info_r6(rrc_DL_InformationPerRL_List_r6 *ie_ptr)
{
  rrc_scr_code_type current_psc;

  current_psc = rrc_ccm_get_curr_camped_psc();
   
  if(ie_ptr->n != 0)
  {
    /*Removed the DPCH presence check to allow detection of semless reconfiguration, this covers 
     scenarios like FACH to DCH(R99), FACH to DCH(FDPCH/EUL), R99<->EUL reconfig in DCH. 
     Introduced during HSRACH to DCH seamless reconfig optimization where PCCPCH can be dropped
     Impact:
     1. new_freq is filled in L1 cmd pointer for non-seamless reconfig cases
     2. With the new change we may not send add/drop of DPCH(unlike legacy), if DPCH to FDPCH reconfig happens
        Verified with L1 for this case and they are OK to not send add/drop for such reconfig 
    */
    if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[0].modeSpecificInfo, 
                T_rrc_DL_InformationPerRL_r6_modeSpecificInfo_fdd))
    {
      if(current_psc == (rrc_scr_code_type)ie_ptr->elem[0].modeSpecificInfo.u.fdd->
                                           primaryCPICH_Info.primaryScramblingCode)
      {
        return (TRUE);
      }
    }
  }
  return(FALSE);
}

/*===========================================================================
FUNCTION        get_dl_info_per_rl_r6()

DESCRIPTION     This function validates and stores Downlink Information Per
                Radio Link for reconfiguration messages.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    Ordered config is updated with the new RL info.
===========================================================================*/
static uecomdef_status_e_type get_dl_info_per_rl_r6
(
  rrc_DL_InformationPerRL_List_r6 *ie_ptr,
  rrc_RRC_StateIndicator next_state
  ,struct rrc_DL_InformationPerRL_List_v6b0ext *dl_sttd_ind_info_per_rl_list

)
{
  uint8 idx;
  uint8 rl_count = 0;
  uint8 cnt = 0;
  /* is_hho flag indicates if it is one of Inter Freq or Intra Freq HHO */
  boolean is_hho;

  /* is_inter_freq flag indicates if it is an Inter Freq HHO */
  boolean is_inter_freq;

  boolean old_rl_seen = FALSE;

  /* new_rl_seen indicates that new RLs are seen which is always TRUE for HHOs */
  boolean new_rl_seen = FALSE;

  boolean existing_hs_link_inactive = FALSE;

  uint32 n_value = 0;
  uint32 n_index = 0;
  uint32 n_value_ie = 0;
  uint32 n_index_ie = 0;
  uint32 n_value_sttd = 0;
  uint32 n_index_sttd = 0;

  rrc_DL_InformationPerRL_List_r6 *tmp_ie_ptr = ie_ptr;
  rrc_DL_InformationPerRL_List_r6 *temp_ptr = ie_ptr;
  boolean was_rl_db_empty = FALSE;
  rrcllcoc_dl_info_per_rl_status_e_type status =
    RRCLLCOC_DL_INFO_PER_RL_IGNORED;
  rrc_freq_type rrc_freq = rrc_ccm_get_curr_camped_freq();
  rrc_state_e_type rrc_state = rrc_get_state();
  rrc_DL_InformationPerRL_v6b0ext * rrc_fdpch_sttd_ind_info_per_rl = NULL;

  if(dl_sttd_ind_info_per_rl_list != NULL)
  {
    n_value_sttd =dl_sttd_ind_info_per_rl_list->n;
  }

  ordered_config_ptr->dest_psc_present = FALSE;
  /* Check if HSDPA link has been specified in more than one place */
  n_value = tmp_ie_ptr->n;
  while (n_value != 0)
  {
    if (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo, 
                T_rrc_DL_InformationPerRL_r6_modeSpecificInfo_fdd))
    {
      if (tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->servingHSDSCH_RL_indicator == TRUE)
      {
        rl_count++;
        if (rl_count > 1)
        {
          WRRC_MSG0_ERROR("RRCHS:More than 1 HS RL specified");
          return FAILURE;
        }

        hsdpa_msg_params.msg_params_present = TRUE;
        hsdpa_msg_params.rl_link_present = TRUE;
        hsdpa_msg_params.new_rl_link = (uint16)
        tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

      }
      else
      {
        /* Check if it was HSDPA Link Earlier */
        if ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && 
          (ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc == 
             tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode))
        {
          WRRC_MSG0_HIGH("RRCHS:Exisitng HSDPA Link made inactive");
          existing_hs_link_inactive = TRUE;
        }
      }
      n_value--;
      n_index++;
    }
    else
    {
      n_value--;
      n_index++;
    }
  }
  

  if ((existing_hs_link_inactive == TRUE) && (rl_count == 0))
  {
    WRRC_MSG0_HIGH("RRCHS:HSDPA to be stopped");
    ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;
  }
  /* Reinitialize values */
  rl_count = 0;
  tmp_ie_ptr = ie_ptr;
  n_value = tmp_ie_ptr->n;
  n_index = 0;

  /* We can say with certainty that if frequency info is included, and
  * it is different than the current frequency, then we are doing a
  * hard handover.  If this is not the case, we revisit this flag
  * later.
  */
  is_inter_freq = is_hho = (ordered_config_ptr->dest_freq_present &&
    ordered_config_ptr->dest_freq != rrc_freq);

  if((rrccsp_channel_locking_nv_status()) && !rrccsp_is_ue_in_true_limited_service() &&
      is_inter_freq )
  {
    WRRC_MSG0_HIGH("Failing, inter-freq HHO not supported");
    return(FAILURE);
  }

  if(next_state == rrc_RRC_StateIndicator_cell_DCH)
  {
  /* If DPCH Info per RL is not present within DL Info per RL, then ignore it and
  * do not change the RL Info list in OC when going from DCH->DCH.
  * When going from non-DCH->DCH, the above condition should result in a Failure.
    */
    while (n_value != 0)
    {
      if((RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo, 
                  T_rrc_DL_InformationPerRL_r6_modeSpecificInfo_fdd)) &&
         (!((RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index], 
                  dl_dpchInfoPresent)) &&
            ((RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].dl_dpchInfo,
                  T_rrc_DL_InformationPerRL_r6_dl_dpchInfo_dl_DPCH_InfoPerRL))
        ||
             (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].dl_dpchInfo, 
                  T_rrc_DL_InformationPerRL_r6_dl_dpchInfo_dl_FDPCH_InfoPerRL))
        ))))
      {
        if(rrc_state == RRC_STATE_CELL_DCH)
        {
          /* Remove this check later - need to process rest of RL Info elements */
          WRRC_MSG1_HIGH("Ignoring DL Info per RL for %d,Info absent", 
              tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode);
          n_value--;
          n_index++;
          if (n_value == 0)
          {
            if (cnt > 0 )
            {
              WRRC_MSG0_HIGH("RRCHS:One link has DL DPCH info perRL");
              break;
            }
            WRRC_MSG0_HIGH("RRCHS:DL DPCH Info Per RL absent");
            return(SUCCESS);
          }
          else
          {
            continue;
          }
        }
        else
        {
          WRRC_MSG0_HIGH("Failing, DPCH Info per RL not present");
          return(FAILURE);
        }
      }
      cnt++;
      n_value--;
      n_index++;
    }

    /* Restore the Pointer */
    tmp_ie_ptr = ie_ptr;
    n_value = tmp_ie_ptr->n;
    n_index = 0;

    /* Did we have any radio links in our database previously? */
    was_rl_db_empty = (ordered_config_ptr->l1_dl_chan_parms.num_rl == 0);

    if(rrc_state != RRC_STATE_CELL_DCH)
    {
      /* Going from non-DCH state to CELL DCH */
      /* Always set new_rl_seen when coming to DCH from a non-DCH state.
      * That ensures the RL Info is populated after initializing.
      */
      new_rl_seen = TRUE;

      if(!is_inter_freq)
      {
        /* Also loop thru and check if the current camped on PSC is in RL Info.
         * If so, force Frequency_info to FALSE.
         */
        if(is_current_camped_psc_in_rl_info_r6(ie_ptr))
        {
          ordered_config_ptr->dest_freq_present = FALSE;
        }
        else  /* Intra freq HHO */
        {
          ordered_config_ptr->dest_freq_present = TRUE;
          ordered_config_ptr->dest_freq = rrc_freq;
          WRRC_MSG0_HIGH("Disjoint ASET, intra-f HHO FACH->DCH");
        }
      }
    }
    else       /* Going from DCH->DCH */
    {
    /* Unless we are doing an inter-frequency hard handover, we cannot
    * take a set of radio links that contains scrambling codes we
    * already have in our database as well as ones that we don't have
    * in our database. (25.331 8.6.6.3a)
      */
      if(!is_inter_freq)
      {
        while(n_value != 0)
        {
          if(get_dl_rl_idx_to_update(tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode,
                            RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo,
                                    T_rrc_DL_InformationPerRL_r6_modeSpecificInfo_fdd),
                            &ordered_config_ptr->l1_dl_chan_parms) <
            ordered_config_ptr->l1_dl_chan_parms.num_rl)
          {
            old_rl_seen = TRUE;
          }
          else
          {
            new_rl_seen = TRUE;
          }

          /* We can bail out early if we detect a mixed active set. */
          if(old_rl_seen && new_rl_seen)
          {
            WRRC_MSG0_ERROR("Mixed ASET detected, rejecting");
            return FAILURE;
          }
          n_value--;
          n_index++;
        }
      }
      else
      {
        /* New RLs always seen for Inter freq HHO */
        new_rl_seen = TRUE;
      }
    } /* DCH->DCH */

    n_value_ie = ie_ptr->n;
    n_index_ie = 0;
    while(n_value_ie != 0)
    {
      if(rrc_state != RRC_STATE_CELL_DCH)
      {
        /* For a non-DCH to DCH transition, there is no existing RL Info */
        idx = rl_count;
      }
      else if(is_inter_freq)
      {
      /* We've found this radio link in our database, but we are
      * doing an inter-frequency hard handover, which means that
      * we are replacing the active set.  This is a case where
      * the primary scrambling code on the new frequency is the
      * same as on the old one.  We need to adjust our radio link
      * index accordingly, since we don't want to place the new
      * radio link into the database position of the old one.
        */
        idx = rl_count;
      }
      else /* DCH -> DCH AND Not Inter Freq */
      {
        /* Now look to see if this radio link is already in our
      * database.
        */

        idx = get_dl_rl_idx_to_update(ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode,
                           RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index_ie].modeSpecificInfo, 
                                     T_rrc_DL_InformationPerRL_r6_modeSpecificInfo_fdd),
                          &ordered_config_ptr->l1_dl_chan_parms );
        if(idx == UE_MAX_RL )
        {
        /* This radio link is not in our database, which means we're
        * replacing our database with an entirely new set of radio
        * links.  We must reset the value of the database index to
        * the current radio link count.
          */
          idx = rl_count;

          is_hho = TRUE;

          hsdpa_msg_params.intra_hho_involved = 
            hsdpa_msg_params.msg_params_present = TRUE;

        } /* idx == UE_MAX_RL */
      } /* DCH -> DCH AND Not Inter Freq */
      if(n_value_sttd != 0 )
      {
        rrc_fdpch_sttd_ind_info_per_rl = &(dl_sttd_ind_info_per_rl_list->elem[n_index_sttd]);
      }
      else
      {
        rrc_fdpch_sttd_ind_info_per_rl = NULL;
      }

      /* Process the IE and place the info into our database. */
      status = get_dl_info_for_each_rl_r6(&ie_ptr->elem[n_index_ie],
        &ordered_config_ptr->l1_dl_chan_parms,
        idx,
        new_rl_seen
        ,rrc_fdpch_sttd_ind_info_per_rl
        );

      if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
      {
        return FAILURE;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_IGNORED)
      {
        n_value_ie--;
        n_index_ie++;
        continue;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS)
      {
        if(is_hho)
        {
        /* If we succeeded in processing the IE, and we are doing a
        * hard handover, we must be sure that L1 is informed by
        * sending frequency info, even if we didn't get frequency
        * info in the reconfiguration message.
          */
          if(!ordered_config_ptr->dest_freq_present)
          {
            ordered_config_ptr->dest_freq_present = TRUE;
            ordered_config_ptr->dest_freq = rrc_freq;
            WRRC_MSG0_HIGH("Disjoint ASET, intra-f HHO triggered");
          }
        }
      }

      rl_count++;
      n_value_ie--;
      n_index_ie++;
      if(n_value_sttd != 0)
      {
         n_value_sttd--;
         n_index_sttd++;
      }

    }

    /* Here we check to see if "Default DPCH Offset Value" and "DPCH frame offset" respect the following
    relation : "Default DPCH Offset Value" % 38400 = "DPCH frame offset" as per 8.6.6.14 in 25.331
      We have to do this validation only when we enter DCH the first time or if it is a Timing Initialized
      HHO */
    n_value = temp_ptr->n;
    n_index = 0;
    if ( (rrc_state != RRC_STATE_CELL_DCH) ||
         (is_hho && ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind == L1_TIMING_IND_INIT) )
    {
      if((RRC_CHECK_MSG_TYPE(temp_ptr->elem[n_index].modeSpecificInfo, 
                  T_rrc_DL_InformationPerRL_r6_modeSpecificInfo_fdd)) &&
         (RRC_CHECK_MSG_TYPE_IE(temp_ptr->elem[n_index], 
                  dl_dpchInfoPresent)) &&
         (RRC_CHECK_MSG_TYPE(temp_ptr->elem[n_index].dl_dpchInfo, 
                  T_rrc_DL_InformationPerRL_r6_dl_dpchInfo_dl_DPCH_InfoPerRL)))
      {
        if ( (ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset % 38400) !=
             (temp_ptr->elem[n_index].dl_dpchInfo.u.dl_DPCH_InfoPerRL->u.fdd->dpch_FrameOffset * RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR) )
        {
          WRRC_MSG2_ERROR("Validation of DOFF %d and DPCH frame offset %d fail",
                    ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
                    (temp_ptr->elem[n_index].dl_dpchInfo.u.dl_DPCH_InfoPerRL->u.fdd->dpch_FrameOffset *
                     RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR));
          return (FAILURE);
        }
      }

      /* Verify if DEFAULT F-DPCH Offset Value & F-DPCH Frame Offset is respected as per 8.6.6.14 */
      if ((ordered_config_ptr->l1_dl_chan_parms.use_fdpch == TRUE) && 
                 (RRC_CHECK_MSG_TYPE(temp_ptr->elem[n_index].modeSpecificInfo,
                            T_rrc_DL_InformationPerRL_r6_modeSpecificInfo_fdd)) &&
                 (RRC_CHECK_MSG_TYPE_IE(temp_ptr->elem[n_index],  
                            dl_dpchInfoPresent)) &&
                 (RRC_CHECK_MSG_TYPE(temp_ptr->elem[n_index].dl_dpchInfo, 
                            T_rrc_DL_InformationPerRL_r6_dl_dpchInfo_dl_FDPCH_InfoPerRL)))
      {
        
        if ((ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset % 38400) ==
                    (temp_ptr->elem[n_index].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset * RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR))
                    
        {
          WRRC_MSG2_HIGH("Default DPCHOffset %d, FDPCHFrameOffset %d", 
            ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
            temp_ptr->elem[n_index].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset);
          
        }
        else if (((ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset + 256) % 38400) ==
                    (temp_ptr->elem[n_index].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset * RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR))
        {
          WRRC_MSG2_HIGH("Default DPCHOffset %d, FDPCHFrameOffset %d", 
            ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
            temp_ptr->elem[n_index].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset);
                    
          // Add 256 to default DPCH Offset value 
                    
          ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset += 256;
                    
          WRRC_MSG1_HIGH("New Default DPCH Offset Value", 
            ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset);
        }
        else
        {
          WRRC_MSG2_ERROR("Validation of DOFF %d and DPCH frame offset %d fail",
                        ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
                        (temp_ptr->elem[n_index].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset  *
                        RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR));
          return (FAILURE);
        }
      }
    }


    if(is_hho || was_rl_db_empty)
    {
    /* We've just replaced the contents of our radio link database, or
    * added radio links when we had none before, so we must update the
    * count of the radio links contained therein.
      */
      ordered_config_ptr->l1_dl_chan_parms.num_rl = rl_count;

      /* Clear out old scrambling codes. */
      while(rl_count < UE_MAX_RL)
      {
        /*We need to invalidate the Cell_Id corresponding to this PSC*/ 
        cell_id_per_rl[rl_count] = WCDMA_INVALID_CELL_ID;      
        ordered_config_ptr->
          l1_dl_chan_parms.dl_per_rl[rl_count++].pri_cpich_scr_code =
          RRCLLC_INVALID_CPICH_SCR_CODE;
      }
    }
  }
  else /* All states other than Cell_DCH */
  {
    if(ie_ptr != NULL)
    {
      if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index].modeSpecificInfo,
                  T_rrc_DL_InformationPerRL_r6_modeSpecificInfo_fdd))
      {
      /* There should be not more than 1 PSCs in the list when going
      * to FACH since the C-RNTI can not be tied up with multiple
      * PSCs. Just remember the 1st PSC.
        */
        ordered_config_ptr->dest_psc =
          (rrc_scr_code_type)ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->
          primaryCPICH_Info.primaryScramblingCode;
        ordered_config_ptr->dest_psc_present = TRUE;

      }
    }
  }

  return rrcllcpcie_check_for_duplicate_rl_entry();

} /* end get_dl_info_per_rl_r6() */
/*============================================================================
FUNCTION: rrcllcpcie_process_dl_hspdsch_info_and_update_hsdpa_msg_params()

DESCRIPTION:
  This function updates IE "dl hspdsch info " in ordered config and update
  hsdpa_msg_param variable
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params
(
  OSS_UINT32 dl_hspdsch_info_present,
  rrc_DL_HSPDSCH_Information_r6 *dl_hspdsch_info_ptr,
  /* is inter freq handover involved */
  OSS_UINT32 is_ifhho_involved,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  if (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
  {
    if (dl_hspdsch_info_present)
    {
      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = FALSE;
      if(current_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE)
      {
        hsdpa_msg_params.hsdsch_info_present = TRUE;
        WRRC_MSG0_HIGH("Set HS-DSCh bitmask as 64 QAM is stopped");
      }

      hsdpa_msg_params.msg_params_present = TRUE;
      hsdpa_msg_params.hspdsch_info_present = TRUE;
      
    }
    /* Determine if IFHHO is involved */
    if (is_ifhho_involved)
    {
      WRRC_MSG0_HIGH("RRCHS:InterFreq HO");
      hsdpa_msg_params.ifhho_involved = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }
    
    if(rrcllc_set_macehs_or_machs_and_check_if_coexist()== TRUE)
    {
      WRRC_MSG2_HIGH("RRCHSPA+: MAC EHS %d and MAC HS %d cant co-exist ",
                          ordered_config_ptr->mac_dl_parms.num_mac_ehs_queue, 
                          ordered_config_ptr->mac_dl_parms.num_dflow);
      return FAILURE;
    }
  
    rrcllc_set_machs_ehs_transition();
    
    /* Set HSDPA Action & Physical Channel Parameters associated with it */
    if ((rrcllc_determine_hsdpa_action_r6(dl_hspdsch_info_ptr) == SUCCESS)
#ifdef FEATURE_MAC_I
         && 
        (rrcllc_is_maci_compatible_with_hsdpa() == SUCCESS)
#endif
       )
    {
      rrc_set_hsdpa_action_in_machs_macehs();

      if(((ordered_config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_HS_TO_EHS )
        ||(ordered_config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_EHS_TO_HS ))
        && (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE))
      {
        WRRC_MSG2_ERROR("MAC-HS <->  MAC-EHS transition %d, and Mac Reset Ind not set %d, reject config",
              ordered_config_ptr->mac_dl_parms.mac_hs_transition_type,
              ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);
        return FAILURE;
      }
#ifdef FEATURE_WCDMA_HS_FACH
     /*for EFACH to MAC-HS transition*/
     if((ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS) &&
        (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE)&&
        (current_config_ptr->hs_status_in_e_fach == TRUE))
     {
       /* The IE mac_hs_reset_indicator is not needed in the HANDOVER TO UTRAN
          COMMAND and the RRC CONNECTION SETUP messages. Otherwise, it is optional.*/
       if (RRC_STATE_CONNECTING != rrc_get_state())
       {        
       WRRC_MSG2_ERROR("MAC-EHS ->  MAC-HS transition %d, and Mac Reset Ind not set %d, reject config",
               ordered_config_ptr->mac_dl_parms.mac_hs_transition_type,
               ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);
       return FAILURE;
     }
    }
#endif
     rrcllcpcie_update_hs_tfri_table_type_non_r7_ota();
      if((ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE)
        &&((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
               (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
               ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
                (rrc_get_hsdpa_status() == HSDPA_ACTIVE))))
      {
        if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS )
        {
            WRRC_MSG0_ERROR("64 QAm cannot be started on MAC-HS");
            return FAILURE;
        }
      }

     WRRC_MSG5_MED("HSDPA :Action %d set in MAC and HS+CM enabled %d CM status L1/RRC/OTA %d %d %d",
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action,hsdpa_cm_enabled,
      l1_cm_query_compressed_mode_active(),
               rrcllc_is_cm_active(ordered_config_ptr),cm_status_from_ota_msg);

      /* Check if network is trying to activate CM with HSDPA */
      if (hsdpa_cm_enabled == FALSE)
      {
        /* Check if network is trying to activate CM with HSDPA */
        if (((((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
               (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
               ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
                (rrc_get_hsdpa_status() == HSDPA_ACTIVE))) && 
              rrcllc_is_cm_active(ordered_config_ptr) == TRUE)) ||
            ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) &&
             (l1_cm_query_compressed_mode_active() == FALSE) &&
             (cm_status_from_ota_msg == ACTIVATE_CM)) ||
            ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) &&
             (l1_cm_query_compressed_mode_active() == TRUE) &&
             (cm_status_from_ota_msg == RRC_CM_NONE)))
        {
          WRRC_MSG0_HIGH("RRCHS: CM with HSDPA Active");
          return FAILURE;
        }
      }
    }
    else
    {
       WRRC_MSG0_ERROR("RRCHS:Error during HSDPA action processing"); 
      return FAILURE;
    }
  }

  return(SUCCESS);
}
/*===========================================================================
FUNCTION        get_rl_add_info_r6()

DESCRIPTION     This function translates radio link addition information from
                a radio link addition list into the RRC config database. This
                function is only called from an Active Set Update Message

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    The RRC config database as pointed to by the input parameters
                will be updated.
===========================================================================*/
static uecomdef_status_e_type get_rl_add_info_r6
(
  rrc_RL_AdditionInformation_r6 *ie_ptr,
  l1_dl_phychan_db_struct_type *dl_phychan,
  boolean *duplicate_add_attempted
  ,rrc_RL_AdditionInformation_v6b0ext * fdpch_sttd_info_per_rl
)
{
  /* local loop variable */
  uint8 ix;

  *duplicate_add_attempted = FALSE;

  /* Check to determine if this is a duplicate radio link.  If so, return
     SUCCESS, since that's not an error and there's no more work to be done. */
  for(ix = 0; ix < ordered_config_ptr->l1_dl_chan_parms.num_rl; ix++)
  {
    if(dl_phychan->dl_per_rl[ix].pri_cpich_scr_code ==
       ie_ptr->primaryCPICH_Info.primaryScramblingCode)
    {
      /* we may want to add the processing of the IEs instead of ignoring RL info */
      WRRC_MSG1_ERROR("ASU trying to add psc: %d -already part of active set - ignoring RL info",
        ie_ptr->primaryCPICH_Info.primaryScramblingCode);
      *duplicate_add_attempted = TRUE;
      return SUCCESS;
    }
  }

  /* look for the first available radio link slot that is available */
  for(ix = 0; ix < UE_MAX_RL; ix++)
  {
    /* look in the ordered_config database for this radio link */
    if(dl_phychan->dl_per_rl[ix].pri_cpich_scr_code == RRCLLC_INVALID_CPICH_SCR_CODE)
    {
      /* Get the Primary Scrambling Code */
      if(ie_ptr->primaryCPICH_Info.primaryScramblingCode <= RRCLLC_MAX_CPICH_SCR_CODE)
      {
        /*If Cell_id is present for this RL, store it in cell_id_per_rl */      
        if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                    cell_IdPresent))
        {
          cell_id_per_rl[ix] = (uint32) rrc_translate_cell_id(&ie_ptr->cell_Id);
        }            
        dl_phychan->dl_per_rl[ix].pri_cpich_scr_code = (uint16)ie_ptr->primaryCPICH_Info.primaryScramblingCode;
      }
      else
      {
        WRRC_MSG1_ERROR("PRI SCR CODE %d is out of range",
          ie_ptr->primaryCPICH_Info.primaryScramblingCode);
        return FAILURE;
      }
      
      /* This is the first open RL slot, so place the info here */
      if(RRC_CHECK_MSG_TYPE(ie_ptr->dl_dpchInfo,
                    T_rrc_RL_AdditionInformation_r6_dl_dpchInfo_dl_DPCH_InfoPerRL))
      {
        if(get_dl_dpch_info_for_each_rl_r5(
          ie_ptr->dl_dpchInfo.u.dl_DPCH_InfoPerRL,
          dl_phychan, ix, TRUE) == FAILURE)
        {
        /* bad status from get_dl_dpch_info_for_each_rl.  Return FALSE
          indicating an error */
          WRRC_MSG0_HIGH("get_dl_dpch_info_for_each_rl failed");
          return FAILURE;
        }
      }
      else
      {

      /* If the TX diverisity is None in Common info, it means that TX diversity is off
      * for all RL, 
      * else 
      * For backward compatibility if the UTRAN has not yet implemented 
      * rrc_DL_InformationPerRL_v6b0ext_sttdIndication_present, then let it be TRUE
      * by default if TX diversity is to be applied according to Common info
      */
        if(dl_phychan->dl_common.tx_div_mode != L1_TX_DIV_NONE )
        {
          dl_phychan->dl_per_rl[ix].dpch_per_rl.fdpch_sttd_ind = TRUE;

          if(fdpch_sttd_info_per_rl != NULL)
          {
       
            /* If rrc_DL_InformationPerRL_v6b0ext_sttdIndication_present is not present */
            dl_phychan->dl_per_rl[ix].dpch_per_rl.fdpch_sttd_ind = FALSE;
           if(RRC_CHECK_MSG_TYPE_IE_PTR(fdpch_sttd_info_per_rl, 
                       sttdIndicationPresent))
            {
              dl_phychan->dl_per_rl[ix].dpch_per_rl.fdpch_sttd_ind = TRUE;
            }
              WRRC_MSG1_HIGH("FDPCH: STTD %d for RL  ",dl_phychan->dl_per_rl[ix].dpch_per_rl.fdpch_sttd_ind);
          }
        }
        else
        {
          dl_phychan->dl_per_rl[ix].dpch_per_rl.fdpch_sttd_ind = FALSE;
        }

        if(get_dl_fdpch_info_for_each_rl_r6(ie_ptr->dl_dpchInfo.u.dl_FDPCH_InfoPerRL,
          dl_phychan, ix, TRUE))
        {
        /* bad status from get_dl_dpch_info_for_each_rl.  Return FALSE
          indicating an error */
          WRRC_MSG0_HIGH("get_dl_fdpch_info_for_each_rl failed");
          return FAILURE;
        }
      }
      /* Ignore the SCCPCH/FACH and TFCI combining info for now */
      
      /* No need to continue */
      break;
    } /* end RL match if */
  } /* end looking for open RL slot */
  
  /* everything is good if here */
  return SUCCESS;

} /* end get_rl_add_info() */
/*====================================================================
FUNCTION: validate_fdpch_information()

DESCRIPTION:
  This function verifies that there are no mixed RLs with DPCH and FDPCH
  after ASU is processed.

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if validation is successful.
  FAILURE if there are mixed RLs with FDPCH and DPCH

SIDE EFFECTS:
  None.
====================================================================*/

static uecomdef_status_e_type validate_fdpch_information
(
  rrc_RL_AdditionInformationList_r6 *rl_AdditionInformationList_ptr
)
{
  uint32 n_value = rl_AdditionInformationList_ptr->n;
  uint32 n_index = 0;
  
  while(n_value != 0)
  {
    if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch)
    {
      if(RRC_CHECK_MSG_TYPE(rl_AdditionInformationList_ptr->elem[n_index].dl_dpchInfo,
           T_rrc_RL_AdditionInformation_r6_dl_dpchInfo_dl_DPCH_InfoPerRL))
      {
        WRRC_MSG0_ERROR("Mixed RLs with DPCH and FDPCH");
        return FAILURE;
      }
    }
    else
    {
      if(RRC_CHECK_MSG_TYPE(rl_AdditionInformationList_ptr->elem[n_index].dl_dpchInfo,
             T_rrc_RL_AdditionInformation_r6_dl_dpchInfo_dl_FDPCH_InfoPerRL))
      {
        WRRC_MSG0_ERROR("Mixed RLs with DPCH and FDPCH");
        return FAILURE;
      }
    }
    n_value--;
    n_index++;
  }
  return SUCCESS;
}
/*============================================================================
FUNCTION: rrcllc_process_serving_hsdsch_cell_info()

DESCRIPTION:
  This function updates IE "rrc_Serving_HSDSCH_CellInformation " in ordered config
  and update e_dch parameters

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/

uecomdef_status_e_type rrcllc_process_serving_hsdsch_cell_info
(
  rrc_ActiveSetUpdate_r6_IEs *msg_ptr 
)
{

  rrc_Serving_HSDSCH_CellInformation *hs_srv_cell_ptr = &msg_ptr->serving_HSDSCH_CellInformation;

  uint8 rl_count;

  if((RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr,
                primaryCPICH_InfoPresent)) &&
     (hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode != ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc) &&
     (!(RRC_CHECK_MSG_TYPE_IE_PTR(msg_ptr, 
                newH_RNTIPresent))))

  {
    WRRC_MSG0_ERROR("ASU repointing without new HRNTI");
    return FAILURE;
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                primaryCPICH_InfoPresent))
  {
    for (rl_count = 0; rl_count < ordered_config_ptr->l1_dl_chan_parms.num_rl; rl_count++)
    {
      if(hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode == 
         ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[rl_count].pri_cpich_scr_code)
      {
        WRRC_MSG0_HIGH("New HS serving cell psc found in AS");
        break;
      }
    }
    if(rl_count == ordered_config_ptr->l1_dl_chan_parms.num_rl)
    {
      WRRC_MSG0_ERROR("New HS srv cell PSC not found in rls of AS");
      return FAILURE;
    }

    if(hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode
      != ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc)
    {
      WRRC_MSG1_HIGH("ASU HS repointing to psc %d", hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode);
      hsdpa_msg_params.msg_params_present = TRUE;
      hsdpa_msg_params.rl_link_present = TRUE;
      hsdpa_msg_params.new_rl_link = hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode;
    }
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                deltaACKPresent))
  {
    if(ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack != hs_srv_cell_ptr->deltaACK)
    {
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack = hs_srv_cell_ptr->deltaACK;
      hsdpa_msg_params.beta_table_present = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                deltaNACKPresent))
  {
    if(ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack != hs_srv_cell_ptr->deltaNACK)
    {
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack = hs_srv_cell_ptr->deltaNACK;
      hsdpa_msg_params.beta_table_present = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }
  }


  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                mac_hsResetIndicatorPresent))
  {
    ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = TRUE;
    hsdpa_msg_params.msg_params_present = TRUE;
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                harqInfoPresent))
  {    
    /* Process HARQ Info */
    if (set_harq_information(ordered_config_ptr,&hs_srv_cell_ptr->harqInfo) == FAILURE)
    {
      return FAILURE;
    }
    hsdpa_msg_params.msg_params_present = TRUE;
    hsdpa_msg_params.hsdsch_info_present = TRUE;
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                dl_hspdsch_InformationPresent))
  {
    hsdpa_msg_params.msg_params_present = TRUE;
    hsdpa_msg_params.hspdsch_info_present = TRUE;
  }
  else
  {
    if(rrc_get_hsdpa_status() == HSDPA_INACTIVE)
    {
      /* Action has already been set to NOOP be default */
      WRRC_MSG0_HIGH("RRCHS:HSDPA Action NOOP");
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP; 
      ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
    }
  }
  if(rrcllc_determine_hsdpa_action(&hs_srv_cell_ptr->dl_hspdsch_Information) == SUCCESS)
  {
     rrc_set_hsdpa_action_in_machs_macehs();
     rrcllcpcie_update_hs_tfri_table_type_non_r7_ota();
      if((ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE)
        &&((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
               (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
               ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
                (rrc_get_hsdpa_status() == HSDPA_ACTIVE))))
      {
        if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS )
        {
            WRRC_MSG0_ERROR("64 QAm cannot be started on MAC-HS");
            return FAILURE;
        }
      }

    WRRC_MSG1_HIGH("RRCHS:HSDPA Action %d set in MAC", 
    ordered_config_ptr->mac_dl_parms.mac_hsdpa_action);
  }
  else
  {
    return FAILURE;
  }
  return SUCCESS;
}

/*============================================================================
FUNCTION: rrcllcpcie_process_rl_addition_info_list_r6()

DESCRIPTION:
  This function updates IE "rrc_RL_AdditionInformationList_r6 " in ordered config
  and update e_dch parameters

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_rl_addition_info_list_r6
(
  OSS_UINT32 rl_additon_info_list_present,
  rrc_RL_AdditionInformationList_r6 *rl_add_ptr
  ,struct rrc_RL_AdditionInformation_list_v6b0ext *rl_info_per_rl_list_sttd_info

)
{
  uint8                            idx;  /* local loop variable */
  uint16                           num_rl;   /* local RL count */
  /* flag to prevent erroneous increment of number of RL on attempt to add
     a duplicate RL */
  boolean duplicate_add_attempted = FALSE;
  uint32 n_value = 0;
  uint32 n_index = 0;
  uint32 n_value_sttd = 0;
  uint32 n_index_sttd = 0;

  uint32 e_rl_idx;
  uint32 prev_e_rl_idx;
  boolean is_e_dl_info_present = FALSE;
  
  if(rl_additon_info_list_present)
  {
    idx = 0;

    if(SUCCESS != validate_fdpch_information(rl_add_ptr))
    {
      return FAILURE;   
    }
    num_rl = ordered_config_ptr->l1_dl_chan_parms.num_rl;
    n_value = rl_add_ptr->n;
    if(rl_info_per_rl_list_sttd_info != NULL)
    {
      n_value_sttd = rl_info_per_rl_list_sttd_info->n;
    }

    while((n_value != 0) && (idx < (UE_MAX_RL - num_rl)))
    {
      rrc_RL_AdditionInformation_v6b0ext * fdpch_sttd_info_per_rl  = NULL;
      if(n_value_sttd != 0)
      {
       fdpch_sttd_info_per_rl= &rl_info_per_rl_list_sttd_info->elem[n_index_sttd];
      }
      

      if(get_rl_add_info_r6(&rl_add_ptr->elem[n_index], &ordered_config_ptr->l1_dl_chan_parms,
                         &duplicate_add_attempted
                        ,fdpch_sttd_info_per_rl

                         ) == FAILURE)
      {
        WRRC_MSG0_HIGH("get_rl_add_info() failed");
        return FAILURE;
      }

      /* one more radio link in ORDERED_CONFIG */
      if(!duplicate_add_attempted)
      {
        ordered_config_ptr->l1_dl_chan_parms.num_rl++;
      }
      if (RRC_CHECK_MSG_TYPE_IE(rl_add_ptr->elem[n_index], 
                    e_HICH_InformationPresent))
      {
        /* if we are inside this if check then it means that RRC needs to indicate
           to L1 that some of the parameters in DL has changed */
        is_e_dl_info_present = TRUE;

        e_rl_idx = get_e_rl_index_for_a_given_psc(
              rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

        if ((e_rl_idx < L1_MAX_EDCH_RL) && (FAILURE == rrcllcpcie_update_e_hich_info_and_mask(e_rl_idx, 
                                                              &rl_add_ptr->elem[n_index].e_HICH_Information,
                                                              rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                            ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                            )))
        {
          return FAILURE;
        }
      }

      if (RRC_CHECK_MSG_TYPE_IE(rl_add_ptr->elem[n_index], 
                 e_RGCH_InformationPresent))
      {
        /* if we are inside this if check then it means that RRC needs to indicate
           to L1 that some of the parameters in DL has changed */
        is_e_dl_info_present = TRUE;

        if (FAILURE == rrcllcpcie_process_e_rgch_information(
            rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode,
            &rl_add_ptr->elem[n_index].e_RGCH_Information
#ifdef FEATURE_WCDMA_DC_HSUPA
          ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ))
        {
          return(FAILURE);
        }
      }
      else
      {
        /* if OVSF code for HICH has changed, then RGCH needs to be reconfigured also as RGCH uses
           same OVSF code as HIGH
         */
        e_rl_idx = get_e_rl_index_for_a_given_psc(
              rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );
  
	 if(e_rl_idx >= L1_MAX_EDCH_RL)
         {
            WRRC_MSG1_ERROR("e_rl_idx more than L1_MAX_EDCH_RL  %d",e_rl_idx);
            return FAILURE;
         }
         
        if(e_rl_idx >=  ordered_config_ptr->l1_e_info.e_dl_info.num_e_dl_rl_add_recfg_info)
        {
          /* e_rl_idx is equal to num_e_dl_rl_add_recfg_info, then there is no valid entry 
           * for E-HICH, So dont do any thing here 
           */
        }
        else if(e_rl_idx < L1_MAX_EDCH_RL)
        {
          /* We found a valid entry for e_rl_idx So start processing */
          if((ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
             (L1_E_HICH_INFO_PRESENT|L1_E_HICH_INFO_RECFG|L1_E_RGCH_INFO_PRESENT)) ==
             (L1_E_HICH_INFO_PRESENT|L1_E_HICH_INFO_RECFG|L1_E_RGCH_INFO_PRESENT))
          {
            prev_e_rl_idx = get_e_rl_index_for_a_given_psc(
              rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode, current_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );
            
            if ((prev_e_rl_idx < L1_MAX_EDCH_RL) &&
                (ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[e_rl_idx].e_hich_info.ch_code !=
                  current_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[prev_e_rl_idx].e_hich_info.ch_code))
            {
              WRRC_MSG0_HIGH("RRCEUL: Reconfig RGCH due to OVSF change in HICH");
              ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask  |= L1_E_RGCH_INFO_RECFG;
            }
          }
        }
      }

      if(n_value_sttd !=0)
      {
        n_value_sttd--;
        n_index_sttd++;
      }

      /* get the next RL */
      n_value--;
      n_index++;
      idx++;
    } /* end loop of all included RLs to add */ 
    if (FAILURE == rrcllcpcie_validate_hich_rgch_info(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
      , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */

      ))
    {
      return(FAILURE);
    }
  } /* end RL Addition information */

  /* Make sure we actually have some RLs in the active set */
  if(ordered_config_ptr->l1_dl_chan_parms.num_rl == 0)
  {
    WRRC_MSG0_HIGH("No RLs in aset after ASU");
    return FAILURE;
  }

  if( ordered_config_ptr->l1_e_info.e_dl_info.num_e_dl_rl_add_recfg_info 
          > RRC_EUL_MAX_RL)
  {
    WRRC_MSG1_ERROR("No of EDCh RL %d is more than 4 in Active set",
      ordered_config_ptr->l1_e_info.e_dl_info.num_e_dl_rl_add_recfg_info);
    return FAILURE;
  }
  /* update the l1_e_req_mask */
  rrcllc_update_l1_e_req_mask_for_e_dl_info(is_e_dl_info_present);

  return(SUCCESS);
} /* rrcllcpcie_process_rl_addition_info_list_r6 */

/*============================================================================
FUNCTION: rrcllcpcie_is_hho()

DESCRIPTION:
  This function returns boolean value based on whether inter-freq or intra-freq
  HHO is ongoing. 

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE - HHO in progress
  FALSE - No HHO

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_is_hho_r6
(
  OSS_UINT32 dl_info_per_rl_list_present,
  rrc_DL_InformationPerRL_List_r6 *dl_info_per_rl_list_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  boolean is_hho = FALSE, old_rl_seen = FALSE, new_rl_seen = FALSE;
  rrc_freq_type rrc_freq = rrc_ccm_get_curr_camped_freq();
  rrc_DL_InformationPerRL_List_r6 *tmp_ie_ptr = dl_info_per_rl_list_ptr;
  rrc_state_e_type curr_rrc_state = rrc_get_state();

  uint32 n_value = tmp_ie_ptr->n;
  uint32 n_index = 0;
  
  if ((rcvd_state_indicator == rrc_RRC_StateIndicator_cell_DCH) && 
      (dl_info_per_rl_list_present))
  {
    /* Consider the following conditions as HHO:  
                   - Inter freq 
                   - Itra freq with disjoint ASET
                   - First time into CELL_DCH
    */
    is_hho = ((ordered_config_ptr->dest_freq_present &&
               ordered_config_ptr->dest_freq != rrc_freq) || 
              (curr_rrc_state != RRC_STATE_CELL_DCH));
    
    if (FALSE == is_hho)
    {
      while(n_value != 0)
      {
        if(get_dl_rl_idx_to_update(tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode,
                  RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo,
                            T_rrc_DL_InformationPerRL_r6_modeSpecificInfo_fdd),
                            &ordered_config_ptr->l1_dl_chan_parms )<
            ordered_config_ptr->l1_dl_chan_parms.num_rl)
        {
          old_rl_seen = TRUE;
        }
        else
        {
          new_rl_seen = TRUE;
        }
  
        /* We can bail out early if we detect a mixed active set. */
        if(old_rl_seen && new_rl_seen)
        {
          WRRC_MSG0_ERROR("Mixed ASET detected, rejecting");
          return FAILURE;
        }
        n_value--;
        n_index++;
      }
      /* if new RL seen is true then it means its a dis-joint set and hence its
         value will indicate whether its HHO or not. */
      is_hho = new_rl_seen;
      
    }
  
    if (TRUE == is_hho)
    {
      MSG_HIGH("HHO detected DCH trans %d intra-freq %d inter-freq %d ",
               (curr_rrc_state != RRC_STATE_CELL_DCH), 
               new_rl_seen,
               (ordered_config_ptr->dest_freq_present &&
                ordered_config_ptr->dest_freq != rrc_freq));
    }
  }

  ordered_config_ptr->is_hho = is_hho;
  return SUCCESS;
}


/*============================================================================
FUNCTION: rrcllcpcie_process_dl_info_per_rl_list_r6()

DESCRIPTION:
  This function updates IE "dl per rl info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_dl_info_per_rl_list_r6
(
  OSS_UINT32 dl_info_per_rl_list_present,
  rrc_DL_InformationPerRL_List_r6 *dl_info_per_rl_list_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
  ,struct rrc_DL_InformationPerRL_List_v6b0ext *dl_sttd_ind_info_per_rl_list

)
{
  if (dl_info_per_rl_list_present)
  {
    if(FAILURE == get_dl_info_per_rl_r6(dl_info_per_rl_list_ptr, rcvd_state_indicator
                                                       ,dl_sttd_ind_info_per_rl_list

        ))
    {
      return (FAILURE);
    }
  }

  /* process EUL related information */
  if (FAILURE == rrcllcpcie_process_e_info_in_dl_info_per_rl_list_r6(
      dl_info_per_rl_list_present, 
      dl_info_per_rl_list_ptr,
      rcvd_state_indicator))
  {
    return(FAILURE);
  }

  return(SUCCESS);
}


/*====================================================================
FUNCTION        is_current_camped_psc_in_rl_info()

DESCRIPTION     This function translates the Downlink information for
                each radio link IE to the RRC config database

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/

static boolean is_current_camped_psc_in_rl_info(rrc_DL_InformationPerRL_List *ie_ptr)
{
  rrc_scr_code_type current_psc;

  current_psc = rrc_ccm_get_curr_camped_psc();
  
  if(ie_ptr->n != 0)
  {
    /*Removed the DPCH presence check to allow detection of semless reconfiguration, this covers 
     scenarios like FACH to DCH(R99), FACH to DCH(FDPCH/EUL), R99<->EUL reconfig in DCH. 
     Introduced during HSRACH to DCH seamless reconfig optimization where PCCPCH can be dropped
     Impact:
     1. new_freq is filled in L1 cmd pointer for non-seamless reconfig cases
     2. With the new change we may not send add/drop of DPCH(unlike legacy), if DPCH to FDPCH reconfig happens
        Verified with L1 for this case and they are OK to not send add/drop for such reconfig 
    */
    if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[0].modeSpecificInfo, 
                T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd))
    {
      if(current_psc == (rrc_scr_code_type)ie_ptr->elem[0].modeSpecificInfo.u.fdd->
                                           primaryCPICH_Info.primaryScramblingCode)
      {
        return (TRUE);
      }
    }
  }
  return(FALSE);
}


/*====================================================================
FUNCTION        get_dl_rl_idx_to_update()

DESCRIPTION     This function retrieves the RL index for a given
                scrambling code in a Downlink information for each
                radio link IE

DEPENDENCIES    NONE

RETURN VALUE    RL index if found, UE_MAX_RL otherwise.

SIDE EFFECTS
====================================================================*/
uint8 get_dl_rl_idx_to_update
(
  rrc_PrimaryScramblingCode pscr,
  OSS_UINT32 modeSpecificInfo_fdd_info_present,
  l1_dl_phychan_db_struct_type *dl_phychan
)
{
  uint8 idx;

  for(idx = 0; idx < UE_MAX_RL; idx++)
  {
    if(modeSpecificInfo_fdd_info_present)
    {
      if(dl_phychan->dl_per_rl[idx].pri_cpich_scr_code ==
        pscr)
      {
        return idx;
      }
    }
    else
    {
      /* No FDD info.  We don't support TDD so return indicating an error */
      return UE_MAX_RL;
    }
  }

  /* If we got all the way here, idx will be set to UE_MAX_RL. */
  return idx;
}

/*====================================================================
FUNCTION        get_dl_info_for_each_rl()

DESCRIPTION     This function translates the Downlink information for
                each radio link IE to the RRC config database

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
rrcllcoc_dl_info_per_rl_status_e_type get_dl_info_for_each_rl
(
  rrc_DL_InformationPerRL *ie_ptr,

  l1_dl_phychan_db_struct_type *dl_phychan,

  uint8 rl_idx,

  boolean is_new_rl
)
{
  l1_dl_info_per_rl_struct_type *rl_info;

  if (rl_idx >= UE_MAX_RL)
  {
    /* radio link index too large, bail */
    WRRC_MSG1_ERROR("Too many Radio Links %d", rl_idx);
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }

  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                  T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd))
  {
    /* First check if the DL DPCH Info per RL is included. If not,
     * this is NOT a valid Radio link - ignore it.
     */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
                dl_DPCH_InfoPerRLPresent))
    {
      /* snap a local pointer to the proper radio link element in the
         RRC config page */
      rl_info = &dl_phychan->dl_per_rl[rl_idx];

      /* Get the Primary CPICH scrambling code */
      rl_info->pri_cpich_scr_code =
        (uint16) ie_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

      /* Get the DL DPCH info for this radio link */
      MSG_MED("Get DL DPCH Info for RL %d", (rl_idx + 1), 0, 0);

      if (get_dl_dpch_info_for_each_rl(&ie_ptr->dl_DPCH_InfoPerRL,
                                        dl_phychan, rl_idx,
                                        is_new_rl) == FAILURE)
      {
        return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
      }
      /* if we made it here we must be ok */
      /* Indicate that Downlink L1 needs to be configured */
      ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
      /* Although no new parameters for MAC have been received, MAC
       * still needs to be reconfigured so as to get the new CCTrCH
       * ID whenever Downlink L1 is reconfigured. This is due to the
       * interface requirements.
       */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      return RRCLLCOC_DL_INFO_PER_RL_SUCCESS;
    }  /* DL DPCH Info is present */
    else
    {
      /* DL DPCH Info per RL is NOT present - ignore this IE */
      return RRCLLCOC_DL_INFO_PER_RL_IGNORED;
    }
  }
  else
  {
    /* No FDD info.  We don't support TDD so return indicating an error */
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }
} /* get_dl_info_for_each_rl() */

/*===========================================================================
FUNCTION        get_radio_link_addition_info()

DESCRIPTION     This function translates radio link information from a
                radio link addition list into the RRC config database.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    The RRC config database as pointed to by the input parameters
                will be updated.
===========================================================================*/
uecomdef_status_e_type get_radio_link_addition_info
(
  rrc_RL_AdditionInformationList *ie_ptr,

  l1_dl_phychan_db_struct_type *dl_phychan

  /* need other parameters for getting to the CCTrCH information */
)
{
  uint8 n_index = 0;

  MSG_MED("Get DL RL Add Info",0,0,0);

  while ((ie_ptr->n > n_index) && (n_index < UE_MAX_RL))
  {
    if (get_dl_dpch_info_for_each_rl(&ie_ptr->elem[n_index].dl_DPCH_InfoPerRL,
                                      dl_phychan, n_index, TRUE) == FAILURE)
    {
      /* bad status from get_dl_dpch_info_for_each_rl.  Return FALSE
         indicating an error */
      return FAILURE;
    }

    /* Set the primary scrambling code for this radio link */
    dl_phychan->dl_per_rl[n_index].pri_cpich_scr_code =
        (uint16) ie_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode;

    /* Need to add code to take care of the
      rl_ptr->elem[n_index].sccpch_InfoforFACH
      rl_ptr->elem[n_index].tfci_CombiningIndicator
    */

    /* update the radio link pointer and index for the next radio link */
    n_index++;
  }

  /* if we made it here everything must be ok */
  return SUCCESS;
}

/*===========================================================================
FUNCTION        get_rl_remove_info()

DESCRIPTION     This function translates radio link removal information from
                a radio link removal list into the RRC config database. This
                function is only called from an Active Set Update Message.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    The RRC config database as pointed to by the input parameters
                will be updated.
===========================================================================*/
uecomdef_status_e_type get_rl_remove_info
(
  rrc_PrimaryCPICH_Info *ie_ptr,
  l1_dl_phychan_db_struct_type *dl_phychan
)
{
  /* local loop variables */
  uint8 ix;
  uecomdef_status_e_type is_rl_found = FAILURE;

  /* look in the ordered_config database for this radio link */
  for(ix = 0; ix < UE_MAX_RL; ix++)
  {
    if((is_rl_found == FAILURE)&&(ie_ptr->primaryScramblingCode == dl_phychan->dl_per_rl[ix].pri_cpich_scr_code))
    {
      /* Clear out that RL */
      rrcllc_init_dl_rl_info(ordered_config_ptr, ix
#ifdef FEATURE_WCDMA_DC_HSUPA
                            ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */

                            );
      MSG_MED("Removed RL %d",ie_ptr->primaryScramblingCode,0,0);
      is_rl_found = SUCCESS;
    }
    /* re-arrange the table to eliminate the gap */
    if(is_rl_found == SUCCESS)
    {
      if((ix < (UE_MAX_RL - 1)) &&
             (dl_phychan->dl_per_rl[ix+1].pri_cpich_scr_code != RRCLLC_INVALID_CPICH_SCR_CODE))
      {
        MSG_MED("Move RL %d to slot %d",dl_phychan->dl_per_rl[ix+1].pri_cpich_scr_code,ix,0);

        /* Move the next slot up */
        dl_phychan->dl_per_rl[ix] = dl_phychan->dl_per_rl[ix+1];

        /*Since RL at index is has been removed, we need to update the cell_id_per_rl
        list also.*/	  		
        cell_id_per_rl[ix] = cell_id_per_rl[ix+1];
        /* Clear out old used slot */
        rrcllc_init_dl_rl_info(ordered_config_ptr, ix+1
#ifdef FEATURE_WCDMA_DC_HSUPA
                            ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
);

      }
      else
      {
        break;
      }
    }
  }

  if(is_rl_found == FAILURE)
  {
    WRRC_MSG1_ERROR("RL %d not removed",ie_ptr->primaryScramblingCode);
  }
  return is_rl_found;

} /* end get_rl_remove_info() */

/*===========================================================================
FUNCTION        get_rl_add_info()

DESCRIPTION     This function translates radio link addition information from
                a radio link addition list into the RRC config database. This
                function is only called from an Active Set Update Message

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    The RRC config database as pointed to by the input parameters
                will be updated.
===========================================================================*/
uecomdef_status_e_type get_rl_add_info
(
  rrc_RL_AdditionInformation *ie_ptr,
  l1_dl_phychan_db_struct_type *dl_phychan,
  boolean *duplicate_add_attempted
)
{
  /* local loop variable */
  uint8 ix;

  *duplicate_add_attempted = FALSE;

  /* Check to determine if this is a duplicate radio link.  If so, return
     SUCCESS, since that's not an error and there's no more work to be done. */
  for(ix = 0; ix < ordered_config_ptr->l1_dl_chan_parms.num_rl; ix++)
  {
    if(dl_phychan->dl_per_rl[ix].pri_cpich_scr_code ==
       ie_ptr->primaryCPICH_Info.primaryScramblingCode)
    {
      *duplicate_add_attempted = TRUE;
      return SUCCESS;
    }
  }

  /* look for the first available radio link slot that is available */
  for(ix = 0; ix < UE_MAX_RL; ix++)
  {
    /* look in the ordered_config database for this radio link */
    if(dl_phychan->dl_per_rl[ix].pri_cpich_scr_code == RRCLLC_INVALID_CPICH_SCR_CODE)
    {
      /* Get the Primary Scrambling Code */
      if(ie_ptr->primaryCPICH_Info.primaryScramblingCode <= RRCLLC_MAX_CPICH_SCR_CODE)
      {
        dl_phychan->dl_per_rl[ix].pri_cpich_scr_code = (uint16)ie_ptr->primaryCPICH_Info.primaryScramblingCode;
      }
      else
      {
        WRRC_MSG1_ERROR("PRI SCR CODE %d is out of range",
                  ie_ptr->primaryCPICH_Info.primaryScramblingCode);
        return FAILURE;
      }

      /* This is the first open RL slot, so place the info here */
      if(get_dl_dpch_info_for_each_rl(&ie_ptr->dl_DPCH_InfoPerRL,
                                      dl_phychan, ix, TRUE) == FAILURE)
      {
        /* bad status from get_dl_dpch_info_for_each_rl.  Return FALSE
           indicating an error */
        WRRC_MSG0_HIGH("get_dl_dpch_info_for_each_rl failed");
        return FAILURE;
      }

      /* Ignore the SCCPCH/FACH and TFCI combining info for now */

      /* No need to continue */
      break;
    } /* end RL match if */
  } /* end looking for open RL slot */

  /* everything is good if here */
  return SUCCESS;

} /* end get_rl_add_info() */


/*===========================================================================

FUNCTION        IS_FREQ_IN_OVERLAPPING_850_AND_800_BANDS

DESCRIPTION     This function determines if the UARFCN passed to it is in 
                the overlapping region of 850 and 800 bands or not.


RETURN VALUE    TRUE:  UARFCN is in the overlapping region
                FALSE: Otherwise

SIDE EFFECTS    

===========================================================================*/
boolean is_freq_in_overlapping_850_and_800_bands(uint32 freq)
{
  if(   (freq == rrc_dl_band_d_addl_channels[0])
     || (freq == rrc_dl_band_d_addl_channels[1])
     || ((freq >= RRC_DL_BAND_D_UARFCN_MIN) && (freq <= RRC_DL_BAND_D_UARFCN_MAX)))
  {
    return TRUE;
  }
  else
  {
    return FALSE;
  }
} /* is_freq_in_overlapping_850_and_800_bands */


/*===========================================================================

FUNCTION        RRC_GET_FREQUENCY_BAND

DESCRIPTION     This function looks at the passed in frequency and PLMN and
                returns the band the frequency belongs to. The PLMN information is used
                to determine the band if the frequency is present in the 
                overlapping region of 850 and 800 bands. 

RETURN VALUE    Returns RRC_CSP_BAND_MAX if UARFCN is invalid.

SIDE EFFECTS    None

===========================================================================*/
rrc_csp_band_class_type rrc_get_frequency_band
(
  rrc_freq_type freq,
  rrc_plmn_identity_type plmn_id
)
{
  uint32 i=0;

  /* Band a, downlink */
  if(freq >= RRC_DL_BAND_A_UARFCN_MIN &&
      freq <= RRC_DL_BAND_A_UARFCN_MAX)
  {
    WRRC_MSG1_MED("Freq %d in IMT2k band",freq);
    return RRC_CSP_IMT2K_BAND;
  }

  /* Band b, 1900 MHz */
  i = 0;
  while(rrc_dl_band_b_addl_channels[i] != 0)
  {
    if(freq == rrc_dl_band_b_addl_channels[i])
    {
      WRRC_MSG1_MED("Freq %d in PCS band",freq);
      return RRC_CSP_PCS_BAND;
    }
    i++;
  }

  if((freq >= RRC_DL_BAND_B_UARFCN_MIN) &&
        (freq <= RRC_DL_BAND_B_UARFCN_MAX))
  {
    WRRC_MSG1_MED("Freq %d in PCS band",freq);
    return RRC_CSP_PCS_BAND;
  }

  /* Band d, 800 MHz */
  i = 0;
  while(rrc_dl_band_d_addl_channels[i] != 0)
  {
    if(freq == rrc_dl_band_d_addl_channels[i])
    {
      WRRC_MSG1_MED("Freq %d in 800 band",freq);

#ifdef FEATURE_MCC_AND_850_800_BAND_COMBINATION
      if((RRC_CSP_GET_INT_MCC(plmn_id) == JAPAN_MCC1)
         || (RRC_CSP_GET_INT_MCC(plmn_id) == JAPAN_MCC2)
         || (RRC_CSP_GET_INT_MCC(plmn_id) == JAPAN_MCC3)
         || (RRC_CSP_GET_INT_MCC(plmn_id) == JAPAN_MCC4))
      {
        WRRC_MSG0_HIGH("MCC_850_800: Japan MCC. band set to 800");
        return (RRC_CSP_WCDMA_800_BAND);
      } 
      else
      {
        WRRC_MSG0_HIGH("MCC_850_800: NOT Japan MCC. band set to 850");
        return (RRC_CSP_WCDMA_850_BAND);
      }
#else
      return (RRC_CSP_WCDMA_800_BAND | RRC_CSP_WCDMA_850_BAND);
#endif
    }

    i++;
  }

  if((freq >= RRC_DL_BAND_D_UARFCN_MIN) &&
        (freq <= RRC_DL_BAND_D_UARFCN_MAX))
  {
    WRRC_MSG1_MED("Freq %d in 800 band",freq);

#ifdef FEATURE_MCC_AND_850_800_BAND_COMBINATION
    if((RRC_CSP_GET_INT_MCC(plmn_id) == JAPAN_MCC1)
       || (RRC_CSP_GET_INT_MCC(plmn_id) == JAPAN_MCC2)
       || (RRC_CSP_GET_INT_MCC(plmn_id) == JAPAN_MCC3)
       || (RRC_CSP_GET_INT_MCC(plmn_id) == JAPAN_MCC4))
    {
      WRRC_MSG0_HIGH("MCC_850_800: Japan MCC. band set to 800");
      return (RRC_CSP_WCDMA_800_BAND);
    } 
    else
    {
      WRRC_MSG0_HIGH("MCC_850_800: NOT Japan MCC. band set to 850");
      return (RRC_CSP_WCDMA_850_BAND);
    }
#else
    return (RRC_CSP_WCDMA_800_BAND | RRC_CSP_WCDMA_850_BAND);
#endif
  }

  /* Band c, 850 MHz */
  i = 0;
  while(rrc_dl_band_c_addl_channels[i] != 0)
  {
    if(freq == rrc_dl_band_c_addl_channels[i])
    {
      WRRC_MSG1_MED("Freq %d in 850 band",freq);
      return RRC_CSP_WCDMA_850_BAND;
    }
    i++;
  }

  if((freq >= RRC_DL_BAND_C_UARFCN_MIN) &&
        (freq <= RRC_DL_BAND_C_UARFCN_MAX))
  {
    WRRC_MSG1_MED("Freq %d in 850 band",freq);
    return RRC_CSP_WCDMA_850_BAND;
  }

  /* Band e, downlink */
  if(freq >= RRC_DL_BAND_E_UARFCN_MIN &&
      freq <= RRC_DL_BAND_E_UARFCN_MAX)
  {
    WRRC_MSG1_MED("Freq %d in 1800 MHz band",freq);
    return RRC_CSP_WCDMA_1800_BAND;
  }

  /* Band f, downlink */
  if(freq >= RRC_DL_BAND_F_UARFCN_MIN &&
      freq <= RRC_DL_BAND_F_UARFCN_MAX)
  {
    WRRC_MSG1_MED("Freq %d in 900 MHz band",freq);
    return RRC_CSP_WCDMA_900_BAND;
  }

  /* Band g, downlink */
  if(freq >= RRC_DL_BAND_G_UARFCN_MIN &&
      freq <= RRC_DL_BAND_G_UARFCN_MAX)
  {
    WRRC_MSG1_MED("Freq %d in 1700 MHz band",freq);
    return RRC_CSP_WCDMA_1700_BAND;
  }


  /* Band h, 1700_2100 AWS MHz */
  i = 0;
  while(rrc_dl_band_h_addl_channels[i] != 0)
  {
    if(freq == rrc_dl_band_h_addl_channels[i])
    {
      WRRC_MSG1_MED("Freq %d in 1700_2100 AWS band",freq);
      return RRC_CSP_WCDMA_1700_2100_BAND;
    }
    i++;
  }

  /* Band h, downlink */
  if(freq >= RRC_DL_BAND_H_UARFCN_MIN &&
      freq <= RRC_DL_BAND_H_UARFCN_MAX)
  {
    WRRC_MSG1_MED("Freq %d in 1700_2100 AWS MHz band",freq);
    return RRC_CSP_WCDMA_1700_2100_BAND;
  }

  /* Band I, 1500 banddownlink */
  if(freq >= RRC_DL_BAND_I_UARFCN_MIN &&
      freq <= RRC_DL_BAND_I_UARFCN_MAX)
  {
    WRRC_MSG1_MED("Freq %d in 1500 MHz band",freq);
    return RRC_CSP_WCDMA_1500_BAND;
  }

  /* Band J */
  i = 0;
  while(rrc_dl_band_j_addl_channels[i] != 0)
  {
    if(freq == rrc_dl_band_j_addl_channels[i])
    {
      WRRC_MSG1_MED("BC19: Freq %d in band",freq);
      return RRC_CSP_WCDMA_BC19_BAND;
    }
    i++;
  }
  /* Band J, downlink */
  if(freq >= RRC_DL_BAND_J_UARFCN_MIN &&
      freq <= RRC_DL_BAND_J_UARFCN_MAX)
  {
    WRRC_MSG1_MED("BC19: Freq %d in band",freq);
    return RRC_CSP_WCDMA_BC19_BAND;
  }

  WRRC_MSG1_MED("No valid band for freq %d, set to NONE", freq);
  return RRC_CSP_BAND_MAX;

} /* rrc_get_frequency_band */


/*===========================================================================

FUNCTION        RRCCSP_IS_MCC_AND_850_800_SUPPORTED_BAND_COMB_VALID()

DESCRIPTION     This function looks at the passed in UARFCN that belongs to
                the overlapping region of 850 and 800 bands, and determines 
                if the MCC and supported band combination is valid.
                
RETURN VALUE    Returns FAILURE if either UARFCN is invalid.

SIDE EFFECTS    None

===========================================================================*/
boolean rrccsp_is_mcc_and_850_800_supported_band_comb_valid(
  uint32 uarfcn_dl, 
  rrc_plmn_identity_type plmn_id,
  w_uarfcn_source_e_type source,
  boolean check_and_update_ui_rf_mask
) 
{
  WRRC_MSG1_HIGH("MCC_850_800: plmn-MCC %d", RRC_CSP_GET_INT_MCC(plmn_id));

  if(   (RRC_CAMPED_ON == rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_LLC))
     || (source == W_UARFCN_FROM_GSM_NBR_LIST)
     || (RRC_CSP_SPEC_PLMN == rrccsp_get_curr_type_acq()))
  {
    MSG_HIGH("MCC_850_800: UE camped status %d, acq_type is %d, g_nbr %d", 
                                             rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_NONE),
                                             rrccsp_get_curr_type_acq(), 
                                             source);

    if((   (   (RRC_CSP_GET_INT_MCC(plmn_id) == JAPAN_MCC1)
            || (RRC_CSP_GET_INT_MCC(plmn_id) == JAPAN_MCC2)
            || (RRC_CSP_GET_INT_MCC(plmn_id) == JAPAN_MCC3)
            || (RRC_CSP_GET_INT_MCC(plmn_id) == JAPAN_MCC4)
           )
        && (
               !(rrccsp_is_supported_band(RRC_CSP_WCDMA_800_BAND))
            && !( check_and_update_ui_rf_mask
                  && (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_800_BAND, 
                                                            check_and_update_ui_rf_mask))
                )
           )
        )
       ||
       (   (RRC_CSP_GET_INT_MCC(plmn_id) != JAPAN_MCC1)
        && (RRC_CSP_GET_INT_MCC(plmn_id) != JAPAN_MCC2)
        && (RRC_CSP_GET_INT_MCC(plmn_id) != JAPAN_MCC3)
        && (RRC_CSP_GET_INT_MCC(plmn_id) != JAPAN_MCC4)
        && (!rrccsp_is_supported_band(RRC_CSP_WCDMA_850_BAND))
        && !( check_and_update_ui_rf_mask
              && (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_850_BAND, 
                                                        check_and_update_ui_rf_mask))
            )
       )
      )
    {
      WRRC_MSG2_HIGH("MCC_850_800: Mismatch. Comb Invalid. plmn-MCC %d, freq %d", 
                                    RRC_CSP_GET_INT_MCC(plmn_id), uarfcn_dl);
      return FALSE;
    } 
    else
    {
      WRRC_MSG2_HIGH("MCC_850_800: Combination is valid. plmn-MCC %d, freq %d", 
                                    RRC_CSP_GET_INT_MCC(plmn_id), uarfcn_dl);
      return TRUE;
    }
  }
  /* MCC check is not needed because UE is not camped and UARFCN is not from
   * GSM and acq_type is not SPEC_PLMN
   */
  else
  {
    WRRC_MSG0_HIGH("MCC_850_800: UE NOT Camped ^ type_acq NOT SPEC_PLMN ^ not_gsm_nbr");
    return TRUE;
  }
}

#ifdef FEATURE_MCC_AND_850_800_BAND_COMBINATION
/*===========================================================================

FUNCTION        validate_dl_arfcn()

DESCRIPTION     This function validates the DL UARFCN and PLMN_id
                combination.

RETURN VALUE    FAILURE if UARFCN and PLMN_id combination is invalid,
                SUCCESS otherwise

SIDE EFFECTS    None

===========================================================================*/
uecomdef_status_e_type validate_dl_arfcn
(
    uint32                 uarfcn_dl,
    rrc_plmn_identity_type plmn_id,
    w_uarfcn_source_e_type source
  , boolean                check_and_update_ui_rf_mask
)
{
  uecomdef_status_e_type rc = FAILURE;
  boolean additional_channel = FALSE;
  
  int i = 0;

  /* The valid set of UARFCN values differs for different frequency bands.
   * If the frequency band is not supported by the UE, return failure
   */
    if((rrccsp_get_locking_nv_value() != uarfcn_dl)
        && ((rrccsp_channel_locking_nv_status() ) && !rrccsp_is_ue_in_true_limited_service()) )
    {
      WRRC_MSG0_ERROR("Channel locking is enable freq validation fails");

      return FAILURE;
    }

  WRRC_MSG1_HIGH("WCDMA Bandclass bitmask : %d",rrc_csp_int_data.wcdma_band_mask);

  if(rrccsp_is_supported_band(RRC_CSP_IMT2K_BAND))
  {
    rc = SUCCESS;

    /* Band a, downlink */
    if(uarfcn_dl < RRC_DL_BAND_A_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_A_UARFCN_MAX)
    {
      rc = FAILURE;
    }
  }

  /* If we've already found that both are valid, go ahead and return here.
   * Otherwise, go on and check band b.
   */

  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_PCS_BAND))
  {
    /* Reinitialize the return value to its optimistic state. */
    rc = SUCCESS;

    /* Band b, downlink */
    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_b_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_b_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_B_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_B_UARFCN_MAX))
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }         


  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_850_BAND)
     || rrccsp_is_supported_band(RRC_CSP_WCDMA_800_BAND))
  {
    WRRC_MSG0_MED("MCC_850_800: UE supports 850/800 bands");

    if(is_freq_in_overlapping_850_and_800_bands(uarfcn_dl))
    {
      WRRC_MSG1_HIGH("MCC_850_800: Freq %d is in overlapping region", uarfcn_dl);

      if(rrccsp_is_mcc_and_850_800_supported_band_comb_valid(uarfcn_dl, 
                                                             plmn_id, 
                                                             source
                                                             , check_and_update_ui_rf_mask
                                                             )
        )
      {
        return SUCCESS;
      }
      else
      {
        return FAILURE;
      }
    } /* DL UARFCN is in the overlapping 850 and 800 region */
    
    if(rrccsp_is_supported_band(RRC_CSP_WCDMA_850_BAND))
    {
      /* Reinitialize the return value to its optimistic state. */
      rc = SUCCESS;

      /* For 850 MHz band, check if the DL UARFCN is within the valid
       * range. If yes, return SUCCESS otherwise return FAILURE. Additional
       * channels check to be added later when additional channels are introduced
       */

      /* Band c, downlink */
      i = 0;
      additional_channel = FALSE;
      while(rrc_dl_band_c_addl_channels[i] != 0)
      {
        if(uarfcn_dl == rrc_dl_band_c_addl_channels[i])
        {
          additional_channel = TRUE;
          break;
        }
        i++;
      }

      if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_C_UARFCN_MIN ||
            uarfcn_dl > RRC_DL_BAND_C_UARFCN_MAX))
      {
        rc = FAILURE;
      }
    }

    if(rc == SUCCESS)
    {
      return rc;
    }


    if(rrccsp_is_supported_band(RRC_CSP_WCDMA_800_BAND))
    {
      /* Reinitialize the return value to its optimistic state. */
      rc = SUCCESS;

      /* For 800 MHz band, check if the DL UARFCN is within the valid
       * range. If yes, return SUCCESS otherwise return FAILURE. Additional
       * channels check to be added later when additional channels are introduced
       */

      /* Band d, downlink */
      i = 0;
      additional_channel = FALSE;
      while(rrc_dl_band_d_addl_channels[i] != 0)
      {
        if(uarfcn_dl == rrc_dl_band_d_addl_channels[i])
        {
          additional_channel = TRUE;
          break;
        }
        i++;
      }

      if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_D_UARFCN_MIN ||
            uarfcn_dl > RRC_DL_BAND_D_UARFCN_MAX))
      {
        rc = FAILURE;
      }
    }

    if(rc == SUCCESS)
    {
      return rc;
    }
  } /* 850 or 800 band */


  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_1800_BAND))
  {
    rc = SUCCESS;

    /* Band e, downlink */
    if(uarfcn_dl < RRC_DL_BAND_E_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_E_UARFCN_MAX)
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_900_BAND))
  {
    rc = SUCCESS;

    /* Band f, downlink */
    if(uarfcn_dl < RRC_DL_BAND_F_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_F_UARFCN_MAX)
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_1700_BAND))
  {
    rc = SUCCESS;

    /* Band g, downlink */
    if(uarfcn_dl < RRC_DL_BAND_G_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_G_UARFCN_MAX)
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_1700_2100_BAND))
  {
    rc = SUCCESS;

    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_h_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_h_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_H_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_H_UARFCN_MAX))
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_1500_BAND))
  {
    rc = SUCCESS;
    if(uarfcn_dl < RRC_DL_BAND_I_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_I_UARFCN_MAX)
    {
      rc = FAILURE;
    }
  }
  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_BC19_BAND))
  {
    rc = SUCCESS;

    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_j_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_j_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_J_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_J_UARFCN_MAX))
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }


  /* The UARFCN does not belong to any of the bands in the wcdma_band_mask. 
   * Check if the UARFCN belongs to any of the bands enabled in the UI && RF. 
   * If yes, then add the band to the wcdma_band_mask and return SUCCESS.
   * Also, check for UI && RF bands only when the var "check_and_update_ui_rf_mask" is 
   * set to TRUE, otherwise do NOT check for UI && RF bands.
   */
  if(check_and_update_ui_rf_mask)
  {
    if(rrccsp_is_band_class_enabled_in_ui_rf(rrc_get_frequency_band(uarfcn_dl, plmn_id), 
                                             check_and_update_ui_rf_mask))
    {
      return SUCCESS; 
    }
  }

  WRRC_MSG2_HIGH("UARFCN = %d. Band %d not supported", uarfcn_dl, rrc_get_frequency_band(uarfcn_dl, plmn_id));

  return rc;

} /* validate_dl_arfcn */

#else

/*===========================================================================

FUNCTION        validate_dl_arfcn()

DESCRIPTION     This function validates the DL UARFCN values.

RETURN VALUE    FAILURE if UARFCN is invalid,
                SUCCESS otherwise

SIDE EFFECTS    None

===========================================================================*/
uecomdef_status_e_type validate_dl_arfcn
(
  uint32 uarfcn_dl
  , boolean check_and_update_ui_rf_mask
)
{
  uecomdef_status_e_type rc = FAILURE;
  boolean additional_channel = FALSE;

  int i = 0;

  if((rrccsp_get_locking_nv_value() != uarfcn_dl)
      && ((rrccsp_channel_locking_nv_status() ) && !rrccsp_is_ue_in_true_limited_service()) )
  {
    WRRC_MSG0_ERROR("Channel locking is enable freq validation fails");

    return FAILURE;
  }

  /* The valid set of UARFCN values differs for different frequency bands.
   * If the frequency band is not supported by the UE, return failure
   */

  if(rrccsp_is_supported_band(RRC_CSP_IMT2K_BAND))
  {
    rc = SUCCESS;

    /* Band a, downlink */
    if(uarfcn_dl < RRC_DL_BAND_A_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_A_UARFCN_MAX)
    {
      rc = FAILURE;
    }
  }

  /* If we've already found that both are valid, go ahead and return here.
   * Otherwise, go on and check band b.
   */

  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_PCS_BAND))
  {
    /* Reinitialize the return value to its optimistic state. */
    rc = SUCCESS;

    /* Band b, downlink */
    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_b_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_b_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_B_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_B_UARFCN_MAX))
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_850_BAND))
  {
    /* Reinitialize the return value to its optimistic state. */
    rc = SUCCESS;

    /* For 850 MHz band, check if the DL UARFCN is within the valid
     * range. If yes, return SUCCESS otherwise return FAILURE. Additional
     * channels check to be added later when additional channels are introduced
     */

    /* Band c, downlink */
    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_c_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_c_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_C_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_C_UARFCN_MAX))
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }


  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_800_BAND))
  {
    /* Reinitialize the return value to its optimistic state. */
    rc = SUCCESS;

    /* For 800 MHz band, check if the DL UARFCN is within the valid
     * range. If yes, return SUCCESS otherwise return FAILURE. Additional
     * channels check to be added later when additional channels are introduced
     */

    /* Band d, downlink */
    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_d_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_d_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_D_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_D_UARFCN_MAX))
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_1800_BAND))
  {
    rc = SUCCESS;

    /* Band e, downlink */
    if(uarfcn_dl < RRC_DL_BAND_E_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_E_UARFCN_MAX)
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_900_BAND))
  {
    rc = SUCCESS;

    /* Band f, downlink */
    if(uarfcn_dl < RRC_DL_BAND_F_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_F_UARFCN_MAX)
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }


  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_1700_BAND))
  {
    rc = SUCCESS;

    /* Band g, downlink */
    if(uarfcn_dl < RRC_DL_BAND_G_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_G_UARFCN_MAX)
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_1700_2100_BAND))
  {
    rc = SUCCESS;

    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_h_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_h_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_H_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_H_UARFCN_MAX))
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_1500_BAND))
  {
    rc = SUCCESS;
    if(uarfcn_dl < RRC_DL_BAND_I_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_I_UARFCN_MAX)
    {
      rc = FAILURE;
    }
  }
  if(rc == SUCCESS)
  {
    return rc;
  }

  if(rrccsp_is_supported_band(RRC_CSP_WCDMA_BC19_BAND))
  {
    rc = SUCCESS;

    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_j_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_j_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_J_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_J_UARFCN_MAX))
    {
      rc = FAILURE;
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  /* The UARFCN does not belong to any of the bands in the wcdma_band_mask. 
   * Check if the UARFCN belongs to any of the bands enabled in the UI && RF. 
   * If yes, then add the band to the wcdma_band_mask and return SUCCESS.
   * Also, check for UI && RF bands only when the var "check_and_update_ui_rf_mask" is 
   * set to TRUE, otherwise do NOT check for UI && RF bands.
   *
   * Also notice that the plmn_id in rrc_csp_int_data.curr_acq_entry.plmn_id is used
   * as a dummy variable because this is the "#else" part of the feature 
   * FEATURE_MCC_AND_850_800_BAND_COMBINATION and that is why plmn_id will not
   * be used inside the function rrc_get_frequency_band().
   */
  if(check_and_update_ui_rf_mask)
  {
    if(rrccsp_is_band_class_enabled_in_ui_rf(rrc_get_frequency_band(uarfcn_dl, 
                                                 rrc_csp_int_data.curr_acq_entry.plmn_id), 
                                             check_and_update_ui_rf_mask))
    {
      return SUCCESS; 
    }
  }

  WRRC_MSG1_ERROR("Received invalid DL UARFCN %d", uarfcn_dl);

  return rc;

} /* validate_dl_arfcn */

#endif /* FEATURE_MCC_AND_850_800_BAND_COMBINATION */


#ifdef FEATURE_MCC_AND_850_800_BAND_COMBINATION
/*===========================================================================

FUNCTION        validate_fdd_frequency()

DESCRIPTION     This function validates the UARFCN (in the provided
                rrc_FrequencyFDD IE) and the PLMN_ID combination.
                Notice that the plmn_id information is used only when
                the UARFCN is in the overlapping region of 850 and 800 bands.
               
RETURN VALUE    Returns FAILURE if UARFCN and plmn_id combination is invalid.

SIDE EFFECTS    None

===========================================================================*/
uecomdef_status_e_type validate_fdd_frequency
(
  rrc_FrequencyInfoFDD *fdd_frequency,
  rrc_plmn_identity_type plmn_id
)
{
  uecomdef_status_e_type rc = FAILURE;
  boolean additional_channel = FALSE;
  boolean uarfcn_ul_present =
    (RRC_CHECK_MSG_TYPE_IE_PTR(fdd_frequency, 
uarfcn_ULPresent));
  rrc_UARFCN uarfcn_ul = 0;
  rrc_UARFCN uarfcn_dl = fdd_frequency->uarfcn_DL;
  int i = 0;

  if((rrccsp_get_locking_nv_value() != uarfcn_dl)
      && ((rrccsp_channel_locking_nv_status() ) && !rrccsp_is_ue_in_true_limited_service()) )
  {
    WRRC_MSG0_ERROR("Channel locking is enable freq validation fails");

    return FAILURE;
  }

  if(uarfcn_ul_present)
  {
    uarfcn_ul = fdd_frequency->uarfcn_UL;
  }

  /* The valid set of UARFCN values differs for different frequency bands.
   * If the frequency band is not supported by the UE, return failure
   */
  if(   (rrccsp_is_supported_band(RRC_CSP_IMT2K_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_IMT2K_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      /* Band a, uplink */
      if(uarfcn_ul < RRC_UL_BAND_A_UARFCN_MIN ||
          uarfcn_ul > RRC_UL_BAND_A_UARFCN_MAX)
      {
        rc = FAILURE;
      }
    }

    /* Band a, downlink */
    if(uarfcn_dl < RRC_DL_BAND_A_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_A_UARFCN_MAX)
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_IMT2K_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_IMT2K_BAND, TRUE));
    }
  }

  /* If we've already found that both are valid, go ahead and return here.
   * Otherwise, go on and check band b.
   */

  if(rc == SUCCESS)
  {
    return rc;
  }

  if((rrccsp_is_supported_band(RRC_CSP_PCS_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_PCS_BAND, FALSE))
    )
  {
    /* Reinitialize the return value to its optimistic state. */
    rc = SUCCESS;

    if(uarfcn_ul_present)
    {
      /* Band b, uplink */
      i = 0;
      additional_channel = FALSE;
      while(rrc_ul_band_b_addl_channels[i] != 0)
      {
        if(uarfcn_ul == rrc_ul_band_b_addl_channels[i])
        {
          additional_channel = TRUE;
          break;
        }
        i++;
      }

      if(!additional_channel && (uarfcn_ul < RRC_UL_BAND_B_UARFCN_MIN ||
            uarfcn_ul > RRC_UL_BAND_B_UARFCN_MAX))
      {
        rc = FAILURE;
      }
    }

    /* Band b, downlink */
    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_b_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_b_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_B_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_B_UARFCN_MAX))
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_PCS_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_PCS_BAND, TRUE));
    }

  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if(   (rrccsp_is_supported_band(RRC_CSP_WCDMA_850_BAND))
     || (rrccsp_is_supported_band(RRC_CSP_WCDMA_800_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_850_BAND, FALSE))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_800_BAND, FALSE))
    )
  {
    if(is_freq_in_overlapping_850_and_800_bands(uarfcn_dl))
    {
      WRRC_MSG1_HIGH("MCC_850_800: Freq %d is in overlapping region", uarfcn_dl);

      if(rrccsp_is_mcc_and_850_800_supported_band_comb_valid(uarfcn_dl, 
                                                             plmn_id, 
                                                             W_UARFCN_NOT_FROM_GSM_NBR_LIST
                                                             , TRUE
                                                             )
        )
      {
        return SUCCESS;
      }
      else
      {
        return FAILURE;
      }
    } /* DL UARFCN is in the overlapping 850 and 800 region */

    if((rrccsp_is_supported_band(RRC_CSP_WCDMA_850_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_850_BAND, FALSE))
      )
    {
      /* Reinitialize the return value to its optimistic state. */
      rc = SUCCESS;
  
      /* For 850 MHz band, check if the UL and DL UARFCN is within the valid
       * range. If yes, return SUCCESS otherwise return FAILURE. Additional
       * channels check to be added later when additional channels are introduced
       */
  
      if(uarfcn_ul_present)
      {
        /* Band c, uplink */
        i = 0;
        additional_channel = FALSE;
        while(rrc_ul_band_c_addl_channels[i] != 0)
        {
          if(uarfcn_ul == rrc_ul_band_c_addl_channels[i])
          {
            additional_channel = TRUE;
            break;
          }
          i++;
        }
  
        if(!additional_channel && (uarfcn_ul < RRC_UL_BAND_C_UARFCN_MIN ||
              uarfcn_ul > RRC_UL_BAND_C_UARFCN_MAX))
        {
          rc = FAILURE;
        }
      }
  
      /* Band c, downlink */
      i = 0;
      additional_channel = FALSE;
      while(rrc_dl_band_c_addl_channels[i] != 0)
      {
        if(uarfcn_dl == rrc_dl_band_c_addl_channels[i])
        {
          additional_channel = TRUE;
          break;
        }
        i++;
      }
  
      if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_C_UARFCN_MIN ||
            uarfcn_dl > RRC_DL_BAND_C_UARFCN_MAX))
      {
        rc = FAILURE;
      }

      /* If 
       * (1) uarfcn is within ul and dl ranges, and 
       * (2) the band is not already present in the wcdma_band_mask
       * then 
       *     Add the band to the wcdma_band_mask
       */
      if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_850_BAND)))
      {
        (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_850_BAND, TRUE));
      }

    }
  
    if(rc == SUCCESS)
    {
      return rc;
    }
  
  
    if((rrccsp_is_supported_band(RRC_CSP_WCDMA_800_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_800_BAND, FALSE))
      )
    {
      /* Reinitialize the return value to its optimistic state. */
      rc = SUCCESS;
  
      /* For 800 MHz band, check if the UL and DL UARFCN is within the valid
       * range. If yes, return SUCCESS otherwise return FAILURE. Additional
       * channels check to be added later when additional channels are introduced
       */
  
      if(uarfcn_ul_present)
      {
        /* Band d, uplink */
        i = 0;
        additional_channel = FALSE;
        while(rrc_ul_band_d_addl_channels[i] != 0)
        {
          if(uarfcn_ul == rrc_ul_band_d_addl_channels[i])
          {
            additional_channel = TRUE;
            break;
          }
          i++;
        }
  
        if(!additional_channel && (uarfcn_ul < RRC_UL_BAND_D_UARFCN_MIN ||
              uarfcn_ul > RRC_UL_BAND_D_UARFCN_MAX))
        {
          rc = FAILURE;
        }
      }
  
      /* Band d, downlink */
      i = 0;
      additional_channel = FALSE;
      while(rrc_dl_band_d_addl_channels[i] != 0)
      {
        if(uarfcn_dl == rrc_dl_band_d_addl_channels[i])
        {
          additional_channel = TRUE;
          break;
        }
        i++;
      }
  
      if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_D_UARFCN_MIN ||
            uarfcn_dl > RRC_DL_BAND_D_UARFCN_MAX))
      {
        rc = FAILURE;
      }

      /* If 
       * (1) uarfcn is within ul and dl ranges, and 
       * (2) the band is not already present in the wcdma_band_mask
       * then 
       *     Add the band to the wcdma_band_mask
       */
      if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_800_BAND)))
      {
        (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_800_BAND, TRUE));
      }

    }
  
    if(rc == SUCCESS)
    {
      return rc;
    }
  }

  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_1800_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1800_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      /* Band e, uplink */
      if(uarfcn_ul < RRC_UL_BAND_E_UARFCN_MIN ||
          uarfcn_ul > RRC_UL_BAND_E_UARFCN_MAX)
      {
        rc = FAILURE;
      }
    }

    /* Band e, downlink */
    if(uarfcn_dl < RRC_DL_BAND_E_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_E_UARFCN_MAX)
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_1800_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1800_BAND, TRUE));
    }

  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_900_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_900_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      /* Band f, uplink */
      if(uarfcn_ul < RRC_UL_BAND_F_UARFCN_MIN ||
          uarfcn_ul > RRC_UL_BAND_F_UARFCN_MAX)
      {
        rc = FAILURE;
      }
    }

    /* Band f, downlink */
    if(uarfcn_dl < RRC_DL_BAND_F_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_F_UARFCN_MAX)
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_900_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_900_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_1700_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1700_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      /* Band g, uplink */
      if(uarfcn_ul < RRC_UL_BAND_G_UARFCN_MIN ||
          uarfcn_ul > RRC_UL_BAND_G_UARFCN_MAX)
      {
        rc = FAILURE;
      }
    }

    /* Band g, downlink */
    if(uarfcn_dl < RRC_DL_BAND_G_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_G_UARFCN_MAX)
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_1700_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1700_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_1700_2100_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1700_2100_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      /* Band h, uplink */
      i = 0;
      additional_channel = FALSE;
      while(rrc_ul_band_h_addl_channels[i] != 0)
      {
        if(uarfcn_ul == rrc_ul_band_h_addl_channels[i])
        {
          additional_channel = TRUE;
          break;
        }
        i++;
      }

      if(!additional_channel && (uarfcn_ul < RRC_UL_BAND_H_UARFCN_MIN ||
            uarfcn_ul > RRC_UL_BAND_H_UARFCN_MAX))
      {
        rc = FAILURE;
      }
    }

    /* Band h, downlink */
    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_h_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_h_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_H_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_H_UARFCN_MAX))
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_1700_2100_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1700_2100_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_1500_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1500_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      if((uarfcn_ul < RRC_UL_BAND_I_UARFCN_MIN ||
            uarfcn_ul > RRC_UL_BAND_I_UARFCN_MAX))
      {
        rc = FAILURE;
      }
    }

    if((uarfcn_dl < RRC_DL_BAND_I_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_I_UARFCN_MAX))
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_1500_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1500_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_BC19_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_BC19_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      /* Band J, uplink */
      i = 0;
      additional_channel = FALSE;
      while(rrc_ul_band_j_addl_channels[i] != 0)
      {
        if(uarfcn_ul == rrc_ul_band_j_addl_channels[i])
        {
          additional_channel = TRUE;
          break;
        }
        i++;
      }

      if(!additional_channel && (uarfcn_ul < RRC_UL_BAND_J_UARFCN_MIN ||
            uarfcn_ul > RRC_UL_BAND_J_UARFCN_MAX))
      {
        rc = FAILURE;
      }
    }

    /* Band J, downlink */
    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_j_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_j_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_J_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_J_UARFCN_MAX))
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_BC19_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_BC19_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }


  WRRC_MSG2_ERROR("Received invalid freq info, UARFCN UL %d DL %d", uarfcn_ul,
        uarfcn_dl);

  return rc;

} /* validate_fdd_frequency */

#else

/*===========================================================================

FUNCTION        validate_fdd_frequency()

DESCRIPTION     This function validates the UARFCN in the provided
                rrc_FrequencyFDD IE.
                               
RETURN VALUE    Returns FAILURE if UARFCN is invalid.

SIDE EFFECTS    None

===========================================================================*/
uecomdef_status_e_type validate_fdd_frequency
(
  rrc_FrequencyInfoFDD *fdd_frequency
)
{
  uecomdef_status_e_type rc = FAILURE;
  boolean additional_channel = FALSE;
  boolean uarfcn_ul_present =
    (RRC_CHECK_MSG_TYPE_IE_PTR(fdd_frequency, 
               uarfcn_ULPresent));
  rrc_UARFCN uarfcn_ul = 0;
  rrc_UARFCN uarfcn_dl = fdd_frequency->uarfcn_DL;
  int i = 0;

  if((rrccsp_get_locking_nv_value() != uarfcn_dl)
      && ((rrccsp_channel_locking_nv_status() ) && !rrccsp_is_ue_in_true_limited_service()) )
  {
    WRRC_MSG0_ERROR("Channel locking is enable freq validation fails");

    return FAILURE;
  }

  WRRC_MSG1_HIGH("WCDMA Bandclass bitmask : %d",rrc_csp_int_data.wcdma_band_mask);

  if(uarfcn_ul_present)
  {
    uarfcn_ul = fdd_frequency->uarfcn_UL;
  }

  /* The valid set of UARFCN values differs for different frequency bands.
   * If the frequency band is not supported by the UE, return failure
   */

  if((rrccsp_is_supported_band(RRC_CSP_IMT2K_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_IMT2K_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      /* Band a, uplink */
      if(uarfcn_ul < RRC_UL_BAND_A_UARFCN_MIN ||
          uarfcn_ul > RRC_UL_BAND_A_UARFCN_MAX)
      {
        rc = FAILURE;
      }
    }

    /* Band a, downlink */
    if(uarfcn_dl < RRC_DL_BAND_A_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_A_UARFCN_MAX)
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_IMT2K_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_IMT2K_BAND, TRUE));
    }
  }

  /* If we've already found that both are valid, go ahead and return here.
   * Otherwise, go on and check band b.
   */

  if(rc == SUCCESS)
  {
    return rc;
  }

  if((rrccsp_is_supported_band(RRC_CSP_PCS_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_PCS_BAND, FALSE))
    )
  {
    /* Reinitialize the return value to its optimistic state. */
    rc = SUCCESS;

    if(uarfcn_ul_present)
    {
      /* Band b, uplink */
      i = 0;
      additional_channel = FALSE;
      while(rrc_ul_band_b_addl_channels[i] != 0)
      {
        if(uarfcn_ul == rrc_ul_band_b_addl_channels[i])
        {
          additional_channel = TRUE;
          break;
        }
        i++;
      }

      if(!additional_channel && (uarfcn_ul < RRC_UL_BAND_B_UARFCN_MIN ||
            uarfcn_ul > RRC_UL_BAND_B_UARFCN_MAX))
      {
        rc = FAILURE;
      }
    }

    /* Band b, downlink */
    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_b_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_b_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_B_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_B_UARFCN_MAX))
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_PCS_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_PCS_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_850_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_850_BAND, FALSE))
    )
  {
    /* Reinitialize the return value to its optimistic state. */
    rc = SUCCESS;

    /* For 850 MHz band, check if the UL and DL UARFCN is within the valid
     * range. If yes, return SUCCESS otherwise return FAILURE. Additional
     * channels check to be added later when additional channels are introduced
     */

    if(uarfcn_ul_present)
    {
      /* Band c, uplink */
      i = 0;
      additional_channel = FALSE;
      while(rrc_ul_band_c_addl_channels[i] != 0)
      {
        if(uarfcn_ul == rrc_ul_band_c_addl_channels[i])
        {
          additional_channel = TRUE;
          break;
        }
        i++;
      }

      if(!additional_channel && (uarfcn_ul < RRC_UL_BAND_C_UARFCN_MIN ||
            uarfcn_ul > RRC_UL_BAND_C_UARFCN_MAX))
      {
        rc = FAILURE;
      }
    }

    /* Band c, downlink */
    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_c_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_c_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_C_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_C_UARFCN_MAX))
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_850_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_850_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }


  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_800_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_800_BAND, FALSE))
    )
  {
    /* Reinitialize the return value to its optimistic state. */
    rc = SUCCESS;

    /* For 800 MHz band, check if the UL and DL UARFCN is within the valid
     * range. If yes, return SUCCESS otherwise return FAILURE. Additional
     * channels check to be added later when additional channels are introduced
     */

    if(uarfcn_ul_present)
    {
      /* Band d, uplink */
      i = 0;
      additional_channel = FALSE;
      while(rrc_ul_band_d_addl_channels[i] != 0)
      {
        if(uarfcn_ul == rrc_ul_band_d_addl_channels[i])
        {
          additional_channel = TRUE;
          break;
        }
        i++;
      }

      if(!additional_channel && (uarfcn_ul < RRC_UL_BAND_D_UARFCN_MIN ||
            uarfcn_ul > RRC_UL_BAND_D_UARFCN_MAX))
      {
        rc = FAILURE;
      }
    }

    /* Band d, downlink */
    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_d_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_d_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_D_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_D_UARFCN_MAX))
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_800_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_800_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }
  
  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_1800_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1800_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      /* Band e, uplink */
      if(uarfcn_ul < RRC_UL_BAND_E_UARFCN_MIN ||
          uarfcn_ul > RRC_UL_BAND_E_UARFCN_MAX)
      {
        rc = FAILURE;
      }
    }

    /* Band e, downlink */
    if(uarfcn_dl < RRC_DL_BAND_E_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_E_UARFCN_MAX)
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_1800_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1800_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_900_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_900_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      /* Band f, uplink */
      if(uarfcn_ul < RRC_UL_BAND_F_UARFCN_MIN ||
          uarfcn_ul > RRC_UL_BAND_F_UARFCN_MAX)
      {
        rc = FAILURE;
      }
    }

    /* Band f, downlink */
    if(uarfcn_dl < RRC_DL_BAND_F_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_F_UARFCN_MAX)
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_900_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_900_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_1700_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1700_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      /* Band g, uplink */
      if(uarfcn_ul < RRC_UL_BAND_G_UARFCN_MIN ||
          uarfcn_ul > RRC_UL_BAND_G_UARFCN_MAX)
      {
        rc = FAILURE;
      }
    }

    /* Band g, downlink */
    if(uarfcn_dl < RRC_DL_BAND_G_UARFCN_MIN ||
        uarfcn_dl > RRC_DL_BAND_G_UARFCN_MAX)
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_1700_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1700_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_1700_2100_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1700_2100_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      /* Band h, uplink */
      i = 0;
      additional_channel = FALSE;
      while(rrc_ul_band_h_addl_channels[i] != 0)
      {
        if(uarfcn_ul == rrc_ul_band_h_addl_channels[i])
        {
          additional_channel = TRUE;
          break;
        }
        i++;
      }

      if(!additional_channel && (uarfcn_ul < RRC_UL_BAND_H_UARFCN_MIN ||
            uarfcn_ul > RRC_UL_BAND_H_UARFCN_MAX))
      {
        rc = FAILURE;
      }
    }

    /* Band h, downlink */
    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_h_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_h_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_H_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_H_UARFCN_MAX))
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_1700_2100_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1700_2100_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }

  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_1500_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1500_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      if((uarfcn_ul < RRC_UL_BAND_I_UARFCN_MIN ||
            uarfcn_ul > RRC_UL_BAND_I_UARFCN_MAX))
      {
        rc = FAILURE;
      }
    }

    if((uarfcn_dl < RRC_DL_BAND_I_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_I_UARFCN_MAX))
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_1500_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_1500_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }


  if((rrccsp_is_supported_band(RRC_CSP_WCDMA_BC19_BAND))
     || (rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_BC19_BAND, FALSE))
    )
  {
    rc = SUCCESS;
    if(uarfcn_ul_present)
    {
      /* Band J, uplink */
      i = 0;
      additional_channel = FALSE;
      while(rrc_ul_band_j_addl_channels[i] != 0)
      {
        if(uarfcn_ul == rrc_ul_band_j_addl_channels[i])
        {
          additional_channel = TRUE;
          break;
        }
        i++;
      }

      if(!additional_channel && (uarfcn_ul < RRC_UL_BAND_J_UARFCN_MIN ||
            uarfcn_ul > RRC_UL_BAND_J_UARFCN_MAX))
      {
        rc = FAILURE;
      }
    }

    /* Band J, downlink */
    i = 0;
    additional_channel = FALSE;
    while(rrc_dl_band_j_addl_channels[i] != 0)
    {
      if(uarfcn_dl == rrc_dl_band_j_addl_channels[i])
      {
        additional_channel = TRUE;
        break;
      }
      i++;
    }

    if(!additional_channel && (uarfcn_dl < RRC_DL_BAND_J_UARFCN_MIN ||
          uarfcn_dl > RRC_DL_BAND_J_UARFCN_MAX))
    {
      rc = FAILURE;
    }

    /* If 
     * (1) uarfcn is within ul and dl ranges, and 
     * (2) the band is not already present in the wcdma_band_mask
     * then 
     *     Add the band to the wcdma_band_mask
     */
    if((rc == SUCCESS) && !(rrccsp_is_supported_band(RRC_CSP_WCDMA_BC19_BAND)))
    {
      (void)(rrccsp_is_band_class_enabled_in_ui_rf(RRC_CSP_WCDMA_BC19_BAND, TRUE));
    }
  }

  if(rc == SUCCESS)
  {
    return rc;
  }


  WRRC_MSG2_ERROR("Received invalid freq info, UARFCN UL %d DL %d", uarfcn_ul,
        uarfcn_dl);

  return rc;

} /* validate_fdd_frequency */

#endif /* FEATURE_MCC_AND_850_800_BAND_COMBINATION */

/*===========================================================================

FUNCTION        validate_frequency_info()

DESCRIPTION     This function validates the UARFCN values in the provided
                Frequency Info IE according to table 5.2 in 25.101.

RETURN VALUE    Returns FAILURE if either UARFCN is invalid.

SIDE EFFECTS    None

===========================================================================*/
uecomdef_status_e_type validate_frequency_info
(
  rrc_FrequencyInfo *ie_ptr
)
{
  /* We only support FDD. */
  if(!(RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo, 
              T_rrc_FrequencyInfo_modeSpecificInfo_fdd)))
  {
    return FAILURE;
  }
  else
  {
#ifdef FEATURE_MCC_AND_850_800_BAND_COMBINATION
    return (validate_fdd_frequency(ie_ptr->modeSpecificInfo.u.fdd, 
                                   rrc_ccm_get_curr_camped_plmn()));
#else
    return (validate_fdd_frequency(ie_ptr->modeSpecificInfo.u.fdd));
#endif
  }
} /* validate_frequency_info */


/*===========================================================================
FUNCTION        get_frequency_info()

DESCRIPTION     This function validates and stores the Frequency Info for
                reconfiguration messages.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    The dest_frequency information in ordered config is updated.
===========================================================================*/
uecomdef_status_e_type get_frequency_info
(
  rrc_FrequencyInfo *ie_ptr,
  rrc_RRC_StateIndicator next_state
)
{
  rrc_state_e_type rrc_state;
  rrc_freq_type rrc_freq;
  rrc_freq_type new_freq;

  /* Make sure the provided frequency info is within range. */
  if(validate_frequency_info(ie_ptr) == FAILURE)
  {
    return FAILURE;
  }

  new_freq = (rrc_freq_type)ie_ptr->modeSpecificInfo.u.fdd->uarfcn_DL;
  rrc_freq = rrc_ccm_get_curr_camped_freq();

  rrc_state = rrc_get_state();
  if(rrc_state == RRC_STATE_CELL_DCH)
  {
    if(rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_LLC) ==
        RRC_NOT_CAMPED_ON)
    {
      WRRC_MSG0_ERROR("Can't process freq info IE, not camped");
      return FAILURE;
    }

    switch(next_state)
    {
      case rrc_RRC_StateIndicator_cell_DCH:
      case rrc_RRC_StateIndicator_cell_FACH:
      case rrc_RRC_StateIndicator_cell_PCH:
      case rrc_RRC_StateIndicator_ura_PCH:

        ordered_config_ptr->dest_freq = new_freq;
        ordered_config_ptr->dest_freq_present = TRUE;
         /* timingMaintainedSynchInd  IE is valid only 
          * if the Frequency info is present in OTA. 
          */
        ordered_config_ptr->tm_sync_ind_applicable =
                 ordered_config_ptr->tm_sync_ind_applicable |
                           RRCLLC_FREQ_INFO_PRESENT_IN_OTA;
        WRRC_MSG2_HIGH("Camped freq %d, new freq %d", rrc_freq, new_freq);
        if(rrc_freq == new_freq)
        {
          WRRC_MSG0_HIGH("Sync A procedure triggered");
        }
        else
        {
          WRRC_MSG0_HIGH("Inter-freq HHO triggered");
        }
        break;

      default:
        WRRC_MSG1_ERROR("Invalid next state %d processing freq info", next_state);
        break;
    }
  }
  else if(rrc_state == RRC_STATE_CELL_FACH ||
          rrc_state == RRC_STATE_CONNECTING)
  {
    if(rrc_ccm_get_curr_camping_status(RRC_PROCEDURE_LLC) ==
        RRC_NOT_CAMPED_ON)
    {
      WRRC_MSG0_ERROR("Can't process freq info IE, not camped");
      return FAILURE;
    }

    switch(next_state)
    {
      case rrc_RRC_StateIndicator_cell_DCH:
        ordered_config_ptr->dest_freq = new_freq;
        ordered_config_ptr->dest_freq_present = TRUE;
         /* timingMaintainedSynchInd  IE is valid only 
          * if the Frequency info is present in OTA. 
          */
        ordered_config_ptr->tm_sync_ind_applicable =
                 ordered_config_ptr->tm_sync_ind_applicable |
                           RRCLLC_FREQ_INFO_PRESENT_IN_OTA;

        WRRC_MSG2_HIGH("Camped freq %d, new freq %d", rrc_freq, new_freq);
        if(rrc_freq == new_freq)
        {
          WRRC_MSG0_HIGH("Sync A procedure triggered");
        }
        else
        {
          WRRC_MSG0_HIGH("Inter-freq HHO triggered");

          /* Later on, we must check to make sure we have received Doff
           * if this is a timing-initialized hard handover.
           */
          check_hho_cfn_handling = TRUE;
        }
        break;

      case rrc_RRC_StateIndicator_cell_FACH:
        if(rrc_freq == new_freq)
        {
          ordered_config_ptr->dest_freq = new_freq;
          ordered_config_ptr->dest_freq_present = TRUE;
          WRRC_MSG2_HIGH("Camped freq %d, new freq %d Sync A procedure triggered", rrc_freq, new_freq);
        }
        ordered_config_ptr->dest_freq = new_freq;
        ordered_config_ptr->dest_freq_present = TRUE;
        WRRC_MSG2_HIGH("Within FACH Camped freq %d, new freq %d", rrc_freq, new_freq);
        break;
     case rrc_RRC_StateIndicator_cell_PCH:
     case rrc_RRC_StateIndicator_ura_PCH:
        if(rrc_freq == new_freq)
        {
          ordered_config_ptr->dest_freq = new_freq;
          ordered_config_ptr->dest_freq_present = TRUE;
        }
        ordered_config_ptr->dest_freq = new_freq;
        ordered_config_ptr->dest_freq_present = TRUE;
        WRRC_MSG2_HIGH("FACH->PCH Camped freq %d, new freq %d", rrc_freq, new_freq);
        break;
      default:
        WRRC_MSG2_HIGH("No action on freq info: state %d->%d", rrc_state,
            next_state);
        break;
    }
  }
  else
  {
    WRRC_MSG1_ERROR("No action on freq info in state %d", rrc_state);
  }

  return SUCCESS;
} /* end get_frequency_info() */

/*===========================================================================
FUNCTION        get_cell_id_per_rl_list()

DESCRIPTION    
  This function is called to fill Cell_Id in cell_id_per_rl. 
  Cell_Id is given for each of RLs that are given in
  IE rrc_DL_InformationPerRL_List.

RETURN VALUE    
  SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    
===========================================================================*/
uecomdef_status_e_type get_cell_id_per_rl_list
(
  rrc_CellIdentity_PerRL_List *ie_ptr_cell_id_PerRL_List,
  rrc_DL_InformationPerRL_List *ie_ptr_dl_info_perRL_List
)
{
  uint16 rl_idx =0, psc =0;
  uint32 cell_id = 0;
  uint32 n_value_cell_id=0, n_value_dl_info=0;
  uint32 n_index = 0;

  /*No. of RLs and no. of Cell_ids should be same.*/  
  n_value_cell_id = ie_ptr_cell_id_PerRL_List->n;
  n_value_dl_info = ie_ptr_dl_info_perRL_List->n;
  
  while((n_value_cell_id != 0) && (n_value_dl_info != 0))
  {
    psc = (uint16) ie_ptr_dl_info_perRL_List->elem[n_index].modeSpecificInfo.u.fdd->
            primaryCPICH_Info.primaryScramblingCode;
    cell_id = (uint32) rrc_translate_cell_id(&(ie_ptr_cell_id_PerRL_List->elem[n_index]));

    /*First get the rl_idx at which PSC is present in OC.*/ 
    if((rl_idx = rrc_get_rl_idx_for_psc(psc)) == L1_MAX_RL)
    {
      WRRC_MSG2_ERROR("PSC %d not found in OC. Cell id %d",psc,cell_id);
      return FAILURE;
    }
    else
    {
      cell_id_per_rl[rl_idx] = cell_id;
    }
    n_value_cell_id--;
    n_value_dl_info--;
    n_index++;
  }
  return SUCCESS;
}

/*===========================================================================
FUNCTION        get_cell_id_per_rl_list()

DESCRIPTION    
  This function is called to fill Cell_Id in cell_id_per_rl. 
  Cell_Id is given for each of RLs that are given in
  IE rrc_RL_AdditionInformationList.

RETURN VALUE    
  SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    
===========================================================================*/
uecomdef_status_e_type get_cell_id_per_rl_list_for_asu
(
  rrc_CellIdentity_PerRL_List *ie_ptr_cell_id_PerRL_List,
  rrc_RL_AdditionInformationList *ie_ptr_RL_add_info_List
)
{
  uint16 rl_idx =0, psc =0;
  uint32 cell_id = 0;
  uint32 n_value_cell_id=0, n_value_rl_add_info=0;
  uint32 n_index = 0;
  
  /*No. of RLs and no. of Cell_ids should be same.*/  
  n_value_cell_id = ie_ptr_cell_id_PerRL_List->n;
  n_value_rl_add_info = ie_ptr_RL_add_info_List->n;
  
  while((n_value_cell_id != 0) && (n_value_rl_add_info != 0))
  {
    psc = (uint16) ie_ptr_RL_add_info_List->elem[n_index].primaryCPICH_Info.primaryScramblingCode;
    cell_id = (uint32) rrc_translate_cell_id(&(ie_ptr_cell_id_PerRL_List->elem[n_index]));

    /*First get the rl_idx at which PSC is present in OC.*/ 
    if((rl_idx = rrc_get_rl_idx_for_psc(psc)) == L1_MAX_RL)
    {
      WRRC_MSG2_ERROR("PSC %d not found in OC. Cell id %d",psc,cell_id);
      return FAILURE;
    }
    else
    {
      cell_id_per_rl[rl_idx] = cell_id;
    }

    n_value_cell_id--;
    n_value_rl_add_info--;
    n_index++;
  }
  return SUCCESS;
}

/*===========================================================================
FUNCTION        get_dl_info_per_rl()

DESCRIPTION     This function validates and stores Downlink Information Per
                Radio Link for reconfiguration messages.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    Ordered config is updated with the new RL info.
===========================================================================*/
uecomdef_status_e_type get_dl_info_per_rl
(
  rrc_DL_InformationPerRL_List *ie_ptr,
  rrc_RRC_StateIndicator next_state
)
{
  uint8 idx;
  uint8 rl_count = 0;
  /* is_hho flag indicates if it is one of Inter Freq or Intra Freq HHO */
  boolean is_hho;

  /* is_inter_freq flag indicates if it is an Inter Freq HHO */
  boolean is_inter_freq;

  boolean old_rl_seen = FALSE;

  /* new_rl_seen indicates that new RLs are seen which is always TRUE for HHOs */
  boolean new_rl_seen = FALSE;

  rrc_DL_InformationPerRL_List *tmp_ie_ptr = ie_ptr;

  rrc_DL_InformationPerRL_List *tmp_ptr = ie_ptr;

  boolean was_rl_db_empty = FALSE;
  rrcllcoc_dl_info_per_rl_status_e_type status =
    RRCLLCOC_DL_INFO_PER_RL_IGNORED;
  rrc_freq_type rrc_freq = rrc_ccm_get_curr_camped_freq();
  rrc_state_e_type rrc_state = rrc_get_state();
 
  uint32 n_index_temp=0; 

  ordered_config_ptr->dest_psc_present = FALSE;


  /* We can say with certainty that if frequency info is included, and
   * it is different than the current frequency, then we are doing a
   * hard handover.  If this is not the case, we revisit this flag
   * later.
   */
  is_inter_freq = is_hho = (ordered_config_ptr->dest_freq_present &&
                            ordered_config_ptr->dest_freq != rrc_freq);

  if((rrccsp_channel_locking_nv_status()) && !rrccsp_is_ue_in_true_limited_service() &&
      is_inter_freq )
  {
    WRRC_MSG0_HIGH("Failing, inter-freq HHO not supported");
    return(FAILURE);
  }

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    if ((is_inter_freq) && (rrc_get_hsdpa_status() == HSDPA_ACTIVE) && 
        (next_state == rrc_RRC_StateIndicator_cell_DCH) && 
        (rrc_state == RRC_STATE_CELL_DCH))
    {
      WRRC_MSG0_HIGH("RRCHS:InterFreq HO with R99");
      hsdpa_msg_params.ifhho_involved = 
        hsdpa_msg_params.msg_params_present = TRUE;
    }
  }


  if(next_state == rrc_RRC_StateIndicator_cell_DCH)
  {
    /* If DPCH Info per RL is not present within DL Info per RL, then ignore it and
     * do not change the RL Info list in OC when going from DCH->DCH.
     * When going from non-DCH->DCH, the above condition should result in a Failure.
     */
    if((RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index_temp].modeSpecificInfo, 
                  T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd)) &&
       ((RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index_temp], 
                dl_DPCH_InfoPerRLPresent)) == 0))
    {
      if(rrc_state == RRC_STATE_CELL_DCH)
      {
        /* Remove this check later - need to process rest of RL Info elements */
        WRRC_MSG0_HIGH("Ignoring DL Info per RL,DPCH Info not present");
        return(SUCCESS);
      }
      else
      {
        WRRC_MSG0_HIGH("Failing, DPCH Info per RL not present");
        return(FAILURE);
      }
    }

    /* Did we have any radio links in our database previously? */
    was_rl_db_empty = (ordered_config_ptr->l1_dl_chan_parms.num_rl == 0);

    if(rrc_state != RRC_STATE_CELL_DCH)
    {
      /* Going from non-DCH state to CELL DCH */
      /* Always set new_rl_seen when coming to DCH from a non-DCH state.
       * That ensures the RL Info is populated after initializing.
       */
      new_rl_seen = TRUE;

      if(!is_inter_freq)
      {
        /* Also loop thru and check if the current camped on PSC is in RL Info.
         * If so, force Frequency_info to FALSE.
         */
        if(is_current_camped_psc_in_rl_info(ie_ptr))
        {
          ordered_config_ptr->dest_freq_present = FALSE;
        }
        else  /* Intra freq HHO */
        {
          ordered_config_ptr->dest_freq_present = TRUE;
          ordered_config_ptr->dest_freq = rrc_freq;
          WRRC_MSG0_HIGH("Disjoint ASET, intra-f HHO FACH->DCH");
        }
      }
    }
    else       /* Going from DCH->DCH */
    {
      /* Unless we are doing an inter-frequency hard handover, we cannot
       * take a set of radio links that contains scrambling codes we
       * already have in our database as well as ones that we don't have
       * in our database. (25.331 8.6.6.3a)
       */
      if(!is_inter_freq)
      {
        while(tmp_ie_ptr->n > n_index_temp )
        {
          if(get_dl_rl_idx_to_update(
           tmp_ie_ptr->elem[n_index_temp].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode,
           RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index_temp].modeSpecificInfo, 
                    T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd),
            &ordered_config_ptr->l1_dl_chan_parms) <
            UE_MAX_RL )
          {
            old_rl_seen = TRUE;
          }
          else
          {
            new_rl_seen = TRUE;
          }

          /* We can bail out early if we detect a mixed active set. */
          if(old_rl_seen && new_rl_seen)
          {
            WRRC_MSG0_ERROR("Mixed ASET detected, rejecting");
            return FAILURE;
          }

          n_index_temp++;
        }
      }
      else
      {
        /* New RLs always seen for Inter freq HHO */
        new_rl_seen = TRUE;
      }
    } /* DCH->DCH */
    n_index_temp =0;
    while(ie_ptr->n > n_index_temp)
    {
      if(rrc_state != RRC_STATE_CELL_DCH)
      {
        /* For a non-DCH to DCH transition, there is no existing RL Info */
        idx = rl_count;
      }
      else if(is_inter_freq)
      {
        /* We've found this radio link in our database, but we are
         * doing an inter-frequency hard handover, which means that
         * we are replacing the active set.  This is a case where
         * the primary scrambling code on the new frequency is the
         * same as on the old one.  We need to adjust our radio link
         * index accordingly, since we don't want to place the new
         * radio link into the database position of the old one.
         */
        idx = rl_count;
      }
      else /* DCH -> DCH AND Not Inter Freq */
      {
        /* Now look to see if this radio link is already in our
         * database.
         */

       idx =  get_dl_rl_idx_to_update(
           ie_ptr->elem[n_index_temp].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode,
           RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index_temp].modeSpecificInfo,
                    T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd),
          &ordered_config_ptr->l1_dl_chan_parms);
        

        if(idx == UE_MAX_RL)
        {
          /* This radio link is not in our database, which means we're
           * replacing our database with an entirely new set of radio
           * links.  We must reset the value of the database index to
           * the current radio link count.
           */
          idx = rl_count;

          is_hho = TRUE;
          if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
          {
            if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
            {
              WRRC_MSG0_HIGH("RRCHS:IntraFreq Hard HO with R99");
              hsdpa_msg_params.intra_hho_involved = 
                hsdpa_msg_params.msg_params_present = TRUE;
            }
          }
          

        } /* idx == UE_MAX_RL */
      } /* DCH -> DCH AND Not Inter Freq */

      /* Process the IE and place the info into our database. */
      status = get_dl_info_for_each_rl(&ie_ptr->elem[n_index_temp],
                                       &ordered_config_ptr->l1_dl_chan_parms,
                                       idx,
                                       new_rl_seen);

      if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
      {
        return FAILURE;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_IGNORED)
      {
        continue;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS)
      {
        if(is_hho)
        {
          /* If we succeeded in processing the IE, and we are doing a
           * hard handover, we must be sure that L1 is informed by
           * sending frequency info, even if we didn't get frequency
           * info in the reconfiguration message.
           */
          if(!ordered_config_ptr->dest_freq_present)
          {
            ordered_config_ptr->dest_freq_present = TRUE;
            ordered_config_ptr->dest_freq = rrc_freq;
            WRRC_MSG0_HIGH("Disjoint ASET, intra-f HHO triggered");
          }

          /* Later on, we must check to make sure we have received Doff
           * if this is a timing-initialized hard handover.
           */

          /* check_hho_cfn_handling = TRUE; */
        }
      }

      rl_count++;
      n_index_temp++;
    }

    /* Here we check to see if "Default DPCH Offset Value" and "DPCH frame offset" respect the following
         * relation : "Default DPCH Offset Value" % 38400 = "DPCH frame offset" as per 8.6.6.14 in 25.331
         * We have to do this validation only when we enter DCH the first time or if it is a Timing Initialized HHO 
         * Checking only 0th location...no loop here. 
         */
    if ( (rrc_state != RRC_STATE_CELL_DCH) ||
         (is_hho && ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind == L1_TIMING_IND_INIT) )
    {
      if((RRC_CHECK_MSG_TYPE(tmp_ptr->elem[0].modeSpecificInfo,
                  T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd)) &&
         (RRC_CHECK_MSG_TYPE_IE(tmp_ptr->elem[0], 
                  dl_DPCH_InfoPerRLPresent)))
      {
        if ( (ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset % 38400) !=
             (tmp_ptr->elem[0].dl_DPCH_InfoPerRL.u.fdd->dpch_FrameOffset * RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR) )
        {
          WRRC_MSG2_ERROR("Validation of DOFF %d and DPCH frame offset %d fail",
              ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
              (tmp_ptr->elem[0].dl_DPCH_InfoPerRL.u.fdd->dpch_FrameOffset *
               RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR));
          return (FAILURE);
        }
      }
    }

    /* Call below function to wipe out any stored L1 information
     * on EUL
     */
    if (is_hho) 
    {
      rrcllc_clean_l1_e_info_on_non_r6_hho();
    }

    if(is_hho || was_rl_db_empty)
    {
      /* We've just replaced the contents of our radio link database, or
       * added radio links when we had none before, so we must update the
       * count of the radio links contained therein.
       */
      ordered_config_ptr->l1_dl_chan_parms.num_rl = rl_count;

      /* Clear out old scrambling codes. */
      while(rl_count < UE_MAX_RL)
      {

        /*We need to invalidate the Cell_Id corresponding to this PSC*/         
        cell_id_per_rl[rl_count] = WCDMA_INVALID_CELL_ID;   
        ordered_config_ptr->
          l1_dl_chan_parms.dl_per_rl[rl_count++].pri_cpich_scr_code =
          RRCLLC_INVALID_CPICH_SCR_CODE;
      }
    }
  }
  else /* All states other than Cell_DCH */
  {
    if(ie_ptr->n > 0)
    {
      if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[0].modeSpecificInfo,
                  T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd))
      {
        /* There should be not more than 1 PSCs in the list when going
         * to FACH since the C-RNTI can not be tied up with multiple
         * PSCs. Just remember the 1st PSC.
         */
        ordered_config_ptr->dest_psc =
          (rrc_scr_code_type)ie_ptr->elem[0].modeSpecificInfo.u.fdd->
            primaryCPICH_Info.primaryScramblingCode;
        ordered_config_ptr->dest_psc_present = TRUE;

      }
    }
  }

  return rrcllcpcie_check_for_duplicate_rl_entry();

} /* end get_dl_info_per_rl() */


/*===========================================================================
FUNCTION        get_dl_info_per_rl_r5_per_rrc_connection()

DESCRIPTION     This function validates and stores Downlink Information Per
                Radio Link for reconfiguration messages.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    Ordered config is updated with the new RL info.
===========================================================================*/
uecomdef_status_e_type get_dl_info_per_rl_r5_per_rrc_connection
(
  rrc_DL_InformationPerRL_List_r5bis *ie_ptr,
  rrc_RRC_StateIndicator next_state
)
{
  uint8 idx;
  uint8 rl_count = 0;
  /* is_hho flag indicates if it is one of Inter Freq or Intra Freq HHO */
  boolean is_hho;

  /* is_inter_freq flag indicates if it is an Inter Freq HHO */
  boolean is_inter_freq;

  boolean old_rl_seen = FALSE;

  /* new_rl_seen indicates that new RLs are seen which is always TRUE for HHOs */
  boolean new_rl_seen = FALSE;

  uint32 n_index_ie=0; 

  rrc_DL_InformationPerRL_List_r5bis *tmp_ie_ptr = ie_ptr;
  rrc_DL_InformationPerRL_List_r5bis *temp_ptr = ie_ptr;
  boolean was_rl_db_empty = FALSE;
  rrcllcoc_dl_info_per_rl_status_e_type status =
    RRCLLCOC_DL_INFO_PER_RL_IGNORED;
  rrc_freq_type rrc_freq = rrc_ccm_get_curr_camped_freq();
  rrc_state_e_type rrc_state = rrc_get_state();

  ordered_config_ptr->dest_psc_present = FALSE;

  /* We can say with certainty that if frequency info is included, and
  * it is different than the current frequency, then we are doing a
  * hard handover.  If this is not the case, we revisit this flag
  * later.
  */
  is_inter_freq = is_hho = (ordered_config_ptr->dest_freq_present &&
    ordered_config_ptr->dest_freq != rrc_freq);

  if(next_state == rrc_RRC_StateIndicator_cell_DCH)
  {
  /* If DPCH Info per RL is not present within DL Info per RL, then ignore it and
  * do not change the RL Info list in OC when going from DCH->DCH.
  * When going from non-DCH->DCH, the above condition should result in a Failure.
    */
    if((RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index_ie].modeSpecificInfo,
                T_rrc_DL_InformationPerRL_r5bis_modeSpecificInfo_fdd)) &&
       ((RRC_CHECK_MSG_TYPE_IE(ie_ptr->elem[n_index_ie], 
                dl_DPCH_InfoPerRLPresent)) == 0))
    {
      if(rrc_state == RRC_STATE_CELL_DCH)
      {
        /* Remove this check later - need to process rest of RL Info elements */
        WRRC_MSG0_HIGH("Ignoring DL Info per RL,DPCH Info not present");
        return(SUCCESS);
      }
      else
      {
        WRRC_MSG0_HIGH("Failing, DPCH Info per RL not present");
        return(FAILURE);
      }
    }

    /* Did we have any radio links in our database previously? */
    was_rl_db_empty = (ordered_config_ptr->l1_dl_chan_parms.num_rl == 0);

    if(rrc_state != RRC_STATE_CELL_DCH)
    {
      /* Going from non-DCH state to CELL DCH */
      /* Always set new_rl_seen when coming to DCH from a non-DCH state.
      * That ensures the RL Info is populated after initializing.
      */
      new_rl_seen = TRUE;

      if(!is_inter_freq)
      {
        /* Also loop thru and check if the current camped on PSC is in RL Info.
         * If so, force Frequency_info to FALSE.
         */
        if(is_current_camped_psc_in_rl_info_r5_per_rrc_connection(ie_ptr))
        {
          ordered_config_ptr->dest_freq_present = FALSE;
        }
        else  /* Intra freq HHO */
        {
          ordered_config_ptr->dest_freq_present = TRUE;
          ordered_config_ptr->dest_freq = rrc_freq;
          WRRC_MSG0_HIGH("Disjoint ASET, intra-f HHO FACH->DCH");
        }
      }
    }
    else       /* Going from DCH->DCH */
    {
    /* Unless we are doing an inter-frequency hard handover, we cannot
    * take a set of radio links that contains scrambling codes we
    * already have in our database as well as ones that we don't have
    * in our database. (25.331 8.6.6.3a)
      */
      
      if(!is_inter_freq)
      {
        while(tmp_ie_ptr->n > n_index_ie)
        {
          if(get_dl_rl_idx_to_update(
            tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode,
            RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo, 
                    T_rrc_DL_InformationPerRL_r5bis_modeSpecificInfo_fdd),
          &ordered_config_ptr->l1_dl_chan_parms) <
          UE_MAX_RL )
          {
            old_rl_seen = TRUE;
          }
          else
          {
            new_rl_seen = TRUE;
          }

          /* We can bail out early if we detect a mixed active set. */
          if(old_rl_seen && new_rl_seen)
          {
            WRRC_MSG0_ERROR("Mixed ASET detected, rejecting");
            return FAILURE;
          }

         n_index_ie++;
        }
      }
      else
      {
        /* New RLs always seen for Inter freq HHO */
        new_rl_seen = TRUE;
      }
    } /* DCH->DCH */
    n_index_ie=0;
    while(ie_ptr->n > n_index_ie)
    {
      if(rrc_state != RRC_STATE_CELL_DCH)
      {
        /* For a non-DCH to DCH transition, there is no existing RL Info */
        idx = rl_count;
      }
      else if(is_inter_freq)
      {
      /* We've found this radio link in our database, but we are
      * doing an inter-frequency hard handover, which means that
      * we are replacing the active set.  This is a case where
      * the primary scrambling code on the new frequency is the
      * same as on the old one.  We need to adjust our radio link
      * index accordingly, since we don't want to place the new
      * radio link into the database position of the old one.
        */
        idx = rl_count;
      }
      else /* DCH -> DCH AND Not Inter Freq */
      {
      /* Now look to see if this radio link is already in our
      * database.
        */
        idx = get_dl_rl_idx_to_update_r5_per_rrc_connection(&ie_ptr->elem[n_index_ie],
          &ordered_config_ptr->l1_dl_chan_parms);

        if(idx == UE_MAX_RL)
        {
        /* This radio link is not in our database, which means we're
        * replacing our database with an entirely new set of radio
        * links.  We must reset the value of the database index to
        * the current radio link count.
          */
          idx = rl_count;

          is_hho = TRUE;

        } /* idx == UE_MAX_RL */
      } /* DCH -> DCH AND Not Inter Freq */

      /* Process the IE and place the info into our database. */
      status = get_dl_info_for_each_rl_r5_per_rrc_connection(&ie_ptr->elem[n_index_ie],
        &ordered_config_ptr->l1_dl_chan_parms,
        idx,
        new_rl_seen);

      if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
      {
        return FAILURE;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_IGNORED)
      {
        continue;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS)
      {
        if(is_hho)
        {
        /* If we succeeded in processing the IE, and we are doing a
        * hard handover, we must be sure that L1 is informed by
        * sending frequency info, even if we didn't get frequency
        * info in the reconfiguration message.
          */
          if(!ordered_config_ptr->dest_freq_present)
          {
            ordered_config_ptr->dest_freq_present = TRUE;
            ordered_config_ptr->dest_freq = rrc_freq;
            WRRC_MSG0_HIGH("Disjoint ASET, intra-f HHO triggered");
          }
        }
      }

      rl_count++;
      n_index_ie++;
    }

    /* Here we check to see if "Default DPCH Offset Value" and "DPCH frame offset" respect the following
         * relation : "Default DPCH Offset Value" % 38400 = "DPCH frame offset" as per 8.6.6.14 in 25.331
         * We have to do this validation only when we enter DCH the first time or if it is a Timing Initialized HHO 
         * Checking only 0th location...no loop here. 
         */
    if ( (rrc_state != RRC_STATE_CELL_DCH) ||
         (is_hho && ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind == L1_TIMING_IND_INIT) )
    {
      if((RRC_CHECK_MSG_TYPE(temp_ptr->elem[0].modeSpecificInfo, 
                  T_rrc_DL_InformationPerRL_r5bis_modeSpecificInfo_fdd)) &&
         (RRC_CHECK_MSG_TYPE_IE(temp_ptr->elem[0], 
                  dl_DPCH_InfoPerRLPresent)))
      {
        if ( (ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset % 38400) !=
             (temp_ptr->elem[0].dl_DPCH_InfoPerRL.u.fdd->dpch_FrameOffset * RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR) )
        {
          WRRC_MSG2_ERROR("Validation of DOFF %d and DPCH frame offset %d fail",
              ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
              (temp_ptr->elem[0].dl_DPCH_InfoPerRL.u.fdd->dpch_FrameOffset *
               RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR));
          return (FAILURE);
        }
      }
    }

    if(is_hho || was_rl_db_empty)
    {
    /* We've just replaced the contents of our radio link database, or
    * added radio links when we had none before, so we must update the
    * count of the radio links contained therein.
      */
      ordered_config_ptr->l1_dl_chan_parms.num_rl = rl_count;

      /* Clear out old scrambling codes. */
      while(rl_count < UE_MAX_RL)
      {

        /*We need to invalidate the Cell_Id corresponding to this PSC*/         
        cell_id_per_rl[rl_count] = WCDMA_INVALID_CELL_ID;    
        ordered_config_ptr->
          l1_dl_chan_parms.dl_per_rl[rl_count++].pri_cpich_scr_code =
          RRCLLC_INVALID_CPICH_SCR_CODE;
      }
    }
  }
  else /* All states other than Cell_DCH */
  {
    if(ie_ptr != NULL)
    {
      if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[0].modeSpecificInfo,
                  T_rrc_DL_InformationPerRL_r5bis_modeSpecificInfo_fdd))
      {
      /* There should be not more than 1 PSCs in the list when going
      * to FACH since the C-RNTI can not be tied up with multiple
      * PSCs. Just remember the 1st PSC.
        */
        ordered_config_ptr->dest_psc =
          (rrc_scr_code_type)ie_ptr->elem[0].modeSpecificInfo.u.fdd->
          primaryCPICH_Info.primaryScramblingCode;
        ordered_config_ptr->dest_psc_present = TRUE;

      }
    }
  }

  return SUCCESS;

} /* end get_dl_info_per_rl_r5_per_rrc_connection() */

/*===========================================================================
FUNCTION        get_dl_info_per_rl_r5()

DESCRIPTION     This function validates and stores Downlink Information Per
                Radio Link for reconfiguration messages.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    Ordered config is updated with the new RL info.
===========================================================================*/
uecomdef_status_e_type get_dl_info_per_rl_r5
(
  rrc_DL_InformationPerRL_List_r5 *ie_ptr,
  rrc_RRC_StateIndicator next_state
)
{
  uint8 idx;
  uint8 rl_count = 0;
  uint8 cnt = 0;
  /* is_hho flag indicates if it is one of Inter Freq or Intra Freq HHO */
  boolean is_hho;

  /* is_inter_freq flag indicates if it is an Inter Freq HHO */
  boolean is_inter_freq;

  boolean old_rl_seen = FALSE;

  /* new_rl_seen indicates that new RLs are seen which is always TRUE for HHOs */
  boolean new_rl_seen = FALSE;

  boolean existing_hs_link_inactive = FALSE;
  uint32 n_index_ie=0; 

  rrc_DL_InformationPerRL_List_r5 *tmp_ie_ptr = ie_ptr;
  rrc_DL_InformationPerRL_List_r5 *temp_ptr = ie_ptr;
  boolean was_rl_db_empty = FALSE;
  rrcllcoc_dl_info_per_rl_status_e_type status =
    RRCLLCOC_DL_INFO_PER_RL_IGNORED;
  rrc_freq_type rrc_freq = rrc_ccm_get_curr_camped_freq();
  rrc_state_e_type rrc_state = rrc_get_state();

  ordered_config_ptr->dest_psc_present = FALSE;

  /* Check if HSDPA link has been specified in more than one place */
  while (tmp_ie_ptr->n > n_index_ie)
  {
    if (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo, 
                T_rrc_DL_InformationPerRL_r5_modeSpecificInfo_fdd))
    {
      if (tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->servingHSDSCH_RL_indicator == TRUE)
      {
        rl_count++;
        if (rl_count > 1)
        {
          WRRC_MSG0_ERROR("RRCHS:More than 1 HS RL specified");
          return FAILURE;
        }

        hsdpa_msg_params.msg_params_present = TRUE;
        hsdpa_msg_params.rl_link_present = TRUE;
        hsdpa_msg_params.new_rl_link = (uint16)
        tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

      }
      else
      {
        /* Check if it was HSDPA Link Earlier */
        if ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && 
          (ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc == 
           tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode))
        {
          WRRC_MSG0_HIGH("RRCHS:Exisitng HSDPA Link made inactive");
          existing_hs_link_inactive = TRUE;
        }
      }
      n_index_ie++;
    }
    else
    {
      n_index_ie++;
    }
  }
  

  if ((existing_hs_link_inactive == TRUE) && (rl_count == 0))
  {
    WRRC_MSG0_HIGH("RRCHS:HSDPA to be stopped");
    ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;
  }

  /* Reinitialize values */
  rl_count = 0;
  tmp_ie_ptr = ie_ptr;
  n_index_ie = 0;

  /* We can say with certainty that if frequency info is included, and
  * it is different than the current frequency, then we are doing a
  * hard handover.  If this is not the case, we revisit this flag
  * later.
  */
  is_inter_freq = is_hho = (ordered_config_ptr->dest_freq_present &&
    ordered_config_ptr->dest_freq != rrc_freq);

  if((rrccsp_channel_locking_nv_status()) && !rrccsp_is_ue_in_true_limited_service() &&
      is_inter_freq )
  {
    WRRC_MSG0_HIGH("Failing, inter-freq HHO not supported");
    return(FAILURE);
  }

  if(next_state == rrc_RRC_StateIndicator_cell_DCH)
  {
  /* If DPCH Info per RL is not present within DL Info per RL, then ignore it and
  * do not change the RL Info list in OC when going from DCH->DCH.
  * When going from non-DCH->DCH, the above condition should result in a Failure.
    */
    while (tmp_ie_ptr->n > n_index_ie)
    {
      if((RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo, 
                  T_rrc_DL_InformationPerRL_r5_modeSpecificInfo_fdd)) &&
         ((RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index_ie], 
                  dl_DPCH_InfoPerRLPresent)) == 0))
      {
        if(rrc_state == RRC_STATE_CELL_DCH)
        {
          /* Remove this check later - need to process rest of RL Info elements */
          WRRC_MSG1_HIGH("Ignoring DL Info per RL for %d,Info absent", 
            tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode);

          n_index_ie++;
          if (n_index_ie == tmp_ie_ptr->n)
          {
            if (cnt > 0 )
            {
              WRRC_MSG0_HIGH("RRCHS:One link has DL DPCH info perRL");
              break;
            }
            WRRC_MSG0_HIGH("RRCHS:DL DPCH Info Per RL absent");
            return(SUCCESS);
          }
          else
          {
            continue;
          }
        }
        else
        {
          WRRC_MSG0_HIGH("Failing, DPCH Info per RL not present");
          return(FAILURE);
        }
      }
      cnt++;
      n_index_ie++;
    }

    /* Restore the Pointer */
    tmp_ie_ptr = ie_ptr;
    n_index_ie = 0;

    /* Did we have any radio links in our database previously? */
    was_rl_db_empty = (ordered_config_ptr->l1_dl_chan_parms.num_rl == 0);

    if(rrc_state != RRC_STATE_CELL_DCH)
    {
      /* Going from non-DCH state to CELL DCH */
      /* Always set new_rl_seen when coming to DCH from a non-DCH state.
      * That ensures the RL Info is populated after initializing.
      */
      new_rl_seen = TRUE;

      if(!is_inter_freq)
      {
        /* Also loop thru and check if the current camped on PSC is in RL Info.
         * If so, force Frequency_info to FALSE.
         */
        if(is_current_camped_psc_in_rl_info_r5(ie_ptr))
        {
          ordered_config_ptr->dest_freq_present = FALSE;
        }
        else  /* Intra freq HHO */
        {
          ordered_config_ptr->dest_freq_present = TRUE;
          ordered_config_ptr->dest_freq = rrc_freq;
          WRRC_MSG0_HIGH("Disjoint ASET, intra-f HHO FACH->DCH");
        }
      }
    }
    else       /* Going from DCH->DCH */
    {
    /* Unless we are doing an inter-frequency hard handover, we cannot
    * take a set of radio links that contains scrambling codes we
    * already have in our database as well as ones that we don't have
    * in our database. (25.331 8.6.6.3a)
      */
      n_index_ie=0;
      if(!is_inter_freq)
      {
        while(tmp_ie_ptr->n >  n_index_ie)
        {
          if(get_dl_rl_idx_to_update_r5(&tmp_ie_ptr->elem[n_index_ie],
            &ordered_config_ptr->l1_dl_chan_parms) <
            UE_MAX_RL)
          {
            old_rl_seen = TRUE;
          }
          else
          {
            new_rl_seen = TRUE;
          }

          /* We can bail out early if we detect a mixed active set. */
          if(old_rl_seen && new_rl_seen)
          {
            WRRC_MSG0_ERROR("Mixed ASET detected, rejecting");
            return FAILURE;
          }

          n_index_ie++;
        }
      }
      else
      {
        /* New RLs always seen for Inter freq HHO */
        new_rl_seen = TRUE;
      }
    } /* DCH->DCH */
    n_index_ie=0;
    while(ie_ptr->n > n_index_ie)
    {
      if(rrc_state != RRC_STATE_CELL_DCH)
      {
        /* For a non-DCH to DCH transition, there is no existing RL Info */
        idx = rl_count;
      }
      else if(is_inter_freq)
      {
      /* We've found this radio link in our database, but we are
      * doing an inter-frequency hard handover, which means that
      * we are replacing the active set.  This is a case where
      * the primary scrambling code on the new frequency is the
      * same as on the old one.  We need to adjust our radio link
      * index accordingly, since we don't want to place the new
      * radio link into the database position of the old one.
        */
        idx = rl_count;
      }
      else /* DCH -> DCH AND Not Inter Freq */
      {
      /* Now look to see if this radio link is already in our
      * database.
        */
        idx = get_dl_rl_idx_to_update_r5(&ie_ptr->elem[n_index_ie],
          &ordered_config_ptr->l1_dl_chan_parms);

        if(idx == UE_MAX_RL)
        {
        /* This radio link is not in our database, which means we're
        * replacing our database with an entirely new set of radio
        * links.  We must reset the value of the database index to
        * the current radio link count.
          */
          idx = rl_count;

          is_hho = TRUE;

          hsdpa_msg_params.intra_hho_involved = 
            hsdpa_msg_params.msg_params_present = TRUE;

        } /* idx == UE_MAX_RL */
      } /* DCH -> DCH AND Not Inter Freq */

      /* Process the IE and place the info into our database. */
      status = get_dl_info_for_each_rl_r5(&ie_ptr->elem[n_index_ie],
        &ordered_config_ptr->l1_dl_chan_parms,
        idx,
        new_rl_seen);

      if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
      {
        return FAILURE;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_IGNORED)
      {
        n_index_ie++;
        continue;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS)
      {
        if(is_hho)
        {
        /* If we succeeded in processing the IE, and we are doing a
        * hard handover, we must be sure that L1 is informed by
        * sending frequency info, even if we didn't get frequency
        * info in the reconfiguration message.
          */
          if(!ordered_config_ptr->dest_freq_present)
          {
            ordered_config_ptr->dest_freq_present = TRUE;
            ordered_config_ptr->dest_freq = rrc_freq;
            WRRC_MSG0_HIGH("Disjoint ASET, intra-f HHO triggered");
          }
        }
      }

      rl_count++;
      n_index_ie++;
    }

    /* Here we check to see if "Default DPCH Offset Value" and "DPCH frame offset" respect the following
         * relation : "Default DPCH Offset Value" % 38400 = "DPCH frame offset" as per 8.6.6.14 in 25.331
         * We have to do this validation only when we enter DCH the first time or if it is a Timing Initialized HHO 
         * Checking only 0th location...no loop here. 
        */
    if ( (rrc_state != RRC_STATE_CELL_DCH) ||
         (is_hho && ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind == L1_TIMING_IND_INIT) )
    {
      if((RRC_CHECK_MSG_TYPE(temp_ptr->elem[0].modeSpecificInfo, 
                  T_rrc_DL_InformationPerRL_r5_modeSpecificInfo_fdd)) &&
         (RRC_CHECK_MSG_TYPE_IE(temp_ptr->elem[0], 
                  dl_DPCH_InfoPerRLPresent)))
      {
        if ( (ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset % 38400) !=
             (temp_ptr->elem[0].dl_DPCH_InfoPerRL.u.fdd->dpch_FrameOffset * RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR) )
        {
          WRRC_MSG2_ERROR("Validation of DOFF %d and DPCH frame offset %d fail",
              ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
              (temp_ptr->elem[0].dl_DPCH_InfoPerRL.u.fdd->dpch_FrameOffset *
               RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR));
          return (FAILURE);
        }
      }
    }

    /* Call below function to wipe out any stored L1 information
     * on EUL
     */
    if (is_hho) 
    {
      rrcllc_clean_l1_e_info_on_non_r6_hho();
    }

    if(is_hho || was_rl_db_empty)
    {
    /* We've just replaced the contents of our radio link database, or
    * added radio links when we had none before, so we must update the
    * count of the radio links contained therein.
      */
      ordered_config_ptr->l1_dl_chan_parms.num_rl = rl_count;

      /* Clear out old scrambling codes. */
      while(rl_count < UE_MAX_RL)
      {

        /*We need to invalidate the Cell_Id corresponding to this PSC*/         
        cell_id_per_rl[rl_count] = WCDMA_INVALID_CELL_ID;    
        ordered_config_ptr->
          l1_dl_chan_parms.dl_per_rl[rl_count++].pri_cpich_scr_code =
          RRCLLC_INVALID_CPICH_SCR_CODE;
      }
    }
  }
  else /* All states other than Cell_DCH */
  {
    if(ie_ptr->n > 0)
    {
      if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[0].modeSpecificInfo,  
                  T_rrc_DL_InformationPerRL_r5_modeSpecificInfo_fdd))
      {
      /* There should be not more than 1 PSCs in the list when going
      * to FACH since the C-RNTI can not be tied up with multiple
      * PSCs. Just remember the 1st PSC.
        */
        ordered_config_ptr->dest_psc =
          (rrc_scr_code_type)ie_ptr->elem[0].modeSpecificInfo.u.fdd->
          primaryCPICH_Info.primaryScramblingCode;
        ordered_config_ptr->dest_psc_present = TRUE;

      }
    }
  }

  return rrcllcpcie_check_for_duplicate_rl_entry();

} /* end get_dl_info_per_rl_r5() */

/*====================================================================
FUNCTION: rrcllc_init_hspdsch_info()

DESCRIPTION:
  This function initializes the HSPDSCH Information in the configuration
  database.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_hspdsch_info(ordered_config_type  *config_ptr)
{
  config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;
  config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code = 0;

  config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 0;
  config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_cqi = RRCLLC_DELTA_CQI_MAX +1;
  config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 0xff;
  config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.po_hs_dsch = RRCLLC_MAX_MEAS_POWER_OFFSET + 1;

}



/*====================================================================
FUNCTION: set_dl_rm_restriction_info_to_invalid

DESCRIPTION:
  This function invalidates the passes RM restriction info. This is
  needed in all Non-DCH states.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void  set_dl_rm_restriction_info_to_invalid(
    /* RM restriction info structure pointer */
  rrcllc_rm_restrict_info_struct_type *rm_restrict_info
)
{
  rm_restrict_info->restriction_info_exist = FALSE;
}

/*====================================================================
FUNCTION: get_dl_rm_restriction_info

DESCRIPTION:
  This function get the RM restriction information for all TrChs that
  are in a physical channel. In the RRCLLC and L1 the information that
  are grouped and multiplexed in to one or more physical channel is kept
  in CCTrCh information. So this information is subsequently used to
  update the valid TFCS for that CCTrCh.

  References: 25.331 (2000-12) 10.3.6.31

DEPENDENCIES:
  None

RETURN VALUE:
  SUCCESS or FAILURE.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type get_dl_rm_restriction_info
(
  /* RRC DL rate matching restriction information */
  rrc_Dl_rate_matching_restriction    *ie_ptr,
  /* RM restriction info structure pointer */
  rrcllc_rm_restrict_info_struct_type *rm_restrict_info
)
{
  /* function local variables */
  /* ------------------------ */

  uint8 cur_trch_index;
  uint8 cur_tf_index;
  rrcllc_rm_restricted_trch_info_struct_type *this_trch_info;
  uint8 this_allowed_tf;

  rrc_RestrictedTrCH_InfoList *restricted_trch_list;
  rrc_AllowedTFI_List *allowed_tf_list;
  uint32 n_value_restricted=0, n_value_allowed=0;
  uint32 n_index_restricted=0, n_index_allowed=0;

  /*** function code starts here ***/

  /* Check if the RM restriction information exists or NOT */
  if (!(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
              restrictedTrCH_InfoListPresent)))
  {
    rm_restrict_info->restriction_info_exist = FALSE;
    return FAILURE;
  }

  /* RM restriction info exist, get it */
  /* --------------------------------- */

  /* set the RM restriction info exist to TRUE.
    Initialize the restricted TrCh index to 0.
    Get the pointer to restricted TrCh link list head */
  rm_restrict_info->restriction_info_exist = TRUE;
  cur_trch_index = 0;
  restricted_trch_list = &(ie_ptr->restrictedTrCH_InfoList);
  n_value_restricted = restricted_trch_list->n;

  /* Get the information of all restricted TrCh */
  while ((n_value_restricted != 0)&&(cur_trch_index < UE_MAX_TRCH))
  {
    /* pointer to this restricted TrCh info. The allowed TFI are
      stored here */
    this_trch_info =
      &(rm_restrict_info->restricted_trch_info[cur_trch_index]);

    /* get the TrCh id that is restrcited */
    this_trch_info->trch_id = (uint8)
      restricted_trch_list->elem[n_index_restricted].restrictedDL_TrCH_Identity;

    /* initialze the TFI index allowed boolean to FALSE (0) */
    memset(this_trch_info->tf_allowed, 0x00,
           sizeof(this_trch_info->tf_allowed));

    /* get the pointer to the TFI allowed state array */
    allowed_tf_list = &(restricted_trch_list->elem[n_index_restricted].allowedTFIList);
    n_value_allowed = allowed_tf_list->n;
    cur_tf_index = 0;
    n_index_allowed = 0;
    /* Update the allowed TFI state that are in the allowed TFI list */
    while (n_value_allowed != 0)
    {
      /* get the index of the TF that is allowed and
        mark its allowed state to TRUE */
      this_allowed_tf = (uint8)allowed_tf_list->elem[n_index_allowed];
      this_trch_info->tf_allowed[this_allowed_tf] = TRUE;

      /* get the pointer to next TF index info */
      cur_tf_index++;
      n_value_allowed--;
      n_index_allowed++;
    } /* End while, getting all the allowed TFs */

    /* update the info pointers/counters for next restrited TrCh */
    this_trch_info->num_tf = cur_tf_index;
    cur_trch_index++;
    n_value_restricted--;
    n_index_restricted++;
  } /* End while, getting all restricted TrCh info */

  /* set the total number of restricted TrCh */
  rm_restrict_info->num_trch = cur_trch_index;

  return SUCCESS;
} /* end get_dl_rm_restriction_info() */

/*====================================================================
FUNCTION: update_rm_restriction_info()

DESCRIPTION:
  This function do multiple jobs to update the TFCS in to RRC-L1
  interface structures.
  1. Calculate the TFI from the CTFC values using corresponding
     CCTrCh info.
  2. Apply the RM restriction information to the TFC and mark the
     TFC as ALLOWED or RESTRICTED.
  3. Update the ALLOWED TFC in the RRC-L1 TFCS/CTFC info interface
     structures.
  4. Set the INVALID (unused/removed) or RESTRICTED TFCI to invalid
     in the RRC-L1 interface TFCS/CTFC info structures.

  The RM restriction info should be a valid structure pointer. Though
  it may optional in Downlink DPCH info. In this case the structure
  member restriction_info_exist must be set to FALSE by the caller
  before calling this function.

  This function compares the TrCh ids in the RM restriction information
  and CCTrCh information. The TrCh Id should be based on the same
  information base. If TrCh Ids are translated to some other scheme
  after getting from IEs that should be applied to both.

  The RM restriction can be applied to the CCTrCh that doesn't have
  the CTFC/TFCS existence. In this case the follwoing function
  parameter can be passed as NULL.
    DL CTFC info structure pointer
    rrcllc_dl_ctfc_info_struct_type *dl_tfcs_info,
  However the parameter
    DL TFCS info for CPHY_SETUP_REQ
    l1_dl_ctfc_info_struct_type *tfcs_info_rrc_l1_inf
  SHOULD NOT be NULL. This member of this structure are filled to indicate
  no TFCI existence.


  References: 25.331 (2000-12) 10.3.6.18, 10.3.6.31

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void update_rm_restriction_info
(
  /* CCTrCh setup information. */
  l1_dl_cctrch_info_struct_type       *cctrch_info,
  /* DL CTFC info structure pointer */
  rrcllc_dl_ctfc_info_struct_type     *dl_tfcs_info,
  /* RM restriction info structure pointer */
  rrcllc_rm_restrict_info_struct_type *rm_restrict_info,
  /* DL TFCS info for CPHY_SETUP_REQ */
  l1_dl_ctfc_info_struct_type         *tfcs_info_rrc_l1_inf
)
{
  /* function local variables */
  /* ------------------------ */

  /* for loop index for iterating over all transport channels, CTFCs */
  uint16 index_tf, index_ctfc, index_rm_rest_trch;
  int16  index_trch;
  /* pointer to the TF table for previous TrCh with reference to the TrCh
     for which the P value is being calculated */
  l1_dl_trch_info_struct_type* prev_trch_table;
  /* This array stores the P value for all TrChs in the given CCTrCh. This
     is used for calculating the TFI from CTFC */
  uint32 p_value[UE_MAX_TRCH];
  /* temporary value (m) of CTFC value in current CTFC entry to calculate
     the TFIs */
  uint32 temp_ctfc_val;
  /* the P value of the TrCh for which TFI are currently being calculated */
  uint32 this_trch_p_value;

  /* TrCh Id if the TrCh current at the current index in loop */
  uint8 this_trch_id;
  /* TFI in a TFCS */
  uint8 this_tfi;
  /* pointer to the CTFC entry of the CTFC for which the TFI of all TrCh are
     currently being calculated in the loop */
  rrcllc_dl_ctfc_entry_info_struct_type *this_ctfc_entry;
  /* Array of the pointers to RM info structures */
  rrcllc_rm_restricted_trch_info_struct_type *restricted_trch_info_ptr[L1_MAX_TRCH];
  /* pointer to TF info structure in the restricted TrCh for which the allowed
    TFI list is to be updated */
  l1_dl_tf_info_struct_type **this_trch_tf_info;

  /* last valid CTFC entry */
  int16 last_valid_entry;

  /*** function code starts here ***/

  /* Initialize local arrays */
  memset(p_value, 0, sizeof(p_value));
  memset(restricted_trch_info_ptr, 0, sizeof(restricted_trch_info_ptr));

  /* Check if the TFCS information exists then only calculate
    the P value for decoding TFI iondices from CTFC values */
  if (dl_tfcs_info)
  {
    /* ------------------------------------------------ */
    /* Calculation of TFI for each TFC from CTFC values */
    /* ------------------------------------------------ */

    /* initialization */
    /* -------------- */

    /* set the P value of the first transport channel to 0 */
    p_value[0] = 1;

    /* calculation of the P value */
    /* -------------------------- */

    /* loop over all the transport channel to multiply the number of  TF
        in all TrChs prior to current TrCh.
       Note: The first TrCh has the P value = 1.
       Calculation method:
         Set L0 = 1
         TrCh#1 Number of TF = L1 Pvalue = L0 = 1
         TrCh#2 Number of TF = L2 Pvalue = L0 x L1 = PvalueTrCh#1 X L1
         TrCh#3 Number of TF = L3 Pvalue = L0 x L1 X L2= PvalueTrCh#2 X L2

         For TrCh#n Pvalue = L0 x L1 x L2 x ..... L(n-1)
                           = TrCh#(n-1) Pvalue * L(n-1)
    */

    for (index_trch = 1; index_trch < cctrch_info->num_trch; index_trch++)
    {
      /* get the pointer to the TrCh info of the previous channel with
         reference to the current TrCh for which the P value is to be
         calculated */
      prev_trch_table = cctrch_info->trch_info_array[index_trch - 1];

      /* calculate the p value for this TrCh */
      p_value[index_trch] =
        p_value[index_trch - 1] * prev_trch_table->num_tf;
    }
  } /* end if, DL TFCS info exist, then calc the P value */

  /* Get the RM restriction transport channel information aligned in
     array as per the TrCh Ids in CcTrCh info */
  /* --------------------------------------------------------------- */

  /* Get the RM restriction info for all TrCh */
  for (index_trch = 0; index_trch < cctrch_info->num_trch; index_trch++)
  {
    /* Get the TrCh id for this TrCh and initialize the
      restriction info pointer to NULL */
    this_trch_id = cctrch_info->trch_info_array[index_trch]->trch_id;
    restricted_trch_info_ptr[index_trch] = NULL;

    /* If the restriction information exists then find the it this
      TrCh is in the restricted TrCh list. If it is then set the
      pointer to the restriction info */
    if (rm_restrict_info->restriction_info_exist)
    {
      for (index_rm_rest_trch = 0;
           index_rm_rest_trch < rm_restrict_info->num_trch;
           index_rm_rest_trch++)
      {
        if (this_trch_id ==
            rm_restrict_info->restricted_trch_info[index_rm_rest_trch].trch_id)
        {
          restricted_trch_info_ptr[index_trch] =
            &(rm_restrict_info->restricted_trch_info[index_rm_rest_trch]);

          /* Update the TF information in this restricted TrCh for the
             allowed TFs */
          this_trch_tf_info =
            cctrch_info->trch_info_array[index_trch]->tf_info_array;
          for (index_tf = 0;
               index_tf < cctrch_info->trch_info_array[index_trch]->num_tf;
               index_tf++)
          {
            if (!restricted_trch_info_ptr[index_trch]->tf_allowed[index_tf])
            {
              this_trch_tf_info[index_tf]->allowed = FALSE;
            }
          } /* End for, updating the allowed TFI list in this restricted TrCh */
          break;
        } /* End if, this is the restricted TrCh Id */
      } /* End for, loop searching if this TrCh is in the restricted TrCh Id list */
    } /* End if, the RM restriction info exists */
  } /* End for, get the RM restriction info for all TrCh in this CCTrCh */

  /* calculation of the TFI from CTFC and P value calculated above */
  /* ------------------------------------------------------------- */

  /* initialize the last valid CTFC entry array index to -1 */
  last_valid_entry = -1;

  /* Check if the TFCS information exists then only process it */
  if (dl_tfcs_info)
  {
    /* loop to calculate the TFI's  for all TrCh in each CTFC. */
    for (index_ctfc = 0;
        ((index_ctfc <= dl_tfcs_info->last_ctfc_entry_index) && (dl_tfcs_info->last_ctfc_entry_index != RRC_DL_INVALID_CTFC_VALUE));
        index_ctfc++)
    {
      this_ctfc_entry = &dl_tfcs_info->ctfc_entry_data[index_ctfc];

      /* if the CTFC is not valid then skip the calculation */
      if (this_ctfc_entry->state == INVALID)
        continue;

      /* initialize the temporary value of this CTFC (m in the
         documentation) */
      temp_ctfc_val = this_ctfc_entry->ctfc_value;

      /* loop to calculate the TFIs for all TrCh for this CTFC */
      for (index_trch = cctrch_info->num_trch - 1;
          index_trch >= 0;
          index_trch--)
      {
        this_trch_p_value = p_value[index_trch];
        if (!this_trch_p_value)
        {
          ERR_FATAL("Trying to divide by zero",0,0,0);
        }
        this_tfi = (uint8) (temp_ctfc_val / this_trch_p_value);
        this_ctfc_entry->tfi_table[index_trch] = this_tfi;
        if (restricted_trch_info_ptr[index_trch])
        {
          if (!restricted_trch_info_ptr[index_trch]->tf_allowed[this_tfi])
            this_ctfc_entry->state = RESTRICTED;
        }

        temp_ctfc_val %= this_trch_p_value;
      } /* end for loop, calculate the TFIs for this CTFC */

      if (this_ctfc_entry->state == ALLOWED)
      {
        tfcs_info_rrc_l1_inf->ctfc_entry_array[index_ctfc]->valid_ctfc = TRUE;
        tfcs_info_rrc_l1_inf->ctfc_entry_array[index_ctfc]->tfi_table =
          this_ctfc_entry->tfi_table;
        last_valid_entry = (int16)index_ctfc;
      }
      else
        tfcs_info_rrc_l1_inf->ctfc_entry_array[index_ctfc]->valid_ctfc = FALSE;
    } /* end for loop, calculate the TFI for all valid CTFCs */
  }

  /* Update the TFCS information for RRC L1 TFCS information */
  /* ------------------------------------------------------- */

  if(last_valid_entry >= 0)
  {
    tfcs_info_rrc_l1_inf->last_ctfc_entry_index = last_valid_entry;
  }

  /* This is HARD CODED to FALSE . It is not ley supported */
  tfcs_info_rrc_l1_inf->pdsch_info_valid = FALSE;
} /* end update_rm_restriction_info() */


/*============================================================================
FUNCTION: set_compressed_mode_info()

DESCRIPTION:
  This function sets the compressed mode parameters from UTRAN message
  in the format required by L1. It validates the parameters to check if they
  are in range and sets in Ordered Config the compressed mode list. L1 is provided
  the entire list everytime with no of elements in it.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type set_compressed_mode_info
(
  rrc_DPCH_CompressedModeInfo* rrc_compressed_mode_ptr
)
{
  /* Store the TGP list ptr in a local list */
  struct rrc_TGP_SequenceList *local_tgp_SequenceList_ptr = NULL;

  struct rrc_TGP_SequenceList *hsdpa_cm_local_list_ptr = NULL;

  uint8 cm_activate = 0;

  uint8 cm_deactivate = 0;
  uint32 n_value_hsdpa = 0;
  uint32 n_index_hsdpa = 0;

  /* Initialize counters */
  uint8 cnt = 0;
  uint8 tgpsi_index = 0;
  uint8 tgpsi = 0;
  uint32 n_index = 0;
  boolean tgpsi_change = FALSE;
  /* Stores the ptr that points to the head of the CM list */
  l1_cm_tgp_seq_info_struct_type* l1_seq_head_ptr = NULL;

  l1_seq_head_ptr = &(ordered_config_ptr->tgp_seq_info[0]);


  hsdpa_cm_local_list_ptr = local_tgp_SequenceList_ptr = 
    &(rrc_compressed_mode_ptr->tgp_SequenceList);
  
  cm_status_from_ota_msg = RRC_CM_NONE;
  n_value_hsdpa = hsdpa_cm_local_list_ptr->n;

  if (local_tgp_SequenceList_ptr->n == 0)
  {
    WRRC_MSG0_ERROR("REL8:Compressed Mode list is NULL");
    return FAILURE;
  }

  /* First initialize action_needed to FALSE */
  while (cnt < L1_CM_MAX_TGP_SEQ_COUNT)
  {
    ordered_config_ptr->cm_info.action_needed[cnt++] = FALSE;
  }

  /* Reinitialize cnt */
  cnt = 0;


  /* enter into this while loop to compute the value of 'cm_status_from_ota_msg' */
  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
  {
    while (n_value_hsdpa != 0)
    {
      if (RRC_CHECK_MSG_TYPE(hsdpa_cm_local_list_ptr->elem[n_index_hsdpa].tgps_Status,
                  T_rrc_TGP_Sequence_tgps_Status_activate))
      {
        cm_activate++;
      }
      else
      {
        cm_deactivate++;
      }
      
      n_value_hsdpa--;
      n_index_hsdpa++;
    }
    
    /* False for CM deactivate does not matter as pattern 
    could be simul activated/deactivated */
    if (cm_activate > 0)
    {
      cm_status_from_ota_msg = ACTIVATE_CM;
    }
    else if (cm_deactivate > 0)
    {
      cm_status_from_ota_msg = (rrcllc_cm_status_e_type) cm_deactivate;
    }
    else
    {
      cm_status_from_ota_msg = RRC_CM_NONE;
    }
  }


  ordered_config_ptr->cm_tgpsi_ota_cnt=0;
  
  /* Now process the CM list */
  while (n_index < local_tgp_SequenceList_ptr->n)
  {
    /* Validate the TGPSI */
    if (local_tgp_SequenceList_ptr->elem[n_index].tgpsi > 0 &&
      local_tgp_SequenceList_ptr->elem[n_index].tgpsi <= L1_CM_MAX_TGP_SEQ_COUNT)
    {
      tgpsi = (uint8) local_tgp_SequenceList_ptr->elem[n_index].tgpsi;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid TGPSI %d", tgpsi);
      return FAILURE;
    }

    /* First check if UTRAN wants to add or modify the existing TGPSI */
    if (find_tgpsi_index(&tgpsi, &tgpsi_index, &tgpsi_change) == SUCCESS)
    {

      /* Set this indication in action_needed so that L1 can find out
      * if a TGPSI has been modified or not */
      set_tgpsi_location(&tgpsi_index);

      /* Element has to be added at position given by tgpsi_index */
      while(cnt++ != tgpsi_index)
      {
        l1_seq_head_ptr++;
      }

      l1_seq_head_ptr->tgp_seq_id = tgpsi;

      /* Find out what has to be done with the pattern */
      if (RRC_CHECK_MSG_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_Status,
                  T_rrc_TGP_Sequence_tgps_Status_activate))
      {

        l1_seq_head_ptr->active = TRUE;

        /* Store Starting TGCFN */
        l1_seq_head_ptr->start_cfn = (uint8)
          local_tgp_SequenceList_ptr->elem[n_index].tgps_Status.u.activate->tgcfn;
      }
      else
      {
        l1_seq_head_ptr->active = FALSE;
      }

      if(RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index], 
                  tgps_ConfigurationParamsPresent))
      {
        /* Configuration parameters present */

        /* Set info valid to TRUE */
        l1_seq_head_ptr->info_valid = TRUE;

        /* Add rest of parameters */
        /* Find out the purpose of this patern sequence */
        if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgmp == rrc_TGMP_multi_carrier)
          || (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgmp == rrc_TGMP_tdd_Measurement))
        {
          WRRC_MSG0_ERROR("TDD/MultiCarrier CompMode not supported");
          return FAILURE;
        }

        /* Get Meas Purpose */
        l1_seq_head_ptr->tg_meas_purpose =
          RET_COMPRESSED_MODE_MEAS_PURPOSE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgmp);

        /* Check rrc_nidentifyAbort_present for Initial BSIC active */
        if ((RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams,
                   nidentifyAbortPresent)) && 
             (l1_seq_head_ptr->tg_meas_purpose == L1_CM_TGMP_GSM_BSIC_IDENTIFY))

        {
          if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.nidentifyAbort <=
            N_IDENTIFY_ABORT_MAX) && (local_tgp_SequenceList_ptr->elem[n_index].
            tgps_ConfigurationParams.nidentifyAbort >= N_IDENTIFY_ABORT_MIN))
          {
            l1_seq_head_ptr->n_identify_abort = (uint8)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.nidentifyAbort;
          }
          else
          {
            WRRC_MSG1_ERROR("nidentifyAbort Invalid",local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.nidentifyAbort);
            return FAILURE;
          }
        }

        /* Check treconfirmAbort for Reconfirmation BSIC */
        if ((RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams,
                      treconfirmAbortPresent)) && 
            (l1_seq_head_ptr->tg_meas_purpose == L1_CM_TGMP_GSM_BSIC_RECONF))

        {
          if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.treconfirmAbort <=
            T_RECONFIRM_ABORT_MAX) && (local_tgp_SequenceList_ptr->elem[n_index].
            tgps_ConfigurationParams.treconfirmAbort >= T_RECONFIRM_ABORT_MIN))
          {
            l1_seq_head_ptr->t_reconf_abort = (uint8)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.treconfirmAbort;
          }
          else
          {
            WRRC_MSG1_ERROR("T_Reconfirm_Abort Invalid",
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.treconfirmAbort);
            return FAILURE;
          }
        }

        /* Find compressed mode method */
        if (RRC_CHECK_MSG_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.ul_DL_Mode,
                     T_rrc_UL_DL_Mode_ul))
        {
          WRRC_MSG0_HIGH("Only UL Compressed Mode given");
          return FAILURE;

        }
        else if (RRC_CHECK_MSG_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.ul_DL_Mode,
                     T_rrc_UL_DL_Mode_dl))
        {
          WRRC_MSG0_HIGH("Only DL Compressed Mode given");
          return FAILURE;
        }
        else if (RRC_CHECK_MSG_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.ul_DL_Mode,
                     T_rrc_UL_DL_Mode_ul_and_dl))
        {
          l1_seq_head_ptr->ul_cm_method = RET_UL_COMPRESSED_MODE_METHOD_TYPE(
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.ul_DL_Mode.u.ul_and_dl->ul);

          l1_seq_head_ptr->dl_cm_method = RET_DL_COMPRESSED_MODE_METHOD_TYPE(
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.ul_DL_Mode.u.ul_and_dl->dl);

          if (l1_seq_head_ptr->dl_cm_method == L1_CM_BY_PUNCT)
          {
            WRRC_MSG1_HIGH("Unsupported DL CM_method:%d",l1_seq_head_ptr->dl_cm_method);
            return FAILURE;
          }

        }
        else
        {
          WRRC_MSG0_ERROR("Invalid mode for TGPS configuration params");
        }

        /* Get downlink frame type */
        l1_seq_head_ptr->dl_frame_type =
          RET_DL_FRAME_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.dl_FrameType);


        /* Get Compressed Mode state control info */

        /* Repetition Count */
        l1_seq_head_ptr->tgp_state_ctrl_info.tgp_rep_count = (uint16)
          local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgprc;


        /* Slot Number [0..14] */
        if (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgsn <= TGSN_MAX)
        {
          l1_seq_head_ptr->tgp_state_ctrl_info.tg_start_slot_num = (uint8)
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgsn;
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid Slot Number : %d",
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgsn);
          return FAILURE;
        }

        /* TGL1 [1...14] */
        if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl1 <= TGL1_MAX) &&
          (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl1 >= TGL_MIN))
        {
          l1_seq_head_ptr->tgp_state_ctrl_info.tg_len_1 = (uint8)
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl1;
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid TGL1 : %d",
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl1);
          return FAILURE;
        }

        /* TGL2 [1...14] */
        if (RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams,
                      tgl2Present))
        {

          if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl2 <= TGL2_MAX) &&
            (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl2 >= TGL_MIN))
          {
            l1_seq_head_ptr->tgp_state_ctrl_info.tg_len_2 = (uint8)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl2;
          }
          else
          {
            WRRC_MSG1_ERROR("Invalid TGL2 : %d",
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl2);
            return FAILURE;
          }
        }
        else
        {
          l1_seq_head_ptr->tgp_state_ctrl_info.tg_len_2 =
            l1_seq_head_ptr->tgp_state_ctrl_info.tg_len_1;
        }

        if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgd >= TGD_MIN) &&
          (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgd <= TGD_MAX))
        {
          /* Check if the value is undefined i.e. 270 */
          if (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgd == TGD_MAX)
          {
            l1_seq_head_ptr->tgp_state_ctrl_info.tgd = 0;
          }
          else
          {
            /* Txion Gap Distance  */
            l1_seq_head_ptr->tgp_state_ctrl_info.tgd = (uint16)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgd;
          }
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid TGD : %d",
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgd);
          return FAILURE;
        }

        /* Transmission gap pattern length1 [1...144] */

        if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgpl1 <= TGPL1_MAX) &&
          (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgpl1 >= TGPL_MIN))
        {
          l1_seq_head_ptr->tgp_state_ctrl_info.tgp_len_1 = (uint8)
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgpl1;
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid TGPL1 : %d",
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgpl1);
          return FAILURE;
        }

        /* Transmission gap pattern length2 [1...144] */
        if (RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams, 
                      dummyPresent))
        {
          if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.dummy <= TGPL2_MAX) &&
            (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.dummy >= TGPL_MIN))
          {
            l1_seq_head_ptr->tgp_state_ctrl_info.tgp_len_2 = (uint8)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.dummy;
          }
          else
          {
            WRRC_MSG1_ERROR("Invalid TGPL2 : %d",
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.dummy);
            return FAILURE;
          }
        }
        else
        {
          l1_seq_head_ptr->tgp_state_ctrl_info.tgp_len_2 =
            l1_seq_head_ptr->tgp_state_ctrl_info.tgp_len_1;
        }

        /* Power Ctrl Info */
        /* recovery period power control mode */
        l1_seq_head_ptr->pwr_ctrl_info.rpp = RET_RECOVERY_POWER_CONTROL(
          local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.rpp);

        /* initial UL transmit power control method */
        l1_seq_head_ptr->pwr_ctrl_info.itp = RET_INITIAL_TRANSMIT_POWER(
          local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.itp);

        /* All delta_sir [0...30]. Actual Value is [0...  .3] */
        if (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIR1 <= SIR_MAX)
        {
          l1_seq_head_ptr->pwr_ctrl_info.delta_sir_1 = (uint8)
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIR1;
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid deltaSIR1 : %d",
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIR1);
          return FAILURE;
        }

        /* delta_sir_2 */
        if (RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams,
                      deltaSIR2Present))
        {
          if (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIR2 <= SIR_MAX)
          {
            l1_seq_head_ptr->pwr_ctrl_info.delta_sir_2 = (uint8)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIR2;

          }
          else
          {
            WRRC_MSG1_ERROR("Invalid deltaSIR2 : %d",
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIR2);
            return FAILURE;
          }
        }
        else
        {
          l1_seq_head_ptr->pwr_ctrl_info.delta_sir_2 = l1_seq_head_ptr->pwr_ctrl_info.delta_sir_1;
        }

        /* delta_sir_after_1 */
        if (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIRAfter1 <= SIR_MAX)
        {
          l1_seq_head_ptr->pwr_ctrl_info.delta_sir_after_1 = (uint8)
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIRAfter1;
        }
        else
        {
          WRRC_MSG1_ERROR("Invalid deltaSIRAfter1 : %d",
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIRAfter1);
          return FAILURE;
        }


        /* delta_sir_after_2 */
        if (RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams,
                      deltaSIRAfter2Present))
        {
          if (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIRAfter2 <= SIR_MAX)
          {
            l1_seq_head_ptr->pwr_ctrl_info.delta_sir_after_2 = (uint8)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIRAfter2;
          }
          else
          {
            WRRC_MSG1_ERROR("Invalid deltaSIRAfter2 : %d",
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIRAfter2);
            return FAILURE;
          }
        }
        else
        {
          l1_seq_head_ptr->pwr_ctrl_info.delta_sir_after_2 =
            l1_seq_head_ptr->pwr_ctrl_info.delta_sir_after_1;
        }

      }  /* End of rrc_tgps_ConfigurationParams_present  Present */
      else
      {
        /* Set info valid to FALSE  */
        l1_seq_head_ptr->info_valid = FALSE;

      }
    } /* End of if of tgpsi successfully found */
    else
    {
      /* This condition would never happen */
      return FAILURE;
    }

    /* Read next value if any */
    n_index++;

    /* Reinitialize count */
    cnt = 0;

    /* Reinitialize the l1_seq_head_ptr */
    l1_seq_head_ptr = &(ordered_config_ptr->tgp_seq_info[0]);

    /* If it is a MODIFY, do not increment the count */
    if (tgpsi_change == FALSE)
    {
      /* Since we added one element, so increment tgpsi_cnt */
      ordered_config_ptr->cm_info.tgp_seq_info_count += 1;
    }
    else
    {
      tgpsi_change = FALSE;
    }

    /*Store the TGPSIs provided in this OTA*/
    ordered_config_ptr->cm_tgpsi_ota_changed[ordered_config_ptr->cm_tgpsi_ota_cnt] = tgpsi;
    ordered_config_ptr->cm_tgpsi_ota_cnt ++;
  
  } /* End of while of local_tgp_SequenceList_ptr != NULL */

  return SUCCESS;
}


/*============================================================================
FUNCTION: find_tgpsi_index()

DESCRIPTION:
  This function finds the tgpsi index for a given compressed mode Meas

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE.

SIDE EFFECTS:
  None.
=============================================================================*/
uecomdef_status_e_type find_tgpsi_index
(
  uint8* utran_tgpsi,
  uint8* tgpsi_index,
  boolean* tgpsi_modify
)
{
  uint8 count =0;
  if (ordered_config_ptr->cm_info.tgp_seq_info_count == 0)
  {
    WRRC_MSG0_HIGH("Compressed Mode List Empty");
    *tgpsi_index = 0;
    return SUCCESS;
  }
  else
  {
    /* Find the position of this index */
    for (count = 0; count < ordered_config_ptr->cm_info.tgp_seq_info_count; count++)
    {
      if (ordered_config_ptr->tgp_seq_info[count].tgp_seq_id == *utran_tgpsi)
      {
        /* Got the Index. Its a Modify */
        MSG_HIGH("Index is : %d\n", ordered_config_ptr->tgp_seq_info[count].tgp_seq_id,0,0);
        *tgpsi_index = count;
        *tgpsi_modify = TRUE;
        return SUCCESS;
      }
    }/* End of for */

    MSG_LOW("Store in first avaliable index",0,0,0);
    if (ordered_config_ptr->cm_info.tgp_seq_info_count <= (L1_CM_MAX_TGP_SEQ_COUNT-1))
    {
      MSG_LOW("Space is available",0,0,0);
      *tgpsi_index = ordered_config_ptr->cm_info.tgp_seq_info_count;
      return SUCCESS;
    }
    else
    {
      WRRC_MSG0_ERROR("No space in CM List");
      return FAILURE;
    }
  } /* End of else */

}


/*============================================================================
FUNCTION: set_tgpsi_location

DESCRIPTION:
  This function sets the tgpsi location in action_needed array so that L1 knows
  which TGPSI's are being modified by UTRAN. If any location in this array is set
  to TRUE, then that means that L1 needs to take care of that TGPSI. If that TGPSI
  is not existing, then L1 adds it else L1 modifies it

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
=============================================================================*/
void set_tgpsi_location
(
  uint8* tgpsi_location
)
{
  uint8 count = 0;

  /* Find the position of this index */
  while(count != *tgpsi_location)
    count++;

  /* Finally reached the position */
  /* Set this position to TRUE */
  ordered_config_ptr->cm_info.action_needed[count] = TRUE;
}


/*============================================================================
FUNCTION: rrcllcpcie_process_rl_removal_information_list()

DESCRIPTION:
  This function processes rl removal list and updates e_dch active set information
  and adds removed rl to e_rl_removed list
      
RE-USABILITY: R99/R5/R6/R7/R8

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_rl_removal_information_list
(
  OSS_UINT32 rl_removal_info_list_present,
  rrc_RL_RemovalInformationList *rl_remove_ptr,
  OSS_UINT32 rl_addition_info_list_present  
)
{
  /* local loop variable */
  uint32                            idx = 0;

  /* local RL count */
  uint32                           num_rl;
  uint32 n_value = rl_remove_ptr->n;
  uint32 n_index = 0;

  /* Can only remove one less than the number of Radio Links
     that the UE has */    
  num_rl = ordered_config_ptr->l1_dl_chan_parms.num_rl;
  while((n_value != 0) && (idx < num_rl))
  {
    if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
    {
      if ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) &&
          (ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc == 
           rl_remove_ptr->elem[n_index].primaryScramblingCode))
      {
        WRRC_MSG1_HIGH("hsdparl %d is deleted so stop HSDPA, could be INTRA HHO  ",rl_remove_ptr->elem[n_index].primaryScramblingCode);
        
        /* HSDPA to be stopped */
        rrc_set_hsdpa_action(HSDPA_STOP);
        
        /* Could be ITRAF HHO without repointing */
        /* When processing RL removal information we set rl_link_present as FALSE.
           If serving_HSDSCH_CellInformation carriers HS repointing info, then rl_link_present 
           is set to TRUE where HS action will again be determined as RECFG */
        hsdpa_msg_params.rl_link_present = FALSE;
	hsdpa_msg_params.intra_hho_involved = TRUE; 
        /* Set MAC HS Action to STOP */
        ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_STOP;
        
      }
    }

    if(get_rl_remove_info(&rl_remove_ptr->elem[n_index], &ordered_config_ptr->l1_dl_chan_parms) == FAILURE)
    {
      WRRC_MSG0_HIGH("get_rl_remove_info() failed");
      rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
      return FAILURE;
    }

   rrcllcpcie_check_and_update_e_active_set_and_remove_info(
     (uint32) rl_remove_ptr->elem[n_index].primaryScramblingCode);

    /* get the next RL */
    n_value--;
    n_index++;
    idx++;

    /* one less radio link in ORDERED_CONFIG */
    ordered_config_ptr->l1_dl_chan_parms.num_rl--;

    /* complain if we removed all the radio links */
    if(ordered_config_ptr->l1_dl_chan_parms.num_rl == 0 && 
       (!rl_addition_info_list_present))
    {
      WRRC_MSG0_HIGH("Attempted to remove all RLs");
      rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
      return FAILURE;
    }
   
    if(ordered_config_ptr->l1_dl_chan_parms.num_rl == 0)
    {
      /* sec 25.331 ,section 8.3.4.5
        If the following condition is valid:
       - the active set update procedure results in active 
         sets that do not contain at least one common radio link before
         and after a DPCH or F-DPCH frame boundary:
         the UE behaviour is not specified.
        */
      WRRC_MSG0_HIGH("Disjoint ASET in ASU is received do reject the ASU");
      rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
      return FAILURE;
    }
  } /* end loop of all included RLs to remove */

  return(SUCCESS);
} /* rrcllcpcie_process_removal_information_list */


/*====================================================================
FUNCTION        rrcllcpcie_update_sync_a_post_veri_info()

DESCRIPTION     This function updates ordered config with the  
                and the timingMaintainedSynchInd IE values
                received in the OTA message

DEPENDENCIES    NONE

RETURN VALUE    None

SIDE EFFECTS
====================================================================*/
void rrcllcpcie_update_sync_a_post_veri_info
(  
  void *msg_ptr,
  uint32 dl_sdu_num
)
{
  rrc_DL_CCCH_Message *ccch_ptr;
  rrc_DL_DCCH_Message *dcch_ptr;
  rrc_RRCConnectionSetup *rrc_conn_ptr;
  rrc_PhysicalChannelReconfiguration *rrc_physChannelReconfig;
  rrc_CellUpdateConfirm_CCCH *rrc_CellUpdateCnf_ccch;
  rrc_RadioBearerReconfiguration *rrc_radioBearerReconfig;
  rrc_RadioBearerRelease *rrc_radioBearerRel; 
  rrc_TransportChannelReconfiguration *rrc_transportChannelReconfig; 
  rrc_CellUpdateConfirm *rrc_CellUpdateCnf_dcch;
  boolean handle_timming_sync_ind =FALSE;

 
  ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = FALSE;
  ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = FALSE;
 
  if((ordered_config_ptr->tm_sync_ind_applicable & RRCLLC_FREQ_INFO_PRESENT_IN_OTA)  && 
     (ordered_config_ptr->tm_sync_ind_applicable & RRCLLC_TIMING_MAINTAIN_IND_PRESENT_OTA ))
  {
    handle_timming_sync_ind = TRUE;
  }

 /* Determine if it was rcv'd on the DL CCCH */
  if(dl_sdu_num == rrc_DL_CCCH_Message_PDU)
  {
    ccch_ptr = (rrc_DL_CCCH_Message *)msg_ptr;

    /* Since it was a DL CCCH Msg, figure out the Message Type */
    switch(RRC_GET_MSG_TYPE(ccch_ptr->message))
    {
      case T_rrc_DL_CCCH_MessageType_rrcConnectionSetup:
      {
         rrc_conn_ptr = &ccch_ptr->message.u.rrcConnectionSetup;
         if (RRC_CHECK_COMMON_MSG_TYPE_PTR(rrc_conn_ptr, 
                rrc_RRCConnectionSetup_r3))
         {
            if((RRC_CHECK_MSG_TYPE_IE(rrc_conn_ptr->u.r3, 
                    laterNonCriticalExtensionsPresent)) &&
               (RRC_CHECK_MSG_TYPE_IE(rrc_conn_ptr->u.r3.laterNonCriticalExtensions, 
                    v4b0NonCriticalExtensionsPresent)) &&
               (RRC_CHECK_MSG_TYPE_IE(rrc_conn_ptr->u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions,
                    v590NonCriticalExtensionsPresent)) &&
               (RRC_CHECK_MSG_TYPE_IE(rrc_conn_ptr->u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.v590NonCriticalExtensions,
                     v690NonCriticalExtensionsPresent)))
            {
              if(RRC_CHECK_MSG_TYPE_IE(rrc_conn_ptr->u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
                    v590NonCriticalExtensions.v690NonCriticalExtensions.rrcConnectionSetup_v690ext,
                    postVerificationPeriodPresent))
              {
                  ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
              }
            }
         }
         else if ((RRC_CHECK_MSG_TYPE(rrc_conn_ptr->u.later_than_r3.criticalExtensions,
                    T_rrc_RRCConnectionSetup_criticalExtensions_5_criticalExtensions)) &&
                  (RRC_CHECK_MSG_TYPE(rrc_conn_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions,
                    T_rrc_RRCConnectionSetup_criticalExtensions_4_r5)))
         {
            if(RRC_CHECK_MSG_TYPE_IE(rrc_conn_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5,
                    v690NonCriticalExtensionsPresent))
            {
               if(RRC_CHECK_MSG_TYPE_IE(rrc_conn_ptr->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.
                     r5.v690NonCriticalExtensions.rrcConnectionSetup_v690ext,
                     postVerificationPeriodPresent))
               {
                  ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
               }
            }
         }
      }
      break;

      case T_rrc_DL_CCCH_MessageType_cellUpdateConfirm:
      {
         rrc_CellUpdateCnf_ccch = &ccch_ptr->message.u.cellUpdateConfirm;
         if (RRC_CHECK_COMMON_MSG_TYPE_PTR(rrc_CellUpdateCnf_ccch, 
                     rrc_CellUpdateConfirm_CCCH_r3))
         {
            if((RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_ccch->u.r3, 
                     laterNonCriticalExtensionsPresent))
                && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_ccch->u.r3.laterNonCriticalExtensions,
                     v4b0NonCriticalExtensionsPresent))
                && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_ccch->u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions, 
                     v590NonCriticalExtensionsPresent))
                && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_ccch->u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.v590NonCriticalExtensions,
                    v5d0NonCriticalExtenstionsPresent))
                && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_ccch->u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.v590NonCriticalExtensions.
                     v5d0NonCriticalExtenstions,
                      v690NonCriticalExtensionsPresent))
                && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_ccch->u.r3.laterNonCriticalExtensions.v4b0NonCriticalExtensions.v590NonCriticalExtensions.
                     v5d0NonCriticalExtenstions.v690NonCriticalExtensions.cellUpdateConfirm_v690ext,
                     postVerificationPeriodPresent)))
            {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
            }
         }
         else if((RRC_CHECK_COMMON_MSG_TYPE_PTR(rrc_CellUpdateCnf_ccch,
                     rrc_CellUpdateConfirm_CCCH_later_than_r3)) &&
                 (RRC_CHECK_MSG_TYPE(rrc_CellUpdateCnf_ccch->u.later_than_r3.criticalExtensions, 
                     T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_5_criticalExtensions)) &&
                 (RRC_CHECK_MSG_TYPE(rrc_CellUpdateCnf_ccch->u.later_than_r3.criticalExtensions.u.criticalExtensions,
                    T_rrc_CellUpdateConfirm_CCCH_criticalExtensions_4_r5)))
         {
            if((RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_ccch->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5, 
                     v5d0NonCriticalExtenstionsPresent))
               && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_ccch->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.v5d0NonCriticalExtenstions, 
                     v690NonCriticalExtensionsPresent))
               && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_ccch->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.v5d0NonCriticalExtenstions.
                     v690NonCriticalExtensions.cellUpdateConfirm_v690ext,
                      postVerificationPeriodPresent)))
            { 
               ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
            }
        
         }
      }
      break;

    default:
      WRRC_MSG1_HIGH("No Post veri field and sync a filed in the OTA message %d rcv'd", RRC_GET_MSG_TYPE(ccch_ptr->message));
      break;
    }
  }
  else if(dl_sdu_num == rrc_DL_DCCH_Message_PDU)
  {
    dcch_ptr = (rrc_DL_DCCH_Message *)msg_ptr;

    /* Since it was a DL DCCH Msg, figure out the Message Type */
    switch(RRC_GET_MSG_TYPE(dcch_ptr->message))
    {
      case T_rrc_DL_DCCH_MessageType_physicalChannelReconfiguration:
      {
         rrc_physChannelReconfig = &dcch_ptr->message.u.physicalChannelReconfiguration;
         if (RRC_CHECK_COMMON_MSG_TYPE_PTR(rrc_physChannelReconfig, 
            rrc_PhysicalChannelReconfiguration_r3))
         {
            if((RRC_CHECK_MSG_TYPE_IE(rrc_physChannelReconfig->u.r3, 
                v3a0NonCriticalExtensionsPresent))
               &&(RRC_CHECK_MSG_TYPE_IE(rrc_physChannelReconfig->u.r3.v3a0NonCriticalExtensions, 
                     laterNonCriticalExtensionsPresent))
               &&(RRC_CHECK_MSG_TYPE_IE(rrc_physChannelReconfig->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions,
                     v4b0NonCriticalExtenstionsPresent))
               &&(RRC_CHECK_MSG_TYPE_IE(rrc_physChannelReconfig->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                     v4b0NonCriticalExtenstions, 
                     v590NonCriticalExtenstionsPresent))
               &&(RRC_CHECK_MSG_TYPE_IE(rrc_physChannelReconfig->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtenstions.
                     v590NonCriticalExtenstions, 
                    v690NonCriticalExtensionsPresent)))
            {
              if(RRC_CHECK_MSG_TYPE_IE(rrc_physChannelReconfig->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtenstions.
                     v590NonCriticalExtenstions.v690NonCriticalExtensions.physicalChannelReconfiguration_v690ext, 
                      postVerificationPeriodPresent))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
              }
              if((handle_timming_sync_ind == TRUE) &&
                 (RRC_CHECK_MSG_TYPE_IE(rrc_physChannelReconfig->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtenstions.
                     v590NonCriticalExtenstions.v690NonCriticalExtensions.physicalChannelReconfiguration_v690ext,
                     timingMaintainedSynchIndPresent)))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = TRUE;
              }
            }
         }
         else if((RRC_CHECK_MSG_TYPE(rrc_physChannelReconfig->u.later_than_r3.criticalExtensions, 
                     T_rrc_PhysicalChannelReconfiguration_criticalExtensions_5_criticalExtensions)) &&
                 (RRC_CHECK_MSG_TYPE(rrc_physChannelReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions,
                     T_rrc_PhysicalChannelReconfiguration_criticalExtensions_4_r5)))
         {
            if(RRC_CHECK_MSG_TYPE_IE(rrc_physChannelReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5, 
                      v690NonCriticalExtensionsPresent))
            {
              if(RRC_CHECK_MSG_TYPE_IE(rrc_physChannelReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.v690NonCriticalExtensions.
                     physicalChannelReconfiguration_v690ext,
                     postVerificationPeriodPresent))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
              }
              if((handle_timming_sync_ind == TRUE) &&
               (RRC_CHECK_MSG_TYPE_IE(rrc_physChannelReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.
                     v690NonCriticalExtensions.physicalChannelReconfiguration_v690ext,
                     timingMaintainedSynchIndPresent)))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = TRUE;
              }
            }
         }
      }
      break;

      case T_rrc_DL_DCCH_MessageType_radioBearerReconfiguration:
      {
         rrc_radioBearerReconfig = &dcch_ptr->message.u.radioBearerReconfiguration;
         if (RRC_CHECK_COMMON_MSG_TYPE_PTR(rrc_radioBearerReconfig,
                     rrc_RadioBearerReconfiguration_r3))
         {
            if((RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerReconfig->u.r3, 
                     v3aoNonCriticalExtensionsPresent))
                &&(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerReconfig->u.r3.v3aoNonCriticalExtensions,
                     laterNonCriticalExtensionsPresent))
                &&(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerReconfig->u.r3.v3aoNonCriticalExtensions.laterNonCriticalExtensions,
                     v4b0NonCriticalExtensionsPresent))
                &&(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerReconfig->u.r3.v3aoNonCriticalExtensions.laterNonCriticalExtensions.
                     v4b0NonCriticalExtensions, 
                     v590NonCriticalExtensionsPresent))
                &&(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerReconfig->u.r3.v3aoNonCriticalExtensions.laterNonCriticalExtensions.
                     v4b0NonCriticalExtensions.v590NonCriticalExtensions, 
                     v5d0NonCriticalExtenstionsPresent))
                &&(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerReconfig->u.r3.v3aoNonCriticalExtensions.laterNonCriticalExtensions.
                     v4b0NonCriticalExtensions.v590NonCriticalExtensions.v5d0NonCriticalExtenstions, 
                     v690NonCriticalExtensionsPresent)))
            {
              if(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerReconfig->u.r3.v3aoNonCriticalExtensions.laterNonCriticalExtensions.
                  v4b0NonCriticalExtensions.v590NonCriticalExtensions.v5d0NonCriticalExtenstions.
                     v690NonCriticalExtensions.radioBearerReconfiguration_v690ext,
                    postVerificationPeriodPresent))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
              }
              if((handle_timming_sync_ind == TRUE) &&
                 (RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerReconfig->u.r3.v3aoNonCriticalExtensions.laterNonCriticalExtensions.
                v4b0NonCriticalExtensions.v590NonCriticalExtensions.v5d0NonCriticalExtenstions.v690NonCriticalExtensions.
                     radioBearerReconfiguration_v690ext,
                     timingMaintainedSynchIndPresent)))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = TRUE;
              }
            }            
         }
         else if((RRC_CHECK_MSG_TYPE(rrc_radioBearerReconfig->u.later_than_r3.criticalExtensions, 
                      T_rrc_RadioBearerReconfiguration_criticalExtensions_5_criticalExtensions))
                 && (RRC_CHECK_MSG_TYPE(rrc_radioBearerReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions,
                     T_rrc_RadioBearerReconfiguration_criticalExtensions_4_r5)))
         {
            if((RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5,
                       v5d0NonCriticalExtenstionsPresent))
               &&(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.
                       v5d0NonCriticalExtenstions, 
                       v690NonCriticalExtensionsPresent)))
            {
              if(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.
                       v5d0NonCriticalExtenstions.v690NonCriticalExtensions.radioBearerReconfiguration_v690ext, 
                       postVerificationPeriodPresent))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
              }
              if((handle_timming_sync_ind == TRUE) &&
               (RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.
                       v5d0NonCriticalExtenstions.v690NonCriticalExtensions.radioBearerReconfiguration_v690ext,
                       timingMaintainedSynchIndPresent)))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = TRUE;
              }
            }
         }
      }
      break;

      case T_rrc_DL_DCCH_MessageType_radioBearerRelease:
      {
        rrc_radioBearerRel = &dcch_ptr->message.u.radioBearerRelease;
        if (RRC_CHECK_COMMON_MSG_TYPE_PTR(rrc_radioBearerRel, 
                        rrc_RadioBearerRelease_r3))
        {
           if((RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerRel->u.r3, 
                        v3a0NonCriticalExtensionsPresent))
             &&(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerRel->u.r3.v3a0NonCriticalExtensions,
                        laterNonCriticalExtensionsPresent))
             &&(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerRel->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions,
                        v4b0NonCriticalExtensionsPresent))
             &&(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerRel->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions,
                        v590NonCriticalExtensionsPresent))
             &&(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerRel->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
                        v590NonCriticalExtensions, 
                        v690NonCriticalExtensionsPresent)))
           {
              if(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerRel->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                        v4b0NonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.radioBearerRelease_v690ext, 
                        postVerificationPeriodPresent))
              {
                 ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
              }
              if((handle_timming_sync_ind == TRUE) &&
                 (RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerRel->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
                        v590NonCriticalExtensions.v690NonCriticalExtensions.radioBearerRelease_v690ext,
                        timingMaintainedSynchIndPresent)))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = TRUE;
              }
           }
        }
        else if((RRC_CHECK_MSG_TYPE(rrc_radioBearerRel->u.later_than_r3.criticalExtensions,
                        T_rrc_RadioBearerRelease_criticalExtensions_5_criticalExtensions)) &&
                (RRC_CHECK_MSG_TYPE(rrc_radioBearerRel->u.later_than_r3.criticalExtensions.u.criticalExtensions,
                        T_rrc_RadioBearerRelease_criticalExtensions_4_r5)))
        {
           if(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerRel->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5,
                        v690NonCriticalExtensionsPresent))
           {
              if(RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerRel->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.v690NonCriticalExtensions.
                        radioBearerRelease_v690ext,
                        postVerificationPeriodPresent))
              {
                 ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
              }
              if((handle_timming_sync_ind == TRUE) &&
                 (RRC_CHECK_MSG_TYPE_IE(rrc_radioBearerRel->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.
                        v690NonCriticalExtensions.radioBearerRelease_v690ext, 
                        timingMaintainedSynchIndPresent)))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = TRUE;
              }
           }
        }
      }
      break;

      case T_rrc_DL_DCCH_MessageType_radioBearerSetup:
      {
         if (RRC_CHECK_MSG_TYPE(dcch_ptr->message.u.radioBearerSetup, 
                         T_rrc_RadioBearerSetup_r3))
         {
            if((RRC_CHECK_MSG_TYPE_IE(dcch_ptr->message.u.radioBearerSetup.u.r3, 
                        v3a0NonCriticalExtensionsPresent))
                 && (RRC_CHECK_MSG_TYPE_IE(dcch_ptr->message.u.radioBearerSetup.u.r3.v3a0NonCriticalExtensions,
                        laterNonCriticalExtensionsPresent))
                 && (RRC_CHECK_MSG_TYPE_IE(dcch_ptr->message.u.radioBearerSetup.u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions,
                        v4b0NonCriticalExtensionsPresent))
                 && (RRC_CHECK_MSG_TYPE_IE(dcch_ptr->message.u.radioBearerSetup.u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                        v4b0NonCriticalExtensions,
                        v590NonCriticalExtensionsPresent))
                 && (RRC_CHECK_MSG_TYPE_IE(dcch_ptr->message.u.radioBearerSetup.u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                        v4b0NonCriticalExtensions.v590NonCriticalExtensions, 
                       v5d0NonCriticalExtenstionsPresent))
                 && (RRC_CHECK_MSG_TYPE_IE(dcch_ptr->message.u.radioBearerSetup.u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                        v4b0NonCriticalExtensions.v590NonCriticalExtensions.v5d0NonCriticalExtenstions,
                        v690NonCriticalExtensionsPresent)))
            {
              if(RRC_CHECK_MSG_TYPE_IE(dcch_ptr->message.u.radioBearerSetup.u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                 v4b0NonCriticalExtensions.v590NonCriticalExtensions.v5d0NonCriticalExtenstions.
                        v690NonCriticalExtensions.radioBearerSetup_v690ext,
                        postVerificationPeriodPresent))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
              }
              if((handle_timming_sync_ind == TRUE) &&
                 (RRC_CHECK_MSG_TYPE_IE(dcch_ptr->message.u.radioBearerSetup.u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                v4b0NonCriticalExtensions.v590NonCriticalExtensions.v5d0NonCriticalExtenstions.
                        v690NonCriticalExtensions.radioBearerSetup_v690ext, timingMaintainedSynchIndPresent)))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = TRUE;
              }
            }
         }
         else if ((RRC_CHECK_MSG_TYPE(dcch_ptr->message.u.radioBearerSetup.u.later_than_r3.criticalExtensions,
                         T_rrc_RadioBearerSetup_criticalExtensions_5_criticalExtensions))
                 && (RRC_CHECK_MSG_TYPE(dcch_ptr->message.u.radioBearerSetup.u.later_than_r3.criticalExtensions.u.criticalExtensions,
                         T_rrc_RadioBearerSetup_criticalExtensions_4_r5)))
         {
          
           if((RRC_CHECK_MSG_TYPE_IE(dcch_ptr->message.u.radioBearerSetup.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5,
                        v5d0NonCriticalExtenstionsPresent))
                 && (RRC_CHECK_MSG_TYPE_IE(dcch_ptr->message.u.radioBearerSetup.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.
                        v5d0NonCriticalExtenstions, 
                        v690NonCriticalExtensionsPresent)))
           {
            if(RRC_CHECK_MSG_TYPE_IE(dcch_ptr->message.u.radioBearerSetup.u.later_than_r3.criticalExtensions.u.
              criticalExtensions.u.r5.v5d0NonCriticalExtenstions.v690NonCriticalExtensions.
                        radioBearerSetup_v690ext, 
                        postVerificationPeriodPresent))
            {
              ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
            }
            if((handle_timming_sync_ind == TRUE) &&
               (RRC_CHECK_MSG_TYPE_IE(dcch_ptr->message.u.radioBearerSetup.u.later_than_r3.criticalExtensions.u.criticalExtensions.
                        u.r5.v5d0NonCriticalExtenstions.v690NonCriticalExtensions.radioBearerSetup_v690ext,
                        timingMaintainedSynchIndPresent)))
            {
              ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = TRUE;
            }
           }
         }
      }
      break;
      
      case T_rrc_DL_DCCH_MessageType_transportChannelReconfiguration:
      {
         rrc_transportChannelReconfig = &dcch_ptr->message.u.transportChannelReconfiguration;
         if (RRC_CHECK_COMMON_MSG_TYPE_PTR(rrc_transportChannelReconfig, 
                        rrc_TransportChannelReconfiguration_r3))
         {
            if((RRC_CHECK_MSG_TYPE_IE(rrc_transportChannelReconfig->u.r3, 
                        v3a0NonCriticalExtensionsPresent))
               && (RRC_CHECK_MSG_TYPE_IE(rrc_transportChannelReconfig->u.r3.v3a0NonCriticalExtensions,
                        laterNonCriticalExtensionsPresent))
               && (RRC_CHECK_MSG_TYPE_IE(rrc_transportChannelReconfig->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions, 
                        v4b0NonCriticalExtensionsPresent))
               && (RRC_CHECK_MSG_TYPE_IE(rrc_transportChannelReconfig->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                        v4b0NonCriticalExtensions, 
                       v590NonCriticalExtensionsPresent))
               && (RRC_CHECK_MSG_TYPE_IE(rrc_transportChannelReconfig->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                        v4b0NonCriticalExtensions.v590NonCriticalExtensions, 
                        v690NonCriticalExtensionsPresent)))
            {
              if(RRC_CHECK_MSG_TYPE_IE(rrc_transportChannelReconfig->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                        v4b0NonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.transportChannelReconfiguration_v690ext,
                        postVerificationPeriodPresent))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
              }
              if((handle_timming_sync_ind == TRUE) &&
                 (RRC_CHECK_MSG_TYPE_IE(rrc_transportChannelReconfig->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
              v4b0NonCriticalExtensions.v590NonCriticalExtensions.v690NonCriticalExtensions.
                        transportChannelReconfiguration_v690ext, 
                       timingMaintainedSynchIndPresent)))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = TRUE;
              }
            }
         }
         else if((RRC_CHECK_MSG_TYPE(rrc_transportChannelReconfig->u.later_than_r3.criticalExtensions, 
                       T_rrc_TransportChannelReconfiguration_criticalExtensions_5_criticalExtensions))
                 && (RRC_CHECK_MSG_TYPE(rrc_transportChannelReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions,
                         T_rrc_TransportChannelReconfiguration_criticalExtensions_4_r5)))
         {
            if(RRC_CHECK_MSG_TYPE_IE(rrc_transportChannelReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5, 
                         v690NonCriticalExtensionsPresent))
            {
              if(RRC_CHECK_MSG_TYPE_IE(rrc_transportChannelReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.
                        v690NonCriticalExtensions.transportChannelReconfiguration_v690ext,
                        postVerificationPeriodPresent))
              {
                ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
              }
              if((handle_timming_sync_ind == TRUE) &&
                 (RRC_CHECK_MSG_TYPE_IE(rrc_transportChannelReconfig->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.
                        r5.v690NonCriticalExtensions.transportChannelReconfiguration_v690ext, 
                        timingMaintainedSynchIndPresent)))
              { 
                ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = TRUE;
              }
            }
         }
      }
      break;
      
      case T_rrc_DL_DCCH_MessageType_cellUpdateConfirm:
      {
         rrc_CellUpdateCnf_dcch = &dcch_ptr->message.u.cellUpdateConfirm;
      
         if (RRC_CHECK_COMMON_MSG_TYPE_PTR(rrc_CellUpdateCnf_dcch, 
                        rrc_CellUpdateConfirm_r3))
         {
            if((RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_dcch->u.r3, 
                        v3a0NonCriticalExtensionsPresent))
                && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_dcch->u.r3.v3a0NonCriticalExtensions, 
                        laterNonCriticalExtensionsPresent))
                && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_dcch->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions,
                         v4b0NonCriticalExtensionsPresent))
                && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_dcch->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                        v4b0NonCriticalExtensions, 
                        v590NonCriticalExtenstionsPresent))
                && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_dcch->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                        v4b0NonCriticalExtensions.v590NonCriticalExtenstions, 
                        v5d0NonCriticalExtenstionsPresent))
                && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_dcch->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.
                        v4b0NonCriticalExtensions.v590NonCriticalExtenstions.v5d0NonCriticalExtenstions, 
                       v690NonCriticalExtensionsPresent))
                && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_dcch->u.r3.v3a0NonCriticalExtensions.laterNonCriticalExtensions.v4b0NonCriticalExtensions.
                        v590NonCriticalExtenstions.v5d0NonCriticalExtenstions.v690NonCriticalExtensions.cellUpdateConfirm_v690ext, 
                        postVerificationPeriodPresent)))
            {
             ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
            }
         }
         else if((RRC_CHECK_COMMON_MSG_TYPE_PTR(rrc_CellUpdateCnf_dcch, 
                       rrc_CellUpdateConfirm_later_than_r3)) 
                 && (RRC_CHECK_MSG_TYPE(rrc_CellUpdateCnf_dcch->u.later_than_r3.criticalExtensions, 
                         T_rrc_CellUpdateConfirm_criticalExtensions_5_criticalExtensions))
                 && (RRC_CHECK_MSG_TYPE(rrc_CellUpdateCnf_dcch->u.later_than_r3.criticalExtensions.u.criticalExtensions,
                        T_rrc_CellUpdateConfirm_criticalExtensions_4_r5)))
         {
            if((RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_dcch->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5, 
                        v5d0NonCriticalExtenstionsPresent))
               && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_dcch->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.
                        v5d0NonCriticalExtenstions, 
                        v690NonCriticalExtensionsPresent))
               && (RRC_CHECK_MSG_TYPE_IE(rrc_CellUpdateCnf_dcch->u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.
                        v5d0NonCriticalExtenstions.v690NonCriticalExtensions.cellUpdateConfirm_v690ext,
                         postVerificationPeriodPresent)))
            { 
              ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = TRUE;
            }
         }
      }
      break;
      
      default:
        WRRC_MSG1_HIGH("No Post veri field and sync a filed in the OTA message %d rcv'd", RRC_GET_MSG_TYPE(dcch_ptr->message));
      break;  
    }
  }

  WRRC_MSG2_HIGH("post_verification_valid flag %d skip_sync_a_procedure %d in OC",
    ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid,
    ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure);
}


/*====================================================================
FUNCTION        rrcllcpcie_initialise_sync_a_post_veri_info()

DESCRIPTION     This function intialises the postVerificationPeriod 
                and the timingMaintainedSynchInd values in ordered 
                config to default values

DEPENDENCIES    NONE

RETURN VALUE    None

SIDE EFFECTS
====================================================================*/
void  rrcllcpcie_initialise_sync_a_post_veri_info
(
  void
)
{
   ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = FALSE;
   ordered_config_ptr->l1_dl_chan_parms.dl_common.post_verification_valid = FALSE;
}

/*====================================================================
FUNCTION        rrcllcpcie_validate_timing_maintained_sync_ind()

DESCRIPTION     This function validates if the timingMaintainedSynchInd IE is valid for the OTA message

DEPENDENCIES    NONE

RETURN VALUE    None

SIDE EFFECTS
====================================================================*/
void rrcllcpcie_validate_timing_maintained_sync_ind
(
  rrc_proc_e_type proc_id
)
{
  if((proc_id == RRC_PROCEDURE_CU ) || (proc_id == RRC_PROCEDURE_RCE)||
    (proc_id == RRC_PROCEDURE_IHO))
  {
    ordered_config_ptr->tm_sync_ind_applicable = 0x00;
    ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.skip_sync_a_procedure = FALSE;
    WRRC_MSG1_HIGH("Sync_a ind reset for proc id rrc_proc_e_type_value%d ",proc_id);
  }
}


/*============================================================================
FUNCTION: rrcllcpcie_process_reference_e_tfcis_r7()

DESCRIPTION:
  This function processes reference E-TFCIs and store the same in e_ul_info for L1
      
DEPENDENCIES:
  NONE

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_reference_e_tfcis_r7
(
  rrc_E_DPDCH_Reference_E_TFCIList_r7 *reference_etfcis_ptr,
  l1_e_dpdch_info_struct_type *e_dpdch_info_ptr
)
{
  rrc_E_DPDCH_Reference_E_TFCIList_r7 *temp_ref_etfci_ptr;
  boolean sort_ref_tfci_list = FALSE;
  uint32 n_value = 0;
  uint32 n_index = 0;

  temp_ref_etfci_ptr = reference_etfcis_ptr;
  /* reset the number of reference e-tfci's to 0 */
  e_dpdch_info_ptr->num_ref_e_tfci = 0;

  n_value = temp_ref_etfci_ptr->n;
  while (n_value != 0)
  {
    if (L1_MAX_REF_E_TFCI_LIST <= e_dpdch_info_ptr->num_ref_e_tfci)
    {
      return(FAILURE);
    }
    
    e_dpdch_info_ptr->ref_e_tfci_list[
      e_dpdch_info_ptr->num_ref_e_tfci].ref_e_tfci = 
      temp_ref_etfci_ptr->elem[n_index].reference_E_TFCI;

    e_dpdch_info_ptr->ref_e_tfci_list[
      e_dpdch_info_ptr->num_ref_e_tfci].ref_e_tfci_pwr_offset = 
      temp_ref_etfci_ptr->elem[n_index].reference_E_TFCI_PO_r7;
 #ifdef FEATURE_WCDMA_REL7_EDPCCH_POWER_BOOST
    /*
     * According to 25.331 section 8.3.4.3
     * If E-TFCI boost is signalled to the UE and a reference E-TFCI <= E-TFCI Boost 
     * is signalled to the UE with a Reference E-TFCI PO of value 30 or 31, the UE behaviour is unspecified.
     */
    if(ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.e_tfci_boost_val  != 0xff)
    {
      if(( e_dpdch_info_ptr->ref_e_tfci_list[e_dpdch_info_ptr->num_ref_e_tfci].ref_e_tfci
            <= ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.e_tfci_boost_val)
            && (e_dpdch_info_ptr->ref_e_tfci_list[e_dpdch_info_ptr->num_ref_e_tfci].ref_e_tfci_pwr_offset > 29))
      {
        MSG_ERROR("ref etfci %d more than etfci boost val %d and po value more than > 29",
                e_dpdch_info_ptr->ref_e_tfci_list[e_dpdch_info_ptr->num_ref_e_tfci].ref_e_tfci,
                ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.e_tfci_boost_val,
                e_dpdch_info_ptr->ref_e_tfci_list[e_dpdch_info_ptr->num_ref_e_tfci].ref_e_tfci_pwr_offset);
        return(FAILURE);
      }    
    }
 #endif
    if(e_dpdch_info_ptr->num_ref_e_tfci > 0 )
    {
      if( e_dpdch_info_ptr->ref_e_tfci_list[e_dpdch_info_ptr->num_ref_e_tfci].ref_e_tfci < 
         e_dpdch_info_ptr->ref_e_tfci_list[e_dpdch_info_ptr->num_ref_e_tfci-1].ref_e_tfci)
      {
        MSG_ERROR("Ref ETFCI not in ascending order in OTA RefTFCI %d <  Next RefTFCI %d num ETFCI %d",
             e_dpdch_info_ptr->ref_e_tfci_list[e_dpdch_info_ptr->num_ref_e_tfci-1].ref_e_tfci,
             e_dpdch_info_ptr->ref_e_tfci_list[e_dpdch_info_ptr->num_ref_e_tfci].ref_e_tfci,
             e_dpdch_info_ptr->num_ref_e_tfci);
        sort_ref_tfci_list = TRUE;
      }
    }
    e_dpdch_info_ptr->num_ref_e_tfci++;

    n_value--;
    n_index++;
  }

  if(sort_ref_tfci_list == TRUE )
  {
    rrcllc_sort_ref_e_tfci_list(e_dpdch_info_ptr);
  }
  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_process_e_dch_reconfig_info_samecell()

DESCRIPTION:
  This function processes edch reconfig info same cell IE and 
  populates the L1 structures and updates the req mask
      
RE-USABILITY: 

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_e_dch_reconfig_info_samecell
(
  OSS_UINT32 e_dch_reconfig_info_samecell_present,
  rrc_E_DCH_RL_InfoSameServingCell *e_dch_reconfig_info_samecell_ptr
)
{

  l1_e_ul_info_struct_type *e_ul_info_ptr = &ordered_config_ptr->l1_e_info.e_ul_info;
  
  if(e_dch_reconfig_info_samecell_present)
  {
    if (RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_reconfig_info_samecell_ptr,
               e_DPCCH_DPCCH_PowerOffsetPresent))
    {
      ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpcch_pwr_offset = 
        e_dch_reconfig_info_samecell_ptr->e_DPCCH_DPCCH_PowerOffset;
      
      rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);
      
    }
    
    if (RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_reconfig_info_samecell_ptr,
               reference_E_TFCIsPresent))
    {
          /* store reference e-tfci's */
      if (FAILURE == rrcllcpcie_process_reference_e_tfcis_r7(
          &e_dch_reconfig_info_samecell_ptr->reference_E_TFCIs,
          &e_ul_info_ptr->e_dpdch_info))
      {
        return(FAILURE);
      }
      /* set bit-mask to indicate L1 that UL info is received */
      rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);
    }
  }
  return SUCCESS;
}

/*============================================================================
FUNCTION: rrcllcpcie_process_e_dch_reconfig_info_r7()

DESCRIPTION:
  This function processes rl removal list and updates e_dch active set information
  and adds removed rl to e_rl_removed list
      
RE-USABILITY: 

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_e_dch_reconfig_info_r7
(
  OSS_UINT32 e_dch_reconfig_info_present,
  rrc_E_DCH_ReconfigurationInfo_r7 *e_dch_reconfig_info_ptr
)
{
  uint32 psc, e_rl_idx;
  rrc_E_RGCH_Information * e_rgch_ptr= NULL;
    rrc_E_HICH_Information * e_hich_info_ptr =NULL;
  boolean is_e_dl_info_present = FALSE;
  
  l1_e_ul_info_struct_type *e_ul_info_ptr =
    &ordered_config_ptr->l1_e_info.e_ul_info;

  l1_e_dl_info_struct_type *e_dl_info_ptr =
    &ordered_config_ptr->l1_e_info.e_dl_info;

  mac_e_dpdch_info_s_type *mac_e_dpdch_info_ptr = 
    &ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info;

  struct rrc_E_DCH_ReconfigurationInfo_r7_e_DCH_RL_InfoOtherCellList *e_rl_info_other_cell_ptr = NULL; 
  uint32 n_value = 0;
  uint32 n_index = 0;

  if (e_dch_reconfig_info_present)
  {
    if (RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_reconfig_info_ptr,
               e_DCH_RL_InfoNewServingCellPresent))
    {
      /* store serving grant */
      if (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
               servingGrantPresent))
      {
        if (rrc_E_DCH_RL_InfoNewServingCell_r7_primary_Secondary_GrantSelector_primary 
              == e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.servingGrant.primary_Secondary_GrantSelector)
        {
          e_dl_info_ptr->grant_config.grant_selector = L1_E_PRIMARY_GRANT;
        }
        else
        {
          e_dl_info_ptr->grant_config.grant_selector = L1_E_SECONDARY_GRANT;
        }

        if (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.servingGrant,
               valuePresent))
        {
          e_dl_info_ptr->grant_config.serving_grant = 
            e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.servingGrant.value;
        }

        WRRC_MSG2_HIGH("RRCEUL: ASU - grantSelector(P:1, S:2): %d, servingGrant: %d", 
          e_dl_info_ptr->grant_config.grant_selector, 
          e_dl_info_ptr->grant_config.serving_grant);

        rrcllc_update_l1_e_req_mask_for_e_dl_info(TRUE);
      }

      /* store beta-ec */
      if (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
               powerOffsetForSchedInfoPresent))
      {
        e_ul_info_ptr->e_dpcch_info.e_dpcch_pwr_offset = 
          e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.e_DPCCH_DPCCH_PowerOffset;
        /* Since L1 parameters are present hence update the bit mask to indicate the same */
        rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);
      }

      /* store reference e-tfci's */
      if (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
               reference_E_TFCIsPresent))
      {
        /* store reference e-tfci's */
        if (FAILURE == rrcllcpcie_process_reference_e_tfcis_r7(
            &e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.reference_E_TFCIs,
            &e_ul_info_ptr->e_dpdch_info))
        {
          return(FAILURE);
        }
        /* set bit-mask to indicate L1 that UL info is received */
        rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);
      }

      /* store po_sched_info */
      if (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
                powerOffsetForSchedInfoPresent))
      {
        mac_e_dpdch_info_ptr->sched_info_config.power_offset_of_si = 
            e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.powerOffsetForSchedInfo;

        rrcllc_update_mac_eul_action(TRUE);
      }

      /* store two and/or three index threshold */
      if ((RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
                 threeIndexStepThresholdPresent)) &&
          (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
                twoIndexStepThresholdPresent)))
      {
        if (FAILURE == rrcllcpcie_process_two_and_three_step_threshold_info(
            RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
            threeIndexStepThresholdPresent),
            e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.threeIndexStepThreshold,
            RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
            twoIndexStepThresholdPresent),
            e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.twoIndexStepThreshold)
           )
        {
          return(FAILURE);
        }
      }

      psc = e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.
        primaryCPICH_Info.primaryScramblingCode;
  
      WRRC_MSG1_HIGH("RRCEUL: ASU- serving e-dch repointing to psc: %d", 
        psc);

      e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );
      /* store hich info */
      if (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell, 
                e_HICH_InformationPresent))
      {
        if (FAILURE == rrcllcpcie_update_e_hich_info_and_mask(e_rl_idx, 
                                                              &e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.e_HICH_Information,
                                                              psc
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                            ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                            ))
        {
          return FAILURE;
        }
      }
      if((RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell,
                   e_RGCH_InfoPresent)) && 
         (RRC_CHECK_MSG_TYPE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.e_RGCH_Info,
       T_rrc_E_DCH_RL_InfoNewServingCell_r7_e_RGCH_Info_e_RGCH_Information))
        )
      {
        e_rgch_ptr = e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.e_RGCH_Info.u.e_RGCH_Information;
      }
      else
      {
        /* This means that the E-RGCH Info IE is not present*/
        e_rgch_ptr = NULL;
      }

      /* store rgch info */
      if (FAILURE == rrcllcpcie_process_e_rgch_info(
          RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell, 
            e_RGCH_InfoPresent),
        e_rgch_ptr,
        psc, 
        TRUE /*is_need_to_honor_e_rl_rel_ind set this to TRUE as default value*/
        
#ifdef FEATURE_WCDMA_DC_HSUPA
       ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        ))
      {
        return(FAILURE);
      }

      /* store agch info */
      if (FAILURE == rrcllcpcie_process_e_agch_info(
        TRUE, 
        &e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewServingCell.e_AGCH_Information,
        psc))
      {
        return(FAILURE);
      }

      if (FAILURE == rrcllcpcie_process_serving_e_dch_rl_indicator(
        TRUE,
        psc))
      {
        return(FAILURE);
      }

      if (FAILURE == rrcllcpcie_validate_hich_rgch_info(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
      , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */

      ))
      {
        return(FAILURE);
      }

      /* since AGCH is mandatory in this IE, hence minimum e_dl_info is reconfigured */
      rrcllc_update_l1_e_req_mask_for_e_dl_info(TRUE);

    }/* rrc_E_DCH_RL_InfoNewServingCell_r7_present */

    if (RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_reconfig_info_ptr, 
             e_DCH_RL_InfoOtherCellListPresent))
    {
      e_rl_info_other_cell_ptr = &(e_dch_reconfig_info_ptr->e_DCH_RL_InfoOtherCellList);
      n_value = e_rl_info_other_cell_ptr->n;
    
      while(n_value != 0)
      {
        psc = e_rl_info_other_cell_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode;

        MSG_HIGH("RRCEUL: e-dch info -HICH: 0x%x, RGCH: 0x%x, updated for psc: %d", 
            (RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                e_HICH_InfoPresent)), 
            (RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                e_RGCH_InfoPresent)), psc);

        if ((RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                 e_HICH_InfoPresent)) &&
            (RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                e_RGCH_InfoPresent)))
        {
          is_e_dl_info_present = TRUE;
        }

        if((RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index],
                        e_HICH_InfoPresent))&&
            (RRC_CHECK_MSG_TYPE(e_rl_info_other_cell_ptr->elem[n_index].e_HICH_Info,
                            T_rrc_E_DCH_RL_InfoOtherCell_e_HICH_Info_e_HICH_Information)))
              {
               e_hich_info_ptr=e_rl_info_other_cell_ptr->elem[n_index].e_HICH_Info.u.e_HICH_Information;
              }
            else
              {
              e_hich_info_ptr=NULL;
              }
        if (FAILURE == rrcllcpcie_process_e_hich_info(
            RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
             e_HICH_InfoPresent),
            e_hich_info_ptr,
          psc,
          TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
            , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
            ))
        {
          return(FAILURE);
        }
        if((RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index],
                         e_RGCH_InfoPresent)) && 
               (RRC_CHECK_MSG_TYPE(e_rl_info_other_cell_ptr->elem[n_index].e_RGCH_Info,
           T_rrc_E_DCH_RL_InfoOtherCell_e_RGCH_Info_e_RGCH_Information))
              )
           {
             e_rgch_ptr = e_rl_info_other_cell_ptr->elem[n_index].e_RGCH_Info.u.e_RGCH_Information;
           }
           else
           {
             /* This means that the E-RGCH Info IE is not present*/
             e_rgch_ptr = NULL;
           }

        if (FAILURE == rrcllcpcie_process_e_rgch_info(
            RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index],e_RGCH_InfoPresent), 
         e_rgch_ptr,
          psc,
          TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
          ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
           ))
        {
          return(FAILURE);
        }

        n_value--;
        n_index++;
      }

      /* update the l1_e_req_mask */
      rrcllc_update_l1_e_req_mask_for_e_dl_info(is_e_dl_info_present);
    } /* rrc_e_DCH_RL_InfoOtherCellList_present */
  }

  return(SUCCESS);
}

#ifdef FEATURE_WCDMA_REL7_EDPCCH_POWER_BOOST
/*====================================================================
FUNCTION: rrcllcpcie_process_edpcch_boost_info()

DESCRIPTION:
   This function updates EDPCH Boost info
   Absence of this IE means that boosting of E-DPCCH is disabled

DEPENDENCIES:
  None.

RETURN VALUE:
   SUCCESS/FAILURE

SIDE EFFECTS:

====================================================================*/
uecomdef_status_e_type rrcllcpcie_process_edpcch_boost_info
(
  rrc_E_TFC_Boost_Info_r7 *e_tfc_boost_info_ptr,
  OSS_UINT32 e_tfc_boost_info_present
)
{
  if ((e_tfc_boost_info_present) && (TRUE == rrcueci_nv_supports_edpcch_pwr_boost()))
  {
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.e_tfci_boost_val = e_tfc_boost_info_ptr->e_TFCI_Boost;
    
    if(e_tfc_boost_info_ptr->m.delta_T2TPPresent )
    {
      ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.delta_t2tp = e_tfc_boost_info_ptr->delta_T2TP;
    }
    else
    {
      if(e_tfc_boost_info_ptr->e_TFCI_Boost != 127 )
      {
        WRRC_MSG0_ERROR("delta_T2TP mandatory if e_TFCI_Boost not 127");
        return FAILURE;
      }
      /*Invalid value. L1 shld not look into it.*/
      ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.delta_t2tp = 0xFF;
    }
    rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);
    WRRC_MSG2_HIGH("EDPCCH boost value %d, Delta T2TP %d",
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.e_tfci_boost_val,
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.delta_t2tp);
  }
  else if (ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.e_tfci_boost_val != 0xFF)
  {
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.e_tfci_boost_val = 
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.delta_t2tp = 0xFF;
    rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);
   WRRC_MSG2_HIGH("EDPCCH boost value %d, Delta T2TP %d",
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.e_tfci_boost_val,
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_tfc_boost_info.delta_t2tp);
  }
  return SUCCESS;
}
#endif
/*============================================================================
FUNCTION: rrcllcpcie_process_edpch_interpolation_info()

DESCRIPTION:
  This function updates EDPCH power interpolation info
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_edpch_interpolation_info
(
  rrc_E_DPDCH_PowerInterpolation  e_dpch_pwr_interpolation_info,
  OSS_UINT32 e_dpch_pwr_interpolation_info_present
)
{
   /*
    absence == disable only when “E-DPDCH power interpolation” is absent.
   	1.	In reconfiguration message:
     	a.	If "E-DCH" info is missing, UE continues its current behavior
     	b.	If "E-DPCCH Info" is missing, UE continues its current behavior
     	c.	If "E-DPDCH power interpolation" is missing, UE disable power interpolation.
   	2.	In ASU: if "E-DPDCH power interpolation" is missing UE disable power interpolation.
   */
        
  if((e_dpch_pwr_interpolation_info_present) && (e_dpch_pwr_interpolation_info == TRUE))
    {
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpdch_pwr_interpolation = TRUE;
    rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);
  } 
  else if(ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpdch_pwr_interpolation == TRUE)
  {
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpdch_pwr_interpolation = FALSE;
    rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);
  } 

  if((current_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpdch_pwr_interpolation != ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpdch_pwr_interpolation) || 
		(ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpdch_pwr_interpolation == TRUE))
  {
    WRRC_MSG2_HIGH("e_dpch_pwr_interpolation_info : %d, e_dpdch_pwr_interpolation: %d",
      e_dpch_pwr_interpolation_info,ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpdch_pwr_interpolation);
  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_e_dpcch__r7info()

DESCRIPTION:
  This function updates IE "dl per rl info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_e_dpcch_info_r7
(
  OSS_UINT32 e_dpcch_info_present,
  rrc_E_DPCCH_Info_r7*e_dpcch_info_ptr
)
{
  if (e_dpcch_info_present)
  {
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpcch_info.e_dpcch_pwr_offset = 
      e_dpcch_info_ptr->e_DPCCH_DPCCH_PowerOffset;
    /* Since L1 parameters are present hence update the bit mask to indicate the same */
    rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);

    ordered_config_ptr->mac_e_config.e_dch_info.e_dpcch_info.happy_bit_delay_in_ms = 
      rrcllcpcie_convert_asn1_happy_bit_delay_condn_to_ms(
      e_dpcch_info_ptr->happyBit_DelayCondition);

#ifdef FEATURE_WCDMA_REL7_EDPCCH_POWER_BOOST
    if (FAILURE == rrcllcpcie_process_edpcch_boost_info(&e_dpcch_info_ptr->e_TFC_Boost_Info, RRC_CHECK_MSG_TYPE_IE_PTR(e_dpcch_info_ptr,e_TFC_Boost_InfoPresent)))
    {
      return FAILURE;
    }
#else
    if (RRC_CHECK_MSG_TYPE_IE_PTR(e_dpcch_info_ptr,e_TFC_Boost_InfoPresent))
    {
      WRRC_MSG0_ERROR("RRCHSPA+: e_TFCI_Boost_present not supported ");
    }
#endif

    rrcllcpcie_process_edpch_interpolation_info(e_dpcch_info_ptr->e_DPDCH_PowerInterpolation,
        (RRC_CHECK_MSG_TYPE_IE_PTR(e_dpcch_info_ptr, 
                e_DPDCH_PowerInterpolationPresent))) ;
  }
  rrcllc_update_mac_eul_action(TRUE);

  return SUCCESS;
}

/*============================================================================
FUNCTION: rrcllcpcie_process_e_dpdch_info_r7()

DESCRIPTION:
  This function updates IE "dl per rl info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_e_dpdch_info_r7
(
  OSS_UINT32 e_dpdch_info_present,
  rrc_E_DPDCH_Info_r7 *e_dpdch_info_ptr
)
{
  if (e_dpdch_info_present)
  {
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_tfci_table_idx = 
      e_dpdch_info_ptr->e_TFCI_TableIndex;

    ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_table_index = 
      e_dpdch_info_ptr->e_TFCI_TableIndex;    

    if (FAILURE == rrcllcpcie_convert_asn1_e_dch_max_ch_codes(
      e_dpdch_info_ptr->maxChannelisationCodes,
      &ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info))
    {
      return(FAILURE);
    }

    /* multiply received value by 4 - as per rrc-l1 interface requirements */
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_dpdch_pl_non_max = 
      e_dpdch_info_ptr->pl_NonMax << 2;

    if (FAILURE == rrcllcpcie_process_reference_e_tfcis_r7(
        &e_dpdch_info_ptr->reference_E_TFCIs,
        &ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info))
    {
      return(FAILURE);
    }

    if (FAILURE == rrcllcpcie_process_sched_info_config(
        &e_dpdch_info_ptr->schedulingInfoConfiguration,
        &ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info))
    {
      return(FAILURE);
    }

    if (RRC_CHECK_MSG_TYPE_IE_PTR(e_dpdch_info_ptr, 
            e_DCH_MinimumSet_E_TFCIPresent))
    {
      ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_min_set =
        e_dpdch_info_ptr->e_DCH_MinimumSet_E_TFCI;
    }
    else
    {
      ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_min_set = 
        MAC_E_TFCI_MIN_SET_NOT_PRESENT;
    }

    /* reset the threshold because its a MD IE */
    ordered_config_ptr->l1_e_info.e_dl_info.grant_config.three_index_step_threshold = 
      L1_SG_STEP_THRESHOLD_NOT_PRESENT;
    ordered_config_ptr->l1_e_info.e_dl_info.grant_config.two_index_step_threshold = 
      L1_SG_STEP_THRESHOLD_NOT_PRESENT;
    if (FAILURE == rrcllcpcie_process_two_and_three_step_threshold_info(
        RRC_CHECK_MSG_TYPE_IE_PTR(e_dpdch_info_ptr, 
                 threeIndexStepThresholdPresent),
        e_dpdch_info_ptr->threeIndexStepThreshold,
        RRC_CHECK_MSG_TYPE_IE_PTR(e_dpdch_info_ptr, 
                 twoIndexStepThresholdPresent),
        e_dpdch_info_ptr->twoIndexStepThreshold)
       )
    {
      return(FAILURE);
    }

    WRRC_MSG0_HIGH("RRCEUL:Init min_beta_ed");
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.min_beta_ed = NUM_L1_E_MIN_BED; /* invalid */

    /* set bit-mask to indicate L1 that UL info is received */
    rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);    
    rrcllc_update_mac_eul_action(TRUE);
    
  }

  return(SUCCESS);
}
/*===========================================================================
FUNCTION        get_rl_add_info_r7()

DESCRIPTION     This function translates radio link addition information from
                a radio link addition list into the RRC config database. This
                function is only called from an Active Set Update Message

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    The RRC config database as pointed to by the input parameters
                will be updated.
===========================================================================*/
static uecomdef_status_e_type get_rl_add_info_r7
(
  rrc_RL_AdditionInformation_r7 *ie_ptr,
  l1_dl_phychan_db_struct_type *dl_phychan,
  boolean *duplicate_add_attempted
)
{
  /* local loop variable */
  uint8 ix;

  *duplicate_add_attempted = FALSE;

  /* Check to determine if this is a duplicate radio link.  If so, return
     SUCCESS, since that's not an error and there's no more work to be done. */
  for(ix = 0; ix < ordered_config_ptr->l1_dl_chan_parms.num_rl; ix++)
  {
    if(dl_phychan->dl_per_rl[ix].pri_cpich_scr_code ==
       ie_ptr->primaryCPICH_Info.primaryScramblingCode)
    {
      /* we may want to add the processing of the IEs instead of ignoring RL info */
      WRRC_MSG1_ERROR("ASU trying to add psc: %d -already part of active set - ignoring RL info",
        ie_ptr->primaryCPICH_Info.primaryScramblingCode);
      *duplicate_add_attempted = TRUE;
      return SUCCESS;
    }
  }

  /* look for the first available radio link slot that is available */
  for(ix = 0; ix < UE_MAX_RL; ix++)
  {
    /* look in the ordered_config database for this radio link */
    if(dl_phychan->dl_per_rl[ix].pri_cpich_scr_code == RRCLLC_INVALID_CPICH_SCR_CODE)
    {
      /* Get the Primary Scrambling Code */
      if(ie_ptr->primaryCPICH_Info.primaryScramblingCode <= RRCLLC_MAX_CPICH_SCR_CODE)
      {
        /*If Cell_id is present for this RL, store it in cell_id_per_rl */      
        if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                    cell_IdPresent))
        {
          cell_id_per_rl[ix] = (uint32) rrc_translate_cell_id(&ie_ptr->cell_Id);
        } 
        dl_phychan->dl_per_rl[ix].pri_cpich_scr_code = (uint16)ie_ptr->primaryCPICH_Info.primaryScramblingCode;
      }
      else
      {
        WRRC_MSG1_ERROR("PRI SCR CODE %d is out of range",
          ie_ptr->primaryCPICH_Info.primaryScramblingCode);
        return FAILURE;
      }
      
      /* This is the first open RL slot, so place the info here */
      if (RRC_CHECK_MSG_TYPE(ie_ptr->dl_dpchInfo, 
                  T_rrc_RL_AdditionInformation_r7_dl_dpchInfo_dl_DPCH_InfoPerRL))
      {
        if(get_dl_dpch_info_for_each_rl_r5(
          ie_ptr->dl_dpchInfo.u.dl_DPCH_InfoPerRL,
          dl_phychan, ix, TRUE) == FAILURE)
        {
        /* bad status from get_dl_dpch_info_for_each_rl.  Return FALSE
          indicating an error */
          WRRC_MSG0_HIGH("get_dl_dpch_info_for_each_rl failed");
          return FAILURE;
        }
      }
      else
      {
        if(get_dl_fdpch_info_for_each_rl_r7(ie_ptr->dl_dpchInfo.u.dl_FDPCH_InfoPerRL,
          dl_phychan, ix, TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
          , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ))
        {
        /* bad status from get_dl_dpch_info_for_each_rl.  Return FALSE
          indicating an error */
          WRRC_MSG0_HIGH("get_dl_fdpch_info_for_each_rl failed");
          return FAILURE;
        }
      }
      /* Ignore the SCCPCH/FACH and TFCI combining info for now */
      
      /* No need to continue */
      break;
    } /* end RL match if */
  } /* end looking for open RL slot */
  
  /* everything is good if here */
  return SUCCESS;

}
/*============================================================================
FUNCTION: rrcllcpcie_process_rl_addition_info_list_r7()

DESCRIPTION:
  This function updates IE "rrc_RL_AdditionInformationList_r6 " in ordered config
  and update e_dch parameters

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_rl_addition_info_list_r7
(
  OSS_UINT32 rl_additon_info_list_present,
  rrc_RL_AdditionInformationList_r7 *rl_add_ptr
)
{
  uint8                            idx;  /* local loop variable */
  uint16                           num_rl;   /* local RL count */
  /* flag to prevent erroneous increment of number of RL on attempt to add
     a duplicate RL */
  boolean duplicate_add_attempted = FALSE;
  uint32 e_rl_idx;
  boolean is_e_dl_info_present = FALSE;
  uint32 n_value = 0;
  uint32 n_index = 0;
  
  
  if(rl_additon_info_list_present)
  {
    idx = 0;

    if(SUCCESS != validate_fdpch_information_r7(rl_add_ptr))
    {
      return FAILURE;   
    }
    num_rl = ordered_config_ptr->l1_dl_chan_parms.num_rl;
    n_value = rl_add_ptr->n;
    while((n_value != 0) && (idx < (UE_MAX_RL - num_rl)))
    {
      if(get_rl_add_info_r7(&rl_add_ptr->elem[n_index], &ordered_config_ptr->l1_dl_chan_parms,
                         &duplicate_add_attempted) == FAILURE)
      {
        WRRC_MSG0_HIGH("get_rl_add_info() failed");
        return FAILURE;
      }

      /* one more radio link in ORDERED_CONFIG */
      if(!duplicate_add_attempted)
      {
        ordered_config_ptr->l1_dl_chan_parms.num_rl++;
      }
      if (RRC_CHECK_MSG_TYPE_IE(rl_add_ptr->elem[n_index], 
                  e_HICH_InformationPresent))
      {
        /* if we are inside this if check then it means that RRC needs to indicate
           to L1 that some of the parameters in DL has changed */
        is_e_dl_info_present = TRUE;

        e_rl_idx = get_e_rl_index_for_a_given_psc(
              rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

        if (FAILURE == rrcllcpcie_update_e_hich_info_and_mask(e_rl_idx, 
                                                              &rl_add_ptr->elem[n_index].e_HICH_Information,
                                                              rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                            ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                            ))
        {
          return FAILURE;
        }
      }

      if (RRC_CHECK_MSG_TYPE_IE(rl_add_ptr->elem[n_index], 
                  e_RGCH_InformationPresent))
      {
        /* if we are inside this if check then it means that RRC needs to indicate
           to L1 that some of the parameters in DL has changed */
        is_e_dl_info_present = TRUE;

        if (FAILURE == rrcllcpcie_process_e_rgch_information(
            rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode,
            &rl_add_ptr->elem[n_index].e_RGCH_Information
#ifdef FEATURE_WCDMA_DC_HSUPA
          ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ))
        {
          return(FAILURE);
        }
      }

      /* get the next RL */
      n_value--;
      n_index++;
      idx++;
    } /* end loop of all included RLs to add */ 
    if (FAILURE == rrcllcpcie_validate_hich_rgch_info(ordered_config_ptr 
#ifdef FEATURE_WCDMA_DC_HSUPA
      , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */

      ))
    {
      return(FAILURE);
    }
  } /* end RL Addition information */

  /* Make sure we actually have some RLs in the active set */
  if(ordered_config_ptr->l1_dl_chan_parms.num_rl == 0)
  {
    WRRC_MSG0_HIGH("No RLs in aset after ASU");
    return FAILURE;
  }

  /* update the l1_e_req_mask */
  rrcllc_update_l1_e_req_mask_for_e_dl_info(is_e_dl_info_present);

  return(SUCCESS);
}

/*====================================================================
FUNCTION      set_meas_feedback_info_r7()

DESCRIPTION   This function sets the Meas Feedback Information in
              L1 structure in OC.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire operation is successful,
              FAILURE otherwise

SIDE EFFECTS  None.
====================================================================*/

uecomdef_status_e_type set_meas_feedback_info_r7
(
  rrc_Measurement_Feedback_Info_r7* meas_feedback_ptr
)
{
  if (RRC_CHECK_MSG_TYPE(meas_feedback_ptr->modeSpecificInfo,
                 T_rrc_Measurement_Feedback_Info_r7_modeSpecificInfo_fdd))
  {
    if ((meas_feedback_ptr->modeSpecificInfo.u.fdd->cqi_RepetitionFactor <
      RRCLLC_CQI_MIN_REP_FACTOR) && (meas_feedback_ptr->modeSpecificInfo.
      u.fdd->cqi_RepetitionFactor > RRCLLC_CQI_MAX_REP_FACTOR))
    {
      WRRC_MSG1_ERROR("RRCHS:Invalid CQI Rfactor %d, 1..4",
        meas_feedback_ptr->modeSpecificInfo.u.fdd->cqi_RepetitionFactor);
      return FAILURE;
    }


    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_rep_factor =
      (uint8) meas_feedback_ptr->modeSpecificInfo.u.fdd->cqi_RepetitionFactor;

    if (meas_feedback_ptr->modeSpecificInfo.u.fdd->deltaCQI > RRCLLC_DELTA_CQI_MAX)
    {
      WRRC_MSG1_ERROR("RRCHS:Invalid DELTA CQI %d, 0..8",
        meas_feedback_ptr->modeSpecificInfo.u.fdd->deltaCQI);
      return FAILURE;
    }
    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_cqi = (uint8)
      meas_feedback_ptr->modeSpecificInfo.u.fdd->deltaCQI;


    
    switch(meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle)
    {
      case rrc_Feedback_cycle_r7_fc0:
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 0;
        break;
  
      case rrc_Feedback_cycle_r7_fc2:
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 2;
        break;
  
      case rrc_Feedback_cycle_r7_fc4:
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 4;
        break;
  
      case rrc_Feedback_cycle_r7_fc8:
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 8;
        break;
  
      case rrc_Feedback_cycle_r7_fc10:
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 10;
        break;
  
      case rrc_Feedback_cycle_r7_fc20:
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 20;
        break;
  
      case rrc_Feedback_cycle_r7_fc40:
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 40;
        break;
  
      case rrc_Feedback_cycle_r7_fc80:
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 80;
        break;
  
      case rrc_Feedback_cycle_r7_fc160:
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 160;
        break;
  
      case rrc_Feedback_cycle_r7_fc16:
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 16;
        break;
  
      case rrc_Feedback_cycle_r7_fc32:
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 32;
        break;
  
      case rrc_Feedback_cycle_r7_fc64:
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle = 64;
        break;
  
      default:
        WRRC_MSG1_ERROR("RRCHS:Incorrect Value",
          meas_feedback_ptr->modeSpecificInfo.u.fdd->feedback_cycle);
        return FAILURE;
  
    }

    if ((meas_feedback_ptr->modeSpecificInfo.u.fdd->measurementPowerOffset <
      RRCLLC_MIN_MEAS_POWER_OFFSET) &&
      (meas_feedback_ptr->modeSpecificInfo.u.fdd->measurementPowerOffset >
      RRCLLC_MAX_MEAS_POWER_OFFSET))

    {
      WRRC_MSG1_ERROR("RRCHS:Invalid MeasPowerOffset %d, -12..26",
        meas_feedback_ptr->modeSpecificInfo.u.fdd->measurementPowerOffset);
      return FAILURE;
    }


    ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.po_hs_dsch = (int8)
      meas_feedback_ptr->modeSpecificInfo.u.fdd->measurementPowerOffset;
    /* rrc_UL_DPCH_PowerControlInfo_r5 : ACK/NACK/REPITITON factor from Power Control */
  }
  else
  {
    WRRC_MSG0_ERROR("RRCHS:Invalid Meas Feedback Info");
    return FAILURE;
  }
  return SUCCESS;

}
/*====================================================================
FUNCTION      set_hsscch_info_r7()

DESCRIPTION   This function sets the Channelization code required
              for HSPDSCH in L1 structure in OC.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire operation is successful,
              FAILURE otherwise

SIDE EFFECTS  None.
====================================================================*/
uecomdef_status_e_type set_hsscch_info_r7
(
  rrc_HS_SCCH_Info_r7* hsscch_info_ptr
)
{
  struct rrc_HS_SCCH_Info_r7_hS_SCCHChannelisationCodeInfo *hsscch_list_ptr = NULL;
  uint8 cnt = 0;
  uint8 n_value = 0;
  uint8 n_index = 0;

  ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code_valid = FALSE;

  if(hsscch_info_ptr->modeSpecificInfo.t == T_rrc_HS_SCCH_Info_r7_modeSpecificInfo_tdd)
  {
    return FAILURE;
  }

  /* Sec Scr Code unsupported by L1 */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(hsscch_info_ptr->modeSpecificInfo.u.fdd, 
                 dl_ScramblingCodePresent))
  {

    if ((hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode == 0) ||
        (hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode > 15))
    {
      WRRC_MSG1_ERROR("RRCHS:Incorrect Sec Scr Code %d", 
          hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode);
      return FAILURE;
    }

    ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code_valid = TRUE;

    ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code = (uint8)
      hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode;
  }

  /* Channelization Codes always need to be a cummulative sum that network needs to specify.
  So initilize the number to 0 */


  ordered_config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code = 0;

  hsscch_list_ptr = &(hsscch_info_ptr->modeSpecificInfo.u.fdd->hS_SCCHChannelisationCodeInfo);
  n_value = hsscch_list_ptr->n;

  while ((n_value != 0) && (cnt < L1_DL_HS_SCCH_CODES_MAX))
  {
    /* Spec allows allows channelisation code 0 also but since MSM6275 will
    not support secondary scrambling code, it will collide with OVSF 0 and 1
    on SF 256 for CPICH and PCCPCH channels. */
    if ((hsscch_list_ptr->elem[n_index] > RRCLLC_MAX_SCCH_CHAN_CODE) || (hsscch_list_ptr->elem[n_index] == 0))
    {
      WRRC_MSG1_ERROR("RRCHS:Invalid Channelization code %d", hsscch_list_ptr->elem[n_index]);
      return FAILURE;
    }
    ordered_config_ptr->l1_hsdpa_info.hs_scch_info.ch_code[cnt++] = (uint8) hsscch_list_ptr->elem[n_index];

    n_value--;
    n_index++;
  }

  ordered_config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code = cnt;



  return SUCCESS;

}

/*============================================================================
FUNCTION: rrcllcpcie_process_dl_hspdsch_info_and_update_hsdpa_msg_params_r7()

DESCRIPTION:
  This function updates IE "dl hspdsch info " in ordered config and update
  hsdpa_msg_param variable
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r7
(
  OSS_UINT32 dl_hspdsch_info_present,
  rrc_DL_HSPDSCH_Information_r7 *dl_hspdsch_info_ptr,
  /* is inter freq handover involved */
  OSS_UINT32 is_ifhho_involved,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  if (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
  {
    if (dl_hspdsch_info_present)
    {
      hsdpa_msg_params.msg_params_present = TRUE;
      hsdpa_msg_params.hspdsch_info_present = TRUE;

      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = FALSE;
      if(RRC_CHECK_MSG_TYPE(dl_hspdsch_info_ptr->modeSpecificInfo, 
                    T_rrc_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd))
      {
        if(RRC_CHECK_MSG_TYPE_IE_PTR(dl_hspdsch_info_ptr->modeSpecificInfo.u.fdd, 
                    dl_64QAM_ConfiguredPresent))
        {
          if(CHECK_WCDMA_OPTIONAL_FEATURE_64QAM_SUPPORTED)
          {
            ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = TRUE;
            WRRC_MSG0_HIGH(" 64 QAM is started/continued");
          }
          else
          {
            WRRC_MSG1_HIGH("64 QAM not supported NV value %d",nv_hsdpa_category);
            return FAILURE;
          }
        }
      }
      else if(RRC_CHECK_MSG_TYPE(dl_hspdsch_info_ptr->modeSpecificInfo, 
                     T_rrc_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd))
      {
         return FAILURE;
      }
      if(current_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured != 
        ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured)
      {
        hsdpa_msg_params.hsdsch_info_present = TRUE;
        
        WRRC_MSG2_HIGH("Set HS-DSCh bitmask as 64 QAM status is changed: Before %d, current %d (0:Not present/1:Present)",
            current_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured ,
             ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured);
      }
    }
    /* Determine if IFHHO is involved */
    if (is_ifhho_involved)
    {
      WRRC_MSG0_HIGH("RRCHS:InterFreq HO");
      hsdpa_msg_params.ifhho_involved = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }
    if(rrcllc_set_macehs_or_machs_and_check_if_coexist()== TRUE)
    {
      WRRC_MSG2_HIGH("MACEHS: MAC EHS %d and MAC HS %d cant co-exist ",
                          ordered_config_ptr->mac_dl_parms.num_mac_ehs_queue, 
                          ordered_config_ptr->mac_dl_parms.num_dflow);
      return FAILURE;
    }
  
    rrcllc_set_machs_ehs_transition();
    
    /* Set HSDPA Action & Physical Channel Parameters associated with it */
    if ((rrcllc_determine_hsdpa_action_r7(dl_hspdsch_info_ptr) == SUCCESS) 
#ifdef FEATURE_MAC_I
         && 
        (rrcllc_is_maci_compatible_with_hsdpa() == SUCCESS)
#endif
       )
    {
      rrc_set_hsdpa_action_in_machs_macehs();

      if(((ordered_config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_HS_TO_EHS )
        ||(ordered_config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_EHS_TO_HS ))
        && (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE))
      {
        WRRC_MSG2_ERROR("MAC-HS <->  MAC-EHS transition %d, and Mac Reset Ind not set %d, reject config",
              ordered_config_ptr->mac_dl_parms.mac_hs_transition_type,
              ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);
        return FAILURE;
      }
#ifdef FEATURE_WCDMA_HS_FACH
     /*for EFACH to MAC-HS transition*/
      if((ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS) &&
         (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE)&&
         (current_config_ptr->hs_status_in_e_fach == TRUE))
      {
       /* The IE mac_hs_reset_indicator is not needed in the HANDOVER TO UTRAN
          COMMAND and the RRC CONNECTION SETUP messages. Otherwise, it is optional.*/
       if (RRC_STATE_CONNECTING != rrc_get_state())
       {         
        WRRC_MSG2_ERROR("MAC-EHS ->  MAC-HS transition %d, and Mac Reset Ind not set %d, reject config",
                ordered_config_ptr->mac_dl_parms.mac_hs_transition_type,
                ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);
        return FAILURE;
      }
     }
#endif
      if((ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE)
        &&((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
               (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
               ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
                (rrc_get_hsdpa_status() == HSDPA_ACTIVE))))
      {
        if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS )
        {
            WRRC_MSG0_ERROR("64 QAm cannot be started on MAC-HS");
            return FAILURE;
        }
      }

     WRRC_MSG5_MED("HSDPA :Action %d set in MAC and HS+CM enabled %d CM status L1/RRC/OTA %d %d %d",
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action,hsdpa_cm_enabled,
      l1_cm_query_compressed_mode_active(),
               rrcllc_is_cm_active(ordered_config_ptr),cm_status_from_ota_msg);

      /* Check if network is trying to activate CM with HSDPA */
      if (hsdpa_cm_enabled == FALSE)
      {
        /* Check if network is trying to activate CM with HSDPA */
        if (((((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
               (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
               ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
                (rrc_get_hsdpa_status() == HSDPA_ACTIVE))) && 
              rrcllc_is_cm_active(ordered_config_ptr) == TRUE)) ||
            ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) &&
             (l1_cm_query_compressed_mode_active() == FALSE) &&
             (cm_status_from_ota_msg == ACTIVATE_CM)) ||
            ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) &&
             (l1_cm_query_compressed_mode_active() == TRUE) &&
             (cm_status_from_ota_msg == RRC_CM_NONE)))
        {
          WRRC_MSG0_HIGH("RRCHS: CM with HSDPA Active");
          return FAILURE;
        }
      }
    }
    else
    {
       WRRC_MSG0_ERROR("RRCHS:Error during HSDPA action processing"); 
      return FAILURE;
    }
  }

  return(SUCCESS);
}
/*============================================================================
FUNCTION: rrcllcpcie_process_e_agch_info_r7()

DESCRIPTION:
  This function processes e-AGCH information and updates the information
  in a given e_rl_index
      
DEPENDENCIES:
  This function needs to be called only after calling function to process E-HICH info.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_e_agch_info_r7
(
  OSS_UINT32 e_agch_info_present,
  rrc_E_AGCH_Information_r7 *e_agch_info_ptr,
  uint32 psc
)
{
  uint32 e_rl_idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_e_info.e_dl_info;

  if ((e_agch_info_present) && 
      (RRC_CHECK_MSG_TYPE(e_agch_info_ptr->modeSpecific, 
                   T_rrc_E_AGCH_Information_r7_modeSpecific_fdd)))
  {
    e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

    if ((e_rl_idx == e_dl_info_ptr->num_e_dl_rl_add_recfg_info)|| (e_rl_idx >= L1_MAX_EDCH_RL))
    {
      WRRC_MSG2_ERROR("RRCEUL: psc:%d(idx: %d) not found in E-DCH RL database i.e. E-AGCH without E-HICH Info ",
        psc, e_rl_idx);
      return(FAILURE);
    }

    /* store RGCH info only if E-HICH info is already stored */
    if (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
      L1_E_HICH_INFO_PRESENT)
    {

      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_agch_info.ch_code = 
        e_agch_info_ptr->modeSpecific.u.fdd->e_AGCH_ChannelisationCode;
    }
    else
    {
      /* as per our current understanding NW should not provide E-AGCH info
         unless E-HICH is provided in config message or already stored in UE */
      WRRC_MSG0_ERROR("RRCEUL: NW trying to provide E-AGCH info without E-HICH Info");
      return(FAILURE);
    }

    if (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
      L1_E_AGCH_INFO_PRESENT)
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |=
        L1_E_AGCH_INFO_RECFG;
    }
    else
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |=
        L1_E_AGCH_INFO_ADD|L1_E_AGCH_INFO_PRESENT;
    }
  }

  return(SUCCESS);
}
/*============================================================================
FUNCTION: rrcllcpcie_process_e_info_in_dl_info_per_rl_list_r7()

DESCRIPTION:
  This function updates IE "dl per rl info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_e_info_in_dl_info_per_rl_list_r7
(
  OSS_UINT32 dl_info_per_rl_list_present,
  rrc_DL_InformationPerRL_List_r7 *dl_info_per_rl_list_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  uint32 e_rl_idx = 0;
  uint32 n_value = 0;
  uint32 n_index = 0;
  rrc_E_RGCH_Information * e_rgch_ptr= NULL;
    rrc_E_HICH_Information * e_hich_info_ptr =NULL;
    /* Look into this IE only if next UE state is DCH */
  if (dl_info_per_rl_list_present && 
      (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
     )
  {
    uint32 num_serv_e_dch_rl_true = 0;
    uint32 psc = 0;
    boolean is_e_dl_info_present = FALSE;
    rrc_DL_InformationPerRL_List_r7 *tmp_ie_ptr = dl_info_per_rl_list_ptr;
    boolean is_need_to_honor_e_rl_rel_ind = TRUE;

    /* Firt time into DCH is also considered a HHO.  So only populate the release list of 
     * EDCH in the case of DCH->DCH only
     */
    if (ordered_config_ptr->is_hho && (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      /* if its inter-freq handover then clear any stored E-Channel information.
         Also indicate layer1 about the release psc's */
      rrcllcpcie_release_and_clear_all_e_dch_active_set_rl(
#ifdef FEATURE_WCDMA_DC_HSUPA
      FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
      );
      is_need_to_honor_e_rl_rel_ind = FALSE;
    }

    /* loop through all the rls informations to extract e-dch related info */
    n_value = tmp_ie_ptr->n;
    
    while (n_value != 0)
    {
      if (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo, 
                  T_rrc_DL_InformationPerRL_r7_modeSpecificInfo_fdd))
      {
        psc = tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

        /* check if any E-Channel related info is present in this RL Info */
        if ((RRC_CHECK_MSG_TYPE_IE_PTR(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd, 
                    e_HICH_InfoPresent))
             ||(RRC_CHECK_MSG_TYPE_IE_PTR(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd, 
                     e_RGCH_InfoPresent))
             ||(RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index], 
                     e_AGCH_InformationPresent))
           )
        {
          /* if we are inside this if check then it means that RRC needs to indicate
             to L1 that some of the parameters in DL has changed */
          is_e_dl_info_present = TRUE;
          if((RRC_CHECK_MSG_TYPE_IE_PTR(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd,
                                  e_HICH_InfoPresent))&&
                      (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd->e_HICH_Info,
                                      T_rrc_DL_InformationPerRL_r7_e_HICH_Info_e_HICH_Information)))
          {
            e_hich_info_ptr= tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd->e_HICH_Info.u.e_HICH_Information;
          }
          else
          {
            e_hich_info_ptr=NULL;
          }

          if (FAILURE == rrcllcpcie_process_e_hich_info(
              RRC_CHECK_MSG_TYPE_IE_PTR(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd, 
            e_HICH_InfoPresent), 
              e_hich_info_ptr,
            psc,
            is_need_to_honor_e_rl_rel_ind
#ifdef FEATURE_WCDMA_DC_HSUPA
            , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
            ))
          {
            return(FAILURE);
          }

          if((RRC_CHECK_MSG_TYPE_IE_PTR(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd,
                           e_RGCH_InfoPresent)) && 
                 (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd->e_RGCH_Info,
             T_rrc_DL_InformationPerRL_r7_e_RGCH_Info_e_RGCH_Information))
              )
          {
            e_rgch_ptr = tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd->e_RGCH_Info.u.e_RGCH_Information;
          }
          else
          {
             /* This means that the E-RGCH Info IE is not present*/
            e_rgch_ptr = NULL;
          }

          if (FAILURE == rrcllcpcie_process_e_rgch_info(
              RRC_CHECK_MSG_TYPE_IE_PTR(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd, 
                      e_RGCH_InfoPresent), 
              e_rgch_ptr,
            psc,
            is_need_to_honor_e_rl_rel_ind
#ifdef FEATURE_WCDMA_DC_HSUPA
          ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
           ))
          {
            return(FAILURE);
          }
            
          if (FAILURE == rrcllcpcie_process_e_agch_info_r7(
              RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index], 
                       e_AGCH_InformationPresent), 
              &tmp_ie_ptr->elem[n_index].e_AGCH_Information,
            psc))
          {
            return(FAILURE);
          }
        }/* if any E-info IE is present */

        if (TRUE == tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->servingEDCH_RL_indicator)
        {
          if (FAILURE == rrcllcpcie_process_serving_e_dch_rl_indicator(
            TRUE,
            psc))
          {
            return(FAILURE);
          }
          num_serv_e_dch_rl_true++;
        }        
        else
        {
          e_rl_idx = ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx;
          /* If the current serving RL becomes non-serving, need to reset the flag*/
          if((e_rl_idx < L1_MAX_EDCH_RL) &&
             (ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[e_rl_idx].e_rl_psc == psc))
          {
            WRRC_MSG1_HIGH("RRCEUL: Serving cell ind for %d set to false",psc);
            ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx = L1_MAX_EDCH_RL;
          }
        }
      }/* mode-FDD */
      
      n_value--;
      n_index++;
    }/* while */

    if (num_serv_e_dch_rl_true > 1)
    {
      WRRC_MSG0_ERROR("Serving E-DCH RL set to TRUE in more than one RL");
      return(FAILURE);
    }

    if (FAILURE == rrcllcpcie_validate_hich_rgch_info(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
      , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */

      ))
    {
      return(FAILURE);
    }

    /* update the l1_e_req_mask */
    rrcllc_update_l1_e_req_mask_for_e_dl_info(is_e_dl_info_present);
  }/* dl_info_per_rl_list_present */
  return(SUCCESS);
}
/*====================================================================
FUNCTION      get_dl_dpch_info_for_each_rl_r7()

FILE NAME     This function gets the DL DPCH info for each RL

DESCRIPTION   This function translates the Downlink DPCH info for each
              RL IE to the RRC config database.  Note that it is assumed
              that a higher level routine is doing the translation from
              the linked list present in the ASN.1 decoder output to
              the array present in the RRC config database.  The radio
              link index is passed into this function and must be
              generated by that higher level routine.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if everything is ok, FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all of the parameters
              that are present in the IE.  For those parameters not
              present the values currently existing are untouched.  For
              each optional parameter that is present the corresponding
              bit in the optional parameters presence bitmask is set.
====================================================================*/
static uecomdef_status_e_type get_dl_dpch_info_for_each_rl_r7
(
  /* pointer to the IE */
  rrc_DL_DPCH_InfoPerRL_r7 *ie_ptr,

  /* pointer to the desired DL PhyChan parameter structure */
  l1_dl_phychan_db_struct_type *dl_phychan,

  /* radio link index */
  uint8 rl_idx,

  /* are we setting up a new radio link? */
  boolean is_new_rl
)
{
  l1_dl_info_per_rl_struct_type *rl_info;

  rrc_DL_ChannelisationCodeList *code_list_ptr;
  uint16 code_ch;
  uint16 new_tau_dpch;
  uint32 n_value = 0;
  uint32 n_index = 0;

  rrc_SF512_AndCodeNumber sf_choice;

  if (RRC_CHECK_COMMON_MSG_TYPE_PTR(ie_ptr, 
              rrc_DL_DPCH_InfoPerRL_r7_fdd))
  {
    if (rl_idx < UE_MAX_RL)
    {
      rl_info = &dl_phychan->dl_per_rl[rl_idx];
    }
    else
    {
      /* rl_idx too large for supported number of radio links */
      WRRC_MSG0_HIGH("rl_idx out of range");
      return FAILURE;
    }

    /* initialize the optional field bit mask */
    if(is_new_rl)
    {
      rl_info->dpch_per_rl.opt_parms_present_mask = 0;
    }

    /* Get the DPCH frame offset (TauDPCH) */
    new_tau_dpch = (uint16)ie_ptr->u.fdd->dpch_FrameOffset;

    /* This validation should be done by the ASN.1 encoder on the
     * network side, but better not to make any assumptions here.
     */
    if(new_tau_dpch > 149)
    {
      WRRC_MSG1_HIGH("Invalid Tau_DPCH: %s", new_tau_dpch);
      return FAILURE;
    }

    /* An existing radio link cannot have its TauDPCH changed by more
     * than 1.
     */
    if(!is_new_rl &&
       ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind != L1_TIMING_IND_INIT &&
        ABS((new_tau_dpch - rl_info->dpch_per_rl.frame_offset)) > 1 &&
        ABS((new_tau_dpch - rl_info->dpch_per_rl.frame_offset)) != 149)
    {
      WRRC_MSG2_HIGH("Tau_DPCH difference > 1: %d (old) %d (new)",
          rl_info->dpch_per_rl.frame_offset, new_tau_dpch);
      return FAILURE;
    }
    rl_info->dpch_per_rl.frame_offset = new_tau_dpch;

    /* Get the CPICH usage for channel estimation */
    switch (ie_ptr->u.fdd->pCPICH_UsageForChannelEst)
    {
      case rrc_PCPICH_UsageForChannelEst_mayBeUsed:
        rl_info->dpch_per_rl.use_pri_cpich = L1_USE_PRI_CPICH;
        break;

      case rrc_PCPICH_UsageForChannelEst_shallNotBeUsed:
        rl_info->dpch_per_rl.use_pri_cpich = L1_DO_NOT_USE_PRI_CPICH;
        break;

      default:
        /* bad enum value, return FALSE immediately */
        WRRC_MSG0_HIGH("Bad CPICH usage enum");
        return FAILURE;
    }

    /* Get the TPC Combination index */
    rl_info->dpch_per_rl.tpc_idx =
      (uint8) ie_ptr->u.fdd->tpc_CombinationIndex;

    /* Get the closed loop timing adjustment type */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->u.fdd,  
                closedLoopTimingAdjModePresent))
    {

        WRRC_MSG1_HIGH("Indicate CLT info in %d TXDivMode", dl_phychan->dl_common.tx_div_mode);
            
      if (dl_phychan->dl_common.tx_div_mode != L1_TX_DIV_NONE)
      {

        /* a cast here is ok as the mapping is as expected */
        rl_info->dpch_per_rl.closed_loop_timing_adj_mode =
          (uint8) ie_ptr->u.fdd->closedLoopTimingAdjMode;

        /* mark the Closed loop timing adjustment info as present */
        rl_info->dpch_per_rl.opt_parms_present_mask |=
          DL_DPCH_INFO_PER_CLOSED_LOOP_TIMING_ADJ_PRESENT;
      }
    }
    else
    {
      if(rl_info->dpch_per_rl.opt_parms_present_mask & DL_DPCH_INFO_PER_CLOSED_LOOP_TIMING_ADJ_PRESENT)
      {
	  WRRC_MSG0_HIGH("clearing CLT ");
    	  rl_info->dpch_per_rl.opt_parms_present_mask &=
  	     ~DL_DPCH_INFO_PER_CLOSED_LOOP_TIMING_ADJ_PRESENT;
      }
    }

    /* Get the secondary CPICH information */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr->u.fdd,  
             secondaryCPICH_InfoPresent))
    {
      /* set the secondary CPICH channelisation code */
      rl_info->dpch_per_rl.sec_cpich_ch_code =
        (uint16) ie_ptr->u.fdd->secondaryCPICH_Info.channelisationCode;

      if (RRC_CHECK_MSG_TYPE_IE(ie_ptr->u.fdd->secondaryCPICH_Info,
                 secondaryDL_ScramblingCodePresent))
      {
        /* set the secondary CPICH secondary scrambling code */
        rl_info->dpch_per_rl.sec_cpich_sec_scr_code =
          (uint16) ie_ptr->u.fdd->secondaryCPICH_Info.secondaryDL_ScramblingCode;

        rl_info->dpch_per_rl.opt_parms_present_mask |=
          DL_DPCH_INFO_PER_RL_SEC_CPICH_SEC_SCR_CODE_PRESENT;
      }

      /* mark the secondary CPICH information as present */
      rl_info->dpch_per_rl.opt_parms_present_mask |=
        DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT;
    }
    /* secondary cpich info is not present. It might have been present
       for the same radiolink before. Make sure that L1 gets
       correct bit masks */
    else
    {
      if (rl_info->dpch_per_rl.opt_parms_present_mask &
        DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT)
      {
        WRRC_MSG1_HIGH("Sec CPICH was present before rl_id:%d",
                 rl_idx);

        /* mark the secondary CPICH information as present */
        rl_info->dpch_per_rl.opt_parms_present_mask &=
          ~DL_DPCH_INFO_PER_RL_SEC_CPICH_INFO_PRESENT;
      }
    }

    /* Get all of the DPCH code channel list information */
    code_list_ptr = &(ie_ptr->u.fdd->dl_ChannelisationCodeList);
    code_ch = 0;
    n_value = code_list_ptr->n;
    
    while ((n_value != 0) && (code_ch < UE_MAX_DPCH))
    {
      /* Initialize the optional parameters for each code channel */
      if(is_new_rl)
      {
        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask = 0;
      }

      /* decode the Spreading factor and OVSF code */
      sf_choice = code_list_ptr->elem[n_index].sf_AndCodeNumber;
      switch (RRC_GET_MSG_TYPE(sf_choice))
      {
        case T_rrc_SF512_AndCodeNumber_sf4:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf4;
          break;

        case T_rrc_SF512_AndCodeNumber_sf8:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf8;
          break;

        case T_rrc_SF512_AndCodeNumber_sf16:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf16;
          break;

        case T_rrc_SF512_AndCodeNumber_sf32:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf32;
          break;

        case T_rrc_SF512_AndCodeNumber_sf64:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf64;
          break;

        case T_rrc_SF512_AndCodeNumber_sf128:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf128;
          break;

        case T_rrc_SF512_AndCodeNumber_sf256:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf256;
          break;

        case T_rrc_SF512_AndCodeNumber_sf512:
          rl_info->dpch_per_rl.dl_chan_code[code_ch].code_number =
            (uint16)sf_choice.u.sf512;
          break;

        default:
          ERR("Bad SF code %u for RL #%u, DPCH #%u",
                    RRC_GET_MSG_TYPE(sf_choice), rl_idx, code_ch);
          return FAILURE;
      }

      /* Get the secondary scrambling code if present */
      if (RRC_CHECK_MSG_TYPE_IE(code_list_ptr->elem[n_index],
                    secondaryScramblingCodePresent))
      {
        rl_info->dpch_per_rl.dl_chan_code[code_ch].sec_scr_code =
          (uint16) code_list_ptr->elem[n_index].secondaryScramblingCode;

        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask |=
          DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT;
      }
      /* Get the secondary scrambling code if present */
      else
      {
        if (rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask &
          DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT)
        {
          WRRC_MSG1_HIGH("Sec SCR was present before %d",
                   rl_info->dpch_per_rl.dl_chan_code[code_ch].sec_scr_code);
        }
        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask &=
          ~DL_DPCH_CODE_CH_SEC_SCR_CODE_PRESENT;
      }

      /* Get the secondary scrambling code change if present */
      if (RRC_CHECK_MSG_TYPE_IE(code_list_ptr->elem[n_index], 
                  scramblingCodeChangePresent))
      {
        switch (code_list_ptr->elem[n_index].scramblingCodeChange)
        {
          case rrc_ScramblingCodeChange_codeChange:
            rl_info->dpch_per_rl.dl_chan_code[code_ch].scr_code_change =
              TRUE;
            break;

          case rrc_ScramblingCodeChange_noCodeChange:
            rl_info->dpch_per_rl.dl_chan_code[code_ch].scr_code_change =
              FALSE;
            break;

          default:
            WRRC_MSG1_ERROR("Bad sec scr code change parameter %u",
                       code_list_ptr->elem[n_index].scramblingCodeChange);
            return FAILURE;
        }

        rl_info->dpch_per_rl.dl_chan_code[code_ch].opt_parm_present_mask |=
          DL_DPCH_CODE_CH_SCR_CODE_CHG_PRESENT;
      }

      /* point to the next code channel and increment the code channel
         index variable */
      n_value--;
      n_index++;
      code_ch++;
    }

    /* set the number of DPCH code channels used for this radio link */
    rl_info->dpch_per_rl.num_dpch = code_ch;
  }
  else
  {
    /* FDD choice not selected, TDD not supported */
    return FAILURE;
  }

  /* everything went ok */
  return SUCCESS;
}

/*====================================================================
FUNCTION        get_dl_info_for_each_rl_r7()

DESCRIPTION     This function translates the Downlink information for
                each radio link IE to the RRC config database

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
static rrcllcoc_dl_info_per_rl_status_e_type get_dl_info_for_each_rl_r7
(
  rrc_DL_InformationPerRL_r7 *ie_ptr,

  l1_dl_phychan_db_struct_type *dl_phychan,

  uint8 rl_idx,

  boolean is_new_rl
)
{
  l1_dl_info_per_rl_struct_type *rl_info;

  if (rl_idx >= UE_MAX_RL)
  {
    /* radio link index too large, bail */
    WRRC_MSG1_ERROR("Too many Radio Links %d", rl_idx);
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }

  MSG_MED("RRCHS:Get Dl Info per RL",0,0,0);
  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                T_rrc_DL_InformationPerRL_r7_modeSpecificInfo_fdd))
  {
    /* First check if the DL DPCH Info per RL is included. If not,
    * this is NOT a valid Radio link - ignore it.
    */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
                dl_dpchInfoPresent))
    {
    /* snap a local pointer to the proper radio link element in the
      RRC config page */
      rl_info = &dl_phychan->dl_per_rl[rl_idx];

      /* Get the Primary CPICH scrambling code */
      rl_info->pri_cpich_scr_code =
        (uint16) ie_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

        /*If Cell_id is present for this RL, store it in cell_id_per_rl */      
        if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                    cell_idPresent))
        {
          cell_id_per_rl[rl_idx] = (uint32) rrc_translate_cell_id(&ie_ptr->cell_id);
        } 

      /* Get the DL DPCH info for this radio link */
      MSG_MED("Get DL DPCH Info for RL %d", (rl_idx + 1), 0, 0);

      if(RRC_CHECK_MSG_TYPE(ie_ptr->dl_dpchInfo, 
                  T_rrc_DL_InformationPerRL_r7_dl_dpchInfo_dl_DPCH_InfoPerRL))
      {
        if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch == TRUE)
        {
           WRRC_MSG0_ERROR("FDPCH common params mixed with DPCH per RL"); 
          return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
        }
        if (get_dl_dpch_info_for_each_rl_r7(ie_ptr->dl_dpchInfo.u.dl_DPCH_InfoPerRL,
          dl_phychan, rl_idx,
          is_new_rl) == FAILURE)
        {
          return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
        }
      }
      else
      {
        if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch == FALSE)
        {
           WRRC_MSG0_ERROR("DPCH common params mixed with FDPCH per RL"); 
          return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
        }
        if (get_dl_fdpch_info_for_each_rl_r7(ie_ptr->dl_dpchInfo.u.dl_FDPCH_InfoPerRL,
          dl_phychan, rl_idx,
          is_new_rl
#ifdef FEATURE_WCDMA_DC_HSUPA
          , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ) == FAILURE)
        {
          return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
        }

      }

      /* if we made it here we must be ok */
      /* Indicate that Downlink L1 needs to be configured */
      ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
      /* Although no new parameters for MAC have been received, MAC
      * still needs to be reconfigured so as to get the new CCTrCH
      * ID whenever Downlink L1 is reconfigured. This is due to the
      * interface requirements.
      */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      return RRCLLCOC_DL_INFO_PER_RL_SUCCESS;
    }  /* DL DPCH Info is present */
    else
    {
      /* DL DPCH Info per RL is NOT present - ignore this IE */
      return RRCLLCOC_DL_INFO_PER_RL_IGNORED;
    }
  }
  else
  {
    /* No FDD info.  We don't support TDD so return indicating an error */
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }
} /* get_dl_info_for_each_rl_r5() */
/*===========================================================================
FUNCTION        is_current_camped_psc_in_rl_info_r7()

DESCRIPTION     This function determines whether the current camped psc is
                included in the dl-per-rl-list or not.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    Ordered config is updated with the new RL info.
===========================================================================*/
static boolean is_current_camped_psc_in_rl_info_r7(rrc_DL_InformationPerRL_List_r7 *ie_ptr)
{
  rrc_scr_code_type current_psc;

  current_psc = rrc_ccm_get_curr_camped_psc();

  if(ie_ptr->n != 0)
  {
    /*Removed the DPCH presence check to allow detection of semless reconfiguration, this covers 
     scenarios like FACH to DCH(R99), FACH to DCH(FDPCH/EUL), R99<->EUL reconfig in DCH. 
     Introduced during HSRACH to DCH seamless reconfig optimization where PCCPCH can be dropped
     Impact:
     1. new_freq is filled in L1 cmd pointer for non-seamless reconfig cases
     2. With the new change we may not send add/drop of DPCH(unlike legacy), if DPCH to FDPCH reconfig happens
        Verified with L1 for this case and they are OK to not send add/drop for such reconfig 
    */
    if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[0].modeSpecificInfo, 
                  T_rrc_DL_InformationPerRL_r7_modeSpecificInfo_fdd))
    {
      if(current_psc == (rrc_scr_code_type)ie_ptr->elem[0].modeSpecificInfo.u.fdd->
                                           primaryCPICH_Info.primaryScramblingCode)
      {
        return (TRUE);
      }
    }
  }
  return(FALSE);
}

/*===========================================================================
FUNCTION        get_dl_info_per_rl_r7()

DESCRIPTION     This function validates and stores Downlink Information Per
                Radio Link for reconfiguration messages.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    Ordered config is updated with the new RL info.
===========================================================================*/
static uecomdef_status_e_type get_dl_info_per_rl_r7
(
  rrc_DL_InformationPerRL_List_r7 *ie_ptr,
  rrc_RRC_StateIndicator next_state
)
{
  uint8 idx;
  uint8 rl_count = 0;
  uint8 cnt = 0;
  /* is_hho flag indicates if it is one of Inter Freq or Intra Freq HHO */
  boolean is_hho;

  /* is_inter_freq flag indicates if it is an Inter Freq HHO */
  boolean is_inter_freq;

  boolean old_rl_seen = FALSE;

  /* new_rl_seen indicates that new RLs are seen which is always TRUE for HHOs */
  boolean new_rl_seen = FALSE;

  boolean existing_hs_link_inactive = FALSE;

  rrc_DL_InformationPerRL_List_r7 *tmp_ie_ptr = ie_ptr;
  rrc_DL_InformationPerRL_List_r7 *temp_ptr = ie_ptr;
  boolean was_rl_db_empty = FALSE;
  rrcllcoc_dl_info_per_rl_status_e_type status =
    RRCLLCOC_DL_INFO_PER_RL_IGNORED;
  rrc_freq_type rrc_freq = rrc_ccm_get_curr_camped_freq();
  rrc_state_e_type rrc_state = rrc_get_state();
 
  uint32 n_index_ie=0;

  ordered_config_ptr->dest_psc_present = FALSE;

  /* Check if HSDPA link has been specified in more than one place */

  
  while (tmp_ie_ptr->n > n_index_ie )
  {
    if (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo, 
                  T_rrc_DL_InformationPerRL_r7_modeSpecificInfo_fdd))
    {
      if (tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->servingHSDSCH_RL_indicator == TRUE)
      {
        rl_count++;
        if (rl_count > 1)
        {
          WRRC_MSG0_ERROR("RRCHS:More than 1 HS RL specified");
          return FAILURE;
        }

        hsdpa_msg_params.msg_params_present = TRUE;
        hsdpa_msg_params.rl_link_present = TRUE;
        hsdpa_msg_params.new_rl_link = (uint16)
        tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

      }
      else
      {
        /* Check if it was HSDPA Link Earlier */
        if ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && 
          (ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc == 
           tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode))
        {
          WRRC_MSG0_HIGH("RRCHS:Exisitng HSDPA Link made inactive");
          existing_hs_link_inactive = TRUE;
        }
      }
      n_index_ie++;
    }
    else
    {
      n_index_ie++;
    }
  }
  

  if ((existing_hs_link_inactive == TRUE) && (rl_count == 0))
  {
    WRRC_MSG0_HIGH("RRCHS:HSDPA to be stopped");
    ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;
  }
  /* Reinitialize values */
  rl_count = 0;
  
  n_index_ie = 0;

  /* We can say with certainty that if frequency info is included, and
  * it is different than the current frequency, then we are doing a
  * hard handover.  If this is not the case, we revisit this flag
  * later.
  */
  is_inter_freq = is_hho = (ordered_config_ptr->dest_freq_present &&
    ordered_config_ptr->dest_freq != rrc_freq);

  if((rrccsp_channel_locking_nv_status()) && !rrccsp_is_ue_in_true_limited_service() &&
      is_inter_freq )
  {
    WRRC_MSG0_HIGH("Failing, inter-freq HHO not supported");
    return(FAILURE);
  }
  
  if(next_state == rrc_RRC_StateIndicator_cell_DCH)
  {
  /* If DPCH Info per RL is not present within DL Info per RL, then ignore it and
  * do not change the RL Info list in OC when going from DCH->DCH.
  * When going from non-DCH->DCH, the above condition should result in a Failure.
    */
    while (tmp_ie_ptr->n > n_index_ie )
    {
      if((RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo, 
                    T_rrc_DL_InformationPerRL_r7_modeSpecificInfo_fdd)) &&
         (!((RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index_ie], 
                     dl_dpchInfoPresent)) &&
            ((RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index_ie].dl_dpchInfo, 
                     T_rrc_DL_InformationPerRL_r7_dl_dpchInfo_dl_DPCH_InfoPerRL))
        ||
             (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index_ie].dl_dpchInfo, 
                    T_rrc_DL_InformationPerRL_r7_dl_dpchInfo_dl_FDPCH_InfoPerRL))
        ))))
      {
        if(rrc_state == RRC_STATE_CELL_DCH)
        {
          /* Remove this check later - need to process rest of RL Info elements */
          WRRC_MSG1_HIGH("Ignoring DL Info per RL for %d,Info absent", 
            tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode);

          n_index_ie++;
          if (n_index_ie == tmp_ie_ptr->n)
          {
            if (cnt > 0 )
            {
              WRRC_MSG0_HIGH("RRCHS:One link has DL DPCH info perRL");
              break;
            }
            WRRC_MSG0_HIGH("RRCHS:DL DPCH Info Per RL absent");
            return(SUCCESS);
          }
          else
          {
            continue;
          }
        }
        else
        {
          WRRC_MSG0_HIGH("Failing, DPCH Info per RL not present");
          return(FAILURE);
        }
      }
      cnt++;
      n_index_ie++;
    }

    /* Restore the Pointer */
    //tmp_ie_ptr = ie_ptr;
    n_index_ie = 0;

    /* Did we have any radio links in our database previously? */
    was_rl_db_empty = (ordered_config_ptr->l1_dl_chan_parms.num_rl == 0);

    if(rrc_state != RRC_STATE_CELL_DCH)
    {
      /* Going from non-DCH state to CELL DCH */
      /* Always set new_rl_seen when coming to DCH from a non-DCH state.
      * That ensures the RL Info is populated after initializing.
      */
      new_rl_seen = TRUE;

      if(!is_inter_freq)
      {
        /* Also loop thru and check if the current camped on PSC is in RL Info.
         * If so, force Frequency_info to FALSE.
         */
        if(is_current_camped_psc_in_rl_info_r7(ie_ptr))
        {
          ordered_config_ptr->dest_freq_present = FALSE;
        }
        else  /* Intra freq HHO */
        {
          ordered_config_ptr->dest_freq_present = TRUE;
          ordered_config_ptr->dest_freq = rrc_freq;
          WRRC_MSG0_HIGH("Disjoint ASET, intra-f HHO FACH->DCH");
        }
      }
    }
    else       /* Going from DCH->DCH */
    {
    /* Unless we are doing an inter-frequency hard handover, we cannot
    * take a set of radio links that contains scrambling codes we
    * already have in our database as well as ones that we don't have
    * in our database. (25.331 8.6.6.3a)
      */
      if(!is_inter_freq)
      {
        while(ie_ptr->n > n_index_ie )
        {
          if(get_dl_rl_idx_to_update(ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode,
                 (RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index_ie].modeSpecificInfo, 
                            T_rrc_DL_InformationPerRL_r7_modeSpecificInfo_fdd)),
            &ordered_config_ptr->l1_dl_chan_parms) <
            ordered_config_ptr->l1_dl_chan_parms.num_rl)
          {
            old_rl_seen = TRUE;
          }
          else
          {
            new_rl_seen = TRUE;
          }

          /* We can bail out early if we detect a mixed active set. */
          if(old_rl_seen && new_rl_seen)
          {
            WRRC_MSG0_ERROR("Mixed ASET detected, rejecting");
            return FAILURE;
          }

          n_index_ie++;
        }
      }
      else
      {
        /* New RLs always seen for Inter freq HHO */
        new_rl_seen = TRUE;
      }
    } /* DCH->DCH */
    n_index_ie = 0;
    while(ie_ptr->n > n_index_ie )
    {
      if(rrc_state != RRC_STATE_CELL_DCH)
      {
        /* For a non-DCH to DCH transition, there is no existing RL Info */
        idx = rl_count;
      }
      else if(is_inter_freq)
      {
      /* We've found this radio link in our database, but we are
      * doing an inter-frequency hard handover, which means that
      * we are replacing the active set.  This is a case where
      * the primary scrambling code on the new frequency is the
      * same as on the old one.  We need to adjust our radio link
      * index accordingly, since we don't want to place the new
      * radio link into the database position of the old one.
        */
        idx = rl_count;
      }
      else /* DCH -> DCH AND Not Inter Freq */
      {
      /* Now look to see if this radio link is already in our
      * database.
        */
        idx =  get_dl_rl_idx_to_update( ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode,
                 (RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index_ie].modeSpecificInfo,
                              T_rrc_DL_InformationPerRL_r7_modeSpecificInfo_fdd)),
                 &ordered_config_ptr->l1_dl_chan_parms );
        

        if(idx == UE_MAX_RL)
        {
        /* This radio link is not in our database, which means we're
        * replacing our database with an entirely new set of radio
        * links.  We must reset the value of the database index to
        * the current radio link count.
          */
          idx = rl_count;

          is_hho = TRUE;

          hsdpa_msg_params.intra_hho_involved = 
            hsdpa_msg_params.msg_params_present = TRUE;

        } /* idx == UE_MAX_RL */
      } /* DCH -> DCH AND Not Inter Freq */

      /* Process the IE and place the info into our database. */
      status = get_dl_info_for_each_rl_r7(&ie_ptr->elem[n_index_ie],
        &ordered_config_ptr->l1_dl_chan_parms,
        idx,
        new_rl_seen);

      if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
      {
        return FAILURE;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_IGNORED)
      {
        n_index_ie++;
        continue;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS)
      {
        if(is_hho)
        {
        /* If we succeeded in processing the IE, and we are doing a
        * hard handover, we must be sure that L1 is informed by
        * sending frequency info, even if we didn't get frequency
        * info in the reconfiguration message.
          */
          if(!ordered_config_ptr->dest_freq_present)
          {
            ordered_config_ptr->dest_freq_present = TRUE;
            ordered_config_ptr->dest_freq = rrc_freq;
            WRRC_MSG0_HIGH("Disjoint ASET, intra-f HHO triggered");
          }
        }
      }

      rl_count++;
      n_index_ie++;
    }

    /* Here we check to see if "Default DPCH Offset Value" and "DPCH frame offset" respect the following
         * relation : "Default DPCH Offset Value" % 38400 = "DPCH frame offset" as per 8.6.6.14 in 25.331
         * We have to do this validation only when we enter DCH the first time or if it is a Timing Initialized HHO 
         * Checking only 0th location...no loop here. 
        */
    n_index_ie = 0;
    if ( (rrc_state != RRC_STATE_CELL_DCH) ||
         (is_hho && ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind == L1_TIMING_IND_INIT) )
    {
      if((RRC_CHECK_MSG_TYPE(temp_ptr->elem[n_index_ie].modeSpecificInfo, 
                    T_rrc_DL_InformationPerRL_r7_modeSpecificInfo_fdd)) &&
         (RRC_CHECK_MSG_TYPE_IE(temp_ptr->elem[n_index_ie], 
                    dl_dpchInfoPresent)) &&
         (RRC_CHECK_MSG_TYPE(temp_ptr->elem[n_index_ie].dl_dpchInfo, 
                    T_rrc_DL_InformationPerRL_r7_dl_dpchInfo_dl_DPCH_InfoPerRL)) &&
         (RRC_CHECK_COMMON_MSG_TYPE_PTR(temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_DPCH_InfoPerRL, 
                   rrc_DL_DPCH_InfoPerRL_r7_fdd)))
      {
        if ( (ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset % 38400) !=
             (temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_DPCH_InfoPerRL->u.fdd->dpch_FrameOffset * RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR) )
        {
          WRRC_MSG2_ERROR("Validation of DOFF %d and DPCH frame offset %d fail",
                    ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
                    (temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_DPCH_InfoPerRL->u.fdd->dpch_FrameOffset *
                     RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR));
          return (FAILURE);
        }
      }

  
      /* Verify if DEFAULT F-DPCH Offset Value & F-DPCH Frame Offset is respected as per 8.6.6.14 */
    if ((ordered_config_ptr->l1_dl_chan_parms.use_fdpch == TRUE) && 
            (RRC_CHECK_MSG_TYPE(temp_ptr->elem[n_index_ie].modeSpecificInfo, 
                       T_rrc_DL_InformationPerRL_r7_modeSpecificInfo_fdd)) &&
            (RRC_CHECK_MSG_TYPE_IE(temp_ptr->elem[n_index_ie], 
                       dl_dpchInfoPresent)) &&
            (RRC_CHECK_MSG_TYPE(temp_ptr->elem[n_index_ie].dl_dpchInfo, 
                      T_rrc_DL_InformationPerRL_r7_dl_dpchInfo_dl_FDPCH_InfoPerRL)))
    {
                
      if ((ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset % 38400) ==
              (temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset * RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR))
                  
      {
        WRRC_MSG2_HIGH("Default DPCHOffset %d, FDPCHFrameOffset %d", 
          ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
        temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset);
        
      }
      else if (((ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset + 256) % 38400) ==
              (temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset * RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR))
      {
                  
        // Add 256 to default DPCH Offset value 
                  
        ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset += 256;
                  
        WRRC_MSG2_HIGH("New Default DPCHOffset %d, FDPCHFrameOffset %d", 
          ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
        temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset);
        
      }
      else
      {
        WRRC_MSG2_ERROR("Validation of DOFF %d and DPCH frame offset %d fail",
                      ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
                  (temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset *
                      RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR));
        return (FAILURE);
      }
    }
    }

    if(is_hho || was_rl_db_empty)
    {
    /* We've just replaced the contents of our radio link database, or
    * added radio links when we had none before, so we must update the
    * count of the radio links contained therein.
      */
      ordered_config_ptr->l1_dl_chan_parms.num_rl = rl_count;

      /* Clear out old scrambling codes. */
      while(rl_count < UE_MAX_RL)
      {
        ordered_config_ptr->
          l1_dl_chan_parms.dl_per_rl[rl_count++].pri_cpich_scr_code =
          RRCLLC_INVALID_CPICH_SCR_CODE;
      }
    }
  }
  else /* All states other than Cell_DCH */
  {
    if(ie_ptr != NULL)
    {
      if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index_ie].modeSpecificInfo,
                   T_rrc_DL_InformationPerRL_r7_modeSpecificInfo_fdd))
      {
      /* There should be not more than 1 PSCs in the list when going
      * to FACH since the C-RNTI can not be tied up with multiple
      * PSCs. Just remember the 1st PSC.
        */
        ordered_config_ptr->dest_psc =
          (rrc_scr_code_type)ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->
          primaryCPICH_Info.primaryScramblingCode;
        ordered_config_ptr->dest_psc_present = TRUE;

      }
    }
  }

  return rrcllcpcie_check_for_duplicate_rl_entry();

} /* end get_dl_info_per_rl_r6() */


/*============================================================================
FUNCTION: rrcllcpcie_process_dl_info_per_rl_list_r7)

DESCRIPTION:
  This function updates IE "dl per rl info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_dl_info_per_rl_list_r7
(
  OSS_UINT32 dl_info_per_rl_list_present,
  rrc_DL_InformationPerRL_List_r7 *dl_info_per_rl_list_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  if (dl_info_per_rl_list_present)
  {
    if(FAILURE == get_dl_info_per_rl_r7(dl_info_per_rl_list_ptr, rcvd_state_indicator))
    {
      return (FAILURE);
    }
  }

  /* process EUL related information */
  if (FAILURE == rrcllcpcie_process_e_info_in_dl_info_per_rl_list_r7(
      dl_info_per_rl_list_present, 
      dl_info_per_rl_list_ptr,
      rcvd_state_indicator))
  {
    return(FAILURE);
  }

  return(SUCCESS);
}
/*====================================================================
FUNCTION        get_dl_info_common_for_all_rl_r7()

DESCRIPTION     This function translates the Downlink information common
                for all radio links IE into the RRC config database.

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
static uecomdef_status_e_type get_dl_info_common_for_all_rl_r7
(
  /* Pointer to the DL CommonInformation IE */
  rrc_DL_CommonInformation_r7 *ie_ptr,

  /* Pointer to the desirec DL PhyChan common information structure */
  l1_dl_common_info_struct_type *dl_common,

  /* Pointer to the DL CCTRCH parameters structure */
  l1_dl_cctrch_info_struct_type *l1_dl_cctrch_parms,

  /* Pointer to the DL CTFC parameters structure */
  l1_dl_ctfc_info_struct_type *l1_dl_ctfc_info
)
{

  MSG_MED("Get DL Info Common for all RL",0,0,0);

  /* initialize the optional field bit mask */
  /* Don't reset DOFF bitmask in DCH state.*/
  dl_common->opt_parm_presence_bitmask = 
      dl_common->opt_parm_presence_bitmask & DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;

  /* Check if HS Reset is indicated */
  /* TBD Why only one value in HSRESET is specified */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
              mac_hsResetIndicatorPresent))
  {
    /* Set it in MAC params */
    ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = TRUE;
    hsdpa_msg_params.msg_params_present = TRUE;
  }
  dl_common->post_verification_valid = FALSE;
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
              postVerificationPeriodPresent))
  {
    /* Set it in MAC params */
    dl_common->post_verification_valid = TRUE;
  }

  /* Get the info common for all DL DPCH if present */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
              dl_dpchInfoCommonPresent))
  {
    if (RRC_CHECK_MSG_TYPE(ie_ptr->dl_dpchInfoCommon, 
               T_rrc_DL_CommonInformation_r7_dl_dpchInfoCommon_dl_DPCH_InfoCommon))
    {
      if(get_dl_dpch_common_info_r6(ie_ptr->dl_dpchInfoCommon.u.dl_DPCH_InfoCommon,
                                 &dl_common->dpch_common,
                                 l1_dl_cctrch_parms,
                                 l1_dl_ctfc_info
                                ) == FAILURE
        )
      {
        return FAILURE;
      }
      ordered_config_ptr->l1_dl_chan_parms.use_fdpch = FALSE;
    }
    else /* rrc_dl_FDPCH_InfoCommon_chosen */
    {
      if(get_dl_fdpch_common_info_r6(ie_ptr->dl_dpchInfoCommon.u.dl_FDPCH_InfoCommon,
        &dl_common->dpch_common
        ) == FAILURE)
      {
        return FAILURE;
      }
      else
      {
        ordered_config_ptr->l1_dl_chan_parms.use_fdpch = TRUE;
      }
    }
  } /* end if dl dpch common info present */

  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
               T_rrc_DL_CommonInformation_r7_modeSpecificInfo_fdd))
  {
     if(rrcllcpcie_dl_common_mode_specific_info((rrc_dlcommon_modespecific_info *)ie_ptr->modeSpecificInfo.u.fdd, dl_common)
        == FAILURE)
     {
       return FAILURE;
     }
  }
  /* end if common FDD */
  else
  {
    /* FDD not selected.  Error as TDD not supported */
    return FAILURE;
  }
  /* Indicate that Downlink L1 needs to be reconfigured */
  ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
 /* Although no new parameters for MAC have been received, MAC
  * still needs to be reconfigured so as to get the new CCTrCH
  * ID whenever Downlink L1 is reconfigured. This is due to the
  * interface requirements.
  */
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
  return SUCCESS;
}

/*============================================================================
FUNCTION: rrcllcpcie_process_dl_common_info_r7()

DESCRIPTION:
  This function updates IE "dl common info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_dl_common_info_r7
(
  OSS_UINT32 dl_common_info_present,
  rrc_DL_CommonInformation_r7 *dl_common_info_ptr,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  /* Get the DL information for all Radio Links */
  if (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
  {
  /* Initialize the L1 bitmask for the parameters in the "Downlink
  * information for all radio links" IE.  Since the IE is optional,
  * we want to make sure we don't signal L1 erroneously that we have
  * received information when we haven't.
    */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);
    
    if (dl_common_info_present)
    {
      if(get_dl_info_common_for_all_rl_r7(dl_common_info_ptr,
        &ordered_config_ptr->l1_dl_chan_parms.dl_common,
        &ordered_config_ptr->l1_dl_cctrch_parms,
        &ordered_config_ptr->l1_dl_ctfc_parms
        )
        == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
    
  } /* If next state is Cell_DCH */
  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
    &ordered_config_ptr->dl_ctfc,
    &ordered_config_ptr->rm_restrict,
    &ordered_config_ptr->l1_dl_ctfc_parms
    );
   
  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_is_hho_r7()

DESCRIPTION:
  This function returns boolean value based on whether inter-freq or intra-freq
  HHO is ongoing. 

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE - HHO in progress
  FALSE - No HHO

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_is_hho_r7
(
  OSS_UINT32 dl_info_per_rl_list_present,
  rrc_DL_InformationPerRL_List_r7 *dl_info_per_rl_list_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  boolean is_hho = FALSE, old_rl_seen = FALSE, new_rl_seen = FALSE;
  rrc_freq_type rrc_freq = rrc_ccm_get_curr_camped_freq();
  rrc_DL_InformationPerRL_List_r7 *tmp_ie_ptr = dl_info_per_rl_list_ptr;
  rrc_state_e_type curr_rrc_state = rrc_get_state();
  uint32 n_value=0, n_index=0;

  if ((rcvd_state_indicator == rrc_RRC_StateIndicator_cell_DCH) && 
      (dl_info_per_rl_list_present))
  {
    /* Consider the following conditions as HHO:  
                   - Inter freq 
                   - Itra freq with disjoint ASET
                   - First time into CELL_DCH
    */
    is_hho = ((ordered_config_ptr->dest_freq_present &&
               ordered_config_ptr->dest_freq != rrc_freq) || 
              (curr_rrc_state != RRC_STATE_CELL_DCH));
    
    if (FALSE == is_hho)
    {
      n_value = tmp_ie_ptr->n;
      while(n_value != 0)
      {
        if(get_dl_rl_idx_to_update( tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode,
                 (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo,
                          T_rrc_DL_InformationPerRL_r7_modeSpecificInfo_fdd)),
                 &ordered_config_ptr->l1_dl_chan_parms )<
                 ordered_config_ptr->l1_dl_chan_parms.num_rl)
        {
          old_rl_seen = TRUE;
        }
        else
        {
          new_rl_seen = TRUE;
        }
  
        /* We can bail out early if we detect a mixed active set. */
        if(old_rl_seen && new_rl_seen)
        {
          WRRC_MSG0_ERROR("Mixed ASET detected, rejecting");
          return FAILURE;
        }
        n_value--;
        n_index++;
      }
      /* if new RL seen is true then it means its a dis-joint set and hence its
         value will indicate whether its HHO or not. */
      is_hho = new_rl_seen;
      
    }
  
    if (TRUE == is_hho)
    {
      MSG_HIGH("HHO detected DCH trans %d intra-freq %d inter-freq %d ",
               (curr_rrc_state != RRC_STATE_CELL_DCH), 
               new_rl_seen,
               (ordered_config_ptr->dest_freq_present &&
                ordered_config_ptr->dest_freq != rrc_freq));
    }
  }

  ordered_config_ptr->is_hho = is_hho;
  return SUCCESS;
}

/*====================================================================
FUNCTION      get_ul_dpch_info_r7()

DESCRIPTION   This function translates the Uplink DPCH info IE into the RRC config database.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire translation operation is successful,
              FAILURE otherwise

SIDE EFFECTS  The RRC config database page pointed to by the input
              parameter ord_cfg is overwritten with all IE elements
              that are present.  Those IE elements that are not present
              do NOT overwrite the database values with, say, default
              values.  Any optional parameters that are present also
              cause parameter presence bits in the database to be set.
====================================================================*/
static uecomdef_status_e_type get_ul_dpch_info_r7
(
  rrc_UL_DPCH_Info_r7 *ie_ptr
)
{
  MSG_MED("Get UL DPCH Info",0,0,0);

  /* Get the UL DPCH power control information if present */
  if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
              ul_DPCH_PowerControlInfoPresent))
  {
    if(RRC_CHECK_MSG_TYPE(ie_ptr->ul_DPCH_PowerControlInfo, 
               T_rrc_UL_DPCH_PowerControlInfo_r7_fdd))
    {
      if(get_ul_dpch_pwr_ctrl_info_r6((rrc_UL_DPCH_PowerControlInfo_r6_fdd *)
      ie_ptr->ul_DPCH_PowerControlInfo.u.fdd
      ) == FAILURE)
      {
        return FAILURE;
      }
    }
    else /* only TDD */
    {
      return FAILURE;
    }
  }

  /* Make sure of FDD and get the right parameters */
  if(RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo, 
              T_rrc_UL_DPCH_Info_r7_modeSpecificInfo_fdd))
  {
    if(rrcllcpcie_update_uldpch_mode_specific_info_r7(ie_ptr->modeSpecificInfo.u.fdd) == FAILURE)
    {
      return FAILURE;
    }
  }
   /* end FDD if */
  else
  {
    return FAILURE;
  }

  /* If made it here, all is well */
  /* Indicate that Uplink L1 needs to be reconfigured */
  ordered_config_ptr->reconfig_needed.uplink_l1 = TRUE;
  return SUCCESS;
}
/*============================================================================
FUNCTION: rrcllcpcie_process_ul_dpch_info_r7()

DESCRIPTION:
  This function updates IE "ul dpch info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_ul_dpch_info_r7
(
  OSS_UINT32 ul_dpch_info_present,
  rrc_UL_DPCH_Info_r7 *ul_dpch_info_ptr,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if (ul_dpch_info_present)
  {
    if (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
    {
      if(get_ul_dpch_info_r7(ul_dpch_info_ptr) == FAILURE)
      {
        return FAILURE;
      }
    }
    else
    {
      WRRC_MSG0_HIGH("RRCEUL: Ignoring rcvd ulDpchInfo when state-indicator is NOT set to DCH");
    }
  }
  return(SUCCESS);
}

#ifdef FEATURE_WCDMA_16_QAM
/*============================================================================
FUNCTION: rrcllcpcie_process_16qam_params()

DESCRIPTION:
  This function process the 16QAM settings" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_validate_16qam_params(void)
{
  /*10.3.6.86o UL 16QAM configuration: Checking the 2ms is conditional value for 16 QAM */
  /* 8.6.6.37: NOTE 5: If the IE "MAC-es/e reset indicator" is not included in the IE "E-DCH Info" and 16QAM operation starts
              or stops, the UE behaviour is unspecified.*/
  if((CHECK_WCDMA_OPTIONAL_FEATURE_16_QAM_SUPPORTED)&&(E_TTI_2MS == ordered_config_ptr->l1_e_info.e_ul_info.e_tti))
    return SUCCESS;
  else
  {
    WRRC_MSG0_ERROR("16 QAM feature is not supported and the TTI is not set to 2ms");
    return FAILURE;
}
}

/*============================================================================
FUNCTION: rrcllcpcie_process_16qam_params()

DESCRIPTION:
  This function process the 16QAM settings" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_16qam_params(OSS_UINT32 ul_16qam_present, rrc_UL_16QAM_Settings *ul_16qam_settings_ptr)
{
  if (ul_16qam_present)
  {
     if (SUCCESS == rrcllcpcie_validate_16qam_params())
     {
       /* 8.6.6.37: NOTE 5: If the IE "MAC-es/e reset indicator" is not included in the IE "E-DCH Info" and 16QAM operation starts
              or stops, the UE behaviour is unspecified.*/
       /*(1)	If it is for a transition from non-16QAM to 16QAM operation, reset the MAC-es/e entity.
         (2)	If it is for a transition from 16QAM to non-16QAM operation, reset the MAC-es/e entity.
         (3)	Else, not to reset the MAC-es/e entity. */

       if (FALSE == ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action)
       {
         ordered_config_ptr->mac_e_reset_indicator = TRUE;
       }
       /*8.6.6.42: indicate to lower layers to operate in 16QAM mode*/
       ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action = TRUE;
       ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_e_agch_table_idx = ul_16qam_settings_ptr->beta_Ed_Gain_E_AGCH_Table_Selection;

       rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);
       rrcllc_update_mac_eul_action(TRUE);
     }
     else
     {
        WRRC_MSG0_ERROR("HSPA+:UL 16QAM validation failed");
        return FAILURE;
     }
    
  }
  else
  {
     if (TRUE == ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action)
     {
        ordered_config_ptr->mac_e_reset_indicator = TRUE;
     }
     /*8.6.6.37: indicate to lower layers to stop any operation in 16QAM mode*/
     ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action = FALSE;
     ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_e_agch_table_idx = 0;

     rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);
     rrcllc_update_mac_eul_action(TRUE);
  }
  return SUCCESS;
}

/*============================================================================
FUNCTION: rrcllcpcie_modify_e_tfci_table()

DESCRIPTION:
  This function updates IE "e_tfci table idx for L1" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_modify_e_tfci_table(void)
{
    if ((TRUE == ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action) 
        &&(ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_tfci_table_idx < 2))
    {
       /*If the UE is operating in 16QAM mode, the value of “E-TFCI table index” is increased by 2, and
          indices in the SG-Table refer to Scheduling Grant Table 2[15]*/
       ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_tfci_table_idx += 2;
       ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_table_index += 2;
    }
    else if ((FALSE == ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action) &&
      (ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_tfci_table_idx >= 2))
    {
     ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_tfci_table_idx -= 2; 
     ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_table_index -= 2;
    }
}
#endif /* FEATURE_WCDMA_16_QAM */

/*============================================================================
FUNCTION: rrcllcpcie_process_ul_e_dch_information_r7()

DESCRIPTION:
  This function updates IE "ul e dch information" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_ul_e_dch_information_r7
(
  OSS_UINT32 e_dch_info_present,
  rrc_UL_EDCH_Information_r7 *e_dch_info_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  uecomdef_status_e_type status = SUCCESS;

  /* Look into this IE only if next UE state is DCH */
  if (e_dch_info_present && 
      (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
     )
  {
    if ((RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr, 
                   mac_es_e_resetIndicatorPresent)) &&
        (rrc_UL_EDCH_Information_r7_mac_es_e_resetIndicator_true == e_dch_info_ptr->mac_es_e_resetIndicator))
    {
      ordered_config_ptr->mac_e_reset_indicator = TRUE;
    }
    else
    {
      ordered_config_ptr->mac_e_reset_indicator = FALSE;
    }

    if(RRC_CHECK_MSG_TYPE(e_dch_info_ptr->modeSpecificInfo, 
                  T_rrc_UL_EDCH_Information_r7_modeSpecificInfo_fdd))
      {
       if(FAILURE == rrcllcpcie_process_e_dpcch_info_r7(
        RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd, 
                  e_DPCCH_InfoPresent),
        &e_dch_info_ptr->modeSpecificInfo.u.fdd->e_DPCCH_Info))
       {
         return(FAILURE);
       }
  
      if (FAILURE == rrcllcpcie_process_e_dpdch_info_r7(
          RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd, 
                 e_DPDCH_InfoPresent),
          &e_dch_info_ptr->modeSpecificInfo.u.fdd->e_DPDCH_Info))
      {
        return(FAILURE);
      }
  
      rrcllcpcie_process_sched_tx_config(
        RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd, 
                  schedulingTransmConfigurationPresent),
        &e_dch_info_ptr->modeSpecificInfo.u.fdd->schedulingTransmConfiguration,
        &ordered_config_ptr->l1_e_info.e_dl_info,
        &ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info
        );   
#ifdef FEATURE_WCDMA_16_QAM
       status = rrcllcpcie_process_16qam_params(RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd,ul_16QAM_SettingsPresent), 
                                       &e_dch_info_ptr->modeSpecificInfo.u.fdd->ul_16QAM_Settings);
       rrcllcpcie_modify_e_tfci_table();
#else
      if(RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd, 
                   ul_16QAM_SettingsPresent))
      {
        WRRC_MSG0_ERROR("RRCHSPA+: UL 16 QAM not supported ");
      }
#endif  
    }
  }
  return(status);
}

#ifdef FEATURE_WCDMA_MIMO

/*============================================================================
FUNCTION: rrcllc_update_n_m_ratio()

DESCRIPTION:


DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllc_update_n_m_ratio
(
  rrc_MIMO_N_M_Ratio ota_n_m_ratio
)
{
  switch(ota_n_m_ratio)
  {
    case rrc_MIMO_N_M_Ratio_mnm1_2:
        ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio = MIMO_N_TO_M_RATIO_1_2;
        break;
    case rrc_MIMO_N_M_Ratio_mnm2_3:
        ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio = MIMO_N_TO_M_RATIO_2_3;
        break;
    case rrc_MIMO_N_M_Ratio_mnm3_4:
         ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio = MIMO_N_TO_M_RATIO_3_4;
        break;
    case rrc_MIMO_N_M_Ratio_mnm4_5:
        ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio = MIMO_N_TO_M_RATIO_4_5;
        break;
    case rrc_MIMO_N_M_Ratio_mnm5_6:
        ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio = MIMO_N_TO_M_RATIO_5_6;
        break;
    case rrc_MIMO_N_M_Ratio_mnm6_7:
        ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio = MIMO_N_TO_M_RATIO_6_7;
        break;
    case rrc_MIMO_N_M_Ratio_mnm7_8:
        ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio = MIMO_N_TO_M_RATIO_7_8;
        break;
    case rrc_MIMO_N_M_Ratio_mnm8_9:
        ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio = MIMO_N_TO_M_RATIO_8_9;
        break;
    case rrc_MIMO_N_M_Ratio_mnm9_10:
        ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio = MIMO_N_TO_M_RATIO_9_10;
        break;
    case rrc_MIMO_N_M_Ratio_mnm1_1:
        ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio = MIMO_N_TO_M_RATIO_1_1;
        break;

    default:
      WRRC_MSG1_ERROR("MIMO: Invalid mimo_n_m_ratio in OTA %",ota_n_m_ratio);
      ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio = MIMO_N_TO_M_RATIO_INVALID;
      return FAILURE;

  }
   WRRC_MSG1_HIGH("MIMO: MIMO N/M ratio %d ",ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio);
 return SUCCESS;
}

#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
/*============================================================================
FUNCTION: rrcllcpcie_update_mimo_scpich_po()

DESCRIPTION:
  This function updates IE "s-cpich-PowerOffset-Mimo" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_update_mimo_scpich_po
(
  rrc_MIMO_Parameters_v7f0ext * mimo_params_ptr
)
{
  if(RRC_CHECK_MSG_TYPE_IE_PTR(mimo_params_ptr, s_cpich_PowerOffset_MimoPresent))
  {
    ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = mimo_params_ptr->s_cpich_PowerOffset_Mimo;
    WRRC_MSG1_HIGH("MIMO:S-CPICH PO from OTA = %d",mimo_params_ptr->s_cpich_PowerOffset_Mimo);
  }
}
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
/*============================================================================
FUNCTION: rrcllcpcie_update_mimo_codebook_restriction()

DESCRIPTION:
  This function updates IE "precodingWeightSetRestriction" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_update_mimo_codebook_restriction
(
  boolean val
)
{
  ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_codebook_restriction_present = val;
  WRRC_MSG1_HIGH("MIMO:Codebook Restriction = %d",val);  
}
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/


/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params()

DESCRIPTION:
  This function updates IE "Mimo Params" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type    rrcllcpcie_process_mimo_params
(
  rrc_MIMO_Parameters_r7 * mimo_params,
  rrc_RRC_StateIndicator rrc_state,
  OSS_UINT32 mimo_params_present_ota
)
{
  hsdpa_action_enum_type hs_action =rrc_get_hsdpa_action() ;
  boolean mimo_reconfig = FALSE;
  if((CHECK_WCDMA_OPTIONAL_FEATURE_MIMO_SUPPORTED ) && 
      ((hs_action == HSDPA_START) ||
        ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && (hs_action != HSDPA_STOP)) )
    )
  {
    ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
    if( mimo_params_present_ota )
    {
       
      if(RRC_CHECK_MSG_TYPE_IE_PTR(mimo_params, 
                 mimoN_M_RatioPresent))
      {
        if(rrcllc_update_n_m_ratio(mimo_params->mimoN_M_Ratio) == FAILURE)
        {
          return FAILURE;
        }
        mimo_reconfig = TRUE;
      }
    
      if(RRC_CHECK_MSG_TYPE_IE_PTR(mimo_params, 
                mimoPilotConfigurationPresent))
      {
        mimo_reconfig = TRUE;
        if(RRC_CHECK_MSG_TYPE(mimo_params->mimoPilotConfiguration.secondCPICH_Pattern, 
                   T_rrc_MIMO_PilotConfiguration_secondCPICH_Pattern_normalPattern))
        {
           ordered_config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern = MIMO_NORMAL_PATTERN;
        }
        else if(RRC_CHECK_MSG_TYPE(mimo_params->mimoPilotConfiguration.secondCPICH_Pattern, 
                  T_rrc_MIMO_PilotConfiguration_secondCPICH_Pattern_diversityPattern))
        {
          ordered_config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern = MIMO_DIVERSITY_PATTERN;
   
          ordered_config_ptr->l1_hsdpa_info.mimo_info.channelisation_code = 
                  mimo_params->mimoPilotConfiguration.secondCPICH_Pattern.u.diversityPattern->channelisationCode;
        }
      }
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
      ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;  
#endif
    }
    else
    {
      WRRC_MSG0_HIGH("MIMO:MIMO params not present in OTA");
    }  
  }
  else
  {
    MSG_HIGH("MIMO:MIMO cannot be started HS Action %d HS Status %d nv category %d",
            hs_action,rrc_get_hsdpa_status(),nv_hsdpa_category);
    mimo_params_present_ota = 0;
  }
   
  if((!mimo_params_present_ota) ||
    (rrcllc_check_if_mimo_can_be_started(rrc_state) == FALSE )
     )
  {
    if(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE )
    {
        
      WRRC_MSG0_HIGH("MIMO:Set MIMO Action to STOP");
      ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_STOP;
      if(hs_action != HSDPA_STOP)
      {
        WRRC_MSG0_HIGH("Include HS bitmask as MIMO is going be stopped, but HS continues");

        ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL |CPHY_HS_DSCH_CFG_INCL|CPHY_HS_DPCCH_CFG_INCL;

          /* Set beta table and hs-dpcch bit mask */
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
        if(hs_action == HSDPA_NOOP)
        {
          rrc_set_hsdpa_action(HSDPA_RECONFIG);
          rrc_set_hsdpa_action_in_machs_macehs();
        }
           
      }
      else
      {
        ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL;
      }
    }
    else
    {
      WRRC_MSG0_HIGH("MIMO:Set MIMO Action to NOOP");
      rrcllc_init_mimo_params(ordered_config_ptr);
      ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
    }
  }
  else
  {
    uint8 num_harq_proc =  ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.num_proc;
    /*If the IE “Number of processes" is not set to one of the values 12, 14 or 16 and the IE “MIMO
        operation” (10.3.6.41a) is included and set to either “start” or “continue”, the UE behaviour is
        unspecified.
      */
    if((num_harq_proc == 12) || (num_harq_proc == 14) || (num_harq_proc == 16))
    {
       WRRC_MSG1_HIGH("MIMO: No. Of harq process is %d as according to MIMO ",num_harq_proc);
    }
    else
    {
      WRRC_MSG1_ERROR("MIMO: No. Of harq process is %d is not suitable for MIMO ",num_harq_proc);
      return FAILURE;
    }
    
    if(mimo_params->mimoOperation == rrc_MIMO_Operation_start )
    {
      ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_START;      
      
      ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL|CPHY_HS_DSCH_CFG_INCL|CPHY_HS_DPCCH_CFG_INCL;

      /* Set beta table and hs-dpcch bit mask */
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
      
      if(hs_action != HSDPA_START)
      {
        rrc_set_hsdpa_action(HSDPA_RECONFIG);
        rrc_set_hsdpa_action_in_machs_macehs();
      }
    }
    else if(mimo_params->mimoOperation == rrc_MIMO_Operation_continue_ )
    {
      ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
      if(mimo_reconfig ==TRUE)
      {
        if(rrcllc_get_mimo_status() == RRC_MIMO_INACTIVE)
        {
          WRRC_MSG0_ERROR(" MIMO not active so MIMO Operation should be rrc_start, but received as rrc_continue  ");
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_START;
        }
        else
        {
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;
        }
        
        MSG_HIGH("MIMO: MIMO action reconfig ,second_cpich_pattern  %d chan code %d M/N ratio %d",
             ordered_config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern,
             ordered_config_ptr->l1_hsdpa_info.mimo_info.channelisation_code,
             ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio);
        
        ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL |CPHY_HS_DSCH_CFG_INCL|CPHY_HS_DPCCH_CFG_INCL;

        /* Set beta table and hs-dpcch bit mask */
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
          
         if(hs_action != HSDPA_START)
         {
           rrc_set_hsdpa_action(HSDPA_RECONFIG);
           rrc_set_hsdpa_action_in_machs_macehs();
         }
      }
      else
      {
        if((ordered_config_ptr->l1_hsdpa_info.hs_req_mask & CPHY_HS_DSCH_CFG_INCL)
            &&(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE))
        {
          /*This is as per L1's requirement that when MIMO is active, even if No MIMO params change
           * if HS-DSCH changes then indicate MIMO as RECONFIG*/
          
          ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL;
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;
          WRRC_MSG1_HIGH("MIMO: No new MIMO params but HSDSCH touched so MIMO action reconfig HS bitmask 0x%x",
                            ordered_config_ptr->l1_hsdpa_info.hs_req_mask);
        }
        else if((ordered_config_ptr->l1_hsdpa_info.hs_req_mask & CPHY_HS_PDSCH_RL_CFG_INCL) && 
          (rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE))
        {
          ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL |CPHY_HS_DSCH_CFG_INCL;
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;        
          WRRC_MSG0_HIGH("MIMO:HS Re-pointing so RECFGing MIMO");
        }
        else
        {
          WRRC_MSG0_HIGH("MIMO: No new MIMO params received so action NOOP");
        }
      }
    }
    else
    {
      WRRC_MSG1_ERROR("MIMO: Invalid MIMO Operation %d",mimo_params->mimoOperation);
      return FAILURE;
    }
  }
   
  return SUCCESS;
}

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_asu_r7()

DESCRIPTION:
  This function updates the addional MIMO params for R7 ASU.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_asu_r7
(
  rrc_ActiveSetUpdate_r7 * active_set_update_r7_ota
)
{
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  if((active_set_update_r7_ota != NULL) 
  	 && (active_set_update_r7_ota->m.v780NonCriticalExtensionsPresent)
  	 && (active_set_update_r7_ota->v780NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent)
  	 && (active_set_update_r7_ota->v780NonCriticalExtensions.v7f0NonCriticalExtensions.activeSetUdpate_v7f0ext.m.mimoParametersPresent))
  {
    rrcllcpcie_update_mimo_scpich_po(&active_set_update_r7_ota->v780NonCriticalExtensions.v7f0NonCriticalExtensions.
      activeSetUdpate_v7f0ext.mimoParameters);
  }
  else
  {
    ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
    WRRC_MSG1_HIGH("MIMO:Setting S-CPICH PO = %d",rrc_mimo_s_cpich_po);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  if((active_set_update_r7_ota != NULL) &&
    (active_set_update_r7_ota->m.v780NonCriticalExtensionsPresent) &&
    (active_set_update_r7_ota->v780NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent) && 
    (active_set_update_r7_ota->v780NonCriticalExtensions.v7f0NonCriticalExtensions.m.
    v7g0NonCriticalExtensionsPresent) &&
    (active_set_update_r7_ota->v780NonCriticalExtensions.v7f0NonCriticalExtensions.
    v7g0NonCriticalExtensions.activeSetUdpate_v7g0ext.m.mimoParametersPresent) &&
    (active_set_update_r7_ota->v780NonCriticalExtensions.v7f0NonCriticalExtensions.v7g0NonCriticalExtensions.activeSetUdpate_v7g0ext.
    mimoParameters.m.precodingWeightSetRestrictionPresent))
  {
    rrcllcpcie_update_mimo_codebook_restriction(TRUE);
  }
  else
  {
    rrcllcpcie_update_mimo_codebook_restriction(FALSE);
  }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

}

/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_asu_r8()

DESCRIPTION:
  This function updates the addional MIMO params for R8 ASU.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_asu_r8
(
  rrc_ActiveSetUpdate_r8 * active_set_update_r8_ota
)
{
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  if((active_set_update_r8_ota != NULL)
  	 && (active_set_update_r8_ota->m.v890NonCriticalExtensionsPresent)
  	 && (active_set_update_r8_ota->v890NonCriticalExtensions.activeSetUpdate_v890ext.m.mimoParametersPresent))
  {
    rrcllcpcie_update_mimo_scpich_po(&active_set_update_r8_ota->v890NonCriticalExtensions.activeSetUpdate_v890ext.mimoParameters);
  }
  else
  {
    ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
    WRRC_MSG1_HIGH("MIMO: Setting S-CPICH PO = %d",rrc_mimo_s_cpich_po);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/


#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  if((active_set_update_r8_ota != NULL) && (active_set_update_r8_ota->m.v890NonCriticalExtensionsPresent) &&
    (active_set_update_r8_ota->v890NonCriticalExtensions.m.v7g0NonCriticalExtensionsPresent) &&
    (active_set_update_r8_ota->v890NonCriticalExtensions.v7g0NonCriticalExtensions.activeSetUpdate_v7g0ext.m. 
    mimoParametersPresent) &&
    (active_set_update_r8_ota->v890NonCriticalExtensions.v7g0NonCriticalExtensions.activeSetUpdate_v7g0ext.
    mimoParameters.m.precodingWeightSetRestrictionPresent))
  {
    rrcllcpcie_update_mimo_codebook_restriction(TRUE);
  }
  else
  {
    rrcllcpcie_update_mimo_codebook_restriction(FALSE);
  }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

}
/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_cu_r7()

DESCRIPTION:
  This function updates the addional MIMO params for R7 CU.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_cu_r7
(
  uint32 dl_sdu_num,
  void * cell_update_r7_msg_ptr
)
{
  rrc_DL_CCCH_Message *ccch_ptr= NULL;
  rrc_DL_DCCH_Message *dcch_ptr= NULL;  

#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  rrcllcpcie_update_mimo_codebook_restriction(FALSE);
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  if(rrc_DL_CCCH_Message_PDU == dl_sdu_num)
  {
    ccch_ptr=  (rrc_DL_CCCH_Message *)cell_update_r7_msg_ptr;

    if((ccch_ptr != NULL) && (ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.
      criticalExtensions.u.criticalExtensions.u.r7.m.cellUpdateConfirm_r7_add_extPresent) && 
      (ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
      u.r7.cellUpdateConfirm_r7_add_ext.m.v7f0NonCriticalExtensionsPresent))
    {
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
      if(ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
        u.r7.cellUpdateConfirm_r7_add_ext.v7f0NonCriticalExtensions.cellUpdateConfirm_v7f0ext.m.mimoParametersPresent)
      {
        rrcllcpcie_update_mimo_scpich_po(&ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.
          criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r7.cellUpdateConfirm_r7_add_ext.
          v7f0NonCriticalExtensions.cellUpdateConfirm_v7f0ext.mimoParameters);      
      }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION	  
      if((ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
        u.r7.cellUpdateConfirm_r7_add_ext.v7f0NonCriticalExtensions.m.v7g0NonCriticalExtensionsPresent) && 
        (ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
        u.r7.cellUpdateConfirm_r7_add_ext.v7f0NonCriticalExtensions.v7g0NonCriticalExtensions.cellUpdateConfirm_v7g0ext.m.
        mimoParametersPresent) && (ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.
        criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r7.cellUpdateConfirm_r7_add_ext.v7f0NonCriticalExtensions.v7g0NonCriticalExtensions.
        cellUpdateConfirm_v7g0ext.mimoParameters.m.precodingWeightSetRestrictionPresent))
      {
        rrcllcpcie_update_mimo_codebook_restriction(TRUE);      
      }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
    }
  }
  {
    dcch_ptr = (rrc_DL_DCCH_Message *)cell_update_r7_msg_ptr;

    if((dcch_ptr != NULL) && (dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.
      criticalExtensions.u.criticalExtensions.u.r7.m.cellUpdateConfirm_r7_add_extPresent) && 
      (dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
      u.r7.cellUpdateConfirm_r7_add_ext.m.v7f0NonCriticalExtensionsPresent))
    {
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
      if(dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
        u.r7.cellUpdateConfirm_r7_add_ext.v7f0NonCriticalExtensions.cellUpdateConfirm_v7f0ext.m.mimoParametersPresent)
      {
        rrcllcpcie_update_mimo_scpich_po(&dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.
          criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r7.cellUpdateConfirm_r7_add_ext.
          v7f0NonCriticalExtensions.cellUpdateConfirm_v7f0ext.mimoParameters);
      }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
       if((dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
        u.r7.cellUpdateConfirm_r7_add_ext.v7f0NonCriticalExtensions.m.v7g0NonCriticalExtensionsPresent) && 
        (dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.
        criticalExtensions.u.criticalExtensions.u.r7.cellUpdateConfirm_r7_add_ext.
        v7f0NonCriticalExtensions.v7g0NonCriticalExtensions.cellUpdateConfirm_v7g0ext.m.mimoParametersPresent) 
        && (dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.
        criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r7.cellUpdateConfirm_r7_add_ext.
        v7f0NonCriticalExtensions.v7g0NonCriticalExtensions.
        cellUpdateConfirm_v7g0ext.mimoParameters.m.precodingWeightSetRestrictionPresent))
      {
        rrcllcpcie_update_mimo_codebook_restriction(TRUE);      
      }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
    }
  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_cu_r8()

DESCRIPTION:
  This function updates the addional MIMO params for R8 CU.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_cu_r8
(
  uint32 dl_sdu_num,
  void * cell_update_r8_msg_ptr
)
{
  rrc_DL_DCCH_Message *dcch_ptr= NULL;  

#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  rrcllcpcie_update_mimo_codebook_restriction(FALSE);
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  if(rrc_DL_DCCH_Message_PDU == dl_sdu_num)
  {
    dcch_ptr = (rrc_DL_DCCH_Message *)cell_update_r8_msg_ptr;
    if((dcch_ptr != NULL) && (dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.
      criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.m.v7d0NonCriticalExtensionsPresent) &&
      (dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent))
    {
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT    
      if(dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.
        v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.cellUpdateConfirm_v7f0ext.m.mimoParametersPresent)
      {
        rrcllcpcie_update_mimo_scpich_po(&dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.
            criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.cellUpdateConfirm_v7f0ext.mimoParameters);
      }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
      if((dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.
	  	criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.
        v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.m.v890NonCriticalExtensionsPresent) &&
        (dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.
        u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.
        v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
        v890NonCriticalExtensions.m.v7g0NonCriticalExtensionsPresent) &&
        (dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.
        criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.
        v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.v7g0NonCriticalExtensions.
        cellUpdateConfirm_v7g0ext.m.mimoParametersPresent) &&
        (dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.
        criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.
        v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.
        v7g0NonCriticalExtensions.cellUpdateConfirm_v7g0ext.mimoParameters.m.
        precodingWeightSetRestrictionPresent))
      {
        rrcllcpcie_update_mimo_codebook_restriction(TRUE);      
      }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/  
    }
  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_tcrc_r7()

DESCRIPTION:
  This function updates the addional MIMO params for R7 TCRC.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_tcrc_r7
(
  rrc_TransportChannelReconfiguration_r7 * trch_reconfig_r7_ota
)
{
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  rrcllcpcie_update_mimo_codebook_restriction(FALSE);
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  if((trch_reconfig_r7_ota != NULL) && (trch_reconfig_r7_ota->m.v780NonCriticalExtensionsPresent) &&
    (trch_reconfig_r7_ota->v780NonCriticalExtensions.m.v7d0NonCriticalExtensionsPresent) &&
    (trch_reconfig_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent))
  {
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
    if(trch_reconfig_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.transportChannelReconfiguration_v7f0ext.m.mimoParametersPresent)
    {
      rrcllcpcie_update_mimo_scpich_po(&trch_reconfig_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
        transportChannelReconfiguration_v7f0ext.mimoParameters);
    }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/  

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
     if((trch_reconfig_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.
		v7f0NonCriticalExtensions.m.v7g0NonCriticalExtensionsPresent) &&
    (trch_reconfig_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.
    v7f0NonCriticalExtensions.v7g0NonCriticalExtensions.
    transportChannelReconfiguration_v7g0ext.m.mimoParametersPresent) &&
    (trch_reconfig_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
    v7g0NonCriticalExtensions.transportChannelReconfiguration_v7g0ext.
    mimoParameters.m.precodingWeightSetRestrictionPresent))
    {
      rrcllcpcie_update_mimo_codebook_restriction(TRUE);
    }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  }
}


/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_tcrc_r8()

DESCRIPTION:
  This function updates the addional MIMO params for R8 TCRC.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_tcrc_r8
(
  rrc_TransportChannelReconfiguration_r8 * trch_reconfig_r8_ota
)
{
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  rrcllcpcie_update_mimo_codebook_restriction(FALSE);
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  if((trch_reconfig_r8_ota != NULL) && (trch_reconfig_r8_ota->m.v7d0NonCriticalExtensionsPresent) &&
    (trch_reconfig_r8_ota->v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent))
  {
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT  
    if(trch_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.transportChannelReconfiguration_v7f0ext.m.mimoParametersPresent)
    {
      rrcllcpcie_update_mimo_scpich_po(&trch_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.transportChannelReconfiguration_v7f0ext.mimoParameters);
    }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/  

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
    if((trch_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
		m.v890NonCriticalExtensionsPresent) &&
      (trch_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
      v890NonCriticalExtensions.m.v7g0NonCriticalExtensionsPresent) &&
      (trch_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
      v890NonCriticalExtensions.v7g0NonCriticalExtensions.
      transportChannelReconfiguration_v7g0ext.m.mimoParametersPresent ) &&
      (trch_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
      v890NonCriticalExtensions.v7g0NonCriticalExtensions.transportChannelReconfiguration_v7g0ext.
      mimoParameters.m.precodingWeightSetRestrictionPresent))
    {
      rrcllcpcie_update_mimo_codebook_restriction(TRUE);
    }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  }
}


/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_rbrc_r7()

DESCRIPTION:
  This function updates the addional MIMO params for R7 RBRC.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_rbrc_r7
(
  rrc_RadioBearerReconfiguration_r7 * rb_reconfig_r7_ota
)
{
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  rrcllcpcie_update_mimo_codebook_restriction(FALSE);
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  if((rb_reconfig_r7_ota != NULL) &&
    (rb_reconfig_r7_ota->m.v780NonCriticalExtensionsPresent) && 
    (rb_reconfig_r7_ota->v780NonCriticalExtensions.m.v790NonCriticalExtensionsPresent) &&
    (rb_reconfig_r7_ota->v780NonCriticalExtensions.v790NonCriticalExtensions.m.v7d0NonCriticalExtensionsPresent) &&
    (rb_reconfig_r7_ota->v780NonCriticalExtensions.v790NonCriticalExtensions.v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent)) 
  {
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT  
    if(rb_reconfig_r7_ota->v780NonCriticalExtensions.v790NonCriticalExtensions.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
      radioBearerReconfiguration_v7f0ext.m.mimoParametersPresent)

    {
      rrcllcpcie_update_mimo_scpich_po(&rb_reconfig_r7_ota->v780NonCriticalExtensions.v790NonCriticalExtensions.v7d0NonCriticalExtensions.
        v7f0NonCriticalExtensions.radioBearerReconfiguration_v7f0ext.mimoParameters);
    }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
     if((rb_reconfig_r7_ota->v780NonCriticalExtensions.v790NonCriticalExtensions.
		v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.m.v7g0NonCriticalExtensionsPresent) && 
      (rb_reconfig_r7_ota->v780NonCriticalExtensions.v790NonCriticalExtensions.
      v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
      v7g0NonCriticalExtensions.radioBearerReconfiguration_v7g0ext.m.mimoParametersPresent) &&
      (rb_reconfig_r7_ota->v780NonCriticalExtensions.v790NonCriticalExtensions.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
      v7g0NonCriticalExtensions.radioBearerReconfiguration_v7g0ext.
      mimoParameters.m.precodingWeightSetRestrictionPresent))
    {
      rrcllcpcie_update_mimo_codebook_restriction(TRUE);
    }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_rbrc_r8()

DESCRIPTION:
  This function updates the addional MIMO params for R8 RBRC.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_rbrc_r8
(
  rrc_RadioBearerReconfiguration_r8 * rb_reconfig_r8_ota
)
{
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  rrcllcpcie_update_mimo_codebook_restriction(FALSE);
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  if((rb_reconfig_r8_ota != NULL) && (rb_reconfig_r8_ota->m.v7d0NonCriticalExtensionsPresent) &&
  (rb_reconfig_r8_ota->v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent))
  {
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT  
    if (rb_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.radioBearerReconfiguration_v7f0ext.m.mimoParametersPresent)
    {
      rrcllcpcie_update_mimo_scpich_po(&rb_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.radioBearerReconfiguration_v7f0ext.mimoParameters);
    } 
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
     if(( rb_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
		m.v890NonCriticalExtensionsPresent) &&
      (rb_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
      v890NonCriticalExtensions.m.v7g0NonCriticalExtensionsPresent) &&
      (rb_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.
      v7g0NonCriticalExtensions.radioBearerReconfiguration_v7g0ext.m.mimoParametersPresent) &&
      (rb_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.
      v7g0NonCriticalExtensions.radioBearerReconfiguration_v7g0ext.mimoParameters.
      m.precodingWeightSetRestrictionPresent))
    {
      rrcllcpcie_update_mimo_codebook_restriction(TRUE);    
    }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_rbr_r7()

DESCRIPTION:
  This function updates the addional MIMO params for R7 RBR.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_rbr_r7
(
  rrc_RadioBearerRelease_r7 * rb_release_r7_ota
)
{
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  rrcllcpcie_update_mimo_codebook_restriction(FALSE);
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  if((rb_release_r7_ota != NULL) &&  (rb_release_r7_ota->m.v780NonCriticalExtensionsPresent) &&
    (rb_release_r7_ota->v780NonCriticalExtensions.m.v7d0NonCriticalExtensionsPresent) &&
    (rb_release_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent))
  {
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT  
    if(rb_release_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.radioBearerRelease_v7f0ext.m.mimoParametersPresent)
    {
      rrcllcpcie_update_mimo_scpich_po(&rb_release_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.
        v7f0NonCriticalExtensions.radioBearerRelease_v7f0ext.mimoParameters);
    }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
     if((rb_release_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.
		v7f0NonCriticalExtensions.m.v7g0NonCriticalExtensionsPresent) &&
      (rb_release_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
      v7g0NonCriticalExtensions.radioBearerRelease_v7g0ext.m.mimoParametersPresent) &&
      (rb_release_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
      v7g0NonCriticalExtensions.radioBearerRelease_v7g0ext.mimoParameters.m.precodingWeightSetRestrictionPresent))
    {
      rrcllcpcie_update_mimo_codebook_restriction(TRUE);
    }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_rbr_r8()

DESCRIPTION:
  This function updates the addional MIMO params for R8 RBR.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_rbr_r8
(
  rrc_RadioBearerRelease_r8 * rb_release_r8_ota
)
{
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  rrcllcpcie_update_mimo_codebook_restriction(FALSE);
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  if((rb_release_r8_ota != NULL) && (rb_release_r8_ota->m.v7d0NonCriticalExtensionsPresent) &&
    (rb_release_r8_ota->v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent))
  {
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT  
    if(rb_release_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.radioBearerRelease_v7f0ext.m.mimoParametersPresent)
    {
      rrcllcpcie_update_mimo_scpich_po(&rb_release_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.radioBearerRelease_v7f0ext.mimoParameters);
    }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
     if((rb_release_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
		m.v890NonCriticalExtensionsPresent) &&
      (rb_release_r8_ota->v7d0NonCriticalExtensions.
      v7f0NonCriticalExtensions.v890NonCriticalExtensions.
      m.v7g0NonCriticalExtensionsPresent) &&
      (rb_release_r8_ota->v7d0NonCriticalExtensions.
      v7f0NonCriticalExtensions.v890NonCriticalExtensions.
      v7g0NonCriticalExtensions.radioBearerRelease_v7g0ext.m.mimoParametersPresent) &&
      (rb_release_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
      v890NonCriticalExtensions.v7g0NonCriticalExtensions.radioBearerRelease_v7g0ext.
      mimoParameters.m.precodingWeightSetRestrictionPresent))
    {
      rrcllcpcie_update_mimo_codebook_restriction(TRUE);
    }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_rbe_r7()

DESCRIPTION:
  This function updates the addional MIMO params for R7 RBE.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_rbe_r7
(
  rrc_RadioBearerSetup_r7 * rb_setup_r7_ota
)
{
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  rrcllcpcie_update_mimo_codebook_restriction(FALSE);
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  if((rb_setup_r7_ota != NULL) && (rb_setup_r7_ota->m.radioBearerSetup_r7_add_extPresent) &&
  (rb_setup_r7_ota->radioBearerSetup_r7_add_ext.m.v7f0NonCriticalExtensionsPresent))
  {

#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT  
    if(rb_setup_r7_ota->radioBearerSetup_r7_add_ext.v7f0NonCriticalExtensions.radioBearerSetup_v7f0ext.m.mimoParametersPresent)
    {
      rrcllcpcie_update_mimo_scpich_po(&rb_setup_r7_ota->radioBearerSetup_r7_add_ext.v7f0NonCriticalExtensions.
        radioBearerSetup_v7f0ext.mimoParameters);
    }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
     if((rb_setup_r7_ota->radioBearerSetup_r7_add_ext.v7f0NonCriticalExtensions.
		m.v7g0NonCriticalExtensionsPresent) &&
      (rb_setup_r7_ota->radioBearerSetup_r7_add_ext.v7f0NonCriticalExtensions.
      v7g0NonCriticalExtensions.radioBearerSetup_v7g0ext.m.mimoParametersPresent) &&
      (rb_setup_r7_ota->radioBearerSetup_r7_add_ext.v7f0NonCriticalExtensions.
      v7g0NonCriticalExtensions.radioBearerSetup_v7g0ext.
      mimoParameters.m.precodingWeightSetRestrictionPresent))
    {
      rrcllcpcie_update_mimo_codebook_restriction(TRUE);    
    }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/  
  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_rbe_r8()

DESCRIPTION:
  This function updates the addional MIMO params for R8 RBE.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_rbe_r8
(
  rrc_RadioBearerSetup_r8 * rb_setup_r8_ota
)
{

#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  rrcllcpcie_update_mimo_codebook_restriction(FALSE);
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  if((rb_setup_r8_ota != NULL) && (rb_setup_r8_ota->m.v7d0NonCriticalExtensionsPresent) &&
    (rb_setup_r8_ota->v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent))
  {
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT    
    if (rb_setup_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.radioBearerSetup_v7f0ext.m.mimoParametersPresent)
    {
      rrcllcpcie_update_mimo_scpich_po(&rb_setup_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.radioBearerSetup_v7f0ext.mimoParameters);
    }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
    if((rb_setup_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.m.v890NonCriticalExtensionsPresent) &&
      (rb_setup_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.m.v7g0NonCriticalExtensionsPresent) &&
      (rb_setup_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.
      v7g0NonCriticalExtensions.radioBearerSetup_v7g0ext.m.mimoParametersPresent) &&
      (rb_setup_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.
      v7g0NonCriticalExtensions.radioBearerSetup_v7g0ext.mimoParameters.m.precodingWeightSetRestrictionPresent))
    {
      rrcllcpcie_update_mimo_codebook_restriction(TRUE);
    }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_pcrc_r7()

DESCRIPTION:
  This function updates the addional MIMO params for R7 PCRC.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_pcrc_r7
(
  rrc_PhysicalChannelReconfiguration_r7 * phys_chan_reconfig_r7_ota
)
{
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  rrcllcpcie_update_mimo_codebook_restriction(FALSE);
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  if((phys_chan_reconfig_r7_ota != NULL) && (phys_chan_reconfig_r7_ota->m.v780NonCriticalExtensionsPresent) && 
    (phys_chan_reconfig_r7_ota->v780NonCriticalExtensions.m.v7d0NonCriticalExtensionsPresent) &&
    (phys_chan_reconfig_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent))
  {
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT  
    if(phys_chan_reconfig_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.physicalChannelReconfiguration_v7f0ext.m.mimoParametersPresent)
    {
      rrcllcpcie_update_mimo_scpich_po(&phys_chan_reconfig_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.
        v7f0NonCriticalExtensions.physicalChannelReconfiguration_v7f0ext.mimoParameters);
    }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
     if((phys_chan_reconfig_r7_ota->v780NonCriticalExtensions.
		v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.m.v7g0NonCriticalExtensionsPresent) &&
      (phys_chan_reconfig_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
      v7g0NonCriticalExtensions.physicalChannelReconfiguration_v7g0ext.m.mimoParametersPresent) &&
      (phys_chan_reconfig_r7_ota->v780NonCriticalExtensions.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
      v7g0NonCriticalExtensions.physicalChannelReconfiguration_v7g0ext.
      mimoParameters.m.precodingWeightSetRestrictionPresent))
    {
      rrcllcpcie_update_mimo_codebook_restriction(TRUE);
    }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_ext_pcrc_r8()

DESCRIPTION:
  This function updates the addional MIMO params for R8 PCRC.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_process_mimo_params_ext_pcrc_r8
(
  rrc_PhysicalChannelReconfiguration_r8 * phys_chan_reconfig_r8_ota
)
{
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
  ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
  rrcllcpcie_update_mimo_codebook_restriction(FALSE);
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  if((phys_chan_reconfig_r8_ota != NULL) && (phys_chan_reconfig_r8_ota->m.v7d0NonCriticalExtensionsPresent) &&
    (phys_chan_reconfig_r8_ota->v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent))
  {
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT  
    if(phys_chan_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.physicalChannelReconfiguration_v7f0ext.m.mimoParametersPresent)
    {
      rrcllcpcie_update_mimo_scpich_po(&phys_chan_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
        physicalChannelReconfiguration_v7f0ext.mimoParameters);
    }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/

#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
    if((phys_chan_reconfig_r8_ota->v7d0NonCriticalExtensions.
		v7f0NonCriticalExtensions.m.v890NonCriticalExtensionsPresent) &&
    (phys_chan_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.
    v890NonCriticalExtensions.m.v7g0NonCriticalExtensionsPresent) &&
    (phys_chan_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.
    v7g0NonCriticalExtensions.physicalChannelReconfiguration_v7g0ext.m.mimoParametersPresent) &&
    (phys_chan_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.
    v7g0NonCriticalExtensions.physicalChannelReconfiguration_v7g0ext.mimoParameters.m.precodingWeightSetRestrictionPresent))
    {
      rrcllcpcie_update_mimo_codebook_restriction(TRUE);
    }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  }
}

#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

#endif

/*============================================================================
FUNCTION: rrcllcpcie_update_hs_tfri_table_type_non_r7_ota()

DESCRIPTION:
  This function updates the TRFI table to be used for MAC-HS or MAC-EHS for Non-R7 OTA
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_update_hs_tfri_table_type_non_r7_ota
(
  void
)
{  
  hsdpa_action_enum_type hs_action =rrc_get_hsdpa_action() ;
  if( (hs_action == HSDPA_START) ||
       ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && (hs_action != HSDPA_STOP)) 
   )
  {
    if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
    {
      WRRC_MSG0_HIGH("MACEHS:Bit aligned TFRI table to be used as MAC-HS configured");
      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type = 
               L1_DL_HS_DSCH_TB_TABLE_OCTET_UNALIGNED;
    }
    else if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
    {
#ifdef FEATURE_WCDMA_64QAM
      if(ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
      {
         WRRC_MSG0_HIGH("MACEHS:OCTET aligned TFRI table to be used as 64QAM configured");
         ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type = 
                    L1_DL_HS_DSCH_TB_TABLE_OCTET_ALIGNED;
      }
      else
#endif
      if(hsdpa_msg_params.hspdsch_info_present == TRUE)
      {
        WRRC_MSG0_HIGH( "MACEHS:Bit aligned TFRI table to be used as HS Pdsch IE is present");
        ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type = 
               L1_DL_HS_DSCH_TB_TABLE_OCTET_UNALIGNED;
      }
      else
      {
        WRRC_MSG1_HIGH("MACEHS:TFRI table to be untouched as MAC-EHS configure %d",
            ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type); 
      }
    }
    
  }
  else
  {
    WRRC_MSG0_HIGH("MACEHS:Reset to Bit aligned TFRI table to be used as HS not active ");
    ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type = 
               L1_DL_HS_DSCH_TB_TABLE_OCTET_UNALIGNED;
  }
}

/*============================================================================
FUNCTION: rrcllcpcie_update_hs_tfri_table_type()

DESCRIPTION:
  This function updates the TRFI table to be used for MAC-HS or MAC-EHS
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_update_hs_tfri_table_type
(
  boolean hs_tb_size_octet_aligned
)
{
  hsdpa_action_enum_type hs_action =rrc_get_hsdpa_action() ;
  if( (hs_action == HSDPA_START) ||
         ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && (hs_action != HSDPA_STOP)) 
     )
  { 
    if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
    {
       ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type = 
               L1_DL_HS_DSCH_TB_TABLE_OCTET_UNALIGNED;
    }
    else if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_EHS)
    {
        /*MAC-EHS*/
      if(ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
      {
         ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type = 
                    L1_DL_HS_DSCH_TB_TABLE_OCTET_ALIGNED;
      }
      else
      {
         if(hs_tb_size_octet_aligned == TRUE)
         {
             ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type = 
                    L1_DL_HS_DSCH_TB_TABLE_OCTET_ALIGNED;
         }
         else
         {
             ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type = 
                    L1_DL_HS_DSCH_TB_TABLE_OCTET_UNALIGNED;
         }
         if(current_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type != 
            ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type)
         {
            ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_DSCH_CFG_INCL;
            WRRC_MSG2_HIGH("Set HS-DSCH bitmask as TFRI table is changed from %d to %d",
              current_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type,
              ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type);
         }
      }
    }
    WRRC_MSG3_MED("MACEHS:hs or ehs %d [1=hs 2=ehs] TB Size table type %d [0=bit 1= octet] 64 QAM status %d",
              ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs,
              ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hsdsch_tb_size_alignment_type,
              ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured);
  }
}
/*============================================================================
FUNCTION: rrcllc_shld_ctch_be_setup()

DESCRIPTION:
  This function indicates if the present cell support CTCH or not.
   CSP calls this function to find out if CTCH can be setup or not after BPLMN search is done
      
DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE/FASLE

SIDE EFFECTS:
=============================================================================*/
boolean rrcllc_shld_ctch_be_setup
(
  void
)
{
  boolean use_conn_mode_sibs = FALSE;
  rrc_SysInfoType5    *sib5_ptr = NULL;
  rrc_SysInfoType6    *sib6_ptr = NULL;
  rrc_state_e_type next_rrc_state=rrc_get_state();
  
  switch(next_rrc_state)
  {
    case RRC_STATE_CELL_DCH:
    case RRC_STATE_CELL_FACH:
    case RRC_STATE_CONNECTING:
      WRRC_MSG1_HIGH("Invalid state to read sibs %d",next_rrc_state);
    return FALSE;
  
    case RRC_STATE_DISCONNECTED:
      use_conn_mode_sibs = FALSE;
    break;
  
    case RRC_STATE_CELL_PCH:
    case RRC_STATE_URA_PCH:
  
      use_conn_mode_sibs = TRUE;
    break;
  
    default:
      WRRC_MSG1_HIGH("Invalid RRC state %d passed", rrc_get_state());
      return(FALSE);
  
  }

  if(is_ctch_present_in_serving_cell(next_rrc_state) == FALSE)
  {
    return FALSE;
    
  }
    /************************/
  /* Get SIB 5 data next  */
  /************************/
  sib5_ptr = (rrc_SysInfoType5 *)
           rrc_sibdb_return_sib_for_srv_cell(rrc_SIB5);
  if (sib5_ptr == NULL)
  {
    WRRC_MSG0_ERROR("SIB 5 not yet in SIB data base");
    return FALSE;
  }
  if(use_conn_mode_sibs && (sib5_ptr->sib6indicator == TRUE))
  {
    sib6_ptr = (rrc_SysInfoType6 *)
             rrc_sibdb_return_sib_for_srv_cell(rrc_SIB6);
    if (sib6_ptr == NULL)
    {
      /* SIB 6 may not be present. That is acceptable */
      WRRC_MSG0_HIGH("SIB 6 not in SIB data base");
    }
  }
  
  if((sib6_ptr && use_conn_mode_sibs)&& 
     (RRC_CHECK_MSG_TYPE_IE_PTR(sib6_ptr, 
             sCCPCH_SystemInformationListPresent)) &&
     (verify_sccpch_exists(&sib6_ptr->sCCPCH_SystemInformationList,
                            next_rrc_state)
       == TRUE))
  {
  
    if((get_sccpch_index_for_sccpch_with_ctch(&sib6_ptr->sCCPCH_SystemInformationList)
       == RRCLLC_INVALID_SCCPCH_IDX ) &&
       (get_sccpch_index_for_sccpch_with_ctch(&sib5_ptr->sCCPCH_SystemInformationList)
     == RRCLLC_INVALID_SCCPCH_IDX ))
    {
     WRRC_MSG0_HIGH("Could not find sccpch index for CTCH in sib 6 and sib5");
     return FALSE;
    }
  
  
  } /* SCCPCH with FACH exists */
  else
  {
    if( get_sccpch_index_for_sccpch_with_ctch(&sib5_ptr->sCCPCH_SystemInformationList)
     == RRCLLC_INVALID_SCCPCH_IDX ) 
    {
      WRRC_MSG0_HIGH("Could not find sccpch index for CTCH in sib 5");
      return FALSE;
    }
  } /* SCCPCH with FACH does NOT exist in SIB6 */
  
  
  return TRUE;

}

#ifdef FEATURE_WCDMA_CPC_DRX
/*============================================================================
FUNCTION: rrcllcpcie_get_internal_inact_thrshd_grant_monitoring()

DESCRIPTION:
  This function will provide inact_thrshd_grant_monitoring in internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  inact_thrshd_grant_monitoring in internal form 

SIDE EFFECTS:
=============================================================================*/
l1_inact_thrshd_for_ue_grant_monitoring_info_enum_type  
rrcllcpcie_get_internal_inact_thrshd_grant_monitoring
(
  rrc_UE_GrantMonitoring_InactivityThreshold ue_GrantMonitoring_InactivityThreshold
)
{
  l1_inact_thrshd_for_ue_grant_monitoring_info_enum_type inact_thrshd_grant_monitoring = 
  L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_INVALID;

  switch(ue_GrantMonitoring_InactivityThreshold)
  {
    case rrc_UE_GrantMonitoring_InactivityThreshold_e_dch_tti_0:
      inact_thrshd_grant_monitoring = L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_0;
      break;
      
    case rrc_UE_GrantMonitoring_InactivityThreshold_e_dch_tti_1:
      inact_thrshd_grant_monitoring = L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_1;
      break;
      
    case rrc_UE_GrantMonitoring_InactivityThreshold_e_dch_tti_2:
      inact_thrshd_grant_monitoring = L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_2;
      break;
      
    case rrc_UE_GrantMonitoring_InactivityThreshold_e_dch_tti_4:
      inact_thrshd_grant_monitoring = L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_4;
      break;
      
    case rrc_UE_GrantMonitoring_InactivityThreshold_e_dch_tti_8:
      inact_thrshd_grant_monitoring = L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_8;
      break;
      
    case rrc_UE_GrantMonitoring_InactivityThreshold_e_dch_tti_16:
      inact_thrshd_grant_monitoring = L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_16;
      break;
      
    case rrc_UE_GrantMonitoring_InactivityThreshold_e_dch_tti_32:
      inact_thrshd_grant_monitoring = L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_32;
      break;
      
    case rrc_UE_GrantMonitoring_InactivityThreshold_e_dch_tti_64:
      inact_thrshd_grant_monitoring = L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_64;
      break;
      
    case rrc_UE_GrantMonitoring_InactivityThreshold_e_dch_tti_128:
      inact_thrshd_grant_monitoring = L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_128;
      break;
      
    case rrc_UE_GrantMonitoring_InactivityThreshold_e_dch_tti_256:
      inact_thrshd_grant_monitoring = L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_256;
      break;
      
    default:
      inact_thrshd_grant_monitoring = L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_INVALID;
      WRRC_MSG2_ERROR("CPCDRX:Invalid inact_thrshd_grant_monitoring [rx]%d [internal form]%d",
          ue_GrantMonitoring_InactivityThreshold,
          inact_thrshd_grant_monitoring);
      break;
  }
     
  return (inact_thrshd_grant_monitoring);
}

/*============================================================================
FUNCTION: rrcllcpcie_get_internal_inact_thrshd_drx_cycle()

DESCRIPTION:
  This function will provide internal_inact_thrshd_drx_cycle in internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  internal_inact_thrshd_drx_cycle in internal form 

SIDE EFFECTS:
=============================================================================*/
l1_inact_thrshd_for_ue_drx_cycle_info_enum_type  
rrcllcpcie_get_internal_inact_thrshd_drx_cycle
(
  rrc_UE_DRX_Cycle_InactivityThreshold ue_drx_Cycle_InactivityThreshold
)
{
  l1_inact_thrshd_for_ue_drx_cycle_info_enum_type inact_thrshd_drx_cycle = 
  L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_INVALID;

  switch(ue_drx_Cycle_InactivityThreshold)
  {
    case rrc_UE_DRX_Cycle_InactivityThreshold_sub_frames_0:
      inact_thrshd_drx_cycle = L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_0;
      break;
      
    case rrc_UE_DRX_Cycle_InactivityThreshold_sub_frames_1:
      inact_thrshd_drx_cycle = L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_1;
      break;
      
    case rrc_UE_DRX_Cycle_InactivityThreshold_sub_frames_2:
      inact_thrshd_drx_cycle = L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_2;
      break;
      
    case rrc_UE_DRX_Cycle_InactivityThreshold_sub_frames_4:
      inact_thrshd_drx_cycle = L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_4;
      break;
      
    case rrc_UE_DRX_Cycle_InactivityThreshold_sub_frames_8:
      inact_thrshd_drx_cycle = L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_8;
      break;
      
    case rrc_UE_DRX_Cycle_InactivityThreshold_sub_frames_16:
      inact_thrshd_drx_cycle = L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_16;
      break;
      
    case rrc_UE_DRX_Cycle_InactivityThreshold_sub_frames_32:
      inact_thrshd_drx_cycle = L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_32;
      break;
      
    case rrc_UE_DRX_Cycle_InactivityThreshold_sub_frames_64:
      inact_thrshd_drx_cycle = L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_64;
      break;
      
    case rrc_UE_DRX_Cycle_InactivityThreshold_sub_frames_128:
      inact_thrshd_drx_cycle = L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_128;
      break;
      
    case rrc_UE_DRX_Cycle_InactivityThreshold_sub_frames_256:
      inact_thrshd_drx_cycle = L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_256;
      break;
      
    case rrc_UE_DRX_Cycle_InactivityThreshold_sub_frames_512:
      inact_thrshd_drx_cycle = L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_512;
      break;
      
    default:
      inact_thrshd_drx_cycle = L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_INVALID;
      WRRC_MSG2_ERROR("CPCDRX:Invalid inact_thrshd_drx_cycle [rx]%d [internal form]%d",
         ue_drx_Cycle_InactivityThreshold,
         inact_thrshd_drx_cycle);
      break;
  }
     
  return (inact_thrshd_drx_cycle);
}


/*============================================================================
FUNCTION: rrcllcpcie_get_internal_drx_cycle()

DESCRIPTION:
  This function will provide drx_cycle in internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  drx_cycle in internal form 

SIDE EFFECTS:
=============================================================================*/
l1_ue_drx_cycle_info_enum_type  rrcllcpcie_get_internal_drx_cycle
(
  rrc_UE_DRX_Cycle ue_drx_Cycle_rx
)
{
  l1_ue_drx_cycle_info_enum_type ue_drx_cycle = L1_UE_DRX_CYCLE_NUM_SUBFM_MAX;
  switch(ue_drx_Cycle_rx)
  {
    case rrc_UE_DRX_Cycle_sub_frames_4:
      ue_drx_cycle = L1_UE_DRX_CYCLE_NUM_SUBFM_4;
      break;
      
    case rrc_UE_DRX_Cycle_sub_frames_5:
      ue_drx_cycle = L1_UE_DRX_CYCLE_NUM_SUBFM_5;
      break;
      
    case rrc_UE_DRX_Cycle_sub_frames_8:
      ue_drx_cycle = L1_UE_DRX_CYCLE_NUM_SUBFM_8;
      break;
      
    case rrc_UE_DRX_Cycle_sub_frames_10:
      ue_drx_cycle = L1_UE_DRX_CYCLE_NUM_SUBFM_10;
      break;
      
    case rrc_UE_DRX_Cycle_sub_frames_16:
      ue_drx_cycle = L1_UE_DRX_CYCLE_NUM_SUBFM_16;
      break;
      
    case rrc_UE_DRX_Cycle_sub_frames_20:
      ue_drx_cycle = L1_UE_DRX_CYCLE_NUM_SUBFM_20;
      break;
      
    default:
      ue_drx_cycle = L1_UE_DRX_CYCLE_NUM_SUBFM_MAX;
      WRRC_MSG2_ERROR("CPCDRX:Invalid ue_drx_cycle [rx]%d [internal form]%d",
         ue_drx_Cycle_rx,
         ue_drx_cycle);
      break;
  }
     
  return (ue_drx_cycle);
}
#endif

#ifdef FEATURE_WCDMA_CPC_DTX
/*============================================================================
FUNCTION: rrcllcpcie_get_dtx_drx_enabling_delay()

DESCRIPTION:
  This function converts dtx-drx enabling delay to internal form.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  internal form of dtx-drx enabling delay

SIDE EFFECTS:
=============================================================================*/
static l1_dtx_drx_enabling_delay_info_enum_type    rrcllcpcie_get_dtx_drx_enabling_delay
(
  rrc_EnablingDelay dtx_drx_enabling_delay
)
{
  l1_dtx_drx_enabling_delay_info_enum_type int_dtx_drx_enabling_delay;

  switch(dtx_drx_enabling_delay)
  {
    case rrc_EnablingDelay_radio_frames_0:
      int_dtx_drx_enabling_delay = L1_NUM_RADIO_FRAMES_0;
      break;
      
    case rrc_EnablingDelay_radio_frames_1:
      int_dtx_drx_enabling_delay = L1_NUM_RADIO_FRAMES_1;
      break;
    
    case rrc_EnablingDelay_radio_frames_2:
      int_dtx_drx_enabling_delay = L1_NUM_RADIO_FRAMES_2;
      break;
    
    case rrc_EnablingDelay_radio_frames_4:
      int_dtx_drx_enabling_delay = L1_NUM_RADIO_FRAMES_4;
      break;
  
    case rrc_EnablingDelay_radio_frames_8:
      int_dtx_drx_enabling_delay = L1_NUM_RADIO_FRAMES_8;
      break;

    case rrc_EnablingDelay_radio_frames_16:
      int_dtx_drx_enabling_delay = L1_NUM_RADIO_FRAMES_16;
      break;

    case rrc_EnablingDelay_radio_frames_32:
      int_dtx_drx_enabling_delay = L1_NUM_RADIO_FRAMES_32;
      break;

    case rrc_EnablingDelay_radio_frames_64:
      int_dtx_drx_enabling_delay = L1_NUM_RADIO_FRAMES_64;
      break;

    case rrc_EnablingDelay_radio_frames_128:
      int_dtx_drx_enabling_delay = L1_NUM_RADIO_FRAMES_128;
      break;
  
    default:
      int_dtx_drx_enabling_delay = L1_NUM_RADIO_FRAMES_MAX;
      WRRC_MSG1_ERROR("RRCCPC:Invalid dtx_drx_enabling_delay =%d ",dtx_drx_enabling_delay);
      break;
  }
  return int_dtx_drx_enabling_delay;
}

/*============================================================================
FUNCTION: rrcllcpcie_process_dtx_drx_timinginfo()

DESCRIPTION:
  This function processes DTX-DRX timing info in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type    rrcllcpcie_process_dtx_drx_timinginfo
(
  rrc_DTX_DRX_TimingInfo_r7 *dtx_drx_timingInfo,
  OSS_UINT32 dtx_drx_timingInfo_present_ota,
  OSS_UINT32 dtx_drx_Info_present_ota
)
{
  uecomdef_status_e_type status = SUCCESS;
  if(dtx_drx_timingInfo_present_ota)
  {
    /*Check to see if the timing chosen is continue or new timing*/
    if(dtx_drx_timingInfo->timing.t ==
      T_rrc_DTX_DRX_TimingInfo_r7_timing_continue_)
    {
      if(dtx_drx_Info_present_ota)
      {
        WRRC_MSG0_ERROR("RRCCPC:dtx_drx_Info_present_ota, Send Failuer");
        status = FAILURE;
      }
      else if(ordered_config_ptr->is_hho && (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
      {
        /* Firt time into DCH is also considered a HHO.  So only populate the release list of 
         * EDCH in the case of DCH->DCH only
         */
        WRRC_MSG0_ERROR("RRCCPC:HHO case,Timing Info is continue, Send Failuer");
        status = FAILURE;
      }
      else
      {
        rrcllc_update_l1_dtx_req_mask_for_no_op(TRUE);
      }
    }
    else
    {
      /*Check if dtx_drx_offset & enabling_delay are in valid range,If not send a failuer*/
      
      if((dtx_drx_timingInfo->timing.u.newTiming->ue_dtx_drx_Offset > UE_MAX_DTX_DRX_OFFSET )||
        (rrcllcpcie_get_dtx_drx_enabling_delay(dtx_drx_timingInfo->timing.u.newTiming->enablingDelay)
          == L1_NUM_RADIO_FRAMES_MAX))
      {
        status = FAILURE;
        WRRC_MSG2_ERROR("RRCCPC:Invalid values,dtx_drx_offset(In Sub-fm) =%d,enabling_delay(In radio frames) =%d",
          dtx_drx_timingInfo->timing.u.newTiming->ue_dtx_drx_Offset,
          rrcllcpcie_get_dtx_drx_enabling_delay(dtx_drx_timingInfo->timing.u.newTiming->enablingDelay));
      }
      else
      {
        ordered_config_ptr->dtx_drx_timing_info.dtx_drx_offset =
        dtx_drx_timingInfo->timing.u.newTiming->ue_dtx_drx_Offset;
        
        ordered_config_ptr->dtx_drx_timing_info.enabling_delay =
          rrcllcpcie_get_dtx_drx_enabling_delay(dtx_drx_timingInfo->timing.u.newTiming->enablingDelay);
        rrcllc_update_l1_dtx_req_mask_for_reconfig(TRUE);
#ifdef FEATURE_WCDMA_CPC_DRX
        rrcllc_update_l1_drx_req_mask_for_reconfig(ordered_config_ptr,TRUE);
#endif
      }
    }

    if((!dtx_drx_Info_present_ota) && (TRUE == ordered_config_ptr->e_dch_transmission) &&
        (current_config_ptr->mac_e_config.e_tti != NUM_E_TTI) && 
        (ordered_config_ptr ->mac_e_config.e_tti != NUM_E_TTI) && 
        (ordered_config_ptr->mac_e_config.e_tti!= current_config_ptr ->mac_e_config.e_tti))
    {
      MSG_ERROR("RRCCPC:dtx_drx_Info_present_ota %d and TTI change from %d to %d, Send Failure",
				dtx_drx_Info_present_ota,current_config_ptr->mac_e_config.e_tti,ordered_config_ptr ->mac_e_config.e_tti);
      status = FAILURE;
    }
			
  }
  return status;
}
/*============================================================================
FUNCTION: rrcllcpcie_get_ue_drx_cycle()

DESCRIPTION:
  This function converts UE DRX cycle to internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  UE DRX cycle internal form 

SIDE EFFECTS:
=============================================================================*/
static uint8 rrcllcpcie_get_ue_drx_cycle
(
  rrc_UE_DRX_Cycle ue_drx_Cycle
)
{
  uint8 ue_drx_cycle_internal=0;

  switch(ue_drx_Cycle)
  {
    case rrc_UE_DRX_Cycle_sub_frames_4:
      ue_drx_cycle_internal = 4;
      break;

    case rrc_UE_DRX_Cycle_sub_frames_5:
      ue_drx_cycle_internal = 5;
      break;

    case rrc_UE_DRX_Cycle_sub_frames_8:
      ue_drx_cycle_internal = 8;
      break;
      
    case rrc_UE_DRX_Cycle_sub_frames_10:
      ue_drx_cycle_internal = 10;
      break;

    case rrc_UE_DRX_Cycle_sub_frames_16:
      ue_drx_cycle_internal = 16;
      break;

    case rrc_UE_DRX_Cycle_sub_frames_20:
      ue_drx_cycle_internal = 20;
      break;

    default:
      ue_drx_cycle_internal = 21;
      break;
  }

  return ue_drx_cycle_internal;
}
/*============================================================================
FUNCTION: rrcllcpcie_validate_drx_params()

DESCRIPTION:
  This function converts MAC DRX info to internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_validate_drx_params
(
  rrc_DRX_Info    *drx_Info
)
{
  uecomdef_status_e_type status = SUCCESS;

  /*If the IE "UE DRX cycle" is not an integer multiple or a divisor of the 
  *value of the IE "UE DTX cycle 1"
  */
  if(status == SUCCESS)
  {
  if((((uint8)ordered_config_ptr->dtx_info.ue_dtx_cycle1) <
      rrcllcpcie_get_ue_drx_cycle(drx_Info->ue_drx_Cycle)))
  {
    if((rrcllcpcie_get_ue_drx_cycle(drx_Info->ue_drx_Cycle) %
      (uint8)ordered_config_ptr->dtx_info.ue_dtx_cycle1) != 0)
    {
      WRRC_MSG2_ERROR("RRCCPC: UE drx_cycle(%d) is not an integer multiple of dtx_cycle1(%d) ",
        rrcllcpcie_get_ue_drx_cycle(drx_Info->ue_drx_Cycle),
        ordered_config_ptr->dtx_info.ue_dtx_cycle1);
      status = FAILURE;
    }
  }
  else
  {
    if(((uint8)ordered_config_ptr->dtx_info.ue_dtx_cycle1) %
      rrcllcpcie_get_ue_drx_cycle(drx_Info->ue_drx_Cycle) != 0)
    {
      WRRC_MSG2_ERROR("RRCCPC: dtx_cycle1(%d) is not an integer multiple of UE drx_cycle(%d) ",
                ordered_config_ptr->dtx_info.ue_dtx_cycle1,
        rrcllcpcie_get_ue_drx_cycle(drx_Info->ue_drx_Cycle));
      status = FAILURE;
    }
  }
  }
  
  return status;
}


/*============================================================================
FUNCTION: rrcllcpcie_process_drx_info()

DESCRIPTION:
  This function processes DRX info in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static void  rrcllcpcie_process_drx_info
(
  rrc_DRX_Info    *drx_Info,
  OSS_UINT32 drx_Info_present_in_ota
)
{
  if(drx_Info_present_in_ota)
  {
#ifdef FEATURE_WCDMA_CPC_DRX
    rrcllcpcie_init_drx_info_before_processing(ordered_config_ptr);
    
    ordered_config_ptr->drx_info.inact_thrshd_drx_cycle = 
      rrcllcpcie_get_internal_inact_thrshd_drx_cycle(
      drx_Info->ue_drx_Cycle_InactivityThreshold);
    
    ordered_config_ptr->drx_info.inact_thrshd_grant_monitoring = 
      rrcllcpcie_get_internal_inact_thrshd_grant_monitoring(
      drx_Info->ue_GrantMonitoring_InactivityThreshold);
    
    if(drx_Info->ue_drx_GrantMonitoring == TRUE)
    {
      ordered_config_ptr->drx_info.l1_ue_drx_grant_monitoring = TRUE;
    }
    else
    {
      ordered_config_ptr->drx_info.l1_ue_drx_grant_monitoring = FALSE;
    }
    
    ordered_config_ptr->drx_info.ue_drx_cycle = 
      rrcllcpcie_get_internal_drx_cycle(drx_Info->ue_drx_Cycle);
#endif
  }
}
/*============================================================================
FUNCTION: rrcllcpcie_validate_dtx_params()

DESCRIPTION:
  This function converts MAC DTX info to internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_validate_dtx_params
(
  rrc_DTX_Info    *dtx_Info
)
{
  uecomdef_status_e_type status = SUCCESS;
  e_tti_enum_type             e_tti = NUM_E_TTI;
  uint8 ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_MAX;
  uint8 ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_MAX;
  uint8 l1_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_MAX;
  uint8 ue_dpcch_burst_1 = L1_UE_DPCCH_BURST_1_NUM_SUBFM_MAX;
  uint8 ue_dpcch_burst_2 = L1_UE_DPCCH_BURST_2_NUM_SUBFM_MAX;
  uint8 dtx_long_preamble_length = L1_LONG_PREAMBLE_LENGTH_NUM_SLOTS_MAX;
  uint16 inact_thrshd_dtx_cycle2 = L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_INVALID;


  if(dtx_Info->e_dch_TTI_Length.t
    == T_rrc_DTX_Info_e_dch_TTI_Length_dtx_e_dch_TTI_10ms)
  {
    e_tti = E_TTI_10MS;
  }
  else
  {
    e_tti = E_TTI_2MS;
  }
  if(ordered_config_ptr->mac_e_config.e_tti != e_tti)
  {
    WRRC_MSG2_ERROR("E-DCH TTI %d which is not same as DTX TTI =%d", 
      ordered_config_ptr->mac_e_config.e_tti, e_tti);
    status = FAILURE;
  }

  /*1) Check    if the value of the IE "UE DTX cycle 2" is not an integer multiple 
  *of the value of the IE "UE DTX cycle 1".
  */
  if(status == SUCCESS)
  {
    if(e_tti == E_TTI_10MS)
    {
      ue_dtx_cycle1 = ((uint8)rrcllcpcie_get_dtx_cycle1(
           &dtx_Info->e_dch_TTI_Length.u.dtx_e_dch_TTI_10ms->ue_dtx_Cycle1_10ms,e_tti));
      
      ue_dtx_cycle2 = ((uint8)rrcllcpcie_get_dtx_cycle2(
           &dtx_Info->e_dch_TTI_Length.u.dtx_e_dch_TTI_10ms->ue_dtx_Cycle2_10ms,e_tti));
      
      l1_mac_dtx_cycle = (uint8)rrcllcpcie_get_mac_dtx_cycle(
          &dtx_Info->e_dch_TTI_Length.u.dtx_e_dch_TTI_10ms->mac_dtx_Cycle_10ms,e_tti);
    }
    else
    {
      ue_dtx_cycle1 = ((uint8)rrcllcpcie_get_dtx_cycle1(
           &dtx_Info->e_dch_TTI_Length.u.dtx_e_dch_TTI_2ms->ue_dtx_Cycle1_2ms,e_tti));
      
      ue_dtx_cycle2 = ((uint8)rrcllcpcie_get_dtx_cycle2(
           &dtx_Info->e_dch_TTI_Length.u.dtx_e_dch_TTI_2ms->ue_dtx_Cycle2_2ms,e_tti));
      
      l1_mac_dtx_cycle = (uint8)rrcllcpcie_get_mac_dtx_cycle(
          &dtx_Info->e_dch_TTI_Length.u.dtx_e_dch_TTI_2ms->mac_dtx_Cycle_2ms,e_tti);
    }
  }
  
  if(status == SUCCESS)
  {
    if(ue_dtx_cycle1 <= ue_dtx_cycle2)
    {
      if(ue_dtx_cycle2 % ue_dtx_cycle1 != 0)
      {
        WRRC_MSG2_ERROR("RRCCPC: dtx_cycle2(%d) is not an integer multiple of dtx_cycle1(%d) ",
          ue_dtx_cycle2,
          ue_dtx_cycle1);
        status = FAILURE;
      }
    }
    else
    {
      WRRC_MSG2_ERROR("RRCCPC: dtx_cycle1(%d) is greater then dtx_cycle2(%d) ",
        ue_dtx_cycle1,
        ue_dtx_cycle2);
      status = FAILURE;
    }
  }
  
  /*2) Check if the value of the IE "UE DTX cycle 2" is not an integer multiple or 
   * a divisor of the value of the IE "CQI Feedback cycle, k"divided by 2; .
  */
  if(status == SUCCESS)
  {
    if(ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle == 0)
    {
      WRRC_MSG2_ERROR("RRCCPC: cqi_feedback_cycle(%d) is not an integer multiple of dtx_cycle2(%d) ",
         (ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle),
          ue_dtx_cycle2);
      status = FAILURE;
    }
    else
    {
      if(((ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle/2) <=
          ue_dtx_cycle2))
      {
        if((ue_dtx_cycle2 %
          (ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle/2)) != 0)
        {
          WRRC_MSG2_ERROR("RRCCPC: ue_dtx_cycle2(%d) is not an integer multiple of cqi_feedback_cycle(%d) ",
           ue_dtx_cycle2,
            (ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle/2));
          status = FAILURE;
        }
      }
      else
      {
        if(((ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle/2) %
          ue_dtx_cycle2) != 0)
        {
          WRRC_MSG2_ERROR("RRCCPC: cqi_feedback_cycle(%d) is not an integer multiple of dtx_cycle2(%d) ",
            (ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.meas_feedback_info.cqi_feedback_cycle/2),
            ue_dtx_cycle2);
          status = FAILURE;
        }
      }
    }
  }
    
  /*3) Check if the value of the IE "UE DPCCH burst 1" is greater than the value of the IE "UE DTX cycle 1"; 
   */
  if(status == SUCCESS)
  {
    ue_dpcch_burst_1 = (uint8)rrcllcpcie_get_ue_dpcch_burst_1_info(&dtx_Info->ue_dpcch_Burst1);
    ue_dpcch_burst_2 = (uint8)rrcllcpcie_get_ue_dpcch_burst_2_info(&dtx_Info->ue_dpcch_Burst2);

    WRRC_MSG2_HIGH("RRCCPC: ue_dpcch_burst_1(%d) ue_dtx_cycle1(%d) ",ue_dpcch_burst_1,ue_dtx_cycle1);
      
    if(ue_dpcch_burst_1 > ue_dtx_cycle1)
    {
      status = FAILURE;
    }
  }
  /*4) Check if the value of the IE "UE DPCCH burst 2" is greater than the value of the IE "UE DTX cycle 2"
  */
  if(status == SUCCESS)
  {
    if(ue_dpcch_burst_2 > ue_dtx_cycle2)
    {
      WRRC_MSG2_ERROR("RRCCPC: ue_dpcch_burst_1(%d) greater then ue_dtx_cycle1(%d) ",
          ue_dpcch_burst_2,
          ue_dtx_cycle2);
      status = FAILURE;
    }
  }
  /*5) if the value of the IE "UE DTX cycle 1" is not an integer multiple or a divisor of the value of the IE "MAC DTX cycle"
  */
  if(status == SUCCESS)
  {
    if((ue_dtx_cycle1 <= l1_mac_dtx_cycle))
    {
      if((l1_mac_dtx_cycle % ue_dtx_cycle1) != 0)
      {
        WRRC_MSG2_ERROR("RRCCPC: ue_dtx_cycle1(%d) is not an integer multiple of l1_mac_dtx_cycle(%d) ",
          ue_dtx_cycle1,
          l1_mac_dtx_cycle);
        status = FAILURE;
      }
    }
    else
    {
      if((ue_dtx_cycle1 % l1_mac_dtx_cycle) != 0)
      {
        WRRC_MSG2_ERROR("RRCCPC: ue_dtx_cycle1(%d) is not an integer multiple of l1_mac_dtx_cycle(%d) ",
          ue_dtx_cycle1,
          l1_mac_dtx_cycle);
        status = FAILURE;
      }
    }
  }
  /*6) if the IE "UE DTX long preamble length" is set to 4 or 15 slots and the value of the 
   *IE "Inactivity Threshold for UE DTX cycle 2" is less than 4 TTIs (for 10ms E-DCH TTI) or 8 TTIs (for 2ms E-DCH TTI);  
  */
  if(status == SUCCESS)
  {
    if(dtx_Info->m.ue_dtx_long_preamble_lengthPresent)
    {
    dtx_long_preamble_length = (uint8)rrcllcpcie_get_ue_dtx_long_preamble_length(
       &dtx_Info->ue_dtx_long_preamble_length);
    }
    else
    {
      WRRC_MSG0_HIGH("RRCCPC: ue_dtx_long_preamble_length in NOT present ,set default val(2)");
      dtx_long_preamble_length = (uint8) L1_LONG_PREAMBLE_LENGTH_NUM_SLOTS_2;
    }

    inact_thrshd_dtx_cycle2 = (uint16)rrcllcpcie_get_inact_thrshd_dtx_cycle2(
    &dtx_Info->ue_dtx_cycle2InactivityThreshold);

    if((dtx_long_preamble_length == (uint8)L1_LONG_PREAMBLE_LENGTH_NUM_SLOTS_4)||
      (dtx_long_preamble_length == (uint8)L1_LONG_PREAMBLE_LENGTH_NUM_SLOTS_15))
    {
      if(((e_tti == E_TTI_2MS)&&
        (inact_thrshd_dtx_cycle2 < (uint16)L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_8)
        )||
        ((e_tti == E_TTI_10MS)&&
        (inact_thrshd_dtx_cycle2 < (uint16)L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_4))
        )
      {
        MSG_ERROR("RRCCPC: Validation of inact_thrshd_dtx_cycle2(%d) fail,E-TTI=%d, long_pre_len = %d",
           inact_thrshd_dtx_cycle2,
          e_tti,
          dtx_long_preamble_length);
        status = FAILURE;
      }
      else
      {
        MSG_HIGH("RRCCPC: Validation of inact_thrshd_dtx_cycle2(%d) Pass..,E-TTI=%d, long_pre_len = %d",
          inact_thrshd_dtx_cycle2,
          e_tti,
          dtx_long_preamble_length);
      }
    }
  }

  /*7) Only the values of the IE “UE DTX DRX Offset” that fulfill the equation UE DTX DRX 
  *Offset mod 5=0 can be configured with 10ms E-DCH TTI. The UE behaviour is not specified 
  *if any other values are used with 10ms TTI.  
  */
  if(status == SUCCESS)
  {
    if(e_tti == E_TTI_10MS)
    {

        WRRC_MSG1_HIGH("RRCCPC:dtx_drx_offset(%d) mod 5 = 0 for 10msec E-TTI",
          ordered_config_ptr->dtx_drx_timing_info.dtx_drx_offset);
    
      if((ordered_config_ptr->dtx_drx_timing_info.dtx_drx_offset % 5) != 0)
      {
        status = FAILURE;
      }
    }
  }
  return status;
}
/*============================================================================
FUNCTION: rrcllcpcie_get_ue_dpcch_burst_2_info()

DESCRIPTION:
  This function converts MAC DTX info to internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
l1_ue_dpcch_burst_2_info_enum_type rrcllcpcie_get_ue_dpcch_burst_2_info
(
    rrc_UE_DPCCH_Burst *ue_dpcch_Burst2
)
{
  l1_ue_dpcch_burst_2_info_enum_type int_ue_dpcch_burst_2_info = 
    L1_UE_DPCCH_BURST_2_NUM_SUBFM_MAX;

  switch(*ue_dpcch_Burst2)
  {
    case rrc_UE_DPCCH_Burst_sub_frames_1:
      int_ue_dpcch_burst_2_info = L1_UE_DPCCH_BURST_2_NUM_SUBFM_1;
      break;

    case rrc_UE_DPCCH_Burst_sub_frames_2:
      int_ue_dpcch_burst_2_info = L1_UE_DPCCH_BURST_2_NUM_SUBFM_2;
      break;

    case rrc_UE_DPCCH_Burst_sub_frames_5:
      int_ue_dpcch_burst_2_info = L1_UE_DPCCH_BURST_2_NUM_SUBFM_5;
      break;

    default :
      WRRC_MSG1_ERROR("RRCCPC:Invalid value for ue_dpcch_burst_2_info=%d ",*ue_dpcch_Burst2);
      int_ue_dpcch_burst_2_info = L1_UE_DPCCH_BURST_2_NUM_SUBFM_MAX;
      break;
  }

  return int_ue_dpcch_burst_2_info;
}

/*============================================================================
FUNCTION: rrcllcpcie_get_ue_dpcch_burst_1_info()

DESCRIPTION:
  This function converts MAC DTX info to internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
l1_ue_dpcch_burst_1_info_enum_type rrcllcpcie_get_ue_dpcch_burst_1_info
(
    rrc_UE_DPCCH_Burst *ue_dpcch_burst_1_info
)
{
  l1_ue_dpcch_burst_1_info_enum_type int_ue_dpcch_burst_1_info = 
    L1_UE_DPCCH_BURST_1_NUM_SUBFM_MAX;

  switch(*ue_dpcch_burst_1_info)
  {
    case rrc_UE_DPCCH_Burst_sub_frames_1:
      int_ue_dpcch_burst_1_info = L1_UE_DPCCH_BURST_1_NUM_SUBFM_1;
      break;

    case rrc_UE_DPCCH_Burst_sub_frames_2:
      int_ue_dpcch_burst_1_info = L1_UE_DPCCH_BURST_1_NUM_SUBFM_2;
      break;

    case rrc_UE_DPCCH_Burst_sub_frames_5:
      int_ue_dpcch_burst_1_info = L1_UE_DPCCH_BURST_1_NUM_SUBFM_5;
      break;

    default :
      WRRC_MSG1_ERROR("RRCCPC:Invalid value for ue_dpcch_burst_1_info=%d ",*ue_dpcch_burst_1_info);
      int_ue_dpcch_burst_1_info = L1_UE_DPCCH_BURST_1_NUM_SUBFM_MAX;
      break;
  }

  return int_ue_dpcch_burst_1_info;
}

/*============================================================================
FUNCTION: rrcllcpcie_get_cqi_dtx_timer()

DESCRIPTION:
  This function converts MAC DTX info to internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static l1_cqi_dtx_timer_info_enum_type rrcllcpcie_get_cqi_dtx_timer
(
  rrc_CQI_DTX_Timer *cqi_dtx_Timer
)
{
  l1_cqi_dtx_timer_info_enum_type int_cqi_dtx_Timer = 
    L1_CQI_DTX_TIMER_NUM_SUBFM_MAX;

  switch(*cqi_dtx_Timer)
  {
    case rrc_CQI_DTX_Timer_sub_frames_0:
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_0;
      break;

    case rrc_CQI_DTX_Timer_sub_frames_1:
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_1;
      break;

    case rrc_CQI_DTX_Timer_sub_frames_2:
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_2;
      break;

    case rrc_CQI_DTX_Timer_sub_frames_4:
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_4;
      break;

    case rrc_CQI_DTX_Timer_sub_frames_8:
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_8;
      break;

    case rrc_CQI_DTX_Timer_sub_frames_16:
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_16;
      break;

    case rrc_CQI_DTX_Timer_sub_frames_32:
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_32;
      break;

    case rrc_CQI_DTX_Timer_sub_frames_64:
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_64;
      break;

    case rrc_CQI_DTX_Timer_sub_frames_128:
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_128;
      break;

    case rrc_CQI_DTX_Timer_sub_frames_256:
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_256;
      break;

    case rrc_CQI_DTX_Timer_sub_frames_512:
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_512;
      break;

    case rrc_CQI_DTX_Timer_sub_frames_Infinity:
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_INFINITY;
      break;
      
    default :
      WRRC_MSG1_ERROR("RRCCPC:Invalid value for cqi_dtx_Timer=%d ",*cqi_dtx_Timer);
      int_cqi_dtx_Timer = L1_CQI_DTX_TIMER_NUM_SUBFM_MAX;
      break;
  }

  return int_cqi_dtx_Timer;
}
  
/*============================================================================
FUNCTION: rrcllcpcie_get_ue_dtx_long_preamble_length()

DESCRIPTION:
  This function converts MAC DTX info to internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static l1_mac_inactivity_threshold_info_enum_type rrcllcpcie_get_mac_inactivity_threshold
(
  rrc_MAC_InactivityThreshold *mac_InactivityThreshold
)
{
  l1_mac_inactivity_threshold_info_enum_type int_mac_InactivityThreshold =
    L1_MAC_INACT_THRSHD_NUM_TTI_MAX;
  switch(*mac_InactivityThreshold)
  {
    case rrc_MAC_InactivityThreshold_e_dch_tti_1:
      int_mac_InactivityThreshold = L1_MAC_INACT_THRSHD_NUM_TTI_1;
      break;

    case rrc_MAC_InactivityThreshold_e_dch_tti_2:
      int_mac_InactivityThreshold = L1_MAC_INACT_THRSHD_NUM_TTI_2;
      break;

    case rrc_MAC_InactivityThreshold_e_dch_tti_4:
      int_mac_InactivityThreshold = L1_MAC_INACT_THRSHD_NUM_TTI_4;
      break;

    case rrc_MAC_InactivityThreshold_e_dch_tti_8:
      int_mac_InactivityThreshold = L1_MAC_INACT_THRSHD_NUM_TTI_8;
      break;

    case rrc_MAC_InactivityThreshold_e_dch_tti_16:
      int_mac_InactivityThreshold = L1_MAC_INACT_THRSHD_NUM_TTI_16;
      break;

    case rrc_MAC_InactivityThreshold_e_dch_tti_32:
      int_mac_InactivityThreshold = L1_MAC_INACT_THRSHD_NUM_TTI_32;
      break;

    case rrc_MAC_InactivityThreshold_e_dch_tti_64:
      int_mac_InactivityThreshold = L1_MAC_INACT_THRSHD_NUM_TTI_64;
      break;

    case rrc_MAC_InactivityThreshold_e_dch_tti_128:
      int_mac_InactivityThreshold = L1_MAC_INACT_THRSHD_NUM_TTI_128;
      break;

    case rrc_MAC_InactivityThreshold_e_dch_tti_256:
      int_mac_InactivityThreshold = L1_MAC_INACT_THRSHD_NUM_TTI_256;
      break;

    case rrc_MAC_InactivityThreshold_e_dch_tti_512:
      int_mac_InactivityThreshold = L1_MAC_INACT_THRSHD_NUM_TTI_512;
      break;

    case rrc_MAC_InactivityThreshold_e_dch_tti_Infinity:
      int_mac_InactivityThreshold = L1_MAC_INACT_THRSHD_NUM_TTI_INFINITY;
      break;

      
    default :
      WRRC_MSG1_ERROR("RRCCPC:Invalid value for mac_InactivityThreshold=%d ",*mac_InactivityThreshold);
      int_mac_InactivityThreshold = L1_MAC_INACT_THRSHD_NUM_TTI_MAX;
      break;
  }

  return int_mac_InactivityThreshold;
}

/*============================================================================
FUNCTION: rrcllcpcie_get_ue_dtx_long_preamble_length()

DESCRIPTION:
  This function converts MAC DTX info to internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
l1_dtx_long_preamble_length_info_enum_type rrcllcpcie_get_ue_dtx_long_preamble_length
(
  rrc_UE_DTX_long_preamble_length *ue_dtx_long_preamble_length
)
{
  l1_dtx_long_preamble_length_info_enum_type int_ue_dtx_long_preamble_length
    = L1_LONG_PREAMBLE_LENGTH_NUM_SLOTS_MAX;
  switch(*ue_dtx_long_preamble_length)
  {
    case rrc_UE_DTX_long_preamble_length_slots_4:
      int_ue_dtx_long_preamble_length = L1_LONG_PREAMBLE_LENGTH_NUM_SLOTS_4;
      break;
      
      case rrc_UE_DTX_long_preamble_length_slots_15:
        int_ue_dtx_long_preamble_length = L1_LONG_PREAMBLE_LENGTH_NUM_SLOTS_15
          ;
        break;

    default :
      WRRC_MSG1_ERROR("RRCCPC:Invalid value for ue_dtx_long_preamble_length=%d ",*ue_dtx_long_preamble_length);
      int_ue_dtx_long_preamble_length = L1_LONG_PREAMBLE_LENGTH_NUM_SLOTS_2;
      break;
  }
  return int_ue_dtx_long_preamble_length;
}

/*============================================================================
FUNCTION: rrcllcpcie_get_inact_thrshd_dtx_cycle2()

DESCRIPTION:
  This function converts MAC DTX info to internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
l1_inactivity_threshold_for_ue_dtx_cycle2_info_enum_type rrcllcpcie_get_inact_thrshd_dtx_cycle2
(
  rrc_UE_DTX_Cycle2InactivityThreshold *ue_dtx_cycle2_inactiv_thrshd
)
{
  l1_inactivity_threshold_for_ue_dtx_cycle2_info_enum_type int_ue_dtx_cycle2_inactiv_thrshd =
    L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_INVALID;
  switch(*ue_dtx_cycle2_inactiv_thrshd)
  {
    case rrc_UE_DTX_Cycle2InactivityThreshold_e_dch_tti_1:
      int_ue_dtx_cycle2_inactiv_thrshd = L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_1;
      break;

  case rrc_UE_DTX_Cycle2InactivityThreshold_e_dch_tti_4:
    int_ue_dtx_cycle2_inactiv_thrshd = L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_4;
    break;

  case rrc_UE_DTX_Cycle2InactivityThreshold_e_dch_tti_8:
    int_ue_dtx_cycle2_inactiv_thrshd = L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_8;
    break;

  case rrc_UE_DTX_Cycle2InactivityThreshold_e_dch_tti_16:
    int_ue_dtx_cycle2_inactiv_thrshd = L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_16;
    break;

  case rrc_UE_DTX_Cycle2InactivityThreshold_e_dch_tti_32:
    int_ue_dtx_cycle2_inactiv_thrshd = L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_32;
    break;

  case rrc_UE_DTX_Cycle2InactivityThreshold_e_dch_tti_64:
    int_ue_dtx_cycle2_inactiv_thrshd = L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_64;
    break;

  case rrc_UE_DTX_Cycle2InactivityThreshold_e_dch_tti_128:
    int_ue_dtx_cycle2_inactiv_thrshd = L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_128;
    break;

  case rrc_UE_DTX_Cycle2InactivityThreshold_e_dch_tti_256:
    int_ue_dtx_cycle2_inactiv_thrshd = L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_256;
    break;

    default :
      WRRC_MSG1_ERROR("RRCCPC:Invalid value for Inactivity thrshd for UE dtx cycle2=%d ",*ue_dtx_cycle2_inactiv_thrshd);
      int_ue_dtx_cycle2_inactiv_thrshd = L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_INVALID;
      break;
  }
  return int_ue_dtx_cycle2_inactiv_thrshd;
}

/*============================================================================
FUNCTION: rrcllcpcie_get_mac_dtx_cycle()

DESCRIPTION:
  This function converts MAC DTX info to internal form 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
l1_mac_dtx_cycle_info_enum_type rrcllcpcie_get_mac_dtx_cycle
(
  void    *mac_dtx_cycle,
  e_tti_enum_type e_tti
)
{
  rrc_MAC_DTX_Cycle_10ms *mac_dtx_Cycle_10ms = NULL;
  rrc_MAC_DTX_Cycle_2ms *mac_dtx_Cycle_2ms = NULL;
  l1_mac_dtx_cycle_info_enum_type int_mac_dtx_cycle = 
    L1_MAC_DTX_CYCLE_NUM_SUBFM_MAX;

if(e_tti == E_TTI_10MS )
{
  mac_dtx_Cycle_10ms = (rrc_MAC_DTX_Cycle_10ms *)mac_dtx_cycle;
}
else
{
  mac_dtx_Cycle_2ms = (rrc_MAC_DTX_Cycle_2ms *)mac_dtx_cycle;
}

if(e_tti == E_TTI_10MS )
{
  switch(*mac_dtx_Cycle_10ms)
  {
    case rrc_MAC_DTX_Cycle_10ms_sub_frames_5:
      int_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_5;
      break;

      case rrc_MAC_DTX_Cycle_10ms_sub_frames_10:
        int_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_10;
        break;
        
        case rrc_MAC_DTX_Cycle_10ms_sub_frames_20:
          int_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_20;
          break;

      default:
        WRRC_MSG1_ERROR("RRCCPC:Invalid value for mac dtx cycle=%d for 10msec E-DCH TTI",*mac_dtx_Cycle_10ms);
        int_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_MAX;
        break;
  }
}
else
{

  switch(*mac_dtx_Cycle_2ms)
  {
    case rrc_MAC_DTX_Cycle_2ms_sub_frames_1:
      int_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_1;
      break;

      case rrc_MAC_DTX_Cycle_2ms_sub_frames_4:
        int_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_4;
        break;

      case rrc_MAC_DTX_Cycle_2ms_sub_frames_5:
        int_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_5;
        break;

      case rrc_MAC_DTX_Cycle_2ms_sub_frames_8:
        int_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_8;
        break;

      case rrc_MAC_DTX_Cycle_2ms_sub_frames_10:
        int_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_10;
        break;

      case rrc_MAC_DTX_Cycle_2ms_sub_frames_16:
        int_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_16;
        break;

      case rrc_MAC_DTX_Cycle_2ms_sub_frames_20:
        int_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_20;
        break;

      default:
        WRRC_MSG1_ERROR("RRCCPC:Invalid value for mac dtx cycle=%d for 2msec E-DCH TTI",*mac_dtx_Cycle_2ms);
        int_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_MAX;
        break;
  }
}

return int_mac_dtx_cycle;

}

/*============================================================================
FUNCTION: rrcllcpcie_get_dtx_cycle2()

DESCRIPTION:
  This function processes DTX info in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
l1_ue_dtx_cycle2_info_enum_type  rrcllcpcie_get_dtx_cycle2
(
  void    *ue_dtx_cycle2,
  e_tti_enum_type e_tti
)
{
  rrc_UE_DTX_Cycle2_10ms *ue_dtx_Cycle2_10ms = NULL;
  rrc_UE_DTX_Cycle2_2ms *ue_dtx_Cycle2_2ms = NULL;
  l1_ue_dtx_cycle2_info_enum_type int_ue_dtx_cycle2 = 
    L1_UE_DTX_CYCLE2_NUM_SUBFM_MAX;

  if(e_tti == E_TTI_10MS )
  {
    ue_dtx_Cycle2_10ms = (rrc_UE_DTX_Cycle2_10ms *)ue_dtx_cycle2;
  }
  else
  {
    ue_dtx_Cycle2_2ms = (rrc_UE_DTX_Cycle2_2ms *)ue_dtx_cycle2;
  }

  if(e_tti == E_TTI_10MS )
  {
    switch(*ue_dtx_Cycle2_10ms)
    {
      case rrc_UE_DTX_Cycle2_10ms_sub_frames_5:
        int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_5;
        break;

        case rrc_UE_DTX_Cycle2_10ms_sub_frames_10:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_10;
          break;

        case rrc_UE_DTX_Cycle2_10ms_sub_frames_20:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_20;
          break;

        case rrc_UE_DTX_Cycle2_10ms_sub_frames_40:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_40;
          break;

        case rrc_UE_DTX_Cycle2_10ms_sub_frames_80:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_80;
          break;

        case rrc_UE_DTX_Cycle2_10ms_sub_frames_160:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_160;
          break;

        default:
          WRRC_MSG1_ERROR("RRCCPC:Invalid value for dtx cycle2=%d for 10msec E-DCH TTI",*ue_dtx_Cycle2_10ms);
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_MAX;
          break;
    }
  }
  else
  {

    switch(*ue_dtx_Cycle2_2ms)
    {
      case rrc_UE_DTX_Cycle2_2ms_sub_frames_4:
        int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_4;
        break;

        case rrc_UE_DTX_Cycle2_2ms_sub_frames_5:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_5;
          break;

        case rrc_UE_DTX_Cycle2_2ms_sub_frames_8:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_8;
          break;

        case rrc_UE_DTX_Cycle2_2ms_sub_frames_10:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_10;
          break;

        case rrc_UE_DTX_Cycle2_2ms_sub_frames_16:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_16;
          break;

        case rrc_UE_DTX_Cycle2_2ms_sub_frames_20:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_20;
          break;

        case rrc_UE_DTX_Cycle2_2ms_sub_frames_32:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_32;
          break;

        case rrc_UE_DTX_Cycle2_2ms_sub_frames_40:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_40;
          break;

        case rrc_UE_DTX_Cycle2_2ms_sub_frames_64:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_64;
          break;

        case rrc_UE_DTX_Cycle2_2ms_sub_frames_80:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_80;
          break;

        case rrc_UE_DTX_Cycle2_2ms_sub_frames_128:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_128;
          break;

        case rrc_UE_DTX_Cycle2_2ms_sub_frames_160:
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_160;
          break;

        default:
          WRRC_MSG1_ERROR("RRCCPC:Invalid value for dtx cycle2=%d for 2msec E-DCH TTI",*ue_dtx_Cycle2_2ms);
          int_ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_MAX;
          break;
    }
  }

  return int_ue_dtx_cycle2;
}
/*============================================================================
FUNCTION: rrcllcpcie_get_ul_dpcch_slot_format()

DESCRIPTION:
  This function will provide ul_dpcch_slot_format in internal format
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static l1_uplink_dpcch_slot_format_info_enum_type  rrcllcpcie_get_ul_dpcch_slot_format
(
rrc_Uplink_DPCCH_Slot_Format_Information ul_dcch_slot_format
)
{
  l1_uplink_dpcch_slot_format_info_enum_type int_ul_dcch_slot_format
    = L1_UL_DPCCH_SLOT_FORMAT_MAX;
  switch(ul_dcch_slot_format)
  {
    case rrc_Uplink_DPCCH_Slot_Format_Information_slot_format_1:
      int_ul_dcch_slot_format = L1_UL_DPCCH_SLOT_FORMAT_1;
      break;
  
    case rrc_Uplink_DPCCH_Slot_Format_Information_dummy:
      int_ul_dcch_slot_format = L1_UL_DPCCH_SLOT_FORMAT_3;
      break;
      
    case rrc_Uplink_DPCCH_Slot_Format_Information_slot_format_4:
      int_ul_dcch_slot_format = L1_UL_DPCCH_SLOT_FORMAT_4;
      break;
   
    default:
      WRRC_MSG1_ERROR("RRCCPC:ul_dcch_slot_format=%d NOT supported", ul_dcch_slot_format);
      break;
  }
  return int_ul_dcch_slot_format;
}
/*============================================================================
FUNCTION: rrcllcpcie_get_dtx_cycle1()

DESCRIPTION:
  This function processes DTX info in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
l1_ue_dtx_cycle1_info_enum_type  rrcllcpcie_get_dtx_cycle1
(
  void    *ue_dtx_cycle1,
  e_tti_enum_type e_tti
)
{
  rrc_UE_DTX_Cycle1_10ms *ue_dtx_Cycle1_10ms = NULL;
  rrc_UE_DTX_Cycle1_2ms *ue_dtx_Cycle1_2ms = NULL;
  l1_ue_dtx_cycle1_info_enum_type int_ue_dtx_cycle1 = 
    L1_UE_DTX_CYCLE1_NUM_SUBFM_MAX;

  if(e_tti == E_TTI_10MS )
  {
    ue_dtx_Cycle1_10ms = (rrc_UE_DTX_Cycle1_10ms *)ue_dtx_cycle1;
  }
  else
  {
    ue_dtx_Cycle1_2ms = (rrc_UE_DTX_Cycle1_2ms *)ue_dtx_cycle1;
  }

  if(e_tti == E_TTI_10MS )
  {
    switch(*ue_dtx_Cycle1_10ms)
    {
      case rrc_UE_DTX_Cycle1_10ms_sub_frames_1:
        int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_1;
        break;

        case rrc_UE_DTX_Cycle1_10ms_sub_frames_5:
          int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_5;
          break;

        case rrc_UE_DTX_Cycle1_10ms_sub_frames_10:
          int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_10;
          break;

        case rrc_UE_DTX_Cycle1_10ms_sub_frames_20:
          int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_20;
          break;

        default:
          WRRC_MSG1_ERROR("RRCCPC:Invalid value for dtx cycle1=%d for 10msec E-DCH TTI",*ue_dtx_Cycle1_10ms);
          int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_MAX;
          break;
    }
  }
  else
  {
    switch(*ue_dtx_Cycle1_2ms)
    {
      case rrc_UE_DTX_Cycle1_2ms_sub_frames_1:
        int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_1;
        break;

        case rrc_UE_DTX_Cycle1_2ms_sub_frames_4:
          int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_4;
          break;

        case rrc_UE_DTX_Cycle1_2ms_sub_frames_5:
          int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_5;
          break;

        case rrc_UE_DTX_Cycle1_2ms_sub_frames_8:
          int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_8;
          break;

        case rrc_UE_DTX_Cycle1_2ms_sub_frames_10:
          int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_10;
          break;

        case rrc_UE_DTX_Cycle1_2ms_sub_frames_16:
          int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_16;
          break;

        case rrc_UE_DTX_Cycle1_2ms_sub_frames_20:
          int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_20;
          break;

        default:
          WRRC_MSG1_ERROR("RRCCPC:Invalid value for dtx cycle1=%d for 2msec E-DCH TTI",*ue_dtx_Cycle1_2ms);
          int_ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_MAX;
          break;
    }
  }

  return int_ue_dtx_cycle1;
}
/*============================================================================
FUNCTION: rrcllcpcie_init_dtx_info_before_processing()

DESCRIPTION:
  This function will init stored DTX info before processing 
  DTX_info I.E
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static void  rrcllcpcie_init_dtx_info_before_processing
(
ordered_config_type *config_ptr
)
{
  config_ptr->dtx_info.cqi_dtx_timer = L1_CQI_DTX_TIMER_NUM_SUBFM_MAX;
  config_ptr->dtx_info.default_sg_in_dtx_cycle2 = L1_SERVING_GRANT_NOT_PRESENT;
  config_ptr->dtx_info.dtx_long_preamble_length = L1_LONG_PREAMBLE_LENGTH_NUM_SLOTS_MAX;
  config_ptr->dtx_info.e_tti = NUM_E_TTI;
  config_ptr->dtx_info.inact_thrshd_dtx_cycle2 = L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_INVALID;
  config_ptr->dtx_info.l1_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_MAX;
  config_ptr->dtx_info.l1_mac_inactivity_threshold = L1_MAC_INACT_THRSHD_NUM_TTI_MAX;
  config_ptr->dtx_info.ue_dpcch_burst_1 = L1_UE_DPCCH_BURST_1_NUM_SUBFM_MAX;
  config_ptr->dtx_info.ue_dpcch_burst_2 = L1_UE_DPCCH_BURST_2_NUM_SUBFM_MAX;
  config_ptr->dtx_info.ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_MAX;
  config_ptr->dtx_info.ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_MAX;
  config_ptr->dtx_info.uplink_dpcch_slot_format_info = L1_UL_DPCCH_SLOT_FORMAT_MAX;
}

/*============================================================================
FUNCTION: rrcllcpcie_process_dtx_info()

DESCRIPTION:
  This function processes DTX info in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static void  rrcllcpcie_process_dtx_info
(
  rrc_DTX_Info    *dtx_Info,
  OSS_UINT32 dtx_Info_present_in_ota
)
{
  e_tti_enum_type             e_tti = NUM_E_TTI;
  if(dtx_Info_present_in_ota)
  {

    /*Fill dtx cycle length*/

    /* store the contents of the IE in the variable DTX_DRX_PARAMS, replacing or clearing 
    *any previously stored "DTX Information" or "DRX Information"*/
    rrcllcpcie_init_dtx_info_before_processing(ordered_config_ptr);
    
    if(dtx_Info->e_dch_TTI_Length.t
      == T_rrc_DTX_Info_e_dch_TTI_Length_dtx_e_dch_TTI_10ms )
    {
      e_tti = E_TTI_10MS;
    }
    else
    {
      e_tti = E_TTI_2MS;
    }
    

    if(e_tti == E_TTI_10MS)
    {

      ordered_config_ptr->dtx_info.e_tti = E_TTI_10MS;
      
      ordered_config_ptr->dtx_info.ue_dtx_cycle1 = rrcllcpcie_get_dtx_cycle1(
         &dtx_Info->e_dch_TTI_Length.u.dtx_e_dch_TTI_10ms->ue_dtx_Cycle1_10ms,
      ordered_config_ptr->dtx_info.e_tti);
  
      ordered_config_ptr->dtx_info.ue_dtx_cycle2 = rrcllcpcie_get_dtx_cycle2(
         &dtx_Info->e_dch_TTI_Length.u.dtx_e_dch_TTI_10ms->ue_dtx_Cycle2_10ms,
      ordered_config_ptr->dtx_info.e_tti);

      ordered_config_ptr->dtx_info.l1_mac_dtx_cycle = rrcllcpcie_get_mac_dtx_cycle(
        &dtx_Info->e_dch_TTI_Length.u.dtx_e_dch_TTI_10ms->mac_dtx_Cycle_10ms,
        ordered_config_ptr->dtx_info.e_tti
        );
    }
    else if(e_tti == E_TTI_2MS)
    {
      
      ordered_config_ptr->dtx_info.e_tti = E_TTI_2MS;
      
      ordered_config_ptr->dtx_info.ue_dtx_cycle1 = rrcllcpcie_get_dtx_cycle1(
         &dtx_Info->e_dch_TTI_Length.u.dtx_e_dch_TTI_2ms->ue_dtx_Cycle1_2ms,
      ordered_config_ptr->dtx_info.e_tti);
  
      ordered_config_ptr->dtx_info.ue_dtx_cycle2 = rrcllcpcie_get_dtx_cycle2(
         &dtx_Info->e_dch_TTI_Length.u.dtx_e_dch_TTI_2ms->ue_dtx_Cycle2_2ms,
      ordered_config_ptr->dtx_info.e_tti);

      ordered_config_ptr->dtx_info.l1_mac_dtx_cycle = rrcllcpcie_get_mac_dtx_cycle(
        &dtx_Info->e_dch_TTI_Length.u.dtx_e_dch_TTI_2ms->mac_dtx_Cycle_2ms,
        ordered_config_ptr->dtx_info.e_tti
        );

    }

    ordered_config_ptr->dtx_info.inact_thrshd_dtx_cycle2 = 
       rrcllcpcie_get_inact_thrshd_dtx_cycle2(&dtx_Info->ue_dtx_cycle2InactivityThreshold);
    

    if(dtx_Info->m.ue_dtx_cycle2DefaultSGPresent)
    {
      ordered_config_ptr->dtx_info.default_sg_in_dtx_cycle2 = 
        dtx_Info->ue_dtx_cycle2DefaultSG;
    }
    else
    {//kpatil:check this out for reconfig case
      if(ordered_config_ptr->dtx_info.default_sg_in_dtx_cycle2 != L1_SERVING_GRANT_NOT_PRESENT)
      {
        WRRC_MSG1_HIGH("RRCCPC: Default SG NOT present in the message,retain prev =%d",
          ordered_config_ptr->dtx_info.default_sg_in_dtx_cycle2);
      }
      else
      {
        ordered_config_ptr->dtx_info.default_sg_in_dtx_cycle2 = L1_SERVING_GRANT_NOT_PRESENT;
      }
    }

    if(dtx_Info->m.ue_dtx_long_preamble_lengthPresent)
    {
      ordered_config_ptr->dtx_info.dtx_long_preamble_length = 
        rrcllcpcie_get_ue_dtx_long_preamble_length(
        &dtx_Info->ue_dtx_long_preamble_length);
    }
    else
    {
      WRRC_MSG0_HIGH("RRCCPC: ue_dtx_long_preamble_length in NOT present in the message,set default val");
      ordered_config_ptr->dtx_info.dtx_long_preamble_length = 
        L1_LONG_PREAMBLE_LENGTH_NUM_SLOTS_2;
    }

   
   ordered_config_ptr->dtx_info.l1_mac_inactivity_threshold= 
     rrcllcpcie_get_mac_inactivity_threshold (&dtx_Info->mac_InactivityThreshold);

   ordered_config_ptr->dtx_info.cqi_dtx_timer = 
     rrcllcpcie_get_cqi_dtx_timer (&dtx_Info->cqi_dtx_Timer);

   ordered_config_ptr->dtx_info.ue_dpcch_burst_1= 
     rrcllcpcie_get_ue_dpcch_burst_1_info (&dtx_Info->ue_dpcch_Burst1);

   ordered_config_ptr->dtx_info.ue_dpcch_burst_2= 
      rrcllcpcie_get_ue_dpcch_burst_2_info(&dtx_Info->ue_dpcch_Burst2);

  }
}
/*============================================================================
FUNCTION: rrcllcpcie_calculate_dpcch_slot_format()

DESCRIPTION:
  This function calculate dpcch_slot_format
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uint8  rrcllcpcie_calculate_dpcch_slot_format
(
  void
)
{
  uint8 slot_format = 0xFF;
  l1_ul_num_tpc_bits_enum_type numtpc;
  numtpc = ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.numtpc;
  /* Calculate DPCCH slot format */
  /* See 25.211 V3.4.0 2000-09 5.2.1, Table 2 (DPCCH fields) */
  switch (ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len)
  {
    case L1_UL_FBI_LEN_0:
      if(ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present)
      {
        slot_format = 0;
      }
      else
      {
        if(numtpc == L1_UL_NUM_TPC_BITS_4)
        {
          slot_format = 4;
        }
        else
        {
          slot_format = 1;
        }
      }
     break;

    case L1_UL_FBI_LEN_1:
      slot_format = (ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present) ? 2 : 3;
      break;

    default:
      slot_format = 0xFF;
      break;
  }

     MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"fbi_len=%d, tfci_present= %d slot_format = %d,numtpc=%d[0=NumTCP2,1=NumTCP4]",
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.fbi_len,
    ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.tfci_present,
    slot_format,numtpc);

  return slot_format;
}
/*============================================================================
FUNCTION: rrcllcpcie_validate_ul_dpcch_slot_format()

DESCRIPTION:
  This function validate ul_dpcch_slot_format
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type  rrcllcpcie_validate_ul_dpcch_slot_format
(
  l1_uplink_dpcch_slot_format_info_enum_type ul_dcch_slot_format
)
{
  uecomdef_status_e_type status = SUCCESS;
  uint8 slot_format = 0xFF;
  slot_format = rrcllcpcie_calculate_dpcch_slot_format();
  switch(slot_format)
  {
    case 0:
      status = FAILURE;
      break;
   
    case 1:
      if(ul_dcch_slot_format != L1_UL_DPCCH_SLOT_FORMAT_1)
      {
        status = FAILURE;
      }
      break;
   
    case 2:
      status = FAILURE;
      break;
   
    case 3:
      if(ul_dcch_slot_format != L1_UL_DPCCH_SLOT_FORMAT_3)
      {
        status = FAILURE;
      }
      break;
    
    case 4:
      if(ul_dcch_slot_format != L1_UL_DPCCH_SLOT_FORMAT_4)
      {
        status = FAILURE;
      }
      break;
    
   default:
    status = FAILURE;
    break;
  }

  MSG_HIGH("RRCCPC:Return status [0=S, 1=F] Calculated Slot Format is %d  Given slot format %d", status, slot_format,ul_dcch_slot_format);
  
  return status;
}
/*============================================================================
FUNCTION: rrcllcpcie_process_dtx_drx_info()

DESCRIPTION:
  This function processes DTX-DRX timing info in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type  rrcllcpcie_process_dtx_drx_info
(
  rrc_DTX_DRX_Info_r7 *dtx_drx_Info,
  OSS_UINT32 dtx_drx_Info_present_ota
)
{
  uecomdef_status_e_type status = SUCCESS;
  if(dtx_drx_Info_present_ota)
  {
    if((dtx_drx_Info->m.dtx_InfoPresent))
    {
      status = rrcllcpcie_validate_dtx_params(&dtx_drx_Info->dtx_Info);
      if(status == SUCCESS)
      {

        rrcllcpcie_process_dtx_info(&dtx_drx_Info->dtx_Info,
        dtx_drx_Info->m.dtx_InfoPresent);
      }
    }
    else
    {
      /*IE "DTX information" is not included in DTX-DRX info I.E 
      */
      WRRC_MSG0_ERROR("RRCCPC:DTX info not present in DTX-DRX info I.E, So reject the config");
      status = FAILURE;
    }
    
    if(status == SUCCESS)
    {
      if((dtx_drx_Info->m.drx_InfoPresent))
      {
        status = rrcllcpcie_validate_drx_params(&dtx_drx_Info->drx_Info);
        if(status == SUCCESS)
        {
          rrcllcpcie_process_drx_info(&dtx_drx_Info->drx_Info,
          dtx_drx_Info->m.drx_InfoPresent);
        }
      }
#ifdef FEATURE_WCDMA_CPC_DRX
      else
      {
        if(rrcllc_get_l1_cpc_drx_status(ordered_config_ptr) == TRUE)
        {
          WRRC_MSG0_HIGH("RRCCPC:DRX info I.E NOT presnt,set DRX action STOP");
          ordered_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_STOP;
    }
        else
        {
          /*Set action as NO_OP, as we would have set act as reconfig while handling dtx-drx timing info I.E*/
          WRRC_MSG0_HIGH("RRCCPC:No DRX info I.E DRX action NO_OP");
          ordered_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_NO_OP;
        }
        rrcllcpcie_init_drx_info_before_processing(ordered_config_ptr);
      }
#endif
    }
    
    if(status == SUCCESS)
    {
      status = rrcllcpcie_validate_ul_dpcch_slot_format(rrcllcpcie_get_ul_dpcch_slot_format
        (dtx_drx_Info->uplink_DPCCHSlotFormatInformation));
      if(status == SUCCESS)
      {
        ordered_config_ptr->dtx_info.uplink_dpcch_slot_format_info = 
        rrcllcpcie_get_ul_dpcch_slot_format(dtx_drx_Info->uplink_DPCCHSlotFormatInformation);
       }
    }
  }

  return status;
}


/*============================================================================
FUNCTION: rrcllcpcie_process_dtx_drx_params()

DESCRIPTION:
  This function processes 
  1) DTX-DRX timing info 
  2) dtx_drx_Info &
  3) evaluates DTX-DRX status in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type    rrcllcpcie_process_dtx_drx_params
(
  rrc_DTX_DRX_TimingInfo_r7 *dtx_drx_timingInfo,
  OSS_UINT32 dtx_drx_timingInfo_present_ota,
  rrc_DTX_DRX_Info_r7 *dtx_drx_Info,
  OSS_UINT32 dtx_drx_Info_present_ota,
  rrc_RRC_StateIndicator rrc_state
)
{
  uecomdef_status_e_type status = SUCCESS;

  /*For DTX-DRX to be ON, we need dtx_drx_timingInfo to be present*/
  if(dtx_drx_timingInfo_present_ota)
  {
    status = rrcllcpcie_process_dtx_drx_timinginfo(dtx_drx_timingInfo,
            dtx_drx_timingInfo_present_ota,
            dtx_drx_Info_present_ota);
  }

  if(status == SUCCESS)
  {
    if(dtx_drx_Info_present_ota)
    {
      status = rrcllcpcie_process_dtx_drx_info(dtx_drx_Info,
        dtx_drx_Info_present_ota);
    }
  }
  if(status == SUCCESS)
  {
    rrcllc_evaluate_dtx_drx_status_var_and_set_lower_layers_action
      (rrc_state,
      dtx_drx_timingInfo_present_ota
      );
  }
  return status;
}

#endif

/*============================================================================
FUNCTION: rrcllcpcie_process_rl_addition_info_list_r8()

DESCRIPTION:
  This function updates IE "rrc_RL_AdditionInformationList_r8 " in ordered config
  and update e_dch parameters

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_rl_addition_info_list_r8
(
  OSS_UINT32 rl_additon_info_list_present,
  rrc_RL_AdditionInformationList_r8 *rl_add_ptr
)
{
  uint8                            idx = 0;  /* local loop variable */
  uint16                           num_rl;   /* local RL count */
  /* flag to prevent erroneous increment of number of RL on attempt to add a duplicate RL */
  boolean duplicate_add_attempted = FALSE;
  uint32 n_value=0, n_index=0;

  uint32 e_rl_idx;
  boolean is_e_dl_info_present = FALSE;
  
  if(rl_additon_info_list_present)
  {
    if(RRC_CHECK_MSG_TYPE_IE(rl_add_ptr->elem[n_index], 
                targetCellPreconfigInfoPresent))
    {
      WRRC_MSG0_ERROR("REL8:IE targetCellPreconfigInfo/E-SCC not supported yet!");
      return FAILURE;
    }
  
    /*Validation is done so that Mixed RLs for DPCH/F-DPCH isn't allowed*/
    if(SUCCESS != validate_fdpch_information_r8(rl_add_ptr))
    {
      return FAILURE;   
    }

    num_rl = ordered_config_ptr->l1_dl_chan_parms.num_rl;
    n_value = rl_add_ptr->n;
    
    while((n_value != 0) && (idx < (UE_MAX_RL - num_rl)))
    {
      if(get_rl_add_info_r8(&rl_add_ptr->elem[n_index], &ordered_config_ptr->l1_dl_chan_parms,
                         &duplicate_add_attempted) == FAILURE)
      {
        WRRC_MSG0_HIGH("REL8: get_rl_add_info_r8() failed");
        return FAILURE;
      }

      /* one more radio link in ORDERED_CONFIG */
      if(!duplicate_add_attempted)
      {
        ordered_config_ptr->l1_dl_chan_parms.num_rl++;
      }
      if (RRC_CHECK_MSG_TYPE_IE(rl_add_ptr->elem[n_index], 
                e_HICH_InformationPresent))
      {
        /* if we are inside this if check then it means that RRC needs to indicate
           to L1 that some of the parameters in DL has changed */
        is_e_dl_info_present = TRUE;

        e_rl_idx = get_e_rl_index_for_a_given_psc(
              rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

        if (FAILURE == rrcllcpcie_update_e_hich_info_and_mask(e_rl_idx, 
                                                              &rl_add_ptr->elem[n_index].e_HICH_Information,
                                                              rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                            ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                            ))
        {
          return FAILURE;
        }
      }

      if (RRC_CHECK_MSG_TYPE_IE(rl_add_ptr->elem[n_index], 
                 e_RGCH_InformationPresent))
      {
        /* if we are inside this if check then it means that RRC needs to indicate
           to L1 that some of the parameters in DL has changed */
        is_e_dl_info_present = TRUE;

        if (FAILURE == rrcllcpcie_process_e_rgch_information(
            rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode,
            &rl_add_ptr->elem[n_index].e_RGCH_Information
#ifdef FEATURE_WCDMA_DC_HSUPA
          ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ))
        {
          return(FAILURE);
        }
      }

      /* get the next RL */
      n_value--;
      n_index++;
      idx++;
    } /* end loop of all included RLs to add */ 
    if (FAILURE == rrcllcpcie_validate_hich_rgch_info(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
      , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
      ))
    {
      return(FAILURE);
    }
  } /* end RL Addition information */

  /* Make sure we actually have some RLs in the active set */
  if(ordered_config_ptr->l1_dl_chan_parms.num_rl == 0)
  {
    WRRC_MSG0_HIGH("REL8:No RLs in ASET after ASU");
    return FAILURE;
  }

  /* update the l1_e_req_mask */
  rrcllc_update_l1_e_req_mask_for_e_dl_info(is_e_dl_info_present);

  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_is_hho_r8()

DESCRIPTION:
  This function returns boolean value based on whether inter-freq or intra-freq
  HHO is ongoing. 

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE - HHO in progress
  FALSE - No HHO

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_is_hho_r8
(
  OSS_UINT32 dl_info_per_rl_list_present,
  rrc_DL_InformationPerRL_List_r8 *dl_info_per_rl_list_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  boolean is_hho = FALSE, old_rl_seen = FALSE, new_rl_seen = FALSE;
  rrc_freq_type rrc_freq = rrc_ccm_get_curr_camped_freq();
  rrc_DL_InformationPerRL_List_r8 *tmp_ie_ptr = dl_info_per_rl_list_ptr;
  rrc_state_e_type curr_rrc_state = rrc_get_state();
  uint32 n_value=0, n_index=0;

  if ((rcvd_state_indicator == rrc_RRC_StateIndicator_cell_DCH) && 
      (dl_info_per_rl_list_present))
  {
    /*Initially set the is_hho flag if Inter-F HO is being triggered by the OTA or 
    the current state is DCH*/
    is_hho = ((ordered_config_ptr->dest_freq_present && ordered_config_ptr->dest_freq != rrc_freq) 
                  ||(curr_rrc_state != RRC_STATE_CELL_DCH));

    if (FALSE == is_hho)
    {
      n_value = tmp_ie_ptr->n;
      
      while(n_value != 0)
      {
        if(get_dl_rl_idx_to_update(tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode, 
            (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo, 
                        T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd)), 
            &ordered_config_ptr->l1_dl_chan_parms) <
            ordered_config_ptr->l1_dl_chan_parms.num_rl)
        {
          old_rl_seen = TRUE;
        }
        else
        {
          new_rl_seen = TRUE;
        }
  
        /* We can bail out early if we detect a mixed active set. */
        if(old_rl_seen && new_rl_seen)
        {
          WRRC_MSG0_ERROR("REL8: Mixed ASET detected, rejecting");
          return FAILURE;
        }
        n_value--;
        n_index++;
      }
      /* if new RL seen is true then it means its a dis-joint set and hence its value will indicate whether 
      its HHO or not. */
      is_hho = new_rl_seen;
    }
  
    if (TRUE == is_hho)
    {
      MSG_HIGH("HHO detected DCH trans %d intra-freq %d inter-freq %d ",
               (curr_rrc_state != RRC_STATE_CELL_DCH), 
               new_rl_seen,
               (ordered_config_ptr->dest_freq_present &&
                ordered_config_ptr->dest_freq != rrc_freq));
    }
  }

  ordered_config_ptr->is_hho = is_hho;
  return SUCCESS;
}

/*============================================================================
FUNCTION: rrcllcpcie_process_dl_common_info_r8()

DESCRIPTION:
  This function updates IE "dl common info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_dl_common_info_r8
(
  OSS_UINT32 dl_common_info_present,
  rrc_DL_CommonInformation_r8 *dl_common_info_ptr,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  /* Get the DL information for all Radio Links */
  if (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
  {
  /* Initialize the L1 bitmask for the parameters in the "Downlink
  * information for all radio links" IE.  Since the IE is optional,
  * we want to make sure we don't signal L1 erroneously that we have
  * received information when we haven't.
    */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);
    
    if (dl_common_info_present)
    {
      if(get_dl_info_common_for_all_rl_r8(dl_common_info_ptr,
        &ordered_config_ptr->l1_dl_chan_parms.dl_common,
        &ordered_config_ptr->l1_dl_cctrch_parms,
        &ordered_config_ptr->l1_dl_ctfc_parms
        )
        == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
    
  } /* If next state is Cell_DCH */
  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
    &ordered_config_ptr->dl_ctfc,
    &ordered_config_ptr->rm_restrict,
    &ordered_config_ptr->l1_dl_ctfc_parms
    );
   
  return(SUCCESS);
}

/*====================================================================
FUNCTION        get_dl_info_common_for_all_rl_r8()

DESCRIPTION     This function translates the Downlink information common
                for all radio links IE into the RRC config database.

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
uecomdef_status_e_type get_dl_info_common_for_all_rl_r8
(
  /* Pointer to the DL CommonInformation IE */
  rrc_DL_CommonInformation_r8 *ie_ptr,

  /* Pointer to the desirec DL PhyChan common information structure */
  l1_dl_common_info_struct_type *dl_common,

  /* Pointer to the DL CCTRCH parameters structure */
  l1_dl_cctrch_info_struct_type *l1_dl_cctrch_parms,

  /* Pointer to the DL CTFC parameters structure */
  l1_dl_ctfc_info_struct_type *l1_dl_ctfc_info
)
{

  MSG_MED("Get DL Info Common for all RL",0,0,0);

  /* initialize the optional field bit mask */
  /* Don't reset DOFF bitmask in DCH state.*/
  dl_common->opt_parm_presence_bitmask = 
      dl_common->opt_parm_presence_bitmask & DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;

  /* Check if HS Reset is indicated */
  /* TBD Why only one value in HSRESET is specified */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
               mac_hsResetIndicatorPresent))
  {
    /* Set it in MAC params */
    ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = TRUE;
    hsdpa_msg_params.msg_params_present = TRUE;
  }
  dl_common->post_verification_valid = FALSE;
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
              postVerificationPeriodPresent))
  {
    /* Set it in MAC params */
    dl_common->post_verification_valid = TRUE;
  }

  /* Get the info common for all DL DPCH if present */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
                dl_dpchInfoCommonPresent))
  {
    if (RRC_CHECK_MSG_TYPE(ie_ptr->dl_dpchInfoCommon, 
        T_rrc_DL_CommonInformation_r8_dl_dpchInfoCommon_dl_DPCH_InfoCommon))
    {
      if(get_dl_dpch_common_info_r6(ie_ptr->dl_dpchInfoCommon.u.dl_DPCH_InfoCommon,
                                 &dl_common->dpch_common,
                                 l1_dl_cctrch_parms,
                                 l1_dl_ctfc_info
                                ) == FAILURE
        )
      {
        return FAILURE;
      }
      ordered_config_ptr->l1_dl_chan_parms.use_fdpch = FALSE;
    }
    else /* rrc_dl_FDPCH_InfoCommon_chosen */
    {
      if(get_dl_fdpch_common_info_r6(ie_ptr->dl_dpchInfoCommon.u.dl_FDPCH_InfoCommon,
        &dl_common->dpch_common
        ) == FAILURE)
      {
        return FAILURE;
      }
      else
      {
        ordered_config_ptr->l1_dl_chan_parms.use_fdpch = TRUE;
      }
    }
  } /* end if dl dpch common info present */

  if(RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
                T_rrc_DL_CommonInformation_r8_modeSpecificInfo_fdd))
  {
    if(rrcllcpcie_dl_common_mode_specific_info_r8(ie_ptr->modeSpecificInfo.u.fdd,dl_common)
      == FAILURE)
    {
      return FAILURE;
    }
  }
  /* end if common FDD */
  else
  {
    /* FDD not selected.  Error as TDD not supported */
    return FAILURE;
  }
  /* Indicate that Downlink L1 needs to be reconfigured */
  ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
 /* Although no new parameters for MAC have been received, MAC
  * still needs to be reconfigured so as to get the new CCTrCH
  * ID whenever Downlink L1 is reconfigured. This is due to the
  * interface requirements.
  */
  ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
  return SUCCESS;
}

/*============================================================================
FUNCTION: rrcllcpcie_process_dl_info_per_rl_list_r8

DESCRIPTION:
  This function updates IE "dl per rl info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_dl_info_per_rl_list_r8
(
  OSS_UINT32 dl_info_per_rl_list_present,
  rrc_DL_InformationPerRL_List_r8 *dl_info_per_rl_list_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  if (dl_info_per_rl_list_present)
  {
    if(FAILURE == get_dl_info_per_rl_r8(dl_info_per_rl_list_ptr, rcvd_state_indicator))
    {
      return (FAILURE);
    }
  }

  /* process EUL related information */
  if (FAILURE == rrcllcpcie_process_e_info_in_dl_info_per_rl_list_r8(
      dl_info_per_rl_list_present, 
      dl_info_per_rl_list_ptr,
      rcvd_state_indicator))
  {
    return(FAILURE);
  }

  return(SUCCESS);
}

/*===========================================================================
FUNCTION        get_dl_info_per_rl_r8()

DESCRIPTION     This function validates and stores Downlink Information Per
                Radio Link for reconfiguration messages.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    Ordered config is updated with the new RL info.
===========================================================================*/
uecomdef_status_e_type get_dl_info_per_rl_r8
(
  rrc_DL_InformationPerRL_List_r8 *ie_ptr,
  rrc_RRC_StateIndicator next_state
)
{
  uint8 idx = 0;
  uint8 rl_count = 0;
  uint8 cnt = 0;
  boolean is_hho;
  boolean is_inter_freq;
  boolean old_rl_seen = FALSE;
  boolean new_rl_seen = FALSE;
  boolean existing_hs_link_inactive = FALSE;
  boolean was_rl_db_empty = FALSE;

  rrc_DL_InformationPerRL_List_r8 *tmp_ie_ptr = ie_ptr;
  rrc_DL_InformationPerRL_List_r8 *temp_ptr = ie_ptr;
  uint32 n_index_ie=0;

  rrcllcoc_dl_info_per_rl_status_e_type status =
    RRCLLCOC_DL_INFO_PER_RL_IGNORED;
  rrc_freq_type rrc_freq = rrc_ccm_get_curr_camped_freq();
  rrc_state_e_type rrc_state = rrc_get_state();

  ordered_config_ptr->dest_psc_present = FALSE;

  /* Check if HSDPA link has been specified in more than one place */
  while (tmp_ie_ptr->n > n_index_ie )
  {
    if(RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo, 
                T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd))
    {
      if(tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->servingHSDSCH_RL_indicator == TRUE)
      {
        rl_count++;
        if (rl_count > 1)
        {
          WRRC_MSG0_ERROR("REL8:More than 1 HS RL specified!");
          return FAILURE;
        }

        hsdpa_msg_params.msg_params_present = TRUE;
        hsdpa_msg_params.rl_link_present = TRUE;
        hsdpa_msg_params.new_rl_link = (uint16)
        tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

      }
      else
      {
        /* Check if it was HSDPA Link Earlier */
        if ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && 
          (ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc == 
           tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode))
        {
          WRRC_MSG0_HIGH("REL8:Exisitng HSDPA Link made inactive");
          existing_hs_link_inactive = TRUE;
        }
      }
      n_index_ie++;
    }
    /*Basically, this "else" is for TDD case, not sure whether Spec allows this.*/
    else
    {
      n_index_ie++;
    }
  }
  

  if ((existing_hs_link_inactive == TRUE) && (rl_count == 0))
  {
    WRRC_MSG0_HIGH("REL8:HSDPA to be stopped");
    ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc = RRCLLC_INVALID_CPICH_SCR_CODE;
  }
  /* Reinitialize values */
  rl_count = 0;
  //tmp_ie_ptr = ie_ptr;
  n_index_ie = 0;

  /* We can say with certainty that if frequency info is included, and
  * it is different than the current frequency, then we are doing a
  * hard handover.  If this is not the case, we revisit this flag
  * later. */
  is_inter_freq = is_hho = (ordered_config_ptr->dest_freq_present &&
    ordered_config_ptr->dest_freq != rrc_freq);

  if((rrccsp_channel_locking_nv_status()) && !rrccsp_is_ue_in_true_limited_service() &&
      is_inter_freq )
  {
    WRRC_MSG0_HIGH("Failing, inter-freq HHO not supported");
    return(FAILURE);
  }
  

  if(next_state == rrc_RRC_StateIndicator_cell_DCH)
  {
  /* If DPCH Info per RL is not present within DL Info per RL, then ignore it and
  * do not change the RL Info list in OC when going from DCH->DCH.
  * When going from non-DCH->DCH, the above condition should result in a Failure.
    */
    while (tmp_ie_ptr->n > n_index_ie )
    {
      if((RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo, 
                     T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd)) &&
          (!((RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index_ie], 
                    dl_dpchInfoPresent)) &&
             ((RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index_ie].dl_dpchInfo, 
                     T_rrc_DL_InformationPerRL_r8_dl_dpchInfo_dl_DPCH_InfoPerRL))
        ||
              (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index_ie].dl_dpchInfo, 
                   T_rrc_DL_InformationPerRL_r8_dl_dpchInfo_dl_FDPCH_InfoPerRL))
        ))))
      {
        if(rrc_state == RRC_STATE_CELL_DCH)
        {
          /* Remove this check later - need to process rest of RL Info elements */
          WRRC_MSG1_HIGH("REL8:Ignoring DL Info per RL for %d,Info absent", 
            tmp_ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode);
          
          n_index_ie++;
          if (n_index_ie == tmp_ie_ptr->n )
          {
            if (cnt > 0 )
            {
              WRRC_MSG0_HIGH("REL8:One link has DL DPCH info perRL");
              break;
            }
            WRRC_MSG0_HIGH("REL8:DL DPCH Info Per RL absent");
            return(SUCCESS);
          }
          else
          {
            continue;
          }
        }
        else
        {
          WRRC_MSG0_HIGH("REL8:Failing, DPCH Info per RL not present");
          return(FAILURE);
        }
      }
      cnt++;
      n_index_ie++;
    }

    /* Restore the Pointer */
    //tmp_ie_ptr = ie_ptr;
    n_index_ie = 0;
    
    /* Did we have any radio links in our database previously? */
    was_rl_db_empty = (ordered_config_ptr->l1_dl_chan_parms.num_rl == 0);

    if(rrc_state != RRC_STATE_CELL_DCH)
    {
      /* Going from non-DCH state to CELL DCH */
      /* Always set new_rl_seen when coming to DCH from a non-DCH state.
      * That ensures the RL Info is populated after initializing.
      */
      new_rl_seen = TRUE;

      if(!is_inter_freq)
      {
        /* Also loop thru and check if the current camped on PSC is in RL Info.
         * If so, force Frequency_info to FALSE.
         */
        if(is_current_camped_psc_in_rl_info_r8(ie_ptr))
        {
          ordered_config_ptr->dest_freq_present = FALSE;
        }
        else  /* Intra freq HHO */
        {
          ordered_config_ptr->dest_freq_present = TRUE;
          ordered_config_ptr->dest_freq = rrc_freq;
          WRRC_MSG0_HIGH("REL8:Disjoint ASET, intra-f HHO FACH->DCH");
        }
      }
    }
    else       /* Going from DCH->DCH */
    {
    /* Unless we are doing an inter-frequency hard handover, we cannot
    * take a set of radio links that contains scrambling codes we
    * already have in our database as well as ones that we don't have
    * in our database. (25.331 8.6.6.3a)
      */
      if(!is_inter_freq)
      {
        while(ie_ptr->n >  n_index_ie)
        {
          if(get_dl_rl_idx_to_update( ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode,
                (RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index_ie].modeSpecificInfo,
                               T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd)),
            &ordered_config_ptr->l1_dl_chan_parms) <
            ordered_config_ptr->l1_dl_chan_parms.num_rl)
          {
            old_rl_seen = TRUE;
          }
          else
          {
            new_rl_seen = TRUE;
          }

          /* We can bail out early if we detect a mixed active set. */
          if(old_rl_seen && new_rl_seen)
          {
            WRRC_MSG0_ERROR("REL8:Mixed ASET detected, rejecting OTA!");
            return FAILURE;
          }
          n_index_ie++;
        }
      }
      else
      {
        /* New RLs always seen for Inter freq HHO */
        new_rl_seen = TRUE;
      }
    } /* DCH->DCH */
    n_index_ie = 0;
    while(ie_ptr->n >  n_index_ie)
    {
      if(rrc_state != RRC_STATE_CELL_DCH)
      {
        /* For a non-DCH to DCH transition, there is no existing RL Info */
        idx = rl_count;
      }
      else if(is_inter_freq)
      {
      /* We've found this radio link in our database, but we are
      * doing an inter-frequency hard handover, which means that
      * we are replacing the active set.  This is a case where
      * the primary scrambling code on the new frequency is the
      * same as on the old one.  We need to adjust our radio link
      * index accordingly, since we don't want to place the new
      * radio link into the database position of the old one.
        */
        idx = rl_count;
      }
      else /* DCH -> DCH AND Not Inter Freq */
      {
      /* Now look to see if this radio link is already in our
      * database.
        */
        idx =  get_dl_rl_idx_to_update( ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode,
                 (RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index_ie].modeSpecificInfo,
                            T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd)),
                 &ordered_config_ptr->l1_dl_chan_parms );
        

        if(idx == UE_MAX_RL)
        {
        /* This radio link is not in our database, which means we're
        * replacing our database with an entirely new set of radio
        * links.  We must reset the value of the database index to
        * the current radio link count.
          */
          idx = rl_count;

          is_hho = TRUE;

          hsdpa_msg_params.intra_hho_involved = 
            hsdpa_msg_params.msg_params_present = TRUE;

        } /* idx == UE_MAX_RL */
      } /* DCH -> DCH AND Not Inter Freq */

      /* Process the IE and place the info into our database. */
      status = get_dl_info_for_each_rl_r8(&ie_ptr->elem[n_index_ie],
        &ordered_config_ptr->l1_dl_chan_parms,
        idx,
        new_rl_seen);

      if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
      {
        return FAILURE;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_IGNORED)
      {
        n_index_ie++;
        continue;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS)
      {
        if(is_hho)
        {
        /* If we succeeded in processing the IE, and we are doing a
        * hard handover, we must be sure that L1 is informed by
        * sending frequency info, even if we didn't get frequency
        * info in the reconfiguration message.
          */
          if(!ordered_config_ptr->dest_freq_present)
          {
            ordered_config_ptr->dest_freq_present = TRUE;
            ordered_config_ptr->dest_freq = rrc_freq;
            WRRC_MSG0_HIGH("REL8:Disjoint ASET, intra-f HHO triggered");
          }
        }
      }

      rl_count++;
      n_index_ie++;
    }

    /* Here we check to see if "Default DPCH Offset Value" and "DPCH frame offset" respect the following
         * relation : "Default DPCH Offset Value" % 38400 = "DPCH frame offset" as per 8.6.6.14 in 25.331
         * We have to do this validation only when we enter DCH the first time or if it is a Timing Initialized HHO 
         * Checking only 0th location...no loop here. 
        */
        
    n_index_ie = 0;
    if ( (rrc_state != RRC_STATE_CELL_DCH) ||
         (is_hho && ordered_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.timing_ind == L1_TIMING_IND_INIT) )
    {
      if((RRC_CHECK_MSG_TYPE(temp_ptr->elem[n_index_ie].modeSpecificInfo, 
                      T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd))&&
         (RRC_CHECK_MSG_TYPE_IE(temp_ptr->elem[n_index_ie], 
                       dl_dpchInfoPresent)) &&
         (RRC_CHECK_MSG_TYPE(temp_ptr->elem[n_index_ie].dl_dpchInfo, 
                      T_rrc_DL_InformationPerRL_r8_dl_dpchInfo_dl_DPCH_InfoPerRL)) &&
         (RRC_CHECK_COMMON_MSG_TYPE_PTR(temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_DPCH_InfoPerRL, 
                       rrc_DL_DPCH_InfoPerRL_r7_fdd)))
      {
        if ( (ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset % 38400) !=
             (temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_DPCH_InfoPerRL->u.fdd->dpch_FrameOffset * RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR) )
        {
          WRRC_MSG2_ERROR("REL8:Validation of DOFF %d and DPCHFrameOffset %d fail!",
                    ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
                    temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_DPCH_InfoPerRL->u.fdd->dpch_FrameOffset);
          return (FAILURE);
        }
      }


      /* Verify if DEFAULT Offset Value & F-DPCH Frame Offset is respected as per 8.6.6.14 */
    if ((ordered_config_ptr->l1_dl_chan_parms.use_fdpch == TRUE) && 
      (RRC_CHECK_MSG_TYPE(temp_ptr->elem[n_index_ie].modeSpecificInfo, 
                    T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd)) &&
      (RRC_CHECK_MSG_TYPE_IE(temp_ptr->elem[n_index_ie], 
                     dl_dpchInfoPresent)) &&
      (RRC_CHECK_MSG_TYPE(temp_ptr->elem[n_index_ie].dl_dpchInfo, 
                     T_rrc_DL_InformationPerRL_r8_dl_dpchInfo_dl_FDPCH_InfoPerRL)))
    {
      
      if ((ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset % 38400) ==
                (temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset * RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR))
                  
      {
        WRRC_MSG2_MED("REL8:DOFF %d, F-DPCHFrameOffset %d", 
          ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
        temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset);
        
      }
      else if (((ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset + 256) % 38400) ==
                (temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset * RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR))
      {
        WRRC_MSG2_HIGH("REL8:DOFF %d, F-DPCHFrameOffset %d. Adding 256 in DOFF", 
          ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
        temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset);
                  
        // Add 256 to default DPCH Offset value 
        ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset += 256;
      }
      else
      {
        WRRC_MSG2_ERROR("REL8:Validation of DOFF %d and F-DPCHFrameOffset %d fail!",
                      ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
                    temp_ptr->elem[n_index_ie].dl_dpchInfo.u.dl_FDPCH_InfoPerRL->fdpch_FrameOffset);
        return (FAILURE);
      }
    }
    }

    if(is_hho || was_rl_db_empty)
    {
      /* We've just replaced the contents of our radio link database, or
    * added radio links when we had none before, so we must update the
    * count of the radio links contained therein. */
      ordered_config_ptr->l1_dl_chan_parms.num_rl = rl_count;

      /* Clear out old scrambling codes. */
      while(rl_count < UE_MAX_RL)
      {
        ordered_config_ptr->
          l1_dl_chan_parms.dl_per_rl[rl_count++].pri_cpich_scr_code =
          RRCLLC_INVALID_CPICH_SCR_CODE;
      }
    }
  }
  else /* All states other than Cell_DCH */
  {
    if(ie_ptr != NULL)
    {
      if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[n_index_ie].modeSpecificInfo,
                      T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd))
      {
      /* There should be not more than 1 PSCs in the list when going
      * to FACH since the C-RNTI can not be tied up with multiple
      * PSCs. Just remember the 1st PSC.
        */
        ordered_config_ptr->dest_psc =
          (rrc_scr_code_type)ie_ptr->elem[n_index_ie].modeSpecificInfo.u.fdd->
          primaryCPICH_Info.primaryScramblingCode;
        ordered_config_ptr->dest_psc_present = TRUE;
      }
    }
  }

  return rrcllcpcie_check_for_duplicate_rl_entry();

} /* end get_dl_info_per_rl_r8() */

/*===========================================================================
FUNCTION        is_current_camped_psc_in_rl_info_r8()

DESCRIPTION     This function determines whether the current camped psc is
                included in the dl-per-rl-list or not.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    Ordered config is updated with the new RL info.
===========================================================================*/
boolean is_current_camped_psc_in_rl_info_r8(rrc_DL_InformationPerRL_List_r8 *ie_ptr)
{
  rrc_scr_code_type current_psc;

  current_psc = rrc_ccm_get_curr_camped_psc();

  if(ie_ptr->n != 0)
  {
    /*Removed the DPCH presence check to allow detection of semless reconfiguration, this covers 
     scenarios like FACH to DCH(R99), FACH to DCH(FDPCH/EUL), R99<->EUL reconfig in DCH. 
     Introduced during HSRACH to DCH seamless reconfig optimization where PCCPCH can be dropped
     Impact:
     1. new_freq is filled in L1 cmd pointer for non-seamless reconfig cases
     2. With the new change we may not send add/drop of DPCH(unlike legacy), if DPCH to FDPCH reconfig happens
        Verified with L1 for this case and they are OK to not send add/drop for such reconfig 
    */
    if(RRC_CHECK_MSG_TYPE(ie_ptr->elem[0].modeSpecificInfo, 
                    T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd))
    {
      if(current_psc == (rrc_scr_code_type)ie_ptr->elem[0].modeSpecificInfo.u.fdd->
                                           primaryCPICH_Info.primaryScramblingCode)
      {
        return (TRUE);
      }
    }
  }

  return(FALSE);

}


/*====================================================================
FUNCTION        get_dl_info_for_each_rl_r8()

DESCRIPTION     This function translates the Downlink information for
                each radio link IE to the RRC config database

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
rrcllcoc_dl_info_per_rl_status_e_type get_dl_info_for_each_rl_r8
(
  rrc_DL_InformationPerRL_r8 *ie_ptr,

  l1_dl_phychan_db_struct_type *dl_phychan,

  uint8 rl_idx,

  boolean is_new_rl
)
{
  l1_dl_info_per_rl_struct_type *rl_info;

  if (rl_idx >= UE_MAX_RL)
  {
    /* radio link index too large, bail */
    WRRC_MSG1_ERROR("Too many Radio Links %d", rl_idx);
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }

  MSG_MED("RRCHS:Get Dl Info per RL",0,0,0);
  if (RRC_CHECK_MSG_TYPE(ie_ptr->modeSpecificInfo,
              T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd))
  {
    /* First check if the DL DPCH Info per RL is included. If not,
    * this is NOT a valid Radio link - ignore it.
    */
    if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
                dl_dpchInfoPresent))
    {
    /* snap a local pointer to the proper radio link element in the
      RRC config page */
      rl_info = &dl_phychan->dl_per_rl[rl_idx];

      /* Get the Primary CPICH scrambling code */
      rl_info->pri_cpich_scr_code =
        (uint16) ie_ptr->modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

        /*If Cell_id is present for this RL, store it in cell_id_per_rl */      
        if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                    cell_idPresent))
        {
          cell_id_per_rl[rl_idx] = (uint32) rrc_translate_cell_id(&ie_ptr->cell_id);
        } 

      /* Get the DL DPCH info for this radio link */
      MSG_MED("Get DL DPCH Info for RL %d", (rl_idx + 1), 0, 0);

      if(RRC_CHECK_MSG_TYPE(ie_ptr->dl_dpchInfo, 
                  T_rrc_DL_InformationPerRL_r8_dl_dpchInfo_dl_DPCH_InfoPerRL))
      {
        if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch == TRUE)
        {
           WRRC_MSG0_ERROR("FDPCH common params mixed with DPCH per RL"); 
          return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
        }
        if (get_dl_dpch_info_for_each_rl_r7(ie_ptr->dl_dpchInfo.u.dl_DPCH_InfoPerRL,
          dl_phychan, rl_idx,
          is_new_rl) == FAILURE)
        {
          return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
        }
      }
      else
      {
        if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch == FALSE)
        {
           WRRC_MSG0_ERROR("DPCH common params mixed with FDPCH per RL"); 
          return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
        }
        if (get_dl_fdpch_info_for_each_rl_r7(ie_ptr->dl_dpchInfo.u.dl_FDPCH_InfoPerRL,
          dl_phychan, rl_idx,
          is_new_rl
#ifdef FEATURE_WCDMA_DC_HSUPA
          , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ) == FAILURE)
        {
          return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
        }

      }

      /* if we made it here we must be ok */
      /* Indicate that Downlink L1 needs to be configured */
      ordered_config_ptr->reconfig_needed.downlink_l1 = TRUE;
      /* Although no new parameters for MAC have been received, MAC
      * still needs to be reconfigured so as to get the new CCTrCH
      * ID whenever Downlink L1 is reconfigured. This is due to the
      * interface requirements.
      */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;
      return RRCLLCOC_DL_INFO_PER_RL_SUCCESS;
    }  /* DL DPCH Info is present */
    else
    {
      /* DL DPCH Info per RL is NOT present - ignore this IE */
      return RRCLLCOC_DL_INFO_PER_RL_IGNORED;
    }
  }
  else
  {
    /* No FDD info.  We don't support TDD so return indicating an error */
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }
} /* get_dl_info_for_each_rl_r5() */


/*===========================================================================
FUNCTION        get_rl_add_info_r8()

DESCRIPTION     This function translates radio link addition information from
                a radio link addition list into the RRC config database. This
                function is only called from an Active Set Update Message

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    The RRC config database as pointed to by the input parameters
                will be updated.
===========================================================================*/
uecomdef_status_e_type get_rl_add_info_r8
(
  rrc_RL_AdditionInformation_r8 *ie_ptr,
  l1_dl_phychan_db_struct_type *dl_phychan,
  boolean *duplicate_add_attempted
)
{
  /* local loop variable */
  uint8 ix;

  *duplicate_add_attempted = FALSE;

  /* Check to determine if this is a duplicate radio link.  If so, return
     SUCCESS, since that's not an error and there's no more work to be done. */
  for(ix = 0; ix < ordered_config_ptr->l1_dl_chan_parms.num_rl; ix++)
  {
    if(dl_phychan->dl_per_rl[ix].pri_cpich_scr_code ==
       ie_ptr->primaryCPICH_Info.primaryScramblingCode)
    {
      /* we may want to add the processing of the IEs instead of ignoring RL info */
      WRRC_MSG1_ERROR("REL8:ASU trying to add PSC %d -already part of AS - ignoring RL info", 
        ie_ptr->primaryCPICH_Info.primaryScramblingCode);
      *duplicate_add_attempted = TRUE;
      return SUCCESS;
    }
  }

  /* look for the first available radio link slot that is available */
  for(ix = 0; ix < UE_MAX_RL; ix++)
  {
    /* look in the ordered_config database for this radio link */
    if(dl_phychan->dl_per_rl[ix].pri_cpich_scr_code == RRCLLC_INVALID_CPICH_SCR_CODE)
    {
      /* Get the Primary Scrambling Code */
      if(ie_ptr->primaryCPICH_Info.primaryScramblingCode <= RRCLLC_MAX_CPICH_SCR_CODE)
      {
        /*If Cell_id is present for this RL, store it in cell_id_per_rl */      
        if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                    cell_IdPresent))
        {
          cell_id_per_rl[ix] = (uint32) rrc_translate_cell_id(&ie_ptr->cell_Id);
        } 
        dl_phychan->dl_per_rl[ix].pri_cpich_scr_code = (uint16)ie_ptr->primaryCPICH_Info.primaryScramblingCode;
      }
      else
      {
        WRRC_MSG1_ERROR("REL8:PRI SCR CODE %d is out of range", ie_ptr->primaryCPICH_Info.primaryScramblingCode);
        return FAILURE;
      }
      
      /* This is the first open RL slot, so place the info here */
      if (RRC_CHECK_MSG_TYPE(ie_ptr->dl_dpchInfo, 
                    T_rrc_RL_AdditionInformation_r8_dl_dpchInfo_dl_DPCH_InfoPerRL))
      {
        if(get_dl_dpch_info_for_each_rl_r5(ie_ptr->dl_dpchInfo.u.dl_DPCH_InfoPerRL,
          dl_phychan, ix, TRUE) == FAILURE)
        {
        /* bad status from get_dl_dpch_info_for_each_rl.  Return FALSE
          indicating an error */
          WRRC_MSG0_HIGH("REL8:get_dl_dpch_info_for_each_rl_r5() failed!");
          return FAILURE;
        }
      }
      else
      {
        if(get_dl_fdpch_info_for_each_rl_r7(ie_ptr->dl_dpchInfo.u.dl_FDPCH_InfoPerRL,
          dl_phychan, ix, TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
          , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ))
        {
        /* bad status from get_dl_dpch_info_for_each_rl.  Return FALSE
          indicating an error */
          WRRC_MSG0_HIGH("REL8:get_dl_fdpch_info_for_each_rl_r7() failed");
          return FAILURE;
        }
      }
      /* Ignore the SCCPCH/FACH and TFCI combining info for now */
      /* No need to continue */
      break;
    } /* end RL match if */
  } /* end looking for open RL slot */
  
  /* everything is good if here */
  return SUCCESS;

}

/*RRC_GKG: See whether the following function should be kept under HSUPA feature*/
/*============================================================================
FUNCTION: rrcllcpcie_process_e_info_in_dl_info_per_rl_list_r8()

DESCRIPTION:
  This function updates IE "dl per rl info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_e_info_in_dl_info_per_rl_list_r8
(
  OSS_UINT32 dl_info_per_rl_list_present,
  rrc_DL_InformationPerRL_List_r8 *dl_info_per_rl_list_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  uint32 e_rl_idx = 0;
   rrc_E_RGCH_Information * e_rgch_ptr= NULL;
    rrc_E_HICH_Information * e_hich_info_ptr =NULL;
  /* Look into this IE only if next UE state is DCH */
  if (dl_info_per_rl_list_present && 
      (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
     )
  {
    uint32 num_serv_e_dch_rl_true = 0;
    uint32 psc = 0;
    boolean is_e_dl_info_present = FALSE;
    rrc_DL_InformationPerRL_List_r8 *tmp_ie_ptr = dl_info_per_rl_list_ptr;
    boolean is_need_to_honor_e_rl_rel_ind = TRUE;
    uint32 n_value=0, n_index=0;

    /* Firt time into DCH is also considered a HHO.  So only populate the release list of 
     * EDCH in the case of DCH->DCH only
     */
    if (ordered_config_ptr->is_hho && (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      /* if its inter-freq handover then clear any stored E-Channel information.
         Also indicate layer1 about the release psc's */
      rrcllcpcie_release_and_clear_all_e_dch_active_set_rl(
#ifdef FEATURE_WCDMA_DC_HSUPA
      FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
      );
      is_need_to_honor_e_rl_rel_ind = FALSE;
    }

    /* loop through all the rls informations to extract e-dch related info */
    n_value = tmp_ie_ptr->n;
    
    while (n_value != 0)
    {
      if (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo, 
                     T_rrc_DL_InformationPerRL_r8_modeSpecificInfo_fdd))
      {
        psc = tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->primaryCPICH_Info.primaryScramblingCode;

        /* check if any E-Channel related info is present in this RL Info */
        if ((RRC_CHECK_MSG_TYPE_IE_PTR(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd, 
                     e_HICH_InfoPresent)) ||
            (RRC_CHECK_MSG_TYPE_IE_PTR(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd, 
                     e_RGCH_InfoPresent)) ||
            (RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index], 
                   e_AGCH_InformationPresent))
           )
        {
          /* if we are inside this if check then it means that RRC needs to indicate
             to L1 that some of the parameters in DL has changed */
          is_e_dl_info_present = TRUE;

          if((RRC_CHECK_MSG_TYPE_IE_PTR(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd,
                                  e_HICH_InfoPresent))&&
              (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd->e_HICH_Info,
                              T_rrc_DL_InformationPerRL_r8_e_HICH_Info_e_HICH_Information)))
          {
            e_hich_info_ptr=tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd->e_HICH_Info.u.e_HICH_Information;
          }
          else
          {
            e_hich_info_ptr=NULL;
          }

          if (FAILURE == rrcllcpcie_process_e_hich_info(
            RRC_CHECK_MSG_TYPE_IE_PTR(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd, 
                    e_HICH_InfoPresent), 
            e_hich_info_ptr,
            psc,
            is_need_to_honor_e_rl_rel_ind
#ifdef FEATURE_WCDMA_DC_HSUPA
            , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
            ))
          {
            return(FAILURE);
          }
          if((RRC_CHECK_MSG_TYPE_IE_PTR(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd,
                               e_RGCH_InfoPresent)) && 
             (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd->e_RGCH_Info,
         T_rrc_DL_InformationPerRL_r8_e_RGCH_Info_e_RGCH_Information))
            )
          {
            e_rgch_ptr = tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd->e_RGCH_Info.u.e_RGCH_Information;
          }
          else
          {
            /* This means that the E-RGCH Info IE is not present*/
            e_rgch_ptr = NULL;
          }

          if (FAILURE == rrcllcpcie_process_e_rgch_info(
            RRC_CHECK_MSG_TYPE_IE_PTR(tmp_ie_ptr->elem[n_index].modeSpecificInfo2.u.fdd, 
                      e_RGCH_InfoPresent), 
            e_rgch_ptr,
            psc,
            is_need_to_honor_e_rl_rel_ind
#ifdef FEATURE_WCDMA_DC_HSUPA
          ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
           ))
          {
            return(FAILURE);
          }
            
          if (FAILURE == rrcllcpcie_process_e_agch_info_r8(
            RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index], 
                       e_AGCH_InformationPresent), 
            &tmp_ie_ptr->elem[n_index].e_AGCH_Information,
            psc))
          {
            return(FAILURE);
          }
        }/* if any E-info IE is present */

        if (TRUE == tmp_ie_ptr->elem[n_index].modeSpecificInfo.u.fdd->servingEDCH_RL_indicator)
        {
          if (FAILURE == rrcllcpcie_process_serving_e_dch_rl_indicator(
            TRUE,
            psc))
          {
            return(FAILURE);
          }
          num_serv_e_dch_rl_true++;
        }        
        else
        {
          e_rl_idx = ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx;
          /* If the current serving RL becomes non-serving, need to reset the flag*/
          if((e_rl_idx < L1_MAX_EDCH_RL) &&
             (ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[e_rl_idx].e_rl_psc == psc))
          {
            WRRC_MSG1_HIGH("RRCEUL: Serving cell ind for %d set to false",psc);
            ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx = L1_MAX_EDCH_RL;
          }
        }
      }/* mode-FDD */
      
      n_value--;
      n_index++;
    }/* while */

    if (num_serv_e_dch_rl_true > 1)
    {
      WRRC_MSG0_ERROR("Serving E-DCH RL set to TRUE in more than one RL");
      return(FAILURE);
    }

    if (FAILURE == rrcllcpcie_validate_hich_rgch_info(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
      , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
      ))
    {
      return(FAILURE);
    }

    /* update the l1_e_req_mask */
    rrcllc_update_l1_e_req_mask_for_e_dl_info(is_e_dl_info_present);
  }/* dl_info_per_rl_list_present */
  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_process_e_agch_info_r8()

DESCRIPTION:
  This function processes e-AGCH information and updates the information
  in a given e_rl_index
      
DEPENDENCIES:
  This function needs to be called only after calling function to process E-HICH info.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_e_agch_info_r8
(
  OSS_UINT32 e_agch_info_present,
  rrc_E_AGCH_Information_r8 *e_agch_info_ptr,
  uint32 psc
)
{
  uint32 e_rl_idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_e_info.e_dl_info;

  if ((e_agch_info_present) && 
      (RRC_CHECK_MSG_TYPE(e_agch_info_ptr->modeSpecific, 
                  T_rrc_E_AGCH_Information_r8_modeSpecific_fdd )))
  {
    e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

    if ((e_rl_idx >= L1_MAX_EDCH_RL) || (e_rl_idx == e_dl_info_ptr->num_e_dl_rl_add_recfg_info))
    {
      WRRC_MSG2_ERROR("RRCEUL: psc:%d(idx: %d) not found in E-DCH RL database i.e. E-AGCH without E-HICH Info ",
        psc, e_rl_idx);
      return(FAILURE);
    }

    /* store RGCH info only if E-HICH info is already stored */
    if (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
      L1_E_HICH_INFO_PRESENT)
    {

      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_agch_info.ch_code = 
        e_agch_info_ptr->modeSpecific.u.fdd->e_AGCH_ChannelisationCode;
    }
    else
    {
      /* as per our current understanding NW should not provide E-AGCH info
         unless E-HICH is provided in config message or already stored in UE */
      WRRC_MSG0_ERROR("RRCEUL: NW trying to provide E-AGCH info without E-HICH Info");
      return(FAILURE);
    }

    if (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
      L1_E_AGCH_INFO_PRESENT)
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |=
        L1_E_AGCH_INFO_RECFG;
    }
    else
    {
      e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |=
        L1_E_AGCH_INFO_ADD|L1_E_AGCH_INFO_PRESENT;
    }
  }

  return(SUCCESS);
}

/*============================================================================
FUNCTION: rrcllcpcie_process_ul_e_dch_information_r8()

DESCRIPTION:
  This function updates IE "ul e dch information" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_ul_e_dch_information_r8
(
  OSS_UINT32 e_dch_info_present,
  rrc_UL_EDCH_Information_r8 *e_dch_info_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  uecomdef_status_e_type status = SUCCESS;

  /* Look into this IE only if next UE state is DCH */
  if (e_dch_info_present && 
      (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
     )
  {
    if ((RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr, 
               mac_es_e_resetIndicatorPresent)) &&
        (rrc_UL_EDCH_Information_r8_mac_es_e_resetIndicator_true == e_dch_info_ptr->mac_es_e_resetIndicator))
    {
      ordered_config_ptr->mac_e_reset_indicator = TRUE;
    }
    else
    {
      ordered_config_ptr->mac_e_reset_indicator = FALSE;
    }

    if(RRC_CHECK_MSG_TYPE(e_dch_info_ptr->modeSpecificInfo, 
                  T_rrc_UL_EDCH_Information_r8_modeSpecificInfo_fdd))
      {
       if(FAILURE == rrcllcpcie_process_e_dpcch_info_r7(
           RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd,
             e_DPCCH_InfoPresent),
           &e_dch_info_ptr->modeSpecificInfo.u.fdd->e_DPCCH_Info))
       {
         return(FAILURE);
       }
  
      if (FAILURE == rrcllcpcie_process_e_dpdch_info_r8(
          RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd, 
                  e_DPDCH_InfoPresent),
          &e_dch_info_ptr->modeSpecificInfo.u.fdd->e_DPDCH_Info))
      {
        return(FAILURE);
      }
  
      rrcllcpcie_process_sched_tx_config(
        RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd, 
                   schedulingTransmConfigurationPresent),
        &e_dch_info_ptr->modeSpecificInfo.u.fdd->schedulingTransmConfiguration,
        &ordered_config_ptr->l1_e_info.e_dl_info,
        &ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info
        );   
#ifdef FEATURE_WCDMA_16_QAM
       status = rrcllcpcie_process_16qam_params(RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd,ul_16QAM_SettingsPresent), 
                                       &e_dch_info_ptr->modeSpecificInfo.u.fdd->ul_16QAM_Settings);
       rrcllcpcie_modify_e_tfci_table();
#else
      if(RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd, 
                   ul_16QAM_SettingsPresent))
      {
        WRRC_MSG0_ERROR("RRCHSPA+: UL 16QAM not supported ");
      }
#endif  
    }
  }
  return(status);
}


/*============================================================================
FUNCTION: rrcllcpcie_process_dl_hspdsch_info_and_update_hsdpa_msg_params_r8()

DESCRIPTION:
  This function updates IE "dl hspdsch info " in ordered config and update
  hsdpa_msg_param variable
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r8
(
  OSS_UINT32 dl_hspdsch_info_present,
  rrc_DL_HSPDSCH_Information_r8 *dl_hspdsch_info_ptr,
  /* is inter freq handover involved */
  OSS_UINT32 is_ifhho_involved,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  /*We need to process HSDPA related IE DL_HSPDSCH_Information only in Cell_DCH state.*/
  if (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
  {
    /* If InterF HO is happening, then set the flags in hsdpa_msg_params appropriately.*/
    if (is_ifhho_involved)
    {
      WRRC_MSG0_HIGH("REL8:InterFreq HO is happening thru OTA.");
      hsdpa_msg_params.ifhho_involved = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }

    /*If IE rrc_DL_HSPDSCH_Information_r8 is present.*/
    if(dl_hspdsch_info_present)
    {
      hsdpa_msg_params.msg_params_present = TRUE;
      hsdpa_msg_params.hspdsch_info_present = TRUE;

      /*Process the 64 QAM IE if present.*/    
      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = FALSE;

      if(RRC_CHECK_MSG_TYPE(dl_hspdsch_info_ptr->modeSpecificInfo, 
                  T_rrc_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd))
      {
        if(RRC_CHECK_MSG_TYPE_IE_PTR(dl_hspdsch_info_ptr->modeSpecificInfo.u.fdd, 
                   dl_64QAM_ConfiguredPresent))
        {
          /*If HSDPA CAT of the UE supports 64 QAM then set it in L1 HSDPA Info.*/
          if(CHECK_WCDMA_OPTIONAL_FEATURE_64QAM_SUPPORTED)
          {
            ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = TRUE;
            WRRC_MSG0_HIGH("REL8:64QAM is being started/continued");
          }
          else
          {
            WRRC_MSG1_HIGH("REL8:64QAM not supported with NV HSDPA-CAT %d :(",nv_hsdpa_category);
            return FAILURE;
          }
        }
      }
      else if(RRC_CHECK_MSG_TYPE(dl_hspdsch_info_ptr->modeSpecificInfo, 
                 T_rrc_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd))
      {
         return FAILURE;
      }

      /*If 64 QAM status is being changed by the OTA, then set the flag hsdsch_info_present in hsdpa_msg_params*/
      if(current_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured != 
        ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured)
      {
        hsdpa_msg_params.hsdsch_info_present = TRUE;

        WRRC_MSG2_HIGH("REL8:Set HSDSCH bitmask for 64QAM. Before %d, current %d (0:Not present/1:Present)",
            current_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured ,
             ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured);
      }

    }

    if(rrcllc_set_macehs_or_machs_and_check_if_coexist()== TRUE)
    {
      WRRC_MSG2_HIGH("REL8:MAC-ehs %d and MAC-hs %d cant co-exist ",
                          ordered_config_ptr->mac_dl_parms.num_mac_ehs_queue, 
                          ordered_config_ptr->mac_dl_parms.num_dflow);
      return FAILURE;
    }
    rrcllc_set_machs_ehs_transition();

    /* Set HSDPA Action & Physical Channel Parameters associated with it */
    if ((rrcllc_determine_hsdpa_action_r8(dl_hspdsch_info_ptr) == SUCCESS)
#ifdef FEATURE_MAC_I
         && 
        (rrcllc_is_maci_compatible_with_hsdpa() == SUCCESS)
#endif
       )
    {
      rrc_set_hsdpa_action_in_machs_macehs();

      if(((ordered_config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_HS_TO_EHS )
        ||(ordered_config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_EHS_TO_HS ))
        && (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE))
      {
        WRRC_MSG2_ERROR("REL8:MAC-hs <-> MAC-ehs transition type %d, But MAC-reset ind is %d!",
              ordered_config_ptr->mac_dl_parms.mac_hs_transition_type,
              ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);
        return FAILURE;
      }
#ifdef FEATURE_WCDMA_HS_FACH
     /*for EFACH to MAC-HS transition*/
      if((ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS) &&
         (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE)&&
         (current_config_ptr->hs_status_in_e_fach == TRUE))
      {
         /* The IE mac_hs_reset_indicator is not needed in the HANDOVER TO UTRAN
          COMMAND and the RRC CONNECTION SETUP messages. Otherwise, it is optional.*/
         if (RRC_STATE_CONNECTING != rrc_get_state())
         {          
        WRRC_MSG2_ERROR("MAC-EHS ->  MAC-HS transition %d, and Mac Reset Ind not set %d, reject config",
                ordered_config_ptr->mac_dl_parms.mac_hs_transition_type,
                ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);
        return FAILURE;
      }
      }
#endif

      /*Validation check for 64 QAM and HSDPA type. 64 QAM is supported for MAC-ehs only right now.*/
      if((ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE) &&
        ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
        (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
        ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
        (rrc_get_hsdpa_status() == HSDPA_ACTIVE))))
      {
        if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
        {
          WRRC_MSG0_ERROR("REL8:64QAM cannot be started on MAC-HS.");
          return FAILURE;
        }
      }

     WRRC_MSG5_MED("HSDPA :Action %d set in MAC and HS+CM enabled %d CM status L1/RRC/OTA %d %d %d",
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action,hsdpa_cm_enabled,
      l1_cm_query_compressed_mode_active(),
               rrcllc_is_cm_active(ordered_config_ptr),cm_status_from_ota_msg);


      /* Check if network is trying to activate CM with HSDPA */
      if (hsdpa_cm_enabled == FALSE)
      {
        /* Check if network is trying to activate CM with HSDPA */
        if ((((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
            (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
            ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
            (rrc_get_hsdpa_status() == HSDPA_ACTIVE))) && 
            (rrcllc_is_cm_active(ordered_config_ptr) == TRUE)) ||

            /*At L1 CM is not active but OTA is trying to activate CM with HSDPA start.*/  
            ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) &&
            (l1_cm_query_compressed_mode_active() == FALSE) &&
            (cm_status_from_ota_msg == ACTIVATE_CM)) ||

            /*At L1 CM is active but OTA is not doing giving any CM and trying to start HSDPA.*/ 
            ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) &&
            (l1_cm_query_compressed_mode_active() == TRUE) &&
            (cm_status_from_ota_msg == RRC_CM_NONE)))
        {
          WRRC_MSG0_HIGH("REL8:CM with HSDPA Active!");
          return FAILURE;
        }
      }
    }
    else
    {
      WRRC_MSG0_ERROR("REL8:Error in determining HSDPA action!");  
      return FAILURE;
    }

    /*By now HSDPA action and type of HSDPA (hs or ehs) should have been decided*/
    if((RRC_CHECK_MSG_TYPE(dl_hspdsch_info_ptr->modeSpecificInfo, 
        T_rrc_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd))
        && (RRC_CHECK_MSG_TYPE_IE_PTR(dl_hspdsch_info_ptr->modeSpecificInfo.u.fdd, 
             hs_DSCH_TBSizeTablePresent)))
    {
      rrcllcpcie_update_hs_tfri_table_type(TRUE);
    }
    else
    {
         /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
         
      if((dl_hspdsch_info_present)
         || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
         || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
        )
      {
        rrcllcpcie_update_hs_tfri_table_type(FALSE);
      }
    }
  } /*only if the next state is Cell_DCH*/

  return(SUCCESS);
}


/*============================================================================
FUNCTION: rrcllcpcie_dl_common_mode_specific_info_r8()

DESCRIPTION:
 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS or FAILURE

SIDE EFFECTS:
=============================================================================*/

uecomdef_status_e_type
rrcllcpcie_dl_common_mode_specific_info_r8
(
  struct rrc_DL_CommonInformation_r8_fdd * ie_ptr,  
  l1_dl_common_info_struct_type *dl_common
)
{
  struct rrc_TGP_SequenceList_r8 * local_tgp_SequenceList_ptr = NULL;
   rrc_state_e_type rrc_state = rrc_get_state();
  boolean compressed_mode_config_ignore = FALSE;
  uint32 n_value=0, n_index=0;
  
  /* Get the DPCH compressed mode info. To be completed */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr, 
                  dpch_CompressedModeInfoPresent))
    {
      if ((ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
        (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH) &&
        (transition_config.toc_ptr->cm_info.tgp_seq_info_count == 0) &&
        (ie_ptr->dpch_CompressedModeInfo.tgp_SequenceList.n != 0)
        )
      {
        /* Check if network tries to deactivate without specifying the config parameters */
        local_tgp_SequenceList_ptr =
          &(ie_ptr->dpch_CompressedModeInfo.tgp_SequenceList);

        n_value = local_tgp_SequenceList_ptr->n;

        while (n_value != 0)
        {
          if ((RRC_CHECK_MSG_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_Status, 
                        T_rrc_TGP_Sequence_r8_tgps_Status_activate)) &&
              (!(RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index], 
                        tgps_ConfigurationParamsPresent))))
          {
            /* Set forcibly the bit mask for CM to 0. No need to check others */
            compressed_mode_config_ignore = TRUE;
            break;
          }
          else
          {
            n_value--;
            n_index++;
          }
        }
      }

      if (compressed_mode_config_ignore == TRUE)
      {
        WRRC_MSG0_HIGH("Deactivate TGPSI.CM config ignored");
      }
      else
      {
        if (set_compressed_mode_info_r8(
          &ie_ptr->dpch_CompressedModeInfo) == FAILURE)
        {
          return FAILURE;
        }

        dl_common->opt_parm_presence_bitmask |=
          DL_COMMON_INFO_COMPRESSED_MODE_INFO_PRESENT;
      }
    }

    /* Get the TX Diversity Mode info. */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,  
               tx_DiversityModePresent))
    {
      if(get_tx_diversity_mode_info(ie_ptr->tx_DiversityMode,
                                    dl_common) == FAILURE)
      {
        return FAILURE;
      }
    } /* end Tx Diversity Prescence */

      /* Get the default DPCH offset if present */
    if (RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr, 
                defaultDPCH_OffsetValuePresent))
    {
      dl_common->default_dpch_offset =
        (uint16) ie_ptr->defaultDPCH_OffsetValue;

      if(dl_common->default_dpch_offset > RRCLLC_ASN1_DOFF_MAX_VAL)
      {
        WRRC_MSG0_ERROR("Doff ASN1 value out of range");
        return(FAILURE);
      }
      /* Multiply the ASN1 value with multiplication factor before sending
       * it to L1.
       */
      dl_common->default_dpch_offset  *= RRCLLC_DOFF_MULTIPLICATION_FACTOR;
      dl_common->opt_parm_presence_bitmask |=
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    }
    else
    {
      rrc_state = rrc_get_state();
      if(rrc_state != RRC_STATE_CELL_DCH)
      {
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          /* This is an error case since we are going to Cell_DCH from
           * another state and Doff is not signalled
           */
          WRRC_MSG2_ERROR("Doff absent RRC state curr%d next%d",
              rrc_state, ordered_config_ptr->rrc_state_indicator);
          return(FAILURE);
        }
      }
      /*RRC_GKG: Commenting out the following check because it will not
      be executed ever. Reason - we are setting check_hho_cfn_handling in
      case of FACH/Conn->DCH only. And if that is the case, then the above check
      will itself return Failure.*/  

//      if(dl_common->dpch_common.timing_ind == L1_TIMING_IND_INIT &&
//          check_hho_cfn_handling)
//      {
        /* This is an error case since we are doing a timing initialized
         * hard handover and Doff is not signalled
         */
//        WRRC_MSG0_ERROR("Doff absent during timing-init HHO");
//        return FAILURE;
//      }
    }  /* Doff is absent */

    /* We're done with this flag now. */
    check_hho_cfn_handling = FALSE;

    /* SSDT information if present NOT supported in this version of spec */
    return SUCCESS;
  }


/*============================================================================
FUNCTION: rrcllcpcie_process_e_dpdch_info_r8()

DESCRIPTION:
  This function updates IE "dl per rl info" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_e_dpdch_info_r8
(
  OSS_UINT32 e_dpdch_info_present,
  rrc_E_DPDCH_Info_r8 *e_dpdch_info_ptr
)
{
  if (e_dpdch_info_present)
  {
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_tfci_table_idx = 
      e_dpdch_info_ptr->e_TFCI_TableIndex;

    ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_table_index = 
      e_dpdch_info_ptr->e_TFCI_TableIndex;    

    if (FAILURE == rrcllcpcie_convert_asn1_e_dch_max_ch_codes(
      e_dpdch_info_ptr->maxChannelisationCodes,
      &ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info))
    {
      return(FAILURE);
    }

    /* multiply received value by 4 - as per rrc-l1 interface requirements */
    ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_dpdch_pl_non_max = 
      e_dpdch_info_ptr->pl_NonMax << 2;

    if (FAILURE == rrcllcpcie_process_reference_e_tfcis_r7(
        &e_dpdch_info_ptr->reference_E_TFCIs,
        &ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info))
    {
      return(FAILURE);
    }

    if (FAILURE == rrcllcpcie_process_sched_info_config(
        &e_dpdch_info_ptr->schedulingInfoConfiguration,
        &ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info))
    {
      return(FAILURE);
    }

    if (RRC_CHECK_MSG_TYPE_IE_PTR(e_dpdch_info_ptr, 
                 e_DCH_MinimumSet_E_TFCIPresent))
    {
      ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_min_set =
        e_dpdch_info_ptr->e_DCH_MinimumSet_E_TFCI;
    }
    else
    {
      ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_min_set = 
        MAC_E_TFCI_MIN_SET_NOT_PRESENT;
    }

    /* reset the threshold because its a MD IE */
    ordered_config_ptr->l1_e_info.e_dl_info.grant_config.three_index_step_threshold = 
      L1_SG_STEP_THRESHOLD_NOT_PRESENT;
    ordered_config_ptr->l1_e_info.e_dl_info.grant_config.two_index_step_threshold = 
      L1_SG_STEP_THRESHOLD_NOT_PRESENT;
    if (FAILURE == rrcllcpcie_process_two_and_three_step_threshold_info(
        RRC_CHECK_MSG_TYPE_IE_PTR(e_dpdch_info_ptr, 
                  threeIndexStepThresholdPresent),
        e_dpdch_info_ptr->threeIndexStepThreshold,
        RRC_CHECK_MSG_TYPE_IE_PTR(e_dpdch_info_ptr, 
                 twoIndexStepThresholdPresent),
        e_dpdch_info_ptr->twoIndexStepThreshold)
       )
    {
      return(FAILURE);
    }


    //Code for processing Release-8 minimum Beta_Ed
    if (RRC_CHECK_MSG_TYPE_IE_PTR(e_dpdch_info_ptr,minReduced_E_DPDCH_GainFactorPresent))
    {
      ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.min_beta_ed =
      rrcllcpcie_convert_asn1_minreduced_e_dpdch_gainfactor(
      e_dpdch_info_ptr->minReduced_E_DPDCH_GainFactor);
    }
    else
    {
       ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.min_beta_ed = L1_E_MIN_BED_08; /* 8/15 default */
    }

    /* set bit-mask to indicate L1 that UL info is received */
    rrcllc_update_l1_e_req_mask_for_e_ul_info(TRUE);    
    rrcllc_update_mac_eul_action(TRUE);
    
  }

  return(SUCCESS);
}


#ifdef FEATURE_WCDMA_MIMO
/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_r8()

DESCRIPTION:
  This function updates IE "Mimo Params" in ordered config for R8 OTAs.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type    rrcllcpcie_process_mimo_params_r8
(
  rrc_MIMO_Parameters_r8 * mimo_params,
  rrc_RRC_StateIndicator rrc_state,
  OSS_UINT32 mimo_params_present_ota
)
{
  hsdpa_action_enum_type hs_action =rrc_get_hsdpa_action();
  boolean mimo_reconfig = FALSE;

  /*Make sure that HSDPA category supports MIMO and (either HSDPA is being started or reconfig) */
  if((CHECK_WCDMA_OPTIONAL_FEATURE_MIMO_SUPPORTED) && ((hs_action == HSDPA_START) ||
        ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && (hs_action != HSDPA_STOP))))
  {
    ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
    if( mimo_params_present_ota )
    {
      if(RRC_CHECK_MSG_TYPE(mimo_params->modeSpecificInfo, 
                   T_rrc_MIMO_Parameters_r8_modeSpecificInfo_fdd))
      {
        if(RRC_CHECK_MSG_TYPE_IE_PTR(mimo_params->modeSpecificInfo.u.fdd, 
                   mimoN_M_RatioPresent))
        {
          if(rrcllc_update_n_m_ratio(mimo_params->modeSpecificInfo.u.fdd->mimoN_M_Ratio) == FAILURE)
          {
            return FAILURE;
          }
          mimo_reconfig = TRUE;
        }
    
        if(RRC_CHECK_MSG_TYPE_IE_PTR(mimo_params->modeSpecificInfo.u.fdd, 
                  mimoPilotConfigurationPresent))
        {
          mimo_reconfig = TRUE;
          if(RRC_CHECK_MSG_TYPE(mimo_params->modeSpecificInfo.u.fdd->mimoPilotConfiguration.secondCPICH_Pattern, 
                   T_rrc_MIMO_PilotConfiguration_secondCPICH_Pattern_normalPattern))
        {
           ordered_config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern = MIMO_NORMAL_PATTERN;
        }
        else if(RRC_CHECK_MSG_TYPE(mimo_params->modeSpecificInfo.u.fdd->mimoPilotConfiguration.secondCPICH_Pattern, 
                   T_rrc_MIMO_PilotConfiguration_secondCPICH_Pattern_diversityPattern))
        {
          ordered_config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern = MIMO_DIVERSITY_PATTERN;
   
          ordered_config_ptr->l1_hsdpa_info.mimo_info.channelisation_code = 
                  mimo_params->modeSpecificInfo.u.fdd->mimoPilotConfiguration.secondCPICH_Pattern.u.diversityPattern->channelisationCode;
          }
        }
      }
      else
      {
        return FAILURE;
      }  
    }
    else
    {
      WRRC_MSG0_HIGH("MIMO:MIMO params not present in OTA");
    }  
  }
  else
  {
    MSG_HIGH("REL8:MIMO can't be started HS-Action %d HS-Status %d NV HS-CAT %d",
            hs_action,rrc_get_hsdpa_status(),nv_hsdpa_category);
    mimo_params_present_ota = 0;
  }
   
  if((!mimo_params_present_ota) ||
    (rrcllc_check_if_mimo_can_be_started(rrc_state) == FALSE ))
  {
    if(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE )
    {
      WRRC_MSG0_HIGH("MIMO:Set MIMO Action to STOP");
      ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_STOP;
      if(hs_action != HSDPA_STOP)
      {
        WRRC_MSG0_HIGH("Include HS bitmask as MIMO is going be stopped, but HS continues");

        ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL |CPHY_HS_DSCH_CFG_INCL|CPHY_HS_DPCCH_CFG_INCL;

          /* Set beta table and hs-dpcch bit mask */
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
        if(hs_action == HSDPA_NOOP)
        {
          rrc_set_hsdpa_action(HSDPA_RECONFIG);
          rrc_set_hsdpa_action_in_machs_macehs();
        }
           
      }
      else
      {
        ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL;
      }
    }
    else
    {
      WRRC_MSG0_HIGH("MIMO:Set MIMO Action to NOOP");
      rrcllc_init_mimo_params(ordered_config_ptr);
      ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
    }
  }
  else
  {
    uint8 num_harq_proc =  ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.num_proc;
    /*If the IE “Number of processes" is not set to one of the values 12, 14 or 16 and the IE “MIMO
        operation” (10.3.6.41a) is included and set to either “start” or “continue”, the UE behaviour is
        unspecified.
      */
    if((num_harq_proc == 12) || (num_harq_proc == 14) || (num_harq_proc == 16))
    {
       WRRC_MSG1_HIGH("MIMO: No. Of harq process is %d as according to MIMO ",num_harq_proc);
    }
    else
    {
      WRRC_MSG1_ERROR("MIMO: No. Of harq process is %d is not suitable for MIMO ",num_harq_proc);
      return FAILURE;
    }
    
    if(mimo_params->mimoOperation == rrc_MIMO_Operation_start )
    {
      ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_START;      
      
      ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL|CPHY_HS_DSCH_CFG_INCL|CPHY_HS_DPCCH_CFG_INCL;

      /* Set beta table and hs-dpcch bit mask */
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
      
      if(hs_action != HSDPA_START)
      {
        rrc_set_hsdpa_action(HSDPA_RECONFIG);
        rrc_set_hsdpa_action_in_machs_macehs();
      }

    }
    else if(mimo_params->mimoOperation == rrc_MIMO_Operation_continue_ )
    {
      ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;

      if(mimo_reconfig ==TRUE)
      {
        if(rrcllc_get_mimo_status() == RRC_MIMO_INACTIVE)
        {
          WRRC_MSG0_ERROR(" MIMO not active so MIMO Operation should be rrc_start, but received as rrc_continue  ");
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_START;
        }
        else
        {
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;
        }
        
        MSG_HIGH("MIMO: MIMO action reconfig ,second_cpich_pattern  %d chan code %d M/N ratio %d",
             ordered_config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern,
             ordered_config_ptr->l1_hsdpa_info.mimo_info.channelisation_code,
             ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio);
        
        ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL |CPHY_HS_DSCH_CFG_INCL|CPHY_HS_DPCCH_CFG_INCL;

        /* Set beta table and hs-dpcch bit mask */
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
          
         if(hs_action != HSDPA_START)
         {
           rrc_set_hsdpa_action(HSDPA_RECONFIG);
           rrc_set_hsdpa_action_in_machs_macehs();
         }
      }
      else
      {
        if((ordered_config_ptr->l1_hsdpa_info.hs_req_mask & CPHY_HS_DSCH_CFG_INCL)
            &&(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE))
        {
          /*This is as per L1's requirement that when MIMO is active, even if No MIMO params change
           * if HS-DSCH changes then indicate MIMO as RECONFIG*/
          
          ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL;
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;
          WRRC_MSG1_HIGH("MIMO: No new MIMO params but HSDSCH touched so MIMO action reconfig HS bitmask 0x%x",
                            ordered_config_ptr->l1_hsdpa_info.hs_req_mask);
        }
        else if((ordered_config_ptr->l1_hsdpa_info.hs_req_mask & CPHY_HS_PDSCH_RL_CFG_INCL) && 
          (rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE))
        {
          ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL |CPHY_HS_DSCH_CFG_INCL;
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;        
          WRRC_MSG0_HIGH("MIMO:HS Re-pointing so RECFGing MIMO");
        }
        else
        {
          WRRC_MSG0_HIGH("MIMO: No new MIMO params received so action NOOP");
        }
      }
    }
    else
    {
      WRRC_MSG1_ERROR("MIMO: Invalid MIMO Operation %d",mimo_params->mimoOperation);
      return FAILURE;
    }
  }
   
  return SUCCESS;
}
#endif /* FEATURE_WCDMA_MIMO */


/*============================================================================
FUNCTION: rrcllc_process_serving_hsdsch_cell_info_r8()

DESCRIPTION:
  This function updates IE "rrc_Serving_HSDSCH_CellInformation " in ordered config

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllc_process_serving_hsdsch_cell_info_r8
(
  rrc_ActiveSetUpdate_r8_IEs *msg_ptr 
)
{
  rrc_Serving_HSDSCH_CellInformation_r8 *hs_srv_cell_ptr = &msg_ptr->serving_HSDSCH_CellInformation;
  uint8 rl_count = 0;

  /*Following check is done to make sure that H-RNTI is provided if HS Re-pointing is happening.*/
  if((RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
             primaryCPICH_InfoPresent))
    && (hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode != ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc)
    && (!(RRC_CHECK_MSG_TYPE_IE_PTR(msg_ptr, 
               newH_RNTIPresent))))

  {
    WRRC_MSG0_ERROR("REL8:ASU Re-pointing without new HRNTI!");
    return FAILURE;
  }
  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                primaryCPICH_InfoPresent))
  {
    /*Find out the RL index in OC for the HS RL PSC*/
    for (rl_count = 0; rl_count < ordered_config_ptr->l1_dl_chan_parms.num_rl; rl_count++)
    {
      if(hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode == 
         ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[rl_count].pri_cpich_scr_code)
      {
        WRRC_MSG1_HIGH("REL8:New HS Serving Cell PSC found in AS at idx %d",rl_count);
        break;
      }
    }
    if(rl_count == ordered_config_ptr->l1_dl_chan_parms.num_rl)
    {
      WRRC_MSG0_ERROR("REL8:New HS Serving Cell PSC not found in AS!");
      return FAILURE;
    }

    /*Update the HSDPA MSG PARAMS with PSC Info.*/
   
    if(hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode
      != ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc)
    {
      WRRC_MSG1_HIGH("REL8:ASU HS repointing to PSC %d", hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode);
      hsdpa_msg_params.msg_params_present = TRUE;
      hsdpa_msg_params.rl_link_present = TRUE;
      hsdpa_msg_params.new_rl_link = hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode;
    }
  }


  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
               deltaACKPresent))
  {
    if(ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack != hs_srv_cell_ptr->deltaACK)
    {
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack = hs_srv_cell_ptr->deltaACK;
      hsdpa_msg_params.beta_table_present = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                deltaNACKPresent))
  {
    if(ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack != hs_srv_cell_ptr->deltaNACK)
    {
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack = hs_srv_cell_ptr->deltaNACK;
      hsdpa_msg_params.beta_table_present = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                mac_hsResetIndicatorPresent))
  {
    ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = TRUE;
    hsdpa_msg_params.msg_params_present = TRUE;
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                harqInfoPresent))
  {    
    /* Process HARQ Info */
    if(set_harq_information_r7(&hs_srv_cell_ptr->harqInfo) == FAILURE)
    {
      return FAILURE;
    }
    hsdpa_msg_params.msg_params_present = TRUE;
    hsdpa_msg_params.hsdsch_info_present = TRUE;
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                dl_hspdsch_InformationPresent))
  {
    hsdpa_msg_params.msg_params_present = TRUE;
    hsdpa_msg_params.hspdsch_info_present = TRUE;

    ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = FALSE;
    if(RRC_CHECK_MSG_TYPE(hs_srv_cell_ptr->dl_hspdsch_Information.modeSpecificInfo, 
                T_rrc_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd))
    {
      if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr->dl_hspdsch_Information.modeSpecificInfo.u.fdd, 
                 dl_64QAM_ConfiguredPresent))
      {
        ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = TRUE;
      }
    }
    else if(RRC_CHECK_MSG_TYPE(hs_srv_cell_ptr->dl_hspdsch_Information.modeSpecificInfo, 
                T_rrc_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd))
    {
      return FAILURE;
    }
  }
  else
  {
    if(rrc_get_hsdpa_status() == HSDPA_INACTIVE)
    {
      /* Action has already been set to NOOP by default */
      WRRC_MSG0_HIGH("RRCHS:HSDPA Action NOOP");
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP; 
      ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
    }
  }

  if(rrcllc_determine_hsdpa_action_r8(&hs_srv_cell_ptr->dl_hspdsch_Information) == SUCCESS)
  {
    rrc_set_hsdpa_action_in_machs_macehs();

    /*Following check is made to ensure that 64 QAM isn't being enabled with MAC-HS*/
    if((ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE)
      &&((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
          (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
          ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
          (rrc_get_hsdpa_status() == HSDPA_ACTIVE))))
    {
      if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS )
      {
        WRRC_MSG0_ERROR("REL8:64QAM cannot be started on MAC-HS!");
        return FAILURE;
      }
    }

  }
  else
  {
    return FAILURE;
  }
  return SUCCESS;
}

/*====================================================================
FUNCTION: validate_fdpch_information_r8()

DESCRIPTION:
  This function verifies that there are no mixed RLs with DPCH and FDPCH
  after ASU is processed.

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if validation is successful.
  FAILURE if there are mixed RLs with FDPCH and DPCH

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type validate_fdpch_information_r8
(
  rrc_RL_AdditionInformationList_r8 *rl_AdditionInformationList_ptr
)
{
  uint32 n_value = rl_AdditionInformationList_ptr->n;
  uint32 n_index = 0;
  
  while(n_value != 0)
  {
    if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch)
    {
      if(RRC_CHECK_MSG_TYPE(rl_AdditionInformationList_ptr->elem[n_index].dl_dpchInfo,
                    T_rrc_RL_AdditionInformation_r8_dl_dpchInfo_dl_DPCH_InfoPerRL))
      {
        WRRC_MSG0_ERROR("REL8:Mixed RLs with DPCH and FDPCH");
        return FAILURE;
      }
    }
    else
    {
      if(RRC_CHECK_MSG_TYPE(rl_AdditionInformationList_ptr->elem[n_index].dl_dpchInfo,
                     T_rrc_RL_AdditionInformation_r8_dl_dpchInfo_dl_FDPCH_InfoPerRL))
      {
        WRRC_MSG0_ERROR("REL8:Mixed RLs with DPCH and FDPCH");
        return FAILURE;
      }
    }
    n_value--;
    n_index++;
  }
  return SUCCESS;
}

/*============================================================================
FUNCTION: set_compressed_mode_info_r8()

DESCRIPTION:
  This function sets the compressed mode parameters from UTRAN message
  in the format required by L1. It validates the parameters to check if they
  are in range and sets in Ordered Config the compressed mode list. L1 is provided
  the entire list everytime with no of elements in it.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type set_compressed_mode_info_r8
(
  rrc_DPCH_CompressedModeInfo_r8 * rrc_compressed_mode_ptr
)
{
  /* Store the TGP list ptr in a local list */
  struct rrc_TGP_SequenceList_r8 *local_tgp_SequenceList_ptr = NULL;

  struct rrc_TGP_SequenceList_r8 *hsdpa_cm_local_list_ptr = NULL;
  uint8 cm_activate = 0;

  uint8 cm_deactivate = 0;
  uint32 n_value_hs=0, n_index_hs=0;

  /* Initialize counters */
  uint8 cnt = 0;
  uint8 tgpsi_index = 0;
  uint8 tgpsi = 0;
  uint32 n_index=0;
  boolean tgpsi_change = FALSE;
  /* Stores the ptr that points to the head of the CM list */
  l1_cm_tgp_seq_info_struct_type* l1_seq_head_ptr = NULL;

  l1_seq_head_ptr = &(ordered_config_ptr->tgp_seq_info[0]);


  hsdpa_cm_local_list_ptr = local_tgp_SequenceList_ptr = 
    &(rrc_compressed_mode_ptr->tgp_SequenceList);
  cm_status_from_ota_msg = RRC_CM_NONE;
  n_value_hs = hsdpa_cm_local_list_ptr->n;

  if (local_tgp_SequenceList_ptr->n == 0)
  {
    WRRC_MSG0_ERROR("Compressed Mode list is NULL");
    return FAILURE;
  }

  /* First initialize action_needed to FALSE */
  while (cnt < L1_CM_MAX_TGP_SEQ_COUNT)
  {
    ordered_config_ptr->cm_info.action_needed[cnt++] = FALSE;
  }

  /* Reinitialize cnt */
  cnt = 0;


  /* enter into this while loop to compute the value of 'cm_status_from_ota_msg' */
  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5)
  {
    while (n_value_hs != 0)
    {
      if(RRC_CHECK_MSG_TYPE(hsdpa_cm_local_list_ptr->elem[n_index_hs].tgps_Status, 
                  T_rrc_TGP_Sequence_r8_tgps_Status_activate))
      {
        cm_activate++;
      }
      else
      {
        cm_deactivate++;
      }
      n_value_hs--;
      n_index_hs++;
    }
    
    /* False for CM deactivate does not matter as pattern 
    could be simul activated/deactivated */
    if (cm_activate > 0)
    {
      cm_status_from_ota_msg = ACTIVATE_CM;
    }
    else if (cm_deactivate > 0)
    {
      cm_status_from_ota_msg = (rrcllc_cm_status_e_type) cm_deactivate;
    }
    else
    {
      cm_status_from_ota_msg = RRC_CM_NONE;
    }
  }

  ordered_config_ptr->cm_tgpsi_ota_cnt =0;

  /* Now process the CM list */
  while (n_index < local_tgp_SequenceList_ptr->n)
  {

    /* Validate the TGPSI */
    if (local_tgp_SequenceList_ptr->elem[n_index].tgpsi > 0 &&
      local_tgp_SequenceList_ptr->elem[n_index].tgpsi <= L1_CM_MAX_TGP_SEQ_COUNT)
    {
      tgpsi = (uint8) local_tgp_SequenceList_ptr->elem[n_index].tgpsi;
    }
    else
    {
      WRRC_MSG1_ERROR("Invalid TGPSI %d", tgpsi);
      return FAILURE;
    }

    /* First check if UTRAN wants to add or modify the existing TGPSI */
    if (find_tgpsi_index(&tgpsi, &tgpsi_index, &tgpsi_change) == SUCCESS)
    {

      /* Set this indication in action_needed so that L1 can find out
      * if a TGPSI has been modified or not */
      set_tgpsi_location(&tgpsi_index);

      /* Element has to be added at position given by tgpsi_index */
      while(cnt++ != tgpsi_index)
      {
        l1_seq_head_ptr++;
      }

      l1_seq_head_ptr->tgp_seq_id = tgpsi;

      /* Find out what has to be done with the pattern */
      if(RRC_CHECK_MSG_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_Status, 
                   T_rrc_TGP_Sequence_tgps_Status_activate))
      {

        l1_seq_head_ptr->active = TRUE;

        /* Store Starting TGCFN */
        l1_seq_head_ptr->start_cfn = (uint8)
          local_tgp_SequenceList_ptr->elem[n_index].tgps_Status.u.activate->tgcfn;
      }
      else
      {
        l1_seq_head_ptr->active = FALSE;
      }

      if (RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index],  
                   tgps_ConfigurationParamsPresent))
      {
        /* Set info valid to TRUE */
        l1_seq_head_ptr->info_valid = TRUE;

        /* Add rest of parameters */
        /* Find out the purpose of this patern sequence */
        if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgmp == rrc_TGMP_r8_multi_carrier)
          || (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgmp == rrc_TGMP_r8_tdd_Measurement)
#ifndef FEATURE_WCDMA_CM_LTE_SEARCH
          ||(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgmp == rrc_TGMP_r8_e_UTRA)          
#else
          ||((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgmp == rrc_TGMP_r8_e_UTRA) && (rrc_wtol_cm_support_nv == FALSE))
#endif
           )
        {
          WRRC_MSG0_ERROR("REL8:TDD/MultiCarrier/E-UTRA CM not supported yet!");
          return FAILURE;
        }
        else
        {
          WRRC_MSG1_HIGH("REL8:Given TGMP %d for TGPS ConfigParams",local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgmp);
        }

        /* Get Meas Purpose */
        l1_seq_head_ptr->tg_meas_purpose =
          RET_COMPRESSED_MODE_MEAS_PURPOSE_R8(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgmp);

        /* Check rrc_nidentifyAbort_present for Initial BSIC active */
        if ((RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams,
                          nidentifyAbortPresent)) && 
          (l1_seq_head_ptr->tg_meas_purpose == L1_CM_TGMP_GSM_BSIC_IDENTIFY))

        {
          if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.nidentifyAbort <=
            N_IDENTIFY_ABORT_MAX) && (local_tgp_SequenceList_ptr->elem[n_index].
            tgps_ConfigurationParams.nidentifyAbort >= N_IDENTIFY_ABORT_MIN))
          {
            l1_seq_head_ptr->n_identify_abort = (uint8)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.nidentifyAbort;
          }
          else
          {
            WRRC_MSG1_ERROR("REL8:nidentifyAbort Invalid",local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.nidentifyAbort);
            return FAILURE;
          }
        }

        /* Check treconfirmAbort for Reconfirmation BSIC */
        if ((RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams,
                        treconfirmAbortPresent)) && 
            (l1_seq_head_ptr->tg_meas_purpose == L1_CM_TGMP_GSM_BSIC_RECONF))

        {
          if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.treconfirmAbort <=
            T_RECONFIRM_ABORT_MAX) && (local_tgp_SequenceList_ptr->elem[n_index].
            tgps_ConfigurationParams.treconfirmAbort >= T_RECONFIRM_ABORT_MIN))
          {
            l1_seq_head_ptr->t_reconf_abort = (uint8)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.treconfirmAbort;
          }
          else
          {
            WRRC_MSG1_ERROR("REL8:T_Reconfirm_Abort Invalid",
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.treconfirmAbort);
            return FAILURE;
          }
        }

        /* Find compressed mode method */
        if(RRC_CHECK_MSG_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.ul_DL_Mode, 
                        T_rrc_UL_DL_Mode_ul))
        {
          WRRC_MSG0_HIGH("REL8:Only UL Compressed Mode given");
          return FAILURE;

        }
        else if(RRC_CHECK_MSG_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.ul_DL_Mode, 
                        T_rrc_UL_DL_Mode_dl))
        {
          WRRC_MSG0_HIGH("REL8:Only DL Compressed Mode given");
          return FAILURE;
        }
        else
        {
          l1_seq_head_ptr->ul_cm_method = RET_UL_COMPRESSED_MODE_METHOD_TYPE(
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.ul_DL_Mode.u.ul_and_dl->ul);

          l1_seq_head_ptr->dl_cm_method = RET_DL_COMPRESSED_MODE_METHOD_TYPE(
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.ul_DL_Mode.u.ul_and_dl->dl);

          if (l1_seq_head_ptr->dl_cm_method == L1_CM_BY_PUNCT)
          {
            WRRC_MSG1_HIGH("REL8:Unsupported DL CM_method:%d",l1_seq_head_ptr->dl_cm_method);
            return FAILURE;
          }

        }

        /* Get downlink frame type */
        l1_seq_head_ptr->dl_frame_type =
          RET_DL_FRAME_TYPE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.dl_FrameType);


        /* Get Compressed Mode state control info */

        /* Repetition Count */
        l1_seq_head_ptr->tgp_state_ctrl_info.tgp_rep_count = (uint16)
          local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgprc;


        /* Slot Number [0..14] */
        if (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgsn <= TGSN_MAX)
        {
          l1_seq_head_ptr->tgp_state_ctrl_info.tg_start_slot_num = (uint8)
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgsn;
        }
        else
        {
          WRRC_MSG1_ERROR("REL8:Invalid Slot Number : %d",
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgsn);
          return FAILURE;
        }

        /* TGL1 [1...14] */
        if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl1 <= TGL1_MAX) &&
          (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl1 >= TGL_MIN))
        {
          l1_seq_head_ptr->tgp_state_ctrl_info.tg_len_1 = (uint8)
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl1;
        }
        else
        {
          WRRC_MSG1_ERROR("REL8:Invalid TGL1 : %d",
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl1);
          return FAILURE;
        }

        /* TGL2 [1...14] */
        if (RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams,
                           tgl2Present))
        {

          if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl2 <= TGL2_MAX) &&
            (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl2 >= TGL_MIN))
          {
            l1_seq_head_ptr->tgp_state_ctrl_info.tg_len_2 = (uint8)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl2;
          }
          else
          {
            WRRC_MSG1_ERROR("REL8:Invalid TGL2 : %d",
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgl2);
            return FAILURE;
          }
        }
        else
        {
          l1_seq_head_ptr->tgp_state_ctrl_info.tg_len_2 =
            l1_seq_head_ptr->tgp_state_ctrl_info.tg_len_1;
        }

        if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgd >= TGD_MIN) &&
          (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgd <= TGD_MAX))
        {
          /* Check if the value is undefined i.e. 270 */
          if (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgd == TGD_MAX)
          {
            l1_seq_head_ptr->tgp_state_ctrl_info.tgd = 0;
          }
          else
          {
            /* Txion Gap Distance  */
            l1_seq_head_ptr->tgp_state_ctrl_info.tgd = (uint16)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgd;
          }
        }
        else
        {
          WRRC_MSG1_ERROR("REL8:Invalid TGD : %d",
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgd);
          return FAILURE;
        }

        /* Transmission gap pattern length1 [1...144] */

        if ((local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgpl1 <= TGPL1_MAX) &&
          (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgpl1 >= TGPL_MIN))
        {
          l1_seq_head_ptr->tgp_state_ctrl_info.tgp_len_1 = (uint8)
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgpl1;
        }
        else
        {
          WRRC_MSG1_ERROR("REL8:Invalid TGPL1 : %d",
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.tgpl1);
          return FAILURE;
        }

        l1_seq_head_ptr->tgp_state_ctrl_info.tgp_len_2 =
          l1_seq_head_ptr->tgp_state_ctrl_info.tgp_len_1;

        /* Power Ctrl Info */
        /* recovery period power control mode */
        l1_seq_head_ptr->pwr_ctrl_info.rpp = RET_RECOVERY_POWER_CONTROL(
          local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.rpp);

        /* initial UL transmit power control method */
        l1_seq_head_ptr->pwr_ctrl_info.itp = RET_INITIAL_TRANSMIT_POWER(
          local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.itp);

        /* All delta_sir [0...30]. Actual Value is [0...  .3] */
        if (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIR1 <= SIR_MAX)
        {
          l1_seq_head_ptr->pwr_ctrl_info.delta_sir_1 = (uint8)
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIR1;
        }
        else
        {
          WRRC_MSG1_ERROR("REL8:Invalid deltaSIR1 : %d",
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIR1);
          return FAILURE;
        }

        /* delta_sir_2 */
        if (RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams,
                        deltaSIR2Present))
        {
          if (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIR2 <= SIR_MAX)
          {
            l1_seq_head_ptr->pwr_ctrl_info.delta_sir_2 = (uint8)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIR2;

          }
          else
          {
            WRRC_MSG1_ERROR("REL8:Invalid deltaSIR2 : %d",
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIR2);
            return FAILURE;
          }
        }
        else
        {
          l1_seq_head_ptr->pwr_ctrl_info.delta_sir_2 = l1_seq_head_ptr->pwr_ctrl_info.delta_sir_1;
        }

        /* delta_sir_after_1 */
        if (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIRAfter1 <= SIR_MAX)
        {
          l1_seq_head_ptr->pwr_ctrl_info.delta_sir_after_1 = (uint8)
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIRAfter1;
        }
        else
        {
          WRRC_MSG1_ERROR("REL8:Invalid deltaSIRAfter1 : %d",
            local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIRAfter1);
          return FAILURE;
        }


        /* delta_sir_after_2 */
        if (RRC_CHECK_MSG_TYPE_IE(local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams,
                        deltaSIRAfter2Present))
        {
          if (local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIRAfter2 <= SIR_MAX)
          {
            l1_seq_head_ptr->pwr_ctrl_info.delta_sir_after_2 = (uint8)
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIRAfter2;
          }
          else
          {
            WRRC_MSG1_ERROR("REL8:Invalid deltaSIRAfter2 : %d",
              local_tgp_SequenceList_ptr->elem[n_index].tgps_ConfigurationParams.deltaSIRAfter2);
            return FAILURE;
          }
        }
        else
        {
          l1_seq_head_ptr->pwr_ctrl_info.delta_sir_after_2 =
            l1_seq_head_ptr->pwr_ctrl_info.delta_sir_after_1;
        }
      }  /* End of rrc_tgps_ConfigurationParams_present  Present */
      else
      {
        /* Set info valid to FALSE  */
        l1_seq_head_ptr->info_valid = FALSE;

      }
    } /* End of if of tgpsi successfully found */
    else
    {
      /* This condition would never happen */
      return FAILURE;
    }

    /* Read next value if any */
    n_index++;

    /* Reinitialize count */
    cnt = 0;

    /* Reinitialize the l1_seq_head_ptr */
    l1_seq_head_ptr = &(ordered_config_ptr->tgp_seq_info[0]);

    /* If it is a MODIFY, do not increment the count */
    if (tgpsi_change == FALSE)
    {
      /* Since we added one element, so increment tgpsi_cnt */
      ordered_config_ptr->cm_info.tgp_seq_info_count += 1;
    }
    else
    {
      tgpsi_change = FALSE;
    }

    /*Store the TGPSIs provided in this OTA*/
    ordered_config_ptr->cm_tgpsi_ota_changed[ordered_config_ptr->cm_tgpsi_ota_cnt] = tgpsi;
    ordered_config_ptr->cm_tgpsi_ota_cnt ++;
  
  } /* End of while of local_tgp_SequenceList_ptr != NULL */

  return SUCCESS;
}

#ifdef FEATURE_WCDMA_DC_HSDPA
/*============================================================================
FUNCTION: rrcllcpcie_check_if_sec_hsdpa_can_be_started

DESCRIPTION:
  This function checks whether SEC HSDPA can be started or not 
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/

static boolean rrcllcpcie_check_if_sec_hsdpa_can_be_started(rrc_RRC_StateIndicator rrc_state, OSS_UINT32 dc_hsdpa_params_present_ota)
{
  hsdpa_action_enum_type hs_action =rrc_get_hsdpa_action();
  if(!((rrcueci_nv_supports_dc_hsdpa() == TRUE) && ((hs_action == HSDPA_START) ||
  	((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && (hs_action != HSDPA_STOP))) && (rrc_state == rrc_RRC_StateIndicator_cell_DCH)))
  {
    if(dc_hsdpa_params_present_ota)
    {
    MSG_HIGH("DC-HSDPA:Can't be started coz HS-Action %d HS-Status %d NV HS-CAT %d",
    hs_action,rrc_get_hsdpa_status(),nv_hsdpa_category);
    }
    return FALSE;
  }
  return TRUE;
}
/*============================================================================
FUNCTION: 
static void rrcllcpcie_init_sec_hs_info_before_processing()

DESCRIPTION: This function initializes the action to STOP for all the carriers

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
=============================================================================*/

static void rrcllcpcie_init_sec_hs_info_before_processing(void)
{
  uint8 ix=0;

  ordered_config_ptr->l1_hsdpa_info.hs_req_mask &= ~CPHY_HS_SEC_HSDPA_CFG_INCL;
  for(ix = 0; ix < MAX_NUM_OF_SEC_CARRIERS; ix++)
  {
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action = L1_SEC_HSDPA_STOP;
  }
}
/*============================================================================
FUNCTION: 
void rrcllcpcie_return_num_sec_hsdpa_carriers(ordered_config_ptr)

DESCRIPTION:
This function returns num of carriers in sec config
DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
=============================================================================*/
uint8 rrcllcpcie_return_num_sec_hsdpa_carriers(ordered_config_type* config_ptr)
{
  uint8 num_sec_hs_carriers = 0, ix;
  for(ix=0; ix< MAX_NUM_OF_SEC_CARRIERS; ix++)
  {
    if(config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action == L1_SEC_HSDPA_RECFG)
    {
      num_sec_hs_carriers++;
    }
  }
  return num_sec_hs_carriers;
}
/*============================================================================
FUNCTION: 
void rrcllcpcie_set_sec_hs_req_mask(set_sec_hs_req_mask)

DESCRIPTION:
This function sets the sec HS req  mask
DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_set_sec_hs_req_mask(boolean set_sec_hs_req_mask)
{
  hsdpa_action_enum_type hs_action =rrc_get_hsdpa_action();
  uint8 num_sec_hs_carrier_oc =rrcllcpcie_return_num_sec_hsdpa_carriers(ordered_config_ptr);
  uint8 num_sec_hs_carrier_cc = rrcllcpcie_return_num_sec_hsdpa_carriers(current_config_ptr);

  if(hs_action != HSDPA_STOP)
  {
    if((set_sec_hs_req_mask == TRUE) || (num_sec_hs_carrier_oc != num_sec_hs_carrier_cc))
    {
      ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_SEC_HSDPA_CFG_INCL |CPHY_HS_DSCH_CFG_INCL|
      CPHY_HS_DPCCH_CFG_INCL;
      /* Set beta table and hs-dpcch bit mask */
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
      HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
      if(rrc_get_hsdpa_status() == HSDPA_ACTIVE)
      {
        rrc_set_hsdpa_action(HSDPA_RECONFIG);
        rrc_set_hsdpa_action_in_machs_macehs();
      }
    }
    else if(num_sec_hs_carrier_oc != 0) 
    {
      /* whenever primary is reconfigured, secondary is also reconfigured 
         This is different from legacy design, but this is done to make the behavior consistent
         (For all primary reconfig, we are reconfiguring secondary also),
          Because with 3C HS SCCH activation status is given by RRC. 
          If it is not done, there are issues at L1 in configuring HSSCCH activation status to FW
      */
      if(hs_action == HSDPA_RECONFIG)
      {
        ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_SEC_HSDPA_CFG_INCL;
      }
    }
  }
#ifdef FEATURE_WCDMA_3C_HSDPA
  if((ordered_config_ptr->l1_hsdpa_info.hs_req_mask & CPHY_HS_SEC_HSDPA_CFG_INCL) || (hs_action == HSDPA_STOP))
  {
    /*TSN extn is possible only if EHS configured */
    if(num_sec_hs_carrier_oc > 1)
    {
       ordered_config_ptr->mac_dl_parms.tsn_extn= TRUE;
    }
    else
    {
      ordered_config_ptr->mac_dl_parms.tsn_extn= FALSE;
    }
    if(current_config_ptr->mac_dl_parms.tsn_extn != ordered_config_ptr->mac_dl_parms.tsn_extn)
    {
      ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = TRUE;
    }
  }
  MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"3C_HSDPA_DEBUG: hs_req_mask: %d, tsn_extn:%d, hs_reset_indicator:%d hs_action: %d",
  ordered_config_ptr->l1_hsdpa_info.hs_req_mask,ordered_config_ptr->mac_dl_parms.tsn_extn,ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator, rrc_get_hsdpa_action());

#endif
}
#ifdef FEATURE_WCDMA_REL10
#error code not present
#endif
/*============================================================================
FUNCTION: 
uecomdef_status_e_type rrcllcpcie_validate_dbdc_band_combination()

DESCRIPTION:
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/

uecomdef_status_e_type rrcllcpcie_validate_dbdc_band_combination(void)
{

  uint32 pri_uarfcn=0, sec_uarfcn=0, pri_freq=0, sec_freq=0;
  rrc_csp_band_class_type primary_band, second_band;
  uint8 ix=0;
#ifdef FEATURE_WCDMA_DB_DC_HSDPA
  uint32  band_comb_configured=0;
	uint8 count;
#endif
  /*Validation added ro reject configuration for DC-HSDPA configuration when the difference
  between primary and secondary frequency is not within limits*/
  pri_uarfcn = (ordered_config_ptr->dest_freq_present == TRUE) ? ordered_config_ptr->dest_freq : rrc_ccm_get_curr_camped_freq();

  for(ix=0; ix<MAX_NUM_OF_SEC_CARRIERS;ix++)
  {
    if(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action == L1_SEC_HSDPA_RECFG)
    {
      sec_uarfcn = ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].hs_sec_cell_dl_freq;
      break;
    }
  }
  primary_band = rrc_get_frequency_band(pri_uarfcn,rrc_ccm_get_curr_camped_plmn());

  second_band = rrc_get_frequency_band(sec_uarfcn,rrc_ccm_get_curr_camped_plmn());

  if((primary_band!=RRC_CSP_BAND_MAX) && (second_band!=RRC_CSP_BAND_MAX)&& (primary_band == second_band))
  {
    pri_freq = rfm_get_freq_from_dl_arfcn(pri_uarfcn);
    sec_freq = rfm_get_freq_from_dl_arfcn(sec_uarfcn);

    if ((ABS((int32)(sec_freq-pri_freq)) < HS_DC_FREQ_KHZ_MIN_DIFF) ||
        (ABS((int32)(sec_freq-pri_freq)) > HS_DC_FREQ_KHZ_MAX_DIFF))
    {
      WRRC_MSG2_ERROR("DC-HSDPA:Incorrect DC frequency:  PriFreq %d SecFreq %d.",pri_freq,sec_freq);
      return FAILURE;
    }
  }
  else
  {

    MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"DC-HSDPA :primary %d and secondary %d frequency belong to bands  primary band %d Secondary band %d ",
  	pri_freq,	sec_freq,	primary_band,second_band);
#ifdef FEATURE_WCDMA_DB_DC_HSDPA

    /*Network configured frequencies on different bands so check if UE supports DB-DC and
     if the band combination is supported or not and then reject the configuration*/          
    if(rrcueci_nv_supports_db_dc_hsdpa()==FALSE)
    {
       WRRC_MSG0_ERROR("DB-DC-NV not enabled rejecting the configuration");
       return FAILURE;
    }

    if(((primary_band == RRC_CSP_IMT2K_BAND) || (second_band == RRC_CSP_IMT2K_BAND))
      && ((primary_band == RRC_CSP_WCDMA_900_BAND) || (second_band == RRC_CSP_WCDMA_900_BAND)))
    {
      band_comb_configured = RRC_DB_DC_BAND1_BAND8;
    }
    else if(((primary_band == RRC_CSP_PCS_BAND) || (second_band == RRC_CSP_PCS_BAND))
          && ((primary_band == RRC_CSP_WCDMA_1700_2100_BAND) || (second_band == RRC_CSP_WCDMA_1700_2100_BAND)))
    {
      band_comb_configured = RRC_DB_DC_BAND2_BAND4;
    }
    else if(((primary_band == RRC_CSP_IMT2K_BAND) || (second_band == RRC_CSP_IMT2K_BAND))
          && ((primary_band == RRC_CSP_WCDMA_850_BAND) || (second_band == RRC_CSP_WCDMA_850_BAND)))
    {
      band_comb_configured = RRC_DB_DC_BAND1_BAND5;
    }
   else if(((primary_band == RRC_CSP_IMT2K_BAND) || (second_band == RRC_CSP_IMT2K_BAND))
          && ((primary_band == RRC_CSP_WCDMA_1800_BAND) || (second_band == RRC_CSP_WCDMA_1800_BAND)))
   {
     band_comb_configured = RRC_DB_DC_BAND1_BAND9;
   }
   else if(((primary_band == RRC_CSP_PCS_BAND) || (second_band == RRC_CSP_PCS_BAND))
          && ((primary_band == RRC_CSP_WCDMA_850_BAND) || (second_band == RRC_CSP_WCDMA_850_BAND)))
   {
     band_comb_configured = RRC_DB_DC_BAND2_BAND5;
   }                
        
    for (count=0;count < db_dc_band_comb_list.num_db_dc_band_comb_supp; count++)
    {
      if(db_dc_band_comb_list.db_dc_band_comb_list[count] == band_comb_configured)
      {
        WRRC_MSG1_HIGH("DB-DC-band combination found %d by UE",band_comb_configured);
        break;
      }
    }
    if(count == db_dc_band_comb_list.num_db_dc_band_comb_supp)
    {
       WRRC_MSG0_ERROR("DB-DC-band combination not supported by UE");
       return FAILURE;
    }                   
#else
    WRRC_MSG0_ERROR("DB-DC feature not enabled rejecting the configuration");
    return FAILURE;
#endif
  }
return SUCCESS;
  }
  
#ifdef FEATURE_WCDMA_REL9
  

/*============================================================================
FUNCTION: rrcllcpcie_process_dc_hsdpa_params_r9()

DESCRIPTION:

      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_dc_hsdpa_params_r9
(
  rrc_DL_SecondaryCellInfoFDD_r9 * dc_hsdpa_params,
  rrc_RRC_StateIndicator rrc_state,
  OSS_UINT32 dc_hsdpa_params_present_ota
)
{
  uint8 ix=0;
  boolean set_sec_hs_req_mask = 0;

  /*Init sec hs action in OC before processing */
  rrcllcpcie_init_sec_hs_info_before_processing();

  /*By this time, HSDPA action should have been determined.*/
  /*Make sure that HSDPA category supports DC-HSDPA and (either HSDPA is being started or reconfig) */
  if(TRUE == rrcllcpcie_check_if_sec_hsdpa_can_be_started(rrc_state, dc_hsdpa_params_present_ota))
  {
    if(dc_hsdpa_params_present_ota)
    {
      if(RRC_CHECK_COMMON_MSG_TYPE(dc_hsdpa_params->configurationInfo, rrc_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration))
      {
        rrcllcpcie_update_sec_hs_ie_info_into_oc_r9(&(dc_hsdpa_params->configurationInfo), ix);
        set_sec_hs_req_mask = TRUE;
      }
      else if(current_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action == L1_SEC_HSDPA_STOP)
      {
        WRRC_MSG0_ERROR("3CHSDPA_DEBUG: Continue received for a carrier that is absent ");
        return FAILURE;
      }
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action = L1_SEC_HSDPA_RECFG;
    }
  }
  if(rrcllc_validate_sec_hsdpa_config(dc_hsdpa_params_present_ota,rrc_state) == FALSE)
  {
    WRRC_MSG0_ERROR(" Validation Failure ");
    return FAILURE;
  }
  rrcllcpcie_set_sec_hs_req_mask(set_sec_hs_req_mask);
  return SUCCESS;
}
/*============================================================================
FUNCTION: rrcllcpcie_update_sec_hs_ie_info_into_oc_r9()

DESCRIPTION:
  This function processes IE "DL_SecondaryCellInfoFDD" content in ordered config for R9 OTAs. Basically,
  this function updates the OC with the IE content
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_update_sec_hs_ie_info_into_oc_r9
(
  rrc_DL_SecondaryCellInfoFDD_r9_configurationInfo * dc_hsdpa_params,
  uint8 index
)
{
  rrc_DL_SecondaryCellInfoFDD_r9_hS_SCCHChannelisationCodeInfo * hsscch_list_ptr = NULL;
  uint32 ix=0;
  uint8 cnt = 0;

  (void)rrc_translate_hrnti(&dc_hsdpa_params->u.newConfiguration->new_H_RNTI, 
    &ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].h_rnti_sec_cell);

  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].pri_cpich_scr_code = 
	(uint16)dc_hsdpa_params->u.newConfiguration->primaryCPICH_Info.primaryScramblingCode;

  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_scch_info.num_ch_code = 0;

  hsscch_list_ptr = &dc_hsdpa_params->u.newConfiguration->hS_SCCHChannelisationCodeInfo;
  while((ix <  hsscch_list_ptr->n) && (cnt < L1_DL_HS_SCCH_CODES_MAX))
  {
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_scch_info.ch_code[cnt++] = 
    (uint8)hsscch_list_ptr->elem[ix];
    ix++;
  }
  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_scch_info.num_ch_code = cnt;

  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].po_hs_dsch_sec_cell = 
	dc_hsdpa_params->u.newConfiguration->measurementPowerOffset;

  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_dl_freq = 
	dc_hsdpa_params->u.newConfiguration->uarfcn_DL;

  if(RRC_CHECK_MSG_TYPE_IE_PTR(dc_hsdpa_params->u.newConfiguration, dl_64QAM_ConfiguredPresent))
  {
	ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_64_qam_configured = TRUE;
  }
  else
  {
	ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_64_qam_configured = FALSE;
  }
  if(RRC_CHECK_MSG_TYPE_IE_PTR(dc_hsdpa_params->u.newConfiguration, hs_DSCH_TBSizeTablePresent))
  {
	ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_tb_size_alignment_type = 
	  L1_DL_HS_DSCH_TB_TABLE_OCTET_ALIGNED;
  }
  else
  {

    if(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_64_qam_configured)
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_tb_size_alignment_type = 
    	L1_DL_HS_DSCH_TB_TABLE_OCTET_ALIGNED;
    }
    else
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_tb_size_alignment_type = 
    	L1_DL_HS_DSCH_TB_TABLE_OCTET_UNALIGNED;
    }
  }
  if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
  {
    WRRC_MSG0_HIGH("DC-HSDPA:MAC header type is MAC-hs, Set Bit-Aligned");
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_tb_size_alignment_type = 
		L1_DL_HS_DSCH_TB_TABLE_OCTET_UNALIGNED; 		 
  }
  if(RRC_CHECK_MSG_TYPE_IE_PTR(dc_hsdpa_params->u.newConfiguration, dl_ScramblingCodePresent))
  {
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_scch_info.sec_scr_code_valid = TRUE;
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_scch_info.sec_scr_code = 
      dc_hsdpa_params->u.newConfiguration->dl_ScramblingCode;
  }
  else
  {
	  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_scch_info.sec_scr_code_valid = FALSE;
  }
  if(dc_hsdpa_params->u.newConfiguration->m.differentTxModeFromServingHS_DSCHCellPresent)
  {
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].diff_txd_mode = TRUE;
  }
  else
  {
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].diff_txd_mode = FALSE;
  }
}
#endif /*FEATURE_WCDMA_REL9*/
/*============================================================================
FUNCTION: rrcllcpcie_update_sec_hs_ie_info_into_oc()

DESCRIPTION:
  This function processes IE "DL_SecondaryCellInfoFDD" content in ordered config for R8 OTAs. Basically,
  this function updates the OC with the IE content.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  None

SIDE EFFECTS:
=============================================================================*/
void rrcllcpcie_update_sec_hs_ie_info_into_oc
(
  rrc_DL_SecondaryCellInfoFDD * dc_hsdpa_params,
  uint8 index
)
{
  rrc_DL_SecondaryCellInfoFDD_hS_SCCHChannelisationCodeInfo * hsscch_list_ptr = NULL;
  uint32 ix=0;
  uint8 cnt = 0;

  (void)rrc_translate_hrnti(&dc_hsdpa_params->u.newConfiguration->new_H_RNTI,	
    &ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].h_rnti_sec_cell);

  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].pri_cpich_scr_code = 
	(uint16)dc_hsdpa_params->u.newConfiguration->primaryCPICH_Info.primaryScramblingCode;

  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_scch_info.num_ch_code = 0;

  hsscch_list_ptr = &dc_hsdpa_params->u.newConfiguration->hS_SCCHChannelisationCodeInfo;
  while((ix <  hsscch_list_ptr->n) && (cnt < L1_DL_HS_SCCH_CODES_MAX))
    {
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_scch_info.ch_code[cnt++] = 
    (uint8)hsscch_list_ptr->elem[ix];
    ix++;
  }
  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_scch_info.num_ch_code = cnt;
      
  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].po_hs_dsch_sec_cell = 
	dc_hsdpa_params->u.newConfiguration->measurementPowerOffset;

  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_dl_freq = 
	dc_hsdpa_params->u.newConfiguration->uarfcn_DL;

  if(RRC_CHECK_MSG_TYPE_IE_PTR(dc_hsdpa_params->u.newConfiguration, dl_64QAM_ConfiguredPresent))
  {
  	ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_64_qam_configured = TRUE;
  }
  else
  {
	  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_64_qam_configured = FALSE;
  }
  if(RRC_CHECK_MSG_TYPE_IE_PTR(dc_hsdpa_params->u.newConfiguration, hs_DSCH_TBSizeTablePresent))
  {
  	ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_tb_size_alignment_type = 
	  L1_DL_HS_DSCH_TB_TABLE_OCTET_ALIGNED;
  }
  else
  {

    if(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_64_qam_configured)
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_tb_size_alignment_type = 
    	L1_DL_HS_DSCH_TB_TABLE_OCTET_ALIGNED;
    }
    else
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_tb_size_alignment_type = 
    	L1_DL_HS_DSCH_TB_TABLE_OCTET_UNALIGNED;
    }
  }
  if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
  {
    WRRC_MSG0_HIGH("DC-HSDPA:MAC header type is MAC-hs, Set Bit-Aligned");
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_tb_size_alignment_type = 
		L1_DL_HS_DSCH_TB_TABLE_OCTET_UNALIGNED; 		 
  }
  if(RRC_CHECK_MSG_TYPE_IE_PTR(dc_hsdpa_params->u.newConfiguration, dl_ScramblingCodePresent))
  {
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_scch_info.sec_scr_code_valid = TRUE;
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_scch_info.sec_scr_code = 
      dc_hsdpa_params->u.newConfiguration->dl_ScramblingCode;
  }
  else
  {
	  ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[index].hs_sec_cell_scch_info.sec_scr_code_valid = FALSE;
  }
}

/*============================================================================
FUNCTION: rrcllcpcie_process_dc_hsdpa_params()

DESCRIPTION:
  This function processes IE "DL_SecondaryCellInfoFDD" content in ordered config for R8 OTAs. Basically,
  this function updates the OC with the IE content and does some valiadation.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_dc_hsdpa_params
(
  rrc_DL_SecondaryCellInfoFDD * dc_hsdpa_params,
  rrc_RRC_StateIndicator rrc_state,
  OSS_UINT32 dc_hsdpa_params_present_ota
)
{
  uint8 ix=0;
  boolean set_sec_hs_req_mask = 0;

  /*Init sec hs action in OC before processing */
  rrcllcpcie_init_sec_hs_info_before_processing();
  
  /*By this time, HSDPA action should have been determined.*/
  /*Make sure that HSDPA category supports DC-HSDPA and (either HSDPA is being started or reconfig) */
  if(TRUE == rrcllcpcie_check_if_sec_hsdpa_can_be_started(rrc_state, dc_hsdpa_params_present_ota))
  {
    if(dc_hsdpa_params_present_ota)
    {
      if(RRC_CHECK_COMMON_MSG_TYPE_PTR(dc_hsdpa_params, rrc_DL_SecondaryCellInfoFDD_newConfiguration))
      {
        rrcllcpcie_update_sec_hs_ie_info_into_oc(dc_hsdpa_params, ix);
        set_sec_hs_req_mask = TRUE;
      }
      else if(current_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action == L1_SEC_HSDPA_STOP)
      {
        WRRC_MSG0_ERROR("3CHSDPA_DEBUG: Continue received for a carrier that is absent ");
        return FAILURE;
      }
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action = L1_SEC_HSDPA_RECFG;
    }
  }
  if(rrcllc_validate_sec_hsdpa_config(dc_hsdpa_params_present_ota, rrc_state) == FALSE)
  {
    return FAILURE;
  }
  rrcllcpcie_set_sec_hs_req_mask(set_sec_hs_req_mask);
  return SUCCESS;
}
#endif /*FEATURE_WCDMA_DC_HSDPA*/


/*===========================================================================

FUNCTION          RRCCSP_DERIVE_FREQ_FROM_UARFCN

DESCRIPTION       This function derivces 

DEPENDENCIES      None

RETURN VALUE      Frequency in multiple of 100KHZ

SIDE EFFECTS      None
===========================================================================*/
uint16 rrccsp_derive_freq_from_uarfcn
(
  rrc_freq_type freq,
  rrc_csp_band_class_type band_class
)
{
  int16 fdl_offset,fdl; /*multiples of 10k*/
  fdl_offset = 0;

  if((band_class == RRC_CSP_IMT2K_BAND)
  ||(band_class == RRC_CSP_WCDMA_1700_BAND)
  )
    fdl_offset = RRC_DEFAULT_FDL_OFFSET;

  else if(band_class == RRC_CSP_PCS_BAND)
  {
    if(freq >= RRC_DL_BAND_B_UARFCN_MIN &&
        freq <= RRC_DL_BAND_B_UARFCN_MAX)
    {
      fdl_offset = RRC_DEFAULT_FDL_OFFSET;
    }
    else
    {
      fdl_offset = RRC_FDL_OFFSET_BAND2_ADDL;
    }
  }

  else if(band_class == RRC_CSP_WCDMA_1800_BAND)
    fdl_offset = RRC_FDL_OFFSET_BAND3;

  else if(band_class == RRC_CSP_WCDMA_1700_2100_BAND)
  {
    if(freq >= RRC_DL_BAND_H_UARFCN_MIN &&
    freq <= RRC_DL_BAND_H_UARFCN_MAX)
    {
      fdl_offset = RRC_FDL_OFFSET_BAND4;
    }
    else
    {
      fdl_offset = RRC_FDL_OFFSET_BAND4_ADDL;
    }
  }

  else if((band_class == RRC_CSP_WCDMA_850_BAND) || (band_class == RRC_CSP_WCDMA_800_BAND))
  {
    if(freq >= RRC_DL_BAND_C_UARFCN_MIN &&
        freq <= RRC_DL_BAND_C_UARFCN_MAX)
    {
      /*If present in 850 band then for sure it will be present in 800 band, so check for 850 band range*/
      fdl_offset = RRC_DEFAULT_FDL_OFFSET;
    }
    else
    {
      fdl_offset = RRC_FDL_OFFSET_BAND5_BAND6_ADDL;
    }
  }

  else if(band_class == RRC_CSP_WCDMA_900_BAND)
    fdl_offset = RRC_FDL_OFFSET_BAND8;

  else if(band_class == RRC_CSP_WCDMA_1500_BAND)
    fdl_offset = RRC_FDL_OFFSET_BAND11;
  else if(band_class == RRC_CSP_WCDMA_BC19_BAND)
  {
    if(freq >= RRC_DL_BAND_J_UARFCN_MIN &&
        freq <= RRC_DL_BAND_J_UARFCN_MAX)
    {
      fdl_offset = RRC_FDL_OFFSET_BAND19;
    }
    else
    {
      fdl_offset = RRC_FDL_OFFSET_BAND19_ADDL;
    }
  }
  else
  {
    WRRC_MSG0_ERROR("Invalid band, use Fdl_offset as zero");
    fdl_offset = 0;
  }

  /*
    UARFCN*10 = 5*(FDL-FDLoffset)   FDL and FDLoffset are in integral multiples of 100KHZ
    FDL = 2*UARFCN + FDLoffset
  */

  fdl = (2*freq + fdl_offset);
  return fdl;
}
/*===========================================================================

FUNCTION          RRCCSP_DERIVE_FREQ_FROM_UARFCN_UL

DESCRIPTION       This function derivces freq from UL UARFCN

DEPENDENCIES      None

RETURN VALUE      Frequency in multiple of 100KHZ

SIDE EFFECTS      None
===========================================================================*/
uint16 rrccsp_derive_freq_from_uarfcn_ul
(
  rrc_freq_type freq,
  rrc_csp_band_class_type band_class
)
{
  int16 ful_offset,ful; /*multiples of 10k*/
  ful_offset = 0;

  if((band_class == RRC_CSP_IMT2K_BAND)
  ||(band_class == RRC_CSP_WCDMA_1700_BAND)
  )
    ful_offset = RRC_DEFAULT_FUL_OFFSET;

  else if(band_class == RRC_CSP_PCS_BAND)
  {
    if(freq >= RRC_UL_BAND_B_UARFCN_MIN &&
        freq <= RRC_UL_BAND_B_UARFCN_MAX)
    {
      ful_offset = RRC_DEFAULT_FUL_OFFSET;
    }
    else
    {
      ful_offset = RRC_FUL_OFFSET_BAND2_ADDL;
    }
  }

  else if(band_class == RRC_CSP_WCDMA_1800_BAND)
    ful_offset = RRC_FUL_OFFSET_BAND3;

  else if(band_class == RRC_CSP_WCDMA_1700_2100_BAND)
  {
    if(freq >= RRC_UL_BAND_H_UARFCN_MIN &&
    freq <= RRC_UL_BAND_H_UARFCN_MAX)
    {
      ful_offset = RRC_FUL_OFFSET_BAND4;
    }
    else
    {
      ful_offset = RRC_FUL_OFFSET_BAND4_ADDL;
    }
  }

  else if((band_class == RRC_CSP_WCDMA_850_BAND) || (band_class == RRC_CSP_WCDMA_800_BAND))
  {
    if(freq >= RRC_UL_BAND_C_UARFCN_MIN &&
        freq <= RRC_UL_BAND_C_UARFCN_MAX)
    {
      /*If present in 850 band then for sure it will be present in 800 band, so check for 850 band range*/
      ful_offset = RRC_DEFAULT_FUL_OFFSET;
    }
    else
    {
      ful_offset = RRC_FUL_OFFSET_BAND5_BAND6_ADDL;
    }
  }

  else if(band_class == RRC_CSP_WCDMA_900_BAND)
    ful_offset = RRC_FUL_OFFSET_BAND8;

  else if(band_class == RRC_CSP_WCDMA_1500_BAND)
    ful_offset = RRC_FUL_OFFSET_BAND11;
  else if(band_class == RRC_CSP_WCDMA_BC19_BAND)
  {
    if(freq >= RRC_UL_BAND_J_UARFCN_MIN &&
        freq <= RRC_UL_BAND_J_UARFCN_MAX)
    {
      ful_offset = RRC_FUL_OFFSET_BAND19;
    }
    else
    {
      ful_offset = RRC_FUL_OFFSET_BAND19_ADDL;
    }
  }
  else
  {
    WRRC_MSG0_ERROR("Invalid band, use Ful_offset as zero");
    ful_offset = 0;
  }
  ful = (2*freq + ful_offset);
  return ful;
}


/*===========================================================================

FUNCTION          rrcllcpcie_check_for_duplicate_rl_entry

DESCRIPTION       This function checks for duplicate RL entries in OC

DEPENDENCIES      None

RETURN VALUE      None

SIDE EFFECTS      None
===========================================================================*/

uecomdef_status_e_type rrcllcpcie_check_for_duplicate_rl_entry(void)
{
  uint8 ix,jx;
  for (ix=0;ix<ordered_config_ptr->l1_dl_chan_parms.num_rl; ix++)
  {
    for (jx=ix+1; jx< ordered_config_ptr->l1_dl_chan_parms.num_rl; jx++)
    {
      if (ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[ix].pri_cpich_scr_code == 
           ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[jx].pri_cpich_scr_code)
      {
        WRRC_MSG1_ERROR("RRC_DEBUG:Duplicate RL entry found in OC for %d",
                    ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[ix].pri_cpich_scr_code);
        return FAILURE;
      }
    }
  }
  return SUCCESS;
}
#ifdef FEATURE_WCDMA_REL9


/*============================================================================
FUNCTION: rrcllcpcie_process_dl_hspdsch_info_and_update_hsdpa_msg_params_r9()

DESCRIPTION:
  This function updates IE "dl hspdsch info " in ordered config and update
  hsdpa_msg_param variable
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r9
(
  OSS_UINT32 dl_hspdsch_info_present,
  rrc_DL_HSPDSCH_Information_r9 *dl_hspdsch_info_ptr,
  /* is inter freq handover involved */
  OSS_UINT32 is_ifhho_involved,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  /*We need to process HSDPA related IE DL_HSPDSCH_Information only in Cell_DCH state.*/
  if (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
  {
    /* If InterF HO is happening, then set the flags in hsdpa_msg_params appropriately.*/
    if (is_ifhho_involved)
    {
      WRRC_MSG0_HIGH("REL9:InterFreq HO is happening thru OTA.");
      hsdpa_msg_params.ifhho_involved = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }

    /*If IE rrc_DL_HSPDSCH_Information_r9 is present.*/
    if(dl_hspdsch_info_present)
    {
      hsdpa_msg_params.msg_params_present = TRUE;
      hsdpa_msg_params.hspdsch_info_present = TRUE;

      /*Process the 64 QAM IE if present.*/    
      ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = FALSE;

      if(RRC_CHECK_MSG_TYPE(dl_hspdsch_info_ptr->modeSpecificInfo, 
                  T_rrc_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd))
      {
        if(RRC_CHECK_MSG_TYPE_IE_PTR(dl_hspdsch_info_ptr->modeSpecificInfo.u.fdd, 
                   dl_64QAM_ConfiguredPresent))
        {
          /*If HSDPA CAT of the UE supports 64 QAM then set it in L1 HSDPA Info.*/
          if(CHECK_WCDMA_OPTIONAL_FEATURE_64QAM_SUPPORTED)
          {
            ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = TRUE;
            WRRC_MSG0_HIGH("REL9:64QAM is being started/continued");
          }
          else
          {
            WRRC_MSG1_HIGH("REL9:64QAM not supported with NV HSDPA-CAT %d :(",nv_hsdpa_category);
            return FAILURE;
          }
        }
      }
      else if(RRC_CHECK_MSG_TYPE(dl_hspdsch_info_ptr->modeSpecificInfo, 
                 T_rrc_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd))
      {
         return FAILURE;
      }

      /*If 64 QAM status is being changed by the OTA, then set the flag hsdsch_info_present in hsdpa_msg_params*/
      if(current_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured != 
        ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured)
      {
        hsdpa_msg_params.hsdsch_info_present = TRUE;

        WRRC_MSG2_HIGH("REL9:Set HSDSCH bitmask for 64QAM. Before %d, current %d (0:Not present/1:Present)",
            current_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured ,
             ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured);
      }

    }

    if(rrcllc_set_macehs_or_machs_and_check_if_coexist()== TRUE)
    {
      WRRC_MSG2_HIGH("REL9:MAC-ehs %d and MAC-hs %d cant co-exist ",
                          ordered_config_ptr->mac_dl_parms.num_mac_ehs_queue, 
                          ordered_config_ptr->mac_dl_parms.num_dflow);
      return FAILURE;
    }
    rrcllc_set_machs_ehs_transition();

    /* Set HSDPA Action & Physical Channel Parameters associated with it */
    if ((rrcllc_determine_hsdpa_action_r9(dl_hspdsch_info_ptr) == SUCCESS) 
#ifdef FEATURE_MAC_I
         && 
        (rrcllc_is_maci_compatible_with_hsdpa() == SUCCESS)
#endif
       )
    {
      rrc_set_hsdpa_action_in_machs_macehs();

      if(((ordered_config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_HS_TO_EHS )
        ||(ordered_config_ptr->mac_dl_parms.mac_hs_transition_type == MAC_EHS_TO_HS ))
        && (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE))
      {
        WRRC_MSG2_ERROR("REL9:MAC-hs <-> MAC-ehs transition type %d, But MAC-reset ind is %d!",
              ordered_config_ptr->mac_dl_parms.mac_hs_transition_type,
              ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);
        return FAILURE;
      }
#ifdef FEATURE_WCDMA_HS_FACH
     /*for EFACH to MAC-HS transition*/
      if((ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS) &&
         (ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator == FALSE)&&
         (current_config_ptr->hs_status_in_e_fach == TRUE))
      {
        /* The IE mac_hs_reset_indicator is not needed in the HANDOVER TO UTRAN
           COMMAND and the RRC CONNECTION SETUP messages. Otherwise, it is optional.*/
        if (RRC_STATE_CONNECTING != rrc_get_state())
        {         
        WRRC_MSG2_ERROR("MAC-EHS ->  MAC-HS transition %d, and Mac Reset Ind not set %d, reject config",
                ordered_config_ptr->mac_dl_parms.mac_hs_transition_type,
                ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator);
        return FAILURE;
      }
     }
#endif

      /*Validation check for 64 QAM and HSDPA type. 64 QAM is supported for MAC-ehs only right now.*/
      if((ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE) &&
        ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
        (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
        ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
        (rrc_get_hsdpa_status() == HSDPA_ACTIVE))))
      {
        if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
        {
          WRRC_MSG0_ERROR("REL9:64QAM cannot be started on MAC-HS.");
          return FAILURE;
        }
      }

     WRRC_MSG5_MED("HSDPA :Action %d set in MAC and HS+CM enabled %d CM status L1/RRC/OTA %d %d %d",
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action,hsdpa_cm_enabled,
      l1_cm_query_compressed_mode_active(),
               rrcllc_is_cm_active(ordered_config_ptr),cm_status_from_ota_msg);

      /* Check if network is trying to activate CM with HSDPA */
      if (hsdpa_cm_enabled == FALSE)
      {
        /* Check if network is trying to activate CM with HSDPA */
        if ((((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
            (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
            ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
            (rrc_get_hsdpa_status() == HSDPA_ACTIVE))) && 
            (rrcllc_is_cm_active(ordered_config_ptr) == TRUE)) ||

            /*At L1 CM is not active but OTA is trying to activate CM with HSDPA start.*/  
            ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) &&
            (l1_cm_query_compressed_mode_active() == FALSE) &&
            (cm_status_from_ota_msg == ACTIVATE_CM)) ||

            /*At L1 CM is active but OTA is not doing giving any CM and trying to start HSDPA.*/ 
            ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) &&
            (l1_cm_query_compressed_mode_active() == TRUE) &&
            (cm_status_from_ota_msg == RRC_CM_NONE)))
        {
          WRRC_MSG0_HIGH("REL9:CM with HSDPA Active!");
          return FAILURE;
        }
      }
    }
    else
    {
      WRRC_MSG0_ERROR("REL9:Error in determining HSDPA action!");  
      return FAILURE;
    }

    /*By now HSDPA action and type of HSDPA (hs or ehs) should have been decided*/
    if((RRC_CHECK_MSG_TYPE(dl_hspdsch_info_ptr->modeSpecificInfo, 
        T_rrc_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd))
        && (RRC_CHECK_MSG_TYPE_IE_PTR(dl_hspdsch_info_ptr->modeSpecificInfo.u.fdd, 
             hs_DSCH_TBSizeTablePresent)))
    {
      rrcllcpcie_update_hs_tfri_table_type(TRUE);
    }
    else
    {
         /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
         
      if((dl_hspdsch_info_present)
         || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
         || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
        )
      {
        rrcllcpcie_update_hs_tfri_table_type(FALSE);
      }
    }
  } /*only if the next state is Cell_DCH*/

  return(SUCCESS);
}




/*============================================================================
FUNCTION: rrcllcpcie_process_ul_e_dch_information_r9()

DESCRIPTION:
  This function updates IE "ul e dch information" in ordered config
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_ul_e_dch_information_r9
(
  OSS_UINT32 e_dch_info_present,
  rrc_UL_EDCH_Information_r9 *e_dch_info_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  uecomdef_status_e_type status = SUCCESS;
  /* Look into this IE only if next UE state is DCH */
  if (e_dch_info_present && 
      (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
     )
  {
    if ((RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr, 
               mac_es_e_resetIndicatorPresent)) &&
        (rrc_UL_EDCH_Information_r9_mac_es_e_resetIndicator_true == e_dch_info_ptr->mac_es_e_resetIndicator))
    {
      ordered_config_ptr->mac_e_reset_indicator = TRUE;
    }
    else
    {
      ordered_config_ptr->mac_e_reset_indicator = FALSE;
    }

    if(RRC_CHECK_MSG_TYPE(e_dch_info_ptr->modeSpecificInfo, 
                  T_rrc_UL_EDCH_Information_r9_modeSpecificInfo_fdd))
      {
       if(FAILURE == rrcllcpcie_process_e_dpcch_info_r7(
           RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd,
             e_DPCCH_InfoPresent),
           &e_dch_info_ptr->modeSpecificInfo.u.fdd->e_DPCCH_Info))
       {
         return(FAILURE);
       }
  
      if (FAILURE == rrcllcpcie_process_e_dpdch_info_r8(
          RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd, 
                  e_DPDCH_InfoPresent),
          &e_dch_info_ptr->modeSpecificInfo.u.fdd->e_DPDCH_Info))
      {
        return(FAILURE);
      }
  
      rrcllcpcie_process_sched_tx_config(
        RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd, 
                   schedulingTransmConfigurationPresent),
        &e_dch_info_ptr->modeSpecificInfo.u.fdd->schedulingTransmConfiguration,
        &ordered_config_ptr->l1_e_info.e_dl_info,
        &ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info
        );   
#ifdef FEATURE_WCDMA_16_QAM
       status = rrcllcpcie_process_16qam_params(RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd,ul_16QAM_SettingsPresent), 
                                       &e_dch_info_ptr->modeSpecificInfo.u.fdd->ul_16QAM_Settings);
       rrcllcpcie_modify_e_tfci_table();
#else 
      if(RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_info_ptr->modeSpecificInfo.u.fdd, 
                   ul_16QAM_SettingsPresent))
      {
        WRRC_MSG0_ERROR("RRCHSPA+: UL 16QAM not supported ");
      }
#endif
    }
  }

  return(status);
}




/*====================================================================
FUNCTION      set_hsscch_info_r9()

DESCRIPTION   This function sets the Channelization code required
              for HSPDSCH in L1 structure in OC.

DEPENDENCIES  None

RETURN VALUE  SUCCESS if the entire operation is successful,
              FAILURE otherwise

SIDE EFFECTS  None.
====================================================================*/
uecomdef_status_e_type set_hsscch_info_r9
(
  rrc_HS_SCCH_Info_r9* hsscch_info_ptr
)
{
  struct rrc_HS_SCCH_Info_r9_hS_SCCHChannelisationCodeInfo *hsscch_list_ptr = NULL;
  uint8 cnt = 0;
  uint8 n_value = 0;
  uint8 n_index = 0;

  ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code_valid = FALSE;

  if(hsscch_info_ptr->modeSpecificInfo.t == T_rrc_HS_SCCH_Info_r9_modeSpecificInfo_tdd)
  {
    return FAILURE;
  }

  /* Sec Scr Code unsupported by L1 */
  if (RRC_CHECK_MSG_TYPE_IE_PTR(hsscch_info_ptr->modeSpecificInfo.u.fdd, 
                 dl_ScramblingCodePresent))
  {

    if ((hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode == 0) ||
        (hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode > 15))
    {
      WRRC_MSG1_ERROR("RRCHS:Incorrect Sec Scr Code %d", 
          hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode);
      return FAILURE;
    }

    ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code_valid = TRUE;

    ordered_config_ptr->l1_hsdpa_info.hs_scch_info.sec_scr_code = (uint8)
      hsscch_info_ptr->modeSpecificInfo.u.fdd->dl_ScramblingCode;
  }

  /* Channelization Codes always need to be a cummulative sum that network needs to specify.
  So initilize the number to 0 */


  ordered_config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code = 0;

  hsscch_list_ptr = &(hsscch_info_ptr->modeSpecificInfo.u.fdd->hS_SCCHChannelisationCodeInfo);
  n_value = hsscch_list_ptr->n;

  while ((n_value != 0) && (cnt < L1_DL_HS_SCCH_CODES_MAX))
  {
    /* Spec allows allows channelisation code 0 also but since MSM6275 will
    not support secondary scrambling code, it will collide with OVSF 0 and 1
    on SF 256 for CPICH and PCCPCH channels. */
    if ((hsscch_list_ptr->elem[n_index] > RRCLLC_MAX_SCCH_CHAN_CODE) || (hsscch_list_ptr->elem[n_index] == 0))
    {
      WRRC_MSG1_ERROR("RRCHS:Invalid Channelization code %d", hsscch_list_ptr->elem[n_index]);
      return FAILURE;
    }
    ordered_config_ptr->l1_hsdpa_info.hs_scch_info.ch_code[cnt++] = (uint8) hsscch_list_ptr->elem[n_index];

    n_value--;
    n_index++;
  }

  ordered_config_ptr->l1_hsdpa_info.hs_scch_info.num_ch_code = cnt;



  return SUCCESS;

}


/*===========================================================================
FUNCTION        get_rl_add_info_r9()

DESCRIPTION     This function translates radio link addition information from
                a radio link addition list into the RRC config database. This
                function is only called from an Active Set Update Message

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    The RRC config database as pointed to by the input parameters
                will be updated.
===========================================================================*/
uecomdef_status_e_type get_rl_add_info_r9
(
  rrc_RL_AdditionInformation_r9 *ie_ptr,
  l1_dl_phychan_db_struct_type *dl_phychan,
  boolean *duplicate_add_attempted
)
{
  /* local loop variable */
  uint8 ix;

  *duplicate_add_attempted = FALSE;

  /* Check to determine if this is a duplicate radio link.  If so, return
     SUCCESS, since that's not an error and there's no more work to be done. */
  for(ix = 0; ix < ordered_config_ptr->l1_dl_chan_parms.num_rl; ix++)
  {
    if(dl_phychan->dl_per_rl[ix].pri_cpich_scr_code ==
       ie_ptr->primaryCPICH_Info.primaryScramblingCode)
    {
      /* we may want to add the processing of the IEs instead of ignoring RL info */
      WRRC_MSG1_ERROR("REL9:ASU trying to add PSC %d -already part of AS - ignoring RL info", 
        ie_ptr->primaryCPICH_Info.primaryScramblingCode);
      *duplicate_add_attempted = TRUE;
      return SUCCESS;
    }
  }

  /* look for the first available radio link slot that is available */
  for(ix = 0; ix < UE_MAX_RL; ix++)
  {
    /* look in the ordered_config database for this radio link */
    if(dl_phychan->dl_per_rl[ix].pri_cpich_scr_code == RRCLLC_INVALID_CPICH_SCR_CODE)
    {
      /* Get the Primary Scrambling Code */
      if(ie_ptr->primaryCPICH_Info.primaryScramblingCode <= RRCLLC_MAX_CPICH_SCR_CODE)
      {
        /*If Cell_id is present for this RL, store it in cell_id_per_rl */      
        if(RRC_CHECK_MSG_TYPE_IE_PTR(ie_ptr,
                    cell_IdPresent))
        {
          cell_id_per_rl[ix] = (uint32) rrc_translate_cell_id(&ie_ptr->cell_Id);
        } 
        dl_phychan->dl_per_rl[ix].pri_cpich_scr_code = (uint16)ie_ptr->primaryCPICH_Info.primaryScramblingCode;
      }
      else
      {
        WRRC_MSG1_ERROR("REL9:PRI SCR CODE %d is out of range", ie_ptr->primaryCPICH_Info.primaryScramblingCode);
        return FAILURE;
      }
      
      /* This is the first open RL slot, so place the info here */
      if (RRC_CHECK_MSG_TYPE(ie_ptr->dl_dpchInfo, 
                    T_rrc_RL_AdditionInformation_r9_dl_dpchInfo_dl_DPCH_InfoPerRL))
      {
        if(get_dl_dpch_info_for_each_rl_r5(ie_ptr->dl_dpchInfo.u.dl_DPCH_InfoPerRL,
          dl_phychan, ix, TRUE) == FAILURE)
        {
        /* bad status from get_dl_dpch_info_for_each_rl.  Return FALSE
          indicating an error */
          WRRC_MSG0_HIGH("REL9:get_dl_dpch_info_for_each_rl_r5() failed!");
          return FAILURE;
        }
      }
      else
      {
        if(get_dl_fdpch_info_for_each_rl_r7(ie_ptr->dl_dpchInfo.u.dl_FDPCH_InfoPerRL,
          dl_phychan, ix, TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
          , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ))
        {
        /* bad status from get_dl_dpch_info_for_each_rl.  Return FALSE
          indicating an error */
          WRRC_MSG0_HIGH("REL9:get_dl_fdpch_info_for_each_rl_r7() failed");
          return FAILURE;
        }
      }
      /* Ignore the SCCPCH/FACH and TFCI combining info for now */
      /* No need to continue */
      break;
    } /* end RL match if */
  } /* end looking for open RL slot */
  
  /* everything is good if here */
  return SUCCESS;

}
/*============================================================================
FUNCTION: get_e_rl_index_for_a_given_psc_in_complete_list()

DESCRIPTION:
  This function find and returns the rl index for a given psc in e-dch active
  set database
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uint32 get_e_rl_index_for_a_given_psc_in_complete_list(uint32 psc , ordered_config_type *config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
, boolean is_sec_eul
#endif
)
{
  uint32 e_rl_idx = L1_MAX_EDCH_RL;

  l1_e_dl_info_struct_type *e_dl_info_ptr = NULL;

#ifdef FEATURE_WCDMA_DC_HSUPA
  if(is_sec_eul == TRUE)
  {
    e_dl_info_ptr = &config_ptr->l1_sec_e_info.e_dl_info;
  }
  else
#endif
  {
    e_dl_info_ptr = &config_ptr->l1_e_info.e_dl_info;
  }
  for (e_rl_idx=0;e_rl_idx < L1_MAX_EDCH_RL; e_rl_idx++)
  {
    if (psc == e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_rl_psc)
    {
      break;
    }
  }
  return(e_rl_idx);
}

#ifdef FEATURE_WCDMA_DC_HSUPA

/*============================================================================
FUNCTION: rrcllcpcie_check_and_update_sec_e_active_set_and_remove_info()

DESCRIPTION:
  This function find and returns the rl index for a given psc in sec e-dch active
  set database
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static void rrcllcpcie_check_and_update_sec_e_active_set_and_remove_info
(
  uint32 removed_psc
)
{
  uint32 e_rl_idx;

  for (e_rl_idx = 0; e_rl_idx < ordered_config_ptr->l1_sec_e_info.e_dl_info.
    num_e_dl_rl_add_recfg_info; e_rl_idx++)
  {
    if ((e_rl_idx < L1_MAX_EDCH_RL) && (ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[e_rl_idx].
       e_rl_psc == removed_psc)/* && 
       (ordered_config_ptr->e_dch_transmission == TRUE) - even if E-DCH is not up we need to maintain the database */)
    {
      /* no need to check for returned value because we dont expect this function
         call to fail from this point */
      (void) rrcllcpcie_remove_rl_from_e_dch_active_set(e_rl_idx, removed_psc
#ifdef FEATURE_WCDMA_DC_HSUPA
      ,TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
      );

      /* update the l1_e_req_mask */
      rrcllc_update_l1_sec_e_req_mask_for_e_dl_info(TRUE);
      break;
    }
  }
} /* rrcllcpcie_update_e_active_set_and_e_removal_list */


/*====================================================================
FUNCTION        get_dl_rl_idx_to_update()

DESCRIPTION     This function retrieves the RL index for a given
                scrambling code in a Downlink information for each
                radio link IE

DEPENDENCIES    NONE

RETURN VALUE    RL index if found, UE_MAX_RL otherwise.

SIDE EFFECTS
====================================================================*/
uint8 get_sec_dl_rl_idx_to_update
(
  rrc_PrimaryScramblingCode pscr,
  l1_dl_phychan_db_struct_type *dl_phychan
)
{
  uint8 idx;

  for(idx = 0; idx < UE_MAX_RL; idx++)
  {

      if(dl_phychan->sec_dl_per_rl[idx].pri_cpich_scr_code ==
        pscr)
      {
        return idx;
      }
  }

  /* If we got all the way here, idx will be set to UE_MAX_RL. */
  return idx;
}

/*===========================================================================
FUNCTION        get_sec_dl_info_per_rl()

DESCRIPTION     This function validates and stores Downlink Information Per
                Radio Link for reconfiguration messages.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    Ordered config is updated with the new RL info.
===========================================================================*/
uecomdef_status_e_type get_sec_dl_info_per_rl
(
  rrc_DL_InformationPerSecondaryRL_List *ie_ptr,
  rrc_RRC_StateIndicator next_state
)
{
  uint8 idx = 0;
  uint8 rl_count = 0;
//  uint8 cnt = 0;
  boolean is_hho;
  boolean is_inter_freq;
  boolean old_rl_seen = FALSE;
  boolean new_rl_seen = FALSE;
//  boolean existing_hs_link_inactive = FALSE;
  boolean was_rl_db_empty = FALSE;

  uint32 n_index_ie=0;

  rrcllcoc_dl_info_per_rl_status_e_type status =
    RRCLLCOC_DL_INFO_PER_RL_IGNORED;
  rrc_state_e_type rrc_state = rrc_get_state();


  /* Reinitialize values */
  rl_count = 0;
  //tmp_ie_ptr = ie_ptr;
  n_index_ie = 0;

  /* We can say with certainty that if frequency info is included, and
  * it is different than the current frequency, then we are doing a
  * hard handover.  If this is not the case, we revisit this flag
  * later. */
  is_inter_freq = is_hho = (current_config_ptr ->sec_e_dch_transmission&&
    ordered_config_ptr->sec_eul_dest_freq != current_config_ptr->sec_eul_dest_freq);

  if((rrccsp_channel_locking_nv_status()) && !rrccsp_is_ue_in_true_limited_service() &&
      is_inter_freq )
  {
    WRRC_MSG0_HIGH("DC_HSUPA: Failing, inter-freq HHO not supported");
    return(FAILURE);
  }
  

  if(next_state == rrc_RRC_StateIndicator_cell_DCH)
  {

    /* Restore the Pointer */
    n_index_ie = 0;
    
    /* Did we have any radio links in our database previously? */
    was_rl_db_empty = (ordered_config_ptr->l1_dl_chan_parms.sec_num_rl== 0);

    if(rrc_state != RRC_STATE_CELL_DCH)
    {
      /* Going from non-DCH state to CELL DCH */
      /* Always set new_rl_seen when coming to DCH from a non-DCH state.
      * That ensures the RL Info is populated after initializing.
      */
      new_rl_seen = TRUE;

    }
    else       /* Going from DCH->DCH */
    {
    /* Unless we are doing an inter-frequency hard handover, we cannot
    * take a set of radio links that contains scrambling codes we
    * already have in our database as well as ones that we don't have
    * in our database. (25.331 8.6.6.3a)
      */

    /* For this scenario spec says UE behavior is unspecified but for legacy if its HHO we are accepting mixed active set so following 
            the same DC HSUPA as well */
      if(!is_inter_freq)
      {
        while(ie_ptr->n >  n_index_ie)
        {
          if(get_sec_dl_rl_idx_to_update( ie_ptr->elem[n_index_ie].primaryCPICH_Info.primaryScramblingCode,
                &ordered_config_ptr->l1_dl_chan_parms) <
                ordered_config_ptr->l1_dl_chan_parms.sec_num_rl)
          {
            old_rl_seen = TRUE;
          }
          else
          {
            new_rl_seen = TRUE;
          }

          /* We can bail out early if we detect a mixed active set. */
          if(old_rl_seen && new_rl_seen)
          {
            WRRC_MSG0_ERROR("DC_HSUPA: REL9:Mixed ASET detected, rejecting OTA!");
            return FAILURE;
          }
          n_index_ie++;
        }
      }
      else
      {
        /* New RLs always seen for Inter freq HHO */
        new_rl_seen = TRUE;
      }
    } /* DCH->DCH */
    n_index_ie = 0;
    while(ie_ptr->n >  n_index_ie)
    {
      if(rrc_state != RRC_STATE_CELL_DCH)
      {
        /* For a non-DCH to DCH transition, there is no existing RL Info */
        idx = rl_count;
      }
      else if(is_inter_freq)
      {
      /* We've found this radio link in our database, but we are
      * doing an inter-frequency hard handover, which means that
      * we are replacing the active set.  This is a case where
      * the primary scrambling code on the new frequency is the
      * same as on the old one.  We need to adjust our radio link
      * index accordingly, since we don't want to place the new
      * radio link into the database position of the old one.
        */
        idx = rl_count;
      }
      else /* DCH -> DCH AND Not Inter Freq */
      {
      /* Now look to see if this radio link is already in our
      * database.
        */
        idx =  get_sec_dl_rl_idx_to_update( ie_ptr->elem[n_index_ie].primaryCPICH_Info.primaryScramblingCode,
                            &ordered_config_ptr->l1_dl_chan_parms );
        

        if(idx == UE_MAX_RL)
        {
        /* This radio link is not in our database, which means we're
        * replacing our database with an entirely new set of radio
        * links.  We must reset the value of the database index to
        * the current radio link count.
          */
          idx = rl_count;

          is_hho = TRUE;

        } /* idx == UE_MAX_RL */
      } /* DCH -> DCH AND Not Inter Freq */

      /* Process the IE and place the info into our database. */
      status = get_sec_fdpch_info_for_each_rl(&ie_ptr->elem[n_index_ie],
        &ordered_config_ptr->l1_dl_chan_parms,
        idx,
        new_rl_seen);

      if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
      {
        return FAILURE;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS)
      {
        if(is_hho)
        {
        /* If we succeeded in processing the IE, and we are doing a
        * hard handover, we must be sure that L1 is informed by
        * sending frequency info, even if we didn't get frequency
        * info in the reconfiguration message.
          */
          if(!ordered_config_ptr->sec_eul_is_hho)
          {
            ordered_config_ptr->sec_eul_is_hho = TRUE;
            WRRC_MSG0_HIGH("DC_HSUPA::Disjoint ASET, intra-f HHO triggered");
          }
        }
      }

      rl_count++;
      n_index_ie++;
    }


  
    if(is_hho || was_rl_db_empty)
    {
      /* We've just replaced the contents of our radio link database, or
    * added radio links when we had none before, so we must update the
    * count of the radio links contained therein. */
      ordered_config_ptr->l1_dl_chan_parms.sec_num_rl = rl_count;

      /* Clear out old scrambling codes. */
      while(rl_count < UE_MAX_RL)
      {
        ordered_config_ptr->
          l1_dl_chan_parms.sec_dl_per_rl[rl_count++].pri_cpich_scr_code =
          RRCLLC_INVALID_CPICH_SCR_CODE;
      }
    }
  }
  else /* All states other than Cell_DCH */
  {
      WRRC_MSG0_HIGH("DC_HSUPA: in non DCH states secondary eul info need not be processed");
  }
  return SUCCESS;
} /* end get_sec_dl_info_per_rl() */

/*===========================================================================
FUNCTION        get_sec_eul_rl_remove_info()

DESCRIPTION     This function translates radio link removal information of sec Eul  from
                a radio link removal list into the RRC config database. This
                function is only called from an Active Set Update Message.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    The RRC config database as pointed to by the input parameters
                will be updated.
===========================================================================*/
uecomdef_status_e_type get_sec_eul_rl_remove_info
(
  rrc_PrimaryCPICH_Info *ie_ptr,
  l1_dl_phychan_db_struct_type *dl_phychan
)
{
  /* local loop variables */
  uint8 ix;
  uint8 iy;
 // uint32 cell_id_temp = INVALID_CELL_ID; /*this temp is used while shifting cell_id_per_list*/

  /* look in the ordered_config database for this radio link */
  for(ix = 0; ix < UE_MAX_RL; ix++)
  {
    if(ie_ptr->primaryScramblingCode == dl_phychan->sec_dl_per_rl[ix].pri_cpich_scr_code)
    {
      /* Clear out that RL */
      rrcllc_init_dl_rl_info(ordered_config_ptr, ix
#ifdef FEATURE_WCDMA_DC_HSUPA
                            ,TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */

                            );
      MSG_MED("Removed RL %d",ie_ptr->primaryScramblingCode,0,0);

      /* re-arrange the table to eliminate the gap */
      iy = ix;
      /*
      if(iy < (UE_MAX_RL - 1))
      {
        cell_id_temp = cell_id_per_rl[iy+1];
      }

      */
      while (iy < (UE_MAX_RL - 1) &&
             dl_phychan->sec_dl_per_rl[iy+1].pri_cpich_scr_code != RRCLLC_INVALID_CPICH_SCR_CODE)
      {
        MSG_MED("Move RL %d to slot %d",dl_phychan->sec_dl_per_rl[iy].pri_cpich_scr_code,iy,0);

        /* Move the next slot up */
        dl_phychan->sec_dl_per_rl[iy] = dl_phychan->sec_dl_per_rl[iy+1];

        /*Since RL at index is has been removed, we need to update the cell_id_per_rl
        list also.*/            
//        cell_id_per_rl[iy] = cell_id_temp;

        /* Clear out old used slot */
        iy++;
//        cell_id_temp = cell_id_per_rl[iy];
        rrcllc_init_dl_rl_info(ordered_config_ptr, iy
#ifdef FEATURE_WCDMA_DC_HSUPA
                            ,TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */

                            );
      }

      /* No valid RL needs to be moved */
      return SUCCESS;
    }
  }

  WRRC_MSG1_ERROR("RL %d not removed",ie_ptr->primaryScramblingCode);
  return FAILURE;

} /* end get_rl_remove_info() */


/*============================================================================
FUNCTION: rrcllcpcie_process_e_agch_info_sec_eul()

DESCRIPTION:
  This function processes e-AGCH information and updates the information
  in a given e_rl_index
      
DEPENDENCIES:
  This function needs to be called only after calling function to process E-HICH info.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_e_agch_info_sec_eul
(
  OSS_UINT32 e_agch_info_present,
  rrc_E_AGCH_Information *e_agch_info_ptr,
  uint32 psc
)
{
  uint32 e_rl_idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_sec_e_info.e_dl_info;

    if(e_agch_info_present)
      {

        e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
            , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
            );

        if ((e_rl_idx >= L1_MAX_EDCH_RL) || (e_rl_idx == e_dl_info_ptr->num_e_dl_rl_add_recfg_info))
        {
          WRRC_MSG2_ERROR("DC_HSUPA: psc:%d(idx: %d) not found in E-DCH RL database i.e. E-AGCH without E-HICH Info ",
            psc, e_rl_idx);
          return(FAILURE);
        }

        /* store RGCH info only if E-HICH info is already stored */
        if (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
          L1_E_HICH_INFO_PRESENT)
        {

          e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_agch_info.ch_code = 
            e_agch_info_ptr->e_AGCH_ChannelisationCode;
        }
        else
        {
          /* as per our current understanding NW should not provide E-AGCH info
             unless E-HICH is provided in config message or already stored in UE */
          WRRC_MSG0_ERROR("DC_HSUPA:: NW trying to provide E-AGCH info without E-HICH Info");
          return(FAILURE);
        }

        if (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
          L1_E_AGCH_INFO_PRESENT)
        {
          e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |=
            L1_E_AGCH_INFO_RECFG;
        }
        else
        {
          e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask |=
            L1_E_AGCH_INFO_ADD|L1_E_AGCH_INFO_PRESENT;
        }
      }
  return(SUCCESS);
}

/*===========================================================================
FUNCTION        get_fdpch_frame_offset_for_a_spec_psc()

DESCRIPTION     This function gives the fdpch frame offset of a perticulat RL of secondary EDCH active set.

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    
===========================================================================*/


static uint16 get_fdpch_frame_offset_for_a_spec_psc(uint16 psc, boolean is_sec_eul)
{

  uint8 rl_idx,max_rl_count;
  l1_dl_info_per_rl_struct_type *dl_info_ptr = NULL;

  if(is_sec_eul == TRUE)
  {
    max_rl_count = ordered_config_ptr->l1_dl_chan_parms.sec_num_rl;
    dl_info_ptr = ordered_config_ptr->l1_dl_chan_parms.sec_dl_per_rl;
  }
  else
  {
    max_rl_count = ordered_config_ptr->l1_dl_chan_parms.num_rl;
    dl_info_ptr = ordered_config_ptr->l1_dl_chan_parms.dl_per_rl;
  }

  for (rl_idx =0; rl_idx < max_rl_count;rl_idx++)
  {
    if(psc == dl_info_ptr[rl_idx].pri_cpich_scr_code)
      {
        return dl_info_ptr[rl_idx].dpch_per_rl.frame_offset;
      }
  }
  WRRC_MSG2_ERROR("DC_HSUPA: no fdpch entry for Psc %d and is_sec_eul =%d",psc,is_sec_eul);
  return 0;

}


/*====================================================================
FUNCTION        get_dl_fdpch_info_for_each_rl()

DESCRIPTION     This function translates the Downlink information for
                each radio link IE to the RRC config database

DEPENDENCIES    NONE

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise.

SIDE EFFECTS
====================================================================*/
rrcllcoc_dl_info_per_rl_status_e_type get_sec_fdpch_info_for_each_rl
(
  rrc_DL_InformationPerSecondaryRL *ie_ptr,

  l1_dl_phychan_db_struct_type *dl_phychan,

  uint8 rl_idx,

  boolean is_new_rl
)
{
  l1_dl_info_per_rl_struct_type *rl_info;

  if (rl_idx >= UE_MAX_RL)
  {
    /* radio link index too large, bail */
    WRRC_MSG1_ERROR("DC_HSUPA: Too many Radio Links %d", rl_idx);
    return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
  }

  MSG_MED("RRCHS:Get Dl Info per RL",0,0,0);

    /* snap a local pointer to the proper radio link element in the
      RRC config page */
      rl_info = &dl_phychan->sec_dl_per_rl[rl_idx];

      /* Get the Primary CPICH scrambling code */
      rl_info->pri_cpich_scr_code =
        (uint16) ie_ptr->primaryCPICH_Info.primaryScramblingCode;


      /* Get the DL DPCH info for this radio link */
      MSG_MED("Get DL FDPCH Info for RL %d", (rl_idx + 1), 0, 0);
      
      if (get_dl_fdpch_info_for_each_rl_r7(&ie_ptr->dl_FDPCHInfoPerRL_SecULFreq,
        dl_phychan, rl_idx,
        is_new_rl
#ifdef FEATURE_WCDMA_DC_HSUPA
          , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ) == FAILURE)
      {
        return RRCLLCOC_DL_INFO_PER_RL_FAILURE;
      }

      /* if we made it here we must be ok */
      /* Indicate that Downlink L1 needs to be configured */
//      ordered_config_ptr->reconfig_needed.sec_downlink_l1 = TRUE;

#if 0
      /* Although no new parameters for MAC have been received, MAC
      * still needs to be reconfigured so as to get the new CCTrCH
      * ID whenever Downlink L1 is reconfigured. This is due to the
      * interface requirements.
      */
      ordered_config_ptr->reconfig_needed.downlink_mac = TRUE;

#endif

      return RRCLLCOC_DL_INFO_PER_RL_SUCCESS;


  
} /* get_sec_dl_info_per_rl() */



/*============================================================================
FUNCTION: rrcllcpcie_update_lower_layer_action_for_dc_hsupa_params_r9()

DESCRIPTION: This function determines SEC EDCH actions for both MAC and L1

      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
boolean rrcllcpcie_update_lower_layer_action_for_dc_hsupa_params_r9
(
  rrc_UL_SecondaryCellInfoFDD * dc_hsupa_params,
  rrc_RRC_StateIndicator rrc_state,
  OSS_UINT32 dc_hudpa_params_present_ota

)
{

  /*The first check for the presence of DC-HSUPA params is done to check whether OTA is trying
  to stop DC-HSDPA if already started.*/
  /*The second check is for the case when DC-HSUPA params are given in the OTA yet it can't be
  started because of validation issues.*/
  
  if (FALSE == rrcllc_evaluate_sec_e_dch_transmission_variable(dc_hudpa_params_present_ota,rrc_state))
  {
    return FALSE;
  }

  if ((TRUE == ordered_config_ptr->sec_e_dch_transmission) &&
      (rrcueci_nv_supports_dc_hsupa() == FALSE))
  {
    {
      ERR_FATAL("DC_HSUPA: e_dch_txn variable TRUE when optional feature SEC EUL is NOT supported",
      0, 0, 0);
    }
  }

  /* when primary carrier HHO happens secondary should be de-activated so set sec_eul_is_hho to TRUE */
  if((TRUE == ordered_config_ptr->sec_e_dch_transmission)&&(ordered_config_ptr->sec_eul_is_hho != TRUE))
  {
    if(ordered_config_ptr->dest_freq_present)
      {
        ordered_config_ptr->sec_eul_is_hho = TRUE;
        rrcllcpcie_indicate_drop_and_add_of_e_dch_active_set_rl(
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                                  TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                                  );

      }
  }

  rrcllc_update_mac_sec_eul_action_and_l1_e_req_mask();

  rrcllc_update_l1_sec_e_info_for_new_e_dch_transmission(rrc_state);

    if(TRUE == ordered_config_ptr->sec_e_dch_transmission)
  {
    /*N/W may provide AGCH info for non eul serving RL. Currently L1 logic of detecting serving RL is based on 
     *AGCH info present it doesn't look at eul serving rl idx, So I don't indicate AGCH add/reconfig action for 
     *non-serving RL's. Later if this non-serving RL become serving EUL RL then we indicate AGCH as add even 
     *if N/W doesn't provide AGCH info in the reconfig message that trigger eul serving cell re-pointing, though 
     *spec clearly say N/W should provide AGCH info for serving rl but since some of the N/W doesn't comply with 
     *this we allow this kind of config 
     */
    rrcllc_clear_agch_chan_mask_for_non_serving_rl(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                );
  }
  return TRUE;

}


/*============================================================================
FUNCTION: rrcllcpcie_process_sec_serv_edch_info()

DESCRIPTION: This fnction processes information specific to secondary eul serving cell.

      
DEPENDENCIES:


RETURN VALUE:


SIDE EFFECTS:
=============================================================================*/


void rrcllcpcie_process_sec_serv_edch_info
(
  rrc_SecondaryServingEDCHCell_Info * sec_serv_edch_info
)
{

/*If either primary E-RNTI or secondary is not present in the sec serv edch info do we need to set the_rnti_present = FALSE?*/
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(sec_serv_edch_info,rrc_SecondaryServingEDCHCell_Info,primary_E_RNTI))
  {
    ordered_config_ptr->l1_sec_e_info.e_dl_info.primary_e_rnti_present = TRUE;
    (void)rrc_translate_ernti(&sec_serv_edch_info->primary_E_RNTI, &ordered_config_ptr->l1_sec_e_info.e_dl_info.primary_e_rnti);
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(sec_serv_edch_info,rrc_SecondaryServingEDCHCell_Info,secondary_E_RNTI))
  {
    ordered_config_ptr->l1_sec_e_info.e_dl_info.secondary_e_rnti_present= TRUE;
    (void)rrc_translate_ernti(&sec_serv_edch_info->secondary_E_RNTI, &ordered_config_ptr->l1_sec_e_info.e_dl_info.secondary_e_rnti);
  }

  if (ordered_config_ptr->l1_sec_e_info.e_dl_info.primary_e_rnti_present || ordered_config_ptr->l1_sec_e_info.e_dl_info.secondary_e_rnti_present)
  {
  
    uint16 serving_rl_idx;
    serving_rl_idx = ordered_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx;

    if (serving_rl_idx < L1_MAX_EDCH_RL)
    {
      /* check if AGCH info is present for serving RL, make sure that its not AGCH add and drop */
      if ((L1_E_AGCH_INFO_PRESENT & 
           ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[serving_rl_idx].e_dl_channel_mask) &&
           (! ((L1_E_AGCH_INFO_ADD | L1_E_AGCH_INFO_DROP) & 
           ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[serving_rl_idx].e_dl_channel_mask)))
      {
        /* indicate as reconfig */
        ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[serving_rl_idx].e_dl_channel_mask |= 
          L1_E_AGCH_INFO_RECFG;
      }
    }
    rrcllc_update_l1_sec_e_req_mask_for_e_dl_info(TRUE);
  }
    
}


/*============================================================================
FUNCTION: rrcllcpcie_validate_dc_hsupa_params()

DESCRIPTION: This function validates whether DC HSUPA and DC HSDPA frequency is same or not.

      
DEPENDENCIES:


RETURN VALUE:
E

SIDE EFFECTS:
=============================================================================*/

uecomdef_status_e_type rrcllcpcie_validate_dc_hsupa_params
(
void
)
{
  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_sec_e_info.e_dl_info;
  rrc_csp_band_class_type primary_band, second_band;
  uint32 pri_uarfcn=0, sec_uarfcn=0, pri_freq=0, sec_freq=0;
  uint8 ix=0;
/* checking whether frequency is same or not*/
/*
	8.6.6.4a Downlink information for each radio link on secondary UL frequency (FDD only) 
	For each of the IE "Downlink information for each radio link on secondary UL frequency" included in a received message, the UE shall: 
	1> if the UE would enter CELL_DCH state according to subclause 8.6.3.3 applied on the received message: 
	2> consider the radio link identified by the IE "Primary CPICH info" in the IE "Downlink secondary cell info FDD" as the secondary serving E-DCH radio link, and no longer consider any other radio link as secondary serving E-DCH radio link;
*/
  for(ix=0; ix<MAX_NUM_OF_SEC_CARRIERS; ix++)
  {
    if(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action == L1_SEC_HSDPA_RECFG)
    {
      WRRC_MSG2_HIGH("DCHSUPA_DEBUG:  ix:%d, action: %d",ix,ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].sec_hsdpa_action);
      break;
    }
  }

  if(ix >= MAX_NUM_OF_SEC_CARRIERS)
  {
    WRRC_MSG0_ERROR("DCHSUPA_DEBUG: DL sec carriers absent ");
    return FAILURE;
  }

  /* If DCHSUPA is continue and only DCHSDPA PSC is changed, serving PSCs become different on UL and DL. we will detect this and reject this configuration  */
  if((ordered_config_ptr->sec_eul_dest_freq!=
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].hs_sec_cell_dl_freq) || 
    (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_dl_info_ptr->e_serving_rl_idx].e_rl_psc != 
    ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].pri_cpich_scr_code))
  {
    MSG_4(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"DCHSUPA_DEBUG: DCHSUPA freq: %d,DCHSDPA freq : %d are diff, DCHSDPA serv-psc: %d, DCHSUPA serv-psc: %d",
        ordered_config_ptr->sec_eul_dest_freq, ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].hs_sec_cell_dl_freq,e_dl_info_ptr->e_dl_rl_add_recfg_info[e_dl_info_ptr->e_serving_rl_idx].e_rl_psc,
        ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].pri_cpich_scr_code);
    return FAILURE;
  }
#ifndef TEST_FRAMEWORK
  /* DCHSUPA frequncy should be contiguous with primary frequency */
  pri_uarfcn = (ordered_config_ptr->dest_freq_present == TRUE) ? ordered_config_ptr->dest_freq : rrc_ccm_get_curr_camped_freq();
  sec_uarfcn = ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[ix].hs_sec_cell_dl_freq;

  primary_band = rrc_get_frequency_band(pri_uarfcn,rrc_ccm_get_curr_camped_plmn());
  second_band = rrc_get_frequency_band(sec_uarfcn,rrc_ccm_get_curr_camped_plmn());
  
  if((primary_band!=RRC_CSP_BAND_MAX) && (second_band!=RRC_CSP_BAND_MAX)&& (primary_band == second_band))
  {
    pri_freq = rfm_get_freq_from_dl_arfcn(pri_uarfcn);
    sec_freq = rfm_get_freq_from_dl_arfcn(sec_uarfcn);
    
    if ((ABS((int32)(sec_freq-pri_freq)) < HS_DC_FREQ_KHZ_MIN_DIFF) ||
    (ABS((int32)(sec_freq-pri_freq)) > HS_DC_FREQ_KHZ_MAX_DIFF))
    {
        WRRC_MSG2_ERROR("DCHSUPA_DEBUG: DCHSUPA frequncy: %d and primary frequency: %d are not contiguous ",sec_freq,pri_freq);
        return FAILURE;
    }
  }
  else /* DCHSUPA frequency and primary frequency should be on the same band */
  {
    WRRC_MSG2_ERROR("DCHSUPA_DEBUG: DCHSUPA band: %d and primary band: %d are on different bands ",second_band,primary_band);
    return FAILURE;
  }
#endif
  return SUCCESS;

}

/*============================================================================
FUNCTION: rrcllcpcie_process_sec_edch_comm_info()

DESCRIPTION:This function processes common edch info of secondary EUL. If the secondary EUL
configuration is 'continue' this function will not get hit.

      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/

uecomdef_status_e_type rrcllcpcie_process_sec_edch_comm_info
(
  rrc_SecondaryEDCH_Info_Common * sec_edch_comm_info
)
{


  l1_e_dl_info_struct_type *e_sec_dl_info = NULL;
  l1_e_sec_ul_info_struct_type *e_sec_ul_info = NULL;

  e_sec_dl_info = &ordered_config_ptr->l1_sec_e_info.e_dl_info;
  e_sec_ul_info = &ordered_config_ptr->l1_sec_e_info.e_ul_info;


  if(validate_frequency_info(&sec_edch_comm_info->frequencyInfo) == FAILURE)
  {
    return FAILURE;
  }
  
  if(RRC_CHECK_COMMON_MSG_TYPE(sec_edch_comm_info->frequencyInfo.modeSpecificInfo,
        rrc_FrequencyInfo_modeSpecificInfo_fdd))
  {
    ordered_config_ptr->sec_eul_dest_freq = (rrc_freq_type)sec_edch_comm_info->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL;
  }

  

  /* Make sure that sec_eul_is_hho should be reset before processing edch info */  
 /* hho should be set to true when 
    configuring for the first time ,
    inter freq hho,
    disjoint active sets, 
    serving cell change, 
    when secondary or primary uplink frequeny changes */
 
    
  if(current_config_ptr->sec_e_dch_transmission == FALSE)
  {
    ordered_config_ptr->sec_eul_is_hho = TRUE;
  }
  else if (ordered_config_ptr->sec_eul_dest_freq != current_config_ptr->sec_eul_dest_freq)
  {
    ordered_config_ptr->sec_eul_is_hho = TRUE;
  }
/* copy scrambling code */
  switch (sec_edch_comm_info->scramblingCodeType)
  {
    case rrc_ScramblingCodeType_shortSC:
      e_sec_ul_info->dpcch_info.scrambling_code_type = L1_UL_SC_SHORT;
      break;
    case rrc_ScramblingCodeType_longSC:
      e_sec_ul_info->dpcch_info.scrambling_code_type = L1_UL_SC_LONG;
      break;
    default:
      WRRC_MSG1_ERROR("DC_HSUPA: DPCH Scrambling Code Type %d is invalid",
        sec_edch_comm_info->scramblingCodeType);
      return FAILURE;
  }
  if(sec_edch_comm_info->scramblingCodeNumber <= RRCLLC_MAX_UL_SCR_CODE)
  {
    e_sec_ul_info->dpcch_info.scrambling_code= (uint32)sec_edch_comm_info->scramblingCodeNumber;
  }
  else
  {
    WRRC_MSG1_ERROR("DC_HSUPA: Scrambling Code %d is out of range",
      sec_edch_comm_info->scramblingCodeNumber);
    return FAILURE;
  }

  if (RRC_CHECK_MSG_TYPE_IE_PTR(sec_edch_comm_info,
              ms2_SchedTransmGrantHARQAllocPresent))
  {
    ordered_config_ptr->mac_sec_eul_config.sched_tx_config.sched_tx_grant_harq_allocation_2ms = 
      rrcllcpcie_convert_asn1_oss_bitstring_to_uint8(
      &sec_edch_comm_info->ms2_SchedTransmGrantHARQAlloc);

  }
  else
  {
    ordered_config_ptr->mac_sec_eul_config.sched_tx_config.sched_tx_grant_harq_allocation_2ms = 0xFF;
  }

  if (RRC_CHECK_MSG_TYPE_IE_PTR(sec_edch_comm_info, 
               e_DCH_minimumSet_E_TFCIPresent))
  {
    ordered_config_ptr->mac_sec_eul_config.e_tfci_min_set =
      sec_edch_comm_info->e_DCH_minimumSet_E_TFCI;
  }
  else
  {
    ordered_config_ptr->mac_sec_eul_config.e_tfci_min_set = 
      MAC_E_TFCI_MIN_SET_NOT_PRESENT;
  }

  if (RRC_CHECK_MSG_TYPE_IE_PTR(sec_edch_comm_info, 
               servingGrantPresent))
  {

    if (rrc_E_DPDCH_SchedulingTransmConfiguration_primary_Secondary_GrantSelector_primary == 
      sec_edch_comm_info->servingGrant.primary_Secondary_GrantSelector)
    {
      e_sec_dl_info->grant_config.grant_selector = L1_E_PRIMARY_GRANT;
    }
    else
    {
      e_sec_dl_info->grant_config.grant_selector = L1_E_SECONDARY_GRANT;
    }

    /* If servingGrant selector is not present we dont need to inform anything to L1 */
    rrcllc_update_l1_sec_e_req_mask_for_e_dl_info(TRUE);
  }

  if (RRC_CHECK_MSG_TYPE_IE_PTR(sec_edch_comm_info,minReduced_E_DPDCH_GainFactorPresent))
  {
    e_sec_ul_info->e_min_beta_ed =
    rrcllcpcie_convert_asn1_minreduced_e_dpdch_gainfactor(
    sec_edch_comm_info->minReduced_E_DPDCH_GainFactor);
  }
  else
  {
    e_sec_ul_info->e_min_beta_ed = L1_E_MIN_BED_08; /* 8/15 default */
  }

  e_sec_ul_info->dpcch_info.pcp_len
              = (uint8)sec_edch_comm_info->pc_Preamble;

  /* Get the DPCCH Power Offset (value in dB) */
  if(sec_edch_comm_info->dpcchPowerOffset_SecondaryULFrequency <= RRCLLC_SEC_UL_DPCCH_PWR_OFFSET_MAX)
  {
	  /* For secondary we don't need to double as we did for primary*/
    e_sec_ul_info->dpcch_info.dpcch_pwr_offset =
      (int16) (sec_edch_comm_info->dpcchPowerOffset_SecondaryULFrequency );
  }
  else
  {
    WRRC_MSG1_ERROR("DC_HSUPA: DPCCH Power Offset %d is out of range",
      e_sec_ul_info->dpcch_info.dpcch_pwr_offset);
    return FAILURE;
  }

  rrcllc_update_mac_sec_eul_action(TRUE);
  rrcllc_update_l1_sec_e_req_mask_for_e_ul_info(TRUE);
  return SUCCESS;
}

/*============================================================================
FUNCTION: rrcllcpcie_check_for_sec_e_dch_repointing_and_set_agch_mask()

DESCRIPTION:
  This function checks whether its a secondary serving e-dch rl repointing scenario or not.
  If needed, it sets the AGCH channel mask accordingly for L1.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static void rrcllcpcie_check_for_sec_e_dch_repointing_and_set_agch_mask
(
  uint32 old_e_serving_rl_idx, /* current_config */
  uint32 new_e_serving_rl_idx /* ordered config */
)
{
  uint32 old_e_serving_rl_idx_new = 0;
  
  uint32 new_e_serving_rl_idx_old = 0;
  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_sec_e_info.e_dl_info;
  
  /* check if E-DCH transmission was up or not */
  if (TRUE == current_config_ptr->sec_e_dch_transmission)
  {
    /* check whether the serving cell is same or not */
    if (e_dl_info_ptr->e_dl_rl_add_recfg_info[new_e_serving_rl_idx].e_rl_psc !=
        current_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[
        old_e_serving_rl_idx].e_rl_psc)
    {
      WRRC_MSG2_HIGH("DC_HSUPA: Serving Cell Re-pointing detected from psc: %d, to psc: %d", 
        current_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[
        old_e_serving_rl_idx].e_rl_psc, 
        e_dl_info_ptr->e_dl_rl_add_recfg_info[new_e_serving_rl_idx].e_rl_psc);

    
      /* in case AGCH is already present in database(NOT PER SPEC), 
         so set this bit again to make sure */
      e_dl_info_ptr->e_dl_rl_add_recfg_info[new_e_serving_rl_idx].e_dl_channel_mask |= 
        L1_E_AGCH_INFO_ADD;
  
      /* if it is already present and NW provides this info again, then reset
         L1_E_AGCH_INFO_RECFG bit because its a serving rl repointing scenario */
      e_dl_info_ptr->e_dl_rl_add_recfg_info[new_e_serving_rl_idx].e_dl_channel_mask  &= 
        ~L1_E_AGCH_INFO_RECFG;
  
      /* recompute the old serving rl index in ordered config again because there
         is a possibility that RL might have been removed from e-dch active set
         by the config message */
      old_e_serving_rl_idx_new = get_e_rl_index_for_a_given_psc(
        current_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[
        old_e_serving_rl_idx].e_rl_psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

      new_e_serving_rl_idx_old = get_e_rl_index_for_a_given_psc_in_complete_list(
        ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[
        new_e_serving_rl_idx].e_rl_psc, current_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , TRUE
#endif
        );
  
      /* check whether old serving RL is already removed or not */
      if ((old_e_serving_rl_idx_new < e_dl_info_ptr->num_e_dl_rl_add_recfg_info) &&
          (old_e_serving_rl_idx_new < L1_MAX_EDCH_RL))
      {
        /* indicate AGCH drop in the bit-mask */
        e_dl_info_ptr->e_dl_rl_add_recfg_info[old_e_serving_rl_idx_new].e_dl_channel_mask |= 
          L1_E_AGCH_INFO_DROP;

          /*Reset L1_E_AGCH_INFO_RECFG bit because AGCH is getting dropped.
          consider this AGCH info as obsolete i.e. set as not present. 
          For re-pointing cases, clear off AGCH present flag for non-serving 
          cell so that AGCH info doesn't get carried forward. */
        e_dl_info_ptr->e_dl_rl_add_recfg_info[old_e_serving_rl_idx_new].e_dl_channel_mask &= 
          ~(L1_E_AGCH_INFO_RECFG|L1_E_AGCH_INFO_ADD|L1_E_AGCH_INFO_PRESENT);
      
        WRRC_MSG0_HIGH("DC_HSUPA: old serving rl is still present in the active set");
      }
      else if (new_e_serving_rl_idx_old >= L1_MAX_EDCH_RL)
        {
           WRRC_MSG0_HIGH("DC_HSUPA: New serving RL was not part of the AS before receiving this ASU");
           
          /* This is the case where serving cell is got added with the current OTA.  consider this case as HHO*/
          ordered_config_ptr->sec_eul_is_hho = TRUE;
          rrcllcpcie_indicate_drop_and_add_of_e_dch_active_set_rl(
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                                    TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                                    );
          
        }

      /* since its a re-pointing scneario - remove stored e-rnti's */

      /*  check if the below code is required for secondary eul aswell? */
      /*
      ordered_config_ptr->l1_e_info.e_dl_info.primary_e_rnti_present = FALSE;
      ordered_config_ptr->l1_e_info.e_dl_info.secondary_e_rnti_present = FALSE;      
      */
    }
  }
  else /* if E-DCH was not up prior to this reconfig message */
  {
    /* in case AGCH is already present in database(NOT PER SPEC), 
       so set this bit again to be on safer side */
    e_dl_info_ptr->e_dl_rl_add_recfg_info[new_e_serving_rl_idx].e_dl_channel_mask |= 
      L1_E_AGCH_INFO_ADD;
    
    e_dl_info_ptr->e_dl_rl_add_recfg_info[new_e_serving_rl_idx].e_dl_channel_mask &= 
      ~L1_E_AGCH_INFO_RECFG;
  }
}


/*============================================================================
FUNCTION: rrcllcpcie_process_sec_e_dl_info_per_rl()

DESCRIPTION:

      
DEPENDENCIES:This function processes dl info of each RL of secondary EUL active set.
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_sec_e_dl_info_per_rl
(
  rrc_DL_InformationPerSecondaryRL_List *dl_info_per_rl_list_ptr,  
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
    rrc_E_RGCH_Information * e_rgch_ptr= NULL;
    rrc_E_HICH_Information * e_hich_info_ptr =NULL;
    uint8 sec_hs_index = 0;

    for(sec_hs_index = 0; sec_hs_index < MAX_NUM_OF_SEC_CARRIERS; sec_hs_index++)
    {
      if(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[sec_hs_index].sec_hsdpa_action == L1_SEC_HSDPA_RECFG)
      {
        break;
      }
    }

  /* Look into this IE only if next UE state is DCH */
  if (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
  {
    uint32 psc = 0;
    boolean is_e_dl_info_present = FALSE;
    rrc_DL_InformationPerSecondaryRL_List *tmp_ie_ptr = dl_info_per_rl_list_ptr;
    boolean is_need_to_honor_e_rl_rel_ind = TRUE;
    uint32 n_value=0, n_index=0;
    uint8 serving_rl_idx = L1_MAX_EDCH_RL;
    /* Firt time into DCH is also considered a HHO.  So only populate the release list of 
     * EDCH in the case of DCH->DCH only
     */
    if ((ordered_config_ptr->sec_eul_is_hho == TRUE )&& (current_config_ptr ->sec_e_dch_transmission != FALSE))
    {
      /* if its inter-freq handover then clear any stored E-Channel information.
         Also indicate layer1 about the release psc's */
      rrcllcpcie_release_and_clear_all_e_dch_active_set_rl(
#ifdef FEATURE_WCDMA_DC_HSUPA
      TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
      );
      is_need_to_honor_e_rl_rel_ind = FALSE;
    }

    /* loop through all the rls informations to extract e-dch related info */
    n_value = tmp_ie_ptr->n;
    
    while (n_value != 0)
    {
        psc = tmp_ie_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode;

        /* check if any E-Channel related info is present in this RL Info */
        if ((RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index], 
                     e_HICH_InformationPresent)) ||
            (RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index], 
                     e_RGCH_InfoPresent)) ||
            (RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index], 
                   e_AGCH_InformationPresent))
           )
        {
          /* if we are inside this if check then it means that RRC needs to indicate
             to L1 that some of the parameters in DL has changed */
          is_e_dl_info_present = TRUE;

          if(RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index],
                                  e_HICH_InformationPresent))
          {
            e_hich_info_ptr= &tmp_ie_ptr->elem[n_index].e_HICH_Information;
          }
          else
          {
            e_hich_info_ptr=NULL;
          }

          if (FAILURE == rrcllcpcie_process_e_hich_info(
            RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index], 
                     e_HICH_InformationPresent), 
            e_hich_info_ptr,
            psc,
            is_need_to_honor_e_rl_rel_ind
#ifdef FEATURE_WCDMA_DC_HSUPA
            , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
            ))
          {
            return(FAILURE);
          }
          if((RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index],
                               e_RGCH_InfoPresent)) && 
             (RRC_CHECK_MSG_TYPE(tmp_ie_ptr->elem[n_index].e_RGCH_Info ,
         T_rrc_DL_InformationPerSecondaryRL_e_RGCH_Info_e_RGCH_Information))
            )
          {
            e_rgch_ptr = tmp_ie_ptr->elem[n_index].e_RGCH_Info.u.e_RGCH_Information;
          }
          else
          {
            /* This means that the E-RGCH Info IE is not present*/
            e_rgch_ptr = NULL;
          }

          if (FAILURE == rrcllcpcie_process_e_rgch_info(
            RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index], 
                      e_RGCH_InfoPresent), 
            e_rgch_ptr,
            psc,
            is_need_to_honor_e_rl_rel_ind
#ifdef FEATURE_WCDMA_DC_HSUPA
          ,TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
           ))
          {
            return(FAILURE);
          }
            
          if (FAILURE == rrcllcpcie_process_e_agch_info_sec_eul(
            RRC_CHECK_MSG_TYPE_IE(tmp_ie_ptr->elem[n_index], 
                       e_AGCH_InformationPresent), 
            &tmp_ie_ptr->elem[n_index].e_AGCH_Information,
            psc))
          {
            return(FAILURE);
          }
        }/* if any E-info IE is present */

      n_value--;
      n_index++;
    }/* while */


    /*  set the serving RL index taking PSC info  from DC HSDPA info  */
    /*  Need to check if it is okay to cal thsbelow fun to get the serv RL index because inside the function we are chekcing agaist num_e_dl_rl_add_recfg_info
                              so what is we are not reconfiguring serv edch rl at this point*/

    if(sec_hs_index < MAX_NUM_OF_SEC_CARRIERS)
    {
      ordered_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx = get_e_rl_index_for_a_given_psc(
                                                ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[sec_hs_index].pri_cpich_scr_code,
                                                ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );
    }
    else
    {
      WRRC_MSG1_HIGH("DC_HSUPA:Invalid sec_hs_index:%d",sec_hs_index);
      return(FAILURE);
    } 
    if ((L1_MAX_EDCH_RL <= ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx) || (L1_MAX_EDCH_RL <= ordered_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx))
    {
     
     WRRC_MSG2_HIGH("DC_HSUPA:serving cell is  not present.%d, %d",ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx,ordered_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx);
      return(FAILURE);
    }

    /*  NOTE:	UTRAN should configure the same value of IE "F-DPCH frame offset" for the serving E-DCH radio link and the secondary serving E-DCH radio link, 
    otherwise the UE behaviour is unspecified.
    */
   if(get_fdpch_frame_offset_for_a_spec_psc(
         ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx].e_rl_psc, FALSE) !=
         get_fdpch_frame_offset_for_a_spec_psc(ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[ordered_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx].e_rl_psc, TRUE))
    {
      WRRC_MSG0_ERROR("DC_HSUPA: Primary and secondary EUL fdpch frame offsets are different");
      return FAILURE;
    }

    if (FAILURE == rrcllcpcie_validate_hich_rgch_info(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
      , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */

      ))
    {
      return(FAILURE);
    }

    serving_rl_idx = ordered_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx;
    if ((ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[serving_rl_idx].e_dl_channel_mask & 
    L1_E_AGCH_INFO_PRESENT) && 
    (ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[serving_rl_idx].e_dl_channel_mask & 
    L1_E_HICH_INFO_PRESENT))
    {

      rrcllcpcie_check_for_sec_e_dch_repointing_and_set_agch_mask(
        current_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx,
        ordered_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx);
    }
    else
    {
      /* 8.6.6.4a, 
          NOTE: The UTRAN should always include the IE "E-AGCH info" if the secondary serving E-DCH radio link indicated in the message is another radio link than the secondary serving E-DCH radio link prior to the procedure.
          */
      WRRC_MSG0_ERROR("DCHSUPA: Secondary serving RL without AGCH or HICH");
    }
    /* update the l1_e_req_mask */
    rrcllc_update_l1_sec_e_req_mask_for_e_dl_info(is_e_dl_info_present);
  }/* dl_info_per_rl_list_present */
  return(SUCCESS);
}


/*============================================================================
FUNCTION: rrcllcpcie_process_dc_hsupa_params()

DESCRIPTION:
  This function processes IE "UL_SecondaryCellInfoFDD" content in ordered config for R9 OTAs. Basically,
  this function updates the OC with the IE content and does some valiadation.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_dc_hsupa_params
(
  rrc_UL_SecondaryCellInfoFDD * dc_hsupa_params,
  rrc_RRC_StateIndicator rrc_state,
  OSS_UINT32 dc_hudpa_params_present_ota
)
{
  uecomdef_status_e_type status = SUCCESS;  

  if((dc_hudpa_params_present_ota) &&(rrcueci_nv_supports_dc_hsupa() == FALSE))
  {
      WRRC_MSG0_HIGH("DC_HSUPA: NV doesn't support DC HSUPA .");
      return FAILURE;
  }
   if((rrcueci_nv_supports_dc_hsupa() == TRUE) &&
      (rrc_RRC_StateIndicator_cell_DCH == rrc_state) && 
      (rrcllcpcie_return_num_sec_hsdpa_carriers(ordered_config_ptr) != 0) &&
      (ordered_config_ptr->e_dch_transmission == TRUE))
    {
      if(ordered_config_ptr->sec_ul_asu == FALSE )
      {
        ordered_config_ptr->l1_sec_e_req_mask = L1_EUL_NOOP;
        ordered_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_NOOP;
      }

      if(dc_hudpa_params_present_ota)
      {
        if(RRC_CHECK_COMMON_MSG_TYPE_PTR(dc_hsupa_params, rrc_UL_SecondaryCellInfoFDD_continue_))
        {
            if(FALSE == ordered_config_ptr->sec_e_dch_transmission)
            {
                WRRC_MSG0_ERROR("DC-HSUPA continue signalled. DCHSUPA is not true");
                return FAILURE;
            }
            if( FAILURE == rrcllcpcie_validate_dc_hsupa_params())
            {
              return FAILURE;
            }
        }
        else if(RRC_CHECK_COMMON_MSG_TYPE_PTR(dc_hsupa_params, rrc_UL_SecondaryCellInfoFDD_newConfiguration))
        {
          /*secondary serving edch info will be processed after dl info per rl list becuase we need to set the AGCH REQ mask to reconfig if either primary or secondary ERNTI info
                    is present so process that at the end*/

          if(RRC_MSG_COMMON_BITMASK_IE_PTR(dc_hsupa_params->u.newConfiguration,rrc_UL_SecondaryCellInfoFDD_newConfiguration,secondaryEDCH_Info_Common))
          {
            status = rrcllcpcie_process_sec_edch_comm_info(&dc_hsupa_params->u.newConfiguration->secondaryEDCH_Info_Common);
          }
          if(status != FAILURE)
          {
            if(RRC_MSG_COMMON_BITMASK_IE_PTR(dc_hsupa_params->u.newConfiguration,rrc_UL_SecondaryCellInfoFDD_newConfiguration,dl_InformationPerSecondaryRL_List))
            {
              status = get_sec_dl_info_per_rl(&dc_hsupa_params->u.newConfiguration->dl_InformationPerSecondaryRL_List,rrc_state);
              if (status != FAILURE)
              {
                status = rrcllcpcie_process_sec_e_dl_info_per_rl(&dc_hsupa_params->u.newConfiguration->dl_InformationPerSecondaryRL_List,rrc_state);
              }
            }
          }
          if(status != FAILURE)
          {
            if(RRC_MSG_COMMON_BITMASK_IE_PTR(dc_hsupa_params->u.newConfiguration,rrc_UL_SecondaryCellInfoFDD_newConfiguration,secondaryServingEDCHCell_Info))
            {
              rrcllcpcie_process_sec_serv_edch_info(&dc_hsupa_params->u.newConfiguration->secondaryServingEDCHCell_Info);
            }
          }
        }
      }
  }
  else
  {
    if(dc_hudpa_params_present_ota)
    {
      WRRC_MSG3_HIGH("DC_HSUPA:Can't be started coz edch status is %d, rrc_state: %d, num_sec_carr: %d ",
      ordered_config_ptr->e_dch_transmission,
      rrc_state,
      rrcllcpcie_return_num_sec_hsdpa_carriers(ordered_config_ptr));
    }
    dc_hudpa_params_present_ota = 0;
  }

  if(rrcllcpcie_update_lower_layer_action_for_dc_hsupa_params_r9(dc_hsupa_params,
  rrc_state, dc_hudpa_params_present_ota) == FALSE)
  {
    status =  FAILURE;
  }
  return status;
}


/*===========================================================================
FUNCTION        get_sec_eul_rl_add_info_r9()

DESCRIPTION     This function translates radio link addition information from
                a radio link addition list into the RRC config database. This
                function is only called from an Active Set Update Message

RETURN VALUE    SUCCESS if all goes well, FAILURE otherwise

SIDE EFFECTS    The RRC config database as pointed to by the input parameters
                will be updated.
===========================================================================*/
uecomdef_status_e_type get_sec_eul_rl_add_info_r9
(
  rrc_RL_AdditionInformation_SecULFreq *ie_ptr,
  l1_dl_phychan_db_struct_type *dl_phychan,
  boolean *duplicate_add_attempted
)
{
  /* local loop variable */
  uint8 ix;

  *duplicate_add_attempted = FALSE;

  /* Check to determine if this is a duplicate radio link.  If so, return
     SUCCESS, since that's not an error and there's no more work to be done. */
  for(ix = 0; ix < ordered_config_ptr->l1_dl_chan_parms.sec_num_rl; ix++)
  {
    if(dl_phychan->sec_dl_per_rl[ix].pri_cpich_scr_code ==
       ie_ptr->primaryCPICH_Info.primaryScramblingCode)
    {
      /* we may want to add the processing of the IEs instead of ignoring RL info */
      WRRC_MSG1_ERROR("DC_HSUPA:ASU trying to add PSC %d -already part of AS - ignoring RL info", 
        ie_ptr->primaryCPICH_Info.primaryScramblingCode);
      *duplicate_add_attempted = TRUE;
      return SUCCESS;
    }
  }

  /* look for the first available radio link slot that is available */
  for(ix = 0; ix < UE_MAX_RL; ix++)
  {
    /* look in the ordered_config database for this radio link */
    if(dl_phychan->sec_dl_per_rl[ix].pri_cpich_scr_code == RRCLLC_INVALID_CPICH_SCR_CODE)
    {
      /* Get the Primary Scrambling Code */
      if(ie_ptr->primaryCPICH_Info.primaryScramblingCode <= RRCLLC_MAX_CPICH_SCR_CODE)
      {
        dl_phychan->sec_dl_per_rl[ix].pri_cpich_scr_code = (uint16)ie_ptr->primaryCPICH_Info.primaryScramblingCode;
      }
      else
      {
        WRRC_MSG1_ERROR("DC_HSUPA:PRI SCR CODE %d is out of range", ie_ptr->primaryCPICH_Info.primaryScramblingCode);
        return FAILURE;
      }
      

      if(get_dl_fdpch_info_for_each_rl_r7(&ie_ptr->dl_FDPCH_InfoPerRL,
        dl_phychan, ix, TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
          , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ))
      {
      /* bad status from get_dl_dpch_info_for_each_rl.  Return FALSE
        indicating an error */
        WRRC_MSG0_HIGH("REL9:get_dl_fdpch_info_for_each_rl_r7() failed");
        return FAILURE;
      }

      /* Ignore the SCCPCH/FACH and TFCI combining info for now */
      /* No need to continue */
      break;
    } /* end RL match if */
  } /* end looking for open RL slot */
  
  /* everything is good if here */
  return SUCCESS;

}


/*============================================================================
FUNCTION: rrcllcpcie_process_sec_eul_rl_addition_info_list_r9()

DESCRIPTION:
  This function updates IE "rrc_RL_AdditionInformationList_r9 " in ordered config
  and update e_dch parameters

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_sec_eul_rl_addition_info_list_r9
(
  OSS_UINT32 rl_additon_info_list_present,
  rrc_RL_AdditionInformationList_SecULFreq *rl_add_ptr
)
{
  uint8                            idx = 0;  /* local loop variable */
  uint16                           num_rl;   /* local RL count */
  /* flag to prevent erroneous increment of number of RL on attempt to add a duplicate RL */
  boolean duplicate_add_attempted = FALSE;
  uint32 n_value=0, n_index=0;

  uint32 e_rl_idx;
  boolean is_e_dl_info_present = FALSE;
  
  if(rl_additon_info_list_present)
  {
    ordered_config_ptr->sec_ul_asu = TRUE;

    num_rl = ordered_config_ptr->l1_dl_chan_parms.sec_num_rl;
    n_value = rl_add_ptr->n;
    
    while((n_value != 0) && (idx < (UE_MAX_RL - num_rl)))
    {
      if(get_sec_eul_rl_add_info_r9(&rl_add_ptr->elem[n_index], &ordered_config_ptr->l1_dl_chan_parms,
                         &duplicate_add_attempted) == FAILURE)
      {
        WRRC_MSG0_HIGH("DC_HSUPA: get_rl_add_info_r8() failed");
        return FAILURE;
      }

      /* one more radio link in ORDERED_CONFIG */
      if(!duplicate_add_attempted)
      {
        ordered_config_ptr->l1_dl_chan_parms.sec_num_rl++;
      }
        /* if we are inside this if check then it means that RRC needs to indicate
           to L1 that some of the parameters in DL has changed */
        is_e_dl_info_present = TRUE;

        e_rl_idx = get_e_rl_index_for_a_given_psc(
              rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

        /*madhavi-> even if HICH info doesnt change do we need set edl info?*/

        if (FAILURE == rrcllcpcie_update_e_hich_info_and_mask(e_rl_idx, 
                                                              &rl_add_ptr->elem[n_index].e_HICH_Information,
                                                              rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                            ,TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                            ))
        {
          return FAILURE;
        }


      if (RRC_CHECK_MSG_TYPE_IE(rl_add_ptr->elem[n_index], 
                 e_RGCH_InformationPresent))
      {
        /* if we are inside this if check then it means that RRC needs to indicate
           to L1 that some of the parameters in DL has changed */
        is_e_dl_info_present = TRUE;

        if (FAILURE == rrcllcpcie_process_e_rgch_information(
            rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode,
            &rl_add_ptr->elem[n_index].e_RGCH_Information
#ifdef FEATURE_WCDMA_DC_HSUPA
          ,TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ))
        {
          return(FAILURE);
        }
      }

      /* get the next RL */
      n_value--;
      n_index++;
      idx++;
    } /* end loop of all included RLs to add */ 
    if (FAILURE == rrcllcpcie_validate_hich_rgch_info(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
      , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */

      ))
    {
      return(FAILURE);
    }
  /* Make sure we actually have some RLs in the active set */
  if(ordered_config_ptr->l1_dl_chan_parms.sec_num_rl == 0)
  {
    WRRC_MSG0_HIGH("DC_HSUPA:No RLs in ASET after ASU");
    return FAILURE;
  }

  } /* end RL Addition information */

  /* update the l1_e_req_mask */
  rrcllc_update_l1_sec_e_req_mask_for_e_dl_info(is_e_dl_info_present);

  return(SUCCESS);
}


/*============================================================================
FUNCTION: rrcllcpcie_process_rl_removal_information_list_on_sec_eul()

DESCRIPTION:
  This function processes rl removal list and updates sec_e_dch active set information
  and adds removed rl to e_rl_removed list
      
RE-USABILITY: R9

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_rl_removal_information_list_on_sec_eul
(
  OSS_UINT32 rl_removal_info_list_present,
  rrc_RL_RemovalInformationList_SecULFreq *rl_remove_ptr,
  OSS_UINT32 rl_addition_info_list_present  
)
{
  /* local loop variable */
  uint32                            idx = 0;

  /* local RL count */
  uint32                           num_rl;
  uint32 n_value = rl_remove_ptr->n;
  uint32 n_index = 0;

  /* Can only remove one less than the number of Radio Links
     that the UE has */    
  num_rl = ordered_config_ptr->l1_dl_chan_parms.sec_num_rl;
if(rl_removal_info_list_present == TRUE)
{
    ordered_config_ptr->sec_ul_asu = TRUE;
    while((n_value != 0) && (idx < num_rl))
    {

      if(get_sec_eul_rl_remove_info(&rl_remove_ptr->elem[n_index], &ordered_config_ptr->l1_dl_chan_parms) == FAILURE)
      {
        WRRC_MSG0_HIGH("DC_HSUPA: get_sec_eul_rl_remove_info() failed");
        rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
        return FAILURE;
      }

     rrcllcpcie_check_and_update_sec_e_active_set_and_remove_info(
       (uint32) rl_remove_ptr->elem[n_index].primaryScramblingCode);

      /* get the next RL */
      n_value--;
      n_index++;
      idx++;

      /* one less radio link in ORDERED_CONFIG */
      ordered_config_ptr->l1_dl_chan_parms.sec_num_rl--;

      /* complain if we removed all the radio links */
      if(ordered_config_ptr->l1_dl_chan_parms.sec_num_rl == 0 && 
         (!rl_addition_info_list_present))
      {
        WRRC_MSG0_HIGH("DC_HSUPA: Attempted to remove all RLs");
        rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
        return FAILURE;
      }
     /*Madhavi: Check if the below condition is valid for secondary EUL aswell*/
      if(ordered_config_ptr->l1_dl_chan_parms.sec_num_rl == 0)
      {
        /* sec 25.331 ,section 8.3.4.5
          If the following condition is valid:
         - the active set update procedure results in active 
           sets that do not contain at least one common radio link before
           and after a DPCH or F-DPCH frame boundary:
           the UE behaviour is not specified.
          */
        WRRC_MSG0_HIGH("DC_HSUPA: Disjoint ASET in ASU is received do reject the ASU");
        rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
        return FAILURE;
      }
    } /* end loop of all included RLs to remove */

    
    rrcllc_update_l1_sec_e_req_mask_for_e_dl_info(TRUE);
}
  return(SUCCESS);
} /* rrcllcpcie_process_rl_removal_information_list_on_sec_eul */

/*============================================================================
FUNCTION: rrcllcpcie_process_sec_serving_e_dch_rl_indicator()

DESCRIPTION:
  This function processes secondary eul e-AGCH information and updates the information
  in a given e_rl_index
      
DEPENDENCIES:
  This function needs to be called only after calling function to process E-HICH info.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
static uecomdef_status_e_type rrcllcpcie_process_sec_serving_e_dch_rl_indicator
(
  boolean serving_e_dch_rl_indicator,
  uint32 psc
)
{
  uint32 e_rl_idx;
  l1_e_dl_info_struct_type *e_dl_info_ptr = &ordered_config_ptr->l1_sec_e_info.e_dl_info;

  e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
        , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        );

  if (serving_e_dch_rl_indicator && (e_rl_idx < L1_MAX_EDCH_RL))
  {
    /* checking for E-AGCH should be sufficient because AGCH is stored only
       if HICH is provided by the NW, but to be on safer side it may be worth
       checking for both the channels (just in case someone removes the check
       for presence of HICH while storing AGCH) */
    if ((e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
      L1_E_AGCH_INFO_PRESENT) && 
      (e_dl_info_ptr->e_dl_rl_add_recfg_info[e_rl_idx].e_dl_channel_mask & 
       L1_E_HICH_INFO_PRESENT))
    {
      e_dl_info_ptr->e_serving_rl_idx = (uint8) e_rl_idx;
      rrcllcpcie_check_for_sec_e_dch_repointing_and_set_agch_mask(
        current_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx,
        e_rl_idx);
    }
    else
    {
      /* as per our current understanding NW should not provide E-RGCH info
         unless E-HICH is provided in config message or already stored in UE */
      WRRC_MSG0_ERROR("DC_HSUPA: NW trying to set Serving E-RL without providing AGCH and/or HICH");
      
    }
  }

  return(SUCCESS);
}


/*============================================================================
FUNCTION: rrcllcpcie_process_sec_e_dch_reconfig_info_r9()

DESCRIPTION:
  This function processes secondary EUL serving cell info and other cells info of secondary EUL active set
  if given by network.
      
RE-USABILITY: 

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_sec_e_dch_reconfig_info_r9
(
  OSS_UINT32 e_dch_reconfig_info_present,
  rrc_E_DCH_ReconfigurationInfo_SecULFrequency *e_dch_reconfig_info_ptr
)
{
  uint32 psc, e_rl_idx;
  rrc_E_RGCH_Information * e_rgch_ptr= NULL;
    rrc_E_HICH_Information * e_hich_info_ptr =NULL;
  boolean is_e_dl_info_present = FALSE;

  #if 0
  l1_e_ul_info_struct_type *e_ul_info_ptr =
    &ordered_config_ptr->l1_e_info.e_ul_info;

  l1_e_dl_info_struct_type *e_dl_info_ptr =
    &ordered_config_ptr->l1_e_info.e_dl_info;

  mac_e_dpdch_info_s_type *mac_e_dpdch_info_ptr = 
    &ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info;
#endif

  struct rrc_E_DCH_ReconfigurationInfo_SecULFrequency_e_DCH_RL_InfoOtherCellList_SecULFreq *e_rl_info_other_cell_ptr = NULL; 
  uint32 n_value = 0;
  uint32 n_index = 0;
  uint8 sec_hs_index = 0;

  for(sec_hs_index = 0; sec_hs_index < MAX_NUM_OF_SEC_CARRIERS; sec_hs_index++)
  {
    if(ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[sec_hs_index].sec_hsdpa_action == L1_SEC_HSDPA_RECFG)
    {
      break;
    }
  }


  if (e_dch_reconfig_info_present)
  {
    
    ordered_config_ptr->sec_ul_asu = TRUE;
    if (RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_reconfig_info_ptr,
               e_DCH_RL_InfoNewSecServingCellPresent))
    {


      if(sec_hs_index < MAX_NUM_OF_SEC_CARRIERS)
      {
        psc = ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[sec_hs_index].pri_cpich_scr_code;
  
        WRRC_MSG2_HIGH("DC_HSUPA: ASU- serving e-dch repointing to psc: %d, sec_hs_index %d ", psc, sec_hs_index);

        e_rl_idx = get_e_rl_index_for_a_given_psc(psc, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
          , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          );
       }
       else
       {
         WRRC_MSG1_HIGH("DC_HSUPA:Invalid sec_hs_index:%d",sec_hs_index);
         return(FAILURE);
       } 
     
      /* store hich info */
      if (RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewSecServingCell, 
                e_HICH_InformationPresent))
      {
        if (FAILURE == rrcllcpcie_update_e_hich_info_and_mask(e_rl_idx, 
                                                              &e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewSecServingCell.e_HICH_Information,
                                                              psc
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                            ,TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                            ))
        {
          return FAILURE;
        }
      }
      if((RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewSecServingCell,
                   e_RGCH_InfoPresent)) && 
         (RRC_CHECK_MSG_TYPE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewSecServingCell.e_RGCH_Info,
       T_rrc_E_DCH_RL_InfoNewSecServingCell_e_RGCH_Info_e_RGCH_Information))
        )
      {
        e_rgch_ptr = e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewSecServingCell.e_RGCH_Info.u.e_RGCH_Information;
      }
      else
      {
        /* This means that the E-RGCH Info IE is not present*/
        e_rgch_ptr = NULL;
      }

      /* store rgch info */
      if (FAILURE == rrcllcpcie_process_e_rgch_info(
          RRC_CHECK_MSG_TYPE_IE(e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewSecServingCell, 
            e_RGCH_InfoPresent),
        e_rgch_ptr,
        psc, 
        TRUE /*is_need_to_honor_e_rl_rel_ind set this to TRUE as default value*/
        
#ifdef FEATURE_WCDMA_DC_HSUPA
        ,TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
        ))

      {
        return(FAILURE);
      }

      /* store agch info */
      if (FAILURE == rrcllcpcie_process_e_agch_info_sec_eul(
        TRUE, 
        &e_dch_reconfig_info_ptr->e_DCH_RL_InfoNewSecServingCell.e_AGCH_Information,
        psc))
      {
        return(FAILURE);
      }

      if (FAILURE == rrcllcpcie_process_sec_serving_e_dch_rl_indicator(
        TRUE,
        psc))
      {
        return(FAILURE);
      }

      if (FAILURE == rrcllcpcie_validate_hich_rgch_info(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
      , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */

      ))
      {
        return(FAILURE);
      }

      /* since AGCH is mandatory in this IE, hence minimum e_dl_info is reconfigured */
      rrcllc_update_l1_sec_e_req_mask_for_e_dl_info(TRUE);

    }/* rrc_E_DCH_RL_InfoNewServingCell_r7_present */

    if (RRC_CHECK_MSG_TYPE_IE_PTR(e_dch_reconfig_info_ptr, 
             e_DCH_RL_InfoOtherCellList_SecULFreqPresent))
    {
      e_rl_info_other_cell_ptr = &(e_dch_reconfig_info_ptr->e_DCH_RL_InfoOtherCellList_SecULFreq);
      n_value = e_rl_info_other_cell_ptr->n;
    
      while(n_value != 0)
      {
        psc = e_rl_info_other_cell_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode;

        MSG_HIGH("DC_HSUPA: e-dch info -HICH: 0x%x, RGCH: 0x%x, updated for psc: %d", 
            (RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                e_HICH_InformationPresent)), 
            (RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                e_RGCH_InfoPresent)), psc);

        if ((RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                 e_HICH_InformationPresent)) &&
            (RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
                e_RGCH_InfoPresent)))
        {
          is_e_dl_info_present = TRUE;
        }

        if(RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index],
                        e_HICH_InformationPresent))
        {
           e_hich_info_ptr=&(e_rl_info_other_cell_ptr->elem[n_index].e_HICH_Information);
           if (FAILURE == rrcllcpcie_process_e_hich_info(
              RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index], 
               e_HICH_InformationPresent),
              e_hich_info_ptr,
            psc,
            TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
            , TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
            ))
          {
            return(FAILURE);
          }
         
        }

        if((RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index],
                         e_RGCH_InfoPresent)) && 
               (RRC_CHECK_MSG_TYPE(e_rl_info_other_cell_ptr->elem[n_index].e_RGCH_Info,
           T_rrc_E_DCH_RL_InfoOtherCell_SecULFreq_e_RGCH_Info_e_RGCH_Information))
              )
           {
             e_rgch_ptr = e_rl_info_other_cell_ptr->elem[n_index].e_RGCH_Info.u.e_RGCH_Information;
           }
           else
           {
             /* This means that the E-RGCH Info IE is not present*/
             e_rgch_ptr = NULL;
           }

        if (FAILURE == rrcllcpcie_process_e_rgch_info(
            RRC_CHECK_MSG_TYPE_IE(e_rl_info_other_cell_ptr->elem[n_index],e_RGCH_InfoPresent), 
         e_rgch_ptr,
          psc,
          TRUE
#ifdef FEATURE_WCDMA_DC_HSUPA
          ,TRUE
#endif /* FEATURE_WCDMA_DC_HSUPA */
           ))
        {
          return(FAILURE);
        }

        n_value--;
        n_index++;
      }

      /* update the l1_e_req_mask */
      rrcllc_update_l1_sec_e_req_mask_for_e_dl_info(is_e_dl_info_present);
    } /* rrc_e_DCH_RL_InfoOtherCellList_present */
  /*  NOTE: UTRAN should configure the same value of IE "F-DPCH frame offset" for the serving E-DCH radio link 
          and for the secondary serving E-DCH radio link, otherwise the UE behaviour is unspecified.
    */
    if(get_fdpch_frame_offset_for_a_spec_psc(
          ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx].e_rl_psc, FALSE) !=
          get_fdpch_frame_offset_for_a_spec_psc(ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[ordered_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx].e_rl_psc, TRUE))
    {
      return FAILURE;
    }
  }



  return(SUCCESS);
}


#endif /* FEATURE_WCDMA_DC_HSUPA */

/*====================================================================
FUNCTION: validate_fdpch_information_r9()

DESCRIPTION:
  This function verifies that there are no mixed RLs with DPCH and FDPCH
  after ASU is processed.

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS if validation is successful.
  FAILURE if there are mixed RLs with FDPCH and DPCH

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type validate_fdpch_information_r9
(
  rrc_RL_AdditionInformationList_r9 *rl_AdditionInformationList_ptr
)
{
  uint32 n_value = rl_AdditionInformationList_ptr->n;
  uint32 n_index = 0;
  
  while(n_value != 0)
  {
    if(ordered_config_ptr->l1_dl_chan_parms.use_fdpch)
    {
      if(RRC_CHECK_MSG_TYPE(rl_AdditionInformationList_ptr->elem[n_index].dl_dpchInfo,
                    T_rrc_RL_AdditionInformation_r9_dl_dpchInfo_dl_DPCH_InfoPerRL))
      {
        WRRC_MSG0_ERROR("REL9:Mixed RLs with DPCH and FDPCH");
        return FAILURE;
      }
    }
    else
    {
      if(RRC_CHECK_MSG_TYPE(rl_AdditionInformationList_ptr->elem[n_index].dl_dpchInfo,
                     T_rrc_RL_AdditionInformation_r9_dl_dpchInfo_dl_FDPCH_InfoPerRL))
      {
        WRRC_MSG0_ERROR("REL9:Mixed RLs with DPCH and FDPCH");
        return FAILURE;
      }
    }
    n_value--;
    n_index++;
  }
  return SUCCESS;
}


#ifdef FEATURE_WCDMA_MIMO
/*============================================================================
FUNCTION: rrcllcpcie_process_mimo_params_r9()

DESCRIPTION:
  This function updates IE "Mimo Params" in ordered config for R8 OTAs.
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type    rrcllcpcie_process_mimo_params_r9
(
  rrc_MIMO_Parameters_r9 * mimo_params,
  rrc_RRC_StateIndicator rrc_state,
  OSS_UINT32 mimo_params_present_ota
)
{
  hsdpa_action_enum_type hs_action =rrc_get_hsdpa_action();
  boolean mimo_reconfig = FALSE;

  /*Make sure that HSDPA category supports MIMO and (either HSDPA is being started or reconfig) */
  if((CHECK_WCDMA_OPTIONAL_FEATURE_MIMO_SUPPORTED) && ((hs_action == HSDPA_START) ||
        ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && (hs_action != HSDPA_STOP))))
  {
    ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
    if( mimo_params_present_ota )
    {
      if(RRC_CHECK_MSG_TYPE(mimo_params->modeSpecificInfo, 
                   T_rrc_MIMO_Parameters_r9_modeSpecificInfo_fdd))
      {
        if(RRC_CHECK_MSG_TYPE_IE_PTR(mimo_params->modeSpecificInfo.u.fdd, 
                   mimoN_M_RatioPresent))
        {
          if(rrcllc_update_n_m_ratio(mimo_params->modeSpecificInfo.u.fdd->mimoN_M_Ratio) == FAILURE)
          {
            return FAILURE;
          }
          mimo_reconfig = TRUE;
        }
    
        if(RRC_CHECK_MSG_TYPE_IE_PTR(mimo_params->modeSpecificInfo.u.fdd, 
                  mimoPilotConfigurationPresent))
        {
          mimo_reconfig = TRUE;
          if(RRC_CHECK_MSG_TYPE(mimo_params->modeSpecificInfo.u.fdd->mimoPilotConfiguration.secondCPICH_Pattern, 
                   T_rrc_MIMO_PilotConfiguration_r9_secondCPICH_Pattern_normalPattern))
        {
           ordered_config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern = MIMO_NORMAL_PATTERN;
        }
        else if(RRC_CHECK_MSG_TYPE(mimo_params->modeSpecificInfo.u.fdd->mimoPilotConfiguration.secondCPICH_Pattern, 
                   T_rrc_MIMO_PilotConfiguration_r9_secondCPICH_Pattern_diversityPattern))
        {
          ordered_config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern = MIMO_DIVERSITY_PATTERN;
   
          ordered_config_ptr->l1_hsdpa_info.mimo_info.channelisation_code = 
                  mimo_params->modeSpecificInfo.u.fdd->mimoPilotConfiguration.secondCPICH_Pattern.u.diversityPattern->channelisationCode;
#ifdef FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT
          if(mimo_params->modeSpecificInfo.u.fdd->mimoPilotConfiguration.secondCPICH_Pattern.u.diversityPattern->m.s_cpich_PowerOffset_MimoPresent)
          {
            ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = mimo_params->modeSpecificInfo.u.fdd->mimoPilotConfiguration.
              secondCPICH_Pattern.u.diversityPattern->s_cpich_PowerOffset_Mimo;
            WRRC_MSG1_HIGH("MIMO:S-CPICH PO from OTA = %d",ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po);

          }
          else
          {
            ordered_config_ptr->l1_hsdpa_info.mimo_info.s_cpich_po = rrc_mimo_s_cpich_po;
            WRRC_MSG1_HIGH("MIMO: Setting S-CPICH PO = %d",rrc_mimo_s_cpich_po);
          }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT*/
          }
        }
#ifdef FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION
        if(RRC_CHECK_MSG_TYPE_IE_PTR(mimo_params->modeSpecificInfo.u.fdd, 
                  precodingWeightSetRestrictionPresent)
        {
          rrcllcpcie_update_mimo_codebook_restriction(TRUE);
        }
        else
        {
          rrcllcpcie_update_mimo_codebook_restriction(FALSE);
        }
#endif /*FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/        
        
      }
      else
      {
        return FAILURE;
      }  
    }
    else
    {
      WRRC_MSG0_HIGH("MIMO:MIMO params not present in OTA");
    }  
  }
  else
  {
    MSG_HIGH("REL9:MIMO can't be started HS-Action %d HS-Status %d NV HS-CAT %d",
            hs_action,rrc_get_hsdpa_status(),nv_hsdpa_category);
    mimo_params_present_ota = 0;
  }
   
  if((!mimo_params_present_ota) ||
    (rrcllc_check_if_mimo_can_be_started(rrc_state) == FALSE ))
  {
    if(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE )
    {
      WRRC_MSG0_HIGH("MIMO:Set MIMO Action to STOP");
      ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_STOP;
      if(hs_action != HSDPA_STOP)
      {
        WRRC_MSG0_HIGH("Include HS bitmask as MIMO is going be stopped, but HS continues");

        ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL |CPHY_HS_DSCH_CFG_INCL|CPHY_HS_DPCCH_CFG_INCL;;

          /* Set beta table and hs-dpcch bit mask */
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
        if(hs_action == HSDPA_NOOP)
        {
          rrc_set_hsdpa_action(HSDPA_RECONFIG);
          rrc_set_hsdpa_action_in_machs_macehs();
        }
           
      }
      else
      {
        ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL;
      }
    }
    else
    {
      WRRC_MSG0_HIGH("MIMO:Set MIMO Action to NOOP");
      rrcllc_init_mimo_params(ordered_config_ptr);
      ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
    }
  }
  else
  {
    uint8 num_harq_proc =  ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.harq_info.num_proc;
    /*If the IE “Number of processes" is not set to one of the values 12, 14 or 16 and the IE “MIMO
        operation” (10.3.6.41a) is included and set to either “start” or “continue”, the UE behaviour is
        unspecified.
      */
    if((num_harq_proc == 12) || (num_harq_proc == 14) || (num_harq_proc == 16))
    {
       WRRC_MSG1_HIGH("MIMO: No. Of harq process is %d as according to MIMO ",num_harq_proc);
    }
    else
    {
      WRRC_MSG1_ERROR("MIMO: No. Of harq process is %d is not suitable for MIMO ",num_harq_proc);
      return FAILURE;
    }
    
    if(mimo_params->mimoOperation == rrc_MIMO_Operation_start )
    {
      ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_START;      
      
      ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL|CPHY_HS_DSCH_CFG_INCL|CPHY_HS_DPCCH_CFG_INCL;

      /* Set beta table and hs-dpcch bit mask */
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
      
      if(hs_action != HSDPA_START)
      {
        rrc_set_hsdpa_action(HSDPA_RECONFIG);
        rrc_set_hsdpa_action_in_machs_macehs();
      }
    }
    else if(mimo_params->mimoOperation == rrc_MIMO_Operation_continue_ )
    {
      ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_NOOP;
      if(mimo_reconfig ==TRUE)
      {
        if(rrcllc_get_mimo_status() == RRC_MIMO_INACTIVE)
        {
          WRRC_MSG0_ERROR(" MIMO not active so MIMO Operation should be rrc_start, but received as rrc_continue  ");
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_START;
        }
        else
        {
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;
        }
        
        MSG_HIGH("MIMO: MIMO action reconfig ,second_cpich_pattern  %d chan code %d M/N ratio %d",
             ordered_config_ptr->l1_hsdpa_info.mimo_info.second_cpich_pattern,
             ordered_config_ptr->l1_hsdpa_info.mimo_info.channelisation_code,
             ordered_config_ptr->l1_hsdpa_info.mimo_info.mimo_n_m_ratio);
        
        ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL |CPHY_HS_DSCH_CFG_INCL|CPHY_HS_DPCCH_CFG_INCL;;

        /* Set beta table and hs-dpcch bit mask */
        ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.info_present_bitmask = 
            HS_DPCCH_BETA_HS_INFO_PRESENT_BITMASK | HS_DPCCH_MEAS_FEEDBACK_INFO_PRESENT_BITMASK;
          
         if(hs_action != HSDPA_START)
         {
           rrc_set_hsdpa_action(HSDPA_RECONFIG);
           rrc_set_hsdpa_action_in_machs_macehs();
         }
      }
      else
      {
        if((ordered_config_ptr->l1_hsdpa_info.hs_req_mask & CPHY_HS_DSCH_CFG_INCL)
            &&(rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE))
        {
          /*This is as per L1's requirement that when MIMO is active, even if No MIMO params change
           * if HS-DSCH changes then indicate MIMO as RECONFIG*/
          
          ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL;
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;
          WRRC_MSG1_HIGH("MIMO: No new MIMO params but HSDSCH touched so MIMO action reconfig HS bitmask 0x%x",
                            ordered_config_ptr->l1_hsdpa_info.hs_req_mask);
        }
        else if((ordered_config_ptr->l1_hsdpa_info.hs_req_mask & CPHY_HS_PDSCH_RL_CFG_INCL) && 
          (rrcllc_get_mimo_status() == RRC_MIMO_ACTIVE))
        {
          ordered_config_ptr->l1_hsdpa_info.hs_req_mask |= CPHY_HS_MIMO_CFG_INCL |CPHY_HS_DSCH_CFG_INCL;
          ordered_config_ptr->l1_hsdpa_info.mimo_info.l1_mimo_action = L1_MIMO_RECFG;        
          WRRC_MSG0_HIGH("MIMO:HS Re-pointing so RECFGing MIMO");
        }
        else
        {
          WRRC_MSG0_HIGH("MIMO: No new MIMO params received so action NOOP");
        }
      }
    }
    else
    {
      WRRC_MSG1_ERROR("MIMO: Invalid MIMO Operation %d",mimo_params->mimoOperation);
      return FAILURE;
    }
  }
  return SUCCESS;
}
#endif /* FEATURE_WCDMA_MIMO */

/*============================================================================
FUNCTION: rrcllc_process_serving_hsdsch_cell_info_r9()

DESCRIPTION:
  This function updates IE "rrc_Serving_HSDSCH_CellInformation " in ordered config

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllc_process_serving_hsdsch_cell_info_r9
(
  rrc_Serving_HSDSCH_CellInformation_r9 *hs_srv_cell_ptr
)
{
  uint8 rl_count = 0;

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                primaryCPICH_InfoPresent))
  {
    /*Find out the RL index in OC for the HS RL PSC*/
    for (rl_count = 0; rl_count < ordered_config_ptr->l1_dl_chan_parms.num_rl; rl_count++)
    {
      if(hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode == 
         ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[rl_count].pri_cpich_scr_code)
      {
        WRRC_MSG1_HIGH("REL9:New HS Serving Cell PSC found in AS at idx %d",rl_count);
        break;
      }
    }
    if(rl_count == ordered_config_ptr->l1_dl_chan_parms.num_rl)
    {
      WRRC_MSG0_ERROR("REL9:New HS Serving Cell PSC not found in AS!");
      return FAILURE;
    }

    /*Update the HSDPA MSG PARAMS with PSC Info.*/
   
    if(hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode
      != ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc)
    {
      WRRC_MSG1_HIGH("REL9:ASU HS repointing to PSC %d", hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode);
      hsdpa_msg_params.msg_params_present = TRUE;
      hsdpa_msg_params.rl_link_present = TRUE;
      hsdpa_msg_params.new_rl_link = hs_srv_cell_ptr->primaryCPICH_Info.primaryScramblingCode;
    }
  }


  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
               deltaACKPresent))
  {
    if(ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack != hs_srv_cell_ptr->deltaACK)
    {
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_ack = hs_srv_cell_ptr->deltaACK;
      hsdpa_msg_params.beta_table_present = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                deltaNACKPresent))
  {
    if(ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack != hs_srv_cell_ptr->deltaNACK)
    {
      ordered_config_ptr->l1_hsdpa_info.hs_dpcch_info.beta_hs_info.delta_nack = hs_srv_cell_ptr->deltaNACK;
      hsdpa_msg_params.beta_table_present = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                mac_hsResetIndicatorPresent))
  {
    ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = TRUE;
    hsdpa_msg_params.msg_params_present = TRUE;
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                harqInfoPresent))
  {    
    /* Process HARQ Info */
    if(set_harq_information_r7(&hs_srv_cell_ptr->harqInfo) == FAILURE)
    {
      return FAILURE;
    }
    hsdpa_msg_params.msg_params_present = TRUE;
    hsdpa_msg_params.hsdsch_info_present = TRUE;
  }

  if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr, 
                dl_hspdsch_InformationPresent))
  {
    hsdpa_msg_params.msg_params_present = TRUE;
    hsdpa_msg_params.hspdsch_info_present = TRUE;

    ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = FALSE;
    if(RRC_CHECK_MSG_TYPE(hs_srv_cell_ptr->dl_hspdsch_Information.modeSpecificInfo, 
                T_rrc_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd))
    {
      if(RRC_CHECK_MSG_TYPE_IE_PTR(hs_srv_cell_ptr->dl_hspdsch_Information.modeSpecificInfo.u.fdd, 
                 dl_64QAM_ConfiguredPresent))
      {
        ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured = TRUE;
      }
    }
    else if(RRC_CHECK_MSG_TYPE(hs_srv_cell_ptr->dl_hspdsch_Information.modeSpecificInfo, 
                T_rrc_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd))
    {
      return FAILURE;
    }
  }
  else
  {
    if(rrc_get_hsdpa_status() == HSDPA_INACTIVE)
    {
      /* Action has already been set to NOOP by default */
      WRRC_MSG0_HIGH("RRCHS:HSDPA Action NOOP");
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_NOOP; 
      ordered_config_ptr->mac_dl_parms.mac_hs_reset_indicator = FALSE;
    }
  }

  if(rrcllc_determine_hsdpa_action_r9(&hs_srv_cell_ptr->dl_hspdsch_Information) == SUCCESS)
  {
    rrc_set_hsdpa_action_in_machs_macehs();

    /*Following check is made to ensure that 64 QAM isn't being enabled with MAC-HS*/
    if((ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE)
      &&((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
          (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
          ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
          (rrc_get_hsdpa_status() == HSDPA_ACTIVE))))
    {
      if(ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS )
      {
        WRRC_MSG0_ERROR("REL9:64QAM cannot be started on MAC-HS!");
        return FAILURE;
      }
    }

  }
  else
  {
    return FAILURE;
  }
  return SUCCESS;
}


/*============================================================================
FUNCTION: rrcllcpcie_process_rl_addition_info_list_ext_asu_r9()

DESCRIPTION:
  This function updates IE "rrc_RL_AdditionInformationList_v950ext " in ordered config

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/

uecomdef_status_e_type rrcllcpcie_process_rl_addition_info_list_ext_asu_r9
(
  rrc_RL_AdditionInformationList_v950ext rl_add_ptr
)
{
  uint32 n_index=0;
  if ((rl_add_ptr.n)&&(RRC_CHECK_MSG_TYPE_IE(rl_add_ptr.elem[n_index],targetCellPreconfigInfoPresent)))
  {
    WRRC_MSG0_ERROR("REL9:IE targetCellPreconfigInfo/E-SCC not supported yet!");
    return FAILURE;
  }
  return SUCCESS;
}


/*============================================================================
FUNCTION: rrcllcpcie_process_rl_addition_info_list_r9()

DESCRIPTION:
  This function updates IE "rrc_RL_AdditionInformationList_r9 " in ordered config
  and update e_dch parameters

DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
uecomdef_status_e_type rrcllcpcie_process_rl_addition_info_list_r9
(
  OSS_UINT32 rl_additon_info_list_present,
  rrc_RL_AdditionInformationList_r9 *rl_add_ptr
)
{
  uint8                            idx = 0;  /* local loop variable */
  uint16                           num_rl;   /* local RL count */
  /* flag to prevent erroneous increment of number of RL on attempt to add a duplicate RL */
  boolean duplicate_add_attempted = FALSE;
  uint32 n_value=0, n_index=0;

  uint32 e_rl_idx;
  boolean is_e_dl_info_present = FALSE;
  
  if(rl_additon_info_list_present)
  {
    if(RRC_CHECK_MSG_TYPE_IE(rl_add_ptr->elem[n_index], 
                targetCellPreconfigInfoPresent))
    {
      WRRC_MSG0_ERROR("REL9:IE targetCellPreconfigInfo/E-SCC not supported yet!");
      return FAILURE;
    }
  
    /*Validation is done so that Mixed RLs for DPCH/F-DPCH isn't allowed*/
    if(SUCCESS != validate_fdpch_information_r9(rl_add_ptr))
    {
      return FAILURE;   
    }

    num_rl = ordered_config_ptr->l1_dl_chan_parms.num_rl;
    n_value = rl_add_ptr->n;
    
    while((n_value != 0) && (idx < (UE_MAX_RL - num_rl)))
    {
      if(get_rl_add_info_r9(&rl_add_ptr->elem[n_index], &ordered_config_ptr->l1_dl_chan_parms,
                         &duplicate_add_attempted) == FAILURE)
      {
        WRRC_MSG0_HIGH("REL9: get_rl_add_info_r8() failed");
        return FAILURE;
      }

      /* one more radio link in ORDERED_CONFIG */
      if(!duplicate_add_attempted)
      {
        ordered_config_ptr->l1_dl_chan_parms.num_rl++;
      }
      if (RRC_CHECK_MSG_TYPE_IE(rl_add_ptr->elem[n_index], 
                e_HICH_InformationPresent))
      {
        /* if we are inside this if check then it means that RRC needs to indicate
           to L1 that some of the parameters in DL has changed */
        is_e_dl_info_present = TRUE;

        e_rl_idx = get_e_rl_index_for_a_given_psc(
              rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode, ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
           , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
              );

        if (FAILURE == rrcllcpcie_update_e_hich_info_and_mask(e_rl_idx, 
                                                              &rl_add_ptr->elem[n_index].e_HICH_Information,
                                                              rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                            ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                            ))
        {
          return FAILURE;
        }
      }

      if (RRC_CHECK_MSG_TYPE_IE(rl_add_ptr->elem[n_index], 
                 e_RGCH_InformationPresent))
      {
        /* if we are inside this if check then it means that RRC needs to indicate
           to L1 that some of the parameters in DL has changed */
        is_e_dl_info_present = TRUE;

        if (FAILURE == rrcllcpcie_process_e_rgch_information(
            rl_add_ptr->elem[n_index].primaryCPICH_Info.primaryScramblingCode,
            &rl_add_ptr->elem[n_index].e_RGCH_Information
#ifdef FEATURE_WCDMA_DC_HSUPA
          ,FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
          ))
        {
          return(FAILURE);
        }
      }

      /* get the next RL */
      n_value--;
      n_index++;
      idx++;
    } /* end loop of all included RLs to add */ 
    if (FAILURE == rrcllcpcie_validate_hich_rgch_info(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
      , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */

      ))
    {
      return(FAILURE);
    }
  } /* end RL Addition information */

  /* Make sure we actually have some RLs in the active set */
  if(ordered_config_ptr->l1_dl_chan_parms.num_rl == 0)
  {
    WRRC_MSG0_HIGH("REL8:No RLs in ASET after ASU");
    return FAILURE;
  }

  /* update the l1_e_req_mask */
  rrcllc_update_l1_e_req_mask_for_e_dl_info(is_e_dl_info_present);

  return(SUCCESS);
}

#endif /*FEATURE_WCDMA_REL9*/

#ifdef FEATURE_WCDMA_REL10
#error code not present
#endif /*FEATURE_WCDMA_REL10*/
#ifdef FEATURE_WCDMA_16_QAM
/*====================================================================
FUNCTION: rrcllcpcie_process_ul_16qam_config_r7()

DESCRIPTION:
   This function updates ul 16qam config info

DEPENDENCIES:
  None.

RETURN VALUE:
   SUCCESS/FAILURE

SIDE EFFECTS:

====================================================================*/
uecomdef_status_e_type rrcllcpcie_process_ul_16qam_config
(
  OSS_UINT32 ul_16qam_config_present,
  rrc_UL_16QAM_Config *ul_16qam_config_ptr
)
{
  uecomdef_status_e_type status = SUCCESS;

  if (ul_16qam_config_present)
  {
      if (RRC_CHECK_MSG_TYPE_IE_PTR(ul_16qam_config_ptr,mac_es_e_resetIndicatorPresent))
      {
         ordered_config_ptr->mac_e_reset_indicator = TRUE;
      }

      if (RRC_CHECK_MSG_TYPE_IE_PTR(ul_16qam_config_ptr,e_TFCI_TableIndexPresent))
      {
         ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_tfci_table_idx = ul_16qam_config_ptr->e_TFCI_TableIndex;
         ordered_config_ptr->mac_e_config.e_dch_info.e_dpdch_info.e_tfci_table_index = ul_16qam_config_ptr->e_TFCI_TableIndex; 
      }

      status = rrcllcpcie_process_16qam_params(RRC_CHECK_MSG_TYPE_IE_PTR(ul_16qam_config_ptr,ul_16QAM_SettingsPresent), 
                                                    &ul_16qam_config_ptr->ul_16QAM_Settings);
      rrcllcpcie_modify_e_tfci_table();
  }
  else
  {
     /* $8.3.4.3: If the IE "UL 16QAM configuration" is not included and 16QAM mode operation is currently ongoing,
        the UE behaviour is unspecified.*/
     if (TRUE == current_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action)
     {
       WRRC_MSG0_ERROR("HSPA+:UL 16QAM configuration is not included");
       return FAILURE;
     }
  }
  return(status);
}
#endif
