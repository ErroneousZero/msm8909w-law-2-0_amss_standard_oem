/*===========================================================================

       L3 - RRC Lower Layer Controller Radio Resource Control Messages

DESCRIPTION
  This file contains functions necessary for the RRC Lower Layer Controller
  Ordered Config Radio Resource Control Message Information Element
  processing.

Copyright (c) 2000-2009 Qualcomm Technologies, Inc.  All Rights Reserved.
QUALCOMM Proprietary.  Export of this technology or software is regulated
by the U.S. Government. Diversion contrary to U.S. law prohibited.
===========================================================================*/


/*===========================================================================
                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

$PVCSPath:  L:/src/asw/MSM5200/RRC/vcs/rrcllcmsgie.c_v   1.28   28 Jun 2002 18:13:00   vnagpal  $
$Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/wcdma/rrc/src/rrcllcmsgie.c#1 $ $DateTime: 2016/12/13 08:00:12 $ $Author: mplcsds1 $

when        who     what, where, why
--------    ---     --------------------------------------------------------
07/28/16   nr      Made changes to reset ota_buffered flag if CS domain is open
06/20/16   sg      Made changes to reduce F3s
04/28/16   ha      Made changes to reject Invalid DPCH 
04/13/16   ha      KW error rrcasn1_decode_pdu() explicitely returns NULL
02/08/16   nr      CR973374: Made changes to not allow LTA if delay restriction IE is set
01/20/15   nr      Changes to not allow LTA during activation time when srns relocation is in progress
11/25/15   nr      Fixing merge error in code to support LTA during act time
10/16/15   as      Added code to support LTA during activation time
06/12/15   sp      Fixed KW errors
02/12/15   sa      Made changes to remove the KW warning for TA
02/10/15   aa      Made changes to include a protoype to avoid medium level errors
12/10/14   sp      Made changes to reduce activation time for dch/fach transition
11/05/14   aa      Added Message Highs for validation failures
10/16/14   sp      Made changes to copy HRNTI to TOC for PCH state transition
09/02/14   sp      Changes are made to not add mac header size for TB size 0
07/18/14   ad      Made changes to reduce F3s
06/30/14   db      Made changes to clear ERNTI when EUL is previously and will be inactive and NW provides new ERNTI
06/26/14   ad      Made changes to implement IE "E-DCH reconfiguration information same serving cell" in ASU
06/09/14   sa      Made changes to update UL 16QAM
05/23/14   db      Made changes to skip SCCPCH selection during message processing
                         when new URNTI is given for transition out of DCH state
04/29/14   sa      Made changes for NV support for default config in CELL FACH
05/20/14   sa      Made changes to retain the predef_po3_status
05/14/14   ymu     Feature name FEATURE_WCDMA_DC_HSUPA_FRAME replacement with FEATURE_WCDMA_DC_HSUPA 
04/29/14   sp      Made changes to avoid saving CRNTI while going to cell_DCH state
03/27/14   sa      Made changes to disable only when “E-DPDCH power interpolation” is absent
03/18/14   sg      Made change to reset sec_num_rl when DCHSUPA is stopped
03/13/14   sp      Removed code under FEATURE_WCDMA_HS_PCH feature flag
02/13/14   ad      Made changes to remove redundant F3s
01/23/14   ad      Made changes to extract values from ETFC boost IE before validation
01/09/14   sp      Removed code under FEATURE_CS_VOICE_OVER_HSPA feature
10/12/13   sa      Made changes for reseting ETFCI boost values
12/05/13   db      Missing R9 Upmerge
11/06/13   sg      Made changes to reject the config if E-HICH and E-AGCH
                   info are not provided for secondary serving EDCH RL
11/07/13   db      Made changes to check for mapping and ERNTI in Connection setup for HSRACH
10/30/13   as      Made changes to add feature code for FEATURE_WCDMA_3C_HSDPA
10/29/13   sp      Made changes to fix compilation errors for BOOST feature 
10/18/13   ad      Made changes to check for HRNTI when serving cell repointing happens through ASU
10/17/13   ad      Changes for DC HSDPA feature with 3C interface
10/04/13   db      Made changes to skip SCCPCH selection during message processing, 
                         when new URNTI is given for transition out of DCH state
09/16/13   mp      Added code for REL10 signalling under feature FEATURE_WCDMA_REL10
09/04/13   sp      Made changes to correct primary_e_rnti_present assignment in toc from oc
09/02/13   sa      Made change to handle the default config CELL FACH IE in DCH state
08/27/13   db      Made changes to retry connection request when NW provides invalid 
                   mapping in R9 connection setup OTA
08/27/13   sp      Made changes to rename r9 function rrcllcpcie_process_dc_hsupa_params
07/09/13   db       Made changes to update OC for RB Release from HSFACH to DCH state
07/08/13   ad      Made changes to remove redundant F3s
06/25/13   as      Fixed compilation error
06/20/13   sa      Made changes for Default config in CELL_FACH
06/14/13   db      Added backup and restore ERNTI logic for transition to(out of) PCH state
06/05/13   as       Fixed compialtion errors
05/22/13   sa       Added code changes to support FEATURE_WCDMA_DC_HSUPA
05/15/13   as      Made changes to pass whether PO3 is signalled or pre-set
05/14/13   mp    Fixing KW errors.
05/13/13   sg       Made changes to use old TBS table if dl_hspdsch_Information
                    IE is missing in rel9 ASU message
05/10/13   sg      Made changes to fix the compilation errors
05/08/13   ad       Made changes to use old TBS table if dl_hspdsch_Information
                    IE is missing in rel7 and rel 8 ASU messages
05/03/13   as       Fixed compilation error
05/03/13   sg       Made changes to fix the compilation errors
04/25/13   sg       Added code for REL9 under FEATURE_WCDMA_REL9
04/24/13   ad       Made changes to configure hsrach dedicated mode during reselection.
                    Made changes not to reset hsrach actions in OC if OC is set when RRCLLC_CHAN_CFG_EPCH_HRNTI_ONLY
                    cause is used.
03/06/13   ad       Added prints to print CRNTI on PCH->FACH and FACH->PCH transition
                    Removed redundant F3s
01/23/13   mp       Fixing KW errors
01/22/13   vi       Made the changes to move out ul_pdu_type based on the eul is active or not
01/10/13   ad       Made changes to make hspa_rnti_stored_cell_pch true 
                    if crnti is provided in OTA
01/03/13   ad       Made changes to reduce the redundant F3s
12/12/12   mp       Fixing KW errors
11/20/12   mp       Fixed KW errors
11/02/12   gv       Corrected the changes under FEATURE_WCDMA_DIME_SW
11/02/12   sg       Fixed KW errors
10/26/12   db       EFACH Redesign changes
10/23/12   pm       Made changes to assign pointer to NULL after de-allocation
10/19/12   sg       Made changes for Rel 9 migration, removing unsupported IEs and ZI reductions. 
10/03/12   pm       Made changes to backup hrnti while going to PCH state and 
                    retrieving it while evaluating hspa_rnti_stored_cell_pch
                    and ready_for_common_edch variables.
10/03/12   pm       Removed the check which checks if mac-ehs is configured when mac-i 
                    and hsrach are on
09/28/12   mp       Fixed compilation warnings
08/15/12   sa       Made the changes not to check the HSRACH ptr at rrcllc_check_ul_flexible_rlc_size_configured
07/24/12   geg      Upmerge WCDMA.MPSS.1.0 to WCDMA.MPSS.2.0
03/28/12   zr       Adding feature definition for Dime
11/07/12   ad       Made changes to handle ERNTI correctly. Changes to avoid starting MAC
                    for a HSRACH to HSRACH SIB5 change.Increased the handing rb size.
06/29/12   ad       Made changes for triggering CU if E-RNTI is not given.
                    Skipped the de-registration of WMs if HS-RACH is ON and RRC is 
                    triggering MR while coming out of PCH. Fixed bug to updated E-RNTI
                    in OC correctly. Added code to trigger CU if R99 or R5 CUCNF is received. 
                    Added code to keep L1 and MAC in sync wrt HS-RACH actions.
04/06/12   ad       Changes for HS-RACH feature
06/04/12   md       Merged MAC_I fix to reset ul_pdu_type upon transition from E-DCH to DCH transport channels
05/29/12   db       Made changes to not invaldate HRNTI status in TOC during DCH->FACH transition
05/10/12   md       Added code changes to support FEATURE_MAC_I
04/04/12   as       Changes to remove released Rb-Id from mapping validation check
03/19/12   db       Made changes to reject invalid OTA, status flag was being set without
                    looking at current status 
03/12/12   db       Mainlined FEATURE_RRC_UM_RLC_INFO, OTA should be rejected if it tries to modify 
                    existing RB RLC mode
02/06/12   db       Made changes to reject the OTA when invalid NW reconfig from Mac-ehs to Mac-hs
10/01/12   sa       Updated IE maxAllowedUL_TX_Power in rrcllc_rb_setup_ie_r8()
01/04/12   md       Fixed compilation errors for rel-9 to rel-10 asn migration.
12/27/11   sa       Added Null pointer checks
12/23/11   mn       Added another NULL ptr check in rrcllc_rrc_conn_setup_ie_r5. This time for 
                          DL add trch ptr.
12/8/11    db       Made changes to not invalidate hrnti status during dch to fach transtion
11/10/11   sa       Updating the RB Setup Msg IE dl_DeletedTransChInfoList for Rel-8
11/03/11   rl       Fixed the osys coding issue
10/12/11   ad       Added NULL pointer check in rrcllc_rrc_conn_setup_ie_r5 function
09/14/11   ad       Added code for FEATURE CPC DTX HS SCCH REVERT HHO RECOVERY feature
07/08/11   gv       Fixed KW errors
05/27/11   ad       Fixed bug in rrcllc_update_l1_e_info_for_new_e_dch_transmission
05/27/11   as       Fixed osys bugs
05/17/11   rl       Fixed the compiler warnings
05/16/11   as       Made changes to allocate memory in handover to utran preconfig functions
05/10/11   as       Made changes to process edch info after extracting e-rnti
05/10/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.97.50
05/03/11   as       Made changes to display CRNTI and URNTI events
05/03/11   rl       Fixed the lint error
05/02/11   kp       Init ptr tmp_rab_setup_list for G2W IRAT-HO R7/R8
05/02/11   kp       Made changes to pass complete config for G2W IRAT-HO R3
04/25/11   rl       Fixed the KW error
04/12/11   kp       Made changes to pass predefined config for G2W IRAT-HO
04/12/11   su       Made changes to correct the condition check for loop index
                    to check for affected RB list.
04/11/11   kp       Bug fix to correct bit mask that will take care of null ptr 
                    access in rrcllc_handover_to_utran_ie.
04/08/11   ad       Made changes to access pointer after memory allocation for
                    rrc_DL_DPCH_InfoPerRL_fdd structure in rrcllc_handover_to_utran_ie
03/29/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.94.50
03/23/11   ad       Removing code to force DTX-DRX reconfig in case of HS-DSCH serving 
                    cell change which DTX-DRX timing continue.
03/28/11   rl       Merged the HS-FACH/PCH changes from mainline
02/15/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.91.50
02/04/11   as       Made changes to process efach info for non R7 releases
02/03/11   as       Fixed compilarion error
02/03/11   as       Made changes to do rnti validation for dch to fach/pch
                    transition when efach is enabled 
02/11/11   rl       Fixed the compiler warning
02/07/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.90.50
01/28/11   rl       Fixed the objective systems changes found during testing
01/28/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.89.57
01/12/11   ad       Added changes for RRC SW decoupling
01/04/11   su       Made changes to configure mac-hs with bit aligned on Mac-ehs to Mac-hs 
                    transition when Downlink HS-PDSCH information IE is missing.
01/04/11   rl       Merged with VU_MODEM_WCDMA_RRC.01.87.50
12/09/10   kp       Added code to force DTX-DRX reconfig in case of HS-DSCH serving 
                    cell change which DTX-DRX timing continue.
12/08/10   as       Added changes to use correct bitmask while extracting C-RNTI
                    from R8 RB Setup message
12/31/10   rl       Merged with VU_MODEM_WCDMA_RRC.01.86.50
12/11/10   rl       Fixed compiler errors for FEATURE_WCDMA_CPC_DTX
11/11/10   as       Fixed compiler errors for MIMO
11/09/10   rl       Merged with VU_MODEM_WCDMA_RRC.01.84.50
10/14/10   su       Fixed compiler errors.
10/13/10   su       Fixed Klocwork errors.
10/11/10   su       Correcting the bitmask to pointer
10/11/10   ss       ASN.1 migration to ASN1 9.3.0
10/11/10   su       Made changes to retain the older TFRI table if 
                    whole Downlink HS-PDSCH information IE is missing.                 
10/04/10   prk      Added code to support FEATURE_WCDMA_HS_PCH.
10/04/10   prk      Merging latest e-fach fixes.
10/01/10   su       Fixed compiler warnings
09/27/10   su       Added code to get CPC DTX params from Release 8 OTA
09/20/10   prk/kp   Added code to support FEATURE_WCDMA_HS_FACH
11/03/10   rl       Fixed compiler warnings
10/30/10   rl       Objective systems migration changes check in 
                    on code base VU_MODEM_WCDMA_RRC.01.80.00
08/02/10   prk      Made changes to skip re-initializing DOFF bitmask in L1 
                    opt_parm_presence_bitmask when RRC is in DCH state.
06/18/10   dm       Fixed compliation warning.
06/03/10   gkg      Made changes to implement Spec CR3955 "Carrier-specific STTD configuration 
                    for DC-HSDPA". Changes are under feature FEATURE_WCDMA_DC_HSDPA_DIFF_TXD_MODE
05/24/10   kp       Added code for feature CPC-DRX under feature flag FEATURE_WCDMA_CPC_DRX
05/21/10   gkg      Made changes to configure AMR codec Type in MAC for R7/R8 RB-Setup
                    OTA Processing.
05/03/10   gkg      Made changes to fix compile errors when enabling FEATURE_WCDMA_FDPCH_STTD.
04/15/10   gkg      Made changes for processing MIMO Codebook Restriction.
04/07/10   gkg      ASN.1 migration to 8.a.0
04/07/10   gkg      Corrected compile errors and errors arising thru ASN.1 migration.
04/01/10   gkg      Made changes not to process EUL IEs for R6 IEs if validation failure
                    happens earlier while processing the OTA.
03/17/10   gkg      Made changes to populate Secondary C-PICH Power Offset 
                    from R7 and R8 OTAs for MIMO UEs.
03/17/10   as       Resolved Errors due to ASN.1 8.9 Migration
03/15/10   as       Updated RRC Code to support ASN.1 8.9 version
03/15/10   gkg      Made changes to put changes for "Multiple DRX Cycles" and 
                    "CU wait Timer" under feature R7. 
02/01/10   dm       Made changes for converting asn1 value of time for DRX cycle2 to 
                    actual value.
01/21/10   kp       Added code to indicate L1 with STOP and START DTX if its HHO or 
                    Forced SYNC A or tau_dpch_change.
12/21/09   gkg      Made changes for CSoHSPA under feature FEATURE_CS_VOICE_OVER_HSPA.
10/20/09   gkg      Made changes so that HARQ Info is processed through R8 PCRC OTA.
10/23/09   dm       Fixed Klocwork warnings
10/21/09   gkg      Fixed the compile errors that popped-up when feature E-FDPCH is defined.
10/12/09   kp       If N/W is providing AGCH info for non EUL serving RL then don’t 
                    indicate add/reconfig action to L1, since AGCH makes sense 
                    only for serving RL.
10/07/09   gkg\kp   Changes for REL8 under FEATURE_WCDMA_REL8 and CPC-DTX
09/03/09   ps       Made changes for EDPCCH power Boost under 
                    FEATURE_WCDMA_REL7_EDPCCH_POWER_BOOST
07/16/09   ps       Fixed Typo error to check for Dl Add trch List bitmask
                    for processing the Dl Add Trch list in R7 Cu Cnf msg
07/16/09   kp       Added code to change the enum member name CM_NONE to RRC_CM_NONE in 
                    rrcllc_cm_status_e_type as it was conflicting with MS VS 2005.NET 
                    which is needed for RRC UTF.
07/06/09   gkg      Added the missed processing of MIMO for R99 RB-Setup & RB-Release 
                    OTAs. Without this fix, MIMO mightn't be stopped if UE receives R99 RBS/RBR.
06/09/09   gkg      Corrected the procesing of IEs delayRestrictionFlag and
                    mbms_PL_ServiceRestrictInfo for R7 Signaling OTAs.
05/29/09   gkg      Made changes so that validation check for DOFF and
                    DPCH Frame Offset is performed for G2W HO through R99/R5
                    HandoverToUTRAN message. Also added the missing check for
                    UL/DL TFCS during G2W HO.
05/25/09   ps       Made changes for EDPCH interpolation support
05/18/09   gkg      To fix compilation warning, moved the definition of 
                    rrcllc_srb5_ho_info() under R6.
05/11/09   ps       Feature to dynamically allocate OC, CC, TOC ptr
05/08/09   ss       Updated Copyright Information
05/04/09   ps       Made changes to update the TFRI table status for Non-R7 OTA 
                    also
04/29/09   ss       Made changes to compiler warnings on gcc compilers.
03/26/09   ps       Made changes to include hw.h instead of hw_api.h, as hw_api.h
                    will be removed for some of the targets    
03/20/09   gkg      Made changes so that Reconfig OTA isn't rejected if High Mobility
                    Indication IE is present in the OTA. This check should have been 
                    removed while making changes for R7 Spec CR for High Mobility Ind.
03/09/09   ps       cleanup of feature flag 
                    FEATURE TFC RLC SIZE
                    FEATURE_DCH_FACH_STATE_TRANSITIONS
                    FEATURE TFC RLC SIZE
                    FEATURE_DCH_IE_IN_CELL_FACH
                    FEATURE_TFCSUBSET
                    FEATURE_ADJUST_TB_SIZE_WHEN_TRCH_INFO_NOT_PRESENT
03/02/09   ps       Indicate Stop and Start to EUL if Tau DPCH changes by 1
                    under FEATURE_WCDMA_REL7_HACK_CHG_TAU_DPCH
02/13/09   gkg      Made changes so that the updation of OC by HandoverToUTRAN is not failed 
                    if tfcs-ubset List IE is missing from the message.
01/19/08   ps       Made changes for ASn1 migration 25.331v7.9  
                    i.e.May 2008 version  (2008-05) 
21/11/08   gkg      Merged the changes that are needed for disabling HS on LCU build.
10/23/08   ps       Made changes to support FEATURE_WCDMA_TRIM_CAPABILITY
10/10/08   ps       Made changes to support Delay restriction IE
10/10/08   ps       Removal of feature FEATURE_GTOW_HO_TO_UTRAN_SPOOF_ENABLE
                    As the Spoof  is no longer required for Anritsu
09/30/08   ps       Fixed compilation errors for MIMO
09/29/08   ps       Check-in of some bug fixes for MIMO
09/12/08   ps       Added code for REl7 under FEATURE_WCDMA_REL7
07/04/08    ps      Made changes to set hrnti_changed as True when  there is
                    a change in HRNTI, this is done so that CPHY_HS_DSCH_CFG_INCL
                    is set to true in this case when FEATURE_HSDPA_PERFORMANCE_OPTIMIZATION
                    is defined
06/16/08    ps      Corrected featurisation issues for FEATURE HSDPA
06/12/08    ps      Made changes to not call rrcllc_get_predefined_rab_info
                    for SRB5 DCs, as an untialised pointer is passed otherwise
04/25/08    ps      Made changes to pass num_trch and num_tfci as 0 to L1
                    when num_dpdch in UL is 0
04/18/08    gkg     Fixed Klockwork errors.
03/04/08    gkg     Added Support for DCs with SRB5 (i.e. 11, 12, 13 and 14) 
                    through RRC Conn Setup OTA. Added function 
                    rrcllc_process_preconfiguration_with_srb5_rrc_conn_setup()
                    to process DCs with SRB5.
03/13/08    kp      Bug fix to take care of clearing e_dl_channel_mask at
                    Stop of EUL.
03/06/08    da      Made changes required to migrate to 09.2007 R6 version of
                    ASN.1
12/03/07    ps      Added support for SRB5 through REL6 OTA messages.
10/30/07    ps      Added support for DC 14. Also added support to extract 
                    SRB5 contents received in Rel6 Handover to utran message.
10/08/07    da      Added change to accept\reject configurations that enable HSUPA
                    and CM based on HSUPA_CM NV item setting.
07/16/07    ps      Made corrections to check the State from the OTA message,  
                    rather than Ordered config state, while checking if any 
                    Trch is mapped to SRBS
07/13/07    da      dl_dpch_mask for R5 rb reconfig shall include a check for
                    rrc_RadioBearerReconfiguration_r5_IEs_dl_InformationPerRL_List 
                    also.
06/29/07    da      Made change to handle ERNTI and HRNTI info before calling 
                    rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action().
06/29/07    ps      Added code to reject a OTA message if the SRBs are not 
                    configured with any Trch configuration.
06/25/07    da      Added code to handle E-RNTI and H-RNTI info in R6 handover to
                    UTRAN message.
05/23/07    ps      Added support for "RB Info to Change" IE in RB-Setup msg.
                    Change are made under feature flag FEATURE_DEFAULT_CONFIG_IN_RB_SETUP.
05/08/07    sm      Necessary clean-up and added function rrcllc_init_before_msg_processing() 
                    to be called before rrc message processing
04/19/07    da      Put TFCS check when TrCH is added/deleted under feature
                    FEATURE_TFCS_SANITY_CHECK.  Also made change to enforce
                    this rule when destination state is CELL_DCH and relaxed
                    the checkf for other states.
04/10/07    ps      Added support for default configs sent through Rb-Setup msg
04/03/07    da      Fix for SYNC-A + EUL.  RRC needs to drop and add EUL channels
                    as well as set the e-dl masks to ADD.
03/08/07    vk      Removed re-dundant initialization of HSDPA parameters in
                    in R6 fn rrcllc_active_set_update_ie_r6() fn under FEATURE HSDPA
03/05/07    da      Corrected bitmask check in R6 TrCH IE handler function.
03/02/07    ps      Added support for Wb-AMR under the feature flag
                    FEATURE_VOC_AMR_WB.
02/28/07    sgk     Added support for HSDPA ASU repointing under 
                    FEATURE_HSDPA_ASU_REPOINTING. 
02/26/07    sm      Added code to reject EUL+CM configuration for early R6 UEs
02/26/07    da      Calling function rrcllc_validate_rb_mapping_info() to validate
                    mapping info provided by the NW.
02/12/07    da      Corrected bitmask check to process dl add reconfig trch info
                    in rrcllc_rrc_conn_setup_ie_r6
02/12/07    ps      Removed the array declaration of tmp_dl_rl in the functions
                    rrcllc_handover_to_utran_ie() and
                    rrcllc_handover_to_utran_process_preconfig_r6()                       
02/07/07    da      Added check to reject configuration if the config adds or deletes 
                    DCH TrChs, and the IE "TFCS" is not included for either the uplink or 
                    the downlink and for that direction after the reconfiguration there is one 
                    or more DCH
02/05/07    da      Corrected activation time calculation during DCH->FACH transitions
                    when feature FEATURE_RRC_DELAY_DCH_FACH is defined.
02/05/07    ps      Made fix for handling of REL6 UtranToHandover msg for
                    default configs
02/02/07    da      Made change for handling activation time for DCH->FACH.
                    Cleaned up activation time code and using 
                    rrcllc_update_activation_time_in_oc() for all reconfig msgs 
01/04/07    sm      Made changes to accomodate L1 request to indicate AGCH reconfig
                    in serving RL whenever E-RNTI is updated.
12/21/06    sm      Fixed 7200 lint error
12/19/06    sm      Clear UL-EDCH-Information stored in MAC datastructures when
                    UE moves out of DCH
11/20/06    da      Made change to always restore oc_ptr before returning
                    when oc is pointing to toc.
11/15/06    sm      Added EUL HHO and reverting back to old config support
19/09/06    sm      Corrected the check for harq_rv_config in rrcllc_evaluate_e_dch_-
                    transmission_variable()
09/09/06   sm/da    Fix code review comments and general clean-up for REL6 and HSUPA and
                    cleaned up #else part of FEATURE_SPEC_CR2393
08/30/06    sm      Fixed REL6 compilation errors because of REL-6/EUL merge to mainline
08/29/06   sm/da    Made changes required for R6 ASN.1 migration. Also merged
                    FEATURE_WCDMA_REL6 and FEATURE WCDMA HSUPA.
08/21/06    tkk     Added SRB#5 support.
08/17/06    tkk     Added correct validation of tx diversity received in 
                    ASU message against the current one.
08/02/06    tkk     Extended validation of ASU message to return the exact 
                    failure cause instead of "unsupported" configuration.
07/13/06    da      Added calling function rrcllcpcie_is_hho to set 
                    ordered_config_ptr->is_hho flag when OTA msg is rcvd.  First 
                    time into DCH or DCH->DCH with disjoint set is considered HHO.
                    Also added a check to see if tb_size is greater than 0 before 
                    decrementing the tb_size by RRCLLC_DED_MULTI_LOG_CHL_DL_DCH_MAC_HDR_SIZE
                    due to mapping info change from multiple to single logical chan.
06/05/06   sgk      Made changes to include rel5 non HSDPA functionality under 
                    FEATURE REL5 while retaining the HSDPA specifc processing 
                    under FEATURE HSDPA.
05/01/06    vk      In the Reconfig Procedure handling for each R5 msg that can
                    activate HSDPA, check if HRNTI has changed when HSDPA is already
                    active and set the hrnti variable to TRUE in hsdpa_msg_params
                    structure. Changes have been featurized under 
                    FEATURE_HSDPA_PERFORMANCE_OPTIMZATIONS
04/20/06    vk      Added more debug statements to prints HSDPA+CM variables
                    while setting HSDPA Action
04/18/06    da      Modified code to support migration to Mar-06 Rel-5 ASN1 +
                    R6 Hacks
04/13/05    vk      Declared an extern cm_status_from_ota_msg that is used to retrieve
                    the status of CM from the Reconfiguration Message. Initialized the
                    variable cm_status_from_ota_msg to CM_NONE on processing of
                    every R5 Reconfiguration Msg. Also, added more checks to reject
                    the activation of HSDPA with CM and vice versa under
                    FEATURE HSDPA
03/28/06    vk      Check if HSDPA+CM is active under FEATURE_RRC_ENABLE_CM_HSDPA
                    for each Reconfiguration procedure after the setting of HSDPA
                    action
03/10/06    da      Added Initial support for PDCP under FEATURE_UMTS_PDCP
03/06/06    tkk     Added support for TFC subset handling through reconfiguration/
                    interRAT messages.
02/28/06  da/sm     Modified code to support migration to Dec-05 Rel-6 ASN1
12/20/05    bd      Changed syntax for suppressing lint error 613
12/01/05    vk      While processing Release 5 Cell Update Confirm Message,
                    initialize hsdpa_msg_params structure so as to reset
                    to default parameters so that HS PSC is not taken from
                    the old configuration
11/16/05    vm      Fixed compilation error. 
11/10/05    da      Removed extern definition of nv_rel_ind;
11/10/05    da      Checking global flag rrc_nv_rel_indicator before doing R5 related
                    processing.
11/10/05    tkk     Added support for Rel-5 Interrat HO To UTRAN.
11/03/05    vk      Once ASU delets the HSDPA link, made the change to not invalidate
                    the HSDPA Serving Link
11/03/05    da      Made change to save common trans chan info if next state
                    indicated by rb setup msg is non-dch.  This change is needed only 
                    for R5 part of code as it was already there for R99.
10/03/05    tkk     Added support for handling signaling default configurations 
                    (0 & 1) received in Rel-5 RRC connection setup message.
08/24/05    da      Made change to store transport channel information in TOC when
                    next state indicated by msg in CELL_PCH or URA_PCH.  TOC will get 
                    copied into OC upon going back to DCH.
08/10/05    vk      If network initiates an IntraFreq/InterFreq Hard HO with HSDPA
                    being Active through a Release 99 Message, set the HSDPA
                    action to STOP through function rrcllc_set_r99_hsdpa_action.
                    Cleaned up the old code that used to set R99 HSDPA action
07/12/05    vk      Added check to RETURN failure if network sends an invalid
                    HRNTI. Remove an unneccessary check to check if HRNTI status
                    is invalid in OC before setting it again
06/08/05    vk      Check for HRNTI bit mask while processing Transport Channel
                    Reconfiguration Message Release 5 under FEATURE HSDPA
06/01/05    da      Forcing activation time to now for any connecting->wildcard
                    and fach->wildcard transition.
05/26/05    vk      Implemented code for Spec CR 2393 under FEATURE_SPEC_CR2393.
                    The code has been featurized in such a way that if the feature
                    is turned off then, UE follows June 04 specs
05/12/05    da      Changed activation time to now for any fach->dch transition.
04/22/05    vk      In case of repointing with HHO, specified the new HRNTI to L1
03/23/05    da      Added change in cell_update_confirm_ie() to store DCH info in TOC
                    when current state is FACH and DCH info is present.
03/11/05   vk       Merged HSDPA code in Mainline from RRC_MSM6275 branch under FEATURE HSDPA
03/02/05   ttl      Support RRC ASN1 Release 5.
12/16/04    sk      Added a check so that C-RNTI will not be copied from message 
                    if next state is any state other than CELL_FACH state.
08/26/04    ttl     Added messages for TB size adjustment.
                    Fixed a bug in flag checking in cell update procedure.
                    Added num_Trch in find_trch_id_in_config_trch_list2 and 
                    find_trch_id_in_config_trch_list.
08/23/04    jh      Expanded DCH IE processing in Cell_FACH to catch some IEs
                    that were left out.
08/19/04    sgk     Removed the variable idx as it is not used in function 
                    find_trch_id_in_config_trch_list2 and 
                    find_trch_id_in_config_trch_list to fix lint error 
08/02/04    jh      Moved TX Diversity Mode processing ahead of Radio Link
                    Addition Information processing in the Active Set Update
                    message.  This fixes the problem of per-RL diversity
                    mode information being ignored for lack of diversity
                    type having specified.
07/30/04    vn      Ensure that timing init type is set to "timing maintained"
                    when that is not present in a message with next state as DCH.
07/27/04    ttl     Put code for TB size adjusting when TrCH info not present
                    under FEATURE_ADJUST_TB_SIZE_WHEN_TRCH_INFO_NOT_PRESENT
07/22/04    kc      Fix to update URNTI present flag to true when we get a new URNTI
                    during a GtoW Handover
07/19/04    ttl     Adjust TB size when the number of LCs mapped onto a TcCH is 
                    changing from 1 to 2 or 2 to 1.
07/15/04    jh      Removed repeated code for reading Frequency Info and
                    Downlink Information Per RL IEs and replaced with calls
                    to new get_frequency_info() and get_dl_info_per_rl()
                    functions.
06/25/04    ttl     Adjust the TB size when the adding LCs in the RB setup msg
                    are mapped into a existing TrCH but the TrCH ie is missing
                    in the RB setup msg.
06/17/04    jh      Added changes to clear out old scrambling codes in
                    l1_dl_chan_parms.dl_per_rl[] after a hard handover.
06/09/04    sk      check for URNTI presence instead of CRNTI in cucnf msg
                    for SCPCH index.
05/25/04    jh      Initialize L1 DL common optional parameters bitmask so
                    as not to carry over previous junk values.
05/06/04    jh      Added calls to rrc_validate_frequency_info() to reject
                    invalid UARFCN values.
05/05/04    jh      Fixed problem with prematurely declaring the active set
                    to be empty when processing ASU message.
05/03/04    jh      Enabled intra-frequency hard handovers.
04/02/04    jh      Restored original order of RL addition processing and RL
                    removal processing in ASU message IE.  Order matters only
                    at L1 level and was causing problems for RRC.
02/25/04    kc      Moved CELL_PCH FEATURE defn. around correct code for
                    handling cell-update-confirm message.
02/17/04    jh      Exchanged order of RL addition processing with RL removal
                    processing in ASU message IE in accordance with spec.
01/14/04    jh      Added logic to accomodate CELL_PCH and URA_PCH state
                    transitions requested in message IEs.
12/11/03    jh      Added support for FACH->DCH transitions with inter-freq
                    hard handover.
12/04/03    vn      When processing any of the Reconfig messages that have 
                    an activation time other than now, fill in the sdu_time 
                    from the global array into Ordered Config. 
11/13/03    jh      Set reconfig_in_progress flag to true when any reconfig
                    message IE is processed.
10/08/03    jh      Fixed srnti2 calculation for G2W handover.  The 10-bit
                    value was erroneously placed into the upper 10 bits of a
                    uint16, not the lower 10 bits.  Changed RB Setup processing
                    to allow SRBs to be set up.
09/22/03    jh      Added support for replacing radio links in a reconfig
                    message for inter-frequency hard handover case.
09/17/03    jh      Removed rejection of ciphering IEs in Handover to UTRAN
                    Command.  Changed formula for dpcch_PowerOffset in
                    Handover to UTRAN Command to make the value compatible with
                    existing RRC functions.
09/09/03    jh      Enabled processing of frequency info IE for interfrequency
                    handover.
08/04/03    jh      Added QXDM messages for ASU failure cases.
07/15/03    jh      Changed message processing for DL Information per RL to
                    only modify existing radio links when processing reconfig
                    messages in Cell_DCH state.
06/27/03    jh      Fixed lint errors.
05/02/03    jh      Corrected name of FEATURE_GTOW_HO_TO_UTRAN_SPOOF_ENABLE
04/30/03    jh      Corrected name of FEATURE_INTEGRATION_TEST_GTOW_HO_TO_UTRAN
04/21/03    vn      Addition of new parameter to rrcllc_populate_mac_rlc_
                    size_restriction_info()
04/28/03    jh      Added support for enabling/disabling g2w spoofing of
                    Doff and TauDPCH values at runtime.
04/24/03    jh      Added support for maxAllowedUL_TX_Power in Handover to
                    UTRAN message
04/10/03    jh      Added support for temporarily pointing ordered_config_ptr
                    at transition_config.toc in order to process and store DCH
                    IEs in Cell_FACH state.
03/27/03    vn      Made changes to allow DCH-FACH transitions thru' Transport
                    and Physical Channel Reconfig messages.
03/24/03    jh      Corrected edit history.
03/20/03    jh      Added validations to enforce presence of UL Channel
                    Requirement, DL Common Information, and DL Information
                    per RL IEs are present when transitioning from a non-DCH
                    state to DCH.
03/20/03    jh      Corrected calculation of Doff and TauDPCH for predefined
                    GtoW handovers.                    
02/27/03    vn      Merged the following from branch:
            vn      Added processing for DCH->FACH transition in RB 
                    Release message handling. Added handling of directed cell
                    in all messages that could transition UE from CELL_DCH
                    to CELL_FACH.
            vn      While processing "Added reconfigured DL TrCH Info", do
                    not advance UL TrCH Info pointer. This ensures all UL TrCHs
          are accessed in the linked list.
            vn      Added correct handling of "frequency info" in various
                    messages. If "frequency info" has the same frequency as
                    the one camped on, it is ignored and not rejected.
02/14/03    kc      Fixed compilation warnings.
02/14/03    kc      Changed feature defn from INTERRAT_HANDOVER_GTOW_RRC to 
                    INTERRAT_HANDOVER_GTOW
02/14/03    jh      Added code in rrcllc_handover_to_utran_ie() to properly
                    calculate the DPCH frame offset.
02/05/03    sk      March2002Rel specific changes 
                    Changed  rrc_dl_PDSCH_Information to
                    rrc_modeSpecificPhysChInfo_fdd_dl_PDSCH_Information  
                    Changed rrc_rl_RemovalInformationList
                    to rrc_rl_RemovalInformationList
                    Changed  rrc_rab_InformationSetupList   
                    to rrc_RadioBearerSetup_r3_IEs_rab_InformationSetupList
02/04/03    ram     Checked in lint changes, updated copyright.
12/11/02    jh      Temporarily disabled FEATURE_UMTS_CIPHERING_ENABLED blocks.
11/22/02    jh      Added code to prevent erroneous increment of RL count
                    when attempting to add a duplicate RL during active set
                    update.  Added code to prevent removal of last RL with
                    an ASU message.  Added code to properly fill in the core
                    network domain for TrCHs.
11/15/02    jh      Enabled FACH to DCH transition support for RB Release
                    message
10/08/02    vn      Updated RB Reconfig message processing to allow for DCH
                    to FACH state transitions.
10/04/02    jh      When messages are processed that contain RLC size
                    restriction information, the MAC configuration must be
                    updated, unless a FACH<->DCH transition is triggered by
                    the message.  Added appropriate processing.
09/24/02    vn      Changed processing of RB Setup message to work for 
                    DCH to FACH transitions. Added processing for "RB Info 
                    to be affected list" in RB Setup Message handling.
06/28/02    vn      If Downlink Info per Radio Link is not processed (ignored)
                    skip info for the rest of RLs in the message and do not
                    update number of Radio Links in Ordered Config. This is 
                    needed since DL Info per RL is MP for RB Reconfig even when
                    there is no valid data inside.
06/07/02    vn      Changes to process Radio Bearer Release Message.
06/03/02    vn      Changes to process Radio Bearer Reconfiguration Message.
05/16/02    vn      Ignore "RB Info to be affected list" in RB Setup message.
                    This is to work for the case when no useful info is sent
                    in RB Info to be affected list and can be ignored till
                    UE has support for processing this message.
05/08/02    jh      The loops to add and remove radio links in
                    rrcllc_active_set_update_ie() were using the num_rl
                    entries in ordered config directly in loop conditions.
                    This resulted in incorrect behavior, as these values are
                    updated inside the bodies of these loops.  The num_rl
                    values are now saved in locals for use in the loop
                    conditions.
05/07/02    vn      Added processing for Transport Channel Reconfiguration.
04/23/02    vn      If Max UL Power is not present in the message, use the
                    one in Current Config (existing one) instead of reading
                    from SIB3 as that might not be the current one. Support
                    for Physical Channel Reconfig message. Call to
                    update_rm_restriction_info independent of state.
04/22/02    vn      No separate common and dedicated TrCH info is maintained
                    anymore as either one or the other is valid. Changes in 
                    functions that accessed common and dedicated TrCH info.
03/25/02    rj      Modified function rrcllc_rb_setup_ie to initialize
                    rb_setup_ptr for every RAB.
03/08/02    vn      Updated to copy SCCPCH info only when new URNTI is 
                    present in RB Setup Message.
03/04/02    vn      Added Cell_FACH support and changes due to OC cleanup.
                    Fill in activation time in OC for all mesasages. Changed 
                    for rrcllc_rb_setup_ie and rrcllc_rrc_conn_setup_ie:
                    Do not process if next state or state transition not 
                    supported, Correctly update status and values of C-RNTI and
                    U-RNTI based on existing status, took out code for 
                    unsupported states. If next state is Cell_FACH, call OC
                    function to select and get SCCPCH info based on new U-RNTI
                    recd in message. No need to initialize TFCS if common TrCH
                    info recd, it is done by OC updation function. Process 
                    Added/Reconfig/Deleted TrCH info only if new state is DCH.
                    Call update_rm_restrict_info only after getting the RM
                    restriction info. Do not update ul/dl_trch_count. Changes
                    due to moving of local data structures to ordered_config.
12/09/01    kc/rj   Modified functions get_srb_info_to_setup and 
                    get_rb_info_to_setup to use lisked list head pointer for
                    June conversion.
11/16/01    vn      Merged the following from branch -
                    Provided non-sequential transport channel handling:
                    While processing RB Setup, Reconfig, Release, RRC Connection
                    Setup, TrCH Reconfig, call rrcllc_add_delete_and_arrange_
                    dl/ul_dch_trch_info before processing any RB mapping info.
                    This adds, deletes and sorts TrCH IDs upfront, taken from
                    deleted and added/reconfig TrCH list. Removed explicit 
                    calls to process deleted DL/UL TrCH lists as that is taken 
                    care of by the function above. Removed calls to rrcllc_ul/dl
                    _trch_reconfig as that is no longer needed.
11/03/01    vn      Updated to use the renamed constants for UTRAN DRX cycle
                    length minimum and maximum values.
09/13/01    kmp     In rrcllc_rrc_conn_setup_ie() during a CELL_DCH transition,
                    add a call to initialize the downlink Radio link database.
                    Change all occurences of L1_MAX_RL to UE_MAX_RL. In
                    rrcllc_active_set_update_ie() after receiving all 
                    DL add and remove Radio Link info, format it for L1.
08/27/01    kmp     Updated all functions for DRX except
                    rrcllc_active_set_update_ie(). Updated all functions for
                    UL/DL TFS Capability check except
                    rrcllc_active_set_update_ie() and 
                    rrcllc_phychan_reconfig_ie()
08/13/01    kmp     Changed all MSG_HIGHs for Activation Time to MSG_MEDs.
                    Updated the MSG_* contents to reflect the correct OTA
                    procedures. Don't need to process RB with PDCP info
                    list, and RAB to reconfigure list.
07/17/01    kmp     In rrcllc_rb_setup_ie() and rrcllc_rb_release_ie(),
                    check to see if there is a TrCH reconfig. Added 
                    rrcllc_active_set_update_ie(). Fixed a bug where
                    the DL and UL TFCI's may have been reset even if new
                    TFCI data was not signalled. Added the following functions:
                    rrcllc_rb_reconfig_ie(), rrcllc_phychan_reconfig(), and
                    rrcllc_trch_reconfig_ie().
06/14/01    kmp     In rrcllc_rrc_conn_setup_ie(), rrcllc_rb_setup_ie() and 
                    rrcllc_rb_release_ie(), update to clear out the nchan
                    count in the uplink TFCS structure when changing states.
06/13/01    kmp     Finished coding rrcllc_rb_release_ie(). Updated 
                    rrcllc_rrc_conn_setup_ie(), rrcllc_rb_setup_ie() and 
                    rrcllc_rb_release_ie() to loop when clearing out TFS
                    data bases. Updated to make ul_trch_cnt and dl_trch_cnt
                    part of the ordered_config_data structure.
06/06/01    kmp     Updated for cleanup when changing states, from within
                    rrcllc_rrc_conn_setup_ie(), rrcllc_rb_setup_ie() and 
                    rrcllc_rb_release_ie().
06/05/01    kmp     Continue coding rrcllc_rb_release_ie(). Fixed bugs in
                    rrcllc_rrc_conn_setup_ie(), rrcllc_rb_setup_ie() and 
                    rrcllc_rb_release_ie().
05/29/01    kmp     Updated for new RLC interface. Updated to only save the 
                    URNTI and CRNTI in the MAC database instead of there and
                    in the local RRC DB part of Ordered Config. Fixed bugs 
                    where addresses for looping through various linked list 
                    were not correctly assigned.
05/16/01    kmp     Fixed compiler warnings.
05/16/01    jrs     Added ".t" to the parameters of two MSG_ERRORs to fix
                    compile problems.
05/14/01    kmp     Changed calls from get_u_rnti() to rrc_translate_urnti().
05/09/01    kmp     Completed coding of RRC Connection setup, RB Setup for
                    initial relase. Started coding of RB Release message. 
04/13/01    kmp     Updated for December 2000 specs.
03/02/01    kmp     Initial release, just as a holding in case something 
                    happened while on vacation.
===========================================================================*/


/*===========================================================================
                           INCLUDE FILES
===========================================================================*/
#include "wcdma_variation.h"
#include "comdef.h"
#include "err.h"
#include "l1dlcctrchcfg.h"
#include "l1dlphychancfg.h"
#include "l1sapcommon.h"
#include "l1rrcif.h"
#include "l1task_v.h"
#include "l1ulcfg.h"
#include "msg.h"
#include "rrcasn1.h"
#include "rrcasn1util.h"
#include "uecomdef.h"
#include "rrcdata_v.h"
#include "rrcllc.h"
#include "rrcllcoc.h"
#include "rrcsibdb.h"
#include "rrcscmgr.h"
#include "rrcccm.h"
#include "uecomdef.h"
#include "rrciho.h"
#include "rrcrbcommon.h"
#include "rrcnv.h"

#include "rrcrce.h"
#include "rrcrbe.h"

#ifdef FEATURE_WCDMA_HS_FACH
#include "rrcenhstateproc.h"
#include "rrcenhstatecfg.h"
#endif

#include "rrclogging.h"

#ifdef FEATURE_RRC_DELAY_DCH_FACH
#include "seq.h"
#include "rlcrrcif_v.h"
#endif /* FEATURE_RRC_DELAY_DCH_FACH */

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
#include "rrcdt.h"
#endif

/*===================================================================
                        DATA DECLARATIONS
=====================================================================*/


rrcllc_cm_status_e_type cm_status_from_ota_msg = RRC_CM_NONE;

/* HSDPA + CM is enabled by default */
extern uint8 hsdpa_cm_enabled;

#ifdef FEATURE_WCDMA_HS_FACH
extern boolean rrcrbe_send_initiate_cu_flag;
extern boolean rrcrbrc_send_initiate_cu_flag;
extern boolean rrcrbr_send_initiate_cu_flag;
extern boolean rrcpcrc_send_initiate_cu_flag;
extern boolean rrctcrc_send_initiate_cu_flag;
boolean validate_directed_cell_info = FALSE;
#endif
extern boolean rrc_predef_po3_not_needed;
/*===================================================================
                        CONSTANTS
=====================================================================*/
#define NUMBER_OF_RETRANSMISSIONS_OF_CONTROL_PDU 3

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
#define WCDMA_RRC_MINIMUM_ACTIVATION_TIME_FOR_PROCESSING_CPHY_SETUP 50
#endif

/*===================================================================
                        FORWARD DECLARATIONS
=====================================================================*/
uint32 DEBUG_EUL_ERNTI = 0;
  /*Variable to store the UTRAN DRX CYCLE INFO*/
  utran_drx_cycle_type utran_drx_cycle_info;
/*===================================================================
*                       FUNCTION PROTOTYPES
====================================================================*/

/*===================================================================
*                            FUNCTIONS
====================================================================*/
#ifdef FEATURE_WCDMA_DC_HSUPA 
boolean rrcllc_check_add_remove_rl_list_for_sec_eul_if_valid_in_asu
( 
  rrc_RL_AdditionInformationList_SecULFreq  * rl_add_list,
  rrc_RL_RemovalInformationList_SecULFreq   * rl_removal_list
);
#endif
/*============================================================================
FUNCTION: rrcllcpcie_init_drx_info_before_processing()

DESCRIPTION:
  This function will init stored DRX info before processing 
  DRX_info I.E
      
DEPENDENCIES:
  None.

RETURN VALUE:
  SUCCESS/FAILURE

SIDE EFFECTS:
=============================================================================*/
void  rrcllcpcie_init_drx_info_before_processing
(
ordered_config_type *config_ptr
)
{

  config_ptr->drx_info.inact_thrshd_drx_cycle = 
    L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_INVALID;
  config_ptr->drx_info.inact_thrshd_grant_monitoring = 
    L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_INVALID;
  config_ptr->drx_info.l1_ue_drx_grant_monitoring = FALSE;
  config_ptr->drx_info.ue_drx_cycle = L1_UE_DRX_CYCLE_NUM_SUBFM_MAX;
}


/*====================================================================
FUNCTION: rrcllc_init_dtx_params()

DESCRIPTION:
  This function evaluates the value of variable rrcllc_is_dtx_params_variable_set.

DEPENDENCIES:
  Function is only called after processing of all the IEs in a config message is completed.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_dtx_params
(
  ordered_config_type *config_ptr  
)
{
  
  config_ptr->dtx_drx_timing_info.enabling_delay= L1_NUM_RADIO_FRAMES_MAX;
  config_ptr->dtx_drx_timing_info.dtx_drx_offset = 0xFF;
  config_ptr->dtx_info.cqi_dtx_timer = L1_CQI_DTX_TIMER_NUM_SUBFM_MAX;
  config_ptr->dtx_info.default_sg_in_dtx_cycle2 = L1_SERVING_GRANT_NOT_PRESENT;
  config_ptr->dtx_info.dtx_long_preamble_length = L1_LONG_PREAMBLE_LENGTH_NUM_SLOTS_MAX;
  config_ptr->dtx_info.e_tti = NUM_E_TTI;
  config_ptr->dtx_info.inact_thrshd_dtx_cycle2 = L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_INVALID;
  config_ptr->dtx_info.l1_mac_dtx_cycle = L1_MAC_DTX_CYCLE_NUM_SUBFM_MAX;
  config_ptr->dtx_info.l1_mac_inactivity_threshold = L1_MAC_INACT_THRSHD_NUM_TTI_MAX;
  config_ptr->dtx_info.ue_dpcch_burst_1 = L1_UE_DPCCH_BURST_1_NUM_SUBFM_MAX;
  config_ptr->dtx_info.ue_dpcch_burst_2 = L1_UE_DPCCH_BURST_2_NUM_SUBFM_MAX;
  config_ptr->dtx_info.ue_dtx_cycle1 = L1_UE_DTX_CYCLE1_NUM_SUBFM_MAX;
  config_ptr->dtx_info.ue_dtx_cycle2 = L1_UE_DTX_CYCLE2_NUM_SUBFM_MAX;
  config_ptr->dtx_info.uplink_dpcch_slot_format_info = L1_UL_DPCCH_SLOT_FORMAT_MAX;

  config_ptr->cpc_dtx_drx_status = FALSE;
  
  rrcllcpcie_init_drx_info_before_processing(config_ptr);
  config_ptr->cpc_drx_status = FALSE;

}

/*====================================================================
FUNCTION: rrcllc_is_drx_params_variable_set()

DESCRIPTION:
  This function evaluates the value of variable rrcllc_is_drx_params_variable_set.

DEPENDENCIES:
  Function is only called after processing of all the IEs in a config message is completed.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_is_drx_params_variable_set
(
  void
)
{
  boolean local_drx_params_variable = TRUE;

  MSG_HIGH("RRCCPC:inact_thrshd_drx_cycle %d inact_thrshd_grant_monitoring %d ue_drx_cycle %d", 
  ordered_config_ptr->drx_info.inact_thrshd_drx_cycle,ordered_config_ptr->drx_info.inact_thrshd_grant_monitoring,ordered_config_ptr->drx_info.ue_drx_cycle);
    
  if((local_drx_params_variable == TRUE)&&(ordered_config_ptr->drx_info.inact_thrshd_drx_cycle == 
  L1_INACT_THRSHD_FOR_UE_DRX_CYCLE_NUM_SUBFM_INVALID))
  {
    local_drx_params_variable = FALSE;
  }

  if((local_drx_params_variable == TRUE)&&(ordered_config_ptr->drx_info.inact_thrshd_grant_monitoring == 
  L1_INACT_THRSHD_FOR_GRANT_MONIT_NUM_TTI_INVALID))
  {
    local_drx_params_variable = FALSE;
  }

  if((local_drx_params_variable == TRUE)&&(ordered_config_ptr->drx_info.ue_drx_cycle == 
  L1_UE_DRX_CYCLE_NUM_SUBFM_MAX))
  {
    local_drx_params_variable = FALSE;
  }

  
  WRRC_MSG1_HIGH("RRCCPC:local_drx_params_variable = %d",local_drx_params_variable);
  return(local_drx_params_variable);
}

/*====================================================================
FUNCTION: rrcllc_is_dtx_params_variable_set()

DESCRIPTION:
  This function evaluates the value of variable rrcllc_is_dtx_params_variable_set.

DEPENDENCIES:
  Function is only called after processing of all the IEs in a config message is completed.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static boolean rrcllc_is_dtx_params_variable_set
(
  void
)
{
  boolean local_dtx_params_variable = TRUE;

  MSG_9(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RRCCPC cqi_dtx_timer %d dtx_long_preamble_length %d inact_thrshd_dtx_cycle2 % l1_mac_dtx_cycle %d l1_mac_inactivity_threshold %d ue_dpcch_burst_1 %d ue_dpcch_burst_2 %d :ue_dtx_cycle1 %d ue_dtx_cycle2 %d",
  ordered_config_ptr->dtx_info.cqi_dtx_timer,
  ordered_config_ptr->dtx_info.dtx_long_preamble_length,
  ordered_config_ptr->dtx_info.inact_thrshd_dtx_cycle2,
  ordered_config_ptr->dtx_info.l1_mac_dtx_cycle,
  ordered_config_ptr->dtx_info.l1_mac_inactivity_threshold,
  ordered_config_ptr->dtx_info.ue_dpcch_burst_1,
  ordered_config_ptr->dtx_info.ue_dpcch_burst_2,
  ordered_config_ptr->dtx_info.ue_dtx_cycle1,
  ordered_config_ptr->dtx_info.ue_dtx_cycle2);
  
  if(((uint16)ordered_config_ptr->dtx_info.cqi_dtx_timer) == ((uint16)L1_CQI_DTX_TIMER_NUM_SUBFM_MAX))
  {
    local_dtx_params_variable = FALSE;
  }

  if(((uint16)ordered_config_ptr->dtx_info.dtx_long_preamble_length) == ((uint16)L1_LONG_PREAMBLE_LENGTH_NUM_SLOTS_MAX))
  {
    local_dtx_params_variable = FALSE;
  }
  
  if(((uint16)ordered_config_ptr->dtx_info.inact_thrshd_dtx_cycle2) == ((uint16)L1_INACT_THRSHD_FOR_CYCLE2_NUM_TTI_INVALID))
  {
    local_dtx_params_variable = FALSE;
  }
  
  if(((uint16)ordered_config_ptr->dtx_info.l1_mac_dtx_cycle) == ((uint16)L1_MAC_DTX_CYCLE_NUM_SUBFM_MAX))
  {
    local_dtx_params_variable = FALSE;
  }
  
  if(((uint16)ordered_config_ptr->dtx_info.l1_mac_inactivity_threshold) == ((uint16)L1_MAC_INACT_THRSHD_NUM_TTI_MAX))
  {
    local_dtx_params_variable = FALSE;
  }
      
  if(((uint16)ordered_config_ptr->dtx_info.ue_dpcch_burst_1) == ((uint16) L1_UE_DPCCH_BURST_1_NUM_SUBFM_MAX))
  {
    local_dtx_params_variable = FALSE;
  }
     
  if(((uint16)ordered_config_ptr->dtx_info.ue_dpcch_burst_2) == ((uint16)L1_UE_DPCCH_BURST_2_NUM_SUBFM_MAX))
  {
    local_dtx_params_variable = FALSE;
  }
     
  if(((uint16)ordered_config_ptr->dtx_info.ue_dtx_cycle1) == ((uint16)L1_UE_DTX_CYCLE1_NUM_SUBFM_MAX))
  {
    local_dtx_params_variable = FALSE;
  }
   
  if(((uint16)ordered_config_ptr->dtx_info.ue_dtx_cycle2) == ((uint16)L1_UE_DTX_CYCLE2_NUM_SUBFM_MAX))
  {
    local_dtx_params_variable = FALSE;
  }
    
  if(((uint16)ordered_config_ptr->dtx_info.uplink_dpcch_slot_format_info) == ((uint16)L1_UL_DPCCH_SLOT_FORMAT_MAX))
  {

    local_dtx_params_variable = FALSE;
  }

  WRRC_MSG2_HIGH("RRCCPC:local_dtx_params_variable %d uplink_dpcch_slot_format_info %d ", 
    local_dtx_params_variable,ordered_config_ptr->dtx_info.uplink_dpcch_slot_format_info);
    
  return(local_dtx_params_variable);
}
/*====================================================================
FUNCTION: rrcllc_evaluate_dtx_drx_status_variable()

DESCRIPTION:
  This function evaluates the value of variable dtx_drx_status.

DEPENDENCIES:
  Function is only called after processing of all the IEs in a config message is completed.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_evaluate_dtx_drx_status_variable
(
  rrc_RRC_StateIndicator rcvd_state_indicator,
  OSS_UINT32 dtx_drx_timingInfo_present_ota
)
{
  boolean local_dtx_drx_status_variable = FALSE;
  boolean local_drx_status_variable = FALSE;
  hsdpa_action_enum_type hs_action =rrc_get_hsdpa_action() ;

  /*Check for all the below conditions
   *1> Check to see if the UE is in CELL_DCH state 
   *
   *2> Check to see if both variables HS_DSCH RECEPTION 
   * and E_DCH_TRANSMISSION are set to TRUE 
   *
   *3> Check to  see no DCH transport channel is configured 
   *
   *4> Check to see the variable DTX_DRX_PARAMS is set;
   *
   *5> Check to see the UE has received the IE "DTX-DRX timing information"
   * The variable DTX_DRX_STATUS shall be set to TRUE only when all above conditions are met
   */

  if((rcvd_state_indicator  == rrc_RRC_StateIndicator_cell_DCH)&&
      (ordered_config_ptr->e_dch_transmission == TRUE)&&
      ((hs_action == HSDPA_START) ||
       ((rrc_get_hsdpa_status() == HSDPA_ACTIVE) && (hs_action != HSDPA_STOP)) )&&
      (dtx_drx_timingInfo_present_ota)&&
      (rrcllc_is_dtx_params_variable_set() ==TRUE)&&
      ((ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.num_dpdch == 0)&&
      (ordered_config_ptr->l1_dl_chan_parms.use_fdpch == TRUE))
    )
  {
    local_dtx_drx_status_variable = TRUE;
    /*For DRX status to be set to TRUE all above mentioned condition need to be TRUE & additionally 
    * we have DRX I.E's. There cant be any DRX operation with out DTX*/
    if(rrcllc_is_drx_params_variable_set() == TRUE)
    {
      if(current_config_ptr->cpc_drx_status == FALSE)
      {
        WRRC_MSG0_HIGH("RRCCPC: drx_status_variable set to TRUE");
      }
      local_drx_status_variable = TRUE;
    }
    else
    {
     if(current_config_ptr->cpc_dtx_drx_status == FALSE)
     {
       WRRC_MSG0_HIGH("RRCCPC: cpc_dtx_drx_status set to TRUE");
     }
     local_drx_status_variable = FALSE;
    }
  }
  else
  {
    if(current_config_ptr->cpc_drx_status || current_config_ptr->cpc_dtx_drx_status || dtx_drx_timingInfo_present_ota)
    {
      WRRC_MSG5_HIGH("RRCCPC: drx_status_variable: %d, dtx_drx_status_variable: %d, timinginfo_prest=%d num_dpdch=%d use_fdpch=%d",
      local_drx_status_variable, local_dtx_drx_status_variable, 
      dtx_drx_timingInfo_present_ota,ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.num_dpdch, 
      ordered_config_ptr->l1_dl_chan_parms.use_fdpch
      );
    }
    local_dtx_drx_status_variable = FALSE;
    local_drx_status_variable = FALSE;
  }
  ordered_config_ptr->cpc_dtx_drx_status = local_dtx_drx_status_variable;
  ordered_config_ptr->cpc_drx_status = local_drx_status_variable;
}
/*====================================================================
FUNCTION: rrcllc_check_and_stop_dtx()

DESCRIPTION:

  This function will be called by all the pre-Rel7 messages which are capable of DTX operation 
  It will check if DTX operation is ongoing, 
    - if yes, then it will stop DTX 
    - otherwise, it will not do anything.
    
DEPENDENCIES:
  Function should be called only by the pre-Rel7 messages which are capable of DTX operation.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_check_and_stop_dtx
(
  rrc_RRC_StateIndicator rcvd_state_indicator,
  rrc_msg_ver_enum_type     rel_ver
)
{
  boolean dtx_drx_timingInfo_present_ota = FALSE;
  if((rcvd_state_indicator  == rrc_RRC_StateIndicator_cell_DCH)&&
    (current_config_ptr->cpc_dtx_drx_status == TRUE))
  {
    WRRC_MSG1_HIGH("RRCCPC:Stop DTX,msg Rel[%d->0,1,2/R99,R5,R6] is not capable of DTX opert",rel_ver);
    rrcllc_evaluate_dtx_drx_status_var_and_set_lower_layers_action(
       rcvd_state_indicator,
       dtx_drx_timingInfo_present_ota);
  }
}

/*====================================================================
FUNCTION: rrcllc_evaluate_dtx_drx_status_var_and_set_lower_layers_action()

DESCRIPTION:

  This function calls 
    - the function that evaluates the value of variable dtx_drx_status.
    - the function that updates the l1_cpc_dtx_req_mask for L1
    - the function updates the various masks in l1 and other information based on 
      evaluated value of dtx_drx_status variable

DEPENDENCIES:
  Function is only called after processing of all the IEs in a config message is 
  completed.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_evaluate_dtx_drx_status_var_and_set_lower_layers_action
(
  rrc_RRC_StateIndicator rcvd_state_indicator,
  OSS_UINT32 dtx_drx_timingInfo_ota
)
{
  /* evaluate the value of variable e_dch_transmission */
  rrcllc_evaluate_dtx_drx_status_variable(rcvd_state_indicator,
     dtx_drx_timingInfo_ota);

  if(ordered_config_ptr->cpc_dtx_drx_status != current_config_ptr->cpc_dtx_drx_status)
  {
    if(ordered_config_ptr->cpc_dtx_drx_status == TRUE)
    {
      WRRC_MSG0_HIGH("RRCCPC:Start of CPC DTX operation, set action as L1_CPC_DTX_START ");
      ordered_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_START;
      ordered_config_ptr->l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_INIT;
    }
    else
    {
      WRRC_MSG0_HIGH("RRCCPC:Stop of CPC DTX operation, set action as L1_CPC_DTX_STOP ");
      ordered_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_STOP;
      ordered_config_ptr->l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_BACKUP_AND_DISCARD;
    }
  }
  else
  {
    if(FALSE == ordered_config_ptr->cpc_dtx_drx_status)
    {

      WRRC_MSG0_MED("RRCCPC:Set action as L1_CPC_DTX_NO_OP ");
      ordered_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_NO_OP;
    }
    else
    {
      if((TRUE == ordered_config_ptr->is_hho) ||
         (TRUE == ordered_config_ptr->dest_freq_present)
        )
      {
        /* if its HHO or Forced SYNC A and EUL is getting reconfigured then RRC needs 
                 to indicate L1 with STOP and START flag set. L1 is expected to STOP the DTX/EUL 
                 first and once DPCH is configured on the new cell then it should START the
                 EUL followed by DTX config */
        if((ordered_config_ptr->l1_cpc_dtx_req_mask & L1_CPC_DTX_RECONFIG) == 
             L1_CPC_DTX_RECONFIG)
        {/*If l1_cpc_dtx_req_mask is L1_CPC_DTX_RECONFIG, then we should have got new timing with 
         *enabling_delay, whcih we have to use*/
          WRRC_MSG1_HIGH("RRCCPC:HHO use enabling_delay %d",
          ordered_config_ptr->dtx_drx_timing_info.enabling_delay);
        }
        else
        {/*use enabling_delay value of Zero*/
          WRRC_MSG0_HIGH("RRCCPC:HHO use enabling_delay Zero");
          ordered_config_ptr->dtx_drx_timing_info.enabling_delay = L1_NUM_RADIO_FRAMES_0;
        }
        WRRC_MSG0_HIGH("RRCCPC:HHO set DTX action as STOP & START");
        ordered_config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_STOP|L1_CPC_DTX_START;
      }
  
      WRRC_MSG1_HIGH("RRCCPC:l1_cpc_dtx_req_mask = %d [0=NOOP,1=S,2=R,4=Stop]",
           ordered_config_ptr->l1_cpc_dtx_req_mask);
    }
  }

  if(ordered_config_ptr->cpc_drx_status != current_config_ptr->cpc_drx_status)
  {
    if(ordered_config_ptr->cpc_drx_status == TRUE)
    {
      WRRC_MSG0_HIGH("RRCCPC:Start of CPC DRX operation, set action as L1_CPC_DRX_START ");
      ordered_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_START;
    }
    else
    {
      WRRC_MSG0_HIGH("RRCCPC:Stop of CPC DRX operation, set action as L1_CPC_DRX_STOP ");
      ordered_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_STOP;
    }
  }
  else
  {
    if(FALSE == ordered_config_ptr->cpc_drx_status)
    {
  
      WRRC_MSG0_MED("RRCCPC:Set action as L1_CPC_DRX_NO_OP ");
      ordered_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_NO_OP;
    }
    else
    {
      if((TRUE == ordered_config_ptr->is_hho) ||
         (TRUE == ordered_config_ptr->dest_freq_present)
          )
      {
        /* if its HHO or Forced SYNC A and EUL is getting reconfigured then RRC needs 
                  to indicate L1 with STOP and START flag set. L1 is expected to STOP the DRX/EUL 
                 first and once DPCH is configured on the new cell then it should START the
                 EUL followed by DRX config */
        WRRC_MSG0_HIGH("RRCCPC:HHO set DRX action as STOP & START");
          ordered_config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_STOP|L1_CPC_DRX_START;
      }
      WRRC_MSG1_HIGH("RRCCPC:l1_cpc_drx_req_mask = %d [0=NOOP,1=S,2=R,4=Stop]",
           ordered_config_ptr->l1_cpc_drx_req_mask);
    }
  }

  if (FALSE == ordered_config_ptr->cpc_dtx_drx_status)
  {
    rrcllc_init_dtx_params(ordered_config_ptr);
  }
}
#ifdef FEATURE_MAC_I
/*====================================================================
FUNCTION: rrcllc_check_ul_flexible_rlc_size_configured()

DESCRIPTION:
  This function checks if for any of the rbs flexible size is configured

DEPENDENCIES:
  None.

RETURN VALUE:
  boolean

SIDE EFFECTS:

====================================================================*/
static boolean rrcllc_check_ul_flexible_rlc_size_configured
(
  void 
)
{
  uint8 ix, iy;
  mac_e_config_s_type *mac_e_config_ptr = &ordered_config_ptr->mac_e_config;

  for(ix = 0; (ix < mac_e_config_ptr->num_e_mac_d_flow); ix++)
    {
    if(mac_e_config_ptr->e_mac_d_flow_info[ix].e_mac_d_flow_id != INVALID_DFLOW_ID)
      {
      for(iy = 0; (iy < mac_e_config_ptr->e_mac_d_flow_info[ix].num_logch); iy++)
        {
        if (mac_e_config_ptr->e_mac_d_flow_info[ix].e_ul_logch_info[iy].rlc_pdu_type == RLC_FLEXIBLE_PDU_SIZE) 
        {
         WRRC_MSG0_HIGH("MACI UL flexible size configured ");	
          return TRUE;				 
        }
      }
    }
  }

  return FALSE;	
}
/*===========================================================================

FUNCTION rrcllc_set_mace_maci_transition

DESCRIPTION
  This function sets the transition type   between mac-e 
  and mac-i depending on the header type IE and CC and OC.
  
DEPENDENCIES


RETURN VALUE
  None
 

SIDE EFFECTS

  None

===========================================================================*/
static rrc_mac_e_transition_type rrcllc_set_mace_maci_transition
(
  void
)
{

  rrc_mac_e_transition_type mac_e_transition_type= RRC_MAC_E_INVALID_TRANSITION;

  if(ordered_config_ptr->e_dch_transmission== current_config_ptr->e_dch_transmission)
  {
    if(current_config_ptr->e_dch_transmission == TRUE)
    {
      mac_e_transition_type= RRC_MAC_E_NO_TRANSITION;
      if((ordered_config_ptr->mac_ul_parms.ul_pdu_type == MAC_E_PDU_HDR) &&
          (current_config_ptr->mac_ul_parms.ul_pdu_type == MAC_I_PDU_HDR))
      {
        mac_e_transition_type= RRC_MAC_I_TO_E;
        rrcllc_update_mac_eul_action(TRUE);
      }
      else if((ordered_config_ptr->mac_ul_parms.ul_pdu_type == MAC_I_PDU_HDR) &&
          (current_config_ptr->mac_ul_parms.ul_pdu_type == MAC_E_PDU_HDR))
      {
        mac_e_transition_type = RRC_MAC_E_TO_I;
        rrcllc_update_mac_eul_action(TRUE);
      }
    }
    if(mac_e_transition_type != RRC_MAC_E_NO_TRANSITION)
    {
      WRRC_MSG1_HIGH("MAC_I:Transition type %d 0:Invalid 1:EtoI 2:ItoE 3:No Tran",mac_e_transition_type);	
    }
  }
  return (mac_e_transition_type);	
}
#endif /* FEATURE_MAC_I */
/*===========================================================================
FUNCTION rrcllc_update_ernti_in_oc
DESCRIPTION
This function updates the Primary/Secondary E-RNTI received in any reconfig 
message in ordered_config

DEPENDENCIES
  None.

RETURN VALUE
  None
===========================================================================*/
static void rrcllc_update_ernti_in_oc
(
  uint32 ernti_present,
  ASN1BitStr32 ernti,
  boolean is_pernti,
  rrc_RRC_StateIndicator rcvd_state_indicator  
)
{

#ifdef FEATURE_WCDMA_HS_RACH

  if((is_pernti) && (ernti_present))
  {
    WRRC_MSG1_MED("RRCHSRACH:Prev Primary E-RNTI %d ",ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti);
  }
  /*Update Primarary RNTI into hsrach structure */
  if((rcvd_state_indicator != rrc_RRC_StateIndicator_cell_DCH) && (TRUE == is_pernti) && (TRUE == ernti_present))
  {
    ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = TRUE;
    (void)rrc_translate_ernti(&ernti, &ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti);
  }
  if(rcvd_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
  {
    if(is_pernti == TRUE)
    {
      if(TRUE == ernti_present)
      {
        (void)rrc_translate_ernti(&ernti, &transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti);
        transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = TRUE;
      }
      else if(rrc_get_state() == RRC_STATE_CELL_DCH)
      {
        
        transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
          ordered_config_ptr->l1_e_info.e_dl_info.primary_e_rnti_present;

        transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = 
          ordered_config_ptr->l1_e_info.e_dl_info.primary_e_rnti;
      }
      else if(rrc_get_state() == RRC_STATE_CELL_FACH)
      {
        
        transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present = 
          ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti_present;

        transition_config.toc_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti = 
          ordered_config_ptr->l1_hs_rach_e_info.e_dl_info.primary_e_rnti;
      }
    }
  }
#endif

  if ((rcvd_state_indicator != rrc_RRC_StateIndicator_cell_DCH) && ernti_present) 
  {
    WRRC_MSG1_MED("RRCEUL:Ignore ERNTI info.  Next state %d is non-dch",rcvd_state_indicator);
  }
  else
  {
    if(ernti_present)
    {
      uint16 serving_rl_idx;

      rrcllc_update_l1_e_req_mask_for_e_dl_info(TRUE);

      serving_rl_idx = ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx;

      if (serving_rl_idx < L1_MAX_EDCH_RL)
      {
        /* check if AGCH info is present for serving RL, make sure that its not AGCH add and drop */
        if ((L1_E_AGCH_INFO_PRESENT & 
             ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[serving_rl_idx].e_dl_channel_mask) &&
             (! ((L1_E_AGCH_INFO_ADD | L1_E_AGCH_INFO_DROP) & 
             ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[serving_rl_idx].e_dl_channel_mask)))
        {
          /* indicate as reconfig */
          ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[serving_rl_idx].e_dl_channel_mask |= 
            L1_E_AGCH_INFO_RECFG;
        }
      }

      /* if passed in value is for Primary ERNTI, Update Primary E-RNTI in L1 struct */
      if(is_pernti)
      {
        /* Indicate to L1 that have a valid Primary ERNTI*/
        ordered_config_ptr->l1_e_info.e_dl_info.primary_e_rnti_present = TRUE;
        (void)rrc_translate_ernti(&ernti, &ordered_config_ptr->l1_e_info.e_dl_info.primary_e_rnti);
      }  /* If new CRNTI present */
      else
      {
        /* This means Secondary E-RNTI is present*/
        /* Indicate to L1 that have a valid Primary ERNTI*/
        ordered_config_ptr->l1_e_info.e_dl_info.secondary_e_rnti_present = TRUE;
        (void)rrc_translate_ernti(&ernti, &ordered_config_ptr->l1_e_info.e_dl_info.secondary_e_rnti);
      }
    }
    else if (DEBUG_EUL_ERNTI)
    {
       /* This means Secondary E-RNTI is present*/
       /* Indicate to L1 that have a valid Primary ERNTI*/
       ordered_config_ptr->l1_e_info.e_dl_info.secondary_e_rnti_present = TRUE;
       ordered_config_ptr->l1_e_info.e_dl_info.secondary_e_rnti = 
          ordered_config_ptr->l1_e_info.e_dl_info.primary_e_rnti;
    }
  }
}

/*====================================================================
FUNCTION: rrcllc_init_l1_e_dl_info()

DESCRIPTION:
  This function initializes l1_e_dl_info()
DEPENDENCIES:
  Function is only called before processing the DL OTA Msg.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_init_l1_e_dl_info_before_msg_processing
(
  l1_e_dl_info_struct_type *e_dl_info
)
{
  uint32 count;

  e_dl_info->grant_config.serving_grant =  
    L1_SERVING_GRANT_NOT_PRESENT;

  e_dl_info->grant_config.grant_selector = 
    L1_E_GRANT_SELECTOR_NOT_PRESENT;

  e_dl_info->num_e_rl_release_info = 0;

  for (count=0; count <L1_MAX_EDCH_RL; count++)
  {
    e_dl_info->e_dl_rl_add_recfg_info[count].e_dl_channel_mask &= 
      (L1_E_AGCH_INFO_PRESENT|L1_E_RGCH_INFO_PRESENT|L1_E_HICH_INFO_PRESENT);
  }

}

/*====================================================================
FUNCTION: rrcllc_init_e_dch_info_before_msg_processing()

DESCRIPTION:
  This function resets needed E-DCH variables before processing any config message

DEPENDENCIES:
  Function is only called before processing the DL OTA Msg.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_e_dch_info_before_msg_processing
(
  ordered_config_type *config_ptr
)
{
  config_ptr->mac_e_reset_indicator = FALSE;
  config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;
  config_ptr->mac_eul_action = MAC_EUL_NOOP;
  config_ptr->l1_e_req_mask = L1_EUL_NOOP; /* L1_EUL_NOOP */

#ifdef FEATURE_WCDMA_HS_RACH
  config_ptr->l1_hs_rach_req_mask = L1_HS_RACH_NO_OP;
  config_ptr->mac_hs_rach_action = MAC_HS_RACH_NOOP; /* L1_EUL_NOOP */
  config_ptr->mac_hsrach_e_reset_indicator = FALSE;
#endif


  rrcllc_init_l1_e_dl_info_before_msg_processing(&config_ptr->l1_e_info.e_dl_info);
}

#ifdef FEATURE_WCDMA_DC_HSUPA
/*====================================================================
FUNCTION: rrcllc_init_sec_e_dch_info_before_msg_processing()

DESCRIPTION:
  This function resets needed Sec E-DCH variables before processing any config message

DEPENDENCIES:
  Function is only called before processing the DL OTA Msg.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_sec_e_dch_info_before_msg_processing
(
  ordered_config_type *config_ptr
)
{

	//while reverting to old config revert edch function is setting revert but here it is getting reset hence commented
 // config_ptr->mac_e_reset_indicator = FALSE;
 // config_ptr->mac_e_tsn_action = MAC_E_TSN_ACTION_BACKUP;

  config_ptr->mac_sec_eul_action = MAC_SEC_EUL_NOOP;
  config_ptr->l1_sec_e_req_mask = L1_EUL_NOOP; /* L1_EUL_NOOP */

  rrcllc_init_l1_e_dl_info_before_msg_processing(&config_ptr->l1_sec_e_info.e_dl_info);

}



/*====================================================================
FUNCTION: rrcllc_update_mac_eul_action_and_l1_e_req_mask()

DESCRIPTION:
  This function updates the mac_sec_eul_action for MAC and l1_sec_e_req_mask for L1.

DEPENDENCIES:
  Function is only called after processing all the IEs in a config message.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_mac_sec_eul_action_and_l1_e_req_mask(void)
{
  if (ordered_config_ptr->sec_e_dch_transmission != current_config_ptr->sec_e_dch_transmission)
  {
    /* check whether its a start of E_DCH */
    if (TRUE == ordered_config_ptr->sec_e_dch_transmission)
    {
      ordered_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_START;

      /* set EUL action as START */
      ordered_config_ptr->l1_sec_e_req_mask = L1_EUL_START;

      ordered_config_ptr->mac_e_reset_indicator = TRUE;
    }
    else /* its E_DCH stop */
    {
      ordered_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_STOP;

      /* set EUL action as STOP */
      ordered_config_ptr->l1_sec_e_req_mask = L1_EUL_STOP;

      /* set mac_e_reset_indicator to TRUE becaise EUL is being stopped */
      ordered_config_ptr->mac_e_reset_indicator = TRUE;
    }
  }
  else /* it can either reconfig or no-op */
  {
    if (FALSE == ordered_config_ptr->sec_e_dch_transmission)
    {
      /* if we are inside this if, then it means that its a no-op for MAC and L1 */
      ordered_config_ptr->mac_sec_eul_action = MAC_SEC_EUL_NOOP;

      /* set EUL action as STOP */
      ordered_config_ptr->l1_sec_e_req_mask = L1_EUL_NOOP;
    }
    else
    {
      /* no need to change MAC eul action because it is already set while
         processing EUL IEs */
      /* no need to change L1-e-req-mask because it is already set while 
         processing EUL IEs */
       if((TRUE == ordered_config_ptr->sec_eul_is_hho))
       {
        /* if its HHO or Forced SYNC A and EUL is getting reconfigured then RRC needs 
           to indicate L1 with STOP and START flag set. L1 is expected to STOP the EUL 
           first and once DPCH is configured on the new cell then it should START the
           EUL config - old config RLs are present in the rl_release_list[] */
          ordered_config_ptr->l1_sec_e_req_mask = L1_EUL_STOP|L1_EUL_START;

        /*CHECK IF THIS HOLD GOOD FOR SEC EUL AS WELL*/
          if ((FALSE == ordered_config_ptr->mac_e_reset_indicator) && 
              (TRUE == ordered_config_ptr->sec_eul_is_hho))
          {
            /* we want to catch case when NW donot set mac-e-reset indicator to
               TRUE during HHO because as per current RRC-L1 understanding 
               RRC is sending L1 STOP during HHO. Does L1 behaves as if mac-e-reset 
               has received when RRC indicates STOP - need to check. If yes and 
               NW doesnt indicate mac-e reset then we may have to optimize L1 handling */
            WRRC_MSG0_ERROR("DC_HSUPA: mac_e_reset_indicator NOT set during HHO");
          }

          //actually for EUL case and HHO we usually do this relaease and add functionality while processing the IEs
          //based on HHO flag. for primary eul sync A means if only dest frq present...I mean just intra freq HHO in that case
          // we were not doing add and drop for AGCH ..but now for secondary EUL sync A will not be there Imean intra freq HHO
          // is the case where primary EUL changes and where secondary serving chages in these 2 cases also we can configure
          // all RLS I mean those can be considered as HHO so basically if we set the is_sec_HHO to TRUE in these cases the follwoing code is not required

          #if 0
          if (TRUE == ordered_config_ptr->sec_eul_is_hho)
          {
            /* This is a SYNC A scenario.  Will be indicating Stop and Start EDCH to L1.
               Need to set the e-dl channel masks to ADD */
            rrcllcpcie_indicate_drop_and_add_of_e_dch_active_set_rl();
          }
          #endif
       }
    }
  }

  if((ordered_config_ptr->mac_sec_eul_action != MAC_SEC_EUL_NOOP) || 
		(ordered_config_ptr->mac_sec_eul_action != current_config_ptr->mac_sec_eul_action))
  {
    WRRC_MSG2_HIGH("DC_HSUPA: mac_eul_action: %d(NOOP-0, START-1, CONFIG-2, STOP-4) l1_e_req_mask: 0x%x(S-1, UL: 2, DL: 4, STOP: 8, GRANT-RECFG: 0x10)", 
    ordered_config_ptr->mac_sec_eul_action,ordered_config_ptr->l1_sec_e_req_mask);
  }
  
}

#endif /* FEATURE_WCDMA_DC_HSUPA */
/*====================================================================
FUNCTION: rrcllc_update_mac_eul_action_and_l1_e_req_mask()

DESCRIPTION:
  This function updates the mac_eul_action for MAC and l1_e_req_mask for L1.

DEPENDENCIES:
  Function is only called after processing all the IEs in a config message.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_update_mac_eul_action_and_l1_e_req_mask(void)
{
  if (ordered_config_ptr->e_dch_transmission != current_config_ptr->e_dch_transmission)
  {
    /* check whether its a start of E_DCH */
    if (TRUE == ordered_config_ptr->e_dch_transmission)
    {
      ordered_config_ptr->mac_eul_action = MAC_EUL_START;

      /* set EUL action as START */
      ordered_config_ptr->l1_e_req_mask = L1_EUL_START;

      /* whenever its a START of E-DCH then set the mac_e_reset indicator to TRUE
         This will help in cleaning/initialization of MAC E variables.
         If MAC doesnt need this then we can remove it later.
         No UE issue is forseen with this change. */
      ordered_config_ptr->mac_e_reset_indicator = TRUE;
    }
    else /* its E_DCH stop */
    {
      ordered_config_ptr->mac_eul_action = MAC_EUL_STOP;

      /* set EUL action as STOP */
      ordered_config_ptr->l1_e_req_mask = L1_EUL_STOP;

      /* set mac_e_reset_indicator to TRUE becaise EUL is being stopped */
      ordered_config_ptr->mac_e_reset_indicator = TRUE;
    }
  }
  else /* it can either reconfig or no-op */
  {
    if (FALSE == ordered_config_ptr->e_dch_transmission)
    {
      /* if we are inside this if, then it means that its a no-op for MAC and L1 */
      ordered_config_ptr->mac_eul_action = MAC_EUL_NOOP;

      /* set EUL action as STOP */
      ordered_config_ptr->l1_e_req_mask = L1_EUL_NOOP;
    }
    else
    {
      /* no need to change MAC eul action because it is already set while
         processing EUL IEs */
      /* no need to change L1-e-req-mask because it is already set while 
         processing EUL IEs */
       if((TRUE == ordered_config_ptr->is_hho) ||
          (TRUE == ordered_config_ptr->dest_freq_present)
       )
       {
        /* if its HHO or Forced SYNC A and EUL is getting reconfigured then RRC needs 
           to indicate L1 with STOP and START flag set. L1 is expected to STOP the EUL 
           first and once DPCH is configured on the new cell then it should START the
           EUL config - old config RLs are present in the rl_release_list[] */
          ordered_config_ptr->l1_e_req_mask = L1_EUL_STOP|L1_EUL_START;
          if ((FALSE == ordered_config_ptr->mac_e_reset_indicator) && 
              (TRUE == ordered_config_ptr->is_hho))
          {
            /* we want to catch case when NW donot set mac-e-reset indicator to
               TRUE during HHO because as per current RRC-L1 understanding 
               RRC is sending L1 STOP during HHO. Does L1 behaves as if mac-e-reset 
               has received when RRC indicates STOP - need to check. If yes and 
               NW doesnt indicate mac-e reset then we may have to optimize L1 handling */
            WRRC_MSG0_ERROR("RRCEUL: mac_e_reset_indicator NOT set during HHO");
          }

          
          if (((TRUE == ordered_config_ptr->dest_freq_present) &&
              (FALSE == ordered_config_ptr->is_hho))
            )
          {
            /* This is a SYNC A scenario.  Will be indicating Stop and Start EDCH to L1.
               Need to set the e-dl channel masks to ADD */
            rrcllcpcie_indicate_drop_and_add_of_e_dch_active_set_rl(
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                                    FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                                    );
          }
       }
    }
  }
  if((ordered_config_ptr->mac_eul_action != MAC_EUL_NOOP) || 
     (ordered_config_ptr->l1_e_req_mask != L1_EUL_NOOP))
  {
  WRRC_MSG2_HIGH("RRCEUL: mac_eul_action: %d(NOOP-0, START-1, CONFIG-2, STOP-4) l1_e_req_mask: 0x%x(S-1, UL: 2, DL: 4, STOP: 8, GRANT-RECFG: 0x10)", 
    ordered_config_ptr->mac_eul_action, ordered_config_ptr->l1_e_req_mask);
  }
}
#ifdef FEATURE_WCDMA_DC_HSUPA

/*====================================================================
FUNCTION: rrcllc_update_l1_sec_e_info_for_new_e_dch_transmission()

DESCRIPTION:
  This function updates the various masks in l1 and other information based on 
  evaluated value of sec_e_dch_transmission variable.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_update_l1_sec_e_info_for_new_e_dch_transmission
(
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  uint32 count = 0;
  uint32 dl_chan_count = 0;
  if (ordered_config_ptr->sec_e_dch_transmission != current_config_ptr->sec_e_dch_transmission)
  {
    if (TRUE == ordered_config_ptr->sec_e_dch_transmission)
    {
      /* means its a start of E-DCH - make sure that any configured HICH/RGCH/AGCH
         is indicated as ADD */
      for (count=0; 
        count<ordered_config_ptr->l1_sec_e_info.e_dl_info.num_e_dl_rl_add_recfg_info;
        count++)
      {
        if (ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
            e_dl_channel_mask & L1_E_HICH_INFO_PRESENT)
        {
          /* clear any reconfig flag in HICH */
          ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
            e_dl_channel_mask &= ~L1_E_HICH_INFO_RECFG;
          /* set add flag */
          ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[count]. 
            e_dl_channel_mask |= L1_E_HICH_INFO_ADD;
        }

        if (ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
            e_dl_channel_mask & L1_E_AGCH_INFO_PRESENT)
        {
          /* if count is equal to serving rl index then only indicate agch add */
          if (count == ordered_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx)
          {
            /* reset any reconfig flag in AGCH */
            ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
              e_dl_channel_mask &= ~L1_E_AGCH_INFO_RECFG;
            /* set add flag */
            ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
              e_dl_channel_mask |= L1_E_AGCH_INFO_ADD;
          }
          else
          {
            /* clean any ADD or RECFG bits */
            /* reset ADD and reconfig bits in AGCH */
            ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
              e_dl_channel_mask &= ~(L1_E_AGCH_INFO_RECFG|L1_E_AGCH_INFO_ADD);
            WRRC_MSG1_ERROR("DC_HSUPA: AGCH present bit indicates true when psc: %d is not serving e-dch rl",
              ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].e_rl_psc);

            /* clear the present bit for AGCH because this is not a serving-rl */
            ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
              e_dl_channel_mask &= ~L1_E_AGCH_INFO_PRESENT;
          }
        }

        if (ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
            e_dl_channel_mask & L1_E_RGCH_INFO_PRESENT)
        {
          /* reset any reconfig flag in HICH */
          ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
            e_dl_channel_mask &= ~L1_E_RGCH_INFO_RECFG;
          /* set reconfig flag */
          ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
            e_dl_channel_mask |= L1_E_RGCH_INFO_ADD;
        }
      }
    }
    else
    {
      /* stop of E-DCH */
      /* clear E-RNTIs */
      ordered_config_ptr->l1_sec_e_info.e_dl_info.primary_e_rnti_present = FALSE;
      ordered_config_ptr->l1_sec_e_info.e_dl_info.secondary_e_rnti_present = FALSE;
  
      /* set mac-e/es to TRUE */
      ordered_config_ptr->mac_e_reset_indicator = TRUE;

     /* reset serving-rl-idx to indicate that none of the e-dch rl is serving rl */
      ordered_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx = L1_MAX_EDCH_RL;
     /* reset num_e_dl_rl_add_recfg_info to Zero on stop of EUL*/
      ordered_config_ptr->l1_sec_e_info.e_dl_info.num_e_dl_rl_add_recfg_info = 0;
      WRRC_MSG0_HIGH("DC_HSUPA: reset e_dl_channel_mask to Zero on stop of EUL for each RL");
      for (dl_chan_count=0; dl_chan_count <L1_MAX_EDCH_RL; dl_chan_count++)
      {
        /* reset e_dl_channel_mask to Zero on stop of EUL for each RL*/
        ordered_config_ptr->l1_sec_e_info.e_dl_info.
          e_dl_rl_add_recfg_info[dl_chan_count].e_dl_channel_mask = 0;
      }
    }
  }

  if (FALSE == ordered_config_ptr->sec_e_dch_transmission)
  {
    rrcllc_init_mac_sec_ul_edch_info_ie(ordered_config_ptr);
    rrcllc_init_l1_sec_e_ul_info(ordered_config_ptr);
    rrcllc_init_l1_sec_e_dl_info(FALSE, FALSE, ordered_config_ptr);    
    rrcllc_init_l1_dl_sec_fdpch_chan_info(ordered_config_ptr);
  }
}
#endif /* FEATURE_WCDMA_DC_HSUPA */

/*====================================================================
FUNCTION: rrcllc_update_l1_e_info_for_new_e_dch_transmission()

DESCRIPTION:
  This function updates the various masks in l1 and other information based on 
  evaluated value of e_dch_transmission variable.

DEPENDENCIES:
  None

RETURN VALUE:
  None

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_update_l1_e_info_for_new_e_dch_transmission
(
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  uint32 count = 0;
  uint32 dl_chan_count = 0;
  if (ordered_config_ptr->e_dch_transmission != current_config_ptr->e_dch_transmission)
  {
    if (TRUE == ordered_config_ptr->e_dch_transmission)
    {
      /* means its a start of E-DCH - make sure that any configured HICH/RGCH/AGCH
         is indicated as ADD */
      for (count=0; 
        count<ordered_config_ptr->l1_e_info.e_dl_info.num_e_dl_rl_add_recfg_info;
        count++)
      {
        if (ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
            e_dl_channel_mask & L1_E_HICH_INFO_PRESENT)
        {
          /* clear any reconfig flag in HICH */
          ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
            e_dl_channel_mask &= ~L1_E_HICH_INFO_RECFG;
          /* set add flag */
          ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[count]. 
            e_dl_channel_mask |= L1_E_HICH_INFO_ADD;
        }

        if (ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
            e_dl_channel_mask & L1_E_AGCH_INFO_PRESENT)
        {
          /* if count is equal to serving rl index then only indicate agch add */
          if (count == ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx)
          {
            /* reset any reconfig flag in AGCH */
            ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
              e_dl_channel_mask &= ~L1_E_AGCH_INFO_RECFG;
            /* set add flag */
            ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
              e_dl_channel_mask |= L1_E_AGCH_INFO_ADD;
          }
          else
          {
            /* clean any ADD or RECFG bits */
            /* reset ADD and reconfig bits in AGCH */
            ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
              e_dl_channel_mask &= ~(L1_E_AGCH_INFO_RECFG|L1_E_AGCH_INFO_ADD);
            WRRC_MSG1_ERROR("RRCEUL: AGCH present bit indicates true when psc: %d is not serving e-dch rl",
              ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].e_rl_psc);

            /* clear the present bit for AGCH because this is not a serving-rl */
            ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
              e_dl_channel_mask &= ~L1_E_AGCH_INFO_PRESENT;
          }
        }

        if (ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
            e_dl_channel_mask & L1_E_RGCH_INFO_PRESENT)
        {
          /* reset any reconfig flag in HICH */
          ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
            e_dl_channel_mask &= ~L1_E_RGCH_INFO_RECFG;
          /* set reconfig flag */
          ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[count].
            e_dl_channel_mask |= L1_E_RGCH_INFO_ADD;
        }
      }
    }
    else
    {
      /* stop of E-DCH */
      /* set mac-e/es to TRUE */
      ordered_config_ptr->mac_e_reset_indicator = TRUE;

     /* reset serving-rl-idx to indicate that none of the e-dch rl is serving rl */
      ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx = L1_MAX_EDCH_RL;
     /* reset num_e_dl_rl_add_recfg_info to Zero on stop of EUL*/
      ordered_config_ptr->l1_e_info.e_dl_info.num_e_dl_rl_add_recfg_info = 0;
      WRRC_MSG0_HIGH("RRCEUL: reset e_dl_channel_mask to Zero on stop of EUL for each RL");
      for (dl_chan_count=0; dl_chan_count <L1_MAX_EDCH_RL; dl_chan_count++)
      {
        /* reset e_dl_channel_mask to Zero on stop of EUL for each RL*/
        ordered_config_ptr->l1_e_info.e_dl_info.
          e_dl_rl_add_recfg_info[dl_chan_count].e_dl_channel_mask = 0;
      }
    }
  }

  if(FALSE == ordered_config_ptr->e_dch_transmission)
  {
    /*
      8.6.3.14 New E-RNTI 
      If, after the completion of this procedure, the variable E_DCH_TRANSMISSION is set to FALSE, the UE in 
      CELL_DCH state shall: 
      1>  clear the variable E_RNTI. 
    
      If, after the completion of this procedure, the variable READY_FOR_COMMON_EDCH is set to FALSE and the 
      variable HSPA_RNTI_STORED_CELL_PCH is also set to FALSE, the UE shall: 
      1>  if not in CELL_DCH state: 
        2>  clear the variable E_RNTI. 
    */
    ordered_config_ptr->l1_e_info.e_dl_info.primary_e_rnti_present = FALSE;
    ordered_config_ptr->l1_e_info.e_dl_info.secondary_e_rnti_present = FALSE;

    if(rrc_RRC_StateIndicator_cell_DCH != rcvd_state_indicator)
  {
    rrcllc_init_mac_ul_edch_info_ie(ordered_config_ptr);
    rrcllc_init_l1_e_ul_info(FALSE, ordered_config_ptr);
    rrcllc_init_l1_e_dl_info(FALSE, FALSE, ordered_config_ptr);
  }
}
}

/*====================================================================
FUNCTION: rrcllc_is_e_dch_info_stored()

DESCRIPTION:
  This function determines whether e_dch_info is stored or not.

DEPENDENCIES:
  None

RETURN VALUE:
  Boolean

SIDE EFFECTS:
  None.
====================================================================*/
static boolean rrcllc_is_e_dch_info_stored(void)
{
  /* if happy bit delay condition is received then it means that e-dpcch 
     info is received */
  if (0 != 
    ordered_config_ptr->mac_e_config.e_dch_info.e_dpcch_info.happy_bit_delay_in_ms)
  {
    /* e-dpdch info present - check for mandatory IEs */
    if ((ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.num_ref_e_tfci > 0) &&
        (L1_NUM_L1_E_MAX_CH_CODES_SF != 
         ordered_config_ptr->l1_e_info.e_ul_info.e_dpdch_info.e_max_ch_codes)
       )
    {
      return(TRUE);
    }
  }

  return(FALSE);
}
#ifdef FEATURE_WCDMA_DC_HSUPA
/*====================================================================
FUNCTION: rrcllc_evaluate_sec_e_dch_transmission_variable()

DESCRIPTION:
  This function evaluates the value of variable sec_e_dch_transmission.

DEPENDENCIES:
  Function is only called after processing of all the IEs in a config message is completed.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
 boolean rrcllc_evaluate_sec_e_dch_transmission_variable
(
  OSS_UINT32 dc_hudpa_params_present_ota,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  boolean temp_e_dch_transmission_variable = FALSE;
  uint32 serving_rl = ordered_config_ptr->l1_sec_e_info.e_dl_info.e_serving_rl_idx;
  
  /* 1. check RRC next state */
  if(dc_hudpa_params_present_ota == FALSE)
  {
    temp_e_dch_transmission_variable = FALSE;
  }
  else if (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
  {
    /* 2. check for E-RNTI info  this also tells there is valid stored secondary serving EDCH info*/
    if ((TRUE == ordered_config_ptr->l1_sec_e_info.e_dl_info.primary_e_rnti_present) ||
        (TRUE == ordered_config_ptr->l1_sec_e_info.e_dl_info.secondary_e_rnti_present))
    {
      /* 3. check whether there is valid secondary commson edch info  so when ever we STOP DC HSUPA or when we want to delete
                  stored info this scrambling code should be set to RRCLLC_MAX_UL_SCR_CODE */
      if (ordered_config_ptr->l1_sec_e_info.e_ul_info.dpcch_info.scrambling_code <= RRCLLC_MAX_UL_SCR_CODE)
      {
        /* 4. check whether one of the radio link is configured as serving-e-dch-rl */
        if ((serving_rl < L1_MAX_EDCH_RL) &&
            /* 4.1 check whether HICH is configured for this e-dch rl or not */
            (ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[
             serving_rl].e_dl_channel_mask & L1_E_HICH_INFO_PRESENT) &&
            /* 4.2 check whether AGCH is configured for this e-dch rl or not */            
            (ordered_config_ptr->l1_sec_e_info.e_dl_info.e_dl_rl_add_recfg_info[
             serving_rl].e_dl_channel_mask & L1_E_AGCH_INFO_PRESENT)
           )
        {
        /* 5. If num of dpdchs are zero         */
          if(ordered_config_ptr->l1_ul_chan_parms.dpch_cfg.num_dpdch == 0)
          {
           /*6. edch transmission should be true and dc HSUPA should be configured are being taken care before calling this function*/
            temp_e_dch_transmission_variable = TRUE;
          }
          else
          {
            if (TRUE == current_config_ptr->sec_e_dch_transmission)
            {
              WRRC_MSG0_HIGH("DC_HSUPA: e_dch_transmission: 0 (STOP-EUL) -complete e-dpcch/dpdch info NOT present ");
            }
          }
        }
        else
        {
          WRRC_MSG1_HIGH("DC_HSUPA: e_dch_transmission: 0 (STOP-EUL) serving rl : %d[6-No serving RL], HICH/AGCH info not present ",
           serving_rl);
        }
      }
      else
      {
        if (TRUE == current_config_ptr->sec_e_dch_transmission)
        {
          WRRC_MSG0_HIGH("DC_HSUPA: e_dch_transmission: 0 (STOP-EUL) -complete e-dpcch/dpdch info NOT present ");
        }
      }
    }
    else
    {
      if (TRUE == current_config_ptr->sec_e_dch_transmission)
      {
        WRRC_MSG1_HIGH("DC_HSUPA: e_dch_transmission: 0 (STOP-EUL) -Pri/Sec ERNTI is not present ", 
          rcvd_state_indicator);
      }
    }
  }
  else
  {
    if (TRUE == current_config_ptr->sec_e_dch_transmission)
    {
      WRRC_MSG1_HIGH("DC_HSUPA: e_dch_transmission: 0 (STOP-EUL) -state_indicator: %d(D(0)/F(1)/P(2)/U(3) ", 
        rcvd_state_indicator);
    }
  }

  if(temp_e_dch_transmission_variable == TRUE)
  {
    WRRC_MSG2_HIGH("DC_HSUPA: evaluated sec_e_dch_transmission: %d(1:TRUE, 0:FALSE), previous e_dch_txn: %d", 
      temp_e_dch_transmission_variable, current_config_ptr->sec_e_dch_transmission);
  }

  /* set the computed value of e_dch_tranmission vairbale */
  ordered_config_ptr->sec_e_dch_transmission = temp_e_dch_transmission_variable;



  if(TRUE == ordered_config_ptr->sec_e_dch_transmission)
  {

    /* This validate function should be called only if the SECONDARY_CELL_E_DCH_TRANSMISSION is TRUE

        if SECONDARY_CELL_E_DCH_TRANSMISSION variable is set to TRUE:
        2> if the IE "UARFCN downlink (Nd)" is present in IE "Downlink Secondary Cell Info" and is different from
        the stored "Frequency info" in the IE "Secondary E-DCH info common":
        3> UE behaviour is unspecified.*/
    if( FAILURE == rrcllcpcie_validate_dc_hsupa_params())
    {
      return FALSE;
    }
    if((E_TTI_2MS  != ordered_config_ptr->mac_e_config.e_tti)||(ordered_config_ptr->mac_ul_parms.ul_pdu_type != MAC_I_PDU_HDR))
    {
      if(FALSE == current_config_ptr->sec_e_dch_transmission)
      {
        WRRC_MSG2_HIGH("DC_HSUPA: DCHSUPA start is given with tti is %d and ul_pdu_type is %d so reject the config ",
          ordered_config_ptr->mac_e_config.e_tti, ordered_config_ptr->mac_ul_parms.ul_pdu_type);
        return FALSE;
      }
      else
      {
        WRRC_MSG2_HIGH("DC_HSUPA: DCHSUPA cant be continued with tti %d and ul_pdu_type %d hence stop the DCHSUPA ",
        ordered_config_ptr->mac_e_config.e_tti, ordered_config_ptr->mac_ul_parms.ul_pdu_type);
        ordered_config_ptr->sec_e_dch_transmission = FALSE;
        return TRUE;
    }
  }

  }
  return TRUE;
}
#endif /* FEATURE_WCDMA_DC_HSUPA */

/*====================================================================
FUNCTION: rrcllc_evaluate_e_dch_transmission_variable()

DESCRIPTION:
  This function evaluates the value of variable e_dch_transmission.

DEPENDENCIES:
  Function is only called after processing of all the IEs in a config message is completed.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_evaluate_e_dch_transmission_variable
(
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  boolean temp_e_dch_transmission_variable = FALSE;
  uint32 mac_d_flow_idx = 0;
  uint32 serving_rl = ordered_config_ptr->l1_e_info.e_dl_info.e_serving_rl_idx;
  
  /* 1. check RRC next state */
  if (rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
  {
    /* 2. check for E-RNTI info */
    if ((TRUE == ordered_config_ptr->l1_e_info.e_dl_info.primary_e_rnti_present) ||
        (TRUE == ordered_config_ptr->l1_e_info.e_dl_info.secondary_e_rnti_present))
    {
      /* 3. check whether e-dch info (e-dpcch and e-dpdch info is present or not */
      if (TRUE == rrcllc_is_e_dch_info_stored())
      {
        /* 4. check whether one of the radio link is configured as serving-e-dch-rl */
        if ((serving_rl < L1_MAX_EDCH_RL) &&
            /* 4.1 check whether HICH is configured for this e-dch rl or not */
            (ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[
             serving_rl].e_dl_channel_mask & L1_E_HICH_INFO_PRESENT) &&
            /* 4.2 check whether AGCH is configured for this e-dch rl or not */            
            (ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[
             serving_rl].e_dl_channel_mask & L1_E_AGCH_INFO_PRESENT)
           )
        {
          temp_e_dch_transmission_variable = TRUE;
        }
        else
        {
          if (TRUE == current_config_ptr->e_dch_transmission)
          {
            MSG_HIGH("RRCEUL: e_dch_txn: 0 (STOP-EUL) -serv-rl-idx: %d, HICH-present: 0x%x, AGCH-present: 0x%x", 
              serving_rl, ((serving_rl < L1_MAX_EDCH_RL) ? (ordered_config_ptr->l1_e_info.e_dl_info.
              e_dl_rl_add_recfg_info[serving_rl].e_dl_channel_mask & L1_E_HICH_INFO_PRESENT) : 0), 
             ((serving_rl < L1_MAX_EDCH_RL) ? (ordered_config_ptr->l1_e_info.e_dl_info.e_dl_rl_add_recfg_info[
             serving_rl].e_dl_channel_mask & L1_E_AGCH_INFO_PRESENT) : 0));
          }
        }
      }
      else
      {
        if (TRUE == current_config_ptr->e_dch_transmission)
        {
          WRRC_MSG0_HIGH("RRCEUL: e_dch_transmission: 0 (STOP-EUL) -complete e-dpcch/dpdch info NOT present ");
        }
      }
    }
    else
    {
      if (TRUE == current_config_ptr->e_dch_transmission)
      {
        WRRC_MSG1_HIGH("RRCEUL: e_dch_transmission: 0 (STOP-EUL) -Pri/Sec ERNTI is not present ", 
          rcvd_state_indicator);
      }
    }
  }
  else
  {
    if (TRUE == current_config_ptr->e_dch_transmission)
    {
      WRRC_MSG1_HIGH("RRCEUL: e_dch_transmission: 0 (STOP-EUL) -state_indicator: %d(D(0)/F(1)/P(2)/U(3) ", 
        rcvd_state_indicator);
    }
  }

  if (TRUE == temp_e_dch_transmission_variable)
  {
    temp_e_dch_transmission_variable = FALSE;

    /* 5. check whether mac-d flow is configured or not */
    if (ordered_config_ptr->mac_e_config.num_e_mac_d_flow > 0)
    {
      for (mac_d_flow_idx = 0;
        mac_d_flow_idx < ordered_config_ptr->mac_e_config.num_e_mac_d_flow;
        mac_d_flow_idx++)
      {
        /* 5.1 check whether mac-d-flow power offset is provided by the NW */
        if ((ordered_config_ptr->mac_e_config.e_mac_d_flow_info[mac_d_flow_idx].
             e_mac_d_flow_power_offset != 0xFF) &&
        /* 5.2 check whether mac-d-flow max num of retx is provided by the NW */
            (ordered_config_ptr->mac_e_config.e_mac_d_flow_info[mac_d_flow_idx].
             e_mac_d_flow_max_num_of_retx != 0xFF) &&
        /* 5.3 check whether tx grant type is configured by the NW or not */
            (ordered_config_ptr->mac_e_config.e_mac_d_flow_info[mac_d_flow_idx].
             e_tx_grant_info != MAC_E_TX_GRANT_NOT_DEFINED) &&
        /* 5.4 check whether number of log channel mapped to this mac-d flow is more
           than 0 or not */
            (ordered_config_ptr->mac_e_config.e_mac_d_flow_info[mac_d_flow_idx].
             num_logch > 0)
        )
        {
          temp_e_dch_transmission_variable = TRUE;
          break;
        }
      }
    }

    if (TRUE == current_config_ptr->e_dch_transmission)
    {
      if (mac_d_flow_idx == ordered_config_ptr->mac_e_config.num_e_mac_d_flow)
      {
        WRRC_MSG1_HIGH("RRCEUL: e_dch_txn: 0 (STOP-EUL) -num_e_mac_d_flow: %d", 
          ordered_config_ptr->mac_e_config.num_e_mac_d_flow);
      }
    }
  }

  if(temp_e_dch_transmission_variable == TRUE)
  {
    WRRC_MSG0_HIGH("RRCEUL: evaluated e_dch_transmission: TRUE (START-EUL)");
  }
  /* set the computed value of e_dch_tranmission vairbale */
  ordered_config_ptr->e_dch_transmission = temp_e_dch_transmission_variable;

  if (TRUE == ordered_config_ptr->e_dch_transmission)
  {
    if ((ordered_config_ptr->mac_e_config.e_tti == NUM_E_TTI) ||
        (ordered_config_ptr->l1_e_info.e_dl_info.e_tti == NUM_E_TTI) ||
        (ordered_config_ptr->l1_e_info.e_ul_info.e_tti == NUM_E_TTI))

    {
      ERR_FATAL("E-TTI set to NUM_E_TTI when e_dch_transmission set to TRUE", 0, 0, 0);
    }
    if (L1_RV_NOT_PRESENT == ordered_config_ptr->l1_e_info.e_ul_info.harq_rv_config)
    {
      ERR_FATAL("harq_rv_config set to NOT_PRESENT when e_dch_transmission set to TRUE", 0, 0, 0);
    }
  }
}

/*====================================================================
FUNCTION: rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action()

DESCRIPTION:

  This function calls 
    - the function that evaluates the value of variable e_dch_transmission.
    - the function that updates the mac_eul_action for MAC and l1_e_req_mask for L1
    - the function updates the various masks in l1 and other information based on 
      evaluated value of e_dch_transmission variable

DEPENDENCIES:
  Function is only called after processing of all the IEs in a config message is 
  completed.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action
(
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
#ifdef FEATURE_MAC_I
  rrc_mac_e_transition_type mac_e_transition_type = RRC_MAC_E_INVALID_TRANSITION;
#endif /*FEATURE_MAC_I*/
  /* evaluate the value of variable e_dch_transmission */
  rrcllc_evaluate_e_dch_transmission_variable(rcvd_state_indicator);

  if ((TRUE == ordered_config_ptr->e_dch_transmission) &&
      (!CHECK_WCDMA_OPTIONAL_FEATURE_HSUPA_SUPPORTED))
  {
    {
      ERR_FATAL("RRCEUL: e_dch_txn variable TRUE when optional feature EUL(0x%x->0x%x) NOT supported",
      wcdma_nv_optional_feature_list,
      CHECK_WCDMA_OPTIONAL_FEATURE_HSUPA_SUPPORTED, 0);
    }
  }

  /* update mac_eul_action adn l1_e_req_mask as per computed value of
     e_dch_transmission variable */
  rrcllc_update_mac_eul_action_and_l1_e_req_mask();

  /* following should be called after evaluating e_dch_transmission variable */
  rrcllc_update_l1_e_info_for_new_e_dch_transmission(rcvd_state_indicator);
  
  if(TRUE == ordered_config_ptr->e_dch_transmission)
  {
    /*N/W may provide AGCH info for non eul serving RL. Currently L1 logic of detecting serving RL is based on 
     *AGCH info present it doesn't look at eul serving rl idx, So I don't indicate AGCH add/reconfig action for 
     *non-serving RL's. Later if this non-serving RL become serving EUL RL then we indicate AGCH as add even 
     *if N/W doesn't provide AGCH info in the reconfig message that trigger eul serving cell re-pointing, though 
     *spec clearly say N/W should provide AGCH info for serving rl but since some of the N/W doesn't comply with 
     *this we allow this kind of config 
     */
    rrcllc_clear_agch_chan_mask_for_non_serving_rl(ordered_config_ptr
#ifdef FEATURE_WCDMA_DC_HSUPA
                                                  , FALSE
#endif /* FEATURE_WCDMA_DC_HSUPA */
                                                  );

#ifdef FEATURE_MAC_I
    mac_e_transition_type = rrcllc_set_mace_maci_transition();

    /*If there is transition between mac-e and mac-i and vice versa, reset indicator must be true*/
    if(((mac_e_transition_type == RRC_MAC_I_TO_E) || (mac_e_transition_type == RRC_MAC_E_TO_I)) &&
      (ordered_config_ptr->mac_e_reset_indicator == FALSE))
    {
      WRRC_MSG1_HIGH("MAC_I: Transition between Mace and Maci but mac_e_reset_indicator is %d ",ordered_config_ptr->mac_e_reset_indicator);
      return FAILURE;
    }

    /*If ul header type is mac-e then ul flexible size cannot be configured*/
    if((ordered_config_ptr->mac_ul_parms.ul_pdu_type == MAC_E_PDU_HDR) && (rrcllc_check_ul_flexible_rlc_size_configured()))
    {
      WRRC_MSG2_HIGH("MAC_I: UL PDU Header type is %d and Flexible PDU size configured for UL %d ",ordered_config_ptr->mac_ul_parms.ul_pdu_type, rrcllc_check_ul_flexible_rlc_size_configured());
      return FAILURE;
    }
#endif /* FEATURE_MAC_I */
  }
#ifdef FEATURE_WCDMA_16_QAM
  else 
  {
    if((current_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action == TRUE) || 
			(ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action == TRUE))
    {
      WRRC_MSG0_HIGH("HSPA+:Resetting UL 16QAM as EUL is inactive");
    }
    ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_action = FALSE;
    ordered_config_ptr->l1_e_info.e_ul_info.e_ul_16qam_e_agch_table_idx = 0;
  }
#endif

  return SUCCESS;
}



/*===========================================================================
FUNCTION rrcllc_srb5_ho_info

DESCRIPTION


DEPENDENCIES
  None.

RETURN VALUE
  SUCCESS or FAILURE
===========================================================================*/
static uecomdef_status_e_type rrcllc_srb5_ho_info
( 
  struct rrc_RadioBearerSetup_r5_IEs *rbs_r5_ptr 
)
{

  rrc_RAB_InformationSetupList_r5 *rab_setup_r5_ptr = NULL;
  rrc_SRB_InformationSetupList_r5 *srb_setup_r5_ptr = NULL;
  rrc_RB_InformationSetupList_r5 * rb_setup_r5_ptr = NULL ;

  rrc_RB_Identity srb_id = RRCLLC_INVALID_RB_ID;
  rrc_DL_AddReconfTransChInfoList_r5 * dl_add_reconf_trch_list= NULL; 
  rrc_UL_CommonTransChInfo_r4  *ul_common_trans_ch_info_r5_ptr = NULL;
  rrc_SRB_InformationSetup_r5 * srb5_setup_ptr = NULL;
  rrc_UL_AddReconfTransChInfoList * ul_trch_add_reconfig_ptr = NULL;
  uint8      srb_cnt = 0; /* Count of SRBs to set up */
  uint8      rab_cnt = 0; /* Count of RABs to set up */
  uint8      rb_cnt  = 0; /* Count of RBs to set up */
  rrc_RB_Identity rb_id   = CCCH_RADIO_BEARER_ID; /* SRB value */
  uint32 idx=0;


    srb_setup_r5_ptr = &rbs_r5_ptr->srb_InformationSetupList;
    ul_trch_add_reconfig_ptr = &rbs_r5_ptr->ul_AddReconfTransChInfoList;
    dl_add_reconf_trch_list = &rbs_r5_ptr->dl_AddReconfTransChInfoList;        
ul_common_trans_ch_info_r5_ptr = &rbs_r5_ptr->ul_CommonTransChInfo;


    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                  NULL)     == FAILURE)
    {
      return(FAILURE);
    }
    
    if(rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(dl_add_reconf_trch_list, NULL)== FAILURE)
    { 
      return(FAILURE);
    } 
  
    /* Update head pointer */
    
     /* We will be here only when complete config for Rel-5 is chosen */
    while((srb_setup_r5_ptr->n > srb_cnt ) && (srb_cnt < UE_MAX_SRB_SETUP))
    {
      /* Check to see if the RB ID is there ... */
      if(srb_setup_r5_ptr->elem[srb_cnt].m.rb_IdentityPresent)
      {
        rb_id = srb_setup_r5_ptr->elem[srb_cnt].rb_Identity;
      }
       
      /*
      * ... if not, then start with the first SRB and get the next SRB ID
      * each time one is not included in the IE.
      */
      else
      {
        /* Get the next SRB, note this increments to 1 the first time */
        rb_id++;
      }
       
       /* Save off the RB Mapping info for each SRB */
      if(get_srb_info_to_setup_r5(
        &srb_setup_r5_ptr->elem[srb_cnt], 
        srb_setup_r5_ptr, 
        rb_id)
        == FAILURE)
      {
        return FAILURE;
      }
  
      /* Pick that pointer that has RB Id > 4 & 
          assume it to be SRB#5 pointer for the time being */
      if(rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
      {
        srb5_setup_ptr = &srb_setup_r5_ptr->elem[srb_cnt];
        srb_id = rb_id;
      }
       
      srb_cnt++;
    }

     /* We are just validating one more SRB, incase 
       SRB#5 is given by n/w */
    if(srb5_setup_ptr != NULL)
    {
      if(rrcllc_update_oc_with_srb5(srb5_setup_ptr, srb_id) == FAILURE)
      {
        WRRC_MSG0_ERROR("Rejecting SRB#5 configuration given by the network");
        return FAILURE;
      }
    }

    rab_setup_r5_ptr = &rbs_r5_ptr->rab_InformationSetupList;
    
    /* Get the RAB setup list if present */
    while((rab_setup_r5_ptr->n > rab_cnt) && (rab_cnt < MAX_RAB_TO_SETUP))
    {
      rb_setup_r5_ptr  = &rab_setup_r5_ptr->elem[rab_cnt].rb_InformationSetupList;
      rb_cnt =0;
      
      while((rb_setup_r5_ptr->n > rb_cnt) && (rb_cnt < MAX_RB_PER_RAB))
      {
        if(get_rb_info_to_setup_r5(&rb_setup_r5_ptr->elem[rb_cnt], 
#ifdef FEATURE_UMTS_PDCP
                                  rab_setup_r5_ptr->elem[rab_cnt].rab_Info.cn_DomainIdentity,
#endif /* FEATURE_UMTS_PDCP */
                                   rb_setup_r5_ptr) == FAILURE)
        {
          return FAILURE;
        }
        rb_cnt++;
      } /* end RB per RAB setup */
      
      rab_cnt++;
    } /* end rab setup */

    /* Get the Common Uplink Transport Channel information */
    if(get_ul_info_common_for_all_trch_r5(&rbs_r5_ptr->ul_CommonTransChInfo,
                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    { 
      return FAILURE;
    }
     
    /* Do the processing for Uplink added/reconfigured TrCH, Compute
     * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
     * (for Cell FACH state), this check for state needs to be re-examined
     */
    idx = 0;

    /* Save info for each additional Transport Channel */
    while((idx <= UE_MAX_TRCH) && (ul_trch_add_reconfig_ptr->n > idx))
    {
      if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }

      /* get next TrCH Info */
      idx++;
     
    } /* end while */

    /* Check to make sure UL TFS count is within UE Capabilities */
    if(rrcllc_check_ul_tfs_cnt() == FAILURE)
    {
      return FAILURE;
    }  
  
    /* Calculate the UL TFCS */
    compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

    /* There is no scope for TFC subset IE in default configurations as of now.
       Code is written keeping future scope in view 
       Presently default configurations we support map to SIB16  structures
       which is same for Rel99 & Rel5.
       "ul_common_trans_ch_info_ptr" is same for complete or default config */

 
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(rbs_r5_ptr,rrc_RadioBearerSetup_r5_IEs,ul_CommonTransChInfo))
    {
      if(RRC_MSG_COMMON_BITMASK_IE(rbs_r5_ptr->ul_CommonTransChInfo,rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {  
        if(rrcllc_update_oc_with_tfc_subset(&rbs_r5_ptr->ul_CommonTransChInfo, MSG_REL5) == FAILURE)
        {  
          return FAILURE;
        }  
      }

      if(RRC_MSG_COMMON_BITMASK_IE_TYPE2(rbs_r5_ptr->ul_CommonTransChInfo,tfc_SubsetList))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&rbs_r5_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          return FAILURE;
        }
      }
    }
      /* Get the Common Downlink Transport Channel information */
    if(get_dl_info_common_for_all_trch_r5(&rbs_r5_ptr->dl_CommonTransChInfo, 
                                          ul_common_trans_ch_info_r5_ptr,
                                          ordered_config_ptr->rrc_state_indicator)
          == FAILURE)
    { 
      return FAILURE;
    }
      idx=0;
      /* Save info for each additional Transport Channel */
  while((idx <= UE_MAX_TRCH) && dl_add_reconf_trch_list != NULL && (dl_add_reconf_trch_list->n > idx))
    {
      if(get_dl_added_reconfig_trch_r5(&dl_add_reconf_trch_list->elem[idx],
                                  &rbs_r5_ptr->ul_AddReconfTransChInfoList,
                                  FALSE) == FAILURE)
      {
        return FAILURE;
      }
      /* get next TrCH Info */
      idx++;
    } /* end while */
  return(SUCCESS);
  }

/*===========================================================================
FUNCTION rrcllc_preconfig_sib16_ho_info

DESCRIPTION


DEPENDENCIES
  None.

RETURN VALUE
  SUCCESS or FAILURE
===========================================================================*/
static uecomdef_status_e_type rrcllc_preconfig_sib16_ho_info
(
  rrc_SysInfoType16   *sib16_ptr,
    rrc_RAB_InformationSetupList * rab_setup_ptr
 )
{
  rrc_UL_CommonTransChInfo        *ul_common_trans_ch_info_ptr = NULL;
  rrc_DL_CommonTransChInfo        *dl_common_trans_ch_info_ptr = NULL;
  rrc_UL_AddReconfTransChInfoList * ul_trch_add_reconfig_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList * dl_trch_add_reconfig_ptr = NULL;
  rrc_SRB_InformationSetupList    * srb_setup_ptr = NULL;
  
  rrc_RB_InformationSetupList      * rb_setup_ptr = NULL;
 
  
   rrc_RB_Identity rb_id   = CCCH_RADIO_BEARER_ID; /* SRB value */
   uint8      srb_cnt = 0; /* Count of SRBs to set up */
   uint8      rab_cnt = 0; /* Count of RABs to set up */
   uint8      rb_cnt  = 0; /* Count of RBs to set up */
   uint32 idx=0;
  
    /* UL Transport channel information common for all transport channels */
    ul_common_trans_ch_info_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.ul_CommonTransChInfo;
  
    /* DL Transport channel information common for all transport channels */
    dl_common_trans_ch_info_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.dl_CommonTransChInfo;
  
    /* Added or Reconfigured UL TrCH information */
    ul_trch_add_reconfig_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.ul_AddReconfTrChInfoList;
  
    /* Added or Reconfigured DL TrCH information */
    dl_trch_add_reconfig_ptr =&sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.dl_TrChInfoList;

   srb_setup_ptr = &sib16_ptr->preDefinedRadioConfiguration.predefinedRB_Configuration.srb_InformationList;
  
    if(rrcllc_add_delete_and_arrange_dl_dch_trch_info(dl_trch_add_reconfig_ptr,
                                                      NULL) == FAILURE)
    { 
      return(FAILURE);
    } 
    
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                      NULL) == FAILURE)
    { 
      return(FAILURE);
    } 
    
    /* Get the SRB setup list.  This cast is here solely for code reuse.
     * The rrc_SRB_InformationSetupList2 type is identical to the
     * rrc_SRB_InformationSetupList type except for the name.  Later on,
     * we will pass srb_setup_head_ptr to a function that expects the
     * rrc_SRB_InformationSetupList2 type.  Lint is uncomfortable with this
     * cast, so we must reassure it. 
     */
   
    
    while((srb_setup_ptr->n > srb_cnt) && (srb_cnt < UE_MAX_SRB_SETUP))
    {
      /* Check to see if the RB ID is there ... */
      if(srb_setup_ptr->elem[srb_cnt].m.rb_IdentityPresent)
      {
        rb_id = srb_setup_ptr->elem[srb_cnt].rb_Identity;
      }
      
      /*
       * ... if not, then start with the first SRB and get the next SRB ID
       * each time one is not included in the IE.
       */
      else
      {
        /* Get the next SRB, note this increments to 1 the first time */
        rb_id++;
      }
  
      /* Save off the RB Mapping info for each SRB */
      if(get_srb_info_to_setup(&srb_setup_ptr->elem[srb_cnt],
	  	(rrc_SRB_InformationSetupList2 *) srb_setup_ptr, rb_id)
         == FAILURE)
      {
        return FAILURE;
      }
      
      srb_cnt++;
    } /* end SRB setup */

    /* Get the RAB setup list if present */
    if(rab_setup_ptr != NULL)
    {
      while((rab_setup_ptr->n > rab_cnt) && (rab_cnt < MAX_RAB_TO_SETUP))
      {
        
		rb_cnt =0;
        rb_setup_ptr  = &rab_setup_ptr->elem[rab_cnt].rb_InformationSetupList;
        

        
        while((rb_setup_ptr->n > rb_cnt) && (rb_cnt < MAX_RB_PER_RAB))
        {
          if(get_rb_info_to_setup(&rb_setup_ptr->elem[rb_cnt], 
  #ifdef FEATURE_UMTS_PDCP
                                  rab_setup_ptr->elem[rab_cnt].rab_Info.cn_DomainIdentity,
  #endif /* FEATURE_UMTS_PDCP */
                                  rb_setup_ptr) == FAILURE)
          {
            return FAILURE;
          }
         
          rb_cnt++;
        } /* end RB per RAB setup */
  
       
        rab_cnt++;
      } /* end rab setup */
    } /* end RAB setup */
  
  
    if (FAILURE == rrcllc_validate_rb_mapping_info()) 
    {
      return FAILURE;
    }
  
    /* Get the Common Uplink Transport Channel information */
    if(get_ul_info_common_for_all_trch(ul_common_trans_ch_info_ptr,
                                       ordered_config_ptr->rrc_state_indicator)
       == FAILURE)
    {
      return FAILURE;
    }
    
    /* Do the processing for Uplink added/reconfigured TrCH, Compute
     * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
     * (for Cell FACH state), this check for state needs to be re-examined
     */
    idx = 0;
   
  
    /* Save info for each additional Transport Channel */
    while((idx <= UE_MAX_TRCH) && (ul_trch_add_reconfig_ptr->n > idx))
    {
      if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }
      
      /* get next TrCH Info */
      idx++;
    
    } /* end while */
  
    /* Check to make sure UL TFS count is within UE Capabilities */
    if(rrcllc_check_ul_tfs_cnt() == FAILURE)
    {
      return FAILURE;
    }  
    
    /* Calculate the UL TFCS */
    compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
    

    /* There is no scope for TFC subset IE in default configurations as of now.
       Code is written keeping future scope in view 
       Presently default configurations we support map to SIB16  structures
       which is same for Rel99 & Rel5.
       "ul_common_trans_ch_info_ptr" is same for complete or default config */
    if(ul_common_trans_ch_info_ptr != NULL)
    {
      if(RRC_MSG_COMMON_BITMASK_IE_PTR(ul_common_trans_ch_info_ptr,rrc_UL_CommonTransChInfo,tfc_Subset))
      { 
        if(rrcllc_update_oc_with_tfc_subset(ul_common_trans_ch_info_ptr, MSG_REL99) == FAILURE)
        { 
          return FAILURE;
        } 
      } 
    }
      /* Get the Common Downlink Transport Channel information */
    if(get_dl_info_common_for_all_trch(dl_common_trans_ch_info_ptr,
                                       ul_common_trans_ch_info_ptr, ordered_config_ptr->rrc_state_indicator)
       == FAILURE)
    {
      return FAILURE;
    }
  
    /* Get the DL Added or Reconfigured Transport Channel information */
    idx = 0;
    
    
    /* Save info for each additional Transport Channel */
    while((idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL && (dl_trch_add_reconfig_ptr->n > idx))
    {
      if(get_dl_added_reconfig_trch(&dl_trch_add_reconfig_ptr->elem[idx],
                                    ul_trch_add_reconfig_ptr,
                                    FALSE) == FAILURE)
      {
        return FAILURE;
      }
      
      /* get next TrCH Info */
      idx++;
      
    } /* end while */
    return(SUCCESS);
  }

/*===========================================================================
FUNCTION rrcllc_convert_asn1_timefordrxcycle2_to_actual_value

DESCRIPTION
This function convert asn1 value of timefordrxcycle2 to actual value

DEPENDENCIES
  None.

RETURN VALUE
  SUCCESS or FAILURE
===========================================================================*/

static uint32 rrcllc_convert_asn1_timefordrxcycle2_to_actual_value
(
  rrc_T_319       timeForDRXCycle2
)
{
  uint32 drx_cycle2_timer_value = 0;

  switch(timeForDRXCycle2)
  {
    case rrc_T_319_ms80:
      drx_cycle2_timer_value = 80;
      break;
 
    case rrc_T_319_ms160:
      drx_cycle2_timer_value = 160;
      break;
    
    case rrc_T_319_ms320:
      drx_cycle2_timer_value = 320;
      break;
  
    case rrc_T_319_ms640:
      drx_cycle2_timer_value = 640;
      break;

    case rrc_T_319_ms1280:
      drx_cycle2_timer_value = 1280;
      break;

    case rrc_T_319_ms2560:
      drx_cycle2_timer_value = 2560;
      break;


    case rrc_T_319_ms5120:
      drx_cycle2_timer_value = 5120;
      break;

    default:
      WRRC_MSG1_HIGH("Error:timeForDRXCycle2=%d",timeForDRXCycle2);
      drx_cycle2_timer_value = 0;
      break;
  }
  WRRC_MSG2_HIGH("UTRAN DRX2:timeForDRXCycle2=%d,drx_cycle2_timer_value=%d",
      timeForDRXCycle2,drx_cycle2_timer_value);
  return drx_cycle2_timer_value;
}

/*===========================================================================
FUNCTION rrcllc_update_utran_drx_cycle_length_coeff_in_oc

DESCRIPTION
This function updates the utran DRX cycle length coefficient to OC received in
any reconfig message.

DEPENDENCIES
  None.

RETURN VALUE
  SUCCESS or FAILURE
===========================================================================*/

uecomdef_status_e_type rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7
(
  OSS_UINT32 utran_drx_cycle_len_coeff_present, 
  rrc_UTRAN_DRX_CycleLengthCoefficient_r7 * utran_drx_cycle_len_coeff
)
{

  boolean drx_cycle_coeff2 = FALSE;
  boolean drx_cycle_coeff = FALSE;

  if(utran_drx_cycle_len_coeff_present) 
  {
      drx_cycle_coeff = TRUE;
      utran_drx_cycle_info.utran_drx_cycle_length.length = 
             utran_drx_cycle_len_coeff->drx_CycleLengthCoefficient;

      if(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(utran_drx_cycle_len_coeff,drx_CycleLengthCoefficient2))
      {
        if(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(utran_drx_cycle_len_coeff,
                    timeForDRXCycle2))
        {
          drx_cycle_coeff2 = TRUE;
          utran_drx_cycle_info.utran_drx_cycle_length.length2 = 
              utran_drx_cycle_len_coeff->drx_CycleLengthCoefficient2;
          utran_drx_cycle_info.drx_cycle2_timer_value = 
            rrcllc_convert_asn1_timefordrxcycle2_to_actual_value(
                 utran_drx_cycle_len_coeff->timeForDRXCycle2);
        }
        else
        {
          WRRC_MSG0_HIGH("DRX Cycle2 timer value = 0");
          utran_drx_cycle_info.drx_cycle2_timer_value = 0;
        }
      }
    }
     
  /* Get the UTRAN DRX cycle length coefficient */
  if(drx_cycle_coeff2) 
  {
    if((utran_drx_cycle_info.utran_drx_cycle_length.length2>= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
      (utran_drx_cycle_info.utran_drx_cycle_length.length2 <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << utran_drx_cycle_info.utran_drx_cycle_length.length2);

      MSG_HIGH("utran_drx_cycle_len = %d, len2=%d, Timer=%d",
      utran_drx_cycle_info.utran_drx_cycle_length.length,
      utran_drx_cycle_info.utran_drx_cycle_length.length2,
      utran_drx_cycle_info.drx_cycle2_timer_value);
    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient2 %d is not valid",
        utran_drx_cycle_info.utran_drx_cycle_length.length2);
      return FAILURE;
    }
  }
  else if(drx_cycle_coeff)
  {
    if((utran_drx_cycle_info.utran_drx_cycle_length.length>= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
      (utran_drx_cycle_info.utran_drx_cycle_length.length <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << utran_drx_cycle_info.utran_drx_cycle_length.length);
    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
        utran_drx_cycle_info.utran_drx_cycle_length.length);
      return FAILURE;
    }

  } /* end UTRAN DRX Cycle Length indicator */

  return(SUCCESS);
}



/*===========================================================================
FUNCTION rrcllc_update_hrnti_in_oc

DESCRIPTION
This function updates the H-RNTI to OC received in any reconfig message.

DEPENDENCIES
  None.

RETURN VALUE
  SUCCESS or FAILURE
===========================================================================*/
static uecomdef_status_e_type rrcllc_update_hrnti_in_oc
(
  OSS_UINT32 new_hrnti_present,
  ASN1BitStr32 *new_hrnti_ptr,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{

#ifdef FEATURE_WCDMA_HS_FACH
  if(new_hrnti_present) 
  {
    if(rrc_translate_hrnti(new_hrnti_ptr, &ordered_config_ptr->efach_hrnti) == FAILURE)
    {
      WRRC_MSG0_ERROR("HRNTI invalid");
      return FAILURE;
    }
    ordered_config_ptr->efach_hrnti_status = DEDICATED_HRNTI;
    if(rrc_RRC_StateIndicator_cell_PCH == rcvd_state_indicator)
    {
      /* Copy HRNTI to TOC as HRNTI is restored from TOC for pch to fach transition */
      transition_config.toc_ptr->efach_hrnti_status = ordered_config_ptr->efach_hrnti_status;
      transition_config.toc_ptr->efach_hrnti = ordered_config_ptr->efach_hrnti;
    }
#ifdef TEST_FRAMEWORK
  #error code not present
#endif
  }
#endif

  if ((rrc_RRC_StateIndicator_cell_DCH == rcvd_state_indicator)
#ifdef FEATURE_WCDMA_HS_FACH
    ||(rrc_RRC_StateIndicator_cell_FACH == rcvd_state_indicator)
#endif /*FEATURE_WCDMA_HS_FACH*/
#if defined (FEATURE_WCDMA_HS_RACH)
    ||(rrc_RRC_StateIndicator_cell_PCH == rcvd_state_indicator)
#endif /*FEATURE_WCDMA_HS_PCH*/
    )
  {
    if (new_hrnti_present)
    {
      if (rrc_translate_hrnti(new_hrnti_ptr, &hsdpa_msg_params.hrnti) == FAILURE)
      {
        WRRC_MSG0_ERROR("HRNTI invalid");
        return FAILURE;
      }
      /*When HSDPA is active, and H-RNTI has changed then we set flag hrnti_changed in hsdpa_msg_params.*/
      if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
      {
        if (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.h_rnti != hsdpa_msg_params.hrnti)
        {
          WRRC_MSG2_HIGH("RRCHS:HRNTI changed. New %d, Old %d",hsdpa_msg_params.hrnti,
                   ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.h_rnti);
          hsdpa_msg_params.hrnti_changed = TRUE;
        }
      }

      ordered_config_ptr->hrnti = ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.h_rnti= 
        hsdpa_msg_params.hrnti;
  
      hsdpa_msg_params.msg_params_present = TRUE;
      hsdpa_msg_params.hrnti_present = TRUE;
     
      WRRC_MSG1_MED("RRCHS:New HRNTI specified is %d", hsdpa_msg_params.hrnti);
      
      rrc_set_hrnti_status(ordered_config_ptr, HRNTI_VALID);
    }
  }
  return(SUCCESS);
}
/*===========================================================================
FUNCTION rrcllc_update_max_allowed_ul_tx_power_in_oc

DESCRIPTION
This function updates "max allowed ul tx power" to OC received in any reconfig message.

DEPENDENCIES
  None.

RETURN VALUE
  SUCCESS or FAILURE
===========================================================================*/
static uecomdef_status_e_type rrcllc_update_max_allowed_ul_tx_power_in_oc
(
  OSS_UINT32 max_allowed_ul_tx_power, 
  rrc_MaxAllowedUL_TX_Power max_ul_tx_pwr
)
{
  /* Get the Maximum allowed UL TX power */
  if (max_allowed_ul_tx_power)
  {
    if(get_max_allow_ul_tx_pwr(max_ul_tx_pwr) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  return(SUCCESS);
}

/*===========================================================================
FUNCTION rrcllc_update_frequency_info_in_oc

DESCRIPTION
This function updates the frequency info to OC received in any reconfig message.

DEPENDENCIES
  None.

RETURN VALUE
  SUCCESS or FAILURE
===========================================================================*/
static uecomdef_status_e_type rrcllc_update_frequency_info_in_oc
(
  OSS_UINT32 frequency_info_present, 
  rrc_FrequencyInfo * frequency_info,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  /* Get the frequency info */
  ordered_config_ptr->dest_freq_present = FALSE;
  if (frequency_info_present)
  {
    if(get_frequency_info(frequency_info, rcvd_state_indicator) == FAILURE)
    {
      return FAILURE;
    }
  }
  return(SUCCESS);
}

/*===========================================================================
FUNCTION rrcllc_update_utran_drx_cycle_length_coeff_in_oc

DESCRIPTION
This function updates the utran DRX cycle length coefficient to OC received in
any reconfig message.

DEPENDENCIES
  None.

RETURN VALUE
  SUCCESS or FAILURE
===========================================================================*/
static uecomdef_status_e_type rrcllc_update_utran_drx_cycle_length_coeff_in_oc
(
  OSS_UINT32 utran_drx_cycle_len_coeff_present, 
  rrc_UTRAN_DRX_CycleLengthCoefficient utran_drx_cycle_len_coeff
)
{
  /* Get the UTRAN DRX cycle length coefficient */
  if(utran_drx_cycle_len_coeff_present) 
  {
    if((utran_drx_cycle_len_coeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
      (utran_drx_cycle_len_coeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << utran_drx_cycle_len_coeff);
    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
        utran_drx_cycle_len_coeff);
      return FAILURE;
    }
  } /* end UTRAN DRX Cycle Length indicator */

  return(SUCCESS);
}

/*===========================================================================
FUNCTION rrcllc_update_state_indicator_in_oc
DESCRIPTION
This function updates the state indicator in oc using state indicator received 
in reconfig message. if the current state is cell-DCH then keep the state 
indicator  in oc as cell-DCH to store DCH related IEs

DEPENDENCIES
  None.

RETURN VALUE
  SUCCESS or FAILURE
===========================================================================*/
static uecomdef_status_e_type rrcllc_update_state_indicator_in_oc
(
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  /* Get the RRC State Indicator */
  switch(rcvd_state_indicator)
  {
  case rrc_RRC_StateIndicator_cell_DCH:
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    break;
    
  case rrc_RRC_StateIndicator_cell_FACH:
  /* If the next state is CELL_FACH while the current state is CELL_DCH, 
  * keep the next state as CELL_DCH so as to process all IEs applicable
  * to CELL_DCH here.
    */
    if(current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }
    else
    {
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_FACH;
    }

    break;
    
  case rrc_RRC_StateIndicator_cell_PCH:
  /* If the next state is CELL_PCH while the current state is CELL_DCH, 
  * keep the next state as CELL_DCH so as to process all IEs applicable
  * to CELL_DCH here.
    */
    if(current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }
    else
    {
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_PCH;
    }
    break;

  case rrc_RRC_StateIndicator_ura_PCH:
  /* If the next state is URA_PCH while the current state is CELL_DCH, 
  * keep the next state as CELL_DCH so as to process all IEs applicable
  * to CELL_DCH here.
    */
    if(current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }
    else
    {
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_URA_PCH;
    }
    break;
    
  default:
    WRRC_MSG1_ERROR("RRC State %d not supported", rcvd_state_indicator);
    return FAILURE;
  } /* End RRC State indicator */

  return SUCCESS;
}

/*===========================================================================
FUNCTION rrcllc_update_urnti_in_oc
DESCRIPTION
This function updates the U-RNTI received in any reconfig message in 
ordered_config

DEPENDENCIES
  None.

RETURN VALUE
  SUCCESS or FAILURE
===========================================================================*/
static uecomdef_status_e_type rrcllc_update_urnti_in_oc
(
  OSS_UINT32 urnti_present,
  rrc_U_RNTI *urnti_ptr,
  rrc_RRC_StateIndicator rcvd_state_indicator  
)
{
  /* internal rrc state */
  rrc_state_e_type int_state_indicator = RRC_STATE_DISCONNECTED;
  rrclog_urnti_event urnti_event;
  
  /* Update U-RNTI */
  if(urnti_present)
  {
    /* Indicate to MAC that only have a valid U_RNTI, and to use in MAC header */
    rrc_translate_urnti(urnti_ptr, &ordered_config_ptr->mac_ul_parms.rnti_info.urnti);

    urnti_event.urnti_value = ordered_config_ptr->mac_ul_parms.rnti_info.urnti;
    WRRC_MSG1_HIGH("urnti =%d ",urnti_event.urnti_value);

    event_report_payload( EVENT_WCDMA_RRC_URNTI,
                     sizeof(urnti_event),
                     (void *)&urnti_event);


    ordered_config_ptr->mac_dl_parms.rnti_info.urnti = 
      ordered_config_ptr->mac_ul_parms.rnti_info.urnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == CRNTI_VALID)||
      (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* CRNTI is already valid - with new URNTI, both are valid now */
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* CRNTI is NOT valid, with new URNTI, only URNTI is valid */
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
    }

    /* go inside if check if state is FACH/PCH or URA_PCH */

    /*
         Skipping update of SCCPCH info in DCH state 
         Issue reported: Divide by zero crash, check CR 550347 for scenario
         If we look at ordered_config_ptr->l1_dl_cctrch_params and dl_dch_trch_info databases,
         during a normal DCH to FACH transition. After state transition TOC will have DCH info with OC having trch info from SIB5(PCH+FACH1+FACH2)
         If we copy sccpch info into OC during OTA processing prior to copy OC to TOC, the contents will be as below
         TOC->l1_dl_cctrch_params(PCH+FACH1+FACH2)) OC->l1_dl_cctrch_params (PCH+FACH1+FACH2).
         i.e DCH(31) info will be wiped out in TOC along with the loss of sync between l1_dl_cctrch_params and dl_dch_trch_info in TOC(indexes must be in sync)
         later when Cell update confirm moves UE to FACH and adds DCH:DCH 5, dl_dch_trch_info returns index 1 when queried for the next free dch index( 31 in index 0).
         so TOC contents are now updated as (PCH+DCH(5)+FACH2), after re-ordering TOC will have (DCH+PCH+FACH2) and dl_dch_trch_info as (5,31). Note that dch 5 has moved up
         in correspondence to TOC. Also note that #trch channels in TOC is 4, even though 3 entries are filled.
         Reconfig OTA now arrives by deleting DCH 5, we query dl_dch_trch_info for DCH:5 index which is now 0. After deletion TOC will be (INVALID+PCH+FACH2)
         after re-ordering TOC is now (PCH+INVALID+FACH2). A hole is created 
         Note: From Bolt 1.0 onwards we will change this condition check to see if cell selection will be done
         By looking at directed cell info 
       */
    if (rrc_RRC_StateIndicator_cell_DCH != rcvd_state_indicator &&
        rrc_get_state() != RRC_STATE_CELL_DCH
       )
    {
      int_state_indicator = 
        rrc_translate_state_indicator_to_state(rcvd_state_indicator);

      if(rrcllc_copy_sccpch_info_from_sib_to_oc_in_connected_mode(
         rrc_get_state(), int_state_indicator)
          == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure to update OC from SIB");
        return(FAILURE);
      }
    }
  }  /* If new URNTI is present */

  return (SUCCESS);
}

/*===========================================================================
FUNCTION rrcllc_update_crnti_in_oc
DESCRIPTION
This function updates the C-RNTI received in any reconfig message in 
ordered_config

DEPENDENCIES
  None.

RETURN VALUE
  None
===========================================================================*/
static void rrcllc_update_crnti_in_oc
(
  OSS_UINT32 crnti_present,
  ASN1BitStr32 crnti,
  rrc_RRC_StateIndicator rcvd_state_indicator  
)
{
  /* Local C_RNTI value */
  rrc_int_c_rnti_type             local_int_c_rnti;
  rrclog_crnti_event crnti_event;
  
  /* Update C-RNTI */
  /* Skip storing C-RNTI while going to cell_DCH state */
  if(crnti_present && (rcvd_state_indicator != rrc_RRC_StateIndicator_cell_DCH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&crnti, &local_int_c_rnti);

    crnti_event.crnti_value = local_int_c_rnti;
    WRRC_MSG1_HIGH("crnti =%d ",crnti_event.crnti_value);

    event_report_payload( EVENT_WCDMA_RRC_CRNTI,
                     sizeof(crnti_event),
                     (void *)&crnti_event);

    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)local_int_c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)local_int_c_rnti;
#ifdef FEATURE_WCDMA_HS_RACH
    if(rcvd_state_indicator == rrc_RRC_StateIndicator_cell_PCH)
    {
      rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
    }
#endif
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
      (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
  }  /* If new CRNTI present */

#ifndef FEATURE_WCDMA_HS_FACH
  /* If transitioning from CELL_DCH to CELL_FACH, or just a PCH transition, 
   * delete the C-RNTI. The procedure will update C-RNTI later.
   */
  if((rcvd_state_indicator == rrc_RRC_StateIndicator_cell_PCH) || 
     (rcvd_state_indicator == rrc_RRC_StateIndicator_ura_PCH) ||
     ((rcvd_state_indicator == rrc_RRC_StateIndicator_cell_FACH) && 
      (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }
#endif
}

/*===========================================================================
FUNCTION rrcllc_update_delay_restriction
DESCRIPTION
This function updates the activation time based on delay restriction flag received in the OTA

DEPENDENCIES
  None.

RETURN VALUE
  None
===========================================================================*/
void rrcllc_update_delay_restriction
(
  OSS_UINT32 act_time_present, 
  OSS_UINT32 delay_restriction_present,
  rrc_ActivationTime act_time,
  rrc_RRC_StateIndicator rcvd_state_indicator
)
{
  uint8 act_fn_num=0;

  if(act_time_present && delay_restriction_present )
  {
    if((rrc_get_hsdpa_action() == HSDPA_START) || (rrc_get_hsdpa_status() == HSDPA_ACTIVE))
    {
      if((rrc_get_state() == RRC_STATE_CELL_DCH) &&
         (rcvd_state_indicator == rrc_RRC_StateIndicator_cell_DCH))
      {
        act_fn_num = ((256 + (act_time) - ordered_config_ptr->sdu_time ) & 0xFF);
        if ( act_fn_num > 128)
  
        {
          WRRC_MSG1_HIGH("Activation Time is Now!delay restriction falg, activation %d more than current CFN",act_fn_num);
          ordered_config_ptr->activation_time = RRCLLC_ACTIVATION_TIME_NOW;
          ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_NONE;
        }
      }
    }
    else
    {
      WRRC_MSG0_ERROR("HS not Active, so do not process Delay restriction IE");  
    }
  }
}

/*===========================================================================
FUNCTION rrcrb_update_activation_time
DESCRIPTION
This function updates the activation time received in any reconfig message in 
ordered_config

DEPENDENCIES
  None.

RETURN VALUE
  None
===========================================================================*/
static void rrcllc_update_activation_time_in_oc
(
  OSS_UINT32 act_time_present, 
  rrc_ActivationTime act_time,
  rrc_RRC_StateIndicator rcvd_state_indicator,
  rrc_proc_e_type proc_id
)
{

#ifdef FEATURE_RRC_DELAY_DCH_FACH
  uint16 min_act_time = 0;
#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  uint16 cur_cfn = 0, cal_cfn_in_ms = 0;
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  rlc_lc_id_type ul_lc_id = RRCLCM_RLC_LC_ID_NOT_FOUND;
#endif 

  if(act_time_present)
  {
    if ((rcvd_state_indicator == rrc_RRC_StateIndicator_cell_FACH) && 
        (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)) 
    {
#ifdef FEATURE_RRC_DELAY_DCH_FACH
      /* Have at least activatin time of 100 ms with EDCH and 150 ms without EDCH, so that the
         base station can get RLC L2 Ack for Reconfiguration.
      */ 
      min_act_time = (seq_get_cfn() + ((current_config_ptr->e_dch_transmission == TRUE)?10:15)) & 0xFF;
      if(((256+(act_time)-(seq_get_cfn())) & 0xFF) < ((current_config_ptr->e_dch_transmission == TRUE)?10:15)) 
      {
        ordered_config_ptr->activation_time = min_act_time;
      }
      else
      {
        ordered_config_ptr->activation_time = (uint16) act_time;
      }
      ul_lc_id = rrclcm_check_ul_rlc_lc_id (UE_LOGCHAN_DCCH,
                                            DCCH_AM_RADIO_BEARER_ID,
                                            UE_MODE_ACKNOWLEDGED_DATA);
      /* Call L2 API to start retransmitting control Pdus. For DCH-FACH transition L2 retransmits control 
         Pdu thrice to increase the probability that n/w RLC gets L2 ack for DCH-FACH reconfiguration */ 
      if(RRCLCM_RLC_LC_ID_NOT_FOUND != ul_lc_id)
      {
        (void)rlc_rrc_set_status_pdu_tx_cnt(ul_lc_id, NUMBER_OF_RETRANSMISSIONS_OF_CONTROL_PDU);
      }
#else   
      ordered_config_ptr->activation_time = (uint16) act_time;
#endif /*FEATURE_RRC_DELAY_DCH_FACH*/

      ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_CFN;
      if(proc_id != MAX_NUM_OF_PROCEDURES)
      {
      ordered_config_ptr->sdu_time        = rrc_cfn_before_decode[proc_id];
      }

      WRRC_MSG1_HIGH("Activation time is 0x%x", ordered_config_ptr->activation_time);
    }
    else if(current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH)
    {
      /* Assume that the default is now, i.e. the current SFN */
      MSG_MED("Activation Time is Now!",0,0,0);
      ordered_config_ptr->activation_time = RRCLLC_ACTIVATION_TIME_NOW;
      ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_NONE;
    }
    else
    {
      MSG_MED("Activation Time is %d",  act_time, 0, 0);
      ordered_config_ptr->activation_time = (uint16)act_time;
      ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_CFN;
      if(proc_id != MAX_NUM_OF_PROCEDURES)
      {
        ordered_config_ptr->sdu_time        = rrc_cfn_before_decode[proc_id];
      }
#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
      if(rrcdata_check_buffer_ota_during_activation_time_feature_support())
      {
        /*No need to trigger optimization when CS is call active and when srns relocation is in progress*/
        if((FALSE == rrcdt_is_cs_domain_open()) && (FALSE == rrcrb_is_srns_in_progress()))
        {
          if((rrcdata_misc_info.rrc_buffer_ota_message == TRUE))
          {
            if(rrcdata_misc_info.rrc_buffered_ota_activation_time_expired_during_lta == TRUE)
            {
              ordered_config_ptr->activation_time = RRCLLC_ACTIVATION_TIME_NOW;
              ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_NONE;
            }
            else
            {
              WRRC_MSG2_HIGH("BUF_OTA:considering activation time given in message %d, msg decode cfn %d", ordered_config_ptr->activation_time,  ordered_config_ptr->sdu_time);
            }
            rrcdata_misc_info.rrc_buffer_ota_message = FALSE;
            rrcdata_misc_info.rrc_buffered_ota_activation_time_expired_during_lta = FALSE;
          }
          else if((rcvd_state_indicator == rrc_RRC_StateIndicator_cell_DCH) && 
            (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
          {
            cur_cfn = (int16)seq_get_cfn(); //wl1_seq_get_cfn
            cal_cfn_in_ms = ((256 + act_time - cur_cfn) & 0xFF) * 10;

            /*Don't buffer (allow LTA) if delay_restriction flag is true and cal_cfn > 128 (Ref Spec 8.6.3.1 Activation time)*/
            if( ( (rrcdata_misc_info.rrc_delay_restriction_flag == FALSE) || (cal_cfn_in_ms <= 1280) ) )
            {
              /*Considering minimum activation time as 100 ms */
              if(cal_cfn_in_ms >= wcdma_rrc_support_lta.minimum_act_time_required_to_allow_lta)
              { 
                rrcdata_misc_info.rrc_buffer_ota_message = TRUE;
                WRRC_MSG1_HIGH("BUF_OTA:Buffer OTA message and start activation timer with value %d",cal_cfn_in_ms);
                /*Wl1 need minimum 5 fames time to process cphy setup and apply configuration*/
                /* will define WL1 controled macro*/
                rrctmr_start_timer(RRCTMR_OTA_BUFFER_ACTIVATION_TIMER, (cal_cfn_in_ms - WCDMA_RRC_MINIMUM_ACTIVATION_TIME_FOR_PROCESSING_CPHY_SETUP ));
                return;
              }
            }
          }
        }
        else
        {
          rrcdata_misc_info.rrc_buffer_ota_message = FALSE;
          rrcdata_misc_info.rrc_buffered_ota_activation_time_expired_during_lta = FALSE;
          if(NULL != rrcdata_misc_info.rrc_buffered_ota.cmd.downlink_sdu_ind.dl_sdu)
          {
             WRRC_MSG0_ERROR("BUF_OTA: rrcdata_misc_info.rrc_buffered_ota.cmd.downlink_sdu_ind.dl_sdu is not NULL");
          }
        }
      }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
    }
  }
  else
  {
#ifdef FEATURE_RRC_DELAY_DCH_FACH
    if ((rcvd_state_indicator == rrc_RRC_StateIndicator_cell_FACH) && 
        (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)) 
    {
      /* Have at least activatin time of 100 ms with EDCH and 150 ms without EDCH, so that the
         base station can get RLC L2 Ack for Reconfiguration.
      */ 
      min_act_time = (seq_get_cfn() + ((current_config_ptr->e_dch_transmission == TRUE)?10:15)) & 0xFF;
      ordered_config_ptr->activation_time = min_act_time;
      ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_CFN;
      if(proc_id != MAX_NUM_OF_PROCEDURES)
      {
        ordered_config_ptr->sdu_time        = rrc_cfn_before_decode[proc_id];
      }
      WRRC_MSG1_HIGH("Activation time is 0x%x", ordered_config_ptr->activation_time);
      ul_lc_id = rrclcm_check_ul_rlc_lc_id (UE_LOGCHAN_DCCH,
                                            DCCH_AM_RADIO_BEARER_ID,
                                            UE_MODE_ACKNOWLEDGED_DATA);
      /* Call L2 API to start retransmitting control Pdus. For DCH-FACH transition L2 retransmits control 
         Pdu thrice to increase the probability that n/w RLC gets L2 ack for DCH-FACH reconfiguration */ 
      if(RRCLCM_RLC_LC_ID_NOT_FOUND != ul_lc_id)
      {
        (void)rlc_rrc_set_status_pdu_tx_cnt(ul_lc_id, NUMBER_OF_RETRANSMISSIONS_OF_CONTROL_PDU);
      }
    }
    else
#endif /* FEATURE_RRC_DELAY_DCH_FACH */
    {
      /* Assume that the default is now, i.e. the current SFN */
      MSG_MED("Activation Time is Now!",0,0,0);
      ordered_config_ptr->activation_time = RRCLLC_ACTIVATION_TIME_NOW;
      ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_NONE;
    }
  }
}
/*====================================================================
FUNCTION: FIND_TRCH_ID_IN_CONFIG_TRCH_LIST

DESCRIPTION:

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static boolean find_trch_id_in_config_trch_list
(
  rrc_DL_AddReconfTransChInfoList * dl_trch_add_reconfig_ptr,
  tr_ch_id_type trch_id
)
{
  uint32 num_TrCh = 0;
  boolean found = FALSE;

  while((num_TrCh <= UE_MAX_TRCH) && (dl_trch_add_reconfig_ptr->n > num_TrCh))
  {
    if (dl_trch_add_reconfig_ptr->elem[num_TrCh].dl_transportChannelIdentity == trch_id)
    {
      found = TRUE;
      break;
    }

    num_TrCh++;
  }

  return found;
}


/*====================================================================
FUNCTION: FIND_TRCH_ID_IN_CONFIG_TRCH_LIST_R5

DESCRIPTION:

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
boolean find_trch_id_in_config_trch_list_r5
(
  rrc_DL_AddReconfTransChInfoList_r5 * dl_trch_add_reconfig_ptr,
  tr_ch_id_type trch_id
)
{
  uint32 idx = 0;
  boolean found = FALSE;
  
  while((idx <= UE_MAX_TRCH) && (dl_trch_add_reconfig_ptr->n > idx))
  {
    if (dl_trch_add_reconfig_ptr->elem[idx].dl_TransportChannelType.t == T_rrc_DL_TrCH_TypeId1_r5_dch)
    {
      if (dl_trch_add_reconfig_ptr->elem[idx].dl_TransportChannelType.u.dch == trch_id)
      {
        found = TRUE;
        break;
      }
    }

    idx++;
  }
  
  return found;
}

/*====================================================================
FUNCTION: FIND_TRCH_ID_IN_CONFIG_TRCH_LIST_R4

DESCRIPTION:
  RRC Connection Setup Message contains R4 DL Added Transport Channel

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static boolean find_trch_id_in_config_trch_list_r4
(
  rrc_DL_AddReconfTransChInfoList_r4 * dl_trch_add_reconfig_ptr,
  tr_ch_id_type trch_id
)
{
  uint32 idx = 0;
  boolean found = FALSE;
  
  while((idx <= UE_MAX_TRCH) && (dl_trch_add_reconfig_ptr->n > idx))
  {
    if (dl_trch_add_reconfig_ptr->elem[idx].dl_TransportChannelType == rrc_DL_TrCH_Type_dch)
    {
      if (dl_trch_add_reconfig_ptr->elem[idx].dl_transportChannelIdentity == trch_id)
      {
        found = TRUE;
        break;
      }
    }
      
    idx++;
  }
  
  return found;
}


/*====================================================================
FUNCTION: FIND_TRCH_ID_IN_CONFIG_TRCH_LIST2

DESCRIPTION:

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static boolean find_trch_id_in_config_trch_list2
(
  rrc_DL_AddReconfTransChInfo2List * dl_trch_add_reconfig_ptr,
  tr_ch_id_type trch_id
)
{
  uint32 num_TrCh = 0;
  boolean found = FALSE;

  while((num_TrCh <= UE_MAX_TRCH) && (dl_trch_add_reconfig_ptr->n > num_TrCh))
  {
    if (dl_trch_add_reconfig_ptr->elem[num_TrCh].transportChannelIdentity == trch_id)
    {
      found = TRUE;
      break;
    }

    num_TrCh++;
  }

  return found;
}


/*====================================================================
FUNCTION: rrcllc_check_add_remove_rl_list_if_valid_in_asu()

DESCRIPTION:
  This function checks if the RL info in remove list & RL info
  in the add list have the same PSC.

DEPENDENCIES:
  None.

RETURN VALUE:
  FALSE - if add & remove list have atleast one PSC in common.
  TRUE - otherwise

SIDE EFFECTS:
  None.
====================================================================*/
static 
boolean rrcllc_check_add_remove_rl_list_if_valid_in_asu
( 
  rrc_RL_AdditionInformationList  * rl_add_list,
  rrc_RL_RemovalInformationList   * rl_removal_list
)
{
 
  boolean valid_config = TRUE;
  uint32 idx =0;
  uint32 idy =0;

  while(rl_add_list->n > idx)
  {
	idy =0;
    while(rl_removal_list->n > idy)
    {
      if(rl_add_list->elem[idx].primaryCPICH_Info.primaryScramblingCode == 
         rl_removal_list->elem[idy].primaryScramblingCode)
      {
        /* Add RL & remove RL list contain same PSC */
        valid_config = FALSE;
        return valid_config;
      }
      idy++;
    }
    idx++;
  }

  return valid_config;
} /* rrcllc_check_add_remove_rl_list_if_valid_in_asu */
#ifdef FEATURE_WCDMA_DC_HSUPA


/*====================================================================
FUNCTION: rrcllc_check_add_remove_rl_list_for_sec_eul_if_valid_in_asu()

DESCRIPTION:
  This function checks if the RL info in remove list & RL info
  in the add list have the same PSC.

DEPENDENCIES:
  None.

RETURN VALUE:
  FALSE - if add & remove list have atleast one PSC in common.
  TRUE - otherwise

SIDE EFFECTS:
  None.
====================================================================*/
boolean rrcllc_check_add_remove_rl_list_for_sec_eul_if_valid_in_asu
( 
  rrc_RL_AdditionInformationList_SecULFreq  * rl_add_list,
  rrc_RL_RemovalInformationList_SecULFreq   * rl_removal_list
)
{

  boolean valid_config = TRUE;
  uint32 idx =0;
  uint32 idy =0;

  while(rl_add_list->n > idx)
  {
	idy =0;
    while(rl_removal_list->n > idy)
    {
      if(rl_add_list->elem[idx].primaryCPICH_Info.primaryScramblingCode == 
         rl_removal_list->elem[idy].primaryScramblingCode)
      {
        /* Add RL & remove RL list contain same PSC */
        valid_config = FALSE;
        return valid_config;
      }
      idy++;
    }
    idx++;
  }

  /* 	the IE "Radio link addition information on secondary UL frequency" or the IE "Radio link removal information on secondary UL frequency" is i
  ncluded while the secondary E-DCH active set prior to the reception of the message do not contain any radio link; and/or */

if (ordered_config_ptr->l1_dl_chan_parms.sec_num_rl == 0)
{
  valid_config = FALSE;
}

  return valid_config;
} /* rrcllc_check_add_remove_rl_list_if_valid_in_asu */

/*====================================================================
FUNCTION: rrcllc_validate_asu_for_sec_eul()

DESCRIPTION:
This function validates secondary EUL ASU message

DEPENDENCIES:
  None.

RETURN VALUE:
  FALSE - if add & remove list have atleast one PSC in common.
  TRUE - otherwise

SIDE EFFECTS:
  None.
====================================================================*/

static 
boolean rrcllc_validate_asu_for_sec_eul
(
  rrc_ActiveSetUpdate_r9_IEs *msg_ptr
)
{


  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_SecondaryCellInfoFDD))
    {
      if(RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->ul_SecondaryCellInfoFDD, rrc_UL_SecondaryCellInfoFDD_newConfiguration))
        {
          
          if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr->ul_SecondaryCellInfoFDD.u.newConfiguration,rrc_UL_SecondaryCellInfoFDD_newConfiguration,
            dl_InformationPerSecondaryRL_List))
            {
              rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
              WRRC_MSG0_ERROR("Rejecting the ASU configuration as dl_InformationPerSecondaryRL_List is included in ASU");
              return FALSE;
            }
        }

    }

  if((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r9_IEs,rl_RemovalInformationList_SecULFreq)) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r9_IEs,rl_AdditionInformationList_SecULFreq)))
  {
    if(rrcllc_check_add_remove_rl_list_for_sec_eul_if_valid_in_asu(&msg_ptr->rl_AdditionInformationList_SecULFreq, 
		&msg_ptr->rl_RemovalInformationList_SecULFreq) == FALSE)
    {
      rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
      WRRC_MSG0_ERROR("Rejecting the ASU configuration as atleast one PSC found common in ADD & REMOVE set");
      return FALSE;
    }
  }
  return TRUE;
}

#endif /* FEATURE_WCDMA_DC_HSUPA */



/*====================================================================
FUNCTION: rrcllc_compare_sf_with_cc()

DESCRIPTION:
  This function checks if the spreading factor in the RL info in ADD 
  list is same as the current SF being used.

DEPENDENCIES:
  None.
T_

RETURN VALUE:
  FALSE - if add & remove list have atleast one PSC in common.
  TRUE - otherwise

SIDE EFFECTS:
  None.
====================================================================*/
static 
boolean rrcllc_compare_sf_with_cc(rrc_SF512_AndCodeNumber *sf_ptr)
{
  boolean sf_match_found = FALSE;
  uint32  ordered_sf = 0xEF; /* some invalid value */

  if(current_config_ptr != NULL && sf_ptr != NULL)
  {
    sf_match_found = TRUE;
    
    switch(sf_ptr->t)
    {
    case  T_rrc_SF512_AndCodeNumber_sf4:
      ordered_sf = L1_SF_4;
      break;

    case  T_rrc_SF512_AndCodeNumber_sf8:
      ordered_sf = L1_SF_8;
      break;

    case  T_rrc_SF512_AndCodeNumber_sf16:
      ordered_sf = L1_SF_16;
      break;

    case  T_rrc_SF512_AndCodeNumber_sf32:
      ordered_sf = L1_SF_32;
      break;

    case  T_rrc_SF512_AndCodeNumber_sf64:
      ordered_sf = L1_SF_64;
      break;

    case  T_rrc_SF512_AndCodeNumber_sf128:
      ordered_sf = L1_SF_128;
      break;

    case  T_rrc_SF512_AndCodeNumber_sf256:
      ordered_sf = L1_SF_256;
      break;

    case  T_rrc_SF512_AndCodeNumber_sf512:
      ordered_sf = L1_SF_512;
      break;

    default:
      sf_match_found = FALSE;
      break;
    } 

    if(sf_match_found != FALSE && 
       ordered_sf != current_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.sf)
    {
      sf_match_found = FALSE;
    }
    WRRC_MSG2_HIGH("Ordered SF = %d; Current SF = %d", ordered_sf, current_config_ptr->l1_dl_chan_parms.dl_common.dpch_common.sf);
  }

  return sf_match_found;
} /* rrcllc_compare_sf_with_cc */

/*====================================================================
FUNCTION: rrcllc_is_cm_deactive_with_eul()

DESCRIPTION:
  This function checks if CM is active along with EUL

DEPENDENCIES:
  None.
T_

RETURN VALUE:
  FALSE - 
  TRUE - otherwise

SIDE EFFECTS:
  None.
====================================================================*/
static 
boolean rrcllc_is_cm_deactive_with_eul(void)
{

  if((!rrc_wcdma_hsupa_cm_enabled) &&
      (rrc_is_cm_active_with_eul(ordered_config_ptr)))
  {
    WRRC_MSG0_ERROR("HSUPA+CM not supported");
    return TRUE;
  }
  
return FALSE;
  
} /* rrcllc_is_cm_deactive_with_eul */

/*====================================================================
FUNCTION: rrcllc_is_cm_active_with_hsdpa()

DESCRIPTION:
  This function checks if CM is active along with HS

DEPENDENCIES:
  None.

RETURN VALUE:
  FALSE - 
  TRUE - otherwise

SIDE EFFECTS:
  None.
====================================================================*/
static boolean rrcllc_is_cm_active_with_hsdpa(void)
{

  if (hsdpa_cm_enabled == FALSE)
  {
    /* Check if network is trying to activate CM with HSDPA */
    if (((((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) ||
      (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_RECONFIG) ||
      ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_NOOP) &&
      (rrc_get_hsdpa_status() == HSDPA_ACTIVE))) && 
      rrcllc_is_cm_active(ordered_config_ptr) == TRUE)) ||
      ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) &&
      (l1_cm_query_compressed_mode_active() == FALSE) &&
      (cm_status_from_ota_msg == ACTIVATE_CM)) ||
      ((ordered_config_ptr->mac_dl_parms.mac_hsdpa_action == HSDPA_START) &&
      (l1_cm_query_compressed_mode_active() == TRUE) &&
      (cm_status_from_ota_msg == RRC_CM_NONE)))
    {
      WRRC_MSG0_HIGH("RRCHS: CM with HSDPA Active");
      return TRUE;
    }
  }
return FALSE;
  
} /* rrcllc_is_cm_active_with_hsdpa */

/*====================================================================
FUNCTION: rrcllc_update_tb_size_for_dch()

DESCRIPTION:
  This function updates TB size for DCH transport channels

DEPENDENCIES:
  None.

RETURN VALUE:
None

SIDE EFFECTS:
  None.
====================================================================*/
static 
void rrcllc_update_tb_size_for_dch(uint8 idx)
{

  uint8 tf_idx;
  
  if (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up &&
      !ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down)
  {
    WRRC_MSG2_HIGH("Increasing TrCH %d TB size, %d by MAC hdr size", 
             ordered_config_ptr->dl_dch_trch_info[idx].trch_id, 
             ordered_config_ptr->dl_trch_info[idx].tf_info_array[0]->tb_size);
    for (tf_idx=0; tf_idx<ordered_config_ptr->dl_trch_info[idx].num_tf; tf_idx++)
    {
      if (ordered_config_ptr->dl_trch_info[idx].tf_info_array[tf_idx]->tb_size > 0) 
      {
        ordered_config_ptr->dl_trch_info[idx].tf_info_array[tf_idx]->tb_size += 
                                    RRCLLC_DED_MULTI_LOG_CHL_DL_DCH_MAC_HDR_SIZE;
      }
    }
  }
  /* Substract MAC head size from the current TB size.  */
  else if (!ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up &&
           ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down)
  {
    WRRC_MSG2_HIGH("Decreasing TrCH %d TB size, %d by MAC hdr size", 
             ordered_config_ptr->dl_dch_trch_info[idx].trch_id, 
             ordered_config_ptr->dl_trch_info[idx].tf_info_array[0]->tb_size);
    for (tf_idx=0; tf_idx<ordered_config_ptr->dl_trch_info[idx].num_tf; tf_idx++)
    {
      if (ordered_config_ptr->dl_trch_info[idx].tf_info_array[tf_idx]->tb_size > 0) 
      {
        ordered_config_ptr->dl_trch_info[idx].tf_info_array[tf_idx]->tb_size -= 
          RRCLLC_DED_MULTI_LOG_CHL_DL_DCH_MAC_HDR_SIZE;
      }
    }
  }
  
} /* rrcllc_update_tb_size_for_dch */

/*====================================================================
FUNCTION: rrcllc_is_cm_active_with_hsdpa_r99()

DESCRIPTION:
  This function checks if CM is active along with HS for r99 ota

DEPENDENCIES:
  None.
T_

RETURN VALUE:
  FALSE - 
  TRUE - otherwise

SIDE EFFECTS:
  None.
====================================================================*/
static 
boolean rrcllc_is_cm_active_with_hsdpa_r99(void)
{

  if (hsdpa_cm_enabled == FALSE)
  {
    /* Check if HSDPA+CM is being activated */
    if ((rrcllc_is_cm_active(ordered_config_ptr) == TRUE) &&
      (ordered_config_ptr->mac_dl_parms.mac_hsdpa_action != HSDPA_STOP))
    {
      WRRC_MSG0_ERROR("HSDPA+CM being activated");
      return TRUE;
    }
  }
  return FALSE;
} /* rrcllc_is_cm_deactive_with_eul */


/*====================================================================
FUNCTION: rrcllc_adjust_tb_size_handover_to_utran()

DESCRIPTION:
  This function adjusts the tb size for handover to utran messages

DEPENDENCIES:
  None.

RETURN VALUE:
None

SIDE EFFECTS:
  None.
====================================================================*/
static 
void rrcllc_adjust_tb_size_handover_to_utran(void)
{

  uint8      idx     = 0; /* Loop index */
  
  for (idx=0; idx<UE_MAX_TRCH; idx++)
  {
    /* The number of logical channel mapped to this transport channel 
       increases from 1 to 2. Needs to adjsut the tb_szie to
       reflect the adding of the MAC header.                         */
    if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
        (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
         ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
    {
      WRRC_MSG0_HIGH("Clean TB size adjust flag in HandOverToUTRAN");
      /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
      ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
      ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
    }
    else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
    {
      /* Since the activated transport channels are sorted before stored in
         the memory, break the looping after reaching the 1st invalid block.  */
      break;
    }
  }
  
} /* rrcllc_adjust_tb_size_handover_to_utran */
  
/*====================================================================
FUNCTION: rrcllc_active_set_update_ie()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Active Set Update Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_active_set_update_ie
(
  rrc_ActiveSetUpdate_r3_IEs *msg_ptr
)
{
  /* local loop variable */
  uint8                            idx;

  /* local RL to remove pointer */
  rrc_RL_AdditionInformationList *  rl_add_ptr;

  /* local RL count */
  uint16                           num_rl;

  /* flag to prevent erroneous increment of number of RL on attempt to add
     a duplicate RL */
  boolean duplicate_add_attempted = FALSE;

  rrcllc_init_before_msg_processing();
  
  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /* Ignore the Integrity Protection and Ciphering IEs */

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r3_IEs,activationTime)),
    msg_ptr->activationTime, rrc_RRC_StateIndicator_cell_DCH, RRC_PROCEDURE_ASU);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/

  /* Get the U-RNTI */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r3_IEs,newU_RNTI))
  {
    /* Indicate to MAC that only have a valid U_RNTI, and to use in MAC header */
    rrc_translate_urnti(&msg_ptr->newU_RNTI, &ordered_config_ptr->mac_ul_parms.rnti_info.urnti);
    ordered_config_ptr->mac_dl_parms.rnti_info.urnti = 
      ordered_config_ptr->mac_ul_parms.rnti_info.urnti;
    ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
    ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
  }

  /* Don't process RB with PDCP info list */

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r3_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  if( (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r3_IEs,rl_RemovalInformationList)) &&
      (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r3_IEs,rl_AdditionInformationList)))
  {
    if(rrcllc_check_add_remove_rl_list_if_valid_in_asu(&msg_ptr->rl_AdditionInformationList, 
		&msg_ptr->rl_RemovalInformationList) == FALSE)
    {
      rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
      WRRC_MSG0_ERROR("Rejecting the ASU configuration as atleast one PSC found common in ADD & REMOVE set");
      return FAILURE;
    }
  }
   
  /* Get the Radio Link Removal information */
  if (FAILURE == rrcllcpcie_process_rl_removal_information_list(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r3_IEs,rl_RemovalInformationList),
      &msg_ptr->rl_RemovalInformationList,
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r3_IEs,rl_AdditionInformationList)
      ))
  {
    return(FAILURE);
  }

  /* Get the TX Diversity Mode */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r3_IEs,tx_DiversityMode))
  {
    if(get_tx_diversity_mode_info(msg_ptr->tx_DiversityMode, &ordered_config_ptr->l1_dl_chan_parms.dl_common)
       == FAILURE)
    {
      return FAILURE;
    }

    if((ordered_config_ptr->l1_dl_chan_parms.dl_common.tx_div_mode != L1_TX_DIV_NONE) && 
       (current_config_ptr->l1_dl_chan_parms.dl_common.tx_div_mode != L1_TX_DIV_NONE))
    {
      switch(current_config_ptr->l1_dl_chan_parms.dl_common.tx_div_mode)
      {
      case L1_TX_DIV_STTD:
        if(ordered_config_ptr->l1_dl_chan_parms.dl_common.tx_div_mode != L1_TX_DIV_STTD)
        {
          WRRC_MSG0_ERROR("Tx diversity mode instructed by UTRAN is different from the current one...rejecting");
          rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
          return FAILURE;
        }
        break;

      case L1_TX_DIV_CLOSED_LOOP_1:
        if(ordered_config_ptr->l1_dl_chan_parms.dl_common.tx_div_mode == L1_TX_DIV_STTD)
        {
          WRRC_MSG0_ERROR("Tx diversity mode instructed by UTRAN is different from the current one...rejecting");
          rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
          return FAILURE;
        }
        break;

      default:
        WRRC_MSG0_HIGH("UTRAN sent dummy Tx diversity mode");
        break;
      }
    } 
  } /* end TX Diversity Mode */

  /* Get the Radio Link Addition information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r3_IEs,rl_AdditionInformationList))
  {
    rl_add_ptr = &msg_ptr->rl_AdditionInformationList;
    idx = 0;

    num_rl = ordered_config_ptr->l1_dl_chan_parms.num_rl;
    while((rl_add_ptr->n > idx) && (idx < (UE_MAX_RL - num_rl)))
    {
      if(get_rl_add_info(&rl_add_ptr->elem[idx], &ordered_config_ptr->l1_dl_chan_parms,
                         &duplicate_add_attempted) == FAILURE)
      {
        return FAILURE;
      }
      
      /* This assumes that there is a single DPCH */
      if(rrcllc_compare_sf_with_cc(&rl_add_ptr->elem[idx].dl_DPCH_InfoPerRL.u.
	  	fdd->dl_ChannelisationCodeList.elem[0].sf_AndCodeNumber) == FALSE)
      {
        WRRC_MSG0_ERROR("Spreading factor is different atleast by one in DL DPCH info per RL...rejecting");
        rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
        return FAILURE;
      }
      
      /* get the next RL */
    
      idx++;

      /* one more radio link in ORDERED_CONFIG */
      if(!duplicate_add_attempted)
      {
        ordered_config_ptr->l1_dl_chan_parms.num_rl++;
      }

    } /* end loop of all included RLs to add */ 
  } /* end RL Addition information */

  /* Make sure we actually have some RLs in the active set */
  if(ordered_config_ptr->l1_dl_chan_parms.num_rl == 0)
  {
    WRRC_MSG0_HIGH("No RLs in aset after ASU");
    rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
    return FAILURE;
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(rrc_RRC_StateIndicator_cell_DCH)
     == FAILURE)
  {
    rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
    return FAILURE;
  }

#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    rrc_RRC_StateIndicator_cell_DCH, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,rrc_RRC_StateIndicator_cell_DCH,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  rrcllc_check_and_stop_dtx(rrc_RRC_StateIndicator_cell_DCH,MSG_REL99);

#ifdef FEATURE_WCDMA_DC_HSUPA
  if(rrcllcpcie_process_dc_hsupa_params(NULL,rrc_RRC_StateIndicator_cell_DCH,
    FALSE)== FAILURE)
  {
    return FAILURE;
  }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return SUCCESS;

} /* end rrcllc_active_set_update_ie() */

/*====================================================================
FUNCTION: rrcllc_phychan_reconfig_ie()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Physical Channel Reconfiguration Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_phychan_reconfig_ie
(
  rrc_DL_DCCH_Message *dcch_ptr 
)
{
  /* Local C_RNTI value */
  rrc_int_c_rnti_type              c_rnti;

  uecomdef_status_e_type          status = SUCCESS;

  rrc_PhysicalChannelReconfiguration_r3_IEs *msg_ptr = &dcch_ptr->message.u.physicalChannelReconfiguration.u.r3.physicalChannelReconfiguration_r3;

  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* Later on, we will check to make sure both of these parameters
     are present when going from a non-DCH state to DCH. */
  /*const uint32 dl_dpch_mask =
    rrc_PhysicalChannelReconfiguration_r3_IEs_dl_CommonInformation |
    rrc_PhysicalChannelReconfiguration_r3_IEs_dl_InformationPerRL_List;
*/
  rrcllc_init_before_msg_processing();


  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;


  /* Get the U-RNTI */
  if(FAILURE == rrcllc_update_urnti_in_oc(
                  RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r3_IEs,new_U_RNTI),
                  &msg_ptr->new_U_RNTI,
                  msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the C-RNTI only if next state is CELL_FACH. We do not need it for
   any other state */
  if((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r3_IEs,new_C_RNTI)) &&
  (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_C_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
  }  /* If new CRNTI present */
#ifdef FEATURE_WCDMA_HS_RACH
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH) &&
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r3_IEs,new_C_RNTI)))
  {
    rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
  }
#endif

  /* If transitioning from CELL_DCH to CELL_FACH, delete the C-RNTI.
   * The procedure will update C-RNTI later.
   */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH) &&
     (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = rrcllc_check_delay_restriction_ie_phys_reconfig(dcch_ptr);
#endif

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r3_IEs,activationTime)),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_PCR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /* Get the RRC State Indicator */
  if(FAILURE == rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the UTRAN DRX cycle length coefficient */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r3_IEs,utran_DRX_CycleLengthCoeff)) 
  {
    if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
       (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);
    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
                msg_ptr->utran_DRX_CycleLengthCoeff);
      return FAILURE;
    }
  } /* end UTRAN DRX Cycle Length indicator */

  /* Don't process RB with PDCP info list */

  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r3_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
          msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r3_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r3_IEs,ul_ChannelRequirement))
    {
      /* Check to see if this is DPCH or CPCH */
      switch(msg_ptr->ul_ChannelRequirement.t)
      {
        case T_rrc_UL_ChannelRequirementWithCPCH_SetID_ul_DPCH_Info:
          if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
          {
            if(get_ul_dpch_info(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
            {
              return FAILURE;
            }
          }
          break;
  
        case T_rrc_UL_ChannelRequirementWithCPCH_SetID_dummy1:
          WRRC_MSG0_ERROR("UL CPCH info not supported for PhyChan Recfg");
          return FAILURE;
  
        default:
          WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in PhyChan Rcfg",
                    msg_ptr->ul_ChannelRequirement.t);
          return FAILURE;
      }
    }
    else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
            current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
    {
      WRRC_MSG2_ERROR("No UL Chan Req, PhyCh Recfg state %d->%d",
          current_config_ptr->rrc_state_indicator,
          msg_ptr->rrc_StateIndicator);
      return FAILURE;
    } /* end if check for UL Channel Requirement */
  } /* If next RRC state is Cell_DCH */

  WRRC_MSG1_HIGH(" PCR R3 Mode specific info FDD %d",msg_ptr->modeSpecificInfo.t);
        
  /* Ignore PDSCH IEs */
  switch(msg_ptr->modeSpecificInfo.t)
  {
    case T_rrc_PhysicalChannelReconfiguration_r3_IEs_modeSpecificInfo_fdd:
      break;

    case T_rrc_PhysicalChannelReconfiguration_r3_IEs_modeSpecificInfo_tdd:
      break;

    default:
      return FAILURE;
  } /* end PDSCH check */

  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
       rrc_PhysicalChannelReconfiguration_r3_IEs,dl_CommonInformation))
    && (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
       rrc_PhysicalChannelReconfiguration_r3_IEs,dl_InformationPerRL_List))) &&
     current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No DL DPCH, PhyChan Recfg state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }

  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Initialize the L1 bitmask for the parameters in the "Downlink
     * information for all radio links" IE.  Since the IE is optional,
     * we want to make sure we don't signal L1 erroneously that we have
     * received information when we haven't.
     */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);

    if(FAILURE == rrcllcpcie_is_hho((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r3_IEs,
		                    dl_InformationPerRL_List)),
                            &msg_ptr->dl_InformationPerRL_List,
                            msg_ptr->rrc_StateIndicator))
    {
        return FAILURE;
    }

    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r3_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl(&msg_ptr->dl_CommonInformation,
                                       &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                       &ordered_config_ptr->l1_dl_cctrch_parms,
                                       &ordered_config_ptr->l1_dl_ctfc_parms
                                      )
         == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
  } /* If next state is CEll_DCH */
  
  /* Calculate the DL TFCS, applying the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms
                            );

  /* Get the DL information for each Radio Link */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r3_IEs,
  	 dl_InformationPerRL_List))
  {
    if(get_dl_info_per_rl(&msg_ptr->dl_InformationPerRL_List,
        msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }
  
  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    /* Determine HSDPA Action */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Set HSDPA Action */
      if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
      {
        rrcllc_set_r99_hsdpa_action();

        if(rrcllc_is_cm_active_with_hsdpa_r99())
        {
          return FAILURE;
        }
      }
    } /* If next state is Cell_DCH */  
    
  }
  
  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action
     (msg_ptr->rrc_StateIndicator) == FAILURE)
  {
    return FAILURE;
  }

  if (rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }

#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);

    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,FALSE);
  }
#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,FALSE);
  }
#endif /*FEATURE_WCDMA_HS_RACH*/
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL99);

#ifdef FEATURE_WCDMA_DC_HSUPA
  if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)== FAILURE)
  {
    return FAILURE;
  }  
#endif /* FEATURE_WCDMA_DC_HSUPA */


  /* Got here, everything is okay */
  return status;

} /* end rrcllc_phychan_reconfig_ie() */



      
/*====================================================================
FUNCTION: rrcllc_phychan_reconfig_ie_r5()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Physical Channel Reconfiguration Message for Rel 5

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_phychan_reconfig_ie_r5
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  /* Local C_RNTI value */
#ifdef FEATURE_WCDMA_HS_FACH
  uecomdef_status_e_type          status = SUCCESS;
#endif  
rrc_PhysicalChannelReconfiguration_r5_IEs *msg_ptr =
  &dcch_ptr->message.u.physicalChannelReconfiguration.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.physicalChannelReconfiguration_r5;
  rrc_int_c_rnti_type              c_rnti;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* Later on, we will check to make sure both of these parameters
     are present when going from a non-DCH state to DCH. */
/*  const uint32 dl_dpch_mask =
    rrc_PhysicalChannelReconfiguration_r5_IEs_dl_CommonInformation |
    rrc_PhysicalChannelReconfiguration_r5_IEs_dl_InformationPerRL_List;
  */
  rrcllc_init_before_msg_processing();

  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /* Ignore the Integrity Protection and Ciphering IEs */

  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

   /* Get the U-RNTI */
  if(FAILURE == rrcllc_update_urnti_in_oc(
                  RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r5_IEs,new_U_RNTI),
                  &msg_ptr->new_U_RNTI,
                  msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the C-RNTI */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r5_IEs,new_C_RNTI)&&
     (msg_ptr->rrc_StateIndicator != rrc_RRC_StateIndicator_cell_DCH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_C_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
    
#ifdef FEATURE_WCDMA_HS_RACH
    if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH)
    {
      rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
    }
#endif
  }  /* If new CRNTI present */

  /* If transitioning from CELL_DCH to CELL_FACH, delete the C-RNTI.
   * The procedure will update C-RNTI later.
   */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH) &&
     (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = rrcllc_check_delay_restriction_ie_phys_reconfig_r5(dcch_ptr);
#endif

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
    rrc_PhysicalChannelReconfiguration_r5_IEs,activationTime)),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_PCR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /* Get the RRC State Indicator */
  if(FAILURE == rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the UTRAN DRX cycle length coefficient */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r5_IEs,
  	utran_DRX_CycleLengthCoeff) )
  {
    if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
       (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);
    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
                msg_ptr->utran_DRX_CycleLengthCoeff);
      return FAILURE;
    }
  } /* end UTRAN DRX Cycle Length indicator */

  /* Don't process RB with PDCP info list */

  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_PhysicalChannelReconfiguration_r5_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
          msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_PhysicalChannelReconfiguration_r5_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r5_IEs,
		ul_ChannelRequirement))
    {
      /* Check to see if this is DPCH or CPCH */
      switch(msg_ptr->ul_ChannelRequirement.t)
      {
        case T_rrc_UL_ChannelRequirementWithCPCH_SetID_r5_ul_DPCH_Info:
          if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
          {
            if(get_ul_dpch_info_r5(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
            {
              return FAILURE;
            }
          }
          break;
  
        case T_rrc_UL_ChannelRequirementWithCPCH_SetID_r5_dummy1:
          WRRC_MSG0_ERROR("UL CPCH info not supported for PhyChan Recfg");
          return FAILURE;
  
        default:
          WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in PhyChan Rcfg",
                    msg_ptr->ul_ChannelRequirement.t);
          return FAILURE;
      }
    }
    else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
            current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
    {
      WRRC_MSG2_ERROR("No UL Chan Req, PhyCh Recfg state %d->%d",
          current_config_ptr->rrc_state_indicator,
          msg_ptr->rrc_StateIndicator);
      return FAILURE;
    } /* end if check for UL Channel Requirement */
  } /* If next RRC state is Cell_DCH */

  WRRC_MSG1_HIGH(" PCR R3 Mode specific info FDD %d",msg_ptr->modeSpecificInfo.t);
  
  /* Ignore PDSCH IEs */
  switch(msg_ptr->modeSpecificInfo.t)
  {
    case T_rrc_PhysicalChannelReconfiguration_r5_IEs_modeSpecificInfo_fdd:
      break;

    case T_rrc_PhysicalChannelReconfiguration_r5_IEs_modeSpecificInfo_tdd:
      break;

    default:
      return FAILURE;
  } /* end PDSCH check */

  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r5_IEs,
     dl_CommonInformation)) &&(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_PhysicalChannelReconfiguration_r5_IEs,
     dl_InformationPerRL_List)))  &&
     (current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH))
  {
    WRRC_MSG2_ERROR("No DL DPCH, PhyChan Recfg state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }

  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Initialize the L1 bitmask for the parameters in the "Downlink
     * information for all radio links" IE.  Since the IE is optional,
     * we want to make sure we don't signal L1 erroneously that we have
     * received information when we haven't.
     */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);

    if(FAILURE == rrcllcpcie_is_hho_r5((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
		                   rrc_PhysicalChannelReconfiguration_r5_IEs,dl_InformationPerRL_List)),
                               &msg_ptr->dl_InformationPerRL_List,
                               msg_ptr->rrc_StateIndicator))
    {
      return FAILURE;
    }


    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r5_IEs,
		dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl_r5(&msg_ptr->dl_CommonInformation,
                                       &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                       &ordered_config_ptr->l1_dl_cctrch_parms,
                                       &ordered_config_ptr->l1_dl_ctfc_parms
                                      )
         == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
  } /* If next state is CEll_DCH */
  
  /* Calculate the DL TFCS, applying the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms
                            );

  /* Get the DL information for each Radio Link */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
      rrc_PhysicalChannelReconfiguration_r5_IEs,dl_InformationPerRL_List))
  {
    if(get_dl_info_per_rl_r5(&msg_ptr->dl_InformationPerRL_List,
        msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }

  if(FAILURE == rrcllc_update_hrnti_in_oc(
                    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r5_IEs,new_H_RNTI), 
                    &msg_ptr->new_H_RNTI,
                    msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }
     
  /* Get HSDPA Info */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    
    /* SET Action Variable by calling HSDPA action table */
    /* First check if HSDPA is already active or is being activated */

    if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r5_IEs,dl_HSPDSCH_Information))
    {
      hsdpa_msg_params.msg_params_present= TRUE;
      hsdpa_msg_params.hspdsch_info_present= TRUE;         
    }

    /* Determine if IFHHO is involved */
    if ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r5_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq()))
    {
      WRRC_MSG0_HIGH("RRCHS:InterFreq HO");
      hsdpa_msg_params.ifhho_involved = TRUE;
      hsdpa_msg_params.msg_params_present= TRUE;
    }

    if (rrcllc_determine_hsdpa_action(&msg_ptr->dl_HSPDSCH_Information) == SUCCESS)
    {
      rrc_set_hsdpa_action_in_machs_macehs();
      rrcllcpcie_update_hs_tfri_table_type_non_r7_ota();

      MSG_5(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RRCHS:HSDPA Action %d set in MAC CM VAR %d CM status L1/RRC/OTA %d %d %d",
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action,
      hsdpa_cm_enabled,
      l1_cm_query_compressed_mode_active(),
      rrcllc_is_cm_active(ordered_config_ptr),
      cm_status_from_ota_msg
      );

      if(rrcllc_is_cm_active_with_hsdpa())
      {
        return FAILURE;
      }
      
    }
    else
    {
       WRRC_MSG0_ERROR("RRCHS:Error during HSDPA action processing"); 
      return FAILURE;     
    }

    WRRC_MSG0_HIGH("RRCHS:Action already set in MAC params");

  } /* If next state is Cell_DCH */ 
  
  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
    == FAILURE)
  {
    return FAILURE;
  }
  
  if (rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }


#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/
#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                    validate_directed_cell_info,
                                    FALSE,
                                    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r5_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                    validate_directed_cell_info,
                                    FALSE,
                                    FALSE);
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL5);

#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
      FALSE)== FAILURE)
    {
      return FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return status;

} /* end rrcllc_phychan_reconfig_ie_r5() */



/*====================================================================
FUNCTION: rrcllc_rb_reconfig_ie()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Reconfiguration Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_reconfig_ie
(
  rrc_DL_DCCH_Message *dcch_ptr 
)
{
  /* local loop variable */
  uint8                            idx;
#ifdef FEATURE_WCDMA_HS_FACH
  uecomdef_status_e_type status = SUCCESS;
#endif

  rrc_RadioBearerReconfiguration_r3_IEs *msg_ptr = &dcch_ptr->message.u.radioBearerReconfiguration.u.r3.radioBearerReconfiguration_r3;

  /* local RB to reconfigure list pointer */
  rrc_RB_InformationReconfigList *  rb_reconfig_ptr;

  /* local RBs to be Affected Pointer */
  rrc_RB_InformationAffectedList  * rb_affected_ptr;

  /* local UL TrCH Drop Pointer */
  rrc_UL_DeletedTransChInfoList    * ul_trch_delete_ptr = NULL;

  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList  * ul_trch_add_reconfig_ptr = NULL;

  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList    * dl_trch_delete_ptr = NULL;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfo2List * dl_trch_add_reconfig_ptr = NULL;

  /* Local C_RNTI value */
  rrc_int_c_rnti_type              c_rnti;

  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* Later on, we will check to make sure this parameter
     is present when going from a non-DCH state to DCH. */
 /* const uint32 dl_dpch_mask =
    rrc_RadioBearerReconfiguration_r3_IEs_dl_CommonInformation;
*/
  rrcllc_init_before_msg_processing();


  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;


   /* Get the U-RNTI */
  if(FAILURE == rrcllc_update_urnti_in_oc(
                  RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,new_U_RNTI),
                  &msg_ptr->new_U_RNTI,
                  msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the C-RNTI only if next state is CELL_FACH. We do not need it for
   any other state */
  if((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,new_C_RNTI)) &&
  (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_C_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
  }  /* If new CRNTI present */
#ifdef FEATURE_WCDMA_HS_RACH
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH) &&
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,new_C_RNTI)))
  {
    rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
  }
#endif
  /* If transitioning from CELL_DCH to CELL_FACH, delete the C-RNTI.
   * The procedure will update C-RNTI later.
   */
  if( ((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH)
       || (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH)
       || (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_ura_PCH)
       ) &&
     (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = rrcllc_check_delay_restriction_ie_rb_reconfig(dcch_ptr);
#endif

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBRC);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /* Get the RRC State Indicator */
  if(FAILURE == rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the UTRAN DRX cycle length coefficient */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,utran_DRX_CycleLengthCoeff)) 
  {
    if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
       (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);
    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
                msg_ptr->utran_DRX_CycleLengthCoeff);
      return FAILURE;
    }
  } /* end UTRAN DRX Cycle Length indicator */

  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
          msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,dl_DeletedTransChInfoList))
  {
    dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,dl_AddReconfTransChInfoList))
  {
    dl_trch_add_reconfig_ptr =&msg_ptr->dl_AddReconfTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,ul_deletedTransChInfoList))
  {
    ul_trch_delete_ptr = &msg_ptr->ul_deletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,ul_AddReconfTransChInfoList))
  {
    ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
  }

  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                      ul_trch_delete_ptr)
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info2(dl_trch_add_reconfig_ptr,dl_trch_delete_ptr) == FAILURE))  
    {
      dch_ie_processing_status = FAILURE;
    }
  }

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }

  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Don't process RAB to reconfig info */

  /* Get the RB reconfiguration list */
  rb_reconfig_ptr = &msg_ptr->rb_InformationReconfigList;
  idx = 0;
  while((rb_reconfig_ptr->n > idx) && (idx < MAX_RB))
  {
    if(get_rb_info_to_reconfig(&rb_reconfig_ptr->elem[idx]) == FAILURE)
    {
      return FAILURE;
    }

    idx++;
  } /* end RB reconfig */

  /* Get the affected RB list if present */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_RadioBearerReconfiguration_r3_IEs,rb_InformationAffectedList))
  {
    rb_affected_ptr = &msg_ptr->rb_InformationAffectedList;
    idx = 0;

    while((rb_affected_ptr->n > idx) && (idx < MAX_RB))
    {
      if(get_rb_info_affected(&rb_affected_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }

      idx++;
    }
  } /* end Affected RB */

  if (FAILURE == rrcllc_validate_rb_mapping_info()) 
  {
    return FAILURE;
  }

  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Get the Common Uplink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_RadioBearerReconfiguration_r3_IEs,ul_CommonTransChInfo))
  {
    if(get_ul_info_common_for_all_trch(&msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }

  /* No need to do anything with Delete UL TrCH info. This has already been processed */

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */
  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
		rrc_RadioBearerReconfiguration_r3_IEs,ul_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) &&
            (idx < UE_MAX_TRCH) && 
            (ul_trch_add_reconfig_ptr->n > idx))
      {
        if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
  
        /* get next TrCH Info */
        idx++;
       
  
      } /* end while */
    } /* end UL TrCH Add/Reconfig */

    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  #ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;  
 #endif/*FEATURE_VOC_AMR_WB*/
    /* Calculate the UL TFCS */
    if((dch_ie_processing_status == SUCCESS) && 
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,
        ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,rrc_UL_CommonTransChInfo,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL99) == FAILURE)
        { 
          dch_ie_processing_status = FAILURE;
        }
      }
    }
  } /* If state is Cell_DCH */

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }



  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      return FAILURE;
    }
  }

  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Get the Common Downlink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,dl_CommonTransChInfo))
  {
    if(get_dl_info_common_for_all_trch(&msg_ptr->dl_CommonTransChInfo,
                                       &msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator
                                      )
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }

  if((dch_ie_processing_status == SUCCESS) &&
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,
		dl_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) &&
            (idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL &&
            (dl_trch_add_reconfig_ptr->n > idx))
      {
        if(get_dl_added_reconfig_trch_2(&dl_trch_add_reconfig_ptr->elem[idx],
                                        ul_trch_add_reconfig_ptr
                                       ) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
  
        /* get next TrCH Info */
        idx++;

  
      } /* end while */
    } /* end DL TrCH Add/Reconfig */


    /* Adjust TB size on every TrCH if necessary. */ 
    for (idx=0; (dch_ie_processing_status == SUCCESS) && (idx < UE_MAX_TRCH); idx++)
    {
      /* The number of logical channel mapped to this transport channel 
         increases from 1 to 2. Needs to adjsut the tb_szie to
         reflect the adding of the MAC header.                         */
      if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present&&
          (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
           ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
      {
        /* TrCH IE is present and the TrCH ID is appear in the TrCH info table. */
        if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,
			dl_AddReconfTransChInfoList) &&
            find_trch_id_in_config_trch_list2(&msg_ptr->dl_AddReconfTransChInfoList,
                                              ordered_config_ptr->dl_dch_trch_info[idx].trch_id)))
        {
          /* Added MAC head size to the current TB size.  */
          rrcllc_update_tb_size_for_dch(idx);
        }
        WRRC_MSG0_HIGH("Clean TB size adjust flag in RBReconfig");
        /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
      }
      else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
      {
        /* Since the activated transport channels are sorted before stored in
           the memory, break the looping after reaching the 1st invalid block.  */
        break;
      }
    }

    
    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_check_dl_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If state is Cell_DCH */

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,
  	ul_ChannelRequirement))
  {
    /* Check to see if this is DPCH or CPCH */
    switch(msg_ptr->ul_ChannelRequirement.t)
    {
      case T_rrc_UL_ChannelRequirement_ul_DPCH_Info:
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          if(get_ul_dpch_info(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        break;

      case T_rrc_UL_ChannelRequirement_dummy:
        WRRC_MSG0_ERROR("UL CPCH info not supported for RB Recfg");
        return FAILURE;

      default:
        WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in RB Recfg",
                  msg_ptr->ul_ChannelRequirement.t);
        return FAILURE;
    }
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
          current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No UL Chan Req, RB Recfg state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  } /* end if check for UL Channel Requirement */

  WRRC_MSG1_HIGH(" RBR R3 Mode specific info FDD %d",msg_ptr->modeSpecificPhysChInfo.t);
  
  /* Ignore PDSCH IEs */
  switch(msg_ptr->modeSpecificPhysChInfo.t)
  {
    case T_rrc_RadioBearerReconfiguration_r3_IEs_modeSpecificPhysChInfo_fdd:
      break;

    case T_rrc_RadioBearerReconfiguration_r3_IEs_modeSpecificPhysChInfo_tdd:
      break;

    default:
      return FAILURE;
  } /* end PDSCH check */

  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,
     dl_CommonInformation)) &&
     current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No DL DPCH, RB Recfg state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }

  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Initialize the L1 bitmask for the parameters in the "Downlink
     * information for all radio links" IE.  Since the IE is optional,
     * we want to make sure we don't signal L1 erroneously that we have
     * received information when we haven't.
     */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);
    
    if(FAILURE == rrcllcpcie_is_hho(TRUE,
                            &msg_ptr->dl_InformationPerRL_List,
                            msg_ptr->rrc_StateIndicator))
    {
        return FAILURE;
    }
    

    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r3_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl(&msg_ptr->dl_CommonInformation,
                                       &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                       &ordered_config_ptr->l1_dl_cctrch_parms,
                                       &ordered_config_ptr->l1_dl_ctfc_parms
                                      )
         == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
  } /* If next state is Cell_DCH */

  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms
                            );

  if(get_dl_info_per_rl(&msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator) != SUCCESS)
  {
    return FAILURE;
  }
  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    /* Determine HSDPA Action */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
      {
        rrcllc_set_r99_hsdpa_action();

        if(rrcllc_is_cm_active_with_hsdpa_r99())
        {
          return FAILURE;
        }
      }
    } /* If next state is Cell_DCH */  
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
     == FAILURE)
  {
    return FAILURE;
  }

  if (rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }


  if (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)) 
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

#ifdef FEATURE_WCDMA_HS_FACH
  if(SUCCESS == status)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                    validate_directed_cell_info,
                                    FALSE,FALSE);
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                    validate_directed_cell_info,
                                    FALSE,FALSE);

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL99);

#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
      FALSE)== FAILURE)
    {
      return FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return status;

} /* end rrcllc_rb_reconfig_ie() */


/*====================================================================
FUNCTION: rrcllc_rb_reconfig_ie_r5()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Reconfiguration Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_reconfig_ie_r5
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  /* local loop variable */
#ifdef FEATURE_WCDMA_HS_FACH
  uecomdef_status_e_type          status = SUCCESS;
#endif
rrc_RadioBearerReconfiguration_r5_IEs *msg_ptr =
  &dcch_ptr->message.u.radioBearerReconfiguration.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.radioBearerReconfiguration_r5;

  uint8                            idx;
  
  /* local RB to reconfigure list pointer */
  rrc_RB_InformationReconfigList_r5 *  rb_reconfig_ptr;
  
  /* local RBs to be Affected Pointer */
  rrc_RB_InformationAffectedList_r5 *  rb_affected_ptr;
  
  /* local UL TrCH Drop Pointer */
  rrc_UL_DeletedTransChInfoList  *  ul_trch_delete_ptr = NULL;
  
  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList * ul_trch_add_reconfig_ptr = NULL;
  
  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r5  *  dl_trch_delete_ptr = NULL;
  
  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r5 * dl_trch_add_reconfig_ptr = NULL;
  
  /* Local C_RNTI value */
  rrc_int_c_rnti_type              c_rnti;
  
  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
  
  /* Later on, we will check to make sure this parameter
  is present when going from a non-DCH state to DCH. */
 /* const uint32 dl_dpch_mask =
    rrc_RadioBearerReconfiguration_r5_IEs_dl_CommonInformation |
    rrc_RadioBearerReconfiguration_r5_IEs_dl_InformationPerRL_List;
*/
  rrcllc_init_before_msg_processing();
  

  
  /* We're processing a reconfiguration message now, so set the
  reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;
  
  /* Get the U-RNTI */
  if(FAILURE == rrcllc_update_urnti_in_oc(
                  RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,new_U_RNTI),
                  &msg_ptr->new_U_RNTI,
                  msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the C-RNTI */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,new_C_RNTI) &&
     (msg_ptr->rrc_StateIndicator != rrc_RRC_StateIndicator_cell_DCH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_C_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
      (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
    
#ifdef FEATURE_WCDMA_HS_RACH
    if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH)
    {
      rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
    }
#endif
  }  /* If new CRNTI present */
     /* If transitioning from CELL_DCH to CELL_FACH, delete the C-RNTI.
     * The procedure will update C-RNTI later.
  */
  if( ((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH)
    || (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH)
    || (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_ura_PCH)
    ) &&
    (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = rrcllc_check_delay_restriction_ie_rb_reconfig_r5(dcch_ptr);
#endif

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,activationTime)),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBRC);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /* Get the RRC State Indicator */
  if(FAILURE == rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the UTRAN DRX cycle length coefficient */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,utran_DRX_CycleLengthCoeff)) 
  {
    if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
      (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);
    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
        msg_ptr->utran_DRX_CycleLengthCoeff);
      return FAILURE;
    }
  } /* end UTRAN DRX Cycle Length indicator */
  
  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }
  
  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,
  	             maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */
  
  /* pre-defined configuration will be handled later */
  if (RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
  	    rrc_RadioBearerReconfiguration_r5_IEs_specificationMode_complete))
  {
    if (msg_ptr->specificationMode.u.complete.m.dl_DeletedTransChInfoListPresent)
    {
      dl_trch_delete_ptr = &msg_ptr->specificationMode.u.complete.dl_DeletedTransChInfoList;
    }
    if(msg_ptr->specificationMode.u.complete.m.dl_AddReconfTransChInfoListPresent)
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
    }
    if(msg_ptr->specificationMode.u.complete.m.ul_deletedTransChInfoListPresent)
    {
      ul_trch_delete_ptr = &msg_ptr->specificationMode.u.complete.ul_deletedTransChInfoList;
    }
    if(msg_ptr->specificationMode.u.complete.m.ul_AddReconfTransChInfoListPresent)
    {
      ul_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList;
    }
  }
  else
  {
    WRRC_MSG0_ERROR("Pre-defined Configuration unsupported");
    return FAILURE;
  }
    
  

  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
  meant for use when we do transition to Cell_DCH state.  If that's the case, store
  it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
  /* Here, update the transport channel info (only transport channel IDs 
  * and count) and rearrange the info by sorting transport channel list
  * based on TrCH ID.
    */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
      ul_trch_delete_ptr)
      == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
    
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(dl_trch_add_reconfig_ptr,dl_trch_delete_ptr)== FAILURE))  
    {
      dch_ie_processing_status = FAILURE;
    }
  }
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Don't process RAB to reconfig info */
  
  /* Get the RB reconfiguration list */
  
  if (msg_ptr->specificationMode.u.complete.m.rb_InformationReconfigListPresent)
  {
    rb_reconfig_ptr = &msg_ptr->specificationMode.u.complete.rb_InformationReconfigList;
    idx = 0;
    while((rb_reconfig_ptr->n >idx ) && (idx < MAX_RB))
    {
      if(get_rb_info_to_reconfig_r5(&rb_reconfig_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }

      idx++;
    } /* end RB reconfig */
  }
  
  /* Get the affected RB list if present */
  if(msg_ptr->specificationMode.u.complete.m.rb_InformationAffectedListPresent)
  {
    rb_affected_ptr = &msg_ptr->specificationMode.u.complete.rb_InformationAffectedList;
    idx = 0;
    
    while((rb_affected_ptr->n > idx) && (idx < MAX_RB))
    {
      if(get_rb_info_affected_r5(&rb_affected_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }
      idx++;
    }
  } /* end Affected RB */

  if (FAILURE == rrcllc_validate_rb_mapping_info()) 
  {
    return FAILURE;
  }

  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  
  if (msg_ptr->specificationMode.u.complete.m.ul_CommonTransChInfoPresent)
  {
    /* Get the Common Uplink Transport Channel information */
    if(get_ul_info_common_for_all_trch_r5(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator)
      == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }
  
  /* No need to do anything with Delete UL TrCH info. This has already been processed */

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
  * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
  * (for Cell FACH state), this check for state needs to be re-examined
  */
  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(msg_ptr->specificationMode.u.complete.m.ul_AddReconfTransChInfoListPresent)
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList;
      idx = 0;
      
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) &&
            (idx < UE_MAX_TRCH) && 
            (ul_trch_add_reconfig_ptr->n > idx))
      {
        if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
        
        /* get next TrCH Info */
        idx++;

        
      } /* end while */
    } /* end UL TrCH Add/Reconfig */
    
    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
#ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/
    /* Calculate the UL TFCS */
    if((dch_ie_processing_status == SUCCESS) && 
		(msg_ptr->specificationMode.u.complete.m.ul_CommonTransChInfoPresent))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
	  	      rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo, MSG_REL5) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
      }

      if((dch_ie_processing_status == SUCCESS) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
          tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
      }
    }
  } /* If state is Cell_DCH */
  
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }
  
  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
    msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
    !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
    msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
      ordered_config_ptr->rrc_state_indicator)
      == FAILURE)
    {
      return FAILURE;
    }
  }

  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  
  /* Get the Common Downlink Transport Channel information */
  if(msg_ptr->specificationMode.u.complete.m.dl_CommonTransChInfoPresent)
  {
    if(get_dl_info_common_for_all_trch_r5(&msg_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
      &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator
      )
      == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }
  
  if((dch_ie_processing_status == SUCCESS) &&
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    if(msg_ptr->specificationMode.u.complete.m.dl_AddReconfTransChInfoListPresent)
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList;
      dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
      idx = 0;
      
      /*  Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) &&
            (idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL &&
            (dl_trch_add_reconfig_ptr->n > idx))
      {
        if(get_dl_added_reconfig_trch_r5(&dl_trch_add_reconfig_ptr->elem[idx],
          ul_trch_add_reconfig_ptr, FALSE
          ) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
        
        
        idx++;
        
      } /* end while */
    } /* end DL TrCH Add/Reconfig */
    
      
      

    /* Adjust TB size on every TrCH if necessary. */ 
    for (idx=0; (dch_ie_processing_status == SUCCESS) && (idx<UE_MAX_TRCH); idx++)
    {
    /* The number of logical channel mapped to this transport channel 
    increases from 1 to 2. Needs to adjsut the tb_szie to
      reflect the adding of the MAC header.                         */
      if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
        (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
      {
        /* TrCH IE is present and the TrCH ID is appear in the TrCH info table. */
        if (!(msg_ptr->specificationMode.u.complete.m.dl_AddReconfTransChInfoListPresent &&
          find_trch_id_in_config_trch_list_r5(&msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
          ordered_config_ptr->dl_dch_trch_info[idx].trch_id)))
        {
          /* Added MAC head size to the current TB size.  */
          rrcllc_update_tb_size_for_dch(idx);
        }
        WRRC_MSG0_HIGH("Clean TB size adjust flag in RBReconfig");
        /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
      }
      else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
      {
      /* Since the activated transport channels are sorted before stored in
        the memory, break the looping after reaching the 1st invalid block.  */
        break;
      }
    }

      
    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_dl_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If state is Cell_DCH */
  
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }

  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_RadioBearerReconfiguration_r5_IEs,ul_ChannelRequirement))
  {
    /* Check to see if this is DPCH or CPCH */
    switch(msg_ptr->ul_ChannelRequirement.t)
    {
    case T_rrc_UL_ChannelRequirement_r5_ul_DPCH_Info:
      if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
      {
        if(get_ul_dpch_info_r5(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
        {
          return FAILURE;
        }
      }
      break;
      
    case T_rrc_UL_ChannelRequirement_r5_dummy:
      WRRC_MSG0_ERROR("UL CPCH info not supported for RB Recfg");
      return FAILURE;
      
    default:
      WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in RB Recfg",
        msg_ptr->ul_ChannelRequirement.t);
      return FAILURE;
    }
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
    current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No UL Chan Req, RB Recfg state %d->%d",
      current_config_ptr->rrc_state_indicator,
      msg_ptr->rrc_StateIndicator);
    return FAILURE;
  } /* end if check for UL Channel Requirement */

  WRRC_MSG1_HIGH(" RBRC R5 Mode specific info FDD %d",msg_ptr->modeSpecificPhysChInfo.t);
    
  /* Ignore PDSCH IEs */
  switch(msg_ptr->modeSpecificPhysChInfo.t)
  {
  case T_rrc_RadioBearerReconfiguration_r5_IEs_modeSpecificPhysChInfo_fdd:
    break;
    
  case T_rrc_RadioBearerReconfiguration_r5_IEs_modeSpecificPhysChInfo_tdd:
    break;
    
  default:
    return FAILURE;
  } /* end PDSCH check */
  
    /* Make sure that if we are transitioning to Cell DCH state that we have
  DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
    !((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,dl_CommonInformation)) &&
     (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,dl_InformationPerRL_List)))
     &&  current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No DL DPCH, RB Recfg state %d->%d",
      current_config_ptr->rrc_state_indicator,
      msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }
  
  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
  /* Initialize the L1 bitmask for the parameters in the "Downlink
  * information for all radio links" IE.  Since the IE is optional,
  * we want to make sure we don't signal L1 erroneously that we have
  * received information when we haven't.
    */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);

    if(FAILURE == rrcllcpcie_is_hho_r5((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
                                rrc_RadioBearerReconfiguration_r5_IEs,dl_InformationPerRL_List)),
                               &msg_ptr->dl_InformationPerRL_List,
                               msg_ptr->rrc_StateIndicator))
    {
      return FAILURE;
    }
    
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl_r5(&msg_ptr->dl_CommonInformation,
        &ordered_config_ptr->l1_dl_chan_parms.dl_common,
        &ordered_config_ptr->l1_dl_cctrch_parms,
        &ordered_config_ptr->l1_dl_ctfc_parms
        )
        == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
    
  } /* If next state is Cell_DCH */
  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
    &ordered_config_ptr->dl_ctfc,
    &ordered_config_ptr->rm_restrict,
    &ordered_config_ptr->l1_dl_ctfc_parms
    );
  
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,dl_InformationPerRL_List))
  {      
    if(get_dl_info_per_rl_r5(&msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }
  
  if(FAILURE == rrcllc_update_hrnti_in_oc(
                    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,new_H_RNTI), 
                    &msg_ptr->new_H_RNTI,
                    msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }
    
  /* Get HS Information */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* SET Action Variable by calling HSDPA action table */
    /* First check if HSDPA is already active or is being activated */

    if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,dl_HSPDSCH_Information))
    {
      hsdpa_msg_params.msg_params_present= TRUE;
      hsdpa_msg_params.hspdsch_info_present= TRUE;         
    }
    
    /* Determine if IFHHO is involved */
    if ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq()))
    {
      WRRC_MSG0_HIGH("RRCHS:InterFreq HO");
      hsdpa_msg_params.ifhho_involved = TRUE;
      hsdpa_msg_params.msg_params_present= TRUE;
    }
    
    if (rrcllc_determine_hsdpa_action(&msg_ptr->dl_HSPDSCH_Information) == SUCCESS)
    {
     rrc_set_hsdpa_action_in_machs_macehs();
     rrcllcpcie_update_hs_tfri_table_type_non_r7_ota();

      MSG_5(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RRCHS:HSDPA Action %d set in MAC CM VAR %d CM status L1/RRC/OTA %d %d %d",
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action,
      hsdpa_cm_enabled,
      l1_cm_query_compressed_mode_active(),
      rrcllc_is_cm_active(ordered_config_ptr),
      cm_status_from_ota_msg
      );

      /* Check if network is trying to activate CM with HSDPA */
      if(rrcllc_is_cm_active_with_hsdpa())
      {
        return FAILURE;
      }
    }
    else
    {
       WRRC_MSG0_ERROR("RRCHS:Error during HSDPA action processing"); 
      return FAILURE;
    }
  } /* If next state is Cell_DCH */     

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
    ==FAILURE)
  { 
    return FAILURE;
  }

  if (rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }


  if (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)) 
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }


  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }


#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator,FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                    validate_directed_cell_info,
                                    FALSE,
                                    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r5_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                    validate_directed_cell_info,
                                    FALSE,
                                    FALSE);
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL5);

#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
      FALSE)== FAILURE)
    {
      return FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return status;

} /* end rrcllc_rb_reconfig_ie_r5() */




/*====================================================================
FUNCTION: rrcllc_rb_release_ie()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Release Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_release_ie
(
  rrc_RadioBearerRelease_r3_IEs *msg_ptr
)
{
  /* local loop variable */
  uint8                            idx;

  /* local RB Release pointer */
  rrc_RB_InformationReleaseList    *rb_release_ptr;

  /* local RBs to be Affected Pointer */
  rrc_RB_InformationAffectedList   * rb_affected_ptr;

  /* local UL TrCH Drop Pointer */
  rrc_UL_DeletedTransChInfoList    * ul_trch_delete_ptr = NULL;

  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList * ul_trch_add_reconfig_ptr = NULL;

  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList    * dl_trch_delete_ptr = NULL;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfo2List * dl_trch_add_reconfig_ptr = NULL;

  /* Local C_RNTI value */
  rrc_int_c_rnti_type              c_rnti;

  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;

#ifdef FEATURE_WCDMA_HS_FACH
    rrcrb_directed_cell_info_type          directed_cell_info;
    memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
#endif


  /* Later on, we will check to make sure both of these parameters
     are present when going from a non-DCH state to DCH. */
  /*const uint32 dl_dpch_mask =
    rrc_RadioBearerRelease_r3_IEs_dl_CommonInformation |
    rrc_RadioBearerRelease_r3_IEs_dl_InformationPerRL_List;
*/
  rrcllc_init_before_msg_processing();
  


  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;


   /* Get the U-RNTI */
  if(FAILURE == rrcllc_update_urnti_in_oc(
                  RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r3_IEs,new_U_RNTI),
                  &msg_ptr->new_U_RNTI,
                  msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the C-RNTI only if next state is CELL_FACH. We do not need it for
   any other state */
  if((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r3_IEs,new_C_RNTI)) &&
  (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_C_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
  }  /* If new CRNTI present */
#ifdef FEATURE_WCDMA_HS_RACH
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH) &&
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r3_IEs,new_C_RNTI)))
  {
    rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
  }
#endif
  /* If transitioning from CELL_DCH to CELL_FACH, delete the C-RNTI.
   * The procedure will update C-RNTI later.
   */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH) &&
     (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }


  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r3_IEs,activationTime)),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /* Get the RRC State Indicator */
  if(FAILURE == rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the UTRAN DRX cycle length coefficient */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r3_IEs,utran_DRX_CycleLengthCoeff)) 
  {
    if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
       (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);
    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
                msg_ptr->utran_DRX_CycleLengthCoeff);
      return FAILURE;
    }
  } /* end UTRAN DRX Cycle Length indicator */

  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
      rrc_RadioBearerRelease_r3_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
          msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_RadioBearerRelease_r3_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	 rrc_RadioBearerRelease_r3_IEs,dl_DeletedTransChInfoList))
  {
    dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_RadioBearerRelease_r3_IEs,dl_AddReconfTransChInfoList))
  {
    dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r3_IEs,ul_deletedTransChInfoList))
  {
    ul_trch_delete_ptr = &msg_ptr->ul_deletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_RadioBearerRelease_r3_IEs,ul_AddReconfTransChInfoList))
  {
    ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                      ul_trch_delete_ptr)
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info2(dl_trch_add_reconfig_ptr,dl_trch_delete_ptr) == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  }
  
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }
  /* Don't process RAB to reconfig info */

  /* Get the RB release list */
  rb_release_ptr  = &msg_ptr->rb_InformationReleaseList;
  idx = 0;
  while((rb_release_ptr->n > idx) && (idx < MAX_RB))
  {
    if(get_rb_info_to_release(&rb_release_ptr->elem[idx]) == FAILURE)
    {
      return FAILURE;
    }

    idx++;
  } /* end RB release */

  /* Get the affected RB list if present */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_RadioBearerRelease_r3_IEs,rb_InformationAffectedList))
  {
    rb_affected_ptr = &msg_ptr->rb_InformationAffectedList;
    idx = 0;

    while((rb_affected_ptr->n > idx) && (idx < MAX_RB))
    {
      if(get_rb_info_affected(&rb_affected_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }

      idx++;
    }
  } /* end Affected RB */

  if (FAILURE == rrcllc_validate_rb_mapping_info()) 
  {
    return FAILURE;
  }

  /* Don't process RB with PDCP info list */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_RadioBearerRelease_r3_IEs,dl_CounterSynchronisationInfo))
  {
    WRRC_MSG0_HIGH("Ignoring DL Counter Sync Info");
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Get the Common Uplink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_RadioBearerRelease_r3_IEs,ul_CommonTransChInfo))
  {

    if(get_ul_info_common_for_all_trch(&msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* End common Uplink TrCH info */

  /* No need to do anything with Delete UL TrCH info. This has already been processed */

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */
  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
		rrc_RadioBearerRelease_r3_IEs,ul_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) &&
            (idx < UE_MAX_TRCH) && 
            (ul_trch_add_reconfig_ptr->n > idx))
      {
        if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
  
        /* get next TrCH Info */
        idx++;

  
      } /* end while */
    } /* end UL TrCH Add/Reconfig */

    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
#ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/
  
    /* Calculate the UL TFCS */
    if((dch_ie_processing_status == SUCCESS) &&
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
       rrc_RadioBearerRelease_r3_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,rrc_UL_CommonTransChInfo,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL99) == FAILURE)
        { 
          dch_ie_processing_status = FAILURE;
        } 
      }

    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      return FAILURE;
    }
  }

  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Get the Common Downlink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_RadioBearerRelease_r3_IEs,dl_CommonTransChInfo))
  {
    if(get_dl_info_common_for_all_trch(&msg_ptr->dl_CommonTransChInfo,
                                       &msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator
                                      )
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }

  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
		rrc_RadioBearerRelease_r3_IEs,dl_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) &&
            (idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL && 
            (dl_trch_add_reconfig_ptr->n > idx))
      {
        if(get_dl_added_reconfig_trch_2(&dl_trch_add_reconfig_ptr->elem[idx],
                                        ul_trch_add_reconfig_ptr
                                       ) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
  
        /* get next TrCH Info */
        idx++;

  
      } /* end while */
    } /* end DL TrCH Add/Reconfig */

    /* Adjust TB size on every TrCH if necessary. */ 
    for (idx=0; (dch_ie_processing_status == SUCCESS) && (idx<UE_MAX_TRCH); idx++)
    {
      /* The number of logical channel mapped to this transport channel 
         increases from 1 to 2. Needs to adjsut the tb_szie to
         reflect the adding of the MAC header.                         */
      if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
          (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
           ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
      {
        /* TrCH IE is present and the TrCH ID is appear in the TrCH info table. */
        if (!((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
			rrc_RadioBearerRelease_r3_IEs,dl_AddReconfTransChInfoList) )&&
            find_trch_id_in_config_trch_list2(&msg_ptr->dl_AddReconfTransChInfoList,
                                              ordered_config_ptr->dl_dch_trch_info[idx].trch_id)))
        {
          /* Added MAC head size to the current TB size.  */
          rrcllc_update_tb_size_for_dch(idx);
        }
        WRRC_MSG0_HIGH("Clean TB size adjust flag in RBRelease");
        /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
      }
      else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
      {
        /* Since the activated transport channels are sorted before stored in
           the memory, break the looping after reaching the 1st invalid block.  */
        break;
      }
    }


    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_check_dl_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
  	rrc_RadioBearerRelease_r3_IEs,ul_ChannelRequirement))
  {
    /* Check to see if this is DPCH or CPCH */
    switch(msg_ptr->ul_ChannelRequirement.t)
    {
      case T_rrc_UL_ChannelRequirement_ul_DPCH_Info:
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          if(get_ul_dpch_info(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        break;

      case T_rrc_UL_ChannelRequirement_dummy:
        WRRC_MSG0_ERROR("UL CPCH info not supported for RB Release");
        return FAILURE;

      default:
        WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in RB Release",
                  msg_ptr->ul_ChannelRequirement.t);
        return FAILURE;
    }
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
          current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No UL Chan Req, RB Release state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  } /* end if check for UL Channel Requirement */


  WRRC_MSG1_HIGH(" RBR R3 Mode specific info FDD %d",msg_ptr->modeSpecificPhysChInfo.t);
  
  /* Ignore PDSCH IEs */
  switch(msg_ptr->modeSpecificPhysChInfo.t)
  {
    case T_rrc_RadioBearerRelease_r3_IEs_modeSpecificPhysChInfo_fdd:
      break;

    case T_rrc_RadioBearerRelease_r3_IEs_modeSpecificPhysChInfo_tdd:
      break;

    default:
      return FAILURE;
  } /* end PDSCH check */

  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_RadioBearerRelease_r3_IEs,dl_CommonInformation) &&
     RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r3_IEs,
     dl_InformationPerRL_List)) &&
     current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No DL DPCH, RB Release state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }

  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Initialize the L1 bitmask for the parameters in the "Downlink
     * information for all radio links" IE.  Since the IE is optional,
     * we want to make sure we don't signal L1 erroneously that we have
     * received information when we haven't.
     */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);

    if(FAILURE == rrcllcpcie_is_hho((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
                             rrc_RadioBearerRelease_r3_IEs,dl_InformationPerRL_List)),
                            &msg_ptr->dl_InformationPerRL_List,
                            msg_ptr->rrc_StateIndicator))
    {
        return FAILURE;
    }

    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
		rrc_RadioBearerRelease_r3_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl(&msg_ptr->dl_CommonInformation,
                                       &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                       &ordered_config_ptr->l1_dl_cctrch_parms,
                                       &ordered_config_ptr->l1_dl_ctfc_parms
                                      )
         == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
  } /* If next state is Cell_DCH */

  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms
                            );

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
      rrc_RadioBearerRelease_r3_IEs,dl_InformationPerRL_List))
  {
    if(get_dl_info_per_rl(&msg_ptr->dl_InformationPerRL_List,
        msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    /* Determine HSDPA Action */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Set HSDPA Action */
      if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
      {
        rrcllc_set_r99_hsdpa_action();


        if(rrcllc_is_cm_active_with_hsdpa_r99())
        {
          return FAILURE;
        }
      }
    } /* If next state is Cell_DCH */  
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
     ==FAILURE)
  { 
    return FAILURE;
  }
  if (rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }



  if (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)) 
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }

#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif /*FEATURE_WCDMA_MIMO*/

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(&msg_ptr->rb_InformationReleaseList) == FAILURE)
    {
      return FAILURE;
    }
  }
  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL99);

  /* Got here, everything is okay */

#ifdef FEATURE_WCDMA_HS_FACH
  rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
  validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
  if(FAILURE == rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                    validate_directed_cell_info,
                                    FALSE,
                                    FALSE))
  {
    return FAILURE;
  }
  
#ifdef FEATURE_WCDMA_HS_RACH
  if(FAILURE == rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                    validate_directed_cell_info,
                                    FALSE,
                                    FALSE))
  {
    return FAILURE;
  }
#endif
#endif

  return SUCCESS;
} /* end rrcllc_rb_release_ie() */


/*====================================================================
FUNCTION: rrcllc_rb_release_ie_r5()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Release 5 Radio Bearer Release Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_release_ie_r5
(
  rrc_RadioBearerRelease_r5_IEs *msg_ptr
)
{
  /* local loop variable */
  uint8                            idx;

  /* local RB Release pointer */
  rrc_RB_InformationReleaseList    * rb_release_ptr;

  /* local RBs to be Affected Pointer */
  rrc_RB_InformationAffectedList_r5  * rb_affected_ptr;

  /* local UL TrCH Drop Pointer */
  rrc_UL_DeletedTransChInfoList    * ul_trch_delete_ptr = NULL;

  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList  * ul_trch_add_reconfig_ptr = NULL;

  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r5   * dl_trch_delete_ptr = NULL;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r5 * dl_trch_add_reconfig_ptr = NULL;

  /* Local C_RNTI value */
  rrc_int_c_rnti_type              c_rnti;

  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;

#ifdef FEATURE_WCDMA_HS_FACH
  rrcrb_directed_cell_info_type          directed_cell_info;
  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
#endif

  /* Later on, we will check to make sure both of these parameters
     are present when going from a non-DCH state to DCH. */
/*  const uint32 dl_dpch_mask =
    rrc_RadioBearerRelease_r5_IEs_dl_CommonInformation |
    rrc_RadioBearerRelease_r5_IEs_dl_InformationPerRL_List;
*/
  rrcllc_init_before_msg_processing();
  

  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;


   /* Get the U-RNTI */
   if(FAILURE == rrcllc_update_urnti_in_oc(
                   RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,new_U_RNTI),
                   &msg_ptr->new_U_RNTI,
                   msg_ptr->rrc_StateIndicator))
   {
     return FAILURE;
   }


  /* Get the C-RNTI */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_RadioBearerRelease_r5_IEs,new_C_RNTI) &&
     (msg_ptr->rrc_StateIndicator != rrc_RRC_StateIndicator_cell_DCH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_C_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
    
#ifdef FEATURE_WCDMA_HS_RACH
    if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH)
    {
      rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
    }
#endif
  }  /* If new CRNTI present */
  /* If transitioning from CELL_DCH to CELL_FACH, delete the C-RNTI.
   * The procedure will update C-RNTI later.
   */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH) &&
     (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }


  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_RadioBearerRelease_r5_IEs,activationTime)),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /* Get the RRC State Indicator */
  if(FAILURE == rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }


  /* Get the UTRAN DRX cycle length coefficient */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,utran_DRX_CycleLengthCoeff) )
  {
    if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
       (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);

    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
                msg_ptr->utran_DRX_CycleLengthCoeff);
      return FAILURE;
    }
  } /* end UTRAN DRX Cycle Length indicator */

  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
      rrc_RadioBearerRelease_r5_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
          msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_RadioBearerRelease_r5_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,dl_DeletedTransChInfoList))
  {
    dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,dl_AddReconfTransChInfoList))
  {
    dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,ul_deletedTransChInfoList))
  {
    ul_trch_delete_ptr = &msg_ptr->ul_deletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,ul_AddReconfTransChInfoList))
  {
    ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                      ul_trch_delete_ptr)
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(dl_trch_add_reconfig_ptr,dl_trch_delete_ptr) == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  }
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Don't process RAB to reconfig info */

  /* Get the RB release list */
  rb_release_ptr  = &msg_ptr->rb_InformationReleaseList;
  idx = 0;
  while((rb_release_ptr->n > idx) && (idx < MAX_RB))
  {
    if(get_rb_info_to_release(&rb_release_ptr->elem[idx]) == FAILURE)
    {
      return FAILURE;
    }

    idx++;
  } /* end RB release */

  /* Get the affected RB list if present */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_RadioBearerRelease_r5_IEs,rb_InformationAffectedList))
  {
    rb_affected_ptr = &msg_ptr->rb_InformationAffectedList;
    idx = 0;

    while((rb_affected_ptr->n > idx) && (idx < MAX_RB))
    {
      if(get_rb_info_affected_r5(&rb_affected_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }

      idx++;
    }
  } /* end Affected RB */

  if (FAILURE == rrcllc_validate_rb_mapping_info()) 
  {
    return FAILURE;
  }

  /* Don't process RB with PDCP info list */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,dl_CounterSynchronisationInfo))
  {
    WRRC_MSG0_HIGH("Ignoring DL Counter Sync Info");
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Get the Common Uplink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,ul_CommonTransChInfo))
  {

    if(get_ul_info_common_for_all_trch_r5(&msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* End common Uplink TrCH info */

  /* No need to do anything with Delete UL TrCH info. This has already been processed */


  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */
  if((dch_ie_processing_status  == SUCCESS) &&
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,ul_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status  == SUCCESS) && 
            (idx < UE_MAX_TRCH) && 
            (ul_trch_add_reconfig_ptr->n > idx))
      {
        if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
  
        /* get next TrCH Info */
        idx++;

  
      } /* end while */
    } /* end UL TrCH Add/Reconfig */

    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status  == SUCCESS) && 
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
 #ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
 #endif/*FEATURE_VOC_AMR_WB*/
  
    /* Calculate the UL TFCS */
    if((dch_ie_processing_status  == SUCCESS) && 
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
      
      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
	  	  rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL5) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
      }

      if((dch_ie_processing_status == SUCCESS) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->ul_CommonTransChInfo,
         tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
      }
    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      return FAILURE;
    }
  }

  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Get the Common Downlink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,dl_CommonTransChInfo))
  {
    if(get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
                                       &msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator
                                      )
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }


  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,dl_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) && 
            (idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL &&
            (dl_trch_add_reconfig_ptr->n > idx))
      {
        if(get_dl_added_reconfig_trch_r5(&dl_trch_add_reconfig_ptr->elem[idx],
                                        ul_trch_add_reconfig_ptr, FALSE
                                       ) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
  
        /* get next TrCH Info */
        idx++;

  
      } /* end while */
    } /* end DL TrCH Add/Reconfig */

    /* Adjust TB size on every TrCH if necessary. */ 
    for (idx=0; (dch_ie_processing_status == SUCCESS) && (idx<UE_MAX_TRCH); idx++)
    {
      /* The number of logical channel mapped to this transport channel 
         increases from 1 to 2. Needs to adjsut the tb_szie to
         reflect the adding of the MAC header.                         */
      if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
          (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
           ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
      {
        /* TrCH IE is present and the TrCH ID is appear in the TrCH info table. */
        if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,dl_AddReconfTransChInfoList) &&
            find_trch_id_in_config_trch_list_r5(&msg_ptr->dl_AddReconfTransChInfoList,
                                              ordered_config_ptr->dl_dch_trch_info[idx].trch_id)))
        {
          /* Added MAC head size to the current TB size.  */
          rrcllc_update_tb_size_for_dch(idx);
        }
        WRRC_MSG0_HIGH("Clean TB size adjust flag in RBRelease");
        /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
      }
      else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
      {
        /* Since the activated transport channels are sorted before stored in
           the memory, break the looping after reaching the 1st invalid block.  */
        break;
      }
    }


    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_dl_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,ul_ChannelRequirement))
  {
    /* Check to see if this is DPCH or CPCH */
    switch(msg_ptr->ul_ChannelRequirement.t)
    {
      case T_rrc_UL_ChannelRequirement_r5_ul_DPCH_Info:
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          if(get_ul_dpch_info_r5(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        break;

      case T_rrc_UL_ChannelRequirement_r5_dummy:
        WRRC_MSG0_ERROR("UL CPCH info not supported for RB Release");
        return FAILURE;

      default:
        WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in RB Release",
                  msg_ptr->ul_ChannelRequirement.t);
        return FAILURE;
    }
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
          current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No UL Chan Req, RB Release state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  } /* end if check for UL Channel Requirement */

  WRRC_MSG1_HIGH(" RBRC R5 Mode specific info FDD %d",msg_ptr->modeSpecificPhysChInfo.t);

  /* Ignore PDSCH IEs */
  switch(msg_ptr->modeSpecificPhysChInfo.t)
  {
    case T_rrc_RadioBearerRelease_r5_IEs_modeSpecificPhysChInfo_fdd:
      break;

    case T_rrc_RadioBearerRelease_r5_IEs_modeSpecificPhysChInfo_tdd:
      break;

    default:
      return FAILURE;
  } /* end PDSCH check */

  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,
     dl_CommonInformation)) && (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
    rrc_RadioBearerRelease_r5_IEs,dl_InformationPerRL_List)) )&&
     current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No DL DPCH, RB Release state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }

  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Initialize the L1 bitmask for the parameters in the "Downlink
     * information for all radio links" IE.  Since the IE is optional,
     * we want to make sure we don't signal L1 erroneously that we have
     * received information when we haven't.
     */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);

    if(FAILURE == rrcllcpcie_is_hho_r5((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
                                rrc_RadioBearerRelease_r5_IEs,dl_InformationPerRL_List)),
                               &msg_ptr->dl_InformationPerRL_List,
                               msg_ptr->rrc_StateIndicator))
    {
      return FAILURE;
    }

    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl_r5(&msg_ptr->dl_CommonInformation,
                                       &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                       &ordered_config_ptr->l1_dl_cctrch_parms,
                                       &ordered_config_ptr->l1_dl_ctfc_parms
                                      )
         == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
  } /* If next state is Cell_DCH */

  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms
                            );

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
      rrc_RadioBearerRelease_r5_IEs,dl_InformationPerRL_List))
  {
    if(get_dl_info_per_rl_r5(&msg_ptr->dl_InformationPerRL_List,
        msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }
  /* Get HS Information */

  
  if(FAILURE == rrcllc_update_hrnti_in_oc(
                  RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,new_H_RNTI), 
                  &msg_ptr->new_H_RNTI,
                  msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }
     

  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* SET Action Variable by calling HSDPA action table */
    /* First check if HSDPA is already active or is being activated */

    /* Either HSDPA is Active or HSPDSCH info present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,dl_HSPDSCH_Information))
    {
      hsdpa_msg_params.msg_params_present= TRUE;
      hsdpa_msg_params.hspdsch_info_present = TRUE;
      
    }
    
    /* Determine if IFHHO is involved */
    if ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_RadioBearerRelease_r5_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq()))
    {
      WRRC_MSG0_HIGH("RRCHS:InterFreq HO");
      hsdpa_msg_params.ifhho_involved = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }
    
    /* Set HSDPA Action & Physical Channel Parameters associated with it */
    if (rrcllc_determine_hsdpa_action(&msg_ptr->dl_HSPDSCH_Information) == SUCCESS)
    {
     rrc_set_hsdpa_action_in_machs_macehs();
     rrcllcpcie_update_hs_tfri_table_type_non_r7_ota();

      MSG_5(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RRCHS:HSDPA Action %d set in MAC CM VAR %d CM status L1/RRC/OTA %d %d %d",
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action,
      hsdpa_cm_enabled,
      l1_cm_query_compressed_mode_active(),
      rrcllc_is_cm_active(ordered_config_ptr),
      cm_status_from_ota_msg
      );

      /* Check if network is trying to activate CM with HSDPA */
      if(rrcllc_is_cm_active_with_hsdpa())
      {
        return FAILURE;
      }
    }
    else
    {
       WRRC_MSG0_ERROR("RRCHS:Error during HSDPA action processing"); 
      return FAILURE;
    }

    
  } /* If next state is Cell_DCH */

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
      ==FAILURE)
  { 
    return FAILURE;
  }
  if (rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }


  if (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)) 
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }


  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(&msg_ptr->rb_InformationReleaseList) == FAILURE)
    {
      return FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL5);

#ifdef FEATURE_WCDMA_HS_FACH
  rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
  validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
  if(FAILURE == rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                    validate_directed_cell_info,
                                    FALSE,
                                    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r5_IEs,new_H_RNTI)))
  {
    return FAILURE;
  }
#ifdef FEATURE_WCDMA_HS_RACH
  if(FAILURE == rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                    validate_directed_cell_info,
                                    FALSE,
                                    FALSE))
  {
    return FAILURE;
  }
#endif
#endif

#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
      FALSE)== FAILURE)
    {
      return FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */


  /* Got here, everything is okay */
  return SUCCESS;
} /* end rrcllc_rb_release_ie_r5() */



/*====================================================================
FUNCTION: rrcllc_rb_setup_ie()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Setup Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_setup_ie
(
  rrc_RadioBearerSetup_r3_IEs *msg_ptr
)
{
  /* local loop variables */
  uint8                           idx;
#ifdef FEATURE_WCDMA_HS_FACH
  uecomdef_status_e_type          status = SUCCESS;
#endif

  /* Local count of # of RAB's & RB's to setup */
  uint8                           rab_cnt = 0;
  rrc_RB_Identity rb_id = 0;
  uint8                           rb_cnt  = 0;
  uint8                           srb_cnt =0;

  rrc_SRB_InformationSetupList  *  srb_setup_ptr;


  /* local RAB to setup list pointer */
  rrc_RAB_InformationSetupList   * rab_setup_ptr;

  /* local RB per RAB to setup list pointer */
  rrc_RB_InformationSetupList    * rb_setup_ptr;

  /* local RBs to be Affected Pointer */
  rrc_RB_InformationAffectedList *  rb_affected_ptr;

  /* local UL TrCH Drop Pointer */
  rrc_UL_DeletedTransChInfoList  * ul_trch_delete_ptr = NULL;

  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList * ul_trch_add_reconfig_ptr = NULL;

  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList  * dl_trch_delete_ptr = NULL;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList  * dl_trch_add_reconfig_ptr = NULL;

  /* Local C_RNTI value */
  rrc_int_c_rnti_type             c_rnti;

 

  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* Later on, we will check to make sure both of these parameters
     are present when going from a non-DCH state to DCH. */
  /*const uint32 dl_dpch_mask =
    rrc_RadioBearerSetup_r3_IEs_dl_CommonInformation |
    rrc_RadioBearerSetup_r3_IEs_dl_InformationPerRL_List;
*/
  rrcllc_init_before_msg_processing();


  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;


  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /* Ignore the Integrity Protection and Ciphering IEs */
  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,activationTime)),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBE);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /* Get the U-RNTI */

  if(FAILURE == rrcllc_update_urnti_in_oc(
                  RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,new_U_RNTI),
                  &msg_ptr->new_U_RNTI,
                  msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the C-RNTI only if next state is CELL_FACH. We do not need it for
   any other state */
  if((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,new_C_RNTI)) &&
  (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_C_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
  }  /* If new CRNTI present */
#ifdef FEATURE_WCDMA_HS_RACH
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH) &&
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,new_C_RNTI)))
  {
    rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
  }
#endif

  /* If transitioning from CELL_DCH to CELL_FACH, delete the C-RNTI.
   * The procedure will update C-RNTI later.
   */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH) &&
     (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }


  /* Get the RRC State Indicator */
  if(FAILURE == rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the UTRAN DRX cycle length coefficient */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,utran_DRX_CycleLengthCoeff)) 
  {
    if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
       (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);
    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
                msg_ptr->utran_DRX_CycleLengthCoeff);
      return FAILURE;
    }
  } /* end UTRAN DRX Cycle Length indicator */

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,dl_DeletedTransChInfoList))
  {
    dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,dl_AddReconfTransChInfoList))
  {
    dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,ul_deletedTransChInfoList))
  {
    ul_trch_delete_ptr = &msg_ptr->ul_deletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,ul_AddReconfTransChInfoList))
  {
    ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                      ul_trch_delete_ptr)
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info(dl_trch_add_reconfig_ptr, dl_trch_delete_ptr) == FAILURE))
    {
      dch_ie_processing_status  = FAILURE;
    }
  } /* If next state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get the SRB setup list if present */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,srb_InformationSetupList))
  {

    /* Get the SRB setup list */
    srb_setup_ptr = &msg_ptr->srb_InformationSetupList;
  
  
  
    while((srb_setup_ptr->n > srb_cnt) && (srb_cnt < UE_MAX_SRB_SETUP))
    {
      /* Check to see if the RB ID is there ... */
      if(srb_setup_ptr->elem[srb_cnt].m.rb_IdentityPresent)
      {
        rb_id = srb_setup_ptr->elem[srb_cnt].rb_Identity;
      }
  
      /*
      * ... if not, then start with the first SRB and get the next SRB ID
      * each time one is not included in the IE.
      */
      else
      {
        /* Get the next SRB, note this increments to 1 the first time */
        rb_id++;
      }
  
      /* Save off the RB Mapping info for each SRB */
    /*lint -e740*/
      if(get_srb_info_to_setup(
        &srb_setup_ptr->elem[srb_cnt], 
        ((rrc_SRB_InformationSetupList2 *) srb_setup_ptr), 
        rb_id)
         == FAILURE)
      {
        return FAILURE;
      }
    /*lint +e740*/
  
      srb_cnt++;
    } /* end SRB setup */

  }

  /* Get the RAB setup list if present */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,rab_InformationSetupList))
  {
    /* Get the RAB & RB per RAB setup list if present */
    rab_setup_ptr = &msg_ptr->rab_InformationSetupList;

    while((rab_setup_ptr->n > rab_cnt) && (rab_cnt < MAX_RAB_TO_SETUP))
    {
      rb_cnt =0;
      rb_setup_ptr  = &rab_setup_ptr->elem[rab_cnt].rb_InformationSetupList;


      while((rb_setup_ptr->n > rb_cnt) && (rb_cnt < MAX_RB_PER_RAB))
      {
        if(get_rb_info_to_setup(&rb_setup_ptr->elem[rb_cnt], 
#ifdef FEATURE_UMTS_PDCP 
                                rab_setup_ptr->elem[rab_cnt].rab_Info.cn_DomainIdentity,
#endif /* FEATURE_UMTS_PDCP */
                                rb_setup_ptr) == FAILURE)
        {
          return FAILURE;
        }
        rb_cnt++;
      } /* end RB per RAB setup */
      rab_cnt++;
    } /* end rab setup */
  } /* end RAB setup */

  /* Get the affected RB list if present */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,rb_InformationAffectedList))
  {
    rb_affected_ptr = &msg_ptr->rb_InformationAffectedList;
    idx = 0;

    while((rb_affected_ptr->n > idx) && (idx < MAX_RB))
    {
      if(get_rb_info_affected(&rb_affected_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }

      idx++;
    }
  } /* end Affected RB */

  if (FAILURE == rrcllc_validate_rb_mapping_info()) 
  {
    return FAILURE;
  }



  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Get the Common Uplink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,ul_CommonTransChInfo))
  {
    if(get_ul_info_common_for_all_trch(&msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */
  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,ul_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) && 
            (idx <= UE_MAX_TRCH) && 
            (ul_trch_add_reconfig_ptr->n > idx))
      {
        if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }

        /* get next TrCH Info */
        idx++;

      } /* end while */
    } /* end UL TrCH Add/Reconfig */

    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }  
#ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
 #endif/*FEATURE_VOC_AMR_WB*/

    /* Calculate the UL TFCS */
    if((dch_ie_processing_status == SUCCESS) && 
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,rrc_UL_CommonTransChInfo,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL99) == FAILURE)
        { 
          dch_ie_processing_status = FAILURE;
        } 
      }

    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      return FAILURE;
    }
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Get the Common Downlink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,dl_CommonTransChInfo))
  {
    if(get_dl_info_common_for_all_trch(&msg_ptr->dl_CommonTransChInfo,
                                       &msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator
                                      ) 
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }

  if((dch_ie_processing_status == SUCCESS) &&
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,dl_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) &&
            (idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL &&
            (dl_trch_add_reconfig_ptr->n > idx))
      {
        if(get_dl_added_reconfig_trch(&dl_trch_add_reconfig_ptr->elem[idx],
                                      ul_trch_add_reconfig_ptr,
                                      /* RRC Connection Setup doesn't allowed TM signalling DCCH */
                                      FALSE
                                     )
            == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }

        /* get next TrCH Info */
        idx++;

      } /* end while */
    } 

    /* Adjust TB size on every TrCH if necessary. */ 
    for (idx=0; (dch_ie_processing_status == SUCCESS) && (idx<UE_MAX_TRCH); idx++)
    {
      /* The number of logical channel mapped to this transport channel 
         increases from 1 to 2. Needs to adjsut the tb_szie to
         reflect the adding of the MAC header.                         */
      if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
          (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
           ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
      {
        /* TrCH IE is present and the TrCH ID is appear in the TrCH info table. */
        if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,dl_AddReconfTransChInfoList) &&
            find_trch_id_in_config_trch_list(&msg_ptr->dl_AddReconfTransChInfoList,
                                              ordered_config_ptr->dl_dch_trch_info[idx].trch_id)))
        {
          /* Added MAC head size to the current TB size.  */
          rrcllc_update_tb_size_for_dch(idx);
        }
        WRRC_MSG0_HIGH("Clean TB size adjust flag in RBSetup");
        /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
      }
      else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
      {
        /* Since the activated transport channels are sorted before stored in
           the memory, break the looping after reaching the 1st invalid block.  */
        break;
      }
    }

    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_check_dl_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_RadioBearerSetup_r3_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
          msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,ul_ChannelRequirement))
  {
    /* Check to see if this is DPCH or CPCH */
    switch(msg_ptr->ul_ChannelRequirement.t)
    {
      case T_rrc_UL_ChannelRequirement_ul_DPCH_Info:
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          if(get_ul_dpch_info(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        break;

      case T_rrc_UL_ChannelRequirement_dummy:
        WRRC_MSG0_ERROR("UL CPCH info not supported for RB Setup");
        return FAILURE;

      default:
        WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in RB Setup",
                  msg_ptr->ul_ChannelRequirement.t);
        return FAILURE;
    }
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
          current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No UL Chan Req, RB Setup state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  } /* end if check for UL Channel Requirement */

  WRRC_MSG1_HIGH(" RBRC R5 Mode specific info FDD %d",msg_ptr->modeSpecificPhysChInfo.t);
  
  /* Ignore PDSCH IEs */
  switch(msg_ptr->modeSpecificPhysChInfo.t)
  {
    case T_rrc_RadioBearerSetup_r3_IEs_modeSpecificPhysChInfo_fdd:
      break;

    case T_rrc_RadioBearerSetup_r3_IEs_modeSpecificPhysChInfo_tdd:
      break;

    default:
      return FAILURE;
  } /* end PDSCH check */

  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,
     dl_CommonInformation) && RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
      rrc_RadioBearerSetup_r3_IEs,dl_InformationPerRL_List) ) &&
     current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No DL DPCH, RB Setup %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }

  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Initialize the L1 bitmask for the parameters in the "Downlink
     * information for all radio links" IE.  Since the IE is optional,
     * we want to make sure we don't signal L1 erroneously that we have
     * received information when we haven't.
     */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);

    if(FAILURE == rrcllcpcie_is_hho((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
                            rrc_RadioBearerSetup_r3_IEs,dl_InformationPerRL_List)),
                            &msg_ptr->dl_InformationPerRL_List,
                            msg_ptr->rrc_StateIndicator))
    {
        return FAILURE;
    }

    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r3_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl(&msg_ptr->dl_CommonInformation,
                                       &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                       &ordered_config_ptr->l1_dl_cctrch_parms,
                                       &ordered_config_ptr->l1_dl_ctfc_parms
                                      )
         == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
  } /* If next state is Cell_DCH */

  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms
                            );

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_RadioBearerSetup_r3_IEs,dl_InformationPerRL_List))
  {
    if(get_dl_info_per_rl(&msg_ptr->dl_InformationPerRL_List,
        msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    /* Determine HSDPA Action */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Set HSDPA Action */
      if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
      {
        rrcllc_set_r99_hsdpa_action();


        if(rrcllc_is_cm_active_with_hsdpa_r99())
        {
          return FAILURE;
        }
      }
    } /* If next state is Cell_DCH */  
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
       ==FAILURE)
  { 
    return FAILURE;
  }

  if (rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }


#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator,FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif /*FEATURE_WCDMA_MIMO*/

  if (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)) 
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }


  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      FALSE);
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      FALSE);
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/
  
  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL99);

  /* Got here, everything is okay */
  return status;

} /* end rrcllc_rb_setup_ie() */


/*====================================================================
FUNCTION: rrcllc_handover_to_utran_alloc_mem()

DESCRIPTION:
  This function allocated memory for utran process preconfig 

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/

static void rrcllc_handover_to_utran_alloc_mem(rrc_UL_DPCH_Info *ul_dpch_info, rrc_DL_CommonInformation *dl_common_info,rrc_DL_InformationPerRL_List *dl_rl_ptr)
{

  ul_dpch_info->ul_DPCH_PowerControlInfo.u.fdd = 
       rrc_malloc (sizeof(rrc_UL_DPCH_PowerControlInfo_fdd));
  ul_dpch_info->modeSpecificInfo.u.fdd = 
      rrc_malloc (sizeof(rrc_UL_DPCH_Info_fdd));


  dl_common_info->dl_DPCH_InfoCommon.cfnHandling.u.initialise = 
   rrc_malloc (sizeof(rrc_DL_DPCH_InfoCommon_initialise));

  dl_common_info->dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd = 
       rrc_malloc (sizeof(rrc_DL_DPCH_InfoCommon_fdd));

  dl_common_info->modeSpecificInfo.u.fdd = 
       rrc_malloc (sizeof(rrc_DL_CommonInformation_fdd));

  dl_rl_ptr->elem = rrc_malloc(sizeof(rrc_DL_InformationPerRL));

  dl_rl_ptr->elem[0].modeSpecificInfo.u.fdd = 
  		rrc_malloc(sizeof(rrc_DL_InformationPerRL_fdd));

  dl_rl_ptr->elem[0].dl_DPCH_InfoPerRL.u.fdd = rrc_malloc(sizeof(rrc_DL_DPCH_InfoPerRL_fdd));


  dl_rl_ptr->elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.elem = 
  		rrc_malloc(sizeof(rrc_DL_ChannelisationCode));

}

/*====================================================================
FUNCTION: rrcllc_handover_to_utran_free_mem()

DESCRIPTION:
  This function frees the memory allocated by rrcllc_handover_to_utran_alloc_mem

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/

static void rrcllc_handover_to_utran_free_mem(rrc_UL_DPCH_Info ul_dpch_info, rrc_DL_CommonInformation dl_common_info,rrc_DL_InformationPerRL_List dl_rl_ptr)
{
  rrc_DL_InformationPerRL *ptr = NULL;
  if(dl_rl_ptr.elem != NULL)
  {
    if(dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd != NULL)
    {
      if(dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.elem != NULL)
      {
        rrc_free(dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.elem);
      }
      rrc_free(dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd);
    }
    if(dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd != NULL)
    {
      rrc_free(dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd);
    }
    ptr = &dl_rl_ptr.elem[0];
    rrc_free(ptr);
  }
  
  if(ul_dpch_info.ul_DPCH_PowerControlInfo.u.fdd != NULL)
  {
    rrc_free(ul_dpch_info.ul_DPCH_PowerControlInfo.u.fdd);
  }
  if(ul_dpch_info.modeSpecificInfo.u.fdd != NULL)
  {
    rrc_free(ul_dpch_info.modeSpecificInfo.u.fdd);
  }
  if(dl_common_info.dl_DPCH_InfoCommon.cfnHandling.u.initialise != NULL)
  {
    rrc_free(dl_common_info.dl_DPCH_InfoCommon.cfnHandling.u.initialise);
  }
  if(dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd != NULL)
  {
    rrc_free(dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd);
  }
  
  if(dl_common_info.modeSpecificInfo.u.fdd != NULL)
  {
    rrc_free(dl_common_info.modeSpecificInfo.u.fdd);
  }
}



/*====================================================================
FUNCTION: rrcllc_rb_setup_ie_r5()



DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Setup Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_setup_ie_r5
(
  rrc_RadioBearerSetup_r5_IEs *msg_ptr
)
{
  /* local loop variables */
  
#ifdef FEATURE_WCDMA_HS_FACH
  uecomdef_status_e_type          status = SUCCESS;
#endif

  uint8                           idx;
  
  /* Local count of # of RAB's & RB's to setup */
  uint8                           rab_cnt = 0;
  rrc_RB_Identity                 rb_id = 0;
  uint8                           rb_cnt  = 0;
  uint8                           srb_cnt =0;
  
  rrc_SRB_InformationSetupList_r5 * srb_setup_r5_ptr;
  
  /* local RAB to setup list pointer */
  rrc_RAB_InformationSetupList_r5   * rab_setup_ptr;
  
  /* local RB per RAB to setup list pointer */
  rrc_RB_InformationSetupList_r5   *  rb_setup_ptr;
  
  /* local RBs to be Affected Pointer */
  rrc_RB_InformationAffectedList_r5 *  rb_affected_ptr;
  
  /* local UL TrCH Drop Pointer */
  rrc_UL_DeletedTransChInfoList *  ul_trch_delete_ptr = NULL;
  
  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList * ul_trch_add_reconfig_ptr = NULL;
  
  
  /* Local C_RNTI value */
  rrc_int_c_rnti_type             c_rnti;

  
  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r5 * dl_trch_add_reconfig_ptr = NULL;
  
  /* local DL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r5  * dl_trch_delete_ptr = NULL;
  
  
  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;


  rrc_SRB_InformationSetup_r5  * srb5_setup_ptr = NULL;

rrcrb_directed_cell_info_type          directed_cell_info;

  rrc_RB_Identity srb_id = RRCLLC_INVALID_RB_ID;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
  
  /* Later on, we will check to make sure both of these parameters
  are present when going from a non-DCH state to DCH. */
  /*const uint32 dl_dpch_mask =
    rrc_RadioBearerSetup_r5_IEs_dl_CommonInformation |
    rrc_RadioBearerSetup_r5_IEs_dl_InformationPerRL_List;
  */

  
  /* We're processing a reconfiguration message now, so set the
  reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  
  /* Process the IEs that need to be stored in ORDERED_CONFIG */

  rrcllc_init_before_msg_processing();

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,activationTime)),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBE);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /* Get the U-RNTI */
  if(FAILURE == rrcllc_update_urnti_in_oc(
                  RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,new_U_RNTI),
                  &msg_ptr->new_U_RNTI,
                  msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the C-RNTI */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,new_C_RNTI) &&
     (msg_ptr->rrc_StateIndicator != rrc_RRC_StateIndicator_cell_DCH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_C_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
      (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
    
#ifdef FEATURE_WCDMA_HS_RACH
    if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH)
    {
      rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
    }
#endif
  }  /* If new CRNTI present */
  
     /* If transitioning from CELL_DCH to CELL_FACH, delete the C-RNTI.
     * The procedure will update C-RNTI later.
  */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH) &&
    (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }

  /* Get the RRC State Indicator */
  if(FAILURE == rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }


  /* Get the UTRAN DRX cycle length coefficient */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,utran_DRX_CycleLengthCoeff)) 
  {
    if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
      (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);

    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
        msg_ptr->utran_DRX_CycleLengthCoeff);
      return FAILURE;
    }
  } /* end UTRAN DRX Cycle Length indicator */
  
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,dl_DeletedTransChInfoList))
  {
    dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,dl_AddReconfTransChInfoList))
  {
    dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,ul_deletedTransChInfoList))
  {
    ul_trch_delete_ptr = &msg_ptr->ul_deletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,ul_AddReconfTransChInfoList))
  {
    ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
  }
  

  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
  meant for use when we do transition to Cell_DCH state.  If that's the case, store
  it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
  /* Here, update the transport channel info (only transport channel IDs 
  * and count) and rearrange the info by sorting transport channel list
  * based on TrCH ID.
    */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
      ul_trch_delete_ptr)
      == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
    
    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
    would be updated later */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(dl_trch_add_reconfig_ptr, dl_trch_delete_ptr) == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }    
  } /* If next state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get the SRB setup list if present */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,srb_InformationSetupList))
  {
    
    /* Get the SRB setup list */
    srb_setup_r5_ptr = &msg_ptr->srb_InformationSetupList;
    
    
    while((srb_setup_r5_ptr->n > srb_cnt) && (srb_cnt < UE_MAX_SRB_SETUP))
    {
      /* Check to see if the RB ID is there ... */
      if(srb_setup_r5_ptr->elem[srb_cnt].m.rb_IdentityPresent)
      {
        rb_id = srb_setup_r5_ptr->elem[srb_cnt].rb_Identity;
      }
      
      /*
      * ... if not, then start with the first SRB and get the next SRB ID
      * each time one is not included in the IE.
      */
      else
      {
        /* Get the next SRB, note this increments to 1 the first time */
        rb_id++;
      }
      
      /* Save off the RB Mapping info for each SRB */
      if(get_srb_info_to_setup_r5(
        &srb_setup_r5_ptr->elem[srb_cnt], 
        (srb_setup_r5_ptr), 
        rb_id)
        == FAILURE)
      {
        return FAILURE;
      }
      
      if(rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
      {
        /* Pick that pointer that has RB Id > 4 & 
         assume it to be SRB#5 pointer for the time being */

        srb5_setup_ptr = &srb_setup_r5_ptr->elem[srb_cnt];
        srb_id = rb_id;
      }
      srb_cnt++;
    } /* end SRB setup */

    /* We are just validating one more SRB, incase 
       SRB#5 is given by n/w */
    if(srb5_setup_ptr != NULL)
    {
      if(rrcllc_update_oc_with_srb5(srb5_setup_ptr, srb_id) == FAILURE)
      {
        return FAILURE;
      }
    }
  }
  
  /* Get the RAB setup list if present */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,rab_InformationSetupList))
  {
    /* Get the RAB & RB per RAB setup list if present */
    rab_setup_ptr = &msg_ptr->rab_InformationSetupList;
    
    while((rab_setup_ptr->n > rab_cnt) && (rab_cnt < MAX_RAB_TO_SETUP))
    {
      rb_cnt =0;
      rb_setup_ptr  = &rab_setup_ptr->elem[rab_cnt].rb_InformationSetupList;
      
      
      
      while((rb_setup_ptr->n > rb_cnt) && (rb_cnt < MAX_RB_PER_RAB))
      {
        if(get_rb_info_to_setup_r5(&rb_setup_ptr->elem[rb_cnt],
#ifdef FEATURE_UMTS_PDCP
                                  rab_setup_ptr->elem[rab_cnt].rab_Info.cn_DomainIdentity,
#endif /* FEATURE_UMTS_PDCP */
                                   rb_setup_ptr

                                   ) == FAILURE)
        {
          return FAILURE;
        }

        rb_cnt++;
      } /* end RB per RAB setup */
      

      rab_cnt++;
    } /* end rab setup */
  } /* end RAB setup */
  
  /* Get the affected RB list if present */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,rb_InformationAffectedList))
  {
    rb_affected_ptr = &msg_ptr->rb_InformationAffectedList;
    idx = 0;
    
    while((rb_affected_ptr->n > idx) && (idx < MAX_RB))
    {
      if(get_rb_info_affected_r5(&rb_affected_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }
      idx++;
    }
  } /* end Affected RB */
  
  if (FAILURE == rrcllc_validate_rb_mapping_info()) 
  {
    return FAILURE;
  }
  

  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
  meant for use when we do transition to Cell_DCH state.  If that's the case, store
  it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Get the Common Uplink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,ul_CommonTransChInfo))
  {
    if(get_ul_info_common_for_all_trch_r5(&msg_ptr->ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator)
      == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    } 
  }

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
  * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
  * (for Cell FACH state), this check for state needs to be re-examined
  */
  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,ul_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      idx = 0;
      
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) && 
            (idx <= UE_MAX_TRCH) && 
            (ul_trch_add_reconfig_ptr->n > idx))
      {
        if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
             
        /* get next TrCH Info */
        idx++;

      } /* end while */
    } /* end UL TrCH Add/Reconfig */
    
    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }  
 #ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
 #endif/*FEATURE_VOC_AMR_WB*/

    /* Calculate the UL TFCS */
    if((dch_ie_processing_status == SUCCESS) && 
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
	  	 rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if((dch_ie_processing_status == SUCCESS) && 
           (rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL5) == FAILURE))
        {
          dch_ie_processing_status = FAILURE;
        }
      }

      if((dch_ie_processing_status == SUCCESS) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->ul_CommonTransChInfo,
         tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
      }
    }


  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
    msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
    !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
    msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
      ordered_config_ptr->rrc_state_indicator)
      == FAILURE)
    {
      return FAILURE;
    }
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
  meant for use when we do transition to Cell_DCH state.  If that's the case, store
  it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  
  /* Get the Common Downlink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,dl_CommonTransChInfo))
  {
    if(get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator
    ) 
      == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
    
  }
  

  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,dl_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
      idx = 0;
      
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) && 
            (idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL && 
            (dl_trch_add_reconfig_ptr->n > idx))
      {
        if(get_dl_added_reconfig_trch_r5(&dl_trch_add_reconfig_ptr->elem[idx],
          ul_trch_add_reconfig_ptr,
          /* RRC Connection Setup doesn't allowed TM signalling DCCH */
          FALSE
          )
          == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
        /* get next TrCH Info */
        idx++;
  
      } /* end while */
    } 
    
    /* Adjust TB size on every TrCH if necessary. */ 
    for (idx=0; (dch_ie_processing_status == SUCCESS) && (idx < UE_MAX_TRCH); idx++)
    {
    /* The number of logical channel mapped to this transport channel 
    increases from 1 to 2. Needs to adjsut the tb_szie to
      reflect the adding of the MAC header.                         */
      if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
        (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
      {
        /* TrCH IE is present and the TrCH ID is appear in the TrCH info table. */
        if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_RadioBearerSetup_r5_IEs,dl_AddReconfTransChInfoList) &&
          find_trch_id_in_config_trch_list_r5(&msg_ptr->dl_AddReconfTransChInfoList,
          ordered_config_ptr->dl_dch_trch_info[idx].trch_id)))
        {
          /* Added MAC head size to the current TB size.  */
          rrcllc_update_tb_size_for_dch(idx);
        }
        WRRC_MSG0_HIGH("Clean TB size adjust flag in RBSetup");
        /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
      }
      else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
      {
      /* Since the activated transport channels are sorted before stored in
        the memory, break the looping after reaching the 1st invalid block.  */
        break;
      }
    }
    
    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_dl_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status  = FAILURE;
    }
    
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
   rrc_RadioBearerSetup_r5_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }
  
  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */
  
  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,ul_ChannelRequirement))
  {
    /* Check to see if this is DPCH or CPCH */
    switch(msg_ptr->ul_ChannelRequirement.t)
    {
    case T_rrc_UL_ChannelRequirement_r5_ul_DPCH_Info:
      if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
      {
        if(get_ul_dpch_info_r5(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
        {
          return FAILURE;
        }
      }
      break;
      
    case T_rrc_UL_ChannelRequirement_r5_dummy:
      WRRC_MSG0_ERROR("UL CPCH info not supported for RB Setup");
      return FAILURE;
      
    default:
      WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in RB Setup",
        msg_ptr->ul_ChannelRequirement.t);
      return FAILURE;
    }
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
    current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No UL Chan Req, RB Setup state %d->%d",
      current_config_ptr->rrc_state_indicator,
      msg_ptr->rrc_StateIndicator);
    return FAILURE;
  } /* end if check for UL Channel Requirement */
  
  /* Ignore PDSCH IEs */
  switch(msg_ptr->modeSpecificPhysChInfo.t)
  {
  case T_rrc_RadioBearerSetup_r5_IEs_modeSpecificPhysChInfo_fdd:
    if(msg_ptr->modeSpecificPhysChInfo.u.fdd.m.dummyPresent)
    {
      WRRC_MSG0_ERROR("PDSCH not supported in RB Setup");
    }
    break;
    
  case T_rrc_RadioBearerSetup_r5_IEs_modeSpecificPhysChInfo_tdd:
    WRRC_MSG0_ERROR("Rcv'd TDD PDSCH in RB Setup");
    break;
    
  default:
    WRRC_MSG1_ERROR("Invalid PDSCH mode %d Rcv'd in RB Setup",
      msg_ptr->modeSpecificPhysChInfo.t);
    return FAILURE;
  } /* end PDSCH check */
  
    /* Make sure that if we are transitioning to Cell DCH state that we have
  DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
    !(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,
    dl_CommonInformation) && RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
    rrc_RadioBearerSetup_r5_IEs,dl_InformationPerRL_List)) &&
    current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No DL DPCH, RB Setup %d->%d",
      current_config_ptr->rrc_state_indicator,
      msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }
  
  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
  /* Initialize the L1 bitmask for the parameters in the "Downlink
  * information for all radio links" IE.  Since the IE is optional,
  * we want to make sure we don't signal L1 erroneously that we have
  * received information when we haven't.
    */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);

    if(FAILURE == rrcllcpcie_is_hho_r5((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
                               rrc_RadioBearerSetup_r5_IEs,dl_InformationPerRL_List)),
                               &msg_ptr->dl_InformationPerRL_List,
                               msg_ptr->rrc_StateIndicator))
    {
      return FAILURE;
    }

    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl_r5(&msg_ptr->dl_CommonInformation,
        &ordered_config_ptr->l1_dl_chan_parms.dl_common,
        &ordered_config_ptr->l1_dl_cctrch_parms,
        &ordered_config_ptr->l1_dl_ctfc_parms
        )
        == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
    
  } /* If next state is Cell_DCH */
  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
    &ordered_config_ptr->dl_ctfc,
    &ordered_config_ptr->rm_restrict,
    &ordered_config_ptr->l1_dl_ctfc_parms
    );
   
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
   rrc_RadioBearerSetup_r5_IEs,dl_InformationPerRL_List))
  {
    if(get_dl_info_per_rl_r5(&msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }
    
  if(FAILURE == rrcllc_update_hrnti_in_oc(
                    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,new_H_RNTI), 
                    &msg_ptr->new_H_RNTI,
                    msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get HS Information */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    
    /* SET Action Variable by calling HSDPA action table */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,dl_HSPDSCH_Information))
    {
      WRRC_MSG0_HIGH("HSPDSCH Info present");
      hsdpa_msg_params.msg_params_present= TRUE;
      hsdpa_msg_params.hspdsch_info_present = TRUE;
      
    }
    /* Determine if IFHHO is involved */
    if ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,frequencyInfo) )&&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq()))
    {
      WRRC_MSG0_HIGH("RRCHS:InterFreq HO");
      hsdpa_msg_params.ifhho_involved = TRUE;
      hsdpa_msg_params.msg_params_present = TRUE;
    }
    
    /* Set HSDPA Action & Physical Channel Parameters associated with it */
    if (rrcllc_determine_hsdpa_action(&msg_ptr->dl_HSPDSCH_Information) == SUCCESS)
    {
     rrc_set_hsdpa_action_in_machs_macehs();
     rrcllcpcie_update_hs_tfri_table_type_non_r7_ota();

      MSG_5(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RRCHS:HSDPA Action %d set in MAC CM VAR %d CM status L1/RRC/OTA %d %d %d",
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action,
      hsdpa_cm_enabled,
      l1_cm_query_compressed_mode_active(),
      rrcllc_is_cm_active(ordered_config_ptr),
      cm_status_from_ota_msg
      );

      /* Check if network is trying to activate CM with HSDPA */
      if(rrcllc_is_cm_active_with_hsdpa())
      {
        return FAILURE;
      }
      
    }
    else
    {
       WRRC_MSG0_ERROR("RRCHS:Error during HSDPA action processing"); 
      return FAILURE;
    }
  } /* If next state is Cell_DCH */

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
      ==FAILURE)
  { 
    return FAILURE;
  }

  if (rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }


  if (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)) 
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }


  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator,FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/
#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r5_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      FALSE);

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/


  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL5);

#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
      FALSE)== FAILURE)
    {
      return FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */


  /* Got here, everything is okay */
  return status;

} /* end rrcllc_rb_setup_ie_r5() */


/*====================================================================
FUNCTION: rrcllc_process_preconfiguration_with_srb5_rrc_conn_setup()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in R6 RRC Connection Setup Message that has DC with SRB5.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_process_preconfiguration_with_srb5_rrc_conn_setup
(
  rrc_RRC_StateIndicator rrc_state
)
{
  /* local loop variable */
  uint8                           idx;
  /* Local count of # of SRB's to setup */
  uint8                           srb_cnt = 0;
  rrc_RB_Identity                          srb_id = RRCLLC_INVALID_RB_ID;
  
  /* Local SRB Value */
  rrc_RB_Identity                      rb_id = CCCH_RADIO_BEARER_ID;

  boolean            predefined_config_ul_common_tr_info = FALSE;

  rrc_SRB_InformationSetup_r5 * srb5_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;

 /* local SRB to setup list pointer */
  rrc_SRB_InformationSetupList_r5 * srb_setup_r5_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList_r5 * dl_add_reconfig_trch_r5_ptr = NULL; 
  rrc_UL_AddReconfTransChInfoList * ul_add_reconfig_trch_ptr = NULL;
  rrc_DL_CommonTransChInfo_r4        *dl_common_trans_ch_info_r4_ptr = NULL;
  rrc_UL_CommonTransChInfo_r4  *ul_common_trans_ch_info_r4_ptr = NULL;

  rrc_DL_DCCH_Message * rbs_ptr = NULL; /*RBS ptr to store DC with SRB5 */
  rrc_RadioBearerSetup_r5_IEs * rbs_r5_ptr = NULL; /* Rel 5 RB-Seup msg */

  /* Store the default configuration pointers locally */
  if((rbs_ptr = rrcrce_get_rbs_ptr()) == NULL)
  {
    WRRC_MSG0_ERROR("Failed to get RBS R5 information from DC with SRB5.");
    return FAILURE;
  }

  rbs_r5_ptr = &rbs_ptr->message.u.radioBearerSetup.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.radioBearerSetup_r5;
  
  /*Store SRB  Setup Info, UL/DL Common & AddReconfig Info in Local variables from DC with SRB5*/
  if( RRC_MSG_COMMON_BITMASK_IE_PTR(rbs_r5_ptr,rrc_RadioBearerSetup_r5_IEs,srb_InformationSetupList))
  {
    srb_setup_r5_ptr = &rbs_r5_ptr->srb_InformationSetupList;
  }
  if( RRC_MSG_COMMON_BITMASK_IE_PTR(rbs_r5_ptr,rrc_RadioBearerSetup_r5_IEs,ul_AddReconfTransChInfoList))
  {
    ul_add_reconfig_trch_ptr = &rbs_r5_ptr->ul_AddReconfTransChInfoList;
  }
  if( RRC_MSG_COMMON_BITMASK_IE_PTR(rbs_r5_ptr,rrc_RadioBearerSetup_r5_IEs,ul_CommonTransChInfo))
  {
    ul_common_trans_ch_info_r4_ptr = &rbs_r5_ptr->ul_CommonTransChInfo;
  }
  if( RRC_MSG_COMMON_BITMASK_IE_PTR(rbs_r5_ptr,rrc_RadioBearerSetup_r5_IEs,dl_CommonTransChInfo))
  {
    dl_common_trans_ch_info_r4_ptr = &rbs_r5_ptr->dl_CommonTransChInfo;
  }
  if( RRC_MSG_COMMON_BITMASK_IE_PTR(rbs_r5_ptr,rrc_RadioBearerSetup_r5_IEs,dl_AddReconfTransChInfoList))
  {
    dl_add_reconfig_trch_r5_ptr = &rbs_r5_ptr->dl_AddReconfTransChInfoList;     
  }

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_add_reconfig_trch_ptr, NULL)
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(dl_add_reconfig_trch_r5_ptr, NULL) == FAILURE))
    { 
      dch_ie_processing_status = FAILURE;
    }
  }

  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }
  
  /*Make sure that SRB setup pointer isn't NULL*/
  if (srb_setup_r5_ptr == NULL)
  {
    WRRC_MSG0_ERROR("SRB Setup Ptr NULL");
    return FAILURE;
  }

  
  /*Process SRBs*/
  while((srb_setup_r5_ptr->n > srb_cnt) && (srb_cnt < UE_MAX_SRB_SETUP))
  {
    /* Check to see if the RB ID is there ... */
    if(srb_setup_r5_ptr->elem[srb_cnt].m.rb_IdentityPresent)
    {
      rb_id = srb_setup_r5_ptr->elem[srb_cnt].rb_Identity;
    }
    else
    {
      /* Get the next SRB, note this increments to 1 the first time */
      rb_id++;
    }

    /* Save off the RB Mapping info for each SRB */
    if(get_srb_info_to_setup_preconfig_r5(&srb_setup_r5_ptr->elem[srb_cnt], srb_setup_r5_ptr, rb_id)
      == FAILURE)
    {
      WRRC_MSG1_ERROR("failure decoding srb id %d for SRB5 Default config",rb_id);
      return FAILURE;
    }

    if(rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
    {
      srb5_ptr = &srb_setup_r5_ptr->elem[srb_cnt];
      srb_id = rb_id;
    }
    srb_cnt++;
  } /* end SRB setup */

  /*Process SRB5, if present*/
  if(srb_id != RRCLLC_INVALID_RB_ID )
  {
    if(rrcllc_update_oc_with_srb5(srb5_ptr, srb_id) == FAILURE)
    {
      return FAILURE;
    }
  }

  if (FAILURE == rrcllc_validate_rb_mapping_info()) 
  {
    return FAILURE;
  }

  /* Get the Common Uplink Transport Channel information */
  if(ul_common_trans_ch_info_r4_ptr != NULL)
  {
    predefined_config_ul_common_tr_info = TRUE;
    if(get_ul_info_common_for_all_trch_r5(ul_common_trans_ch_info_r4_ptr,
                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    { 
      dch_ie_processing_status = FAILURE;
    }
  } /* end UL Common TrCH Info */

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */

  ul_add_reconfig_trch_ptr = NULL;

  if((dch_ie_processing_status == SUCCESS) &&
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /*lint -save -e613 */
    ul_add_reconfig_trch_ptr = &rbs_r5_ptr->ul_AddReconfTransChInfoList;
    /*lint -restore */

    idx = 0;
    
	
    /* Save info for each additional Transport Channel */
    while((dch_ie_processing_status == SUCCESS) &&
              (idx <= UE_MAX_TRCH) && 
              (ul_add_reconfig_trch_ptr->n > idx))
    {
      if(get_ul_added_reconfig_trch(&ul_add_reconfig_trch_ptr->elem[idx]) == FAILURE)
      {
        dch_ie_processing_status = FAILURE;
      }
  
      /* get next TrCH Info */
      idx++;

    } /* end UL TrCH Add/Reconfig */
    
    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
	
#ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = MVS_MODE_NONE;
#endif/*FEATURE_VOC_AMR_WB*/
  
    /* Calculate the UL TFCS for the DCH */
    if(predefined_config_ul_common_tr_info == TRUE)
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
    }

    if((dch_ie_processing_status == SUCCESS ) && (ul_common_trans_ch_info_r4_ptr != NULL))
    {
      if(RRC_MSG_COMMON_BITMASK_IE_PTR(ul_common_trans_ch_info_r4_ptr,
	  	  rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {  
        if(rrcllc_update_oc_with_tfc_subset(ul_common_trans_ch_info_r4_ptr, MSG_REL5) == FAILURE)
        {  
          dch_ie_processing_status = FAILURE;
          WRRC_MSG0_ERROR("failure decoding UL tfc subset for SRB5 Default config");
        }  
      }
    
      if((dch_ie_processing_status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(
	  	ul_common_trans_ch_info_r4_ptr,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(ul_common_trans_ch_info_r4_ptr) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
      }
    }

  } /* If state is Cell_DCH */
 
  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      rrc_state == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      rrc_state == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      return FAILURE;
    }
  }


  /* Get the Common Downlink Transport Channel information */
  if((dl_common_trans_ch_info_r4_ptr != NULL)&&(ul_common_trans_ch_info_r4_ptr!=NULL))
  {
    if(get_dl_info_common_for_all_trch_r5(dl_common_trans_ch_info_r4_ptr, 
                                          ul_common_trans_ch_info_r4_ptr,
                                          ordered_config_ptr->rrc_state_indicator)
          == FAILURE)
    { 
      dch_ie_processing_status = FAILURE;
    }
  } /* end DL Common TrCH Info */

  dl_add_reconfig_trch_r5_ptr = NULL;
  
  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    idx = 0;

    /* Store the complete configuration pointers locally */
    /*lint -save -e613 */
    dl_add_reconfig_trch_r5_ptr = &rbs_r5_ptr->dl_AddReconfTransChInfoList;
    /*lint -restore */

    /*lint -save -e613 */
    ul_add_reconfig_trch_ptr = &rbs_r5_ptr->ul_AddReconfTransChInfoList;
    /*lint -restore */
    
    /* Save info for each additional Transport Channel */
    while((dch_ie_processing_status == SUCCESS) && 
          (idx <= UE_MAX_TRCH) && dl_add_reconfig_trch_r5_ptr != NULL && 
          (dl_add_reconfig_trch_r5_ptr->n > idx))
    { 
      if(get_dl_added_reconfig_trch_r5(&dl_add_reconfig_trch_r5_ptr->elem[idx],
                                ul_add_reconfig_trch_ptr,
                                FALSE) == FAILURE)
      { 
        dch_ie_processing_status = FAILURE;
      } 

      /* get next TrCH Info */
      idx++;
   
    }
  
    /* Adjust TB size on every TrCH if necessary. */ 
    for (idx=0; (dch_ie_processing_status == SUCCESS) && (idx < UE_MAX_TRCH); idx++)
    {
      /* The number of logical channel mapped to this transport channel 
         increases from 1 to 2. Needs to adjsut the tb_szie to
         reflect the adding of the MAC header.                         */
      if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
          (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
           ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
      {
        boolean trch_search_result = FALSE;

        /* TrCH ID is appeared in the TrCH info table. */
        /*lint -save -e613 */
        trch_search_result = find_trch_id_in_config_trch_list_r5(&rbs_r5_ptr->dl_AddReconfTransChInfoList, 
                                                              ordered_config_ptr->dl_dch_trch_info[idx].trch_id);
        /*lint -restore */
       
        if (!trch_search_result)
        {
          /* Added MAC head size to the current TB size.  */
          rrcllc_update_tb_size_for_dch(idx);
        }
        /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
        WRRC_MSG0_HIGH("Clean TB size adjust flag in RRCConn");
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
      }
      else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
      {
        /* Since the activated transport channels are sorted before stored in
           the memory, break the looping after reaching the 1st invalid block.  */
        break;
      }
    }
    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       rrcllc_check_dl_tfs_cnt() == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If state is Cell_DCH */

  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  return(SUCCESS);
}
/*====================================================================
FUNCTION: rrcllc_process_hspa_default_config()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in R5 RRC Connection Setup Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.
add check for F-DPCH & E-DPDCH
SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_process_hspa_default_config
(
  void  * msg_void_ptr,
  rrc_msg_ver_enum_type msg_version
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_RadioBearerSetup_r6_IEs *rb_setup_r6;
  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r5 * dl_trch_add_reconfig_ptr = NULL;
  
  /* local DL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r5  * dl_trch_delete_ptr = NULL;
  boolean ul_EDCH_Info = 0;
  boolean dl_FDPCH_Info = FALSE;
  
  
#ifdef FEATURE_WCDMA_REL10
  #error code not present
#endif /* FEATURE_WCDMA_REL10 */
#ifdef FEATURE_WCDMA_REL9
  rrc_RRCConnectionSetup_r9_IEs *msg_r9_ptr;
#endif /* FEATURE_WCDMA_REL9 */

  rrc_RRCConnectionSetup_r7_IEs *msg_r7_ptr;

  rrc_RRCConnectionSetup_r8_IEs *msg_r8_ptr;

  rrc_RRCConnectionSetup_r6_IEs *msg_ptr;

  rrc_RRC_StateIndicator state_indicator;

  rb_setup_r6 = rrcrce_get_rb_setup_r6_ptr_for_dc();
  if(rb_setup_r6 == NULL)
  {
    WRRC_MSG1_ERROR("Default config-17 decoded msg ptr NULL, ptr val=%x",rb_setup_r6);
    status = FAILURE;
    return status;
  }
#ifdef FEATURE_WCDMA_REL10
  #error code not present
#endif /* FEATURE_WCDMA_REL10 */
  
#ifdef FEATURE_WCDMA_REL9
  if(msg_version == MSG_REL9)
  {
    msg_r9_ptr = (rrc_RRCConnectionSetup_r9_IEs *) msg_void_ptr;
    
    state_indicator = msg_r9_ptr->rrc_StateIndicator;

     ul_EDCH_Info = RRC_MSG_COMMON_BITMASK_IE_PTR(msg_r9_ptr,rrc_RRCConnectionSetup_r9_IEs,
     ul_EDCH_Information);
     dl_FDPCH_Info = ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_r9_ptr,rrc_RRCConnectionSetup_r9_IEs,
    dl_CommonInformation))&&
         (RRC_MSG_COMMON_BITMASK_IE(msg_r9_ptr->dl_CommonInformation,
         rrc_DL_CommonInformation_r8,dl_dpchInfoCommon))&&
         (msg_r9_ptr->dl_CommonInformation.dl_dpchInfoCommon.t ==
          T_rrc_DL_CommonInformation_r8_dl_dpchInfoCommon_dl_FDPCH_InfoCommon)
        );
  }
  else
#endif /* FEATURE_WCDMA_REL9 */


  if(msg_version == MSG_REL8)
  {
    msg_r8_ptr = (rrc_RRCConnectionSetup_r8_IEs *) msg_void_ptr;
    
    state_indicator = msg_r8_ptr->rrc_StateIndicator;

     ul_EDCH_Info = RRC_MSG_COMMON_BITMASK_IE_PTR(msg_r8_ptr,rrc_RRCConnectionSetup_r8_IEs,
	 	 ul_EDCH_Information);
     dl_FDPCH_Info = ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_r8_ptr,rrc_RRCConnectionSetup_r8_IEs,
	 	dl_CommonInformation))&&
         (RRC_MSG_COMMON_BITMASK_IE(msg_r8_ptr->dl_CommonInformation,
         rrc_DL_CommonInformation_r8,dl_dpchInfoCommon))&&
         (msg_r8_ptr->dl_CommonInformation.dl_dpchInfoCommon.t ==
          T_rrc_DL_CommonInformation_r8_dl_dpchInfoCommon_dl_FDPCH_InfoCommon)
        );
  }
  else
  if(msg_version == MSG_REL7)
  {
    msg_r7_ptr = (rrc_RRCConnectionSetup_r7_IEs *) msg_void_ptr;
    
    state_indicator = msg_r7_ptr->rrc_StateIndicator;

     ul_EDCH_Info = RRC_MSG_COMMON_BITMASK_IE_PTR(msg_r7_ptr,rrc_RRCConnectionSetup_r7_IEs,
	 	ul_EDCH_Information);
     dl_FDPCH_Info = ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_r7_ptr,
	 	  rrc_RRCConnectionSetup_r7_IEs,dl_CommonInformation))&&
         (RRC_MSG_COMMON_BITMASK_IE(msg_r7_ptr->dl_CommonInformation,
         rrc_DL_CommonInformation_r7,dl_dpchInfoCommon))&&
         (msg_r7_ptr->dl_CommonInformation.dl_dpchInfoCommon.t ==
          T_rrc_DL_CommonInformation_r7_dl_dpchInfoCommon_dl_FDPCH_InfoCommon)
        );
  }
  else
  {
   msg_ptr = (rrc_RRCConnectionSetup_r6_IEs *) msg_void_ptr;

   state_indicator = msg_ptr->rrc_StateIndicator;
   ul_EDCH_Info = RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,ul_EDCH_Information);
   dl_FDPCH_Info = ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,dl_CommonInformation))&&
         (RRC_MSG_COMMON_BITMASK_IE(msg_ptr->dl_CommonInformation,rrc_DL_CommonInformation_r6,
         dl_dpchInfoCommon))&&
         (msg_ptr->dl_CommonInformation.dl_dpchInfoCommon.t ==
          T_rrc_DL_CommonInformation_r6_dl_dpchInfoCommon_dl_FDPCH_InfoCommon)
        );
 
  }
 
  /* Call these functions ONLY in DCH state */
  if(state_indicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    /*Check to see if Phy chan I.e's present for EDCH & F-DPCH*/
    if(ul_EDCH_Info && dl_FDPCH_Info)
    {
      WRRC_MSG2_HIGH("Phy chan I.E's present, ul_EDCH_Info = %d, F-DPCH info=%d", ul_EDCH_Info, dl_FDPCH_Info);
      
       /* Here, update the transport channel info (only transport channel IDs 
       * and count) and rearrange the info by sorting transport channel list
       * based on TrCH ID.
       */
      status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r6(
      RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(rb_setup_r6, rrc_RadioBearerSetup_r6_IEs),
      &rb_setup_r6->specificationMode.u.complete.ul_AddReconfTransChInfoList,
      RRCRB_R6_UL_DELETED_TRCH_INFO_LIST_PRESENT(rb_setup_r6, rrc_RadioBearerSetup_r6_IEs),
      &rb_setup_r6->specificationMode.u.complete.ul_deletedTransChInfoList);
    
    
      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
       would be updated later */
      if (RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(rb_setup_r6, rrc_RadioBearerSetup_r6_IEs))
      {
       dl_trch_add_reconfig_ptr = &rb_setup_r6->specificationMode.u.complete.dl_AddReconfTransChInfoList;
      }
    
      if (RRCRB_R6_DL_DELETED_TRCH_INFO_LIST_PRESENT(rb_setup_r6, rrc_RadioBearerSetup_r6_IEs))
      {
         dl_trch_delete_ptr = &rb_setup_r6->specificationMode.u.complete.dl_DeletedTransChInfoList;
      }
    
      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
       would be updated later */
      if (SUCCESS == status)
      {
        status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(
             dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
      }
    }
    else
    {
      WRRC_MSG2_ERROR("Phy chan I.E's not present, ul_EDCH_Info = %d, F-DPCH info=%d",
	  	ul_EDCH_Info,dl_FDPCH_Info);
	  
      status = FAILURE;
      return status;
    }
  }
  else
  {
    WRRC_MSG1_ERROR("RRC State Ind to non DCH,msg State Ind =%d",state_indicator);
    status = FAILURE;
    return status;
  }
  /* Get the SRB setup list if present */
  if (SUCCESS == status)
  {
    status =  rrcllc_process_srb_info_setup_list_r6(
      RRCRB_R6_SRB_INFO_SETUP_LIST_PRESENT(rb_setup_r6,rrc_RadioBearerSetup_r6_IEs), 
      &rb_setup_r6->specificationMode.u.complete.srb_InformationSetupList);
  }
  
  if (SUCCESS == status) 
  {
    status = rrcllc_validate_rb_mapping_info();
  }


  /* Do the processing for Uplink added/reconfigured TrCH, Compute
  * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
  * (for Cell FACH state), this check for state needs to be re-examined
  */
  if(SUCCESS == status)
  {
    status = rrcllc_store_ul_add_reconf_trch_info_list_r6(
        RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(rb_setup_r6, rrc_RadioBearerSetup_r6_IEs),
        &rb_setup_r6->specificationMode.u.complete.ul_AddReconfTransChInfoList);
  } /* If state is Cell_DCH */

  if(SUCCESS == status)
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r6(
      RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(rb_setup_r6, rrc_RadioBearerSetup_r6_IEs),
      &rb_setup_r6->specificationMode.u.complete.dl_AddReconfTransChInfoList,
      &rb_setup_r6->specificationMode.u.complete.ul_AddReconfTransChInfoList);
  } /* If state is Cell_DCH */      

  return status;
}
/*====================================================================
FUNCTION: rrcllc_process_preconfiguration_rrc_conn_setup_ie_r6()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in R5 RRC Connection Setup Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_process_preconfiguration_rrc_conn_setup_ie_r6
(
  void  *msg_ptr,
  rrc_msg_ver_enum_type msg_version
)
{
  /* local loop variable */
  uint8                           idx;

  /* Local count of # of SRB's to setup */
  uint8                           srb_cnt = 0;

  /* Local SRB Value */
  rrc_RB_Identity                      rb_id = CCCH_RADIO_BEARER_ID;

  /* local SRB to setup list pointer */
  rrc_SRB_InformationSetupList2   * srb_setup_ptr;

  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList * ul_trch_add_reconfig_ptr = NULL;

  

  boolean            predefined_config_ul_common_tr_info = FALSE;
  rrc_SysInfoType16            *sib16_ptr = NULL;
  rrc_UL_CommonTransChInfo            *default_ul_common_tr_ch_info_ptr = NULL;
  rrc_DL_CommonTransChInfo            *default_dl_common_tr_ch_info_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList     * default_dl_trch_add_reconfig_ptr = NULL;

  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;


  rrc_RRC_StateIndicator state_indicator;

  if(rrcrce_is_dc_config_on_hspa() == TRUE)
  {
    return rrcllc_process_hspa_default_config(msg_ptr,msg_version);
  }
  
#ifdef FEATURE_WCDMA_REL10
  #error code not present
#endif /* FEATURE_WCDMA_REL10 */
#ifdef FEATURE_WCDMA_REL9
  if(msg_version == MSG_REL9)
  {
    rrc_RRCConnectionSetup_r9_IEs * rel9_msg_ptr;
    rel9_msg_ptr = (rrc_RRCConnectionSetup_r9_IEs * )msg_ptr; 
    state_indicator = rel9_msg_ptr->rrc_StateIndicator;
  }
  else
#endif /* FEATURE_WCDMA_REL9 */
  if(msg_version == MSG_REL8)
  {
    rrc_RRCConnectionSetup_r8_IEs * rel8_msg_ptr;
    rel8_msg_ptr = (rrc_RRCConnectionSetup_r8_IEs * )msg_ptr; 
    state_indicator = rel8_msg_ptr->rrc_StateIndicator;
  }
  else
  if(msg_version == MSG_REL7)
  {
    rrc_RRCConnectionSetup_r7_IEs * rel7_msg_ptr;
    rel7_msg_ptr = (rrc_RRCConnectionSetup_r7_IEs * )msg_ptr; 
    state_indicator = rel7_msg_ptr->rrc_StateIndicator;
  }
  else
  {
    rrc_RRCConnectionSetup_r6_IEs * rel6_msg_ptr;
    rel6_msg_ptr = (rrc_RRCConnectionSetup_r6_IEs * )msg_ptr; 
    state_indicator = rel6_msg_ptr->rrc_StateIndicator;
     
  }

  /* Store the default configuration pointers locally */
  if((sib16_ptr = rrcrce_get_sib16_ptr()) == NULL)
  { 
    WRRC_MSG0_ERROR("Failed to get SIB16 information.");
    return FAILURE;
  } 

  default_dl_trch_add_reconfig_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.dl_TrChInfoList;
  ul_trch_add_reconfig_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.ul_AddReconfTrChInfoList;
  default_ul_common_tr_ch_info_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.ul_CommonTransChInfo;
  default_dl_common_tr_ch_info_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.dl_CommonTransChInfo;

  /* Get the SRB setup list */
  /*lint -e740 */
  srb_setup_ptr = (rrc_SRB_InformationSetupList2 *)&sib16_ptr->preDefinedRadioConfiguration.predefinedRB_Configuration.srb_InformationList;
  /*lint +e740 */


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                      NULL)
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info(default_dl_trch_add_reconfig_ptr, NULL) == FAILURE))
    { 
      dch_ie_processing_status = FAILURE;
    }
  }
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  if (srb_setup_ptr == NULL)
  {
    WRRC_MSG0_ERROR("SRB Setup Ptr NULL");
    return FAILURE;
  }

  

  while((srb_setup_ptr->n >  srb_cnt) && (srb_cnt < UE_MAX_SRB_SETUP))
  {
    /* Check to see if the RB ID is there ... */
    if(srb_setup_ptr->elem[srb_cnt].m.rb_IdentityPresent)
    {
      rb_id = srb_setup_ptr->elem[srb_cnt].rb_Identity;
    }

    /*
    * ... if not, then start with the first SRB and get the next SRB ID
    * each time one is not included in the IE.
    */
    else
    {
      /* Get the next SRB, note this increments to 1 the first time */
      rb_id++;
    }

    /* Save off the RB Mapping info for each SRB */
    if(get_srb_info_to_setup(&srb_setup_ptr->elem[srb_cnt], srb_setup_ptr, rb_id)
       == FAILURE)
    {
      return FAILURE;
    }


    srb_cnt++;
  } /* end SRB setup */

  if (FAILURE == rrcllc_validate_rb_mapping_info()) 
  {
    return FAILURE;
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Get the Common Uplink Transport Channel information */
  if(default_ul_common_tr_ch_info_ptr != NULL)
  {
    predefined_config_ul_common_tr_info = TRUE;
    if(get_ul_info_common_for_all_trch(default_ul_common_tr_ch_info_ptr, 
                                     ordered_config_ptr->rrc_state_indicator)
      == FAILURE)
    { 
      dch_ie_processing_status = FAILURE;
    }
  } /* end UL Common TrCH Info */

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */

  ul_trch_add_reconfig_ptr = NULL;

  if((dch_ie_processing_status == SUCCESS) &&
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /*lint -save -e613 */
    ul_trch_add_reconfig_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.ul_AddReconfTrChInfoList;
    /*lint -restore */

    idx = 0;
    /* Save info for each additional Transport Channel */
    while((dch_ie_processing_status == SUCCESS) &&
          (idx <= UE_MAX_TRCH) && 
          (ul_trch_add_reconfig_ptr->n >  idx))
    {
      if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
      {
        dch_ie_processing_status = FAILURE;
      }
  
      /* get next TrCH Info */
      idx++;

    } /* end UL TrCH Add/Reconfig */
    
    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
#ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = MVS_MODE_NONE;
#endif/*FEATURE_VOC_AMR_WB*/
  
    /* Calculate the UL TFCS for the DCH */
    if(predefined_config_ul_common_tr_info == TRUE)
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      state_indicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
     state_indicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      return FAILURE;
    }
  }

  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Get the Common Downlink Transport Channel information */
  if(default_dl_common_tr_ch_info_ptr != NULL)
  {
    if(get_dl_info_common_for_all_trch(default_dl_common_tr_ch_info_ptr,
                                     default_ul_common_tr_ch_info_ptr,
                                     ordered_config_ptr->rrc_state_indicator
                                    )
      == FAILURE)
    { 
      dch_ie_processing_status = FAILURE;
    }
  } /* end DL Common TrCH Info */

  default_dl_trch_add_reconfig_ptr = NULL;
  
  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    idx = 0;

    /* Store the complete configuration pointers locally */
    /*lint -save -e613 */
    default_dl_trch_add_reconfig_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.dl_TrChInfoList;
    /*lint -restore */

    /*lint -save -e613 */
    ul_trch_add_reconfig_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.ul_AddReconfTrChInfoList;
    /*lint -restore */
    
    /* Save info for each additional Transport Channel */
    while((dch_ie_processing_status == SUCCESS) && 
          (idx <= UE_MAX_TRCH) && default_dl_trch_add_reconfig_ptr != NULL && 
          (default_dl_trch_add_reconfig_ptr->n > idx))
    { 
      if(get_dl_added_reconfig_trch(&default_dl_trch_add_reconfig_ptr->elem[idx],
                                  ul_trch_add_reconfig_ptr, FALSE)
                                  
        == FAILURE)
      { 
        dch_ie_processing_status = FAILURE;
      } 

      /* get next TrCH Info */
      idx++;

    }
  
    /* Adjust TB size on every TrCH if necessary. */ 
    for (idx=0; (dch_ie_processing_status == SUCCESS) && (idx < UE_MAX_TRCH); idx++)
    {
      /* The number of logical channel mapped to this transport channel 
         increases from 1 to 2. Needs to adjsut the tb_szie to
         reflect the adding of the MAC header.                         */
      if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
          (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
           ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
      {
        boolean trch_search_result = FALSE;

        /* TrCH ID is appeared in the TrCH info table. */
        /*lint -save -e613 */
        trch_search_result = find_trch_id_in_config_trch_list(&sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.dl_TrChInfoList, 
                                                              ordered_config_ptr->dl_dch_trch_info[idx].trch_id);
        /*lint -restore */
       
        if (!trch_search_result)
        {
          /* Added MAC head size to the current TB size.  */
          rrcllc_update_tb_size_for_dch(idx);
        }
        /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
        WRRC_MSG0_HIGH("Clean TB size adjust flag in RRCConn");
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
      }
      else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
      {
        /* Since the activated transport channels are sorted before stored in
           the memory, break the looping after reaching the 1st invalid block.  */
        break;
      }
    }
    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       rrcllc_check_dl_tfs_cnt() == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If state is Cell_DCH */

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  return(SUCCESS);
}


/*====================================================================
FUNCTION: rrcllc_process_rb_info_release_list()

DESCRIPTION:
  This function the IE rrc_RB_InformationReleaseList and updates the ordered
  config accordingly

REUSABILITY: R99/R5/R6

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_process_rb_info_release_list 
(
  rrc_RB_InformationReleaseList * rb_release_ptr
)
{
  uint32 idx;
  /* local RB Release pointer */
 
  idx = 0;
  while((rb_release_ptr->n > idx) && (idx < MAX_RB))
  {
    if(get_rb_info_to_release(&rb_release_ptr->elem[idx]) == FAILURE)
    {
      return FAILURE;
    }
  
    idx++;
  } /* end RB release */

  return(SUCCESS);
}
/*====================================================================
FUNCTION: rrcllc_rb_reconfig_ie_r6()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Reconfiguration Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_reconfig_ie_r6
(
  rrc_RadioBearerReconfiguration_r6_IEs *msg_ptr
  ,rrc_RadioBearerReconfiguration_r6 *rb_reconfig_r6_non_crit_ext

)
{
  uecomdef_status_e_type          status = SUCCESS;

  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r5    * dl_trch_delete_ptr = NULL;
  
  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r5 * dl_trch_add_reconfig_ptr = NULL;

  ordered_config_type              *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* We're processing a reconfiguration message now, so set the
  reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;


  rrcllc_init_before_msg_processing();

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,delayRestrictionFlag) !=0);
#endif

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBRC);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  status = rrcllc_update_urnti_in_oc(
     RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,new_U_RNTI), 
     &msg_ptr->new_U_RNTI,
     msg_ptr->rrc_StateIndicator);

   rrcllc_update_crnti_in_oc(
     RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,new_C_RNTI),
     msg_ptr->new_C_RNTI, 
     msg_ptr->rrc_StateIndicator);

   if (SUCCESS == status)
   {
     status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
   }
  
   if (SUCCESS == status)
   {
     status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc(
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,utran_DRX_CycleLengthCoeff),
       msg_ptr->utran_DRX_CycleLengthCoeff);
   }

   if (SUCCESS == status)
   {
     /* Get the frequency info */  
     status = rrcllc_update_frequency_info_in_oc(
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,frequencyInfo),
       &msg_ptr->frequencyInfo,
       msg_ptr->rrc_StateIndicator);
   }

   if (SUCCESS == status)
   {
     /* Get the Maximum allowed UL TX power */
     status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,maxAllowedUL_TX_Power),
       msg_ptr->maxAllowedUL_TX_Power);
   }



  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
  meant for use when we do transition to Cell_DCH state.  If that's the case, store
  it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  if ((SUCCESS == status) && (RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
  	  rrc_RadioBearerReconfiguration_r6_IEs_specificationMode_complete)
      ))
  {
    /* Call these functions ONLY in DCH state */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Here, update the transport channel info (only transport channel IDs 
      * and count) and rearrange the info by sorting transport channel list
      * based on TrCH ID.
      */
      status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r6(
        RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs),
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList,
        RRCRB_R6_UL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs),
        &msg_ptr->specificationMode.u.complete.ul_deletedTransChInfoList);

      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
      if (RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs))
      {
        dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
      }

      if (RRCRB_R6_DL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs))
      {
        dl_trch_delete_ptr = &msg_ptr->specificationMode.u.complete.dl_DeletedTransChInfoList;
      }

      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
      if (SUCCESS == status)
      {
        status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(
           dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
      }
    }

    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    if(tmp_config_ptr)
    {
      ordered_config_ptr = tmp_config_ptr;
      tmp_config_ptr = NULL;
    }


    /* Don't process RAB to reconfig info */

    /* Get the RB reconfiguration list */
    if (SUCCESS == status)
    {
      status = rrcllc_process_rb_info_reconfig_list_r6(
        RRCRB_R6_RB_INFO_RECONFIG_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs),
        &msg_ptr->specificationMode.u.complete.rb_InformationReconfigList);
    }

    if (SUCCESS == status)
    {
      status = rrcllc_process_rb_info_affected_list_r6(
        RRCRB_R6_RB_INFO_AFFECTED_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs),
        &msg_ptr->specificationMode.u.complete.rb_InformationAffectedList);
    }

    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }


    /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
       meant for use when we do transition to Cell_DCH state.  If that's the case, store
       it in the TOC and it will be copied into OC at the appropriate time. */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
    {
      tmp_config_ptr = ordered_config_ptr;
      ordered_config_ptr = transition_config.toc_ptr;
      /* Processing functions must think we are going to Cell_DCH state. */
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }


    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(
       RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs),
       &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined
    */
    if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
#ifdef FEATURE_VOC_AMR_WB
      ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
 #endif/*FEATURE_VOC_AMR_WB*/

      status = rrcllc_store_ul_add_reconf_trch_info_list_r6(
          RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs),
          &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);

      /* Calculate the UL TFCS */
      if((SUCCESS == status) &&
         (RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs)))
      {
        compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
        if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,  
           rrc_UL_CommonTransChInfo_r4,tfc_Subset))
        {
          if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo, 
                                              MSG_REL6) == FAILURE)
          {
            status = FAILURE;
          }
        }

        if((status == SUCCESS) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,tfc_SubsetList)))
        {
          if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo) == FAILURE)
          {
            status = FAILURE;
          }
        }

      }

    } /* If state is Cell_DCH */

    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    if(tmp_config_ptr)
    {
      ordered_config_ptr = tmp_config_ptr;
      tmp_config_ptr = NULL;
    }



    if (SUCCESS == status)
    {
      /* Fill in the RLC size restriction information for MAC */
      if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
        !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
      {
        status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
          ordered_config_ptr->rrc_state_indicator);
      }
    }


    /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
    meant for use when we do transition to Cell_DCH state.  If that's the case, store
    it in the TOC and it will be copied into OC at the appropriate time. */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
         ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
         ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
    {
      tmp_config_ptr = ordered_config_ptr;
      ordered_config_ptr = transition_config.toc_ptr;
      /* Processing functions must think we are going to Cell_DCH state. */
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }


    /* Get the Common Downlink Transport Channel information */
    if((SUCCESS == status) &&
       (RRCRB_R6_DL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs)))
    {
      status = get_dl_info_common_for_all_trch_r5(&msg_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
        &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
        ordered_config_ptr->rrc_state_indicator);
    }
  
    if((SUCCESS == status) && 
       (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r6(
        RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs),
        &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    } /* If state is Cell_DCH */      

    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    if(tmp_config_ptr)
    {
      ordered_config_ptr = tmp_config_ptr;
      tmp_config_ptr = NULL;
    }

    if (msg_ptr->specificationMode.u.complete.m.pdcp_ROHC_TargetModePresent)
    {
      WRRC_MSG0_ERROR("RRCEUL: specificationMode_complete_pdcp_ROHC_TargetMode NOT supported yet");
    }

  }
  else /*rrc_RadioBearerReconfiguration_r6_IEs,specificationMode_complete */
  {
    WRRC_MSG0_ERROR("RRCEUL: preconfiguration in config message not yet supported");
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
          rrc_DL_InformationPerRL_List_v6b0ext *dl_info_per_rl_list_sttd_info = NULL;

          if(RRCRB_R6_DL_INFO_PERRL_EXT_PRESENT(rb_reconfig_r6_non_crit_ext,
                                             rrc_RadioBearerReconfiguration,
                                             radioBearerReconfiguration))
          {
            dl_info_per_rl_list_sttd_info =  &rb_reconfig_r6_non_crit_ext->v6b0NonCriticalExtensions.
                  radioBearerReconfiguration_v6b0ext.dl_InformationPerRL_List_v6b0ext;
          }
          
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator
      ,dl_info_per_rl_list_sttd_info

      );
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status = rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }

  if ((SUCCESS == status) && (rrcllc_is_cm_deactive_with_eul()))
  {
    status = FAILURE;
  }


  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }


  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }


  if((SUCCESS == status) && (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH))
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      status = FAILURE;
    }
  }

  if(SUCCESS == status)
  {
    if( RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,delayRestrictionFlag))
    {
      if(( RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs))
         || ( RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs))
         || (RRCRB_R6_UL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs))
         || ( RRCRB_R6_DL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs))
      ) 
      {
        WRRC_MSG0_ERROR("Trch IE touched bitmask  , so Delay restriction cannot be applied");
      }
      else
      {
        rrcllc_update_delay_restriction(
          RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,activationTime),
          RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,delayRestrictionFlag),
          msg_ptr->activationTime,msg_ptr->rrc_StateIndicator);
      }
    }
  }

#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator,FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r6_IEs,newPrimary_E_RNTI));
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL6);

#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
      FALSE)== FAILURE)
    {
      return FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return (status);
} /* end rrcllc_rb_reconfig_ie_r6() */

/*====================================================================
FUNCTION: rrcllc_trch_reconfig_ie_r6()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Release 6 Transport Channel Reconfiguration Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_trch_reconfig_ie_r6
(
  rrc_TransportChannelReconfiguration_r6_IEs *msg_ptr
  ,rrc_TransportChannelReconfiguration_r6 * trch_chan_reconfig_r6_non_crit_ext

)
{
  uecomdef_status_e_type          status = SUCCESS;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r5  * dl_trch_add_reconfig_ptr = NULL;

  ordered_config_type              *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;


  rrcllc_init_before_msg_processing();

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,delayRestrictionFlag) !=0);
#endif

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_TCR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
 status = rrcllc_update_urnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,new_U_RNTI), 
    &msg_ptr->new_U_RNTI,
    msg_ptr->rrc_StateIndicator);

   rrcllc_update_crnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,new_C_RNTI),
    msg_ptr->new_C_RNTI, 
    msg_ptr->rrc_StateIndicator);

   if (SUCCESS == status)
   {
     status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
   }

  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,utran_DRX_CycleLengthCoeff),
    msg_ptr->utran_DRX_CycleLengthCoeff);
  }


  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }



  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
      /* Here, update the transport channel info (only transport channel IDs 
      * and count) and rearrange the info by sorting transport channel list
      * based on TrCH ID.
      */
      status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r6(
        (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,ul_AddReconfTransChInfoList)),
        &msg_ptr->ul_AddReconfTransChInfoList,
        FALSE,
        NULL);


      if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,dl_AddReconfTransChInfoList))
      {
        dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
      }

      if (SUCCESS == status)
      {
        status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(dl_trch_add_reconfig_ptr,
                                                                   NULL);
      }
  }


  /* Get the Common Uplink Transport Channel information */
  if (SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6(
     (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,ul_CommonTransChInfo)),
     &msg_ptr->ul_CommonTransChInfo);
  }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined
    */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_ul_add_reconf_trch_info_list_r6(
        (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,ul_AddReconfTransChInfoList)),
        &msg_ptr->ul_AddReconfTransChInfoList);
  
    /* Calculate the UL TFCS */
    if((SUCCESS == status) &&
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,rrc_UL_CommonTransChInfo_r4,
	  	 tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL6) == FAILURE)
        {
          status = FAILURE;
        }
      }

      if((status == SUCCESS) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          status = FAILURE;
        }
      }
    }
  
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      status = FAILURE;
    }
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }



  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) &&
     (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,dl_CommonTransChInfo)))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator);
  }

  if((SUCCESS == status) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r6(
      (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,dl_AddReconfTransChInfoList)),
      &msg_ptr->dl_AddReconfTransChInfoList,
      &msg_ptr->ul_AddReconfTransChInfoList);
  } /* If state is Cell_DCH */   

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
          rrc_DL_InformationPerRL_List_v6b0ext *dl_info_per_rl_list_sttd_info = NULL;

          if(RRCRB_R6_DL_INFO_PERRL_EXT_PRESENT(trch_chan_reconfig_r6_non_crit_ext,
                                                                           rrc_TransportChannelReconfiguration,
                                                                           transportChannelReconfiguration))
          {
            dl_info_per_rl_list_sttd_info =  &trch_chan_reconfig_r6_non_crit_ext->v6b0NonCriticalExtensions.
                  transportChannelReconfiguration_v6b0ext.dl_InformationPerRL_List_v6b0ext;
          }
          
         
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator
      ,dl_info_per_rl_list_sttd_info
      );
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status = rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }
  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }


  if((SUCCESS == status) && (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH))
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      status = FAILURE;
    }
  }

  if(SUCCESS == status)
  {
    if( RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,delayRestrictionFlag))
    {
      if(( RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,ul_AddReconfTransChInfoList))
         || ( RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,dl_AddReconfTransChInfoList))
      ) 
      {
        WRRC_MSG0_ERROR("Trch Ie touched bitmask  , so Delay restriction cannot be applied");
      }
      else
      {
        rrcllc_update_delay_restriction(
          RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,activationTime),
          RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,delayRestrictionFlag),
          msg_ptr->activationTime,msg_ptr->rrc_StateIndicator);
      }
    }
  }
#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator,FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/
#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r6_IEs,newPrimary_E_RNTI));
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL6);

#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
      FALSE)== FAILURE)
    {
      return FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return (status);

} /* end rrcllc_trch_reconfig_ie_r6() */

/*====================================================================
FUNCTION: rrcllc_phychan_reconfig_ie_r6()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Physical Channel Reconfiguration Message for Rel 6

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_phychan_reconfig_ie_r6
(
  rrc_PhysicalChannelReconfiguration_r6_IEs *msg_ptr
  , rrc_PhysicalChannelReconfiguration_r6  * phys_chan_reconfig_r6_non_critical_ext
)
{

  uecomdef_status_e_type          status = SUCCESS;
rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));


  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  rrcllc_init_before_msg_processing();

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,delayRestrictionFlag) !=0);
#endif

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_PCR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
 status = rrcllc_update_urnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,new_U_RNTI), 
    &msg_ptr->new_U_RNTI,
    msg_ptr->rrc_StateIndicator);

   rrcllc_update_crnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,new_C_RNTI),
    msg_ptr->new_C_RNTI, 
    msg_ptr->rrc_StateIndicator);

   if (SUCCESS == status)
   {
     status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
   }

  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,utran_DRX_CycleLengthCoeff),
    msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }


  if (SUCCESS == status)
  {
     rrc_DL_InformationPerRL_List_v6b0ext *dl_info_per_rl_list_sttd_info = NULL;

    if(RRCRB_R6_DL_INFO_PERRL_EXT_PRESENT(phys_chan_reconfig_r6_non_critical_ext,
                                                                    rrc_PhysicalChannelReconfiguration,
                                                                    physicalChannelReconfiguration))
    {
      dl_info_per_rl_list_sttd_info =  &phys_chan_reconfig_r6_non_critical_ext->v6b0NonCriticalExtensions.
            physicalChannelReconfiguration_v6b0ext.dl_InformationPerRL_List_v6b0ext;
    }
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator
      ,dl_info_per_rl_list_sttd_info
      );
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status = rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }


  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,frequencyInfo) )&&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if(SUCCESS == status)
  {
    rrcllc_update_delay_restriction(
     RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,activationTime),
     RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,delayRestrictionFlag),
     msg_ptr->activationTime,msg_ptr->rrc_StateIndicator);

  }

#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                    validate_directed_cell_info,
                                    FALSE,
                                    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r6_IEs,newPrimary_E_RNTI));
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL6);

#ifdef FEATURE_WCDMA_DC_HSUPA
  if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)== FAILURE)
  {
    return FAILURE;
  }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return (status);

} /* end rrcllc_phychan_reconfig_ie_r6() */

/*====================================================================
FUNCTION: rrcllc_cell_update_confirm_ie_r6()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Cell Update Confirm Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_cell_update_confirm_ie_r6
(
  rrc_CellUpdateConfirm_r6_IEs *msg_ptr
  ,rrc_DL_InformationPerRL_List_v6b0ext *dl_info_per_rl_list_sttd_info
)
{

  uecomdef_status_e_type          status = SUCCESS;

  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r5    * dl_trch_delete_ptr = NULL;
  
  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r5 * dl_trch_add_reconfig_ptr = NULL;

  ordered_config_type              *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* We're processing a reconfiguration message now, so set the
  reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  rrcllc_init_before_msg_processing();

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_CU);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  status = rrcllc_update_urnti_in_oc(
     RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,new_U_RNTI), 
     &msg_ptr->new_U_RNTI,
     msg_ptr->rrc_StateIndicator);

   rrcllc_update_crnti_in_oc(
     RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,new_C_RNTI),
     msg_ptr->new_C_RNTI, 
     msg_ptr->rrc_StateIndicator);

   if (SUCCESS == status)
   {
     status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
   }
  
   if (SUCCESS == status)
   {
     status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc(
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,utran_DRX_CycleLengthCoeff),
       msg_ptr->utran_DRX_CycleLengthCoeff);
   }

   if (SUCCESS == status)
   {
     /* Get the frequency info */  
     status = rrcllc_update_frequency_info_in_oc(
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,frequencyInfo),
       &msg_ptr->frequencyInfo,
       msg_ptr->rrc_StateIndicator);
   }

   if (SUCCESS == status)
   {
     /* Get the Maximum allowed UL TX power */
     status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,maxAllowedUL_TX_Power),
       msg_ptr->maxAllowedUL_TX_Power);
   }



  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
  meant for use when we do transition to Cell_DCH state.  If that's the case, store
  it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }



  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r6(
      (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,ul_AddReconfTransChInfoList)),
      &msg_ptr->ul_AddReconfTransChInfoList,
      (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,ul_deletedTransChInfoList)),
      &msg_ptr->ul_deletedTransChInfoList);


    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
       would be updated later */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }

    if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,dl_DeletedTransChInfoList))
    {
      dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
    }

    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
       would be updated later */
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(
        dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
    }
  }

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }
 


  if (SUCCESS == status && 
      (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,rb_InformationReleaseList)))
  {
    status = rrcllc_process_rb_info_release_list(&msg_ptr->rb_InformationReleaseList);
  }

  /* Get the RB reconfiguration list */
  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_reconfig_list_r6(
      (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,rb_InformationReconfigList)),
      &msg_ptr->rb_InformationReconfigList);
  }

  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_affected_list_r6(
      (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,rb_InformationAffectedList)),
      &msg_ptr->rb_InformationAffectedList);
  }


  if (SUCCESS == status) 
  {
    status = rrcllc_validate_rb_mapping_info();
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Get the Common Uplink Transport Channel information */
  if (SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6(
      (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,ul_CommonTransChInfo)),
      &msg_ptr->ul_CommonTransChInfo);
  }

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_ul_add_reconf_trch_info_list_r6(
      (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,ul_AddReconfTransChInfoList)),
      &msg_ptr->ul_AddReconfTransChInfoList);
    
    /* Calculate the UL TFCS */
    if((SUCCESS == status) &&
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
	  	rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL6) == FAILURE)
        { 
          status = FAILURE;
        }
      }

      if((status == SUCCESS) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          status = FAILURE;
        }
      }
    }

  } /* If state is Cell_DCH */

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (SUCCESS == status)
  {
    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
        ordered_config_ptr->rrc_state_indicator);
    }
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
  meant for use when we do transition to Cell_DCH state.  If that's the case, store
  it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) &&
     (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,dl_CommonInformation)))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator);
  }

  if((SUCCESS == status) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r6(
      (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,dl_AddReconfTransChInfoList)),
      &msg_ptr->dl_AddReconfTransChInfoList,
      &msg_ptr->ul_AddReconfTransChInfoList);
  } /* If state is Cell_DCH */      

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }

  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,pdcp_ROHC_TargetMode))
  {
    WRRC_MSG0_ERROR("RRCEUL:rrc_CellUpdateConfirm_r6_IEs,pdcp_ROHC_TargetMode NOT supported yet");
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator
      ,dl_info_per_rl_list_sttd_info
      );
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status = rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }

  if ((SUCCESS == status) &&  rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }


  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }


  if((SUCCESS == status) && (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH))
  {
    if(rrcllc_check_trch_mapped_to_rb_present(&msg_ptr->rb_InformationReleaseList) == FAILURE)
    {
      status = FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/
#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r6_IEs,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL6);

#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
      FALSE)== FAILURE)
    {
      return FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return (status);
} /* end rrcllc_cell_update_confirm_ie_r6() */

/*====================================================================
FUNCTION: rrcllc_rb_release_ie_r6()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Release 5 Radio Bearer Release Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_release_ie_r6
(
  rrc_RadioBearerRelease_r6_IEs *msg_ptr,
  rrc_RadioBearerRelease_r6 *rb_rel_r6_non_crit_ext
)
{
  uecomdef_status_e_type          status = SUCCESS;

  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r5   * dl_trch_delete_ptr = NULL;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r5 * dl_trch_add_reconfig_ptr = NULL;

  ordered_config_type              *tmp_config_ptr = NULL;
#ifdef FEATURE_WCDMA_HS_FACH
  rrcrb_directed_cell_info_type          directed_cell_info;
  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
#endif


  rrcllc_init_before_msg_processing();
  
  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;


 status = rrcllc_update_urnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,new_U_RNTI), 
    &msg_ptr->new_U_RNTI,
    msg_ptr->rrc_StateIndicator);

  rrcllc_update_crnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,new_C_RNTI),
    msg_ptr->new_C_RNTI, 
    msg_ptr->rrc_StateIndicator);


  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the UTRAN DRX cycle length coefficient */
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,utran_DRX_CycleLengthCoeff),
    msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }
  

  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Call these functions ONLY in DCH state */
  if ((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Here, update the transport channel info (only transport channel IDs 
    * and count) and rearrange the info by sorting transport channel list
    * based on TrCH ID.
    */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList,
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,ul_deletedTransChInfoList),
      &msg_ptr->ul_deletedTransChInfoList);

    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
    would be updated later */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }

    if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,dl_DeletedTransChInfoList))
    {
      dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
    }

    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
    would be updated later */
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(
         dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
    }
  }

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  /* Don't process RAB to reconfig info */

  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_release_list(&msg_ptr->rb_InformationReleaseList);
  }

  if (SUCCESS == status)
  {
    /* Get the affected RB list if present */
    status = rrcllc_process_rb_info_reconfig_list_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,rb_InformationReconfigList),
      &msg_ptr->rb_InformationReconfigList);
  }

  if (SUCCESS == status)
  {
    /* Get the affected RB list if present */
    status = rrcllc_process_rb_info_affected_list_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,rb_InformationAffectedList),
      &msg_ptr->rb_InformationAffectedList);
  }

  if (SUCCESS == status) 
  {
    status = rrcllc_validate_rb_mapping_info();
  }

  /* Don't process RB with PDCP info list */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_RadioBearerRelease_r5_IEs,dl_CounterSynchronisationInfo))
  {
    WRRC_MSG0_HIGH("Ignoring DL Counter Sync Info");
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }



  /* Get the Common Uplink Transport Channel information */
  if (SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6(
     RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,ul_CommonTransChInfo),
     &msg_ptr->ul_CommonTransChInfo);
  }

  /* No need to do anything with Delete UL TrCH info. This has already been processed */

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
  * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
  * (for Cell FACH state), this check for state needs to be re-examined
  */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
#ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
 #endif/*FEATURE_VOC_AMR_WB*/

    status = rrcllc_store_ul_add_reconf_trch_info_list_r6(
        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,ul_AddReconfTransChInfoList),
        &msg_ptr->ul_AddReconfTransChInfoList);

    /* Calculate the UL TFCS */
    if((SUCCESS == status) &&
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,rrc_UL_CommonTransChInfo_r4,
	  	tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL6) == FAILURE)
        {
          status = FAILURE;
        }
      }

      if((status == SUCCESS) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          status = FAILURE;
        }
      }
    }
  } /* If state is Cell_DCH */

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (SUCCESS == status)
  {
    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
        ordered_config_ptr->rrc_state_indicator);
    }
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
  meant for use when we do transition to Cell_DCH state.  If that's the case, store
  it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) &&
     (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,dl_CommonTransChInfo)))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator);
  }

  if((SUCCESS == status) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,dl_AddReconfTransChInfoList),
      &msg_ptr->dl_AddReconfTransChInfoList,
      &msg_ptr->ul_AddReconfTransChInfoList);
  } /* If state is Cell_DCH */      

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
          rrc_DL_InformationPerRL_List_v6b0ext *dl_info_per_rl_list_sttd_info = NULL;

          if(RRCRB_R6_DL_INFO_PERRL_EXT_PRESENT(rb_rel_r6_non_crit_ext,
                                                                           rrc_RadioBearerRelease,
                                                                           radioBearerRelease))
          {
            dl_info_per_rl_list_sttd_info =  &rb_rel_r6_non_crit_ext->v6b0NonCriticalExtensions.
                  radioBearerRelease_v6b0ext.dl_InformationPerRL_List_v6b0ext;
          }
          
        
    status = rrcllcpcie_process_dl_info_per_rl_list_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator
      ,dl_info_per_rl_list_sttd_info
      );
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status = rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }

  if ((SUCCESS == status) &&  rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }


  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  /* First check if HSDPA is already active or is being activated */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if((SUCCESS == status) && (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH))
  {
    if(rrcllc_check_trch_mapped_to_rb_present(&msg_ptr->rb_InformationReleaseList) == FAILURE)
    {
      status = FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL6);

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(status == SUCCESS)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerRelease_r6_IEs,newPrimary_E_RNTI));
  }
#endif
#endif


#ifdef FEATURE_WCDMA_DC_HSUPA
  if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)== FAILURE)
  {
    return FAILURE;
  }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return (status);
} /* end rrcllc_rb_release_ie_r6() */


/*====================================================================
FUNCTION: rrcllc_rb_setup_ie_r6()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Setup Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_setup_ie_r6
(
  rrc_RadioBearerSetup_r6_IEs *msg_ptr
  ,rrc_RadioBearerSetup_r6 *rb_setup_r6_non_crit_ext
)
{
  uecomdef_status_e_type          status = SUCCESS;
  
  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r5 * dl_trch_add_reconfig_ptr = NULL;
  
  /* local DL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r5   * dl_trch_delete_ptr = NULL;
  
  
  ordered_config_type              *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
  
  /* We're processing a reconfiguration message now, so set the
  reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;
  
  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  rrcllc_init_before_msg_processing();

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBE);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
   if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
   {
     return FAILURE;
   }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
 status = rrcllc_update_urnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,new_U_RNTI), 
    &msg_ptr->new_U_RNTI,
    msg_ptr->rrc_StateIndicator);
 

  rrcllc_update_crnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,new_C_RNTI),
    msg_ptr->new_C_RNTI, 
    msg_ptr->rrc_StateIndicator);

  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,utran_DRX_CycleLengthCoeff),
    msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }


  if ((SUCCESS == status) && (RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
  	     rrc_RadioBearerSetup_r6_IEs_specificationMode_complete)))
  {

    /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
    meant for use when we do transition to Cell_DCH state.  If that's the case, store
    it in the TOC and it will be copied into OC at the appropriate time. */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
    {
      /* If the TOC isn't valid, we must make it valid now. */
      if(transition_config.toc_usage == TOC_INVALID)
      {
        transition_config.toc_usage = TOC_FOR_DCH;
      }
      tmp_config_ptr = ordered_config_ptr;
      ordered_config_ptr = transition_config.toc_ptr;
      /* Processing functions must think we are going to Cell_DCH state. */
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }


    /* Call these functions ONLY in DCH state */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Here, update the transport channel info (only transport channel IDs 
      * and count) and rearrange the info by sorting transport channel list
      * based on TrCH ID.
      */
      status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r6(
        RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs),
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList,
        RRCRB_R6_UL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs),
        &msg_ptr->specificationMode.u.complete.ul_deletedTransChInfoList);


      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
      if (RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs))
      {
        dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
      }

      if (RRCRB_R6_DL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs))
      {
        dl_trch_delete_ptr = &msg_ptr->specificationMode.u.complete.dl_DeletedTransChInfoList;
      }

      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
      if (SUCCESS == status)
      {
        status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(
           dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
      }
    }

    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    if(tmp_config_ptr)
    {
      ordered_config_ptr = tmp_config_ptr;
      tmp_config_ptr = NULL;
    }

    /* Get the SRB setup list if present */
    if (SUCCESS == status)
    {
      status =  rrcllc_process_srb_info_setup_list_r6(
        RRCRB_R6_SRB_INFO_SETUP_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs), 
        &msg_ptr->specificationMode.u.complete.srb_InformationSetupList);
    }

    /* Get the RAB setup list if present */
    if (SUCCESS == status)
    {
      status = rrcllc_process_rab_info_setup_list_r6(
        RRCRB_R6_RAB_INFO_SETUP_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs),
        &msg_ptr->specificationMode.u.complete.rab_InformationSetupList);
    }

    /* Get the RB reconfiguration list */
    if (SUCCESS == status)
    {
      status = rrcllc_process_rb_info_reconfig_list_r6(
        RRCRB_R6_RB_INFO_RECONFIG_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs),
        &msg_ptr->specificationMode.u.complete.rb_InformationReconfigList);
    }

    if (SUCCESS == status)
    {
      status = rrcllc_process_rb_info_affected_list_r6(
        RRCRB_R6_RB_INFO_AFFECTED_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs),
        &msg_ptr->specificationMode.u.complete.rb_InformationAffectedList);
    }

    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }


    /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
       meant for use when we do transition to Cell_DCH state.  If that's the case, store
       it in the TOC and it will be copied into OC at the appropriate time. */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
    {
      tmp_config_ptr = ordered_config_ptr;
      ordered_config_ptr = transition_config.toc_ptr;
      /* Processing functions must think we are going to Cell_DCH state. */
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }


    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(
       RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs),
       &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined
    */
    if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
#ifdef FEATURE_VOC_AMR_WB
      ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
 #endif/*FEATURE_VOC_AMR_WB*/

      status = rrcllc_store_ul_add_reconf_trch_info_list_r6(
          RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs),
          &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);

      /* Calculate the UL TFCS */
      if((SUCCESS == status) &&
         (RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs)))
      {
        compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
        if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,  
           rrc_UL_CommonTransChInfo_r4,tfc_Subset))
        {
          if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
                                              MSG_REL6) == FAILURE)
          {
            status = FAILURE;
          }
        }

        if((status == SUCCESS) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,tfc_SubsetList)))
        {
          if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo) == FAILURE)
          {
            status = FAILURE;
          }
        }
      }
    } /* If state is Cell_DCH */

    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    if(tmp_config_ptr)
    {
      ordered_config_ptr = tmp_config_ptr;
      tmp_config_ptr = NULL;
    }

    
    if (SUCCESS == status)
    {
      /* Fill in the RLC size restriction information for MAC */
      if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
        !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
      {
        status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
          ordered_config_ptr->rrc_state_indicator);
      }
    }



    /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
    meant for use when we do transition to Cell_DCH state.  If that's the case, store
    it in the TOC and it will be copied into OC at the appropriate time. */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
    {
      tmp_config_ptr = ordered_config_ptr;
      ordered_config_ptr = transition_config.toc_ptr;
      /* Processing functions must think we are going to Cell_DCH state. */
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }

    /* Get the Common Downlink Transport Channel information */
    if((SUCCESS == status) &&
       (RRCRB_R6_DL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs)))
    {
      status = get_dl_info_common_for_all_trch_r5(&msg_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
        &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
        ordered_config_ptr->rrc_state_indicator);
    }

    if((SUCCESS == status) && 
       (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r6(
        RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r6_IEs),
        &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    } /* If state is Cell_DCH */      

    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    if(tmp_config_ptr)
    {
      ordered_config_ptr = tmp_config_ptr;
      tmp_config_ptr = NULL;
    }


    if (   msg_ptr->specificationMode.u.complete.m.pdcp_ROHC_TargetModePresent)
    {
      WRRC_MSG0_ERROR("RRCEUL: specificationMode_complete_pdcp_ROHC_TargetMode NOT supported yet");
    }

  }
  else /*rrc_RadioBearerSetup_r6_IEs,specificationMode_preconfiguration */
  {
    WRRC_MSG0_ERROR("Preconfig mde not allowed in RB-Setup ");
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    struct rrc_DL_InformationPerRL_List_v6b0ext *dl_info_per_rl_list_sttd_info = NULL;

    if(RRCRB_R6_DL_INFO_PERRL_EXT_PRESENT(rb_setup_r6_non_crit_ext,
                                                                    rrc_RadioBearerSetup,
                                                                    radioBearerSetup))
    {
      dl_info_per_rl_list_sttd_info =  &rb_setup_r6_non_crit_ext->v6b0NonCriticalExtensions.
            radioBearerSetup_v6b0ext.dl_InformationPerRL_List_v6b0ext;
    }
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator
      ,dl_info_per_rl_list_sttd_info
      );
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status = rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }

  if ((SUCCESS == status) &&  rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if((SUCCESS == status) && (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH))
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      status = FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/
#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r6_IEs,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL6);

#ifdef FEATURE_WCDMA_DC_HSUPA
  if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)== FAILURE)
  {
    return FAILURE;
  }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return (status);

} /* end rrcllc_rb_setup_ie_r6() */


/*====================================================================
FUNCTION: rrcllc_rrc_conn_setup_ie_r6()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in R5 RRC Connection Setup Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rrc_conn_setup_ie_r6
(
  rrc_RRCConnectionSetup_r6_IEs *msg_ptr
  ,rrc_RRCConnectionSetup_r6 * rrc_conn_setup_r6_non_crit_ext
)
{
  uecomdef_status_e_type          status = SUCCESS;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r5 * dl_trch_add_reconfig_ptr = NULL;

  ordered_config_type              *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /************************************************************/
  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /************************************************************/

  /* We do not handle Cell_PCH and URA_PCH states at present */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH) || (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    WRRC_MSG0_ERROR("CELL_PCH or URA-PCH state transition invalid!");
    status = FAILURE;
  }

  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  /* Assume that the default is now, i.e. the current SFN */
  MSG_MED("Activation Time is Now!",0,0,0);
  ordered_config_ptr->activation_time = RRCLLC_ACTIVATION_TIME_NOW;
  ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_NONE;

  rrcllc_init_before_msg_processing();
  
#ifdef FEATURE_VOC_AMR_WB
  ordered_config_ptr->ul_tfcs.orderd_codec_mode = MVS_MODE_NONE;
#endif/*FEATURE_VOC_AMR_WB*/

  if (SUCCESS == status)
  {
   status = rrcllc_update_urnti_in_oc(
      TRUE, /* new-U-RNTI is mandatory in RRC Connection Setup message */
      &msg_ptr->new_U_RNTI,
      msg_ptr->rrc_StateIndicator);  
  }

  /* Get the C-RNTI */
  rrcllc_update_crnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,new_c_RNTI),
    msg_ptr->new_c_RNTI, 
    msg_ptr->rrc_StateIndicator);


  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the UTRAN DRX cycle length coefficient */
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc(
    TRUE, /* its mandatory present in RRC Connection Setup message */
    msg_ptr->utran_DRX_CycleLengthCoeff);
  }  

  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  if ((SUCCESS == status) && (RRC_CHECK_COMMON_MSG_TYPE( msg_ptr->specificationMode,
  	rrc_RRCConnectionSetup_r6_IEs_specificationMode_complete)))
  {
    if(RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(
        msg_ptr,rrc_RRCConnectionSetup_r6_IEs) )
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
    } 
    /* Call these functions ONLY in DCH state */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Here, update the transport channel info (only transport channel IDs 
      * and count) and rearrange the info by sorting transport channel list
      * based on TrCH ID.
      */
      status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r6(
        TRUE, /* ul_AddReconfTransChInfoList is mandatory present */
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList,
        FALSE,
        NULL);


      if (SUCCESS == status)
      {
        status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(
                 dl_trch_add_reconfig_ptr, NULL);
      }
    }  
    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    if(tmp_config_ptr)
    {
      ordered_config_ptr = tmp_config_ptr;
      tmp_config_ptr = NULL;
    }


    /* Get the SRB setup list if present */
    if (SUCCESS == status)
    {
      status =  rrcllc_process_srb_info_setup_list_r6(
        TRUE, /* SRB info has to be present in rrcConnectionSetup message */
        (rrc_SRB_InformationSetupList_r6 *) &msg_ptr->specificationMode.u.
        complete.srb_InformationSetupList);
    }

    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }
    

    /* We might receive TrCH info even if the next state isn't Cell_DCH.
     * This info is meant for use when we do transition to Cell_DCH state.
     * If that's the case, store it in the TOC and it will be copied into OC
     * at the appropriate time. */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
    {
      tmp_config_ptr = ordered_config_ptr;
      ordered_config_ptr = transition_config.toc_ptr;
      /* Processing functions must think we are going to Cell_DCH state. */
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }


    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(
       RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r6_IEs),
       &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined
    */
    if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      status = rrcllc_store_ul_add_reconf_trch_info_list_r6(
          RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r6_IEs),
          &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);

      /* Calculate the UL TFCS */
      if((SUCCESS == status) &&
         (RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r6_IEs)))
      {
        compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

        if(RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,tfc_SubsetList))
        {
          if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo) == FAILURE)
          {
            status = FAILURE;
          } 
        } 
      }

    } /* If state is Cell_DCH */

    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    if(tmp_config_ptr)
    {
      ordered_config_ptr = tmp_config_ptr;
      tmp_config_ptr = NULL;
    }


    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
       !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                       ordered_config_ptr->rrc_state_indicator)
          == FAILURE)
      {
        status = FAILURE;
      }
    }



    /* We might receive TrCH info even if the next state isn't Cell_DCH.
     * This info is meant for use when we do transition to Cell_DCH state.
     * If that's the case, store it in the TOC and it will be copied into OC
     * at the appropriate time. */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
    {
      tmp_config_ptr = ordered_config_ptr;
      ordered_config_ptr = transition_config.toc_ptr;
      /* Processing functions must think we are going to Cell_DCH state. */
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }


    /* Get the Common Downlink Transport Channel information */
    if((SUCCESS == status) &&
       (RRCRB_R6_DL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r6_IEs)))
    {
      status = get_dl_info_common_for_all_trch_r5(
        &msg_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
        &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
        ordered_config_ptr->rrc_state_indicator);
    }

    if (SUCCESS == status)
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r6(
        RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r6_IEs),
        &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    }
  }
  else /*rrc_RRCConnectionSetup_r6_IEs,specificationMode_preconfiguration */
  {
    if(rrcrce_get_rbs_ptr() != NULL)
    {
      status = rrcllc_process_preconfiguration_with_srb5_rrc_conn_setup(msg_ptr->rrc_StateIndicator);
      WRRC_MSG1_HIGH("Finished processing DC with SRB5. status = %d",status);
    }
    else
    {
      status = rrcllc_process_preconfiguration_rrc_conn_setup_ie_r6((void *) msg_ptr, MSG_REL6);
    }
  }

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (SUCCESS == status)
  {
    /* Get the frequency info */
    status = rrcllc_update_frequency_info_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get Uplink DPCH info if included, Ignore CPCH info */
    status = rrcllcpcie_process_ul_dpch_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the DL information for all Radio Links */
    status = rrcllcpcie_process_dl_common_info_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
     rrc_DL_InformationPerRL_List_v6b0ext * dl_info_per_rl_list_sttd_info = NULL;
    if(rrc_conn_setup_r6_non_crit_ext != NULL )
    {
        if( RRCRB_R6_DL_INFO_PERRL_EXT_PRESENT(rrc_conn_setup_r6_non_crit_ext,
               rrc_RRCConnectionSetup,rrcConnectionSetup))
        {
            dl_info_per_rl_list_sttd_info =
              &rrc_conn_setup_r6_non_crit_ext->v6b0NonCriticalExtensions.rrcConnectionSetup_v6b0ext.dl_InformationPerRL_List_v6b0ext;
        }
    }
    status = rrcllcpcie_process_dl_info_per_rl_list_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator
      ,dl_info_per_rl_list_sttd_info
      );
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status = rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }


  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }
  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }


  if((SUCCESS == status) && (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH))
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                       validate_directed_cell_info,
                                       TRUE,
                                       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                       validate_directed_cell_info,
                                       TRUE,
                                       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r6_IEs,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/


  return (status);
} /* end rrcllc_rrc_conn_setup_ie_r6() */


/*====================================================================
FUNCTION: rrcllc_active_set_update_ie()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Active Set Update Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_active_set_update_ie_r6
(
  rrc_ActiveSetUpdate_r6_IEs *msg_ptr
  ,rrc_ActiveSetUpdate_r6 *asu_r6_non_crit_ext
)
{
  uecomdef_status_e_type          status = SUCCESS;

  rrcllc_init_before_msg_processing();

  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /* Ignore the Integrity Protection and Ciphering IEs */

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,activationTime),
    msg_ptr->activationTime, rrc_RRC_StateIndicator_cell_DCH, RRC_PROCEDURE_ASU);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
 /* Get the U-RNTI */
 status = rrcllc_update_urnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,newU_RNTI), 
    &msg_ptr->newU_RNTI,
    rrc_RRC_StateIndicator_cell_DCH);

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  } 

  if (SUCCESS == status)
  {
    /* Get the Radio Link Removal information */
    status = rrcllcpcie_process_rl_removal_information_list(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,rl_RemovalInformationList),
      &msg_ptr->rl_RemovalInformationList,
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,rl_AdditionInformationList)
      );
  }
    

  /* Get the TX Diversity Mode */
  if((SUCCESS == status) && 
     (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,tx_DiversityMode)))
  {
    status = get_tx_diversity_mode_info(msg_ptr->tx_DiversityMode,
      &ordered_config_ptr->l1_dl_chan_parms.dl_common);
  } /* end TX Diversity Mode */

  if (SUCCESS == status)
  {
          rrc_RL_AdditionInformation_list_v6b0ext *rl_info_per_rl_list_sttd_info = NULL;

          if( (    asu_r6_non_crit_ext->m.v6b0NonCriticalExtensionsPresent)
              && ( asu_r6_non_crit_ext->v6b0NonCriticalExtensions.activeSetUpdate_v6b0ext.m.rl_AdditionInformation_list_v6b0extPresent )   
            )
          {
            rl_info_per_rl_list_sttd_info =  &asu_r6_non_crit_ext->v6b0NonCriticalExtensions.
                  activeSetUpdate_v6b0ext.rl_AdditionInformation_list_v6b0ext;
          }
    /* Get the Radio Link Addition information */
    status = rrcllcpcie_process_rl_addition_info_list_r6(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,rl_AdditionInformationList),
      &msg_ptr->rl_AdditionInformationList
     ,rl_info_per_rl_list_sttd_info

      );
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_e_dch_reconfig_info(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,e_dch_ReconfigurationInfo),
      &msg_ptr->e_dch_ReconfigurationInfo);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    rrc_RRC_StateIndicator_cell_DCH);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    rrc_RRC_StateIndicator_cell_DCH);

  if(SUCCESS == status)
  {
    rrcllcpcie_process_edpch_interpolation_info(FALSE, FALSE);
  }

#ifdef FEATURE_WCDMA_REL7_EDPCCH_POWER_BOOST
  if(SUCCESS == status)
  {
    status = rrcllcpcie_process_edpcch_boost_info(NULL,FALSE);
  }
#endif

#ifdef FEATURE_WCDMA_16_QAM
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_16qam_config(FALSE,NULL);
  }
#endif
  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  {
    status = rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(rrc_RRC_StateIndicator_cell_DCH);
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  /* Validation for and processing for ASU repointing */

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,newH_RNTI), 
      &msg_ptr->newH_RNTI,
      rrc_RRC_StateIndicator_cell_DCH);
  }


  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,serving_HSDSCH_CellInformation))
  {
    if(SUCCESS == status)
    {
      status = rrcllc_process_serving_hsdsch_cell_info(msg_ptr); 
    }
  }


  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r6_IEs,dpc_Mode))
  {
    WRRC_MSG0_ERROR("processing of dpc_Mode in ASU not yet supported");
    status = FAILURE;
  }
 #ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    rrc_RRC_StateIndicator_cell_DCH, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,rrc_RRC_StateIndicator_cell_DCH,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  rrcllc_check_and_stop_dtx(rrc_RRC_StateIndicator_cell_DCH,MSG_REL6);

#ifdef FEATURE_WCDMA_DC_HSUPA
  if(rrcllcpcie_process_dc_hsupa_params(NULL,rrc_RRC_StateIndicator_cell_DCH,
    FALSE)== FAILURE)
  {
    return FAILURE;
  }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  return (status);
} /* end rrcllc_active_set_update_ie() */
/*====================================================================
FUNCTION: rrcllc_handover_to_utran_process_preconfig_r6()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Handover to UTRAN Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_handover_to_utran_process_preconfig_r6
(
  rrc_HandoverToUTRANCommand_r6_IEs *msg_ptr
)
{
  /* Local copy of SIB16 pointer.  In the case of a default configuration,
   * this actually points to data for the specified default configuration,
   * not the actual SIB16 data.  That doesn't matter to us, though.  We also
   * declare some convenience pointers here to shorten the names of the 
   * SIB16 members later on. */
  rrc_SysInfoType16            *sib16_ptr = NULL;
  uecomdef_status_e_type ret_status = SUCCESS;
  rrc_PredefinedRB_Configuration      *predef_rb = NULL;
  rrc_PreDefTransChConfiguration      *predef_trch = NULL;
  rrc_PreDefPhyChConfiguration        *predef_phych = NULL;

  rrc_SRB_InformationSetupList   * srb_setup_ptr = NULL;
  rrc_RAB_InformationSetupList    rab_setup_ptr;
   
  rrc_UL_CommonTransChInfo        *ul_common_trans_ch_info_ptr = NULL;
  rrc_DL_CommonTransChInfo        *dl_common_trans_ch_info_ptr = NULL;
  rrc_UL_AddReconfTransChInfoList *ul_trch_add_reconfig_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList *dl_trch_add_reconfig_ptr = NULL;
  rrc_UL_DPCH_Info                ul_dpch_info;
  rrc_DL_CommonInformation        dl_common_info;
  rrc_DL_InformationPerRL_List     dl_rl_ptr = {0};
  
  /* Local pointers and instances for other IEs that are used to hold
     onto list pointers, or for temporary IE construction. */

  rrc_RB_InformationSetupList          * rb_setup_ptr = NULL;

  rrc_RadioBearerSetup_r5_IEs *rbs_r5_ptr = NULL;
  uint32 default_config_id = RRC_DEF_CONFIG_INVALID;
  void *rbs_ptr = NULL;

  rrcllcoc_dl_info_per_rl_status_e_type status =
      RRCLLCOC_DL_INFO_PER_RL_IGNORED; /* Return status from DL Info per RL processing. */

  /* Local counters, return values, and other simple scalar types. */
  uint8      idx     = 0; /* Loop index */
  rrc_RB_Identity rb_id   = CCCH_RADIO_BEARER_ID; /* SRB value */
  uint8      srb_cnt = 0; /* Count of SRBs to set up */
  uint8      rab_cnt = 0; /* Count of RABs to set up */
  uint8      rb_cnt  = 0; /* Count of RBs to set up */
 
  rrc_DL_InformationPerRL_ListPostFDD  * dl_rl_post_ptr;
  /* Get a pointer to the SIB16 data and set up some shorter aliases for
   * the unwieldy member data names. */
  rab_setup_ptr.elem = NULL;
  rab_setup_ptr.n = 0;

  memset((void *)&ul_dpch_info, 0, sizeof(rrc_UL_DPCH_Info));
  memset((void *)&dl_common_info, 0, sizeof(rrc_DL_CommonInformation));

  rrcllc_handover_to_utran_alloc_mem(&ul_dpch_info, &dl_common_info, &dl_rl_ptr);

  if((rbs_ptr = rrciho_get_rbs_ptr(&default_config_id)) != NULL)
  {
    rbs_r5_ptr = (rrc_RadioBearerSetup_r5_IEs *) rbs_ptr;
  }
  else
  {
    sib16_ptr = rrciho_get_sib16_ptr(); 
    if(sib16_ptr == NULL)
    {
      WRRC_MSG0_ERROR("Failed to get SIB16 information.");
      ret_status = FAILURE;
    }
	if(ret_status == SUCCESS)
    {
    predef_rb =
      &sib16_ptr->preDefinedRadioConfiguration.predefinedRB_Configuration;
    predef_trch =
      &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration;
    predef_phych =
      &sib16_ptr->preDefinedRadioConfiguration.preDefPhyChConfiguration;
  
  
    /* Set up our local pointers for processing.  This is a little tougher
       than the complete specification case, because now the information we
       need is split up between the incoming message and SIB16, and we must
       make that information come together in familiar IEs in order to use
       existing processing functions. */
    /* Signalling RB information to setup list */
    srb_setup_ptr = &predef_rb->srb_InformationList;
  }
}

  if ((ret_status == SUCCESS) &&( msg_ptr->specificationMode.u.preconfiguration.m.rab_InfoPresent))
  {
    if(rbs_r5_ptr == NULL)
    {
      rab_setup_ptr.elem = rrc_malloc(sizeof(rrc_RAB_InformationSetup));
      (void) rrcllc_get_predefined_rab_info(msg_ptr->specificationMode.u.preconfiguration.rab_Info,
                                   predef_rb,
                                   &rab_setup_ptr);

    }
  }
  
  if((ret_status == SUCCESS) && (msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.t == 
     T_rrc_HandoverToUTRANCommand_r6_IEs_modeSpecificInfo_fdd))
  { 

    if(rbs_r5_ptr != NULL)
    {
      if((RRC_MSG_COMMON_BITMASK_IE_PTR(rbs_r5_ptr,rrc_RadioBearerSetup_r5_IEs,ul_ChannelRequirement))
            && (rbs_r5_ptr->ul_ChannelRequirement.t == T_rrc_UL_ChannelRequirement_r5_ul_DPCH_Info ))
      {
        if (rrcllc_get_predefined_ul_dpch_info_srb5(&ul_dpch_info,
                                                &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                                fdd.ul_DPCH_Info,
                                                rbs_r5_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
        {
          ret_status = FAILURE;
        }
		if(ret_status == SUCCESS)
	    {
          (void)rrcllc_get_predefined_dl_common_info_srb5(&dl_common_info,
                                                  &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                                  fdd.dl_CommonInformationPost,
                                                  &rbs_r5_ptr->dl_CommonInformation.dl_DPCH_InfoCommon,
                                                  &msg_ptr->new_U_RNTI);
	    }
      }
      else
      {
        WRRC_MSG0_ERROR("UL DPCH info not present in encoded rb-setup not present ");
        ret_status = FAILURE;
      }
    }
    else
    {
      (void) rrcllc_get_predefined_ul_dpch_info(&ul_dpch_info,
                                               &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                               fdd.ul_DPCH_Info,
                                               predef_phych);
 
      (void) rrcllc_get_predefined_dl_common_info(&dl_common_info,
                                                 &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                                 fdd.dl_CommonInformationPost,
                                                 predef_phych,
                                                 &msg_ptr->new_U_RNTI);
    }
    if(ret_status == SUCCESS)
    {
      dl_rl_post_ptr= &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.fdd.dl_InformationPerRL_List;
   /*PSR check this */
      dl_rl_ptr.n =1;
  	
      memset(&dl_rl_ptr.elem[0].m,0,sizeof(dl_rl_ptr.elem[0].m));
      dl_rl_ptr.elem[0].m.dl_DPCH_InfoPerRLPresent = 1;

      memset(&dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd->m,0,
  		sizeof(dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd->m));
  		
      dl_rl_ptr.elem[0].modeSpecificInfo.t =
        T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd;
      dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info =
        dl_rl_post_ptr->elem[0].primaryCPICH_Info;
      memset(&dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->m,0,sizeof(dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->m));
  
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.t =
        T_rrc_DL_DPCH_InfoPerRL_fdd;
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->pCPICH_UsageForChannelEst =
        dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.pCPICH_UsageForChannelEst;
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->pCPICH_UsageForChannelEst =
         rrc_PCPICH_UsageForChannelEst_mayBeUsed;

      if(NULL != dl_common_info.modeSpecificInfo.u.fdd)
      {
        dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dpch_FrameOffset = 
           ((dl_common_info.modeSpecificInfo.u.fdd->defaultDPCH_OffsetValue * 512)
             % 38400) / 256; /* 25.331, clause 8.3.5.1.2 */
      }
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.n = 1;
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.elem[0] =
      dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.dl_ChannelisationCode;
 
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->tpc_CombinationIndex =
        dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.tpc_CombinationIndex;
      if( dl_rl_post_ptr->n > 1)
      {
        WRRC_MSG0_ERROR("Single Pri-SCR supported for GtoW HO");
      }
    }

  }
  else
  {
    WRRC_MSG0_ERROR("Only FDD mode supported in Handover to UTRAN Command");
    ret_status = FAILURE;
  }
  if((ret_status == SUCCESS) && (rbs_r5_ptr == NULL))
  {

    /* UL Transport channel information common for all transport channels */
    ul_common_trans_ch_info_ptr = &predef_trch->ul_CommonTransChInfo;
  
    /* DL Transport channel information common for all transport channels */
    dl_common_trans_ch_info_ptr = &predef_trch->dl_CommonTransChInfo;
  
    /* Added or Reconfigured UL TrCH information */
    ul_trch_add_reconfig_ptr = &predef_trch->ul_AddReconfTrChInfoList;
  
    /* Added or Reconfigured DL TrCH information */
    dl_trch_add_reconfig_ptr = &predef_trch->dl_TrChInfoList;
  
  
    if(rrcllc_add_delete_and_arrange_dl_dch_trch_info(dl_trch_add_reconfig_ptr,
                                                      NULL) == FAILURE)
    { 
      ret_status =FAILURE;
    } 
    
    if((ret_status == SUCCESS) && (rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                      NULL) == FAILURE))
    { 
      ret_status =FAILURE;
    } 
    
    /* Get the SRB setup list.  This cast is here solely for code reuse.
     * The rrc_SRB_InformationSetupList2 type is identical to the
     * rrc_SRB_InformationSetupList type except for the name.  Later on,
     * we will pass srb_setup_head_ptr to a function that expects the
     * rrc_SRB_InformationSetupList2 type.  Lint is uncomfortable with this
     * cast, so we must reassure it. 
     */
   
    
    while((srb_setup_ptr->n > srb_cnt) && (srb_cnt < UE_MAX_SRB_SETUP)
		&&(ret_status == SUCCESS))
    {
      /* Check to see if the RB ID is there ... */
      if(srb_setup_ptr->elem[srb_cnt].m.rb_IdentityPresent)
      {
        rb_id = srb_setup_ptr->elem[srb_cnt].rb_Identity;
      }
      
      /*
       * ... if not, then start with the first SRB and get the next SRB ID
       * each time one is not included in the IE.
       */
      else
      {
        /* Get the next SRB, note this increments to 1 the first time */
        rb_id++;
      }
  
      /* Save off the RB Mapping info for each SRB */
      if(get_srb_info_to_setup(&srb_setup_ptr->elem[srb_cnt], 
      (rrc_SRB_InformationSetupList2* )srb_setup_ptr, rb_id)
         == FAILURE)
      {
        ret_status = FAILURE;
      }
      
 
      srb_cnt++;
    } /* end SRB setup */
  
    /* Get the RAB setup list if present */
    if ((ret_status == SUCCESS) &&( msg_ptr->specificationMode.u.preconfiguration.m.rab_InfoPresent))
    {
      while((ret_status == SUCCESS) && (rab_setup_ptr.elem != NULL)
             && (rab_setup_ptr.n > rab_cnt) && (rab_cnt < MAX_RAB_TO_SETUP))
      {
        rb_cnt =0;
        rb_setup_ptr  = &rab_setup_ptr.elem[rab_cnt].rb_InformationSetupList;
        
      
        
        while((rb_setup_ptr->n > rb_cnt) && (rb_cnt < MAX_RB_PER_RAB))
        {
          if(get_rb_info_to_setup(&rb_setup_ptr->elem[rb_cnt], 
  #ifdef FEATURE_UMTS_PDCP
                                  rab_setup_ptr.elem[rab_cnt].rab_Info.cn_DomainIdentity,
  #endif /* FEATURE_UMTS_PDCP */
                                  rb_setup_ptr) == FAILURE)
          {
            ret_status = FAILURE;
          }
         
          rb_cnt++;
        } /* end RB per RAB setup */
  
      
        rab_cnt++;
      } /* end rab setup */
    
      if(rab_setup_ptr.elem !=NULL)
      {
        rrc_free(rab_setup_ptr.elem);
      }
    }
    if ((ret_status == SUCCESS) && (FAILURE == rrcllc_validate_rb_mapping_info()) )
    {
      ret_status = FAILURE;
    }
  
    /* Get the Common Uplink Transport Channel information */
    if((ret_status == SUCCESS) && (get_ul_info_common_for_all_trch(ul_common_trans_ch_info_ptr,
                                       ordered_config_ptr->rrc_state_indicator))
       == FAILURE)
    {
      ret_status = FAILURE;
    }
    
    /* Do the processing for Uplink added/reconfigured TrCH, Compute
     * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
     * (for Cell FACH state), this check for state needs to be re-examined
     */
    idx = 0;
    
  
    /* Save info for each additional Transport Channel */
    while((ret_status == SUCCESS) &&
		(idx <= UE_MAX_TRCH) && (ul_trch_add_reconfig_ptr->n > idx))
    {
      if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
      {
        ret_status = FAILURE;
      }
      
      /* get next TrCH Info */
      idx++;
      
    } /* end while */
  
    /* Check to make sure UL TFS count is within UE Capabilities */
    if((ret_status == SUCCESS) && (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      ret_status = FAILURE;
    }  
    
    /* Calculate the UL TFCS */
    compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
    
    /* There is no scope for TFC subset IE in default configurations as of now.
       Code is written keeping future scope in view 
       Presently default configurations we support map to SIB16  structures
       which is same for Rel99 & Rel5.
       "ul_common_trans_ch_info_ptr" is same for complete or default config */
    if((ret_status == SUCCESS) && (ul_common_trans_ch_info_ptr != NULL))
    {
      if(RRC_MSG_COMMON_BITMASK_IE_PTR(ul_common_trans_ch_info_ptr,rrc_UL_CommonTransChInfo,tfc_Subset))
      { 
        if(rrcllc_update_oc_with_tfc_subset(ul_common_trans_ch_info_ptr, MSG_REL99) == FAILURE)
        { 
          ret_status = FAILURE;
        } 
      } 
    }

      /* Get the Common Downlink Transport Channel information */
    if((ret_status == SUCCESS) && 
		(get_dl_info_common_for_all_trch(dl_common_trans_ch_info_ptr,
                                       ul_common_trans_ch_info_ptr, ordered_config_ptr->rrc_state_indicator))
       == FAILURE)
    {
      ret_status = FAILURE;
    }
  
    /* Get the DL Added or Reconfigured Transport Channel information */
    idx = 0;
    
    
    /* Save info for each additional Transport Channel */
    while((ret_status == SUCCESS) &&(idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL && (dl_trch_add_reconfig_ptr->n > idx))
    {
      if(get_dl_added_reconfig_trch(&dl_trch_add_reconfig_ptr->elem[idx],
                                    ul_trch_add_reconfig_ptr,
                                    FALSE) == FAILURE)
      {
        ret_status = FAILURE;
      }
      
      /* get next TrCH Info */
      idx++;
     
    } /* end while */
         

  }
  else
  {

    if((ret_status == SUCCESS) && 
		(rrcllc_srb5_ho_info(rbs_r5_ptr) == FAILURE ))
    {
        ret_status = FAILURE;
    }
  }
  /* Check to make sure DL TFS count is within UE Capabilities */
  if((ret_status == SUCCESS) && (rrcllc_check_dl_tfs_cnt() == FAILURE))
  {
    ret_status = FAILURE;
  }
  
  if((ret_status == SUCCESS) && (get_ul_dpch_info(&ul_dpch_info) == FAILURE))
  {
    ret_status = FAILURE;
  }
  
  /* Init DL Common Info to Timing Maintained */
  rrcllc_init_dl_common_info(ordered_config_ptr);

  /* All handover to UTRAN are considered HHO. */
  ordered_config_ptr->is_hho = TRUE;

  if((ret_status == SUCCESS) &&
  	(get_dl_info_common_for_all_rl(&dl_common_info,
                                   &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                   &ordered_config_ptr->l1_dl_cctrch_parms,
                                   &ordered_config_ptr->l1_dl_ctfc_parms))
     == FAILURE)
  {
    ret_status = FAILURE;
  }
  
  if(ret_status == SUCCESS)
  	{
  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms);
  	}
  /* Get the DL information for each Radio Link */
  /* Initialize the loop variables */
  idx = 0;
  
  while ((ret_status == SUCCESS)&& (idx < UE_MAX_RL) && (dl_rl_ptr.n > idx) )
  {
    status = get_dl_info_for_each_rl(&dl_rl_ptr.elem[idx],
                                     &ordered_config_ptr->l1_dl_chan_parms,
                                     idx,
                                     TRUE);
    if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
    {
      ret_status = FAILURE;
    }
    else if(status == RRCLLCOC_DL_INFO_PER_RL_IGNORED)
    {
      break;
    }
    else /* status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS */
    {
      idx++;
      
    }
  } /* end loop of all Radio links */

  /* Save off the number of Radio links in ordered config */
  if((ret_status == SUCCESS) && (status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS))
  {
    ordered_config_ptr->l1_dl_chan_parms.num_rl = (uint16)idx;
  }

  if(ret_status == SUCCESS)
    {
    /* Update the timers and constants in ordered config */
    rrcllc_get_timers_and_const_in_conn_mode_for_handover();
  #ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status; 
  #endif/*FEATURE_VOC_AMR_WB*/
    
    rrcllc_adjust_tb_size_handover_to_utran();
    }
 
   rrcllc_handover_to_utran_free_mem(ul_dpch_info, dl_common_info, dl_rl_ptr);
  	
  return ret_status;

}
/*====================================================================
FUNCTION: rrcllc_handover_to_utran_ie_r6()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Handover to UTRAN Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_handover_to_utran_ie_r6
(
  rrc_HandoverToUTRANCommand_r6 *msg_ptr
)
{
  uecomdef_status_e_type          status = SUCCESS;

  ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;

  /* GET URNTI and Update mac DL and UL info */
  rrc_translate_urnti_short(&msg_ptr->handoverToUTRANCommand_r6.new_U_RNTI,
                            &ordered_config_ptr->mac_ul_parms.rnti_info.urnti);
  ordered_config_ptr->mac_dl_parms.rnti_info.urnti = 
    ordered_config_ptr->mac_ul_parms.rnti_info.urnti;
  ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power.  MP for ho to utran */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(TRUE,
                                                         msg_ptr->handoverToUTRANCommand_r6.maxAllowedUL_TX_Power);
  }

  if ((SUCCESS == status) && 
     RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->handoverToUTRANCommand_r6.specificationMode,
     rrc_HandoverToUTRANCommand_r6_IEs_specificationMode_complete))
  {

    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r6(
      TRUE,
      &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.ul_AddReconfTransChInfoList,
      FALSE,
      NULL);
    
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(
        &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.dl_AddReconfTransChInfoList, NULL);
    }
    
    /* Get the SRB setup list if present */
    if (SUCCESS == status)
    {
      status =  rrcllc_process_srb_info_setup_list_r6(
        TRUE,
        &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.srb_InformationSetupList);
    }

    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }

    /* Get the RAB setup list if present */
    if (SUCCESS == status)
    {
      status = rrcllc_process_rab_info_setup_list_r6(
        (msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.m.rab_InformationSetupListPresent),
        &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.rab_InformationSetupList);
    }

    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(
       TRUE, &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.ul_CommonTransChInfo);
    }

    if(SUCCESS == status)
    {
      status = rrcllc_store_ul_add_reconf_trch_info_list_r6(
          TRUE,
          &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.ul_AddReconfTransChInfoList);
    }

    /* Calculate the UL TFCS */
    compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

    if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.ul_CommonTransChInfo,rrc_UL_CommonTransChInfo,tfc_Subset))
    { 
      status = rrcllc_update_oc_with_tfc_subset(
        &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.ul_CommonTransChInfo, MSG_REL6);
    } 


    if((SUCCESS == status ) &&
      (msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.ul_CommonTransChInfo.m.tfc_SubsetListPresent))
    {
      if(rrcllc_update_oc_with_tfc_subset_list(
          &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.ul_CommonTransChInfo) == FAILURE)
      {
        status= FAILURE;
      }
    }


    /* Get the Common Downlink Transport Channel information */
    if(SUCCESS == status)
    {
      status = get_dl_info_common_for_all_trch_r5(&msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.dl_CommonTransChInfo,
                                                  &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.ul_CommonTransChInfo,
                                                  ordered_config_ptr->rrc_state_indicator);
    }

    if(SUCCESS == status)
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r6(
        TRUE,
        &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.ul_AddReconfTransChInfoList);
    } /* If state is Cell_DCH */   


    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_ul_dpch_info_r6(
        TRUE,
        &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.ul_DPCH_Info, rrc_RRC_StateIndicator_cell_DCH);
    }

    if (SUCCESS == status) 
    {
      status = rrcllcpcie_is_hho_r6(
        TRUE, 
        &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.dl_InformationPerRL_List,
        rrc_RRC_StateIndicator_cell_DCH);
    }

    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_dl_common_info_r6(
        TRUE, 
        &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.dl_CommonInformation,
        rrc_RRC_StateIndicator_cell_DCH);
    }
    
    if (SUCCESS == status)
    {
      /* update R99, HS and EUL related variables */
      status = rrcllcpcie_process_dl_info_per_rl_list_r6(
        TRUE, 
        &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.dl_InformationPerRL_List,
        rrc_RRC_StateIndicator_cell_DCH
        ,NULL
        );
    }

    if (msg_ptr->m.v6b0NonCriticalExtensionsPresent) 
    {
      if (msg_ptr->v6b0NonCriticalExtensions.handoverToUTRANCommand_v6b0ext.m.ue_hspa_identitiesPresent) 
      {
        if (rrcllc_update_hrnti_in_oc(
          (msg_ptr->v6b0NonCriticalExtensions.handoverToUTRANCommand_v6b0ext.ue_hspa_identities.m. 
           new_H_RNTIPresent), 
          &msg_ptr->v6b0NonCriticalExtensions.handoverToUTRANCommand_v6b0ext.ue_hspa_identities.new_H_RNTI,
          rrc_RRC_StateIndicator_cell_DCH) == FAILURE)
        {
          return FAILURE;
        }

        /* Get the Primary E-RNTI */
        rrcllc_update_ernti_in_oc(
          (msg_ptr->v6b0NonCriticalExtensions.handoverToUTRANCommand_v6b0ext.ue_hspa_identities.m.
           newPrimary_E_RNTIPresent),
          msg_ptr->v6b0NonCriticalExtensions.handoverToUTRANCommand_v6b0ext.ue_hspa_identities.newPrimary_E_RNTI,
          TRUE,
          rrc_RRC_StateIndicator_cell_DCH);

        /* Get the Secondary E-RNTI */
        rrcllc_update_ernti_in_oc(
          (msg_ptr->v6b0NonCriticalExtensions.handoverToUTRANCommand_v6b0ext.ue_hspa_identities.m. 
           newSecondary_E_RNTIPresent),
          msg_ptr->v6b0NonCriticalExtensions.handoverToUTRANCommand_v6b0ext.ue_hspa_identities.newSecondary_E_RNTI,
          FALSE,
          rrc_RRC_StateIndicator_cell_DCH);

      }
    }

    /* process UL-E_DCH Information */
    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_ul_e_dch_information(
        msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.m.ul_EDCH_InformationPresent,
        &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.ul_EDCH_Information,
        rrc_RRC_StateIndicator_cell_DCH);
    }


  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
    if(SUCCESS == status)
    { 
      status = rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(rrc_RRC_StateIndicator_cell_DCH);
    }

    /* Get HS Information */
    /* SET Action Variable by calling HSDPA action table */
    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params(
        msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.m.dl_HSPDSCH_InformationPresent,
        &msg_ptr->handoverToUTRANCommand_r6.specificationMode.u.complete.dl_HSPDSCH_Information,
        FALSE,
        rrc_RRC_StateIndicator_cell_DCH);
    }

  }
  else if ((SUCCESS == status) && 
           msg_ptr->handoverToUTRANCommand_r6.specificationMode.t == 
           T_rrc_HandoverToUTRANCommand_r6_IEs_specificationMode_preconfiguration)
  {
    WRRC_MSG0_HIGH("RRCEUL: rcvd R6 HO with preconfig");
    status = rrcllc_handover_to_utran_process_preconfig_r6(&msg_ptr->handoverToUTRANCommand_r6);
  }
#ifdef FEATURE_VOC_AMR_WB
  ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/


  /* Update the timers and constants in ordered config */
  rrcllc_get_timers_and_const_in_conn_mode_for_handover();

  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(rrc_RRC_StateIndicator_cell_DCH)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      status = FAILURE;
    }
  }
  
  return (status);
}


/*====================================================================
FUNCTION: FIND_TRCH_ID_IN_CONFIG_TRCH_LIST_R7

DESCRIPTION:

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
boolean find_trch_id_in_config_trch_list_r7
(
  rrc_DL_AddReconfTransChInfoList_r7 * dl_trch_add_reconfig_ptr,
  tr_ch_id_type trch_id
)
{
  uint32 idx = 0;
  boolean found = FALSE;
  
  while((idx <= UE_MAX_TRCH) && (dl_trch_add_reconfig_ptr->n > idx))
  {
    if (dl_trch_add_reconfig_ptr->elem[idx].dl_TransportChannelType.t == T_rrc_DL_TrCH_TypeId1_r5_dch)
    {
      if (dl_trch_add_reconfig_ptr->elem[idx].dl_TransportChannelType.u.dch == trch_id)
      {
        found = TRUE;
        break;
      }
    }
    idx++;
  }
  
  return found;
}

/*====================================================================
FUNCTION: rrcllc_copy_toc_ptr_to_oc()

DESCRIPTION:
  

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static ordered_config_type    * rrcllc_copy_toc_ptr_to_oc(void)
{

    ordered_config_type              *tmp_config_ptr = NULL;
  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
  meant for use when we do transition to Cell_DCH state.  If that's the case, store
  it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;

    return tmp_config_ptr;
  }

return NULL;
}

/*====================================================================
FUNCTION: rrcllc_restore_oc_ptr()

DESCRIPTION:
  

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static void rrcllc_restore_oc_ptr(ordered_config_type   *tmp_config_ptr)
{

    if(tmp_config_ptr)
    {
      ordered_config_ptr = tmp_config_ptr;
      tmp_config_ptr = NULL;
    }
  

}

/*====================================================================
FUNCTION: rrcllc_handover_to_utran_process_preconfig_r7()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Handover to UTRAN Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_handover_to_utran_process_preconfig_r7
(
  rrc_HandoverToUTRANCommand_r7_IEs *msg_ptr
)
{
  /* Local copy of SIB16 pointer.  In the case of a default configuration,
   * this actually points to data for the specified default configuration,
   * not the actual SIB16 data.  That doesn't matter to us, though.  We also
   * declare some convenience pointers here to shorten the names of the 
   * SIB16 members later on. */
  struct rrc_SysInfoType16            *sib16_ptr = NULL;
  rrc_PredefinedRB_Configuration      *predef_rb = NULL;
  rrc_PreDefPhyChConfiguration        *predef_phych = NULL;

  rrc_RAB_InformationSetupList  tmp_rab_setup_list;
  rrc_UL_DPCH_Info                ul_dpch_info;
  rrc_DL_CommonInformation        dl_common_info;
  rrc_DL_InformationPerRL_List    dl_rl_ptr = {0};
  uecomdef_status_e_type ret_status = SUCCESS;

  struct rrc_RadioBearerSetup_r5_IEs *rbs_r5_ptr = NULL;
  uint32 default_config_id = RRC_DEF_CONFIG_INVALID;
  void *rbs_ptr = NULL;

  rrcllcoc_dl_info_per_rl_status_e_type status =
      RRCLLCOC_DL_INFO_PER_RL_IGNORED; /* Return status from DL Info per RL processing. */
  /* Local counters, return values, and other simple scalar types. */
  uint8      idx     = 0; /* Loop index */

  rrc_DL_InformationPerRL_ListPostFDD  * dl_rl_post_ptr;
  /* Get a pointer to the SIB16 data and set up some shorter aliases for
   * the unwieldy member data names. */

  tmp_rab_setup_list.elem = NULL;
  tmp_rab_setup_list.n = 0;
  memset((void *)&ul_dpch_info, 0, sizeof(rrc_UL_DPCH_Info));
  memset((void *)&dl_common_info, 0, sizeof(rrc_DL_CommonInformation));

  rrcllc_handover_to_utran_alloc_mem(&ul_dpch_info, &dl_common_info, &dl_rl_ptr);

  if((rbs_ptr = rrciho_get_rbs_ptr(&default_config_id)) != NULL)
  {
    rbs_r5_ptr = (rrc_RadioBearerSetup_r5_IEs *) rbs_ptr;
  }
  else
  {
    sib16_ptr = rrciho_get_sib16_ptr(); 
    if(sib16_ptr == NULL)
    {
      WRRC_MSG0_ERROR("Failed to get SIB16 information.");
      ret_status = FAILURE;
    }
    else
    {
      predef_rb =
        &sib16_ptr->preDefinedRadioConfiguration.predefinedRB_Configuration;
    
      predef_phych =
        &sib16_ptr->preDefinedRadioConfiguration.preDefPhyChConfiguration;
    }
  


    if ((ret_status == SUCCESS) &&(msg_ptr->specificationMode.u.preconfiguration.m.rab_InfoPresent))
    {
      tmp_rab_setup_list.elem = rrc_malloc(sizeof(rrc_RAB_InformationSetup));
      (void) rrcllc_get_predefined_rab_info(msg_ptr->specificationMode.u.preconfiguration.rab_Info,
                                     predef_rb,
                                     &tmp_rab_setup_list);
  
    }
    else
    {  
      WRRC_MSG0_ERROR("predef_rb is NULL.");
      ret_status = FAILURE;
    }  
  }
  if((ret_status == SUCCESS) && 
  	(msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.t == 
     T_rrc_HandoverToUTRANCommand_r7_IEs_modeSpecificInfo_fdd))
  { 

    if(rbs_r5_ptr != NULL)
    {
      if((RRC_MSG_COMMON_BITMASK_IE_PTR(rbs_r5_ptr,rrc_RadioBearerSetup_r5_IEs,ul_ChannelRequirement))
        &&RRC_CHECK_COMMON_MSG_TYPE(rbs_r5_ptr->ul_ChannelRequirement,
        rrc_UL_ChannelRequirement_r5_ul_DPCH_Info ))
      {
        if (rrcllc_get_predefined_ul_dpch_info_srb5(&ul_dpch_info,
                                                &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                                fdd.ul_DPCH_Info,
                                                rbs_r5_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
        {
          ret_status = FAILURE;
        }
		if(ret_status == SUCCESS)
			{
        (void)rrcllc_get_predefined_dl_common_info_srb5(&dl_common_info,
                                                  &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                                  fdd.dl_CommonInformationPost,
                                                  &rbs_r5_ptr->dl_CommonInformation.dl_DPCH_InfoCommon,
                                                  &msg_ptr->new_U_RNTI);
			}
      }
      else
      {
        WRRC_MSG0_ERROR("UL DPCH info not present in encoded rb-setup not present ");
        ret_status = FAILURE;
      }
    }
    else
    if(ret_status == SUCCESS)
    {
      (void) rrcllc_get_predefined_ul_dpch_info(&ul_dpch_info,
                                               &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                               fdd.ul_DPCH_Info,
                                               predef_phych);
 
      (void) rrcllc_get_predefined_dl_common_info(&dl_common_info,
                                                 &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                                 fdd.dl_CommonInformationPost,
                                                 predef_phych,
                                                 &msg_ptr->new_U_RNTI);
    }
	if(ret_status == SUCCESS)
		{
    dl_rl_post_ptr= &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.fdd.dl_InformationPerRL_List;
    dl_rl_ptr.n =1;

	
    memset(&dl_rl_ptr.elem[0].m,0,sizeof(dl_rl_ptr.elem[0].m));
    dl_rl_ptr.elem[0].m.dl_DPCH_InfoPerRLPresent = 1;

	
    memset(&dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd->m,0,
		sizeof(dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd->m));
		
    dl_rl_ptr.elem[0].modeSpecificInfo.t =
      T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd;
    dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info =
      dl_rl_post_ptr->elem[0].primaryCPICH_Info;
	memset(&dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->m,0,sizeof(dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->m));
  
    dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.t =
      T_rrc_DL_DPCH_InfoPerRL_fdd;
    dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->pCPICH_UsageForChannelEst =
      dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.pCPICH_UsageForChannelEst;
    dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->pCPICH_UsageForChannelEst =
       rrc_PCPICH_UsageForChannelEst_mayBeUsed;
    if(NULL != dl_common_info.modeSpecificInfo.u.fdd)
    {
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dpch_FrameOffset = 
         ((dl_common_info.modeSpecificInfo.u.fdd->defaultDPCH_OffsetValue * 512)
           % 38400) / 256; /* 25.331, clause 8.3.5.1.2 */
    }
    
    dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.n = 1;
    dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.elem[0] =
      dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.dl_ChannelisationCode;
 
    dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->tpc_CombinationIndex =
      dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.tpc_CombinationIndex;
    if( dl_rl_post_ptr->n > 1)
    {
      WRRC_MSG0_ERROR("Single Pri-SCR supported for GtoW HO");
    }
		}
  }
  else
  {
    WRRC_MSG0_ERROR("Only FDD mode supported in Handover to UTRAN Command");
    ret_status = FAILURE;
  }
  if(rbs_r5_ptr == NULL)
  {
   if((ret_status == SUCCESS) && (sib16_ptr != NULL) &&
   	(rrcllc_preconfig_sib16_ho_info(sib16_ptr,&tmp_rab_setup_list) == FAILURE ))
   {
     ret_status = FAILURE;
   }
  }
  else
  {
    if((ret_status == SUCCESS) &&(rrcllc_srb5_ho_info(rbs_r5_ptr) == FAILURE ))
    {
      ret_status = FAILURE;
    }
  }

  if (msg_ptr->specificationMode.u.preconfiguration.m.rab_InfoPresent)
  {
    if(tmp_rab_setup_list.elem !=NULL)
    {
      rrc_free(tmp_rab_setup_list.elem);
    }
  }
  /* Check to make sure DL TFS count is within UE Capabilities */
  if((ret_status == SUCCESS) && (rrcllc_check_dl_tfs_cnt() == FAILURE))
  {
    ret_status = FAILURE;
  }
  
  if((ret_status == SUCCESS) && (get_ul_dpch_info(&ul_dpch_info) == FAILURE))
  {
    ret_status = FAILURE;
  }
  
  /* Init DL Common Info to Timing Maintained */
  rrcllc_init_dl_common_info(ordered_config_ptr);

  /* All handover to UTRAN are considered HHO. */
  ordered_config_ptr->is_hho = TRUE;

  if((ret_status == SUCCESS) && (get_dl_info_common_for_all_rl(&dl_common_info,
                                   &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                   &ordered_config_ptr->l1_dl_cctrch_parms,
                                   &ordered_config_ptr->l1_dl_ctfc_parms))
     == FAILURE)
  {
    ret_status = FAILURE;
  }
  
  if(ret_status == SUCCESS)
  	{
  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms);
  
  /* Get the DL information for each Radio Link */
  /* Initialize the loop variables */
  	}
  idx = 0;
  
  while ((ret_status == SUCCESS) && (idx < UE_MAX_RL) && (dl_rl_ptr.n > idx) )
  {
    status = get_dl_info_for_each_rl(&dl_rl_ptr.elem[idx],
                                     &ordered_config_ptr->l1_dl_chan_parms,
                                     idx,
                                     TRUE);
    if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
    {
      ret_status = FAILURE;
    }
    else if(status == RRCLLCOC_DL_INFO_PER_RL_IGNORED)
    {
      break;
    }
    else /* status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS */
    {
      idx++;
      
    }
  } /* end loop of all Radio links */


  /* Save off the number of Radio links in ordered config */
  if(status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS)
  {
    ordered_config_ptr->l1_dl_chan_parms.num_rl = (uint16)idx;
  }
  if(ret_status == SUCCESS)
  {
  /* Update the timers and constants in ordered config */
    rrcllc_get_timers_and_const_in_conn_mode_for_handover();
#ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status; 
#endif/*FEATURE_VOC_AMR_WB*/
  
    for (idx=0; idx<UE_MAX_TRCH; idx++)
    {
      /* The number of logical channel mapped to this transport channel 
         increases from 1 to 2. Needs to adjsut the tb_szie to
         reflect the adding of the MAC header.                         */
      if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
          (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
           ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
      {
        WRRC_MSG0_HIGH("Clean TB size adjust flag in HandOverToUTRAN");
        /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
      }
      else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
      {
        /* Since the activated transport channels are sorted before stored in
             the memory, break the looping after reaching the 1st invalid block.  */
        break;
      }
    }
  }
  rrcllc_handover_to_utran_free_mem(ul_dpch_info, dl_common_info, dl_rl_ptr);
  return ret_status;

}
/*====================================================================
FUNCTION: rrcllc_handover_to_utran_ie_r7()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Handover to UTRAN Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
static uecomdef_status_e_type rrcllc_handover_to_utran_ie_r7
(
  rrc_HandoverToUTRANCommand_r7 *msg_ptr
)
{
  uecomdef_status_e_type          status = SUCCESS;
 rrc_HandoverToUTRANCommand_r7_IEs * ho_utran_r7_ptr;
  ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;

  ho_utran_r7_ptr = &msg_ptr->handoverToUTRANCommand_r7;
  /* GET URNTI and Update mac DL and UL info */
  rrc_translate_urnti_short(&ho_utran_r7_ptr->new_U_RNTI,
                            &ordered_config_ptr->mac_ul_parms.rnti_info.urnti);
  ordered_config_ptr->mac_dl_parms.rnti_info.urnti = 
    ordered_config_ptr->mac_ul_parms.rnti_info.urnti;
  ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power.  MP for ho to utran */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(TRUE,
                                                         ho_utran_r7_ptr->maxAllowedUL_TX_Power);
  }

  if ((SUCCESS == status) && 
     RRC_CHECK_COMMON_MSG_TYPE(ho_utran_r7_ptr->specificationMode,
     rrc_HandoverToUTRANCommand_r7_IEs_specificationMode_complete))
  {

    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r7(
      TRUE,
      &ho_utran_r7_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList,
      FALSE,
      NULL);
    
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(
        &ho_utran_r7_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList, NULL);
    }
    
    /* Get the SRB setup list if present */
    if (SUCCESS == status)
    {
      status =  rrcllc_process_srb_info_setup_list_r7(
        TRUE,
        &ho_utran_r7_ptr->specificationMode.u.complete.srb_InformationSetupList);
    }



    /* Get the RAB setup list if present */
    if (SUCCESS == status)
    {
      status = rrcllc_process_rab_info_setup_list_r7(
        (ho_utran_r7_ptr->specificationMode.u.complete.m.rab_InformationSetupListPresent),
        &ho_utran_r7_ptr->specificationMode.u.complete.rab_InformationSetupList);
    }

    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }
    
    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(
       TRUE, &ho_utran_r7_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }

    if(SUCCESS == status)
    {
      status = rrcllc_store_ul_add_reconf_trch_info_list_r7(
          TRUE,
          &ho_utran_r7_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    }

    /* Calculate the UL TFCS */
    compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);


    if(RRC_MSG_COMMON_BITMASK_IE(ho_utran_r7_ptr->specificationMode.u.complete.ul_CommonTransChInfo, 
       rrc_UL_CommonTransChInfo_r4,tfc_Subset))
    { 
      status = rrcllc_update_oc_with_tfc_subset(
        &ho_utran_r7_ptr->specificationMode.u.complete.ul_CommonTransChInfo, MSG_REL6);
    } 

    if((SUCCESS == status ) &&
      (RRC_MSG_COMMON_BITMASK_IE_TYPE2(ho_utran_r7_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
      tfc_SubsetList)))
    {
      if(rrcllc_update_oc_with_tfc_subset_list(
          &ho_utran_r7_ptr->specificationMode.u.complete.ul_CommonTransChInfo) == FAILURE)
      {
        status= FAILURE;
      }
    }

    /* Get the Common Downlink Transport Channel information */
    if(SUCCESS == status)
    {
      status = get_dl_info_common_for_all_trch_r5(&ho_utran_r7_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
                                                  &ho_utran_r7_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
                                                  ordered_config_ptr->rrc_state_indicator);
    }

    if(SUCCESS == status)
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r7(
        TRUE,
        &ho_utran_r7_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &ho_utran_r7_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    } /* If state is Cell_DCH */   


    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_ul_dpch_info_r7(
        TRUE,
        &ho_utran_r7_ptr->specificationMode.u.complete.ul_DPCH_Info, rrc_RRC_StateIndicator_cell_DCH);
    }

    if (SUCCESS == status) 
    {
      status = rrcllcpcie_is_hho_r7(
        TRUE, 
        &ho_utran_r7_ptr->specificationMode.u.complete.dl_InformationPerRL_List,
        rrc_RRC_StateIndicator_cell_DCH);
    }

    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_dl_common_info_r7(
        TRUE, 
        &ho_utran_r7_ptr->specificationMode.u.complete.dl_CommonInformation,
        rrc_RRC_StateIndicator_cell_DCH);
    }
    
    if (SUCCESS == status)
    {
      /* update R99, HS and EUL related variables */
      status = rrcllcpcie_process_dl_info_per_rl_list_r7(
        TRUE, 
        &ho_utran_r7_ptr->specificationMode.u.complete.dl_InformationPerRL_List,
        rrc_RRC_StateIndicator_cell_DCH
        );
    }

    if (rrcllc_update_hrnti_in_oc(
        RRC_MSG_COMMON_BITMASK_IE_PTR(ho_utran_r7_ptr,rrc_HandoverToUTRANCommand_r7_IEs,new_H_RNTI), 
        &ho_utran_r7_ptr->new_H_RNTI,
        rrc_RRC_StateIndicator_cell_DCH) == FAILURE)
    {
      return FAILURE;
    }

    /* Get the Primary E-RNTI */
    rrcllc_update_ernti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(ho_utran_r7_ptr,rrc_HandoverToUTRANCommand_r7_IEs,
      newPrimary_E_RNTI),
      ho_utran_r7_ptr->newPrimary_E_RNTI,
      TRUE,
      rrc_RRC_StateIndicator_cell_DCH);

    /* Get the Secondary E-RNTI */
    rrcllc_update_ernti_in_oc(
       RRC_MSG_COMMON_BITMASK_IE_PTR(ho_utran_r7_ptr,
       rrc_HandoverToUTRANCommand_r7_IEs,newSecondary_E_RNTI),
      ho_utran_r7_ptr->newSecondary_E_RNTI,
      FALSE,
      rrc_RRC_StateIndicator_cell_DCH);

    /* process UL-E_DCH Information */
    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_ul_e_dch_information_r7(
        (ho_utran_r7_ptr->specificationMode.u.complete.m.ul_EDCH_InformationPresent),
        &ho_utran_r7_ptr->specificationMode.u.complete.ul_EDCH_Information,
        rrc_RRC_StateIndicator_cell_DCH);
    }

    /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
       update mac_eul_action and l1_e_req_mask as per computed value of
       e_dch_transmission variable
     */
    if(SUCCESS == status)
    { 
      status= rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(rrc_RRC_StateIndicator_cell_DCH);
    }

    /* Get HS Information */
    /* SET Action Variable by calling HSDPA action table */
    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r7(
        ho_utran_r7_ptr->specificationMode.u.complete.m.dl_HSPDSCH_InformationPresent,
        &ho_utran_r7_ptr->specificationMode.u.complete.dl_HSPDSCH_Information,
        FALSE,
        rrc_RRC_StateIndicator_cell_DCH);
    }


  }
  else if ((SUCCESS == status) && 
           RRC_CHECK_COMMON_MSG_TYPE(ho_utran_r7_ptr->specificationMode,
           rrc_HandoverToUTRANCommand_r7_IEs_specificationMode_preconfiguration))
  {
    WRRC_MSG0_HIGH("RRCEUL: rcvd R7 HO with preconfig");
    status = rrcllc_handover_to_utran_process_preconfig_r7(ho_utran_r7_ptr);
  }
  
#ifdef FEATURE_VOC_AMR_WB
  ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/

   
  if((SUCCESS == status) && (msg_ptr->m.v780NonCriticalExtensionsPresent)
   &&(msg_ptr->v780NonCriticalExtensions.handoverToUTRANCommand_v780ext.m.
   hs_DSCH_TBSizeTablePresent ))
  {
    rrcllcpcie_update_hs_tfri_table_type(TRUE);
  }
  else
  {
     /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
    if ((ho_utran_r7_ptr->specificationMode.u.complete.m.dl_HSPDSCH_InformationPresent)
        || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
        || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
       )
    {
      rrcllcpcie_update_hs_tfri_table_type(FALSE);
    }
  }

  /* Update the timers and constants in ordered config */
  rrcllc_get_timers_and_const_in_conn_mode_for_handover();

  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(rrc_RRC_StateIndicator_cell_DCH)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      status = FAILURE;
    }
  }
  
  return (status);
}
/*====================================================================
FUNCTION: rrcllc_trch_reconfig_ie_r7()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Release 6 Transport Channel Reconfiguration Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_trch_reconfig_ie_r7
(
  rrc_TransportChannelReconfiguration_r7 * trch_reconfig_r7_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_TransportChannelReconfiguration_r7_IEs *msg_ptr;
  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r7  * dl_trch_add_reconfig_ptr = NULL;

  ordered_config_type              *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;
  msg_ptr = &trch_reconfig_r7_ota->transportChannelReconfiguration_r7;
  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  rrcllc_init_before_msg_processing();

  if(RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,new_DSCH_RNTI) )
  {
    WRRC_MSG0_ERROR("RRCHSPA+: new_DSCH_RNTI received, invalid paramters in FDD mode ");
    return FAILURE;
  }

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = (RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,delayRestrictionFlag) !=0);
#endif
   
  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_TCR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
 status = rrcllc_update_urnti_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,new_U_RNTI),
    &msg_ptr->new_U_RNTI,
    msg_ptr->rrc_StateIndicator);

   rrcllc_update_crnti_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,new_C_RNTI),
    msg_ptr->new_C_RNTI, 
    msg_ptr->rrc_StateIndicator);

   if (SUCCESS == status)
   {
     status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
   }

  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
    RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,utran_DRX_CycleLengthCoeff),
                              &msg_ptr->utran_DRX_CycleLengthCoeff
                              );
  }


  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(
      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
       RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }



  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
     /* ----------- For FACH, PCH, URA PCH states  the below contents will now-------------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr ==-----------------------------------*/

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
    * and count) and rearrange the info by sorting transport channel list
    * based on TrCH ID.
    */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList,
      FALSE,
      NULL);
  
  
    if ( RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }
  
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(dl_trch_add_reconfig_ptr,
                                                                 NULL);
    }
  }


  /* Get the Common Uplink Transport Channel information */
  if (SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6(
     RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,ul_CommonTransChInfo),
     &msg_ptr->ul_CommonTransChInfo);
  }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined
    */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_ul_add_reconf_trch_info_list_r7(
       RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,ul_AddReconfTransChInfoList),
       &msg_ptr->ul_AddReconfTransChInfoList);
  
    /* Calculate the UL TFCS */
    if((SUCCESS == status) &&
       (RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
    if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
		rrc_UL_CommonTransChInfo_r4,tfc_Subset))
    {
      if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL7) == FAILURE)
      {
        status = FAILURE;
      }
    if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->ul_CommonTransChInfo,
		tfc_SubsetList)))
    {
      if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
      {
        status = FAILURE;
      }
    }
    }

    } 
  } /* If state is Cell_DCH */
  
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
     
  rrcllc_restore_oc_ptr (tmp_config_ptr);


  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      status = FAILURE;
    }
  }


  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
  /* ----------- For FACH, PCH, URA PCH states  the below contents will now-------------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr ==-----------------------------------*/


  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) && (RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dl_CommonTransChInfo)))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator);
  }

  if((SUCCESS == status) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r7(
      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dl_AddReconfTransChInfoList),
      &msg_ptr->dl_AddReconfTransChInfoList,
      &msg_ptr->ul_AddReconfTransChInfoList);
  } /* If state is Cell_DCH */   

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);


  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch( 
      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,ul_DPCH_Info),
      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dl_CommonInformation), 
      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7(
      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r7(
      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r7(
      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r7(
      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,newPrimary_E_RNTI) ,
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,newSecondary_E_RNTI), 
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r7(
      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status= rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }


  if ((SUCCESS == status) &&    rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }



  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r7(
      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dl_HSPDSCH_Information),  
      &msg_ptr->dl_HSPDSCH_Information,
      (( RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,frequencyInfo) ) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(&msg_ptr->mimoParameters,
  msg_ptr->rrc_StateIndicator,
  ( RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,mimoParameters))
                                                ) == FAILURE)
  {
    status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_tcrc_r7(trch_reconfig_r7_ota);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
#else
  if( RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,mimoParameters)) 
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("RRCHSPA+: rrc_TransportChannelReconfiguration_r7_IEs_mimoParameters set to TRUE ");
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  if( RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,delayRestrictionFlag)) 
  {
       status = FAILURE;
     WRRC_MSG0_ERROR("RRCHSPA+: rrc_TransportChannelReconfiguration_r7_IEs_delayRestrictionFlag set to TRUE ");
  }
     
  /* Ignore the MBMS IEs */
  if( RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,mbms_PL_ServiceRestrictInfo)) 
  {
    status = FAILURE;
  } /* end MBMS IE check */

  if( RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,hs_scch_LessInfo)) 
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("RRCHSPA+: hs_scch_LessInfo not supported ");
  }

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }
  
  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if(RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,delayRestrictionFlag))
    {
      if(( RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dl_AddReconfTransChInfoList))
          ||  (RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,ul_AddReconfTransChInfoList))
      ) 
      {
        WRRC_MSG0_ERROR("Trch Ie touched bitmask , so Delay restriction cannot be applied");
      }
      else
      {
        rrcllc_update_delay_restriction(
         RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,activationTime),
         RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,delayRestrictionFlag),
         msg_ptr->activationTime,msg_ptr->rrc_StateIndicator);
      }
    }
  }

  if((SUCCESS == status) && (trch_reconfig_r7_ota->m.v780NonCriticalExtensionsPresent)
     &&(trch_reconfig_r7_ota->v780NonCriticalExtensions.transportChannelReconfiguration_v780ext.
        m.hs_DSCH_TBSizeTablePresent) )
  {
    rrcllcpcie_update_hs_tfri_table_type(TRUE);
  }
  else
  {
       /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
    if(RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dl_HSPDSCH_Information)
       || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
       || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
      )
    {
    rrcllcpcie_update_hs_tfri_table_type(FALSE);
  }
  }


  if (SUCCESS == status)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
    (RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dtx_drx_TimingInfo)),
         &msg_ptr->dtx_drx_Info,
    (RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,dtx_drx_Info)),
         msg_ptr->rrc_StateIndicator
    ) == FAILURE)
    {
       status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,new_H_RNTI));
  }


#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRBR_R7_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r7_IEs,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_DC_HSUPA
      if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
        FALSE)== FAILURE)
      {
        return FAILURE;
      }  
#endif /* FEATURE_WCDMA_DC_HSUPA */


  /* Got here, everything is okay */
  return (status);

}

/*====================================================================
FUNCTION: rrcllc_rb_setup_ie_r7()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Setup Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_setup_ie_r7
(
  rrc_RadioBearerSetup_r7 * rb_setup_r7_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_RadioBearerSetup_r7_IEs *msg_ptr;
  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r7 *dl_trch_add_reconfig_ptr = NULL;
  
  /* local DL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r7   *dl_trch_delete_ptr = NULL;
  
  ordered_config_type              *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;
  msg_ptr = &rb_setup_r7_ota->radioBearerSetup_r7;
  /* We're processing a reconfiguration message now, so set the
  reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;
  
  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
    
  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /* Ignore the Integrity Protection and Ciphering IEs */
  
  
 rrcllc_init_before_msg_processing();

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBE);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
 status = rrcllc_update_urnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,new_U_RNTI), 
    &msg_ptr->new_U_RNTI,
    msg_ptr->rrc_StateIndicator);
 

  rrcllc_update_crnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,new_C_RNTI),
    msg_ptr->new_C_RNTI, 
    msg_ptr->rrc_StateIndicator);

  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,utran_DRX_CycleLengthCoeff),
    &msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }


  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /* ----------- For FACH, PCH, URA PCH states  the below contents will now---------------
   -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr --------------------------------------*/

  if ((SUCCESS == status) && (RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
  	rrc_RadioBearerSetup_r7_IEs_specificationMode_complete)))
  {
    /* Call these functions ONLY in DCH state */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Here, update the transport channel info (only transport channel IDs 
      * and count) and rearrange the info by sorting transport channel list
      * based on TrCH ID.
      */
      status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r7(
        RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerSetup_r7_IEs),
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList,
        RRCRB_R6_UL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerSetup_r7_IEs),
        &msg_ptr->specificationMode.u.complete.ul_deletedTransChInfoList);


      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
      if (RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerSetup_r7_IEs))
      {
        dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
      }

      if (RRCRB_R6_DL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerSetup_r7_IEs))
      {
        dl_trch_delete_ptr = &msg_ptr->specificationMode.u.complete.dl_DeletedTransChInfoList;
      }

      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
      if (SUCCESS == status)
      {
        status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(
           dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
      }
    }

     /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);

    /* Get the SRB setup list if present */
    if (SUCCESS == status)
    {
      status =  rrcllc_process_srb_info_setup_list_r7(
        RRCRB_R6_SRB_INFO_SETUP_LIST_PRESENT(msg_ptr,rrc_RadioBearerSetup_r7_IEs), 
        &msg_ptr->specificationMode.u.complete.srb_InformationSetupList);
    }

    /* Get the RAB setup list if present */
    if (SUCCESS == status)
    {
      status = rrcllc_process_rab_info_setup_list_r7(
        RRCRB_R6_RAB_INFO_SETUP_LIST_PRESENT(msg_ptr, rrc_RadioBearerSetup_r7_IEs),
        &msg_ptr->specificationMode.u.complete.rab_InformationSetupList);
    }
   /* Get the RB reconfiguration list */
   
    if (SUCCESS == status)
    {
      status = rrcllc_process_rb_info_reconfig_list_r7(
        RRCRB_R6_RB_INFO_RECONFIG_LIST_PRESENT(msg_ptr, rrc_RadioBearerSetup_r7_IEs),
        &msg_ptr->specificationMode.u.complete.rb_InformationReconfigList);
    }
    if (SUCCESS == status)
    {
      status = rrcllc_process_rb_info_affected_list_r7(
        RRCRB_R6_RB_INFO_AFFECTED_LIST_PRESENT(msg_ptr, rrc_RadioBearerSetup_r7_IEs),
        &msg_ptr->specificationMode.u.complete.rb_InformationAffectedList);
    }

  if (SUCCESS == status) 
  {
    status = rrcllc_validate_rb_mapping_info();
  }


  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
     /* ----------- For FACH, PCH, URA PCH states  the below contents will now----------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr -------------------------------------*/

    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(
       RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerSetup_r7_IEs),
       &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined
    */
    if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
#ifdef FEATURE_VOC_AMR_WB
      ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/    

      status = rrcllc_store_ul_add_reconf_trch_info_list_r7(
          RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerSetup_r7_IEs),
          &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);

      /* Calculate the UL TFCS */
      if((SUCCESS == status) &&
         (RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerSetup_r7_IEs)))
      {
        compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
        if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
           rrc_UL_CommonTransChInfo_r4,tfc_Subset))
        {
          if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
                                              MSG_REL7) == FAILURE)
          {
            return FAILURE;
          }
        }
       if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
	   	   tfc_SubsetList)))
       {
         if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo) == FAILURE)
         {
           status = FAILURE;
         }
       }
      }
      }
     /* If state is Cell_DCH */

    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);



    if (SUCCESS == status)
    {
      /* Fill in the RLC size restriction information for MAC */
      if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
        !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
      {
        status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
          ordered_config_ptr->rrc_state_indicator);
      }
    }



    tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    /* ----------- For FACH, PCH, URA PCH states  the below contents will now----------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr -------------------------------------*/


    /* Get the Common Downlink Transport Channel information */
    if((SUCCESS == status) &&
       (RRCRB_R6_DL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerSetup_r7_IEs)))
    {
      status = get_dl_info_common_for_all_trch_r5(&msg_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
        &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
        ordered_config_ptr->rrc_state_indicator);
    }

    if((SUCCESS == status) && 
       (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r7(
        RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerSetup_r7_IEs),
        &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    } /* If state is Cell_DCH */      

     /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);
 

    
    if ( msg_ptr->specificationMode.u.complete.m.pdcp_ROHC_TargetModePresent)
    {
      WRRC_MSG0_ERROR("RRCEUL: specificationMode_complete_pdcp_ROHC_TargetMode NOT supported yet");
    }

  }
  else /*rrc_RadioBearerSetup_r6_IEs,specificationMode_preconfiguration */
  {
    WRRC_MSG0_ERROR("RRCEUL: preconfiguration in config message not yet supported");
    status = FAILURE;
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status= rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }
  if((SUCCESS == status)&& rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }


#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(&msg_ptr->mimoParameters,
  msg_ptr->rrc_StateIndicator,
  (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,mimoParameters))
                                                ) == FAILURE)
  {
    status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_rbe_r7(rb_setup_r7_ota);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
#else
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,mimoParameters))
  {
    WRRC_MSG0_ERROR("RRCHSPA+: mimoParameters not supported ");
    status = FAILURE;
  }
#endif
 
#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/ 


  /* Ignore the MBMS IEs */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,mbms_PL_ServiceRestrictInfo))
  {
    status = FAILURE;
  } /* end MBMS IE check */


  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,hs_scch_LessInfo))
  {
    WRRC_MSG0_ERROR("RRCHSPA+: hs_scch_LessInfo not supported ");
    status = FAILURE;
  }

  if((SUCCESS == status) && (rb_setup_r7_ota->m.v780NonCriticalExtensionsPresent
     ) &&(rb_setup_r7_ota->v780NonCriticalExtensions.radioBearerSetup_v780ext.m.hs_DSCH_TBSizeTablePresent))
  {
    rrcllcpcie_update_hs_tfri_table_type(TRUE);
  }
  else
  {
       /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
    if((msg_ptr->m.dl_HSPDSCH_InformationPresent )
       || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
       || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
      )
    {
      rrcllcpcie_update_hs_tfri_table_type(FALSE);
    }
  }


  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,dtx_drx_TimingInfo),
        &msg_ptr->dtx_drx_Info,
        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,dtx_drx_Info),
        msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerSetup_r7_IEs,newPrimary_E_RNTI));
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/


#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
      FALSE)== FAILURE)
    {
      return FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */


  /* Got here, everything is okay */
  return (status);

}

/*====================================================================
FUNCTION: rrcllc_rb_release_ie_r7()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Release 5 Radio Bearer Release Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_release_ie_r7
(
  rrc_RadioBearerRelease_r7 * rb_release_r7_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_RadioBearerRelease_r7_IEs *msg_ptr;
  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r7   * dl_trch_delete_ptr = NULL;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r7 * dl_trch_add_reconfig_ptr = NULL;

  ordered_config_type              *tmp_config_ptr = NULL;

#ifdef FEATURE_WCDMA_HS_FACH
  rrcrb_directed_cell_info_type          directed_cell_info;
  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
#endif
  rrcllc_init_before_msg_processing();
  
  msg_ptr= &rb_release_r7_ota->radioBearerRelease_r7;
  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  if( RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,new_DSCH_RNTI) )
  {
    status = FAILURE;
  }

  status = rrcllc_update_urnti_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,new_U_RNTI),
    &msg_ptr->new_U_RNTI,
    msg_ptr->rrc_StateIndicator);

  rrcllc_update_crnti_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,new_C_RNTI),
    msg_ptr->new_C_RNTI, 
    msg_ptr->rrc_StateIndicator);


  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the UTRAN DRX cycle length coefficient */
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
    RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,utran_DRX_CycleLengthCoeff),
                              &msg_ptr->utran_DRX_CycleLengthCoeff
                              );
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
   /* ----------- For FACH, PCH, URA PCH states  the below contents will now----------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr -------------------------------------*/
 
  /* Call these functions ONLY in DCH state */
  if ((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Here, update the transport channel info (only transport channel IDs 
    * and count) and rearrange the info by sorting transport channel list
    * based on TrCH ID.
    */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList,
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,ul_deletedTransChInfoList),
      &msg_ptr->ul_deletedTransChInfoList);

    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
    would be updated later */
    if ( RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }

    if (RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dl_DeletedTransChInfoList))
    {
      dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
    }

    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
    would be updated later */
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(
         dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
    }
  }

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  /* Don't process RAB to reconfig info */

  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_release_list(&msg_ptr->rb_InformationReleaseList);
  }

  if (SUCCESS == status)
  {
    /* Get the affected RB list if present */
    status = rrcllc_process_rb_info_reconfig_list_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,rb_InformationReconfigList),
      &msg_ptr->rb_InformationReconfigList);
  }

  if (SUCCESS == status)
  {
    /* Get the affected RB list if present */
    status = rrcllc_process_rb_info_affected_list_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,rb_InformationAffectedList),
      &msg_ptr->rb_InformationAffectedList);
  }

  if (SUCCESS == status) 
  {
    status = rrcllc_validate_rb_mapping_info();
  }

  /* Don't process RB with PDCP info list */
  if(RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dl_CounterSynchronisationInfo))
  {
    WRRC_MSG0_HIGH("Ignoring DL Counter Sync Info");
  }

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
  /* ----------- For FACH, PCH, URA PCH states  the below contents will now----------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr -------------------------------------*/

  /* Get the Common Uplink Transport Channel information */
  if (SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6(
     RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,ul_CommonTransChInfo),
     &msg_ptr->ul_CommonTransChInfo);
  }

  /* No need to do anything with Delete UL TrCH info. This has already been processed */

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
  * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
  * (for Cell FACH state), this check for state needs to be re-examined
  */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
#ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
 #endif/*FEATURE_VOC_AMR_WB*/

    status = rrcllc_store_ul_add_reconf_trch_info_list_r7(
         RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,ul_AddReconfTransChInfoList),
        &msg_ptr->ul_AddReconfTransChInfoList);

    /* Calculate the UL TFCS */
    if((SUCCESS == status) &&
        RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,ul_CommonTransChInfo))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
	  	rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL7) == FAILURE)
        {
          status = FAILURE;
        }
      }
      if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->ul_CommonTransChInfo,
	  	tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          status = FAILURE;
        }
      }
    }
  }
   /* If state is Cell_DCH */

   /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);


  if (SUCCESS == status)
  {
    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
        ordered_config_ptr->rrc_state_indicator);
    }
  }

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

   /* ----------- For FACH, PCH, URA PCH states  the below contents will now----------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr -------------------------------------*/

  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) &&
    RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dl_CommonTransChInfo))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator);
  }

  if((SUCCESS == status) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dl_AddReconfTransChInfoList),
      &msg_ptr->dl_AddReconfTransChInfoList,
      &msg_ptr->ul_AddReconfTransChInfoList);
  } /* If state is Cell_DCH */      

   /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
   
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,ul_DPCH_Info),
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dl_CommonInformation),
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dl_InformationPerRL_List),
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dl_CommonInformation),
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_info_per_rl_list_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dl_InformationPerRL_List),
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status= rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }

  if ((SUCCESS == status) &&    rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,new_H_RNTI),
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  /* First check if HSDPA is already active or is being activated */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,frequencyInfo))
      && (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(&msg_ptr->mimoParameters,
    msg_ptr->rrc_StateIndicator,
    (RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,mimoParameters))
                                                  ) == FAILURE)
  {
    status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_rbr_r7(rb_release_r7_ota);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
#else
  if(RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,mimoParameters))
  {
      status = FAILURE;
     WRRC_MSG0_ERROR("RRCHSPA+: mimoParameters not supported ");
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/
 
  if(RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,hs_scch_LessInfo))
  {
       status = FAILURE;
     WRRC_MSG0_ERROR("RRCHSPA+: hs_scch_LessInfo not supported ");
  }

  

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(&msg_ptr->rb_InformationReleaseList) == FAILURE)
    {
      return FAILURE;
    }
  }
  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if((SUCCESS == status) && (rb_release_r7_ota->m.v780NonCriticalExtensionsPresent
     ) &&(rb_release_r7_ota->v780NonCriticalExtensions.radioBearerRelease_v780ext.m.hs_DSCH_TBSizeTablePresent))
  {
    rrcllcpcie_update_hs_tfri_table_type(TRUE);
  }
  else
  {
       /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */

    if(RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dl_HSPDSCH_Information)
       || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
       || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
      )
    {
      rrcllcpcie_update_hs_tfri_table_type(FALSE);
    }
  }


  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
     (RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dtx_drx_TimingInfo)),
         &msg_ptr->dtx_drx_Info,
     (RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,dtx_drx_Info)),
         msg_ptr->rrc_StateIndicator
    ) == FAILURE)
    {
      status = FAILURE;
    }
  }
  
#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
  rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,new_H_RNTI));
  }
#ifdef FEATURE_WCDMA_HS_RACH
  if(status == SUCCESS)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r7_IEs,newPrimary_E_RNTI));
  }
#endif
#endif


#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
      FALSE)== FAILURE)
    {
      status = FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */


  /* Got here, everything is okay */
  return (status);
}

/*====================================================================
FUNCTION: rrcllc_rb_reconfig_ie_r7()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Reconfiguration Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_reconfig_ie_r7
(
  rrc_RadioBearerReconfiguration_r7 * rb_reconfig_r7_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_RadioBearerReconfiguration_r7_IEs *msg_ptr;
  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r7    * dl_trch_delete_ptr = NULL;
  
  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r7 * dl_trch_add_reconfig_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;
  ordered_config_type              *tmp_config_ptr = NULL;
  /* We're processing a reconfiguration message now, so set the
  reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
  
  rrcllc_init_before_msg_processing();
  msg_ptr  = &rb_reconfig_r7_ota->radioBearerReconfiguration_r7;
  
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,new_DSCH_RNTI))
  {
     status = FAILURE;
  }
     

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,hs_scch_LessInfo))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("RRCHSPA+: hs_scch_LessInfo not supported ");
  }

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,delayRestrictionFlag) !=0);
#endif
 
  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBRC);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  status = rrcllc_update_urnti_in_oc(
     RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,new_U_RNTI), 
     &msg_ptr->new_U_RNTI,
     msg_ptr->rrc_StateIndicator);

   rrcllc_update_crnti_in_oc(
     RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,new_C_RNTI),
     msg_ptr->new_C_RNTI, 
     msg_ptr->rrc_StateIndicator);

   if (SUCCESS == status)
   {
     status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
   }
  
   if (SUCCESS == status)
   {
     status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
                              (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,utran_DRX_CycleLengthCoeff)),
                              &msg_ptr->utran_DRX_CycleLengthCoeff
                              );
   }

   if (SUCCESS == status)
   {
     /* Get the frequency info */  
     status = rrcllc_update_frequency_info_in_oc(
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,frequencyInfo),
       &msg_ptr->frequencyInfo,
       msg_ptr->rrc_StateIndicator);
   }

   if (SUCCESS == status)
   {
     /* Get the Maximum allowed UL TX power */
     status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,maxAllowedUL_TX_Power),
       msg_ptr->maxAllowedUL_TX_Power);
   }

    /* use TOC ptr if not received in DCH state */
   tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /* ----------- For FACH, PCH, URA PCH states  the below contents will now-------------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr ==-----------------------------------*/
  
  
  if ((SUCCESS == status) && (RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
  	rrc_RadioBearerReconfiguration_r7_IEs_specificationMode_complete)))
  {
    /* Call these functions ONLY in DCH state */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Here, update the transport channel info (only transport channel IDs 
      * and count) and rearrange the info by sorting transport channel list
      * based on TrCH ID.
      */
      status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r7(
        RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs),
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList,
        RRCRB_R6_UL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs),
        &msg_ptr->specificationMode.u.complete.ul_deletedTransChInfoList);


      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
      if (RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs))
      {
        dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
      }

      if (RRCRB_R6_DL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs))
      {
        dl_trch_delete_ptr = &msg_ptr->specificationMode.u.complete.dl_DeletedTransChInfoList;
      }

      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
      if (SUCCESS == status)
      {
        status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(
           dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
      }
    }

     /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);
     
    /* Don't process RAB to reconfig info */

    /* Get the RB reconfiguration list */
    if (SUCCESS == status)
    {
      status = rrcllc_process_rb_info_reconfig_list_r7(
        RRCRB_R6_RB_INFO_RECONFIG_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs),
        &msg_ptr->specificationMode.u.complete.rb_InformationReconfigList);
    }

    if (SUCCESS == status)
    {
      status = rrcllc_process_rb_info_affected_list_r7(
        RRCRB_R6_RB_INFO_AFFECTED_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs),
        &msg_ptr->specificationMode.u.complete.rb_InformationAffectedList);
    }

    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }

      /* use TOC ptr if not received in DCH state */
    tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

   /* ----------- For FACH, PCH, URA PCH states  the below contents will now----------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr -------------------------------------*/
      
    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(
       RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs),
       &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined
    */
    if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
#ifdef FEATURE_VOC_AMR_WB
      ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
 #endif/*FEATURE_VOC_AMR_WB*/

      status = rrcllc_store_ul_add_reconf_trch_info_list_r7(
          RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs),
          &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);

      /* Calculate the UL TFCS */
      if((SUCCESS == status) &&
         (RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs)))
      {
        compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

        if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,  
           rrc_UL_CommonTransChInfo_r4,tfc_Subset))
        {
          if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo, 
                                              MSG_REL7) == FAILURE)
          {
            status = FAILURE;
          }
          if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(
		  	msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,tfc_SubsetList)))
          {
            if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo) == FAILURE)
            {
              status = FAILURE;
            }
          }
        }
      }
    } /* If state is Cell_DCH */

    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);


    if (SUCCESS == status)
    {
      /* Fill in the RLC size restriction information for MAC */
      if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
        !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
      {
        status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
          ordered_config_ptr->rrc_state_indicator);
      }
    }


    /* use TOC ptr if not received in DCH state */
   tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

     /* ----------- For FACH, PCH, URA PCH states  the below contents will now----------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr -------------------------------------*/

    /* Get the Common Downlink Transport Channel information */
    if((SUCCESS == status) &&
       (RRCRB_R6_DL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs)))
    {
      status = get_dl_info_common_for_all_trch_r5(&msg_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
        &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
        ordered_config_ptr->rrc_state_indicator);
    }
  
    if((SUCCESS == status) && 
       (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r7(
        RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs),
        &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    } /* If state is Cell_DCH */      

    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);

    if ( msg_ptr->specificationMode.u.complete.m.pdcp_ROHC_TargetModePresent)
    {
      WRRC_MSG0_ERROR("RRCEUL: specificationMode_complete_pdcp_ROHC_TargetMode NOT supported yet");
    }
  }
  else /*rrc_RadioBearerReconfiguration_r7_IEs,specificationMode_complete */
  {
    WRRC_MSG0_ERROR("RRCEUL: preconfiguration in config message not yet supported");
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status= rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }


  if ((SUCCESS == status) &&    rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }


  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(&msg_ptr->mimoParameters,
    msg_ptr->rrc_StateIndicator,
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,mimoParameters))
                                                  ) == FAILURE)
  {
    status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_rbrc_r7(rb_reconfig_r7_ota);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
#else
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("RRCHSPA+: mimoParameters not supported ");
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if( RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,delayRestrictionFlag))
    {
      if(( RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs))
         || (  RRCRB_R6_UL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs))
         || ( RRCRB_R6_DL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs))
         || ( RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r7_IEs))
      ) 
      {
         WRRC_MSG0_ERROR("Trch Ie touched bitmask  , so Delay restriction cannot be applied");
      }
      else
      {
        rrcllc_update_delay_restriction(
         RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,activationTime),
         RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,delayRestrictionFlag),
         msg_ptr->activationTime,msg_ptr->rrc_StateIndicator);
      }
    }
  }

  if((SUCCESS == status) && (rb_reconfig_r7_ota->m.v780NonCriticalExtensionsPresent)
   &&(rb_reconfig_r7_ota->v780NonCriticalExtensions.radioBearerReconfiguration_v780ext.m. 
      hs_DSCH_TBSizeTablePresent) )
  {
    rrcllcpcie_update_hs_tfri_table_type(TRUE);     
  }
  else
  {
       /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
    if(( msg_ptr->m.dl_HSPDSCH_InformationPresent )
       || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
       || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
      )
    {
    rrcllcpcie_update_hs_tfri_table_type(FALSE);     
  }
  }


  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
         RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,dtx_drx_TimingInfo),
         &msg_ptr->dtx_drx_Info,
         RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,dtx_drx_Info),
         msg_ptr->rrc_StateIndicator
    ) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RadioBearerReconfiguration_r7_IEs,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_DC_HSUPA
      if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
        FALSE)== FAILURE)
      {
        status = FAILURE;
      }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return (status);
}

/*====================================================================
FUNCTION: rrcllc_phychan_reconfig_ie_r7()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Physical Channel Reconfiguration Message for Rel 6

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_phychan_reconfig_ie_r7
(
  rrc_PhysicalChannelReconfiguration_r7  * phys_chan_reconfig_r7_ota
)
{

  uecomdef_status_e_type          status = SUCCESS;
  rrc_PhysicalChannelReconfiguration_r7_IEs *msg_ptr;
  rrcrb_directed_cell_info_type          directed_cell_info;
  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;
  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
  
  msg_ptr = &phys_chan_reconfig_r7_ota->physicalChannelReconfiguration_r7;
  
  rrcllc_init_before_msg_processing();

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,delayRestrictionFlag) !=0);
#endif

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_PCR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
 status = rrcllc_update_urnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,new_U_RNTI), 
    &msg_ptr->new_U_RNTI,
    msg_ptr->rrc_StateIndicator);

   rrcllc_update_crnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,new_C_RNTI),
    msg_ptr->new_C_RNTI, 
    msg_ptr->rrc_StateIndicator);

   if (SUCCESS == status)
   {
     status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
   }

  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
                              (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,utran_DRX_CycleLengthCoeff)),
                              &msg_ptr->utran_DRX_CycleLengthCoeff
                              );
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }


  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status= rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }
    


  if ((SUCCESS == status) &&    rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }




  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  if((phys_chan_reconfig_r7_ota != NULL) &&
    (phys_chan_reconfig_r7_ota->m.v780NonCriticalExtensionsPresent)) 
  {
    if(phys_chan_reconfig_r7_ota->v780NonCriticalExtensions.physicalChannelReconfiguration_v780ext.m.harqInfoPresent)
    {
      if (set_harq_information_r7(
        &phys_chan_reconfig_r7_ota->v780NonCriticalExtensions.physicalChannelReconfiguration_v780ext.harqInfo)
        == FAILURE)
      {
        status = FAILURE;
      }  
    }
  }
    
  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,hs_scch_LessInfo))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("RRCHSPA+: hs_scch_LessInfo not supported ");
  }
#ifdef FEATURE_WCDMA_MIMO

 

  if(rrcllcpcie_process_mimo_params(&msg_ptr->mimoParameters,
    msg_ptr->rrc_StateIndicator,
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,mimoParameters))
                                                  ) == FAILURE)
  {
     status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_pcrc_r7(phys_chan_reconfig_r7_ota);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
#else
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,mimoParameters))
  {
     status = FAILURE;
     WRRC_MSG0_ERROR("RRCHSPA+: mimoParameters not supported ");
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  if(SUCCESS == status)
  {
    rrcllc_update_delay_restriction(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,activationTime),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,delayRestrictionFlag),
      msg_ptr->activationTime,msg_ptr->rrc_StateIndicator);
  }
  
  if((SUCCESS == status) && (phys_chan_reconfig_r7_ota != NULL) && (phys_chan_reconfig_r7_ota->m.v780NonCriticalExtensionsPresent
     )&&(phys_chan_reconfig_r7_ota->v780NonCriticalExtensions.physicalChannelReconfiguration_v780ext.m.hs_DSCH_TBSizeTablePresent) )
  {
    rrcllcpcie_update_hs_tfri_table_type(TRUE);
  }
  else
  {
       /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
    if((msg_ptr->m.dl_HSPDSCH_InformationPresent )
       || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
       || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
      )
    {
    rrcllcpcie_update_hs_tfri_table_type(FALSE);
  }
  }


  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,dtx_drx_TimingInfo),
       &msg_ptr->dtx_drx_Info,
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,dtx_drx_Info),
       msg_ptr->rrc_StateIndicator
       ) == FAILURE)
    {
      status = FAILURE;
    }
  }
  
#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,new_H_RNTI));
  }


#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_PhysicalChannelReconfiguration_r7_IEs,newPrimary_E_RNTI));
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/


#ifdef FEATURE_WCDMA_DC_HSUPA
  if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)== FAILURE)
  {
    status = FAILURE;
  }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return (status);

}


/*====================================================================
FUNCTION: rrcllc_rrc_conn_setup_ie_r6()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in R5 RRC Connection Setup Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rrc_conn_setup_ie_r7
(
  rrc_RRCConnectionSetup_r7  *rrc_conn_setup_r7_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_RRCConnectionSetup_r7_IEs *msg_ptr;
  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r7 * dl_trch_add_reconfig_ptr = NULL;

  ordered_config_type              *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;
  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
  msg_ptr = &rrc_conn_setup_r7_ota->rrcConnectionSetup_r7;

  /************************************************************/
  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /************************************************************/

  /* We do not handle Cell_PCH and URA_PCH states at present */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH) || (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    WRRC_MSG0_ERROR("CELL_PCH or URA-PCH state transition invalid!");
    status = FAILURE;
  }

  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;


  /* Assume that the default is now, i.e. the current SFN */
  MSG_MED("Activation Time is Now!",0,0,0);
  ordered_config_ptr->activation_time = RRCLLC_ACTIVATION_TIME_NOW;
  ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_NONE;

  rrcllc_init_before_msg_processing();
  
#ifdef FEATURE_VOC_AMR_WB
  ordered_config_ptr->ul_tfcs.orderd_codec_mode = MVS_MODE_NONE;
#endif/*FEATURE_VOC_AMR_WB*/

  if (SUCCESS == status)
  {
   status = rrcllc_update_urnti_in_oc(
      TRUE, /* new-U-RNTI is mandatory in RRC Connection Setup message */
      &msg_ptr->new_U_RNTI,
      msg_ptr->rrc_StateIndicator);  
  }

  /* Get the C-RNTI */
  rrcllc_update_crnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,new_c_RNTI),
    msg_ptr->new_c_RNTI, 
    msg_ptr->rrc_StateIndicator);


  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the UTRAN DRX cycle length coefficient */
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
                              TRUE,           /*Since Coef1 is always present in RRC connection setup*/
                              &msg_ptr->utran_DRX_CycleLengthCoeff
                              );
  }  

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /* ----------- For FACH, PCH, URA PCH states  the below contents will now-------------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr ==-----------------------------------*/
     
  if ((SUCCESS == status) && (RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
      rrc_RRCConnectionSetup_r7_IEs_specificationMode_complete)))
  {
    if ((RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(
        msg_ptr,rrc_RRCConnectionSetup_r7_IEs) ))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
    } 
    /* Call these functions ONLY in DCH state */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Here, update the transport channel info (only transport channel IDs 
      * and count) and rearrange the info by sorting transport channel list
      * based on TrCH ID.
      */
      status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r7(
        TRUE, /* ul_AddReconfTransChInfoList is mandatory present */
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList,
        FALSE,
        NULL);


      if (SUCCESS == status)
      {
        status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(
                 dl_trch_add_reconfig_ptr, NULL);
      }
    }  

    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);
 
    /* Get the SRB setup list if present */
    if (SUCCESS == status)
    {
      status =  rrcllc_process_srb_info_setup_list_r7(
        TRUE, /* SRB info has to be present in rrcConnectionSetup message */
        (rrc_SRB_InformationSetupList_r7 *) &msg_ptr->specificationMode.u.
        complete.srb_InformationSetupList);
    }

    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }
    
 /* use TOC ptr if not received in DCH state */
   tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /* ----------- For FACH, PCH, URA PCH states  the below contents will now-------------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr ==-----------------------------------*/
     
    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(
       RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r7_IEs),
       &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined
    */
    if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      status = rrcllc_store_ul_add_reconf_trch_info_list_r7(
          RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r7_IEs),
          &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);

      /* Calculate the UL TFCS */
      if((SUCCESS == status) &&
         (RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r7_IEs)))
      {
        compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
      }

    } /* If state is Cell_DCH */

 /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);
 

    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
       !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                       ordered_config_ptr->rrc_state_indicator)
          == FAILURE)
      {
        status = FAILURE;
      }
    }



 /* use TOC ptr if not received in DCH state */
   tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /* ----------- For FACH, PCH, URA PCH states  the below contents will now-------------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr ==-----------------------------------*/
     
    /* Get the Common Downlink Transport Channel information */
    if((SUCCESS == status) &&
       (RRCRB_R6_DL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r7_IEs)))
    {
      status = get_dl_info_common_for_all_trch_r5(
        &msg_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
        &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
        ordered_config_ptr->rrc_state_indicator);
    }

    if (SUCCESS == status)
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r7(
        RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r7_IEs),
        &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    }
  }
  else /*rrc_RRCConnectionSetup_r7_IEs,specificationMode_preconfiguration */
  {
    if(rrcrce_get_rbs_ptr() != NULL)
    {
      status = rrcllc_process_preconfiguration_with_srb5_rrc_conn_setup(msg_ptr->rrc_StateIndicator);
      WRRC_MSG1_HIGH("Finished processing DC with SRB5. status = %d",status);
    }
    else
    {
      status = rrcllc_process_preconfiguration_rrc_conn_setup_ie_r6((void *) msg_ptr, MSG_REL7);
    }
  }

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);
 
  if (SUCCESS == status)
  {
    /* Get the frequency info */
    status = rrcllc_update_frequency_info_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get Uplink DPCH info if included, Ignore CPCH info */
    status = rrcllcpcie_process_ul_dpch_info_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the DL information for all Radio Links */
    status = rrcllcpcie_process_dl_common_info_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_info_per_rl_list_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }


  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status= rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }


  if ((SUCCESS == status) &&    rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }



  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }
   
  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if((SUCCESS == status) && (rrc_conn_setup_r7_ota->m.v780NonCriticalExtensionsPresent
     )&&(rrc_conn_setup_r7_ota->v780NonCriticalExtensions.rrcConnectionSetup_v780ext.m. 
        hs_DSCH_TBSizeTablePresent) )
  {
    rrcllcpcie_update_hs_tfri_table_type(TRUE);
  }
  else
  {
       /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
    if((msg_ptr->m.dl_HSPDSCH_InformationPresent)
       || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
       || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
      )
    {
    rrcllcpcie_update_hs_tfri_table_type(FALSE);
  }
  }


  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,dtx_drx_TimingInfo),
       &msg_ptr->dtx_drx_Info,
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,dtx_drx_Info),
       msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        TRUE,
                                        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,new_H_RNTI));
  }


#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        TRUE,
                                        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r7_IEs,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  return (status);
}

/*====================================================================
FUNCTION: rrcllc_active_set_update_ie_r7()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Active Set Update Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_active_set_update_ie_r7
(
  rrc_ActiveSetUpdate_r7 * active_set_update_r7_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_ActiveSetUpdate_r7_IEs *msg_ptr;

  
  rrcllc_init_before_msg_processing();
  msg_ptr =  &active_set_update_r7_ota->activeSetUpdate_r7;
  
  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /* Ignore the Integrity Protection and Ciphering IEs */

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,activationTime),
    msg_ptr->activationTime, rrc_RRC_StateIndicator_cell_DCH, RRC_PROCEDURE_ASU);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
 /* Get the U-RNTI */
 status = rrcllc_update_urnti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,newU_RNTI), 
    &msg_ptr->newU_RNTI,
    rrc_RRC_StateIndicator_cell_DCH);

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  } 

  if (SUCCESS == status)
  {
    /* Get the Radio Link Removal information */
    status = rrcllcpcie_process_rl_removal_information_list(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,rl_RemovalInformationList),
      &msg_ptr->rl_RemovalInformationList,
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,rl_AdditionInformationList)
      );
  }
    

  /* Get the TX Diversity Mode */
  if((SUCCESS == status) && 
     (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,tx_DiversityMode)))
  {
    status = get_tx_diversity_mode_info(msg_ptr->tx_DiversityMode,
      &ordered_config_ptr->l1_dl_chan_parms.dl_common);
  } /* end TX Diversity Mode */

  if (SUCCESS == status)
  {
    /* Get the Radio Link Addition information */
    status = rrcllcpcie_process_rl_addition_info_list_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,rl_AdditionInformationList),
      &msg_ptr->rl_AdditionInformationList);
  }

  if(SUCCESS == status)
  {
    rrcllcpcie_process_edpch_interpolation_info(  msg_ptr->e_DPDCH_PowerInterpolation,
        (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,e_DPDCH_PowerInterpolation)));
  }

#ifdef FEATURE_WCDMA_REL7_EDPCCH_POWER_BOOST
  if (SUCCESS == status)
  {
     status = rrcllcpcie_process_edpcch_boost_info(&msg_ptr->e_TFC_Boost_Info, RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,e_TFC_Boost_Info));
  }
#else
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,e_TFC_Boost_Info))
  {
    WRRC_MSG0_ERROR("processing of e_TFC_Boost_Info in ASU not yet supported");
  }
#endif

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_e_dch_reconfig_info_samecell(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r7_IEs,e_dch_ReconfInfoSameCell),
      &msg_ptr->e_dch_ReconfInfoSameCell);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_e_dch_reconfig_info_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,e_dch_ReconfigurationInfo),
      &msg_ptr->e_dch_ReconfigurationInfo);
  }
#ifdef FEATURE_WCDMA_16_QAM
  if (SUCCESS == status)
  {
     status = rrcllcpcie_process_ul_16qam_config(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,ul_16QAM_Config),&msg_ptr->ul_16QAM_Config);
  }
#endif
  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    rrc_RRC_StateIndicator_cell_DCH);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    rrc_RRC_StateIndicator_cell_DCH);

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status= rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(rrc_RRC_StateIndicator_cell_DCH);
  }


  if ((SUCCESS == status) &&    rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  /* Validation for and processing for ASU repointing */

 if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,newH_RNTI), 
      &msg_ptr->newH_RNTI,
      rrc_RRC_StateIndicator_cell_DCH);
  }

  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,serving_HSDSCH_CellInformation))
  {
    if(SUCCESS == status)
    {
      status = rrcllc_process_serving_hsdsch_cell_info_r7(msg_ptr); 
    }
  }

#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(&msg_ptr->mimoParameters,
    rrc_RRC_StateIndicator_cell_DCH,
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,mimoParameters))
                                                  ) == FAILURE)
  {
    status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_asu_r7(active_set_update_r7_ota);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
#else
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("RRCHSPA+: mimoParameters not supported ");
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,rrc_RRC_StateIndicator_cell_DCH,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/




  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,dpc_Mode))
  {
    WRRC_MSG0_ERROR("processing of dpc_Mode in ASU not yet supported");
    status = FAILURE;
  }
  if((SUCCESS == status) && (active_set_update_r7_ota->m.v780NonCriticalExtensionsPresent
   ) &&(active_set_update_r7_ota->v780NonCriticalExtensions.activeSetUpdate_v780ext.m. 
      hs_DSCH_TBSizeTablePresent))
  {
    rrcllcpcie_update_hs_tfri_table_type(TRUE);
  }
  else
  {
       /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
    if(((RRC_MSG_COMMON_BITMASK_IE(active_set_update_r7_ota->activeSetUpdate_r7,
      rrc_ActiveSetUpdate_r7_IEs,serving_HSDSCH_CellInformation)) &&
      (RRC_MSG_COMMON_BITMASK_IE(active_set_update_r7_ota->activeSetUpdate_r7.serving_HSDSCH_CellInformation,
      rrc_Serving_HSDSCH_CellInformation_r7,dl_hspdsch_Information))) 
       || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
       || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
      )
    {
    rrcllcpcie_update_hs_tfri_table_type(FALSE);
  }
  }


  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,dtx_drx_TimingInfo),
       &msg_ptr->dtx_drx_Info,
       RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r7_IEs,dtx_drx_Info),
       rrc_RRC_StateIndicator_cell_DCH) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,rrc_RRC_StateIndicator_cell_DCH,
      FALSE)== FAILURE)
    {
      status = FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  return (status);
}

/*====================================================================
FUNCTION: rrcllc_cell_update_confirm_ie_r7()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Cell Update Confirm Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_cell_update_confirm_ie_r7
(
  uint32 dl_sdu_num,
  void * cell_update_r7_msg_ptr
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_CellUpdateConfirm_r7_IEs *msg_ptr;
  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r7    * dl_trch_delete_ptr = NULL;
   
  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r7 * dl_trch_add_reconfig_ptr = NULL;
  
  ordered_config_type              *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;
  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* We're processing a reconfiguration message now, so set the
  reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  if(rrc_DL_CCCH_Message_PDU == dl_sdu_num)
  {
    rrc_DL_CCCH_Message *ccch_ptr= NULL;
    ccch_ptr=  (rrc_DL_CCCH_Message *)cell_update_r7_msg_ptr;
    msg_ptr =&ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
                                               criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
                                               u.r7.cellUpdateConfirm_r7;
  }
  else
  {
    rrc_DL_DCCH_Message *dcch_ptr= NULL;

    dcch_ptr = (rrc_DL_DCCH_Message *)cell_update_r7_msg_ptr;
 
    msg_ptr =&dcch_ptr->message.u.cellUpdateConfirm.u.
                                               later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.
                                               r7.cellUpdateConfirm_r7;
     
  }
                                               
  rrcllc_init_before_msg_processing();

  /* Get the Activation Time */
  
  rrcllc_update_activation_time_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_CU);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  status = rrcllc_update_urnti_in_oc(
     RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,new_U_RNTI),
     &msg_ptr->new_U_RNTI,
     msg_ptr->rrc_StateIndicator);

  rrcllc_update_crnti_in_oc(
     RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,new_C_RNTI),
     msg_ptr->new_C_RNTI, 
     msg_ptr->rrc_StateIndicator);

  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
                              (RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,utran_DRX_CycleLengthCoeff)),
                              &msg_ptr->utran_DRX_CycleLengthCoeff
                              );
  }
  
  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,frequencyInfo),
     &msg_ptr->frequencyInfo,
     msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(
     RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,maxAllowedUL_TX_Power),
     msg_ptr->maxAllowedUL_TX_Power);
  }


  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /* ----------- For FACH, PCH, URA PCH states  the below contents will now-------------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr ==-----------------------------------*/

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList,
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_deletedTransChInfoList),
      &msg_ptr->ul_deletedTransChInfoList);


    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
       would be updated later */
    if (RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }

    if (RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_DeletedTransChInfoList))
    {
      dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
    }

    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
       would be updated later */
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(
        dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
    }
  }

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if (SUCCESS == status && 
      (RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReleaseList)))
  {
    status = rrcllc_process_rb_info_release_list(&msg_ptr->rb_InformationReleaseList);
  }

  /* Get the RB reconfiguration list */
  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_reconfig_list_r7(
     RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationReconfigList),
      &msg_ptr->rb_InformationReconfigList);
  }

  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_affected_list_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,rb_InformationAffectedList),
      &msg_ptr->rb_InformationAffectedList);
  }


  if (SUCCESS == status) 
  {
    status = rrcllc_validate_rb_mapping_info();
  }

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /* ----------- For FACH, PCH, URA PCH states  the below contents will now-------------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr ==-----------------------------------*/
     
  /* Get the Common Uplink Transport Channel information */
  if (SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6(
       RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_CommonTransChInfo),
      &msg_ptr->ul_CommonTransChInfo);
  }

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_ul_add_reconf_trch_info_list_r7(
     RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_AddReconfTransChInfoList),
     &msg_ptr->ul_AddReconfTransChInfoList);
    
    /* Calculate the UL TFCS */
    if((SUCCESS == status) &&
       ( RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_CommonTransChInfo) ))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
	  	rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL7) == FAILURE)
        { 
          status = FAILURE;
        }
      }
      if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(
	  	msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          status = FAILURE;
        }
      }
    }
  }

  /* If state is Cell_DCH */

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);


  if (SUCCESS == status)
  {
    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
        ordered_config_ptr->rrc_state_indicator);
    }
  }


  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /* ----------- For FACH, PCH, URA PCH states  the below contents will now-------------------
     -------------be update to TOC.----------------------------------------------------
     -------------OC ptr is now pointing to TOC ptr ==-----------------------------------*/
     
  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) &&
     (RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_CommonInformation)))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator);
  }

  if((SUCCESS == status) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_AddReconfTransChInfoList), 
      &msg_ptr->dl_AddReconfTransChInfoList,
      &msg_ptr->ul_AddReconfTransChInfoList);
  } /* If state is Cell_DCH */      

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if (RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,pdcp_ROHC_TargetMode) )
  {
    WRRC_MSG0_ERROR("RRCEUL: rrc_CellUpdateConfirm_r7_IEs_pdcp_ROHC_TargetMode NOT supported yet");
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_DPCH_Info),
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_CommonInformation),
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_InformationPerRL_List), 
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_DPCH_Info), 
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_InformationPerRL_List),
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_InformationPerRL_List),  
      &msg_ptr->dl_InformationPerRL_List,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI,
    TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(
    RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI,
    FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information,
      msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(SUCCESS == status)
  { 
    status= rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator);
  }


  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }



  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,new_H_RNTI),
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r7(
      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      (( RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(&msg_ptr->mimoParameters,
    msg_ptr->rrc_StateIndicator,
    RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,mimoParameters)) == FAILURE)
  {
    status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_cu_r7(dl_sdu_num,cell_update_r7_msg_ptr);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
#else
  if(RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("RRCHSPA+: mimoParameters not supported ");
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/


  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(&msg_ptr->rb_InformationReleaseList) == FAILURE)
    {
      status = FAILURE;
    }
  }
   
  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }


  if(SUCCESS == status)
  {
    if(rrc_DL_CCCH_Message_PDU == dl_sdu_num)
    {
      rrc_DL_CCCH_Message *ccch_ptr= NULL;
      ccch_ptr=  (rrc_DL_CCCH_Message *)cell_update_r7_msg_ptr;

      if((ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.
	  	u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
        u.r7.m.v780NonCriticalExtensionsPresent) &&
      ( ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
        criticalExtensions.u.criticalExtensions.u.criticalExtensions.
        u.criticalExtensions.u.r7.v780NonCriticalExtensions.cellUpdateConfirm_v780ext.m.hs_DSCH_TBSizeTablePresent))
      {
        rrcllcpcie_update_hs_tfri_table_type(TRUE);
      }
      else
      {
           /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
        if((RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_HSPDSCH_Information))
           || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
           || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
          )
        {
          rrcllcpcie_update_hs_tfri_table_type(FALSE);
        }
      }
    }
    else
    {
      rrc_DL_DCCH_Message *dcch_ptr= NULL;
      dcch_ptr = (rrc_DL_DCCH_Message *)cell_update_r7_msg_ptr;

      if((dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.
        u.criticalExtensions.u.criticalExtensions.u.r7.m.v780NonCriticalExtensionsPresent) &&
        ( dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.
        u.criticalExtensions.u.criticalExtensions.u.r7.v780NonCriticalExtensions.cellUpdateConfirm_v780ext.m.hs_DSCH_TBSizeTablePresent))
      {
        rrcllcpcie_update_hs_tfri_table_type(TRUE);
      }
      else
      {
           /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
        if(RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dl_HSPDSCH_Information)
           || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
           || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
          )
        {
          rrcllcpcie_update_hs_tfri_table_type(FALSE);
        }
      }
    }
  }


  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
   (RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dtx_drx_TimingInfo)),
       &msg_ptr->dtx_drx_Info,
   (RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,dtx_drx_Info)),
       msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRBR_R7_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r7_IEs,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/


#ifdef FEATURE_WCDMA_DC_HSUPA
      if(rrcllcpcie_process_dc_hsupa_params(NULL,rrc_RRC_StateIndicator_cell_DCH,
        FALSE)== FAILURE)
      {
        status = FAILURE;
      }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return (status);

}

/*====================================================================
FUNCTION: rrcllc_rrc_conn_setup_ie()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the RRC Connection Setup Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rrc_conn_setup_ie
(
  rrc_RRCConnectionSetup_r3_IEs *msg_ptr
)
{
  /* local loop variable */
  uint8                           idx;
#ifdef FEATURE_WCDMA_HS_FACH
  uecomdef_status_e_type status = SUCCESS;
#endif
  rrcrb_directed_cell_info_type          directed_cell_info;
  /* Local count of # of SRB's to setup */
  uint8                           srb_cnt = 0;

  /* Local SRB Value */
  rrc_RB_Identity                      rb_id = CCCH_RADIO_BEARER_ID;

  /* local SRB to setup list pointer */
  rrc_SRB_InformationSetupList2  *srb_setup_ptr;

  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList * ul_trch_add_reconfig_ptr = NULL;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList * dl_trch_add_reconfig_ptr = NULL;

  /* Local C_RNTI value */
  rrc_int_c_rnti_type             c_rnti;

  /* Local variable to store head pointer */


  
  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* Later on, we will check to make sure both of these parameters
     are present when going from a non-DCH state to DCH. */
/*  const uint32 dl_dpch_mask =
   rrc_RRCConnectionSetup_r3_IEs,dl_CommonInformation |
   rrc_RRCConnectionSetup_r3_IEs,dl_InformationPerRL_List;
*/
  /************************************************************/
  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /************************************************************/

  /* We do not handle Cell_PCH and URA_PCH states at present */
  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH)
  {
    WRRC_MSG0_ERROR("CELL_PCH state transition is not supported!");
    return FAILURE;
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_ura_PCH)
  {
    WRRC_MSG0_ERROR("URA_PCH state transition not supported");
    return(FAILURE);
  }

  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  rrcllc_init_before_msg_processing();
  // Activation time should always be set to NOW for connection setup

    /* Assume that the default is now, i.e. the current SFN */
  MSG_MED("Activation Time is Now!",0,0,0);
  ordered_config_ptr->activation_time = RRCLLC_ACTIVATION_TIME_NOW;
  ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_NONE;

  /* Indicate to MAC that only have a valid U_RNTI, and to use in MAC header */
  rrc_translate_urnti(&msg_ptr->new_U_RNTI, &ordered_config_ptr->mac_ul_parms.rnti_info.urnti);
  ordered_config_ptr->mac_dl_parms.rnti_info.urnti = 
    ordered_config_ptr->mac_ul_parms.rnti_info.urnti;
  ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
  ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;

  /* Get the C-RNTI */
  if((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r3_IEs,new_c_RNTI)) && 
   (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_c_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
    ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
  }

  /* Get the RRC State Indicator */
  switch(msg_ptr->rrc_StateIndicator)
  {
    case rrc_RRC_StateIndicator_cell_DCH:
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
      break;

    case rrc_RRC_StateIndicator_cell_FACH:
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_FACH;
      /* For Cell_FACH state, use the new U_RNTI (in the message) to
       * select SCCPCH and update SCCPCH, PCH and FACH related info.
       */ 
      if(rrcllc_copy_sccpch_info_from_sib_to_oc_in_connected_mode(rrc_get_state(), RRC_STATE_CELL_FACH)
          == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure to update OC from SIB");
        return(FAILURE);
      }
      break;

    default:
      WRRC_MSG1_ERROR("RRC State %d not supported",msg_ptr->rrc_StateIndicator);
      return FAILURE;
  } /* end RRC State indicator */


  /* Get the UTRAN DRX cycle length coefficient */
  if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
     (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
    )
  {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);

  }
  else
  {
    WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
              msg_ptr->utran_DRX_CycleLengthCoeff);
    return FAILURE;
  } /* end UTRAN DRX cycle length coefficient */



  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;

    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                      NULL)
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info(dl_trch_add_reconfig_ptr,NULL) == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  }
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get the SRB setup list */
  srb_setup_ptr = &msg_ptr->srb_InformationSetupList;


  while((srb_setup_ptr->n > srb_cnt ) && (srb_cnt < UE_MAX_SRB_SETUP))
  {
    /* Check to see if the RB ID is there ... */
    if(srb_setup_ptr->elem[srb_cnt].m.rb_IdentityPresent)
    {
      rb_id = srb_setup_ptr->elem[srb_cnt].rb_Identity;
    }

    /*
    * ... if not, then start with the first SRB and get the next SRB ID
    * each time one is not included in the IE.
    */
    else
    {
      /* Get the next SRB, note this increments to 1 the first time */
      rb_id++;
    }

    /* Save off the RB Mapping info for each SRB */
    if(get_srb_info_to_setup(&srb_setup_ptr->elem[srb_cnt], srb_setup_ptr, rb_id)
       == FAILURE)
    {
      return FAILURE;
    }

    srb_cnt++;
  } /* end SRB setup */

  if (FAILURE == rrcllc_validate_rb_mapping_info()) 
  {
    return FAILURE;
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Get the Common Uplink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r3_IEs,ul_CommonTransChInfo))
  {
    if(get_ul_info_common_for_all_trch(&msg_ptr->ul_CommonTransChInfo, 
                                       ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* end UL Common TrCH Info */

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */
  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the UL Added or Reconfigured Transport Channel information */
    ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
    idx = 0;
    
    /* Save info for each additional Transport Channel */
    while((dch_ie_processing_status == SUCCESS) && 
          (idx <= UE_MAX_TRCH) && 
          (ul_trch_add_reconfig_ptr->n > idx))
    {
      if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
      {
        dch_ie_processing_status = FAILURE;
      }
  
      /* get next TrCH Info */
      idx++;
 
    } /* end UL TrCH Add/Reconfig */
    
    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
 #ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = MVS_MODE_NONE;
 #endif/*FEATURE_VOC_AMR_WB*/
  
    /* Calculate the UL TFCS for the DCH */
    if((dch_ie_processing_status == SUCCESS) && 
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r3_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,rrc_UL_CommonTransChInfo,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL99) == FAILURE)
        { 
          dch_ie_processing_status = FAILURE;
        } 
      }

    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      return FAILURE;
    }
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Get the Common Downlink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r3_IEs,dl_CommonTransChInfo))
  {
    if(get_dl_info_common_for_all_trch(&msg_ptr->dl_CommonTransChInfo,
                                       &msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator
                                      )
        == FAILURE)
    {
      dch_ie_processing_status  = FAILURE;
    }
  } /* end DL Common TrCH Info */

  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
    dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    idx = 0;
    
    /* Save info for each additional Transport Channel */
    while((dch_ie_processing_status == SUCCESS) && 
          (idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL &&
          (dl_trch_add_reconfig_ptr->n > idx))
    {
      if(get_dl_added_reconfig_trch(&dl_trch_add_reconfig_ptr->elem[idx],
                                    ul_trch_add_reconfig_ptr,
                                    /* RRC Connection Setup doesn't allowed TM signalling DCCH */
                                    FALSE
                                   )
          == FAILURE)
      {
        dch_ie_processing_status = FAILURE;
      }
  
      /* get next TrCH Info */
      idx++;

  
    } /* end DL TrCH Add/Reconfig */
  
    /* Adjust TB size on every TrCH if necessary. */ 
    for (idx=0; (dch_ie_processing_status == SUCCESS) && (idx < UE_MAX_TRCH); idx++)
    {
      /* The number of logical channel mapped to this transport channel 
         increases from 1 to 2. Needs to adjsut the tb_szie to
         reflect the adding of the MAC header.                         */
      if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
          (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
           ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
      {
        /* TrCH ID is appeared in the TrCH info table. */
        if (!(find_trch_id_in_config_trch_list(&msg_ptr->dl_AddReconfTransChInfoList,
                                              ordered_config_ptr->dl_dch_trch_info[idx].trch_id)))
        {
          /* Added MAC head size to the current TB size.  */
          rrcllc_update_tb_size_for_dch(idx);
        }
        /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
        WRRC_MSG0_HIGH("Clean TB size adjust flag in RRCConn");
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
      }
      else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
      {
        /* Since the activated transport channels are sorted before stored in
           the memory, break the looping after reaching the 1st invalid block.  */
        break;
      }
    }

    
    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_dl_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_RRCConnectionSetup_r3_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
          msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r3_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if((ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
     (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r3_IEs,ul_ChannelRequirement)))
  {
    /* Check to see if this is DPCH or CPCH */
    switch(msg_ptr->ul_ChannelRequirement.t)
    {
      case T_rrc_UL_ChannelRequirement_ul_DPCH_Info:
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          if(get_ul_dpch_info(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        break;

      case T_rrc_UL_ChannelRequirement_dummy:
        WRRC_MSG0_ERROR("UL CPCH info not supported for RRC Conn Setup");
        return FAILURE;

      default:
        WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in RRC Conn Setup",
                  msg_ptr->ul_ChannelRequirement.t);
        return FAILURE;
    }
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
          current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No UL Ch Req, RRC ConnSetup state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  } /* end if state is Cell DCH && check for UL Channel Requirement */

  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     (!((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r3_IEs,dl_CommonInformation))
     &&(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r3_IEs,dl_InformationPerRL_List))))
       && current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No DL DPCH, RRC Conn Setup state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }

  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Initialize the L1 bitmask for the parameters in the "Downlink
     * information for all radio links" IE.  Since the IE is optional,
     * we want to make sure we don't signal L1 erroneously that we have
     * received information when we haven't.
     */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
   rrcllc_init_dl_common_info(ordered_config_ptr);

   if (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) 
   {
     ordered_config_ptr->is_hho = TRUE;
   }

   if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r3_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl(&msg_ptr->dl_CommonInformation,
                                       &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                       &ordered_config_ptr->l1_dl_cctrch_parms,
                                       &ordered_config_ptr->l1_dl_ctfc_parms
                                      ) == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL Common RL */
  } /* If next state is Cell_DCH */

  /* Calculate the TFIs from CTFCs and restrict CTFCs based on the RM restricted info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms
                            );

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_RRCConnectionSetup_r3_IEs,dl_InformationPerRL_List))
  {
    if(get_dl_info_per_rl(&msg_ptr->dl_InformationPerRL_List,
        msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }
  
  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
    == FAILURE)
  { 
    return FAILURE;
  }
  
  if(rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }


  if (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)) 
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }


  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_HS_FACH
  if(SUCCESS == status)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        TRUE,
                                        FALSE);
  }
#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        TRUE,
                                        FALSE);

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  return status;
} /* end rrcllc_rrc_conn_setup_ie() */


  /*====================================================================
FUNCTION: rrcllc_rrc_conn_setup_ie_r5()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in R5 RRC Connection Setup Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rrc_conn_setup_ie_r5
(
  rrc_RRCConnectionSetup_r5_IEs *msg_ptr
)
{
  /* local loop variable */
  uint8                           idx;

  /* Local count of # of SRB's to setup */
  uint8                           srb_cnt = 0;

  /* Local SRB Value */
  rrc_RB_Identity                      rb_id = CCCH_RADIO_BEARER_ID;

  /* local SRB to setup list pointer */
  rrc_SRB_InformationSetupList2   * srb_setup_ptr = NULL;

  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList * ul_trch_add_reconfig_ptr = NULL;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r4 * dl_trch_add_reconfig_ptr = NULL;

  rrc_UL_CommonTransChInfo_r4* ul_common_tr_ch_info_ptr = NULL; 

  rrc_DL_CommonTransChInfo_r4* dl_common_tr_ch_info_ptr = NULL;  

  /* Local C_RNTI value */
  rrc_int_c_rnti_type             c_rnti;
  rrcrb_directed_cell_info_type          directed_cell_info;

  boolean            predefined_config_ul_common_tr_info = FALSE;
  rrc_SysInfoType16            *sib16_ptr = NULL;
  rrc_UL_CommonTransChInfo            *default_ul_common_tr_ch_info_ptr = NULL;
  rrc_DL_CommonTransChInfo            *default_dl_common_tr_ch_info_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList  *   default_dl_trch_add_reconfig_ptr = NULL;

  boolean dc_with_srb5 = FALSE;

  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;
#ifdef FEATURE_WCDMA_HS_FACH
  uecomdef_status_e_type          status = SUCCESS;
#endif

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* Later on, we will check to make sure both of these parameters
     are present when going from a non-DCH state to DCH. */
 /* const uint32 dl_dpch_mask =
   rrc_RRCConnectionSetup_r5_IEs,dl_CommonInformation |
   rrc_RRCConnectionSetup_r5_IEs,dl_InformationPerRL_List;
*/
  /************************************************************/
  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /************************************************************/

  /* We do not handle Cell_PCH and URA_PCH states at present */
  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH)
  {
    WRRC_MSG0_ERROR("CELL_PCH state transition invalid!");
    return FAILURE;
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_ura_PCH)
  {
    WRRC_MSG0_ERROR("URA_PCH state transition invalid");
    return(FAILURE);
  }

  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  rrcllc_init_before_msg_processing();

  /* Assume that the default is now, i.e. the current SFN */
  MSG_MED("Activation Time is Now!",0,0,0);
  ordered_config_ptr->activation_time = RRCLLC_ACTIVATION_TIME_NOW;
  ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_NONE;


  /* Indicate to MAC that only have a valid U_RNTI, and to use in MAC header */
  rrc_translate_urnti(&msg_ptr->new_U_RNTI, &ordered_config_ptr->mac_ul_parms.rnti_info.urnti);
  ordered_config_ptr->mac_dl_parms.rnti_info.urnti = 
    ordered_config_ptr->mac_ul_parms.rnti_info.urnti;
  ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
  ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;

  /* Get the C-RNTI */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r5_IEs,new_c_RNTI) &&
     (msg_ptr->rrc_StateIndicator != rrc_RRC_StateIndicator_cell_DCH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_c_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
    ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
  }

  /* Get the RRC State Indicator */
  switch(msg_ptr->rrc_StateIndicator)
  {
    case rrc_RRC_StateIndicator_cell_DCH:
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
      break;

    case rrc_RRC_StateIndicator_cell_FACH:
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_FACH;
      /* For Cell_FACH state, use the new U_RNTI (in the message) to
       * select SCCPCH and update SCCPCH, PCH and FACH related info.
       */ 
      if(rrcllc_copy_sccpch_info_from_sib_to_oc_in_connected_mode(rrc_get_state(), RRC_STATE_CELL_FACH)
          == FAILURE)
      {
        WRRC_MSG0_ERROR("Failure to update OC from SIB");
        return(FAILURE);
      }
      break;

    default:
      WRRC_MSG1_ERROR("RRC State %d not supported",msg_ptr->rrc_StateIndicator);
      return FAILURE;
  } /* end RRC State indicator */


  /* Get the UTRAN DRX cycle length coefficient */
  if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
     (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
    )
  {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);

  }
  else
  {
    WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
              msg_ptr->utran_DRX_CycleLengthCoeff);
    return FAILURE;
  } /* end UTRAN DRX cycle length coefficient */

  switch(msg_ptr->specificationMode.t)
  {
    case T_rrc_RRCConnectionSetup_r5_IEs_specificationMode_complete:
      /* Store the complete configuration pointers locally */
      if (msg_ptr->specificationMode.u.complete.m.dl_AddReconfTransChInfoListPresent)
        
      {
        dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
      } 

      if (msg_ptr->specificationMode.u.complete.m.ul_AddReconfTransChInfoListPresent)
      { 
        ul_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList;
      } 
  
      if (msg_ptr->specificationMode.u.complete.m.ul_CommonTransChInfoPresent)
      { 
        ul_common_tr_ch_info_ptr = &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo;
      } 
  
      if (msg_ptr->specificationMode.u.complete.m.dl_CommonTransChInfoPresent)
      { 
        dl_common_tr_ch_info_ptr = &msg_ptr->specificationMode.u.complete.dl_CommonTransChInfo;
      } 

      /* Get the SRB setup list */
      srb_setup_ptr = &msg_ptr->specificationMode.u.complete.srb_InformationSetupList;
      break;


    case T_rrc_RRCConnectionSetup_r5_IEs_specificationMode_preconfiguration:

      if(rrcrce_get_rbs_ptr() != NULL)
      {
        if(rrcllc_process_preconfiguration_with_srb5_rrc_conn_setup(msg_ptr->rrc_StateIndicator) == FAILURE)
        {
          WRRC_MSG0_ERROR("Failed while processing DC with SRB5 i.e. R5 RBS");
          return FAILURE;
        }
        dc_with_srb5 = TRUE;
        WRRC_MSG0_HIGH("Finished processing DC with SRB5 in R5 RCE");		
      }
      else
      {
        /* Store the default configuration pointers locally */
        if((sib16_ptr = rrcrce_get_sib16_ptr()) == NULL)
        { 
          WRRC_MSG0_ERROR("Failed to get SIB16 information.");
          return FAILURE;
        } 
  
        default_dl_trch_add_reconfig_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.dl_TrChInfoList;
        ul_trch_add_reconfig_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.ul_AddReconfTrChInfoList;
        default_ul_common_tr_ch_info_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.ul_CommonTransChInfo;
        default_dl_common_tr_ch_info_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.dl_CommonTransChInfo;
  
        /* Get the SRB setup list */
        /*lint -e740 */
        srb_setup_ptr = (rrc_SRB_InformationSetupList2 *)&sib16_ptr->preDefinedRadioConfiguration.predefinedRB_Configuration.srb_InformationList;
        /*lint +e740 */
      }
      break;


    default:
      WRRC_MSG0_HIGH("Invalid specificationMode");
      return FAILURE;
  }

  if(dc_with_srb5 == FALSE)
  {

    /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
       meant for use when we do transition to Cell_DCH state.  If that's the case, store
       it in the TOC and it will be copied into OC at the appropriate time. */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
    {
      /* If the TOC isn't valid, we must make it valid now. */
      if(transition_config.toc_usage == TOC_INVALID)
      {
        transition_config.toc_usage = TOC_FOR_DCH;
      }
      tmp_config_ptr = ordered_config_ptr;
      ordered_config_ptr = transition_config.toc_ptr;
      /* Processing functions must think we are going to Cell_DCH state. */
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }

    /* Call these functions ONLY in DCH state */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Here, update the transport channel info (only transport channel IDs 
       * and count) and rearrange the info by sorting transport channel list
       * based on TrCH ID.
       */
      if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                        NULL)
         == FAILURE)
      {
        dch_ie_processing_status = FAILURE;
      }
    
      if((dch_ie_processing_status == SUCCESS) && 
         (RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
          rrc_RRCConnectionSetup_r5_IEs_specificationMode_complete)))
      {
        if(rrcllc_add_delete_and_arrange_dl_dch_trch_info2_r5(dl_trch_add_reconfig_ptr,
                                                        NULL)
         == FAILURE)
        { 
          dch_ie_processing_status = FAILURE;
        } 
      } 
      else
      { 
        if((dch_ie_processing_status == SUCCESS) && 
           (rrcllc_add_delete_and_arrange_dl_dch_trch_info(default_dl_trch_add_reconfig_ptr,NULL) == FAILURE))
        { 
          dch_ie_processing_status = FAILURE;
        } 
      } 
    }
    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    if(tmp_config_ptr)
    {
      ordered_config_ptr = tmp_config_ptr;
      tmp_config_ptr = NULL;
    }

  
    if (dch_ie_processing_status == FAILURE) 
    {
      return FAILURE;
    }
  
    if (srb_setup_ptr == NULL)
    {
      WRRC_MSG0_ERROR("SRB Setup Ptr NULL");
      return FAILURE;
    }
  
   
  
    while((srb_setup_ptr->n > srb_cnt) && (srb_cnt < UE_MAX_SRB_SETUP))
    {
      /* Check to see if the RB ID is there ... */
      if(srb_setup_ptr->elem[srb_cnt].m.rb_IdentityPresent)
      {
        rb_id = srb_setup_ptr->elem[srb_cnt].rb_Identity;
      }
  
      /*
      * ... if not, then start with the first SRB and get the next SRB ID
      * each time one is not included in the IE.
      */
      else
      {
        /* Get the next SRB, note this increments to 1 the first time */
        rb_id++;
      }
  
      /* Save off the RB Mapping info for each SRB */
      if(get_srb_info_to_setup(&srb_setup_ptr->elem[srb_cnt], srb_setup_ptr, rb_id)
         == FAILURE)
      {
        return FAILURE;
      }
  
      srb_cnt++;
    } /* end SRB setup */
  
    if (FAILURE == rrcllc_validate_rb_mapping_info()) 
    {
      return FAILURE;
    }
  

    /* We might receive TrCH info even if the next state isn't Cell_DCH.
     * This info is meant for use when we do transition to Cell_DCH state.
     * If that's the case, store it in the TOC and it will be copied into OC
     * at the appropriate time. */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
    {
      tmp_config_ptr = ordered_config_ptr;
      ordered_config_ptr = transition_config.toc_ptr;
      /* Processing functions must think we are going to Cell_DCH state. */
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }

    /* Get the Common Uplink Transport Channel information */
    if((ul_common_tr_ch_info_ptr != NULL) 
       || (default_ul_common_tr_ch_info_ptr != NULL)
       )
    {
      if(RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
	  	rrc_RRCConnectionSetup_r5_IEs_specificationMode_complete))
      { 
        if(get_ul_info_common_for_all_trch_r5(ul_common_tr_ch_info_ptr, 
                                         ordered_config_ptr->rrc_state_indicator)
          == FAILURE)
        { 
          dch_ie_processing_status = FAILURE;
        } 
      } 
      else
      { 
        predefined_config_ul_common_tr_info = TRUE;
        if(get_ul_info_common_for_all_trch(default_ul_common_tr_ch_info_ptr, 
                                         ordered_config_ptr->rrc_state_indicator)
          == FAILURE)
        { 
          dch_ie_processing_status = FAILURE;
        } 
      } 
    } /* end UL Common TrCH Info */
  
    /* Do the processing for Uplink added/reconfigured TrCH, Compute
     * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
     * (for Cell FACH state), this check for state needs to be re-examined
     */
  
    ul_trch_add_reconfig_ptr = NULL;
  
    if((dch_ie_processing_status == SUCCESS) && 
       (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      if(RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
	  	rrc_RRCConnectionSetup_r5_IEs_specificationMode_complete))
      {
        if (msg_ptr->specificationMode.u.complete.m.ul_AddReconfTransChInfoListPresent)
        { 
          ul_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList;
        } 
      }
      else
      {
        /*lint -save -e613 */
        ul_trch_add_reconfig_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.ul_AddReconfTrChInfoList;
        /*lint -restore */
      }
  
      idx = 0;
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) && 
            (idx <= UE_MAX_TRCH) && (ul_trch_add_reconfig_ptr != NULL) &&
            (ul_trch_add_reconfig_ptr->n > idx ))
      {
        if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
    
        /* get next TrCH Info */
        idx++;
        
      } /* end UL TrCH Add/Reconfig */
      
      /* Check to make sure UL TFS count is within UE Capabilities */
      if((dch_ie_processing_status == SUCCESS) && 
         (rrcllc_check_ul_tfs_cnt() == FAILURE))
      {
        dch_ie_processing_status = FAILURE;
      }
#ifdef FEATURE_VOC_AMR_WB
      ordered_config_ptr->ul_tfcs.orderd_codec_mode = MVS_MODE_NONE;
#endif/*FEATURE_VOC_AMR_WB*/
    
      /* Calculate the UL TFCS for the DCH */
      if((dch_ie_processing_status == SUCCESS) && 
         ((msg_ptr->specificationMode.u.complete.m.ul_CommonTransChInfoPresent) || 
          (predefined_config_ul_common_tr_info == TRUE)))
      {
        compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
  
        if(predefined_config_ul_common_tr_info)
        {
          /* There is no scope for TFC subset IE in default configurations as of now.
             Code is written keeping future scope in view 
             Presently default configurations we support map to SIB16  structures
             which is same for Rel99 & Rel5 */
          if(RRC_MSG_COMMON_BITMASK_IE_PTR(default_ul_common_tr_ch_info_ptr,
		  	rrc_UL_CommonTransChInfo,tfc_Subset))
          {
            if(rrcllc_update_oc_with_tfc_subset(default_ul_common_tr_ch_info_ptr, MSG_REL99) == FAILURE)
            {
              dch_ie_processing_status = FAILURE;
            }
          }
        }
        else
        {
          if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
		  	 rrc_UL_CommonTransChInfo_r4,tfc_Subset))
          {
            if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo, MSG_REL5) == FAILURE)
            {
              dch_ie_processing_status = FAILURE;
            }
          }
  
          if((dch_ie_processing_status == SUCCESS) && 
             (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
              tfc_SubsetList)))
          {
            if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo) == FAILURE)
            {
              dch_ie_processing_status = FAILURE;
            } 
          } 
        }

      }
    } /* If state is Cell_DCH */
    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    if(tmp_config_ptr)
    {
      ordered_config_ptr = tmp_config_ptr;
      tmp_config_ptr = NULL;
    }

  
    if (dch_ie_processing_status == FAILURE) 
    {
      return FAILURE;
    }
  
    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
       !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                       ordered_config_ptr->rrc_state_indicator)
          == FAILURE)
      {
        return FAILURE;
      }
    }

  

    /* We might receive TrCH info even if the next state isn't Cell_DCH.
     * This info is meant for use when we do transition to Cell_DCH state.
     * If that's the case, store it in the TOC and it will be copied into OC
     * at the appropriate time. */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
       ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
    {
      tmp_config_ptr = ordered_config_ptr;
      ordered_config_ptr = transition_config.toc_ptr;
      /* Processing functions must think we are going to Cell_DCH state. */
      ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
    }

    /* Get the Common Downlink Transport Channel information */
    if(dl_common_tr_ch_info_ptr != NULL 
        || (default_dl_common_tr_ch_info_ptr != NULL)
      ) 
    {
      if(RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
	  	rrc_RRCConnectionSetup_r5_IEs_specificationMode_complete))
      { 
        if(get_dl_info_common_for_all_trch_r5(dl_common_tr_ch_info_ptr,
                                         ul_common_tr_ch_info_ptr,
                                         ordered_config_ptr->rrc_state_indicator
                                        )
          == FAILURE)
        { 
          dch_ie_processing_status = FAILURE;
        } 
      } 
      else
      {
        if(get_dl_info_common_for_all_trch(default_dl_common_tr_ch_info_ptr,
                                         default_ul_common_tr_ch_info_ptr,
                                         ordered_config_ptr->rrc_state_indicator
                                        )
          == FAILURE)
        { 
          dch_ie_processing_status = FAILURE;
        } 
      }
    } /* end DL Common TrCH Info */
  
    dl_trch_add_reconfig_ptr = NULL;
    
    default_dl_trch_add_reconfig_ptr = NULL;
    
    if((dch_ie_processing_status == SUCCESS) && 
       (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      /* Get the DL Added or Reconfigured Transport Channel information */
      idx = 0;
  
      /* Store the complete configuration pointers locally */
      if(RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
	  	rrc_RRCConnectionSetup_r5_IEs_specificationMode_complete))
      {
        if(msg_ptr->specificationMode.u.complete.m.dl_AddReconfTransChInfoListPresent) 
          
        { 
          dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
        } 
      }
      else
      {
        /*lint -save -e613 */
        default_dl_trch_add_reconfig_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.dl_TrChInfoList;
        /*lint -restore */
      }
  
      if(RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
	  	rrc_RRCConnectionSetup_r5_IEs_specificationMode_complete))
      {
        if(msg_ptr->specificationMode.u.complete.m.ul_AddReconfTransChInfoListPresent) 
        { 
          ul_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList;
        } 
      } 
      else
      {
        /*lint -save -e613 */
        ul_trch_add_reconfig_ptr = &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.ul_AddReconfTrChInfoList;
        /*lint -restore */
      }
      
      /* Save info for each additional Transport Channel */
      if(RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
	  	rrc_RRCConnectionSetup_r5_IEs_specificationMode_complete))
      {
        while((dch_ie_processing_status == SUCCESS) && 
              (idx <= UE_MAX_TRCH) && (dl_trch_add_reconfig_ptr != NULL) &&
              (dl_trch_add_reconfig_ptr->n > idx))
        {
          if(get_dl_added_reconfig_trch_2_r5(&dl_trch_add_reconfig_ptr->elem[idx],
                                      ul_trch_add_reconfig_ptr)
                                      
             == FAILURE)
          {
            dch_ie_processing_status = FAILURE;
          }
  
          /* get next TrCH Info */
          idx++;
   
        } /* end DL TrCH Add/Reconfig */
      } 
      else
      { 
        while((dch_ie_processing_status == SUCCESS) && 
              (idx <= UE_MAX_TRCH) && (default_dl_trch_add_reconfig_ptr != NULL) &&
              (default_dl_trch_add_reconfig_ptr->n > idx))
        { 
          if(get_dl_added_reconfig_trch(&default_dl_trch_add_reconfig_ptr->elem[idx],
                                        ul_trch_add_reconfig_ptr, FALSE)
             
             == FAILURE)
          { 
            dch_ie_processing_status = FAILURE;
          } 
          
          /* get next TrCH Info */
          idx++;
          
        } /* end DL TrCH Add/Reconfig */
      } 
    
      /* Adjust TB size on every TrCH if necessary. */ 
      for (idx=0; (dch_ie_processing_status == SUCCESS) && (idx < UE_MAX_TRCH); idx++)
      {
        /* The number of logical channel mapped to this transport channel 
           increases from 1 to 2. Needs to adjsut the tb_szie to
           reflect the adding of the MAC header.                         */
        if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
            (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
             ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
        {
          boolean trch_search_result = FALSE;
  
          /* TrCH ID is appeared in the TrCH info table. */
          if(RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
		  	rrc_RRCConnectionSetup_r5_IEs_specificationMode_complete))
          { 
            trch_search_result = find_trch_id_in_config_trch_list_r4(&msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
                                                ordered_config_ptr->dl_dch_trch_info[idx].trch_id);
          } 
          else
          { 
            /*lint -save -e613 */
            trch_search_result = find_trch_id_in_config_trch_list(&sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration.dl_TrChInfoList, 
                                                                  ordered_config_ptr->dl_dch_trch_info[idx].trch_id);
            /*lint -restore */
          } 
         
          if (!trch_search_result)
          {
            /* Added MAC head size to the current TB size.  */
            rrcllc_update_tb_size_for_dch(idx);
          }
          /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
          WRRC_MSG0_HIGH("Clean TB size adjust flag in RRCConn");
          ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
          ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
        }
        else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
        {
          /* Since the activated transport channels are sorted before stored in
             the memory, break the looping after reaching the 1st invalid block.  */
          break;
        }
      }
  
      
      /* Check to make sure DL TFS count is within UE Capabilities */
      if((dch_ie_processing_status == SUCCESS) && 
         (rrcllc_check_dl_tfs_cnt() == FAILURE))
      {
        dch_ie_processing_status = FAILURE;
      }
    } /* If state is Cell_DCH */
    /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
    if(tmp_config_ptr)
    {
      ordered_config_ptr = tmp_config_ptr;
      tmp_config_ptr = NULL;
    }

  
    if (dch_ie_processing_status == FAILURE) 
    {
      return FAILURE;
    }
  }/* dc_with_srb5 == FALSE*/
  
  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_RRCConnectionSetup_r5_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
          msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r5_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if((ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH) &&
     (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r5_IEs,ul_ChannelRequirement)))
  {
    /* Check to see if this is DPCH or CPCH */
    switch(msg_ptr->ul_ChannelRequirement.t)
    {
      case T_rrc_UL_ChannelRequirement_r4_ul_DPCH_Info:
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
           
          if(get_ul_dpch_info_per_r4_rrc_connection(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
          {
            return FAILURE;
          } 
        }
        break;

      case T_rrc_UL_ChannelRequirement_r4_dummy:
        WRRC_MSG0_ERROR("UL CPCH info not supported for RRC Conn Setup");
        return FAILURE;

      default:
        WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in RRC Conn Setup",
                  msg_ptr->ul_ChannelRequirement.t);
        return FAILURE;
    }
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
          current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No UL Ch Req, RRC ConnSetup state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  } /* end if state is Cell DCH && check for UL Channel Requirement */

  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r5_IEs,dl_CommonInformation) &&
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r5_IEs,dl_InformationPerRL_List)) &&
     current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No DL DPCH, RRC Conn Setup state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }

  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Initialize the L1 bitmask for the parameters in the "Downlink
     * information for all radio links" IE.  Since the IE is optional,
     * we want to make sure we don't signal L1 erroneously that we have
     * received information when we haven't.
     */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
   rrcllc_init_dl_common_info(ordered_config_ptr);

   if (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) 
   {
     ordered_config_ptr->is_hho = TRUE;
   }

   if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r5_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl_per_r4_rrc_connection(&msg_ptr->dl_CommonInformation,
                                       &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                       &ordered_config_ptr->l1_dl_cctrch_parms,
                                       &ordered_config_ptr->l1_dl_ctfc_parms
                                      ) == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL Common RL */
  } /* If next state is Cell_DCH */

  /* Calculate the TFIs from CTFCs and restrict CTFCs based on the RM restricted info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms
                            );

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_RRCConnectionSetup_r5_IEs,dl_InformationPerRL_List))
  {
    if(get_dl_info_per_rl_r5_per_rrc_connection(&msg_ptr->dl_InformationPerRL_List,
        msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }
  
  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
    == FAILURE)
  { 
    return FAILURE;
  }

  if(rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }


  if (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)) 
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(SUCCESS == status)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        TRUE,
                                        FALSE);
  }
#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        TRUE,
                                        FALSE);

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/


  return status;
} /* end rrcllc_rrc_conn_setup_ie_r5() */



/*====================================================================
FUNCTION: rrcllc_trch_reconfig_ie()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Transport Channel Reconfiguration Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_trch_reconfig_ie
(
  rrc_DL_DCCH_Message *dcch_ptr
)
{
  /* local loop variable */
  uint8                            idx;
#ifdef FEATURE_WCDMA_HS_FACH
  uecomdef_status_e_type   status = SUCCESS;
#endif

  rrc_TransportChannelReconfiguration_r3_IEs *msg_ptr = &dcch_ptr->message.u.transportChannelReconfiguration.u.r3.transportChannelReconfiguration_r3;
  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList  * ul_trch_add_reconfig_ptr = NULL;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList  * dl_trch_add_reconfig_ptr = NULL;

  /* Local C_RNTI value */
  rrc_int_c_rnti_type              c_rnti;

  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;
  rrcrb_directed_cell_info_type          directed_cell_info;

  /* Later on, we will check to make sure both of these parameters
     are present when going from a non-DCH state to DCH. */
     /*
  const uint32 dl_dpch_mask =
   rrc_TransportChannelReconfiguration_r3_IEs,dl_CommonInformation |
   rrc_TransportChannelReconfiguration_r3_IEs,dl_InformationPerRL_List;
*/
  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /* Ignore the Integrity Protection and Ciphering IEs */
  rrcllc_init_before_msg_processing();
  


  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

   /* Get the U-RNTI */
   if(FAILURE == rrcllc_update_urnti_in_oc(
                   RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,new_U_RNTI),
                   &msg_ptr->new_U_RNTI,
                   msg_ptr->rrc_StateIndicator))
   {
     return FAILURE;
   }

  /* Get the C-RNTI only if next state is CELL_FACH. We do not need it for
   any other state */
  if((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,new_C_RNTI)) &&
   (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_C_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
  }  /* If new CRNTI present */
  
#ifdef FEATURE_WCDMA_HS_RACH
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH) &&
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,new_C_RNTI)))
  {
    rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
  }
#endif
  /* If transitioning from CELL_DCH to CELL_FACH, delete the C-RNTI.
   * The procedure will update C-RNTI later.
   */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH) &&
     (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = rrcllc_check_delay_restriction_ie_trch_reconfig(dcch_ptr);
#endif

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,activationTime)),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_TCR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /* Get the RRC State Indicator */
  if(FAILURE == rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }


  /* Get the UTRAN DRX cycle length coefficient */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,utran_DRX_CycleLengthCoeff)) 
  {
    if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
       (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length =
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);

    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
                msg_ptr->utran_DRX_CycleLengthCoeff);
      return FAILURE;
    }
  } /* end UTRAN DRX Cycle Length indicator */

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,dl_AddReconfTransChInfoList))
  {
    dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,ul_AddReconfTransChInfoList))
  {
    ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                      NULL)
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info(dl_trch_add_reconfig_ptr, NULL)== FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  }
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Get the Common Uplink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,ul_CommonTransChInfo))
  {
    if(get_ul_info_common_for_all_trch(&msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */
  if((dch_ie_processing_status == SUCCESS) &&
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,ul_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) &&
            (idx <= UE_MAX_TRCH) && 
            (ul_trch_add_reconfig_ptr->n > idx))
      {
        if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
  
        /* get next TrCH Info */
        idx++;
 
      } /* end while */
    } /* end UL TrCH Add/Reconfig */

    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }  
    /* Calculate the UL TFCS */
    if((dch_ie_processing_status == SUCCESS) &&
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,rrc_UL_CommonTransChInfo,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL99) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
      }

    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      return FAILURE;
    }
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.
   * This info is meant for use when we do transition to Cell_DCH state.
   * If that's the case, store it in the TOC and it will be copied into OC
   * at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Get the Common Downlink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,dl_CommonTransChInfo))
  {
    if(get_dl_info_common_for_all_trch(&msg_ptr->dl_CommonTransChInfo,
                                       &msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator
                                      )
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }

  if((dch_ie_processing_status == SUCCESS) &&
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,dl_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) &&
            (idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL && 
            (dl_trch_add_reconfig_ptr->n > idx))
      {
        if(get_dl_added_reconfig_trch(&dl_trch_add_reconfig_ptr->elem[idx],
                                      ul_trch_add_reconfig_ptr,
                                      /* RRC Connection Setup doesn't allowed TM signalling DCCH */
                                      FALSE
                                     )
            == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
  
        /* get next TrCH Info */
        idx++;

      } /* end while */
    } /* end DL TrCH Add/Reconfig */

    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) &&
       (rrcllc_check_dl_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_TransportChannelReconfiguration_r3_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
          msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,ul_ChannelRequirement))
  {
    /* Check to see if this is DPCH or CPCH */
    switch(msg_ptr->ul_ChannelRequirement.t)
    {
      case T_rrc_UL_ChannelRequirement_ul_DPCH_Info:
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          if(get_ul_dpch_info(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        break;

      case T_rrc_UL_ChannelRequirement_dummy:
        WRRC_MSG0_ERROR("UL CPCH info not supported for TrCH Recfg");
        return FAILURE;

      default:
        WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in TrCH Recfg",
                  msg_ptr->ul_ChannelRequirement.t);
        return FAILURE;
    }
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
          current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No UL Chan Req, TrCH Recfg state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  } /* end if check for UL Channel Requirement */

  WRRC_MSG1_HIGH(" TCRC R3 Mode specific info FDD %d",msg_ptr->modeSpecificPhysChInfo.t);
  
  /* Ignore PDSCH IEs */
  switch(msg_ptr->modeSpecificPhysChInfo.t)
  {
    case T_rrc_TransportChannelReconfiguration_r3_IEs_modeSpecificPhysChInfo_fdd:
      break;

    case T_rrc_TransportChannelReconfiguration_r3_IEs_modeSpecificPhysChInfo_tdd:
      break;

    default:
      return FAILURE;
  } /* end PDSCH check */

  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,dl_CommonInformation)) &&
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,dl_InformationPerRL_List)))&&
     current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
    WRRC_MSG2_ERROR("No DL DPCH, RRC Conn Setup state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }

  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Initialize the L1 bitmask for the parameters in the "Downlink
     * information for all radio links" IE.  Since the IE is optional,
     * we want to make sure we don't signal L1 erroneously that we have
     * received information when we haven't.
     */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);

    if(FAILURE == rrcllcpcie_is_hho((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
                            rrc_TransportChannelReconfiguration_r3_IEs,dl_InformationPerRL_List)),
                            &msg_ptr->dl_InformationPerRL_List,
                            msg_ptr->rrc_StateIndicator))
    {
        return FAILURE;
    }

    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r3_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl(&msg_ptr->dl_CommonInformation,
                                       &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                       &ordered_config_ptr->l1_dl_cctrch_parms,
                                       &ordered_config_ptr->l1_dl_ctfc_parms
                                      )
         == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
  } /* If next state is Cell_DCH */

  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms
                            );

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_TransportChannelReconfiguration_r3_IEs,dl_InformationPerRL_List))
  {
    if(get_dl_info_per_rl(&msg_ptr->dl_InformationPerRL_List,
        msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    /* Determine HSDPA Action */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Set HSDPA Action */
      if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
      {
        rrcllc_set_r99_hsdpa_action();


        if(rrcllc_is_cm_active_with_hsdpa_r99())
        {
          return FAILURE;
        }
      }
    } /* If next state is Cell_DCH */ 
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
    == FAILURE)
  { 
    return FAILURE;
  }
  
  if(rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }

  if (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)) 
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }
  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

#ifdef FEATURE_WCDMA_HS_FACH
  if(SUCCESS == status)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        FALSE);
  }
#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        FALSE);

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL99);

#ifdef FEATURE_WCDMA_DC_HSUPA
  if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)== FAILURE)
  {
    status = FAILURE;
  }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return status;

} /* end rrcllc_trch_reconfig_ie() */


/*====================================================================
FUNCTION: rrcllc_trch_reconfig_ie_r5()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Release 5 Transport Channel Reconfiguration Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_trch_reconfig_ie_r5
(
  rrc_DL_DCCH_Message *dcch_ptr 
)
{
  /* local loop variable */
  #ifdef FEATURE_WCDMA_HS_FACH
  uecomdef_status_e_type          status = SUCCESS;
#endif

  rrc_TransportChannelReconfiguration_r5_IEs *msg_ptr =
   &dcch_ptr->message.u.transportChannelReconfiguration.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.r5.transportChannelReconfiguration_r5;
  uint8                            idx;

  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList  * ul_trch_add_reconfig_ptr = NULL;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r5  * dl_trch_add_reconfig_ptr = NULL;

  /* Local C_RNTI value */
  rrc_int_c_rnti_type              c_rnti;

  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* Later on, we will check to make sure both of these parameters
     are present when going from a non-DCH state to DCH. */
     /*
  const uint32 dl_dpch_mask =
   rrc_TransportChannelReconfiguration_r5_IEs,dl_CommonInformation |
   rrc_TransportChannelReconfiguration_r5_IEs,dl_InformationPerRL_List;
*/
  rrcllc_init_before_msg_processing();
  
  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /* Ignore the Integrity Protection and Ciphering IEs */



  /* We're processing a reconfiguration message now, so set the
     reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

   /* Get the U-RNTI */
  if(FAILURE == rrcllc_update_urnti_in_oc(
                  RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,new_U_RNTI),
                  &msg_ptr->new_U_RNTI,
                  msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the C-RNTI */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,new_C_RNTI) &&
     (msg_ptr->rrc_StateIndicator != rrc_RRC_StateIndicator_cell_DCH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_C_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
    
#ifdef FEATURE_WCDMA_HS_RACH
    if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH)
    {
      rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
    }
#endif
  }  /* If new CRNTI present */
  /* If transitioning from CELL_DCH to CELL_FACH, delete the C-RNTI.
   * The procedure will update C-RNTI later.
   */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH) &&
     (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = rrcllc_check_delay_restriction_ie_trch_reconfig_r5(dcch_ptr);
#endif

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,activationTime)),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_TCR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /* Get the RRC State Indicator */
  if(FAILURE == rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the UTRAN DRX cycle length coefficient */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,utran_DRX_CycleLengthCoeff)) 
  {
    if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
       (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      /* This is only for PS per 25.304. CS only arrives in SIB 1 */
      ordered_config_ptr->ps_drx_cycle_length = 
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);

    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
                msg_ptr->utran_DRX_CycleLengthCoeff);
      return FAILURE;
    }
  } /* end UTRAN DRX Cycle Length indicator */

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,dl_AddReconfTransChInfoList))
  {
    dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,ul_AddReconfTransChInfoList))
  {
    ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
  }

  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                      NULL)
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(dl_trch_add_reconfig_ptr,NULL) == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  }
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Get the Common Uplink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,ul_CommonTransChInfo))
  {
    if(get_ul_info_common_for_all_trch_r5(&msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }


  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */
  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,ul_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) && 
            (idx <= UE_MAX_TRCH) && 
            (ul_trch_add_reconfig_ptr->n > idx))
      {
        if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
  
        /* get next TrCH Info */
        idx++;
    
      } /* end while */
    } /* end UL TrCH Add/Reconfig */

    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }  
    /* Calculate the UL TFCS */
    if((dch_ie_processing_status == SUCCESS) && 
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL5) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
      }

      if((dch_ie_processing_status == SUCCESS) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
      }
    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      return FAILURE;
    }
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Get the Common Downlink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,dl_CommonTransChInfo))
  {
    if(get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
                                       &msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator
                                      )
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }


  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,dl_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) && 
            (idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL && 
            (dl_trch_add_reconfig_ptr->n > idx))
      {
        if(get_dl_added_reconfig_trch_r5(&dl_trch_add_reconfig_ptr->elem[idx],
                                      ul_trch_add_reconfig_ptr,
                                      /* RRC Connection Setup doesn't allowed TM signalling DCCH */
                                      FALSE
                                     )
            == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
  
        /* get next TrCH Info */
        idx++;
      } /* end while */
    } /* end DL TrCH Add/Reconfig */

    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_dl_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If state is Cell_DCH */
  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_TransportChannelReconfiguration_r5_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
          msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,ul_ChannelRequirement))
  {
    /* Check to see if this is DPCH or CPCH */
    switch(msg_ptr->ul_ChannelRequirement.t)
    {
      case T_rrc_UL_ChannelRequirement_ul_DPCH_Info:
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          if(get_ul_dpch_info_r5(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        break;

      case T_rrc_UL_ChannelRequirement_dummy:
        WRRC_MSG0_ERROR("UL CPCH info not supported for TrCH Recfg");
        return FAILURE;

      default:
        WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in TrCH Recfg",
                  msg_ptr->ul_ChannelRequirement.t);
        return FAILURE;
    }
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
          current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
   WRRC_MSG2_ERROR("No UL Chan Req, TrCH Recfg state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  } /* end if check for UL Channel Requirement */

  WRRC_MSG1_HIGH(" TCRC R5 Mode specific info FDD %d",msg_ptr->modeSpecificPhysChInfo.t);
  
  /* Ignore PDSCH IEs */
  switch(msg_ptr->modeSpecificPhysChInfo.t)
  {
    case T_rrc_TransportChannelReconfiguration_r5_IEs_modeSpecificPhysChInfo_fdd:
      break;

    case T_rrc_TransportChannelReconfiguration_r5_IEs_modeSpecificPhysChInfo_tdd:
      break;

    default:
      return FAILURE;
  } /* end PDSCH check */

  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,dl_CommonInformation)) &&
            (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,dl_InformationPerRL_List)))&&
     current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
   WRRC_MSG2_ERROR("No DL DPCH, RRC Conn Setup state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }

  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Initialize the L1 bitmask for the parameters in the "Downlink
     * information for all radio links" IE.  Since the IE is optional,
     * we want to make sure we don't signal L1 erroneously that we have
     * received information when we haven't.
     */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);

    if(FAILURE == rrcllcpcie_is_hho_r5((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
                              rrc_TransportChannelReconfiguration_r5_IEs,dl_InformationPerRL_List)),
                              &msg_ptr->dl_InformationPerRL_List,
                              msg_ptr->rrc_StateIndicator))
    {
      return FAILURE;
    }

    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl_r5(&msg_ptr->dl_CommonInformation,
                                       &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                       &ordered_config_ptr->l1_dl_cctrch_parms,
                                       &ordered_config_ptr->l1_dl_ctfc_parms
                                      )
         == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
  } /* If next state is Cell_DCH */

  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms
                            );

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_TransportChannelReconfiguration_r5_IEs,dl_InformationPerRL_List))
  {
    if(get_dl_info_per_rl_r5(&msg_ptr->dl_InformationPerRL_List,
        msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }
  if(FAILURE == rrcllc_update_hrnti_in_oc(
                    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,new_H_RNTI), 
                    &msg_ptr->new_H_RNTI,
                    msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }
    /* Get HS Information */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* SET Action Variable by calling HSDPA action table */
    /* First check if HSDPA is already active or is being activated */
    /* Either HSDPA is Active or HSPDSCH info present */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,dl_HSPDSCH_Information))
    {
      hsdpa_msg_params.msg_params_present= TRUE;
      hsdpa_msg_params.hspdsch_info_present= TRUE;
      
    }
    
    /* Determine if IFHHO is involved */
    if ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq()))
    {
      WRRC_MSG0_HIGH("RRCHS:InterFreq HO");
      hsdpa_msg_params.ifhho_involved = TRUE;
      hsdpa_msg_params.msg_params_present= TRUE;
    }
    
    /* Set HSDPA Action & Physical Channel Parameters associated with it */
    if (rrcllc_determine_hsdpa_action(&msg_ptr->dl_HSPDSCH_Information) == SUCCESS)
    {
     rrc_set_hsdpa_action_in_machs_macehs();
     rrcllcpcie_update_hs_tfri_table_type_non_r7_ota();

      MSG_5(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RRCHS:HSDPA Action %d set in MAC CM VAR %d CM status L1/RRC/OTA %d %d %d",
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action,
      hsdpa_cm_enabled,
      l1_cm_query_compressed_mode_active(),
      rrcllc_is_cm_active(ordered_config_ptr),
      cm_status_from_ota_msg
      );

      /* Check if network is trying to activate CM with HSDPA */
      if(rrcllc_is_cm_active_with_hsdpa())
      {
        return FAILURE;
      }
      
    }
    else
    {
      WRRC_MSG0_ERROR("RRCHS:Error during HSDPA action processing");   
      return FAILURE;
    }
    
  } /* If next state is Cell_DCH */

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
    == FAILURE)
  { 
    return FAILURE;
  }

  if(rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }

  if (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)) 
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }


  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }

 #ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_TransportChannelReconfiguration_r5_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        FALSE);
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL5);

#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
      FALSE)== FAILURE)
    {
      status = FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return status;

} /* end rrcllc_trch_reconfig_ie_r5() */



/*====================================================================
FUNCTION: rrcllc_handover_to_utran_ie()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Handover to UTRAN Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_handover_to_utran_ie
(
  rrc_HandoverToUTRANCommand *msg_ptr
)
{
  /* Local copy of SIB16 pointer.  In the case of a default configuration,
     this actually points to data for the specified default configuration,
     not the actual SIB16 data.  That doesn't matter to us, though.  We also
     declare some convenience pointers here to shorten the names of the 
     SIB16 members later on. */
  struct rrc_SysInfoType16            *sib16_ptr = NULL;
  rrc_PredefinedRB_Configuration      *predef_rb = NULL;
  rrc_PreDefTransChConfiguration      *predef_trch = NULL;
  rrc_PreDefPhyChConfiguration        *predef_phych = NULL;
  
  /* Here we collect a bunch of local pointers to major IEs.  We will use
     these later in a processing section that is common for processing
     either a completely specified handover or one that uses preconfigured
     values. */
  rrc_SRB_InformationSetupList   * srb_setup_ptr = NULL;
  rrc_RAB_InformationSetupList    *rab_setup_ptr = NULL;
  rrc_UL_CommonTransChInfo        *ul_common_trans_ch_info_ptr = NULL;
  rrc_DL_CommonTransChInfo        *dl_common_trans_ch_info_ptr = NULL;
  rrc_UL_AddReconfTransChInfoList * ul_trch_add_reconfig_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList * dl_trch_add_reconfig_ptr = NULL;
  rrc_UL_DPCH_Info                *ul_dpch_info_ptr = NULL;
  rrc_DL_CommonInformation        *dl_common_info_ptr = NULL;
  rrc_DL_InformationPerRL_List    * dl_rl_ptr =NULL;

  /* Local pointers and instances for other IEs that are used to hold
     onto list pointers, or for temporary IE construction. */

  rrc_RB_InformationSetupList          *rb_setup_ptr = NULL;

  rrc_RAB_InformationSetupList  tmp_rab_setup_list;
  rrc_UL_DPCH_Info                     tmp_ul_dpch_info;
  rrc_UL_DPCH_InfoPostFDD              *ul_dpch_info_post_ptr = NULL;
  rrc_DL_CommonInformation             tmp_dl_common_info;
  rrc_DL_CommonInformationPost         *dl_common_info_post_ptr = NULL;
  rrc_DL_InformationPerRL_List  tmp_dl_rl;
  rrc_DL_InformationPerRL_ListPostFDD  * dl_rl_post_ptr = NULL;

  uecomdef_status_e_type ret_status = SUCCESS;

  /* Local counters, return values, and other simple scalar types. */
  uint8      idx     = 0; /* Loop index */
  rrc_RB_Identity rb_id   = CCCH_RADIO_BEARER_ID; /* SRB value */
  uint8      srb_cnt = 0; /* Count of SRBs to set up */
  uint8      rab_cnt = 0; /* Count of RABs to set up */
  uint8      rb_cnt  = 0; /* Count of RBs to set up */
  uint16     srnti2  = 0; /* S-RNTI 2 portion of the U-RNTI in the message,
                             used later to calculate the default DPCH offset
                             value in preconfigured mode */
  rrcllcoc_dl_info_per_rl_status_e_type status =
    RRCLLCOC_DL_INFO_PER_RL_IGNORED; /* Return status from DL Info per
                                        RL processing. */

  rrc_U_RNTI_Short *new_urnti_ptr;
  rrc_MaxAllowedUL_TX_Power max_tx_power;
  uint32 mode_specific_choice = T_rrc_HandoverToUTRANCommand_r3_IEs_modeSpecificInfo_1_tdd;
  uint32 specification_choice = T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_preconfiguration; 
  rrc_msg_ver_enum_type  msg_rel_version = MSG_INVALID;

  rrc_SRB_InformationSetupList_r5 *srb_setup_r5_ptr  = NULL;
  rrc_RAB_InformationSetupList_r5 *rab_setup_r5_ptr = NULL;
  rrc_UL_CommonTransChInfo_r4  *ul_common_trans_ch_info_r5_ptr = NULL;
  rrc_DL_CommonTransChInfo_r4 *dl_common_trans_ch_info_r5_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList_r5 *dl_add_reconf_trch_list = NULL;
  rrc_UL_DPCH_Info_r5 *ul_dpch_info_r5_ptr = NULL;
  rrc_DL_CommonInformation_r4 *dl_common_info_r5_ptr = NULL;
  rrc_DL_InformationPerRL_List_r5 *dl_info_per_rl_ptr = NULL;
  rrc_RB_InformationSetupList_r5 * rb_setup_r5_ptr = NULL ;

  rrc_SRB_InformationSetup_r5 * srb5_setup_ptr = NULL;

  rrc_RB_Identity                          srb_id = RRCLLC_INVALID_RB_ID;
  struct rrc_RadioBearerSetup_r5_IEs *rbs_r5_ptr = NULL;
  uint32 default_config_id = RRC_DEF_CONFIG_INVALID;
  void *rbs_ptr = NULL;


  tmp_rab_setup_list.n = 0;
  tmp_rab_setup_list.elem = NULL;


  rrcllc_init_before_msg_processing();

  /* Get the new U-RNTI from the message. */
  if( RRC_CHECK_COMMON_MSG_TYPE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_r3))
  {
    new_urnti_ptr = &msg_ptr->u.r3.handoverToUTRANCommand_r3.new_U_RNTI;
    msg_rel_version = MSG_REL99;
  }
  else if(RRC_CHECK_COMMON_MSG_TYPE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_criticalExtensions) && 
          msg_ptr->u.criticalExtensions.t == T_rrc_HandoverToUTRANCommand_criticalExtensions_4_criticalExtensions
          &&(msg_ptr->u.criticalExtensions.u.criticalExtensions.t == 
            T_rrc_HandoverToUTRANCommand_criticalExtensions_3_r5) )
  {
    new_urnti_ptr = &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.new_U_RNTI;
    msg_rel_version = MSG_REL5;
  }
  else if (RRCRB_R6_CRITICAL_EXT_HO_TO_UTRAN_PRESENT(
           msg_ptr,rrc_HandoverToUTRANCommand, 
           rrc_HandoverToUTRANCommand))
  {
    if (FAILURE == rrcllc_handover_to_utran_ie_r6(
      &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r6))
    {
      WRRC_MSG0_ERROR("RRCEUL: Rel-6 rrc_HandoverToUTRANCommand failed to update OC");
      return FAILURE;
    }
    else
    {
      return SUCCESS;
    }
  }
  else if (RRCRB_R7_CRITICAL_EXT_HO_TO_UTRAN_PRESENT(
           msg_ptr,  rrc_HandoverToUTRANCommand, 
           rrc_HandoverToUTRANCommand))
  {
    if (FAILURE == rrcllc_handover_to_utran_ie_r7(
      &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r7))
    {
      WRRC_MSG0_ERROR("RRCEUL: Rel-6 rrc_HandoverToUTRANCommand failed to update OC");
      return FAILURE;
    }
    else
    {
      return SUCCESS;
    }
  }
  else if (RRCRB_R8_CRITICAL_EXT_HO_TO_UTRAN_PRESENT(
           msg_ptr,  rrc_HandoverToUTRANCommand, 
           rrc_HandoverToUTRANCommand))
  {
    if (FAILURE == rrcllc_handover_to_utran_ie_r8(&msg_ptr->u.criticalExtensions.u.criticalExtensions.u.
        criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8))
    {
      WRRC_MSG0_ERROR("REL8: rrc_HandoverToUTRANCommand failed to update OC");
      return FAILURE;
    }
    else
    {
      return SUCCESS;
    }
  }

#ifdef FEATURE_WCDMA_REL9
  else if (RRCRB_R9_CRITICAL_EXT_HO_TO_UTRAN_PRESENT(
           msg_ptr,  rrc_HandoverToUTRANCommand, 
           rrc_HandoverToUTRANCommand))
  {
    if (FAILURE == rrcllc_handover_to_utran_ie_r9(&msg_ptr->u.criticalExtensions.u.criticalExtensions.u.
        criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.later_r8_criticalExtensions.u.r9))
    {
      WRRC_MSG0_ERROR("REL9: rrc_HandoverToUTRANCommand failed to update OC");
      return FAILURE;
    }
    else
    {
      return SUCCESS;
    }
  }

#endif /* FEATURE_WCDMA_REL9 */

#ifdef FEATURE_WCDMA_REL10
  #error code not present
#endif /* FEATURE_WCDMA_REL10 */


  else
  {
    /* Being very defensive - should have been rejected even before set_ordered_config is called */
    msg_rel_version = MSG_INVALID;
    WRRC_MSG0_ERROR("Message is rejected as it is invalid");
    return FAILURE;
  }

  rrc_translate_urnti_short(new_urnti_ptr,
                            &ordered_config_ptr->mac_ul_parms.rnti_info.urnti);

  ordered_config_ptr->mac_dl_parms.rnti_info.urnti = 
    ordered_config_ptr->mac_ul_parms.rnti_info.urnti;

  ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;

  memset((void *)&max_tx_power, 0, sizeof(rrc_MaxAllowedUL_TX_Power));

  /* Get the maximum allowed UL TX power. */
  if( RRC_CHECK_COMMON_MSG_TYPE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_r3))
  {
    max_tx_power = msg_ptr->u.r3.handoverToUTRANCommand_r3.maxAllowedUL_TX_Power;
  }
  else
  {
    max_tx_power = msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.maxAllowedUL_TX_Power;
  }

  if(get_max_allow_ul_tx_pwr(max_tx_power) == FAILURE)
  {
    return FAILURE;
  }

  /* Extract the specification t from the received message 
     If the specification t is of default type, irrespective of
     it is Rel99 or Rel5 - it is treated the same way as configurations
     0-10 are of same type */
  if( RRC_CHECK_COMMON_MSG_TYPE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_r3))
  {
    specification_choice = msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.t;
  }
  else
  {
    specification_choice = msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.t;
  }

  switch(specification_choice)
  {
    case T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_complete:
      /* Set up our local pointers to point at the information provided in
         the message.  This is all very straightforward, since all the info
         we need comes prepackaged in familiar IEs. */

      if( RRC_CHECK_COMMON_MSG_TYPE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_r3))
      {
        /* Signalling RB information to setup list */
        srb_setup_ptr =
        &msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.complete.srb_InformationSetupList;

        /* RAB information to setup list */
        if(msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.complete.m.rab_InformationSetupListPresent)
        {
          rab_setup_ptr = &msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.complete.rab_InformationSetupList;
        }

        /* UL Transport channel information common for all transport channels */
        ul_common_trans_ch_info_ptr =
          &msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.complete.ul_CommonTransChInfo;

        /* DL Transport channel information common for all transport channels */
        dl_common_trans_ch_info_ptr =
          &msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.complete.dl_CommonTransChInfo;

        /* Added or Reconfigured UL TrCH information */
        ul_trch_add_reconfig_ptr =
          &msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.complete.ul_AddReconfTransChInfoList;

        /* Added or Reconfigured DL TrCH information */
        dl_trch_add_reconfig_ptr =
          &msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.complete.dl_AddReconfTransChInfoList;

        /* Uplink DPCH info */
        ul_dpch_info_ptr =
          &msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.complete.ul_DPCH_Info;

        /* Downlink information common for all radio links */
        dl_common_info_ptr =
          &msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.complete.dl_CommonInformation;

        /* Downlink information per radio link */
        dl_rl_ptr =
          &msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.complete.dl_InformationPerRL_List;
      }
      else
      {
        srb_setup_r5_ptr = &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.complete.srb_InformationSetupList;

        if(msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.complete.m.rab_InformationSetupListPresent)
        {
          rab_setup_r5_ptr = &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.complete.rab_InformationSetupList;
        }

        /* Added or Reconfigured UL TrCH information */
        ul_trch_add_reconfig_ptr = &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.complete.ul_AddReconfTransChInfoList;

         /* UL Transport channel information common for all transport channels */
        ul_common_trans_ch_info_r5_ptr = &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.complete.ul_CommonTransChInfo;

        /* DL Transport channel information common for all transport channels */
        dl_common_trans_ch_info_r5_ptr = &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.complete.dl_CommonTransChInfo;

        /* Added or Reconfigured DL TrCH information */
        dl_add_reconf_trch_list = &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.complete.dl_AddReconfTransChInfoList;

        /* Uplink DPCH info */
        ul_dpch_info_r5_ptr = &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.complete.ul_DPCH_Info;

        /* Downlink information common for all radio links */
        dl_common_info_r5_ptr = &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.complete.dl_CommonInformation;

        /* Downlink information per radio link */
        dl_info_per_rl_ptr = &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.complete.dl_InformationPerRL_List;
      }
      break;

    case T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_preconfiguration:

      if((rbs_ptr = rrciho_get_rbs_ptr(&default_config_id)) != NULL)
      {
        if(msg_rel_version == MSG_REL5)
        {
          rbs_r5_ptr = (rrc_RadioBearerSetup_r5_IEs *) rbs_ptr;
          srb_setup_r5_ptr = &rbs_r5_ptr->srb_InformationSetupList;
          ul_trch_add_reconfig_ptr = &rbs_r5_ptr->ul_AddReconfTransChInfoList;
          ul_common_trans_ch_info_r5_ptr = &rbs_r5_ptr->ul_CommonTransChInfo;
          dl_common_trans_ch_info_r5_ptr = &rbs_r5_ptr->dl_CommonTransChInfo;
          dl_add_reconf_trch_list = &rbs_r5_ptr->dl_AddReconfTransChInfoList;        
        }

        specification_choice = T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_complete;
      }
      else
      { 
       /* Get a pointer to the SIB16 data and set up some shorter aliases for
           the unwieldy member data names. */
        sib16_ptr = rrciho_get_sib16_ptr(); 
        if(sib16_ptr == NULL)
        {
          WRRC_MSG0_ERROR("Failed to get SIB16 information.");
          return FAILURE;
        }
        predef_rb =
          &sib16_ptr->preDefinedRadioConfiguration.predefinedRB_Configuration;
        predef_trch =
          &sib16_ptr->preDefinedRadioConfiguration.preDefTransChConfiguration;
        predef_phych =
          &sib16_ptr->preDefinedRadioConfiguration.preDefPhyChConfiguration;

        /* Set up our local pointers for processing.  This is a little tougher
           than the complete specification case, because now the information we
           need is split up between the incoming message and SIB16, and we must
           make that information come together in familiar IEs in order to use
           existing processing functions. */

        /* Signalling RB information to setup list */
        srb_setup_ptr = &predef_rb->srb_InformationList;
      }

      

      /*lint -e774 */
      if(msg_rel_version == MSG_REL99)
      {
        /* RAB information to setup list */
        if(msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.preconfiguration.m.rab_InfoPresent)
        {
          tmp_rab_setup_list.n = 1;

		  tmp_rab_setup_list.elem = rrc_malloc(sizeof(rrc_RAB_InformationSetup));
		  
          memset(&tmp_rab_setup_list.elem[0].rab_Info.m,0,sizeof(tmp_rab_setup_list.elem[0].rab_Info.m));
          tmp_rab_setup_list.elem[0].rab_Info.cn_DomainIdentity =
            msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.preconfiguration.rab_Info
          .cn_DomainIdentity;

          if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.preconfiguration.rab_Info,
              rrc_RAB_Info_Post,nas_Synchronisation_Indicator))
          {
            tmp_rab_setup_list.elem[0].rab_Info.nas_Synchronisation_Indicator =
              msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.preconfiguration.rab_Info
              .nas_Synchronisation_Indicator;
            tmp_rab_setup_list.elem[0].rab_Info.m.nas_Synchronisation_IndicatorPresent = 1;
          }
          tmp_rab_setup_list.elem[0].rab_Info.rab_Identity =
            msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.preconfiguration.rab_Info.rab_Identity;
          tmp_rab_setup_list.elem[0].rab_Info.re_EstablishmentTimer =
            predef_rb->re_EstablishmentTimer;
          tmp_rab_setup_list.elem[0].rb_InformationSetupList =
            predef_rb->rb_InformationList;
          rab_setup_ptr = &tmp_rab_setup_list;
        }
        
        mode_specific_choice = msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.preconfiguration.modeSpecificInfo.t;

        if(mode_specific_choice == T_rrc_HandoverToUTRANCommand_r3_IEs_modeSpecificInfo_1_fdd)
        {
          ul_dpch_info_post_ptr =
          &msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.preconfiguration.modeSpecificInfo.u
          .fdd.ul_DPCH_Info;

          /* Downlink information common for all radio links */
          dl_common_info_post_ptr =
            &msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.preconfiguration.modeSpecificInfo.u.fdd
            .dl_CommonInformationPost;

          /* Downlink information per radio link */
          dl_rl_post_ptr =
             &msg_ptr->u.r3.handoverToUTRANCommand_r3.specificationMode.u.preconfiguration.modeSpecificInfo.u.fdd
            .dl_InformationPerRL_List;
        }
      }
      /*lint +e774 */
      else
      {
        if(msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.preconfiguration.m.
           rab_InfoPresent)
        {
          tmp_rab_setup_list.elem = rrc_malloc(sizeof(rrc_RAB_InformationSetup));
		  tmp_rab_setup_list.n = 1;
          tmp_rab_setup_list.elem[0].rab_Info.cn_DomainIdentity =
            msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.preconfiguration.rab_Info
            .cn_DomainIdentity;

          if(msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.preconfiguration.rab_Info.m.
            nas_Synchronisation_IndicatorPresent)
          {
            tmp_rab_setup_list.elem[0].rab_Info.nas_Synchronisation_Indicator =
              msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.preconfiguration.rab_Info
            .nas_Synchronisation_Indicator;
            tmp_rab_setup_list.elem[0].rab_Info.m.nas_Synchronisation_IndicatorPresent = 1;
          }
          tmp_rab_setup_list.elem[0].rab_Info.rab_Identity =
            msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.preconfiguration.rab_Info.rab_Identity;
          if(rbs_r5_ptr != NULL)
          {
            rab_setup_r5_ptr = &rbs_r5_ptr->rab_InformationSetupList;
          }
          else
          {           
            tmp_rab_setup_list.elem[0].rab_Info.re_EstablishmentTimer =
                        predef_rb->re_EstablishmentTimer;
            tmp_rab_setup_list.elem[0].rb_InformationSetupList =
                        predef_rb->rb_InformationList;
                      rab_setup_ptr = &tmp_rab_setup_list;
          } 
        }
       
        mode_specific_choice = msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.preconfiguration.modeSpecificInfo.t;

        if(mode_specific_choice == T_rrc_HandoverToUTRANCommand_r5_IEs_modeSpecificInfo_1_fdd)
        { 
          ul_dpch_info_post_ptr =
           &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.preconfiguration.modeSpecificInfo.u
          .fdd.ul_DPCH_Info;

          /* Downlink information common for all radio links */
          dl_common_info_post_ptr =
            &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.preconfiguration.modeSpecificInfo.u.fdd
            .dl_CommonInformationPost;

          /* Downlink information per radio link */
          dl_rl_post_ptr =
             &msg_ptr->u.criticalExtensions.u.criticalExtensions.u.r5.handoverToUTRANCommand_r5.specificationMode.u.preconfiguration.modeSpecificInfo.u.fdd
            .dl_InformationPerRL_List;
        }
      }

      /* Terminate further processing if mode spec is other than FDD */
      if(mode_specific_choice != T_rrc_HandoverToUTRANCommand_r3_IEs_modeSpecificInfo_1_fdd)
      {
        WRRC_MSG0_ERROR("Only FDD mode supported in Handover to UTRAN Command");
        ret_status = FAILURE;
      }

      if((ret_status == SUCCESS) && (rbs_r5_ptr == NULL))
      {
        /* UL Transport channel information common for all transport channels */
        ul_common_trans_ch_info_ptr = &predef_trch->ul_CommonTransChInfo;

        /* DL Transport channel information common for all transport channels */
        dl_common_trans_ch_info_ptr = &predef_trch->dl_CommonTransChInfo;

        /* Added or Reconfigured UL TrCH information */
        ul_trch_add_reconfig_ptr = &predef_trch->ul_AddReconfTrChInfoList;

        /* Added or Reconfigured DL TrCH information */
        dl_trch_add_reconfig_ptr = &predef_trch->dl_TrChInfoList;
      }

      /* Uplink DPCH info */
      if((ret_status == SUCCESS) && (ul_dpch_info_post_ptr != NULL))
      {
      
        memset(&tmp_ul_dpch_info.m,0,sizeof(tmp_ul_dpch_info.m));
        tmp_ul_dpch_info.ul_DPCH_PowerControlInfo.t =
          T_rrc_UL_DPCH_PowerControlInfo_fdd;

		tmp_ul_dpch_info.ul_DPCH_PowerControlInfo.u.fdd = 
			rrc_malloc(sizeof(rrc_UL_DPCH_PowerControlInfo_fdd));
		
        tmp_ul_dpch_info.ul_DPCH_PowerControlInfo.u.fdd->dpcch_PowerOffset =
         (2 + (ul_dpch_info_post_ptr->ul_DPCH_PowerControlInfo.dpcch_PowerOffset
              * 4)) / 2 ; /* This value is provided as an rrc_DPCCH_PowerOffset2
                             type, which must be converted to the actual value.
                             See ASN.1 definition for details.  Then, we must
                             divide by 2 to make the value compatible with
                             existing RRC functions. */ 
        tmp_ul_dpch_info.ul_DPCH_PowerControlInfo.u.fdd->pc_Preamble =
          ul_dpch_info_post_ptr->ul_DPCH_PowerControlInfo.pc_Preamble;
        tmp_ul_dpch_info.ul_DPCH_PowerControlInfo.u.fdd->sRB_delay =
          ul_dpch_info_post_ptr->ul_DPCH_PowerControlInfo.sRB_delay;
        if(rbs_r5_ptr != NULL)
        {
          tmp_ul_dpch_info.ul_DPCH_PowerControlInfo.u.fdd->powerControlAlgorithm = 
		  	rbs_r5_ptr->ul_ChannelRequirement.u.ul_DPCH_Info->ul_DPCH_PowerControlInfo.u.fdd->powerControlAlgorithm;
        }
        else
        { 
          tmp_ul_dpch_info.ul_DPCH_PowerControlInfo.u.fdd->powerControlAlgorithm =
            predef_phych->ul_DPCH_InfoPredef.ul_DPCH_PowerControlInfo.u.fdd->powerControlAlgorithm;
        } 
        tmp_ul_dpch_info.m.ul_DPCH_PowerControlInfoPresent = 1;
        tmp_ul_dpch_info.modeSpecificInfo.t =
          T_rrc_UL_DPCH_Info_modeSpecificInfo_fdd;

		tmp_ul_dpch_info.modeSpecificInfo.u.fdd = 
			rrc_malloc(sizeof(rrc_UL_DPCH_Info_fdd));
		 memset(&tmp_ul_dpch_info.modeSpecificInfo.u.fdd->m,0,sizeof(tmp_ul_dpch_info.modeSpecificInfo.u.fdd->m));

        tmp_ul_dpch_info.modeSpecificInfo.u.fdd->numberOfDPDCH =
          RRCLLC_DEFAULT_NUM_DPDCH_ALLOWED;

        tmp_ul_dpch_info.modeSpecificInfo.u.fdd->scramblingCodeType =
          ul_dpch_info_post_ptr->scramblingCodeType;
        tmp_ul_dpch_info.modeSpecificInfo.u.fdd->scramblingCode =
          ul_dpch_info_post_ptr->reducedScramblingCodeNumber;
        tmp_ul_dpch_info.modeSpecificInfo.u.fdd->spreadingFactor =
          ul_dpch_info_post_ptr->spreadingFactor;

        if(rbs_r5_ptr != NULL)
        {
          tmp_ul_dpch_info.modeSpecificInfo.u.fdd->tfci_Existence =
                  rbs_r5_ptr->ul_ChannelRequirement.u.ul_DPCH_Info->modeSpecificInfo.u.fdd->tfci_Existence;

          tmp_ul_dpch_info.modeSpecificInfo.u.fdd->puncturingLimit =
                  rbs_r5_ptr->ul_ChannelRequirement.u.ul_DPCH_Info->modeSpecificInfo.u.fdd->puncturingLimit;
        }
        else
        { 
          tmp_ul_dpch_info.modeSpecificInfo.u.fdd->tfci_Existence =
            predef_phych->ul_DPCH_InfoPredef.modeSpecificInfo.u.fdd->tfci_Existence;
          tmp_ul_dpch_info.modeSpecificInfo.u.fdd->puncturingLimit =
            predef_phych->ul_DPCH_InfoPredef.modeSpecificInfo.u.fdd->puncturingLimit;
        } 
        ul_dpch_info_ptr = &tmp_ul_dpch_info;
      }

      memset((void *)&tmp_dl_common_info, 0, sizeof(rrc_DL_CommonInformation));

      /* Downlink information common for all radio links */
      if((ret_status == SUCCESS) && (dl_common_info_post_ptr != NULL))
      {
      memset(&tmp_dl_common_info.m,0,sizeof(tmp_dl_common_info.m));

        tmp_dl_common_info.dl_DPCH_InfoCommon.cfnHandling.t =
          T_rrc_DL_DPCH_InfoCommon_cfnHandling_maintain;
        tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.t =
          T_rrc_DL_DPCH_InfoCommon_modeSpecificInfo_fdd;
			tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd = 
			rrc_malloc(sizeof(rrc_DL_DPCH_InfoCommon_fdd));
			memset(&tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->m
				,0,sizeof(tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->m));
        
        tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd
        ->dl_DPCH_PowerControlInfo =
        dl_common_info_post_ptr->dl_DPCH_InfoCommon.dl_DPCH_PowerControlInfo;
        tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->m.dl_DPCH_PowerControlInfoPresent =1;
        tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->powerOffsetPilot_pdpdch = 0; /* 25.331, clause 8.3.6.3 */
        rrc_set_predefined_po3_status( TRUE);
        rrc_predef_po3_not_needed = TRUE;

        if(rbs_r5_ptr != NULL)
        {
          tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd
                ->spreadingFactorAndPilot =
          rbs_r5_ptr->dl_CommonInformation.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->spreadingFactorAndPilot;

          tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd
                ->tfci_Existence = rbs_r5_ptr->dl_CommonInformation.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd->tfci_Existence;
        }
        else
        { 
          tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd
          ->spreadingFactorAndPilot =
            predef_phych->dl_CommonInformationPredef.dl_DPCH_InfoCommon
            .modeSpecificInfo.u.fdd->spreadingFactorAndPilot;
          tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd
            ->positionFixedOrFlexible =
          predef_phych->dl_CommonInformationPredef.dl_DPCH_InfoCommon
            .modeSpecificInfo.u.fdd->positionFixedOrFlexible;
            tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd
          ->tfci_Existence =
          predef_phych->dl_CommonInformationPredef.dl_DPCH_InfoCommon
          .modeSpecificInfo.u.fdd->tfci_Existence;
        } 
        tmp_dl_common_info.m.dl_DPCH_InfoCommonPresent = 1;
        tmp_dl_common_info.modeSpecificInfo.t =
          T_rrc_DL_CommonInformation_modeSpecificInfo_fdd;
		tmp_dl_common_info.modeSpecificInfo.u.fdd = 
			rrc_malloc(sizeof(rrc_DL_CommonInformation_fdd));
		memset(&tmp_dl_common_info.modeSpecificInfo.u.fdd->m
				,0,sizeof(tmp_dl_common_info.modeSpecificInfo.u.fdd->m));
        

        srnti2 = (new_urnti_ptr->s_RNTI_2.data[0]) << 8;
        srnti2 |= (new_urnti_ptr->s_RNTI_2.data[1]);
        srnti2 >>= 6;

        tmp_dl_common_info.modeSpecificInfo.u.fdd->defaultDPCH_OffsetValue =
          (srnti2 % 600); /* 25.331, clause 8.3.6.3 */

      
        tmp_dl_common_info.modeSpecificInfo.u.fdd->m.defaultDPCH_OffsetValuePresent = 1;
        dl_common_info_ptr = &tmp_dl_common_info;
      }
      if(ret_status == SUCCESS)
      {
        tmp_dl_rl.n = dl_rl_post_ptr->n;

        tmp_dl_rl.elem = rrc_malloc(sizeof(rrc_DL_InformationPerRL));
	
        memset(&tmp_dl_rl.elem[0].m,0,sizeof(tmp_dl_rl.elem[0].m));
        tmp_dl_rl.elem[0].m.dl_DPCH_InfoPerRLPresent = 1;
     
        tmp_dl_rl.elem[0].modeSpecificInfo.t =
         T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd;
	  
	tmp_dl_rl.elem[0].modeSpecificInfo.u.fdd = 
		rrc_malloc(sizeof(rrc_DL_InformationPerRL_fdd));
	
        memset(&tmp_dl_rl.elem[0].modeSpecificInfo.u.fdd->m,0,
		sizeof(tmp_dl_rl.elem[0].modeSpecificInfo.u.fdd->m));
	
        tmp_dl_rl.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info =
        dl_rl_post_ptr->elem[0].primaryCPICH_Info;
     
	  tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd = 
		rrc_malloc(sizeof(rrc_DL_DPCH_InfoPerRL_fdd));
		
	  memset(&tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd->m,0,
	  	sizeof(tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd->m));
	  
      tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.t =
        T_rrc_DL_DPCH_InfoPerRL_fdd;

      tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd->pCPICH_UsageForChannelEst =
        dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.pCPICH_UsageForChannelEst;
      tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd->pCPICH_UsageForChannelEst =
         rrc_PCPICH_UsageForChannelEst_mayBeUsed;;
      tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd->dpch_FrameOffset =
        ((tmp_dl_common_info.modeSpecificInfo.u.fdd->defaultDPCH_OffsetValue * 512)
          % 38400) / 256; /* 25.331, clause 8.3.5.1.2 */
   
      
      tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.elem =
        rrc_malloc(sizeof(rrc_DL_ChannelisationCode));
      tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.n =1;
      tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.elem[0] =
	  	dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.dl_ChannelisationCode;

      tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd->tpc_CombinationIndex =
        dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.tpc_CombinationIndex;
      if( dl_rl_post_ptr->n > 1)
      {
        WRRC_MSG0_ERROR("Single Pri-SCR supported for GtoW HO");
      }
      
     
      dl_rl_ptr = &tmp_dl_rl;
      	}
      break;
    
    default:
      WRRC_MSG0_HIGH("Invalid specificationMode");
      ret_status = FAILURE;
  } /* switch(specification_choice) */

  /* Use existing processing functions to put the information from the
     received IEs into the ordered configuration database. */

  /* Here, update the transport channel info (only transport channel IDs 
   * and count) and rearrange the info by sorting transport channel list
   * based on TrCH ID.
   */
  if((ret_status == SUCCESS) && (rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                    NULL))
     == FAILURE)
  {
    ret_status = FAILURE;
  }

  if(ret_status == SUCCESS)
  	{
  if(( RRC_CHECK_COMMON_MSG_TYPE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_r3)) ||
     (specification_choice == T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_preconfiguration))
  {
    if(rrcllc_add_delete_and_arrange_dl_dch_trch_info(dl_trch_add_reconfig_ptr,
                                                    NULL)
     == FAILURE)
    {
      ret_status = FAILURE;
    }
  }
  else
  {
    if(rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(dl_add_reconf_trch_list, NULL)== FAILURE)
    { 
      ret_status = FAILURE;
    } 
  }
  	}

  if((ret_status == SUCCESS) && (( RRC_CHECK_COMMON_MSG_TYPE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_r3)) || 
     (specification_choice == T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_preconfiguration)))
  {
    /* Get the SRB setup list.  This cast is here solely for code reuse.
     The rrc_SRB_InformationSetupList2 type is identical to the
     rrc_SRB_InformationSetupList type except for the name.  Later on,
     we will pass srb_setup_head_ptr to a function that expects the
     rrc_SRB_InformationSetupList2 type.  Lint is uncomfortable with this
     cast, so we must reassure it. */
  

    while((ret_status == SUCCESS) &&(srb_setup_ptr->n > srb_cnt) && (srb_cnt < UE_MAX_SRB_SETUP))
    {
      /* Check to see if the RB ID is there ... */
      if(srb_setup_ptr->elem[srb_cnt].m.rb_IdentityPresent)
      {
        rb_id = srb_setup_ptr->elem[srb_cnt].rb_Identity;
      }

      /*
      * ... if not, then start with the first SRB and get the next SRB ID
      * each time one is not included in the IE.
      */
      else
      {
        /* Get the next SRB, note this increments to 1 the first time */
        rb_id++;
      }

      /* Save off the RB Mapping info for each SRB */
      if(get_srb_info_to_setup(&srb_setup_ptr->elem[srb_cnt],
	  	(rrc_SRB_InformationSetupList2 *) srb_setup_ptr, rb_id)
       == FAILURE)
      {
        ret_status = FAILURE;
      }

      srb_cnt++;
    } /* end SRB setup */

    /* Get the RAB setup list if present */
    if(rab_setup_ptr != NULL)
    {
      while((ret_status == SUCCESS) && (rab_setup_ptr->n > rab_cnt) && (rab_cnt < MAX_RAB_TO_SETUP))
      {
        rb_cnt = 0;
        rb_setup_ptr  = &rab_setup_ptr->elem[rab_cnt].rb_InformationSetupList;

       

        while((rb_setup_ptr->n > rb_cnt) && (rb_cnt < MAX_RB_PER_RAB))
        {
          if(get_rb_info_to_setup(&rb_setup_ptr->elem[rb_cnt], 
#ifdef FEATURE_UMTS_PDCP
                                rab_setup_ptr->elem[rab_cnt].rab_Info.cn_DomainIdentity,
#endif /* FEATURE_UMTS_PDCP */
                                  rb_setup_ptr) == FAILURE)
          {
            ret_status = FAILURE;
          }

          rb_cnt++;
        } /* end RB per RAB setup */


        rab_cnt++;
      } /* end rab setup */
    } /* end RAB setup */

    if(tmp_rab_setup_list.elem != NULL)
    {
      rrc_free(tmp_rab_setup_list.elem);
    }
		
    if ((ret_status == SUCCESS) && (FAILURE == rrcllc_validate_rb_mapping_info()) )
    {
      ret_status = FAILURE;
    }

    /* Get the Common Uplink Transport Channel information */
    if((ret_status == SUCCESS) && (get_ul_info_common_for_all_trch(ul_common_trans_ch_info_ptr,
                                     ordered_config_ptr->rrc_state_indicator))
      == FAILURE)
    {
      ret_status = FAILURE;
    }
  }
  else
  {
    /* We will be here only when complete config for Rel-5 is chosen */
    while((ret_status == SUCCESS) && (srb_setup_r5_ptr->n > srb_cnt) && (srb_cnt < UE_MAX_SRB_SETUP))
    {
      /* Check to see if the RB ID is there ... */
      if(srb_setup_r5_ptr->elem[srb_cnt].m.rb_IdentityPresent)
      {
        rb_id = srb_setup_r5_ptr->elem[srb_cnt].rb_Identity;
      }
      
      /*
      * ... if not, then start with the first SRB and get the next SRB ID
      * each time one is not included in the IE.
      */
      else
      {
        /* Get the next SRB, note this increments to 1 the first time */
        rb_id++;
      }
      
      /* Save off the RB Mapping info for each SRB */
      if(get_srb_info_to_setup_r5(
        &srb_setup_r5_ptr->elem[srb_cnt], 
        (srb_setup_r5_ptr), 
        rb_id)
        == FAILURE)
      {
        ret_status = FAILURE;
      }

      /* Pick that pointer that has RB Id > 4 & 
         assume it to be SRB#5 pointer for the time being */
      if(rb_id > DCCH_DT_LOW_PRI_RADIO_BEARER_ID)
      {
        srb5_setup_ptr = &srb_setup_r5_ptr->elem[srb_cnt];
        srb_id = rb_id;
      }
      
    
      srb_cnt++;
    }

    /* We are just validating one more SRB, incase 
       SRB#5 is given by n/w */
    if((ret_status == SUCCESS) && (srb5_setup_ptr != NULL))
    {
      if(rrcllc_update_oc_with_srb5(srb5_setup_ptr, srb_id) == FAILURE)
      {
        WRRC_MSG0_ERROR("Rejecting SRB#5 configuration given by the network");
        ret_status = FAILURE;
      }
    }

    /* Get the RAB setup list if present */
    while((ret_status == SUCCESS) && (rab_setup_r5_ptr->n > rab_cnt) && (rab_cnt < MAX_RAB_TO_SETUP))
    {
      rb_cnt =0;
      rb_setup_r5_ptr  = &rab_setup_r5_ptr->elem[rab_cnt].rb_InformationSetupList;
      
            
      while((rb_setup_r5_ptr->n > rb_cnt ) && (rb_cnt < MAX_RB_PER_RAB))
      {
        if(get_rb_info_to_setup_r5(&rb_setup_r5_ptr->elem[rb_cnt], 
#ifdef FEATURE_UMTS_PDCP
                                  rab_setup_r5_ptr->elem[rab_cnt].rab_Info.cn_DomainIdentity,
#endif /* FEATURE_UMTS_PDCP */
                                   rb_setup_r5_ptr) == FAILURE)
        {
          ret_status = FAILURE;
        }

        rb_cnt++;
      } /* end RB per RAB setup */
      

      rab_cnt++;
    } /* end rab setup */

    /* Get the Common Uplink Transport Channel information */
    if((ret_status == SUCCESS) && (get_ul_info_common_for_all_trch_r5(ul_common_trans_ch_info_r5_ptr,
                                     ordered_config_ptr->rrc_state_indicator))
        == FAILURE)
    { 
      return FAILURE;
    }
  }


  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */
  idx = 0;


  /* Save info for each additional Transport Channel */
  while((ret_status == SUCCESS) && (idx <= UE_MAX_TRCH) && (ul_trch_add_reconfig_ptr->n > idx))
  {
    if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
    {
      ret_status = FAILURE;
    }

    /* get next TrCH Info */
    idx++;
  } /* end while */

  /* Check to make sure UL TFS count is within UE Capabilities */
  if((ret_status == SUCCESS) && (rrcllc_check_ul_tfs_cnt() == FAILURE))
  {
    ret_status = FAILURE;
  }  
  if(ret_status == SUCCESS)
  	{
  /* Calculate the UL TFCS */
  compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
  	}
  /* There is no scope for TFC subset IE in default configurations as of now.
     Code is written keeping future scope in view 
     Presently default configurations we support map to SIB16  structures
     which is same for Rel99 & Rel5.
     "ul_common_trans_ch_info_ptr" is same for complete or default config */
  if((ret_status == SUCCESS) && (ul_common_trans_ch_info_ptr != NULL))
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(ul_common_trans_ch_info_ptr,
		rrc_UL_CommonTransChInfo,tfc_Subset))
    { 
      if(rrcllc_update_oc_with_tfc_subset(ul_common_trans_ch_info_ptr, MSG_REL99) == FAILURE)
      { 
        ret_status = FAILURE;
      } 
    } 
  }
  else 
  {
    if((ret_status == SUCCESS) && (ul_common_trans_ch_info_r5_ptr != NULL))
    {
      if(RRC_MSG_COMMON_BITMASK_IE_PTR(ul_common_trans_ch_info_r5_ptr,
	  	rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {  
        if(rrcllc_update_oc_with_tfc_subset(ul_common_trans_ch_info_r5_ptr, MSG_REL5) == FAILURE)
        {  
          ret_status = FAILURE;
        }  
      }
      if(RRC_MSG_COMMON_BITMASK_IE_TYPE2_PTR(ul_common_trans_ch_info_r5_ptr,
	  	tfc_SubsetList))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(ul_common_trans_ch_info_r5_ptr) == FAILURE)
        {
          ret_status = FAILURE;
        }
      }
    }
  }

  if((ret_status == SUCCESS) && (( RRC_CHECK_COMMON_MSG_TYPE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_r3)) || 
     (specification_choice == T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_preconfiguration)))
  {
    /* Get the Common Downlink Transport Channel information */
    if(get_dl_info_common_for_all_trch(dl_common_trans_ch_info_ptr,
      ul_common_trans_ch_info_ptr, ordered_config_ptr->rrc_state_indicator)
      == FAILURE)
    {
      ret_status = FAILURE;
    }
  }
  else if(ret_status == SUCCESS)
  {
    if(get_dl_info_common_for_all_trch_r5(dl_common_trans_ch_info_r5_ptr, 
                                          ul_common_trans_ch_info_r5_ptr,
                                          ordered_config_ptr->rrc_state_indicator)
          == FAILURE)
    { 
      ret_status = FAILURE;
    }
  }

  /* Get the DL Added or Reconfigured Transport Channel information */
  idx = 0;


  if((ret_status == SUCCESS) && (( RRC_CHECK_COMMON_MSG_TYPE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_r3)) || 
     (specification_choice == T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_preconfiguration)))
  {
    /* Save info for each additional Transport Channel */
    while((idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL && (dl_trch_add_reconfig_ptr->n > idx))
    {
      if(get_dl_added_reconfig_trch(&dl_trch_add_reconfig_ptr->elem[idx],
                                  ul_trch_add_reconfig_ptr,
                                  FALSE) == FAILURE)
      {
        ret_status = FAILURE;
      }

      /* get next TrCH Info */
      idx++;
    } /* end while */
  }
  else
  {
    /* Save info for each additional Transport Channel */
    while((ret_status == SUCCESS) && (idx <= UE_MAX_TRCH) && dl_add_reconf_trch_list != NULL && (dl_add_reconf_trch_list->n > idx))
    {
      if(get_dl_added_reconfig_trch_r5(&dl_add_reconf_trch_list->elem[idx],
                                  ul_trch_add_reconfig_ptr,
                                  FALSE) == FAILURE)
      {
       ret_status = FAILURE;
      }

      /* get next TrCH Info */
      idx++;
    } /* end while */
  }

  /* Check to make sure DL TFS count is within UE Capabilities */
  if((ret_status == SUCCESS) && (rrcllc_check_dl_tfs_cnt() == FAILURE))
  {
    ret_status = FAILURE;
  }

  if ((ret_status == SUCCESS) && (!rrcllc_is_tfcs_provided_on_add_delete_trch(rrc_RRC_StateIndicator_cell_DCH)) )
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }

  /* Get Uplink DPCH Info */
  if((ret_status == SUCCESS)&& (( RRC_CHECK_COMMON_MSG_TYPE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_r3)) || 
     (specification_choice == T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_preconfiguration) 
     || (RRC_DEF_CONFIG_11 == default_config_id) || (RRC_DEF_CONFIG_12 == default_config_id)
#ifdef FEATURE_VOC_AMR_WB
        ||( RRC_DEF_CONFIG_13 == default_config_id)
#endif /*FEATURE_VOC_AMR_WB*/
    ))
  {
    if(get_ul_dpch_info(ul_dpch_info_ptr) == FAILURE)
    {
      ret_status = FAILURE;
    }
  }

  else if(ret_status == SUCCESS)
  {
    if(get_ul_dpch_info_r5(ul_dpch_info_r5_ptr) == FAILURE)
    {
      ret_status = FAILURE;
    }
  }

  if( (specification_choice == T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_preconfiguration)
     && (ul_dpch_info_ptr != NULL))
  {
    if(tmp_ul_dpch_info.modeSpecificInfo.u.fdd != NULL)
    {
      rrc_free(tmp_ul_dpch_info.modeSpecificInfo.u.fdd);
    }
    if(tmp_ul_dpch_info.ul_DPCH_PowerControlInfo.u.fdd != NULL)
    {
      rrc_free(tmp_ul_dpch_info.ul_DPCH_PowerControlInfo.u.fdd);
    }
  }


  /* Init DL Common Info to Timing Maintained */
  rrcllc_init_dl_common_info(ordered_config_ptr);

  /* set is_hho flag explicity to true */
  ordered_config_ptr->is_hho = TRUE;

  /* Get the DL information for all Radio Links */
  if((ret_status == SUCCESS) && (( RRC_CHECK_COMMON_MSG_TYPE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_r3)) || 
     (specification_choice == T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_preconfiguration) 
     || (RRC_DEF_CONFIG_11 == default_config_id) || (RRC_DEF_CONFIG_12 == default_config_id)
#ifdef FEATURE_VOC_AMR_WB
        ||( RRC_DEF_CONFIG_13 == default_config_id)
#endif/*FEATURE_VOC_AMR_WB*/
    ))
  {
    if(get_dl_info_common_for_all_rl(dl_common_info_ptr,
                                   &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                   &ordered_config_ptr->l1_dl_cctrch_parms,
                                   &ordered_config_ptr->l1_dl_ctfc_parms)
     == FAILURE)
    {
      ret_status = FAILURE;
    }
  }
  else if (ret_status == SUCCESS)
  {
    if(get_dl_info_common_for_all_rl_per_r4_rrc_connection(dl_common_info_r5_ptr,
                                   &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                   &ordered_config_ptr->l1_dl_cctrch_parms,
                                   &ordered_config_ptr->l1_dl_ctfc_parms)
     == FAILURE)
    {
      ret_status = FAILURE;
    }
  }
  if( (specification_choice == T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_preconfiguration)
      && (dl_common_info_ptr != NULL)) 
  {
    if(tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd != NULL)
    {
      rrc_free(tmp_dl_common_info.dl_DPCH_InfoCommon.modeSpecificInfo.u.fdd);
    }
    if(tmp_dl_common_info.modeSpecificInfo.u.fdd != NULL)
    {
      rrc_free(tmp_dl_common_info.modeSpecificInfo.u.fdd);
    }  
  }
  if (ret_status == SUCCESS)
  	{
  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms);

  /* Get the DL information for each Radio Link */
  /* Initialize the loop variables */
  idx = 0;
  	}
  if(( RRC_CHECK_COMMON_MSG_TYPE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_r3)) || 
     (specification_choice == T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_preconfiguration) 
     || (RRC_DEF_CONFIG_11 == default_config_id) || (RRC_DEF_CONFIG_12 == default_config_id)
#ifdef FEATURE_VOC_AMR_WB
        ||( RRC_DEF_CONFIG_13 == default_config_id)
#endif/*FEATURE_VOC_AMR_WB*/
    )
  {
    while ((ret_status == SUCCESS) && (idx < UE_MAX_RL) && (dl_rl_ptr->n > idx) )
    {
      status = get_dl_info_for_each_rl(&dl_rl_ptr->elem[idx],
                                     &ordered_config_ptr->l1_dl_chan_parms,
                                     idx,
                                     TRUE);
      if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
      {
        ret_status = FAILURE;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_IGNORED)
      {
        break;
      }
      else /* status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS */
      {
        idx++;
      }
    } /* end loop of all Radio links */
  }
  else
  {
    while ((ret_status == SUCCESS) && (idx < UE_MAX_RL) && (dl_info_per_rl_ptr->n > idx) )
    {
      status = get_dl_info_for_each_rl_r5(&dl_info_per_rl_ptr->elem[idx],
                                     &ordered_config_ptr->l1_dl_chan_parms,
                                     idx,
                                     TRUE);

      if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
      {
        ret_status = FAILURE;
      }
      else if(status == RRCLLCOC_DL_INFO_PER_RL_IGNORED)
      {
        break;
      }
      else /* status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS */
      {
        idx++;
      }
    } /* end loop of all Radio links */
  }
  if( (specification_choice == T_rrc_HandoverToUTRANCommand_r3_IEs_specificationMode_preconfiguration)
  	&&(dl_rl_ptr != NULL))
	{
	if(tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.elem != NULL)
	{
	rrc_free(tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.elem);
	}
	if(tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd != NULL)
	{
	rrc_free(tmp_dl_rl.elem[0].dl_DPCH_InfoPerRL.u.fdd);
	}
	if(tmp_dl_rl.elem[0].modeSpecificInfo.u.fdd != NULL)
	{
	rrc_free(tmp_dl_rl.elem[0].modeSpecificInfo.u.fdd);
	}
	if(tmp_dl_rl.elem != NULL)
	{
	rrc_free(tmp_dl_rl.elem);
	}
	}

  /* Save off the number of Radio links in ordered config */
  if(status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS)
  {
    ordered_config_ptr->l1_dl_chan_parms.num_rl = (uint16)idx;
  }
  if(ret_status == SUCCESS)
  	{
  /* Update the timers and constants in ordered config */
  rrcllc_get_timers_and_const_in_conn_mode_for_handover();

  /*We assume that HandoverToUTRAN will take UE to Cell_DCH state only. And there will
  be only one RL given in the OTA.
  So we can simply check for this relation as per 8.6.6.14 in 25.331
  "Default DPCH Offset Value" % 38400 = "DPCH frame offset" */
  for(idx=0; idx<ordered_config_ptr->l1_dl_chan_parms.num_rl; idx++)
  {
    if((ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset % 38400) !=
        (uint32)(ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[idx].dpch_per_rl.frame_offset * 
        RRCLLC_TAU_DPCH_MULTIPLICATION_FACTOR))
    {
      WRRC_MSG2_ERROR("Validation failed for DOFF %d, and frame_offset %d relation!",
        ordered_config_ptr->l1_dl_chan_parms.dl_common.default_dpch_offset,
        ordered_config_ptr->l1_dl_chan_parms.dl_per_rl[idx].dpch_per_rl.frame_offset); 
      ret_status = FAILURE;
    }
  } 
  
    rrcllc_adjust_tb_size_handover_to_utran();

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(rrc_RRC_StateIndicator_cell_DCH)
    == FAILURE)
  { 
    ret_status = FAILURE;
  }
  	
#ifdef FEATURE_VOC_AMR_WB
  ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/
  	}
  
  if((ret_status == SUCCESS) && (rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE))
  {
    ret_status = FAILURE;
  }
  

  return ret_status;
} /* end rrcllc_handover_to_utran_ie() */


/*====================================================================
FUNCTION: rrcllc_cell_update_confirm_ie()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Cell Update Confirm Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_cell_update_confirm_ie
(
  rrc_CellUpdateConfirm_r3_IEs *msg_ptr
)
{
  /* local loop variables */
  uint8                           idx;
#ifdef FEATURE_WCDMA_HS_FACH
  uecomdef_status_e_type  status = SUCCESS;
#endif

  /* local RB to reconfigure list pointer */
  rrc_RB_InformationReconfigList   * rb_reconfig_ptr;

  /* local RB Release pointer */
  rrc_RB_InformationReleaseList    * rb_release_ptr;

  /* local RBs to be Affected Pointer */
  rrc_RB_InformationAffectedList   * rb_affected_ptr;

  /* local UL TrCH Drop Pointer */
  rrc_UL_DeletedTransChInfoList   * ul_trch_delete_ptr = NULL;

  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList * ul_trch_add_reconfig_ptr = NULL;

  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList   * dl_trch_delete_ptr = NULL;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList * dl_trch_add_reconfig_ptr = NULL;

  /* Local C_RNTI value */
  rrc_int_c_rnti_type             c_rnti;

  /* Later on, we will check to make sure both of these parameters
     are present when going from a non-DCH state to DCH. */
 /* const uint32 dl_dpch_mask =
   rrc_CellUpdateConfirm_r3_IEs,dl_CommonInformation |
   rrc_CellUpdateConfirm_r3_IEs,dl_InformationPerRL_List;
*/
  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  rrcllc_init_before_msg_processing();


  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /* Ignore the Integrity Protection and Ciphering IEs */
  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,activationTime)),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_CU);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /* Get the U-RNTI */
  if(FAILURE == rrcllc_update_urnti_in_oc(
                  RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,new_U_RNTI),
                  &msg_ptr->new_U_RNTI,
                  msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the C-RNTI only if next state is CELL_FACH. We do not need it for
   any other state */
  if((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,new_C_RNTI)) &&
  (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_C_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
  }  /* If new CRNTI present */

#ifdef FEATURE_WCDMA_HS_RACH
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH) &&
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,new_C_RNTI)))
  {
    rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
  }
#endif

  /* If transitioning from CELL_DCH to CELL_FACH, or to CELL_PCH or URA_PCH,
   * delete the C-RNTI.
   * The procedure will update C-RNTI later.
   */
  if(((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH) && 
      (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)) ||
     (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH ||
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }

  /* Get the RRC State Indicator */
  if(FAILURE == rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the UTRAN DRX cycle length coefficient */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,utran_DRX_CycleLengthCoeff)) 
  {
    if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
       (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length = 
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);
    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
                msg_ptr->utran_DRX_CycleLengthCoeff);
      return FAILURE;
    }
  }
  else if (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH ||
           msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_ura_PCH)
  {
    /* If we're transitioning to Cell_PCH or URA_PCH state, the "UTRAN DRX
    Cycle length coefficient must be present. */
    return FAILURE;
  } /* end UTRAN DRX Cycle Length indicator */


  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,dl_DeletedTransChInfoList))
  {
    dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,dl_AddReconfTransChInfoList))
  {
    dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,ul_deletedTransChInfoList))
  {
    ul_trch_delete_ptr = &msg_ptr->ul_deletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,ul_AddReconfTransChInfoList))
  {
    ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }



  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                      ul_trch_delete_ptr)
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info(dl_trch_add_reconfig_ptr, dl_trch_delete_ptr) == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If next state is Cell_DCH */

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }
  
  /* Get the affected RB list if present */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,rb_InformationAffectedList))
  {
    rb_affected_ptr = &msg_ptr->rb_InformationAffectedList;
    idx = 0;

    while((rb_affected_ptr->n > idx) && (idx < MAX_RB))
    {
      if(get_rb_info_affected(&rb_affected_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }
      idx++;
    }
  } /* end Affected RB */

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,rb_InformationReconfigList))
  {
    /* Get the RB reconfiguration list */
    rb_reconfig_ptr = &msg_ptr->rb_InformationReconfigList;
    idx = 0;
    while((rb_reconfig_ptr->n > idx) && (idx < MAX_RB))
    {
      if(get_rb_info_to_reconfig(&rb_reconfig_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }
      idx++;
    } /* end RB reconfig */
  }

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,rb_InformationReleaseList))
  {
    rb_release_ptr  = &msg_ptr->rb_InformationReleaseList;
    idx = 0;
    while((rb_release_ptr->n > idx) && (idx < MAX_RB))
    {
      if(get_rb_info_to_release(&rb_release_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }
      idx++;
    } /* end RB release */
  }

  if (FAILURE == rrcllc_validate_rb_mapping_info()) 
  {
    return FAILURE;
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Get the Common Uplink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,ul_CommonTransChInfo))
  {
    if(get_ul_info_common_for_all_trch(&msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */
  if((dch_ie_processing_status == SUCCESS) &&  
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,ul_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) && 
            (idx <= UE_MAX_TRCH) && 
            (ul_trch_add_reconfig_ptr->n > idx))
      {
        if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }

        /* get next TrCH Info */
        idx++;
      } /* end while */
    } /* end UL TrCH Add/Reconfig */

    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }  
    /* Calculate the UL TFCS */
    if((dch_ie_processing_status == SUCCESS) && 
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
	  	rrc_UL_CommonTransChInfo,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL99) == FAILURE)
        { 
          dch_ie_processing_status = FAILURE;
        } 
      }

    }
  } /* If state is Cell_DCH */

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      return FAILURE;
    }
  }


  WRRC_MSG1_HIGH(" CUC  R3 Mode specific info FDD %d",msg_ptr->modeSpecificTransChInfo.t);
  
  /* Ignore the DRAC and CPCH IEs */
  switch(msg_ptr->modeSpecificTransChInfo.t)
  {
    case T_rrc_CellUpdateConfirm_r3_IEs_modeSpecificTransChInfo_fdd:
      break;

    case T_rrc_CellUpdateConfirm_r3_IEs_modeSpecificTransChInfo_tdd:
      break;

    default:
      break;

  } /* end mode switch */

  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Get the Common Downlink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,dl_CommonTransChInfo))
  {
    if(get_dl_info_common_for_all_trch(&msg_ptr->dl_CommonTransChInfo,
                                       &msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator
                                      ) 
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }

  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,dl_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) && 
            (idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL && 
            (dl_trch_add_reconfig_ptr->n > idx))
      {
        if(get_dl_added_reconfig_trch(&dl_trch_add_reconfig_ptr->elem[idx],
                                      ul_trch_add_reconfig_ptr,
                                      /* RRC Connection Setup doesn't allowed TM signalling DCCH */
                                      FALSE
                                     )
            == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }

        /* get next TrCH Info */
        idx++;

      } /* end while */
    } /* end DL TrCH Add/Reconfig */

    /* Adjust TB size on every TrCH if necessary. */ 
    for (idx=0; (dch_ie_processing_status == SUCCESS) && (idx < UE_MAX_TRCH); idx++)
    {
      /* The number of logical channel mapped to this transport channel 
         increases from 1 to 2. Needs to adjsut the tb_szie to
         reflect the adding of the MAC header.                         */
      if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
          (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
           ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
      {
        /* TrCH IE is present and the TrCH ID is appear in the TrCH info table. */
        if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,dl_AddReconfTransChInfoList) &&
            find_trch_id_in_config_trch_list(&msg_ptr->dl_AddReconfTransChInfoList,
                                              ordered_config_ptr->dl_dch_trch_info[idx].trch_id)))
        {
          /* Added MAC head size to the current TB size.  */
          rrcllc_update_tb_size_for_dch(idx);
        }
        WRRC_MSG0_HIGH("Clean TB size adjust flag in CellUpdate");
        /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
      }
      else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
      {
        /* Since the activated transport channels are sorted before stored in
           the memory, break the looping after reaching the 1st invalid block.  */
        break;
      }
    }


    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_dl_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If state is Cell_DCH */

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_CellUpdateConfirm_r3_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
          msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,ul_ChannelRequirement))
  {
    /* Check to see if this is DPCH or CPCH */
    switch(msg_ptr->ul_ChannelRequirement.t)
    {
      case T_rrc_UL_ChannelRequirement_ul_DPCH_Info:
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          if(get_ul_dpch_info(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        break;

      case T_rrc_UL_ChannelRequirement_dummy:
        WRRC_MSG0_ERROR("UL CPCH info not supported for CU cnf");
        return FAILURE;

      default:
        WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in CU cnf",
                  msg_ptr->ul_ChannelRequirement.t);
        return FAILURE;
    }
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
          current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
   WRRC_MSG2_ERROR("No UL Chan Req, CU cnf state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  } /* end if check for UL Channel Requirement */

  WRRC_MSG1_HIGH(" CUC R3 Mode specific info FDD %d",msg_ptr->modeSpecificPhysChInfo.t);
  
  /* Ignore PDSCH IEs */
  switch(msg_ptr->modeSpecificPhysChInfo.t)
  {
    case T_rrc_CellUpdateConfirm_r3_IEs_modeSpecificPhysChInfo_fdd:
      break;

    case T_rrc_CellUpdateConfirm_r3_IEs_modeSpecificPhysChInfo_tdd:
      break;

    default:
      return FAILURE;
  } /* end PDSCH check */

  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,dl_CommonInformation)) &&
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,dl_InformationPerRL_List)))&&
     current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
   WRRC_MSG2_ERROR("No DL DPCH, CU cnf %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }

  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Initialize the L1 bitmask for the parameters in the "Downlink
     * information for all radio links" IE.  Since the IE is optional,
     * we want to make sure we don't signal L1 erroneously that we have
     * received information when we haven't.
     */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);


    if(FAILURE == rrcllcpcie_is_hho((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
                            rrc_CellUpdateConfirm_r3_IEs,dl_InformationPerRL_List)),
                            &msg_ptr->dl_InformationPerRL_List,
                            msg_ptr->rrc_StateIndicator))
    {
        return FAILURE;
    }

    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r3_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl(&msg_ptr->dl_CommonInformation,
                                       &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                       &ordered_config_ptr->l1_dl_cctrch_parms,
                                       &ordered_config_ptr->l1_dl_ctfc_parms
                                      )
         == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
  } /* If next state is Cell_DCH */

  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms
                            );

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_CellUpdateConfirm_r3_IEs,dl_InformationPerRL_List))
  {
    if(get_dl_info_per_rl(&msg_ptr->dl_InformationPerRL_List,
        msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }

  if (rrc_nv_rel_indicator & RRC_NV_REL_INDICATOR_REL5) 
  {
    /* Determine HSDPA Action */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      if (rrc_get_hsdpa_status() == HSDPA_ACTIVE)
      {
        /* Check to make sure that everything is present */
        if (rrcllc_check_if_hsdpa_can_be_started_reconfigured(ordered_config_ptr) == FALSE)
        {
          rrc_set_hsdpa_action(HSDPA_STOP);
          ordered_config_ptr->mac_dl_parms.mac_hsdpa_action = HSDPA_STOP;
          WRRC_MSG0_HIGH("RRCHS:HSSTOP");
        }
      }
    } /* If next state is Cell_DCH */  
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
    == FAILURE)
  { 
    return FAILURE;
  }
  if(rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }

  if (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)) 
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(&msg_ptr->rb_InformationReleaseList) == FAILURE)
    {
      return FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

#ifdef FEATURE_WCDMA_HS_FACH
  if(SUCCESS == status)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        FALSE);
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        FALSE);

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL99);

#ifdef FEATURE_WCDMA_DC_HSUPA
  if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)== FAILURE)
  {
    status = FAILURE;
  }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return status;

} /* end rrcllc_cell_update_confirm_ie() */



/*====================================================================
FUNCTION: rrcllc_cell_update_confirm_ie_r5()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Cell Update Confirm Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_cell_update_confirm_ie_r5
(
  rrc_CellUpdateConfirm_r5_IEs *msg_ptr
)
{
  /* local loop variables */
  #ifdef FEATURE_WCDMA_HS_FACH
  uecomdef_status_e_type          status = SUCCESS;
#endif
  uint8                           idx;

  /* local RB to reconfigure list pointer */
  rrc_RB_InformationReconfigList_r5  * rb_reconfig_ptr;

  /* local RB Release pointer */
  rrc_RB_InformationReleaseList    *rb_release_ptr;

  /* local RBs to be Affected Pointer */
  rrc_RB_InformationAffectedList_r5  * rb_affected_ptr;

  /* local UL TrCH Drop Pointer */
  rrc_UL_DeletedTransChInfoList  * ul_trch_delete_ptr = NULL;

  /* local UL TrCH Add Reconfig pointer */
  rrc_UL_AddReconfTransChInfoList *ul_trch_add_reconfig_ptr = NULL;

  /* local UL TrCH Drop Pointer */
  rrc_DL_DeletedTransChInfoList_r5  * dl_trch_delete_ptr = NULL;

  /* local DL TrCH Add Reconfig pointer */
  rrc_DL_AddReconfTransChInfoList_r5 *  dl_trch_add_reconfig_ptr = NULL;

  /* Local C_RNTI value */
  rrc_int_c_rnti_type             c_rnti;

  /* Later on, we will check to make sure both of these parameters
     are present when going from a non-DCH state to DCH. */
 /* const uint32 dl_dpch_mask =
    rrc_CellUpdateConfirm_r5_IEs_dl_CommonInformation |
    rrc_CellUpdateConfirm_r5_IEs_dl_InformationPerRL_List;
*/
  ordered_config_type              *tmp_config_ptr = NULL;
  uecomdef_status_e_type dch_ie_processing_status = SUCCESS;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  rrcllc_init_before_msg_processing();


  /* Process the IEs that need to be stored in ORDERED_CONFIG */
  /* Ignore the Integrity Protection and Ciphering IEs */

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(
    (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,activationTime)),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_CU);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /* Get the U-RNTI */
  if(FAILURE == rrcllc_update_urnti_in_oc(
                  RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,new_U_RNTI),
                  &msg_ptr->new_U_RNTI,
                  msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the C-RNTI */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,new_C_RNTI) &&
     (msg_ptr->rrc_StateIndicator != rrc_RRC_StateIndicator_cell_DCH))
  {
    /* Indicate to MAC that have a valid U_RNTI and C_RNTI */
    rrc_translate_crnti(&msg_ptr->new_C_RNTI, &c_rnti);
    ordered_config_ptr->mac_ul_parms.rnti_info.crnti = (uint16)c_rnti;
    ordered_config_ptr->mac_dl_parms.rnti_info.crnti = (uint16)c_rnti;
    
    if((ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == URNTI_VALID)||
       (ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid == BOTH_VALID))
    {
      /* URNTI is already valid - with new CRNTI, both are valid now */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = BOTH_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = BOTH_VALID;
    }
    else
    {
      /* URNTI is NOT valid, with new CRNTI, only CRNTI is valid */
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = CRNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = CRNTI_VALID;
    }
    
#ifdef FEATURE_WCDMA_HS_RACH
    if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH)
    {
      rrchsrach_set_hspa_rnti_stored_cell_pch(ordered_config_ptr,TRUE);
    }
#endif
  }  /* If new CRNTI present */

  /* If transitioning from CELL_DCH to CELL_FACH, or to CELL_PCH or URA_PCH,
   * delete the C-RNTI.
   * The procedure will update C-RNTI later.
   */
  if(((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH) && 
      (current_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)) ||
     (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH ||
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == CRNTI_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = NO_RNTI_VALID;
    }
    else if(ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid == BOTH_VALID)
    {
      ordered_config_ptr->mac_ul_parms.rnti_info.rnti_valid = URNTI_VALID;
      ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;
    }
  }

  /* Get the RRC State Indicator */
  if(FAILURE == rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }

  /* Get the UTRAN DRX cycle length coefficient */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,utran_DRX_CycleLengthCoeff) )
  {
    if((msg_ptr->utran_DRX_CycleLengthCoeff >= RRCLLC_UTRAN_MIN_DRX_CYCLE_LENGTH) && 
       (msg_ptr->utran_DRX_CycleLengthCoeff <= RRCLLC_UTRAN_MAX_DRX_CYCLE_LENGTH)
      )
    {
      ordered_config_ptr->utran_drx_cycle_length = 
        (uint32) (1 << msg_ptr->utran_DRX_CycleLengthCoeff);
    }
    else
    {
      WRRC_MSG1_ERROR("UTRAN DRX Cycle Length Coefficient %d is not valid",
                msg_ptr->utran_DRX_CycleLengthCoeff);
      return FAILURE;
    }
  }
  else if (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH ||
           msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_ura_PCH)
  {
    /* If we're transitioning to Cell_PCH or URA_PCH state, the "UTRAN DRX
    Cycle length coefficient must be present. */
    return FAILURE;
  } /* end UTRAN DRX Cycle Length indicator */


  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,dl_DeletedTransChInfoList))
  {
    dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,dl_AddReconfTransChInfoList))
  {
    dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,ul_deletedTransChInfoList))
  {
    ul_trch_delete_ptr = &msg_ptr->ul_deletedTransChInfoList;
  }
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,ul_AddReconfTransChInfoList))
  {
    ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
  }



  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    if(rrcllc_add_delete_and_arrange_ul_dch_trch_info(ul_trch_add_reconfig_ptr,
                                                      ul_trch_delete_ptr)
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_add_delete_and_arrange_dl_dch_trch_info_r5(dl_trch_add_reconfig_ptr, dl_trch_delete_ptr)== FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }
  } /* If next state is Cell_DCH */

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get the affected RB list if present */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,rb_InformationAffectedList))
  {
    rb_affected_ptr = &msg_ptr->rb_InformationAffectedList;
    idx = 0;

    while((rb_affected_ptr->n > idx) && (idx < MAX_RB))
    {
      if(get_rb_info_affected_r5(&rb_affected_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }
      idx++;
    }
  } /* end Affected RB */

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,rb_InformationReconfigList))
  {
    /* Get the RB reconfiguration list */
    rb_reconfig_ptr = &msg_ptr->rb_InformationReconfigList;
    idx = 0;
    while((rb_reconfig_ptr->n > idx) && (idx < MAX_RB))
    {
      if(get_rb_info_to_reconfig_r5(&rb_reconfig_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }
      idx++;
    } /* end RB reconfig */
  }

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,rb_InformationReleaseList))
  {
    rb_release_ptr  = &msg_ptr->rb_InformationReleaseList;
    idx = 0;
    while((rb_release_ptr->n > idx) && (idx < MAX_RB))
    {
      if(get_rb_info_to_release(&rb_release_ptr->elem[idx]) == FAILURE)
      {
        return FAILURE;
      }
      idx++;
    } /* end RB release */
  }

  if (FAILURE == rrcllc_validate_rb_mapping_info()) 
  {
    return FAILURE;
  }


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Get the Common Uplink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,ul_CommonTransChInfo))
  {
    if(get_ul_info_common_for_all_trch_r5(&msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined
   */
  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,ul_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) && 
            (idx <= UE_MAX_TRCH) && 
            (ul_trch_add_reconfig_ptr->n > idx))
      {
        if(get_ul_added_reconfig_trch(&ul_trch_add_reconfig_ptr->elem[idx]) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }

        /* get next TrCH Info */
        idx++;
      } /* end while */
    } /* end UL TrCH Add/Reconfig */

    /* Check to make sure UL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_ul_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status = FAILURE;
    }  
    /* Calculate the UL TFCS */
    if((dch_ie_processing_status == SUCCESS) && 
       (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
	  	rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL5) == FAILURE)
        { 
          dch_ie_processing_status = FAILURE;
        }
      }

      if((dch_ie_processing_status == SUCCESS) && 
         (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }
      }
    }
  } /* If state is Cell_DCH */

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
                                                     ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      return FAILURE;
    }
  }


  WRRC_MSG1_HIGH(" RBRC R5 Mode specific info FDD %d",msg_ptr->modeSpecificTransChInfo.t);

  /* Ignore the DRAC and CPCH IEs */
  switch(msg_ptr->modeSpecificTransChInfo.t)
  {
    case T_rrc_CellUpdateConfirm_r5_IEs_modeSpecificTransChInfo_fdd:
      break;

    case T_rrc_CellUpdateConfirm_r5_IEs_modeSpecificTransChInfo_tdd:
      break;

    default:
      break;

  } /* end mode switch */


  /* We might receive TrCH info even if the next state isn't Cell_DCH.  This info is
     meant for use when we do transition to Cell_DCH state.  If that's the case, store
     it in the TOC and it will be copied into OC at the appropriate time. */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_PCH ||
     ordered_config_ptr->rrc_state_indicator == RRC_STATE_URA_PCH)
  {
    /* If the TOC isn't valid, we must make it valid now. */
    if(transition_config.toc_usage == TOC_INVALID)
    {
      transition_config.toc_usage = TOC_FOR_DCH;
    }
    tmp_config_ptr = ordered_config_ptr;
    ordered_config_ptr = transition_config.toc_ptr;
    /* Processing functions must think we are going to Cell_DCH state. */
    ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;
  }


  /* Get the Common Downlink Transport Channel information */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,dl_CommonTransChInfo))
  {
    if(get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
                                       &msg_ptr->ul_CommonTransChInfo,
                                       ordered_config_ptr->rrc_state_indicator
                                      ) 
       == FAILURE)
    {
      dch_ie_processing_status = FAILURE;
    }
  }

  if((dch_ie_processing_status == SUCCESS) && 
     (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Get the DL Added or Reconfigured Transport Channel information */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,dl_AddReconfTransChInfoList))
    {
      /* Initialize the UL Add/Reconfig TrCH IE loop variables */
      ul_trch_add_reconfig_ptr = &msg_ptr->ul_AddReconfTransChInfoList;
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
      idx = 0;
    
      /* Save info for each additional Transport Channel */
      while((dch_ie_processing_status == SUCCESS) && 
            (idx <= UE_MAX_TRCH) && dl_trch_add_reconfig_ptr != NULL &&
            (dl_trch_add_reconfig_ptr->n > idx))
      {
        if(get_dl_added_reconfig_trch_r5(&dl_trch_add_reconfig_ptr->elem[idx],
                                      ul_trch_add_reconfig_ptr,
                                      /* RRC Connection Setup doesn't allowed TM signalling DCCH */
                                      FALSE
                                     )
            == FAILURE)
        {
          dch_ie_processing_status = FAILURE;
        }

        /* get next TrCH Info */
        idx++;
      } /* end while */
    } /* end DL TrCH Add/Reconfig */

    /* Adjust TB size on every TrCH if necessary. */ 
    for (idx=0; (dch_ie_processing_status == SUCCESS) && (idx < UE_MAX_TRCH); idx++)
    {
      /* The number of logical channel mapped to this transport channel 
         increases from 1 to 2. Needs to adjsut the tb_szie to
         reflect the adding of the MAC header.                         */
      if (ordered_config_ptr->dl_dch_trch_info[idx].dch_present &&
          (ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up ||
           ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down))
      {
        /* TrCH IE is present and the TrCH ID is appear in the TrCH info table. */
        if (!(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_CellUpdateConfirm_r5_IEs,dl_AddReconfTransChInfoList) &&
            find_trch_id_in_config_trch_list_r5(&msg_ptr->dl_AddReconfTransChInfoList,
                                              ordered_config_ptr->dl_dch_trch_info[idx].trch_id)))
        {
          /* Added MAC head size to the current TB size.  */
          rrcllc_update_tb_size_for_dch(idx);
        }
        WRRC_MSG0_HIGH("Clean TB size adjust flag in CellUpdate");
        /* Reset lg_ch_cnt_up and lg_ch_cnt_down. */
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_up = FALSE;
        ordered_config_ptr->dl_dch_trch_info[idx].lg_ch_cnt_down = FALSE;
      }
      else if (!ordered_config_ptr->dl_dch_trch_info[idx].dch_present)
      {
        /* Since the activated transport channels are sorted before stored in
           the memory, break the looping after reaching the 1st invalid block.  */
        break;
      }
    }


    /* Check to make sure DL TFS count is within UE Capabilities */
    if((dch_ie_processing_status == SUCCESS) && 
       (rrcllc_check_dl_tfs_cnt() == FAILURE))
    {
      dch_ie_processing_status  = FAILURE;
    }
  } /* If state is Cell_DCH */

  /* ----------- The OC ptr is now restor to point to Order config ptr-----------------*/
  if(tmp_config_ptr)
  {
    ordered_config_ptr = tmp_config_ptr;
    tmp_config_ptr = NULL;
  }


  if (dch_ie_processing_status == FAILURE) 
  {
    return FAILURE;
  }

  /* Get the frequency info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_CellUpdateConfirm_r5_IEs,frequencyInfo))
  {
    if(get_frequency_info(&msg_ptr->frequencyInfo,
          msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      return FAILURE;
    }
  }

  /* Get the Maximum allowed UL TX power */
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,maxAllowedUL_TX_Power))
  {
    if(get_max_allow_ul_tx_pwr(msg_ptr->maxAllowedUL_TX_Power) == FAILURE)
    {
      return FAILURE;
    }
  }
  else /* read from Current Config */
  {
    ordered_config_ptr->l1_ul_chan_parms.max_tx_pwr =
      current_config_ptr->l1_ul_chan_parms.max_tx_pwr;
  } /* end Uplink Max Allowed Tx Pwr Info */

  /* Get Uplink DPCH info if included, Ignore CPCH info */
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,ul_ChannelRequirement))
  {
    /* Check to see if this is DPCH or CPCH */
    switch(msg_ptr->ul_ChannelRequirement.t)
    {
      case T_rrc_UL_ChannelRequirement_ul_DPCH_Info:
        if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
        {
          if(get_ul_dpch_info_r5(msg_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
          {
            return FAILURE;
          }
        }
        break;

      case T_rrc_UL_ChannelRequirement_dummy:
        WRRC_MSG0_ERROR("UL CPCH info not supported for CU cnf");
        return FAILURE;

      default:
        WRRC_MSG1_ERROR("Invalid Uplink Channel %d Rcv'd in CU cnf",
                  msg_ptr->ul_ChannelRequirement.t);
        return FAILURE;
    }
  }
  else if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH &&
          current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
   WRRC_MSG2_ERROR("No UL Chan Req, CU cnf state %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  } /* end if check for UL Channel Requirement */

  WRRC_MSG1_HIGH(" RBRC R5 Mode specific info FDD %d",msg_ptr->modeSpecificPhysChInfo.t);
  
  /* Ignore PDSCH IEs */
  switch(msg_ptr->modeSpecificPhysChInfo.t)
  {
    case T_rrc_CellUpdateConfirm_r5_IEs_modeSpecificPhysChInfo_fdd:
      break;

    case T_rrc_CellUpdateConfirm_r5_IEs_modeSpecificPhysChInfo_tdd:
      break;

    default:
      return FAILURE;
  } /* end PDSCH check */

  /* Make sure that if we are transitioning to Cell DCH state that we have
     DL DPCH info in the message. */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
     !((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
	 rrc_CellUpdateConfirm_r5_IEs,dl_CommonInformation)) &&
	(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,dl_InformationPerRL_List)))
    && current_config_ptr->rrc_state_indicator != RRC_STATE_CELL_DCH)
  {
   WRRC_MSG2_ERROR("No DL DPCH, CU cnf %d->%d",
        current_config_ptr->rrc_state_indicator,
        msg_ptr->rrc_StateIndicator);
    return FAILURE;
  }

  /* Get the DL information for all Radio Links */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Initialize the L1 bitmask for the parameters in the "Downlink
     * information for all radio links" IE.  Since the IE is optional,
     * we want to make sure we don't signal L1 erroneously that we have
     * received information when we haven't.
     */
    /* Don't reset DOFF bitmask in DCH state.*/
    ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask = 
      ordered_config_ptr->l1_dl_chan_parms.dl_common.opt_parm_presence_bitmask &
        DL_COMMON_INFO_DEFAULT_DPCH_OFFSET_PRESENT;
    /* Init DL Common Info to Timing Maintained */
    rrcllc_init_dl_common_info(ordered_config_ptr);

    if(FAILURE == rrcllcpcie_is_hho_r5((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
                              rrc_CellUpdateConfirm_r5_IEs,dl_InformationPerRL_List)),
                              &msg_ptr->dl_InformationPerRL_List,
                              msg_ptr->rrc_StateIndicator))
    {
      return FAILURE;
    }

    if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,dl_CommonInformation))
    {
      if(get_dl_info_common_for_all_rl_r5(&msg_ptr->dl_CommonInformation,
                                       &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                       &ordered_config_ptr->l1_dl_cctrch_parms,
                                       &ordered_config_ptr->l1_dl_ctfc_parms
                                      )
         == FAILURE)
      {
        return FAILURE;
      }
    } /* end DL common RL info */
  } /* If next state is Cell_DCH */

  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms
                            );

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,
     rrc_CellUpdateConfirm_r5_IEs,dl_InformationPerRL_List))
  {
    if(get_dl_info_per_rl_r5(&msg_ptr->dl_InformationPerRL_List,
        msg_ptr->rrc_StateIndicator) != SUCCESS)
    {
      return FAILURE;
    }
  }

  if (FAILURE == rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,new_H_RNTI),
      &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator))
  {
    return FAILURE;
  }


  /* Get HSDPA Info */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    
    /* SET Action Variable by calling HSDPA action table */
    /* First check if HSDPA is already active or is being activated */
    if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,dl_HSPDSCH_Information))
    {
      hsdpa_msg_params.msg_params_present = TRUE;
      hsdpa_msg_params.hspdsch_info_present = TRUE;         
    }
    
    /* Determine if IFHHO is involved */
    if ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq()))
    {
      WRRC_MSG0_HIGH("RRCHS:InterFreq HO");
      hsdpa_msg_params.ifhho_involved = TRUE;
      hsdpa_msg_params.msg_params_present= TRUE;
    }
    
    if (rrcllc_determine_hsdpa_action(&msg_ptr->dl_HSPDSCH_Information) == SUCCESS)
    {
     rrc_set_hsdpa_action_in_machs_macehs();
     rrcllcpcie_update_hs_tfri_table_type_non_r7_ota();

      MSG_5(MSG_SSID_DFLT, MSG_LEGACY_HIGH,"RRCHS:HSDPA Action %d set in MAC CM VAR %d CM status L1/RRC/OTA %d %d %d",
      ordered_config_ptr->mac_dl_parms.mac_hsdpa_action,
      hsdpa_cm_enabled,
      l1_cm_query_compressed_mode_active(),
      rrcllc_is_cm_active(ordered_config_ptr),
      cm_status_from_ota_msg
      );

      /* Check if network is trying to activate CM with HSDPA */
      if(rrcllc_is_cm_active_with_hsdpa())
      {
        return FAILURE;
      }
    }
    else
    {
      WRRC_MSG0_ERROR("RRCHS:Error during HSDPA action processing"); 
      return FAILURE;        
    }

  } /* If next state is Cell_DCH */ 

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable
   */
  if(rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->rrc_StateIndicator)
    == FAILURE)
  { 
    return FAILURE;
  }

  if (rrcllc_is_cm_deactive_with_eul())
  {
    return(FAILURE);
  }

  if (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)) 
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    return FAILURE;
  }


  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(&msg_ptr->rb_InformationReleaseList) == FAILURE)
    {
      return FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_MIMO
  if(rrcllcpcie_process_mimo_params(NULL,
    msg_ptr->rrc_StateIndicator, FALSE ) == FAILURE)
  {
    return(FAILURE);
  }
#endif

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((rrcllcpcie_process_dc_hsdpa_params(NULL,msg_ptr->rrc_StateIndicator,
    FALSE)) == FAILURE)
  {
    return FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_CellUpdateConfirm_r5_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        FALSE);

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  rrcllc_check_and_stop_dtx(msg_ptr->rrc_StateIndicator,MSG_REL5);

#ifdef FEATURE_WCDMA_DC_HSUPA
    if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
      FALSE)== FAILURE)
    {
      status = FAILURE;
    }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* Got here, everything is okay */
  return status;

} /* end rrcllc_cell_update_confirm_ie_r5() */

/*====================================================================
FUNCTION: rrcllc_update_oc_with_srb5()

DESCRIPTION:
  This function updates ordered_config with SRB#5 information such as 
  RB ID & transport channel ID.

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE if SRB#5 is found & OC is successful cases.
  FALSE otherwise

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_update_oc_with_srb5
(
  rrc_SRB_InformationSetup_r5 * srb_setup_r5_ptr, 
  rrc_RB_Identity rb_id
)
{
  rrc_RB_Identity srb5_trch_id = 0;
  rrc_RB_Identity srb5_id = 0;
  uint8         trch_idx = RRCLLC_INVALID_TRCH_IDX;
  uecomdef_status_e_type result = FAILURE;

  if(srb_setup_r5_ptr != NULL)
  {
    /* Probably SRB5 exists  */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(srb_setup_r5_ptr,
		rrc_SRB_InformationSetup_r5,rb_Identity))
    {
      srb5_id = srb_setup_r5_ptr->rb_Identity;
    }
    else
    {
      srb5_id = rb_id;
    }

    /* Verify RLC mode - accept iff DL TM mode */
    if(RRC_CHECK_COMMON_MSG_TYPE(srb_setup_r5_ptr->rlc_InfoChoice,rrc_RLC_InfoChoice_r5_rlc_Info))
    {
      if(RRC_MSG_COMMON_BITMASK_IE_PTR_FOR_OBYS_ONLY(srb_setup_r5_ptr->rlc_InfoChoice.u.rlc_Info,
	  	rrc_RLC_Info_r5,ul_RLC_Mode))
      {
        WRRC_MSG0_ERROR("SRB#5 can't have UL mode .. rejecting");
        return result;
      }
      else if(RRC_MSG_COMMON_BITMASK_IE_PTR_FOR_OBYS_ONLY(srb_setup_r5_ptr->rlc_InfoChoice.u.rlc_Info,
	  	 rrc_RLC_Info_r5,dl_RLC_Mode))
      {
        if(!(RRC_CHECK_COMMON_MSG_TYPE(srb_setup_r5_ptr->rlc_InfoChoice.u.rlc_Info->dl_RLC_Mode,
			rrc_DL_RLC_Mode_r5_dl_TM_RLC_Mode)))
        {
          WRRC_MSG0_ERROR("SRB#5 can't be in other than DL TM mode .. rejecting");
          return result;
        }
      }
      else
      {
        WRRC_MSG0_ERROR("SRB#5 can't be in other than DL .. rejecting");
        return result;
      }
    }
    else
    {
      WRRC_MSG0_ERROR("No other SRB can have the characteristics of SRB#5 .. rejecting");
      return result;
    }
    
    /* Verify RLC mapping */
    if(srb_setup_r5_ptr->rb_MappingInfo.elem[0].m.ul_LogicalChannelMappingsPresent)
    {
      WRRC_MSG0_ERROR("SRB#5 can't have UL mapping .. rejecting");
      return result;
    }
    else if(srb_setup_r5_ptr->rb_MappingInfo.elem[0].m.dl_LogicalChannelMappingListPresent)
    {
      if(srb_setup_r5_ptr->rb_MappingInfo.elem[0].dl_LogicalChannelMappingList.elem[0].dl_TransportChannelType.t 
	  	== T_rrc_DL_TransportChannelType_r5_dch)
      {
        /* Remember the mapped TRCH ID for SRB5 */
        srb5_trch_id = srb_setup_r5_ptr->rb_MappingInfo.elem[0].dl_LogicalChannelMappingList.elem[0].dl_TransportChannelType.u.dch;
      }
      else
      {
        WRRC_MSG0_ERROR("SRB#5 can't DL mapping other than DCH .. rejecting");
        return result;
      }
    }
    else
    {
      WRRC_MSG0_ERROR("SRB#5 can't DL mapping other than DCH .. rejecting");
      return result;
    }

    trch_idx = rrcllc_find_dl_dch_trch_idx((tr_ch_id_type)srb5_trch_id);

    if (trch_idx >= UE_MAX_TRCH)
    {
     WRRC_MSG1_ERROR("DL DCH TrCH ID %d, no idx found", srb5_trch_id);
      return result;
    }

    /* If we came this far, we found SRB5. Update OC with SRB5 info */
    ordered_config_ptr->srb5_info.srb5_rb_exists   = TRUE;
    ordered_config_ptr->srb5_info.rb_id            = srb5_id;
    ordered_config_ptr->srb5_info.srb5_trch_exists = TRUE;
    ordered_config_ptr->srb5_info.trch_id          = srb5_trch_id;


    WRRC_MSG2_HIGH("Updated OC with SRB5 INFO->rb id=%d, tchid=%d",
 srb5_id, srb5_trch_id);
    result = SUCCESS;
  }
  else
  {
    WRRC_MSG0_ERROR("One of the SRB pointers is NULL ... rejecting");
    result = FAILURE;
  }

  return result;
} /* rrcllc_update_oc_with_srb5 */
/*====================================================================
FUNCTION: rrcllc_update_oc_with_srb5_rel6_ie()

DESCRIPTION:
  This function updates ordered_config with SRB#5 information such as 
  RB ID & transport channel ID.

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE if SRB#5 is found & OC is successful cases.
  FALSE otherwise

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_update_oc_with_srb5_rel6_ie
(
  rrc_SRB_InformationSetup_r6 * srb_setup_r6_ptr, 
  rrc_RB_Identity rb_id
)
{
  uint32 srb5_trch_id = 0;
  rrc_RB_Identity srb5_id = 0;
  uint8         trch_idx = RRCLLC_INVALID_TRCH_IDX;
  uecomdef_status_e_type result = FAILURE;

  if(srb_setup_r6_ptr != NULL)
  {
    WRRC_MSG0_HIGH("Probable SRB5 INFO .. processing");
    /* Probably SRB5 exists  */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(srb_setup_r6_ptr,rrc_SRB_InformationSetup_r6,rb_Identity))
    {
      srb5_id = srb_setup_r6_ptr->rb_Identity;
    }
    else
    {
      srb5_id = rb_id;
    }

    /* Verify RLC mode - accept iff DL TM mode */
    if(RRC_CHECK_COMMON_MSG_TYPE(srb_setup_r6_ptr->rlc_InfoChoice,rrc_RLC_InfoChoice_r6_rlc_Info))
    {
      if(RRC_MSG_COMMON_BITMASK_IE_PTR_FOR_OBYS_ONLY(srb_setup_r6_ptr->rlc_InfoChoice.u.rlc_Info,
	  	     rrc_RLC_Info_r6,ul_RLC_Mode))
      {
        WRRC_MSG0_ERROR("SRB#5 can't have UL mode .. rejecting");
        return result;
      }
      else if(RRC_MSG_COMMON_BITMASK_IE_PTR_FOR_OBYS_ONLY(srb_setup_r6_ptr->rlc_InfoChoice.u.rlc_Info,
	  	  rrc_RLC_Info_r6,dl_RLC_Mode))
      {
        if(!(RRC_CHECK_COMMON_MSG_TYPE(srb_setup_r6_ptr->rlc_InfoChoice.u.rlc_Info->dl_RLC_Mode,rrc_DL_RLC_Mode_r6_dl_TM_RLC_Mode)))
        {
          WRRC_MSG0_ERROR("SRB#5 can't be in other than DL TM mode .. rejecting");
          return result;
        }
      }
      else
      {
        WRRC_MSG0_ERROR("SRB#5 can't be in other than DL .. rejecting");
        return result;
      }
    }
    else
    {
      WRRC_MSG0_ERROR("No other SRB can have the characteristics of SRB#5 .. rejecting");
      return result;
    }

    /* Verify RLC mapping */
    if(srb_setup_r6_ptr->rb_MappingInfo.elem[0].m.ul_LogicalChannelMappingsPresent)
    {
      WRRC_MSG0_ERROR("SRB#5 can't have UL mapping .. rejecting");
      return result;
    }
    else if(srb_setup_r6_ptr->rb_MappingInfo.elem[0].m.dl_LogicalChannelMappingListPresent)
    {
      if(srb_setup_r6_ptr->rb_MappingInfo.elem[0].dl_LogicalChannelMappingList.
	  	elem[0].dl_TransportChannelType.t == T_rrc_DL_TransportChannelType_r5_dch)
      {
        /* Remember the mapped TRCH ID for SRB5 */
        srb5_trch_id = srb_setup_r6_ptr->rb_MappingInfo.elem[0].dl_LogicalChannelMappingList.elem[0].
           dl_TransportChannelType.u.dch;
      }
      else
      {
        WRRC_MSG0_ERROR("SRB#5 can't DL mapping other than DCH .. rejecting");
        return result;
      }
    }
    else
    {
      WRRC_MSG0_ERROR("SRB#5 can't DL mapping other than DCH .. rejecting");
      return result;
    }

    trch_idx = rrcllc_find_dl_dch_trch_idx((tr_ch_id_type)srb5_trch_id);

    if (trch_idx >= UE_MAX_TRCH)
    {
     WRRC_MSG1_ERROR("DL DCH TrCH ID %d, no idx found", srb5_trch_id);
      return result;
    }

    /* If we came this far, we found SRB5. Update OC with SRB5 info */
    ordered_config_ptr->srb5_info.srb5_rb_exists   = TRUE;
    ordered_config_ptr->srb5_info.rb_id            = srb5_id;
    ordered_config_ptr->srb5_info.srb5_trch_exists = TRUE;
    ordered_config_ptr->srb5_info.trch_id          = srb5_trch_id;


    WRRC_MSG2_HIGH("Updated OC with SRB5 INFO->rb id=%d, tchid=%d",
 srb5_id, srb5_trch_id);
    result = SUCCESS;
  }
  else
  {
    WRRC_MSG0_ERROR("One of the SRB pointers is NULL ... rejecting");
    result = FAILURE;
  }

  return result;
}
/*====================================================================
FUNCTION: rrcllc_update_oc_with_srb5_rel7_ie()

DESCRIPTION:
  This function updates ordered_config with SRB#5 information such as 
  RB ID & transport channel ID.

DEPENDENCIES:
  None.

RETURN VALUE:
  TRUE if SRB#5 is found & OC is successful cases.
  FALSE otherwise

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type
rrcllc_update_oc_with_srb5_rel7_ie
(
  rrc_SRB_InformationSetup_r7 * srb_setup_r7_ptr, 
  rrc_RB_Identity rb_id
)
{
  uint32 srb5_trch_id = 0;
  rrc_RB_Identity srb5_id = 0;
  uint8         trch_idx = RRCLLC_INVALID_TRCH_IDX;
  uecomdef_status_e_type result = FAILURE;

  if(srb_setup_r7_ptr != NULL)
  {
    WRRC_MSG0_HIGH("Probable SRB5 INFO .. processing");
    /* Probably SRB5 exists  */
    if(RRC_MSG_COMMON_BITMASK_IE_PTR(srb_setup_r7_ptr,rrc_SRB_InformationSetup_r7,rb_Identity))
    {
      srb5_id = srb_setup_r7_ptr->rb_Identity;
    }
    else
    {
      srb5_id = rb_id;
    }

    /* Verify RLC mode - accept iff DL TM mode */
    if(RRC_CHECK_COMMON_MSG_TYPE(srb_setup_r7_ptr->rlc_InfoChoice,rrc_RLC_InfoChoice_r7_rlc_Info))
    {
      if(RRC_MSG_COMMON_BITMASK_IE_PTR_FOR_OBYS_ONLY(srb_setup_r7_ptr->rlc_InfoChoice.u.rlc_Info,
	  	   rrc_RLC_Info_r7,ul_RLC_Mode))
      {
        WRRC_MSG0_ERROR("SRB#5 can't have UL mode .. rejecting");
        return result;
      }
      else if(RRC_MSG_COMMON_BITMASK_IE_PTR_FOR_OBYS_ONLY(srb_setup_r7_ptr->rlc_InfoChoice.u.rlc_Info,
	  	  rrc_RLC_Info_r7,dl_RLC_Mode))
      {
        if(RRC_CHECK_COMMON_MSG_TYPE(srb_setup_r7_ptr->rlc_InfoChoice.u.rlc_Info->dl_RLC_Mode,
			rrc_DL_RLC_Mode_r7_dl_TM_RLC_Mode))
        {
          WRRC_MSG0_ERROR("SRB#5 can't be in other than DL TM mode .. rejecting");
          return result;
        }
      }
      else
      {
        WRRC_MSG0_ERROR("SRB#5 can't be in other than DL .. rejecting");
        return result;
      }
    }
    else
    {
      WRRC_MSG0_ERROR("No other SRB can have the characteristics of SRB#5 .. rejecting");
      return result;
    }

    /* Verify RLC mapping */
    if(srb_setup_r7_ptr->rb_MappingInfo.elem[0].m.ul_LogicalChannelMappingsPresent)
    {
      WRRC_MSG0_ERROR("SRB#5 can't have UL mapping .. rejecting");
      return result;
    }
    else if(srb_setup_r7_ptr->rb_MappingInfo.elem[0].m.dl_LogicalChannelMappingListPresent)
    {
      if(srb_setup_r7_ptr->rb_MappingInfo.elem[0].dl_LogicalChannelMappingList.
          elem[0].dl_TransportChannelType.t == T_rrc_DL_TransportChannelType_r7_dch)
      {
        /* Remember the mapped TRCH ID for SRB5 */
        srb5_trch_id = srb_setup_r7_ptr->rb_MappingInfo.elem[0].dl_LogicalChannelMappingList.elem[0].dl_TransportChannelType.u.dch;
      }
      else
      {
        WRRC_MSG0_ERROR("SRB#5 can't DL mapping other than DCH .. rejecting");
        return result;
      }
    }
    else
    {
      WRRC_MSG0_ERROR("SRB#5 can't DL mapping other than DCH .. rejecting");
      return result;
    }

    trch_idx = rrcllc_find_dl_dch_trch_idx((tr_ch_id_type)srb5_trch_id);

    if (trch_idx == RRCLLC_INVALID_TRCH_IDX)
    {
     WRRC_MSG1_ERROR("DL DCH TrCH ID %d, no idx found", srb5_trch_id);
      return result;
    }

    /* If we came this far, we found SRB5. Update OC with SRB5 info */
    ordered_config_ptr->srb5_info.srb5_rb_exists   = TRUE;
    ordered_config_ptr->srb5_info.rb_id            = srb5_id;
    ordered_config_ptr->srb5_info.srb5_trch_exists = TRUE;
    ordered_config_ptr->srb5_info.trch_id          = srb5_trch_id;


    WRRC_MSG2_HIGH("Updated OC with SRB5 INFO->rb id=%d, tchid=%d",srb5_id, srb5_trch_id);
    result = SUCCESS;
  }
  else
  {
    WRRC_MSG0_ERROR("One of the SRB pointers is NULL ... rejecting");
    result = FAILURE;
  }

  return result;
}

/*====================================================================
FUNCTION: rrcllc_init_cpc_dtx_info_before_msg_processing()

DESCRIPTION:
  This function resets needed CPC-DTX variables before processing any config message

DEPENDENCIES:
  Function is only called before processing the DL OTA Msg.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_cpc_dtx_info_before_msg_processing
(
  ordered_config_type *config_ptr
)
{
  config_ptr->l1_cpc_dtx_req_mask = L1_CPC_DTX_NO_OP;
  config_ptr->l1_hs_scch_order_action = L1_HS_SCCH_ORDER_ACTION_BACKUP;
}


/*====================================================================
FUNCTION: rrcllc_init_cpc_drx_info_before_msg_processing()

DESCRIPTION:
  This function resets needed CPC-DRX variables before processing any config message

DEPENDENCIES:
  Function is only called before processing the DL OTA Msg.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
void rrcllc_init_cpc_drx_info_before_msg_processing
(
  ordered_config_type *config_ptr
)
{
  config_ptr->l1_cpc_drx_req_mask = L1_CPC_DRX_NO_OP;
}

/*====================================================================
FUNCTION: rrcllc_rb_setup_ie_r8()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Setup Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_setup_ie_r8
(
  rrc_RadioBearerSetup_r8 * rb_setup_r8_ota
)
{
  uecomdef_status_e_type                    status = SUCCESS;
  rrc_RadioBearerSetup_r8_IEs             *msg_ptr;
  rrc_DL_AddReconfTransChInfoList_r7  * dl_trch_add_reconfig_ptr = NULL;
  rrc_DL_DeletedTransChInfoList_r7     * dl_trch_delete_ptr = NULL;
  ordered_config_type                          *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;
  msg_ptr = &rb_setup_r8_ota->radioBearerSetup_r8;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));


  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,
    new_DSCH_RNTI))
  {
     return FAILURE;
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,
    controlChannelDRXInfo_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,
    sps_Information_TDD128))
  {
    return FAILURE;
  }

  /* We're processing a reconfiguration message now, so set the reconfig_in_progress flag accordingly.*/
  ordered_config.reconfig_in_progress = TRUE;
  
  rrcllc_init_before_msg_processing();

  if(msg_ptr->m.sr_vcc_InfoPresent)
  {
    WRRC_MSG0_HIGH("REL8: IE sr-vcc-Info not supported yet!");
    return FAILURE;
  }

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
    rrc_RadioBearerSetup_r8_IEs,activationTime)), msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, 
    RRC_PROCEDURE_RBE);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /*Update U-RNTI in OC for MAC and also update SCCPCH Info from SIB5/6*/
  status = rrcllc_update_urnti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
    rrc_RadioBearerSetup_r8_IEs,new_U_RNTI)), &msg_ptr->new_U_RNTI,
    msg_ptr->rrc_StateIndicator);
 
  /*Update C-RNTI in OC for MAC*/
  rrcllc_update_crnti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
    rrc_RadioBearerSetup_r8_IEs,new_C_RNTI)), msg_ptr->new_C_RNTI, 
    msg_ptr->rrc_StateIndicator);

  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
    rrc_RadioBearerSetup_r8_IEs,utran_DRX_CycleLengthCoeff)),
    &msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerSetup_r8_IEs,frequencyInfo)), &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerSetup_r8_IEs,maxAllowedUL_TX_Power)),
      msg_ptr->maxAllowedUL_TX_Power);
  }

  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
    * and count) and rearrange the info by sorting transport channel list
    * based on TrCH ID. */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,ul_AddReconfTransChInfoList)),
      &msg_ptr->ul_AddReconfTransChInfoList,
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,ul_deletedTransChInfoList)),
      &msg_ptr->ul_deletedTransChInfoList);

  
    if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }
  
    if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,dl_DeletedTransChInfoList))
    {
      dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
    }
  
    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
    would be updated later */
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(dl_trch_add_reconfig_ptr, 
                    dl_trch_delete_ptr);
    }

  }
  
   /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  /* Get the SRB setup list if present */
  if (SUCCESS == status)
  {
    status =  rrcllc_process_srb_info_setup_list_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerSetup_r8_IEs,srb_InformationSetupList)), 
      &msg_ptr->srb_InformationSetupList);
  }
  
  /* Get the RAB setup list if present */
  if (SUCCESS == status)
  {
    status = rrcllc_process_rab_info_setup_list_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerSetup_r8_IEs,rab_InformationSetupList)),
      &msg_ptr->rab_InformationSetupList);
  }

  /* Get the RB reconfiguration list */
  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_reconfig_list_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerSetup_r8_IEs,rb_InformationReconfigList)),
      &msg_ptr->rb_InformationReconfigList);
  }

  /* Get the RB Affected list */  
  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_affected_list_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerSetup_r8_IEs,rb_InformationAffectedList)),
      &msg_ptr->rb_InformationAffectedList);
  }
  
  if (SUCCESS == status) 
  {
    status = rrcllc_validate_rb_mapping_info();
  }
  
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  /* Get the Common Uplink Transport Channel information */
  if (SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerSetup_r8_IEs,ul_CommonTransChInfo)),
      &msg_ptr->ul_CommonTransChInfo);
  }
  
  /* Do the processing for Uplink added/reconfigured TrCH, Compute
  * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
  * (for Cell FACH state), this check for state needs to be re-examined */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
#ifdef FEATURE_VOC_AMR_WB
      ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/

    status = rrcllc_store_ul_add_reconf_trch_info_list_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
        rrc_RadioBearerSetup_r8_IEs,ul_AddReconfTransChInfoList)),
        &msg_ptr->ul_AddReconfTransChInfoList);
  
    /* Calculate the UL TFCS */
    if((SUCCESS == status) && (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,
      ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
	  	 rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL8) == FAILURE)
        {
          return FAILURE;
        }
      }

      /*RRC_GKG: Processing of TFC subset List is under UL CommonTransChList.*/
      if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(
	  	msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          status = FAILURE;
        }
      }
    }
  }   /* If state is Cell_DCH */

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if(SUCCESS == status)
  {
    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
        ordered_config_ptr->rrc_state_indicator);
    }
  }

  /* For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) && (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,
    dl_CommonTransChInfo)))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo, ordered_config_ptr->rrc_state_indicator);
  }
  
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r8(
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,
      dl_AddReconfTransChInfoList)), &msg_ptr->dl_AddReconfTransChInfoList,
      &msg_ptr->ul_AddReconfTransChInfoList);
  }
  
   /* The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr(tmp_config_ptr);

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,pdcp_ROHC_TargetMode))
  {
    WRRC_MSG0_ERROR("REL8: pdcp_ROHC_TargetMode IE not supported yet");
    /*RRC_GKG: From Spec, see whether we need to ignore or return Failure*/
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,ul_DPCH_Info)),
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,dl_CommonInformation)),
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,dl_InformationPerRL_List)),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerSetup_r8_IEs,ul_DPCH_Info)),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,
      dl_InformationPerRL_List)), &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerSetup_r8_IEs,dl_CommonInformation)), &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerSetup_r8_IEs,dl_InformationPerRL_List)), 
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,
    newPrimary_E_RNTI)), msg_ptr->newPrimary_E_RNTI, TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,
    newSecondary_E_RNTI)), msg_ptr->newSecondary_E_RNTI, FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r8(
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,ul_EDCH_Information)),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
    update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable*/
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,
      new_H_RNTI)), &msg_ptr->new_H_RNTI, msg_ptr->rrc_StateIndicator);
  }

  /* Get HSDPA Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r8(
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,dl_HSPDSCH_Information)),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }


#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r8(&msg_ptr->mimoParameters, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,
    mimoParameters))) == FAILURE))
  {
    status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_rbe_r8(rb_setup_r8_ota);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

#else /*FEATURE_WCDMA_MIMO*/
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,mimoParameters))
  {
    WRRC_MSG0_ERROR("REL8: mimoParameters IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_MIMO*/


#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,
    dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if((rb_setup_r8_ota != NULL) && (rb_setup_r8_ota->m.v7d0NonCriticalExtensionsPresent) 
		&&(rb_setup_r8_ota->v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent) 
		&&(rb_setup_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.m.v890NonCriticalExtensionsPresent) 
        &&(rb_setup_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.radioBearerSetup_v890ext.
           m.dl_SecondaryCellInfoFDD_v890extPresent) && (rb_setup_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.
           radioBearerSetup_v890ext.dl_SecondaryCellInfoFDD_v890ext.m.differentTxModeFromServingHS_DSCHCellPresent))
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = TRUE;
      WRRC_MSG0_HIGH("DC-HSDPA:Different Txd Signaled in OTA.");  
    }
    else
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = FALSE;
    }
  }
 
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL8: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,hs_scch_LessInfo))
  {
    WRRC_MSG0_ERROR("REL8: hs_scch_LessInfo IE not supported yet!");
    status = FAILURE;
  }
  
  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
        (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,dtx_drx_TimingInfo)),
        &msg_ptr->dtx_drx_Info,
        (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,dtx_drx_Info)),
        msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerSetup_r8_IEs,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_DC_HSUPA
      if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
        FALSE)== FAILURE)
      {
        status = FAILURE;
      }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* By now the status has been filled as per the processing.*/
  return (status);
}

/*====================================================================
FUNCTION: rrcllc_rb_reconfig_ie_r8()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Reconfiguration Message R8

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_reconfig_ie_r8
(
  rrc_RadioBearerReconfiguration_r8 * rb_reconfig_r8_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_RadioBearerReconfiguration_r8_IEs *msg_ptr;
  rrc_DL_DeletedTransChInfoList_r7   * dl_trch_delete_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList_r7 * dl_trch_add_reconfig_ptr = NULL;
  ordered_config_type              *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  msg_ptr  = &rb_reconfig_r8_ota->radioBearerReconfiguration_r8;

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,
    new_DSCH_RNTI))
  {
     return FAILURE;
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,
    controlChannelDRXInfo_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,
    sps_Information_TDD128))
  {
    return FAILURE;
  }

  /*We're processing a reconfiguration message now, so set the reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  rrcllc_init_before_msg_processing();

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,delayRestrictionFlag) !=0);
#endif

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
    rrc_RadioBearerReconfiguration_r8_IEs,activationTime)),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBRC);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  status = rrcllc_update_urnti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
    rrc_RadioBearerReconfiguration_r8_IEs,new_U_RNTI)), &msg_ptr->new_U_RNTI,
    msg_ptr->rrc_StateIndicator);

  rrcllc_update_crnti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
    rrc_RadioBearerReconfiguration_r8_IEs,new_C_RNTI)), msg_ptr->new_C_RNTI, 
    msg_ptr->rrc_StateIndicator);

  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerReconfiguration_r8_IEs,utran_DRX_CycleLengthCoeff)),
      &msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerReconfiguration_r8_IEs,frequencyInfo)), &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerReconfiguration_r8_IEs,maxAllowedUL_TX_Power)),
      msg_ptr->maxAllowedUL_TX_Power);
  }

    /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/
  if ((SUCCESS == status) && (T_rrc_RadioBearerReconfiguration_r8_IEs_specificationMode_complete ==
      msg_ptr->specificationMode.t))
  {
    /* Call these functions ONLY in DCH state */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Here, update the transport channel info (only transport channel IDs 
      * and count) and rearrange the info by sorting transport channel list
      * based on TrCH ID. */
      status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(
        RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r8_IEs),
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList,
        RRCRB_R6_UL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r8_IEs),
        &msg_ptr->specificationMode.u.complete.ul_deletedTransChInfoList);


      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
      if (RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r8_IEs))
      {
        dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
      }

      if (RRCRB_R6_DL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r8_IEs))
      {
        dl_trch_delete_ptr = &msg_ptr->specificationMode.u.complete.dl_DeletedTransChInfoList;
      }

      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
      if (SUCCESS == status)
      {
        status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(
           dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
      }

    }

     /*The OC ptr is now restor to point to Order config ptr*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);
     
    /* Get the RB reconfiguration list */
    if (SUCCESS == status)
    {
      status = rrcllc_process_rb_info_reconfig_list_r8(RRCRB_R6_RB_INFO_RECONFIG_LIST_PRESENT(msg_ptr, 
        rrc_RadioBearerReconfiguration_r8_IEs), &msg_ptr->specificationMode.u.complete.rb_InformationReconfigList);
    }

    if (SUCCESS == status)
    {
      status = rrcllc_process_rb_info_affected_list_r8(RRCRB_R6_RB_INFO_AFFECTED_LIST_PRESENT(msg_ptr, 
        rrc_RadioBearerReconfiguration_r8_IEs), &msg_ptr->specificationMode.u.complete.rb_InformationAffectedList);
    }

    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }

      /* use TOC ptr if not received in DCH state */
    tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

   /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
   OC ptr is now pointing to TOC ptr*/
      
    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(
        RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r8_IEs),
        &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined */
    if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
#ifdef FEATURE_VOC_AMR_WB
      ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/

      status = rrcllc_store_ul_add_reconf_trch_info_list_r8(
          RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r8_IEs),
          &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);

      /* Calculate the UL TFCS */
      if((SUCCESS == status) && (RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr, 
        rrc_RadioBearerReconfiguration_r8_IEs)))
      {
        compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

        if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
			     rrc_UL_CommonTransChInfo_r4,tfc_Subset))
        {
          if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo, 
            MSG_REL8) == FAILURE)
          {
            status = FAILURE;
          }
          if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
            tfc_SubsetList)))
          {
            if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo) == FAILURE)
            {
              status = FAILURE;
            }
          }
        }
      }
    } /* If state is Cell_DCH */

    /*The OC ptr is now restor to point to Order config ptr*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);

    if (SUCCESS == status)
    {
      /* Fill in the RLC size restriction information for MAC */
      if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
        !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
      {
        status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
          ordered_config_ptr->rrc_state_indicator);
      }
    }

    /* use TOC ptr if not received in DCH state */
    tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

    /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
    OC ptr is now pointing to TOC ptr*/

    /* Get the Common Downlink Transport Channel information */
    if((SUCCESS == status) &&
       (RRCRB_R6_DL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r8_IEs)))
    {
      status = get_dl_info_common_for_all_trch_r5(&msg_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
        &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
        ordered_config_ptr->rrc_state_indicator);
    }

    if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r8(
        RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r8_IEs),
        &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    } /* If state is Cell_DCH */      

    /* The OC ptr is now restor to point to Order config ptr */
    rrcllc_restore_oc_ptr (tmp_config_ptr);

    if ( msg_ptr->specificationMode.u.complete.m.pdcp_ROHC_TargetModePresent)
    {
      WRRC_MSG0_ERROR("REL8: pdcp_ROHC_TargetMode IE not supported yet!");
    }
  }
  else /* rrc_RadioBearerReconfiguration_r8_IEs_specificationMode_complete */
  {
    WRRC_MSG0_ERROR("REL8: SpecificationMode preconfiguration isn't supported yet!");
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,ul_DPCH_Info)),
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,dl_CommonInformation)),
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,dl_InformationPerRL_List)),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerReconfiguration_r8_IEs,ul_DPCH_Info)),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,
      dl_InformationPerRL_List)), &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerReconfiguration_r8_IEs,dl_CommonInformation)), &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerReconfiguration_r8_IEs,dl_InformationPerRL_List)), 
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,
    newPrimary_E_RNTI)), msg_ptr->newPrimary_E_RNTI, TRUE, msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,
    newSecondary_E_RNTI)), msg_ptr->newSecondary_E_RNTI, FALSE, msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerReconfiguration_r8_IEs,ul_EDCH_Information)),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of
     e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerReconfiguration_r8_IEs,new_H_RNTI)), &msg_ptr->new_H_RNTI,
      msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r8(
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,dl_HSPDSCH_Information)),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }


  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r8(&msg_ptr->mimoParameters, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,
    mimoParameters))) == FAILURE))
  {
    status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_rbrc_r8(rb_reconfig_r8_ota);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
#else /*FEATURE_WCDMA_MIMO*/
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL8: mimoParameters not supported ");
  }
#endif /*FEATURE_WCDMA_MIMO*/


  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,hs_scch_LessInfo))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL8: hs_scch_LessInfo not supported ");
  }

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,
    dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if((rb_reconfig_r8_ota != NULL) && (rb_reconfig_r8_ota->m.v7d0NonCriticalExtensionsPresent)
	   &&(rb_reconfig_r8_ota->v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent) 
	   &&(rb_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.m.v890NonCriticalExtensionsPresent) 
	   &&(rb_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.radioBearerReconfiguration_v890ext.
           m.dl_SecondaryCellInfoFDD_v890extPresent) && (rb_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.
           radioBearerReconfiguration_v890ext.dl_SecondaryCellInfoFDD_v890ext.m.differentTxModeFromServingHS_DSCHCellPresent))
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = TRUE;
      WRRC_MSG0_HIGH("DC-HSDPA:Different Txd Signaled in OTA.");  
    }
    else
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = FALSE;
    }
  }
  
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL8: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  if ((SUCCESS == status) && (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,delayRestrictionFlag))
    {
      if((RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r8_IEs))
         ||(RRCRB_R6_UL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r8_IEs))
         ||(RRCRB_R6_DL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r8_IEs))
         ||(RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r8_IEs))
      ) 
      {
         WRRC_MSG0_ERROR("REL8: Trch IE touched bitmask  , so Delay restriction cannot be applied");
      }
      else
      {
        rrcllc_update_delay_restriction((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
          rrc_RadioBearerReconfiguration_r8_IEs,activationTime)),
        (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,delayRestrictionFlag)),
         msg_ptr->activationTime,msg_ptr->rrc_StateIndicator);
      }
    }
  }

  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
         (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,dtx_drx_TimingInfo)),
         &msg_ptr->dtx_drx_Info,
         (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,dtx_drx_Info)),
         msg_ptr->rrc_StateIndicator
    ) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerReconfiguration_r8_IEs,newPrimary_E_RNTI));

  }
#endif  /*FEATURE_WCDMA_HS_RACH*/
#endif /*FEATURE_WCDMA_HS_FACH*/


#ifdef FEATURE_WCDMA_DC_HSUPA
      if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
        FALSE)== FAILURE)
      {
        status = FAILURE;
      }  
#endif /* FEATURE_WCDMA_DC_HSUPA */


  /* By now the status has been filled as per the processing.*/
  return (status);
}

/*====================================================================
FUNCTION: rrcllc_rb_release_ie_r8()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Release 8 Radio Bearer Release Message R8.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_release_ie_r8
(
  rrc_RadioBearerRelease_r8 * rb_release_r8_ota
)
{
  uecomdef_status_e_type                status = SUCCESS;
  rrc_DL_DeletedTransChInfoList_r7  * dl_trch_delete_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList_r7 * dl_trch_add_reconfig_ptr = NULL;
  ordered_config_type                         *tmp_config_ptr = NULL;
  rrc_RadioBearerRelease_r8_IEs      *msg_ptr;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  msg_ptr= &rb_release_r8_ota->radioBearerRelease_r8;

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,
    new_DSCH_RNTI))
  {
     return FAILURE;
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,
    controlChannelDRXInfo_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,
    sps_Information_TDD128))
  {
    return FAILURE;
  }

  rrcllc_init_before_msg_processing();

  /*We're processing a reconfiguration message now, so set the reconfig_in_progress flag accordingly.*/
  ordered_config.reconfig_in_progress = TRUE;

  status = rrcllc_update_urnti_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,
    new_U_RNTI), &msg_ptr->new_U_RNTI, msg_ptr->rrc_StateIndicator);

  rrcllc_update_crnti_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,
    new_C_RNTI), msg_ptr->new_C_RNTI, msg_ptr->rrc_StateIndicator);

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
    rrc_RadioBearerRelease_r8_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the UTRAN DRX cycle length coefficient */
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,utran_DRX_CycleLengthCoeff),
      &msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerRelease_r8_IEs,frequencyInfo), &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerRelease_r8_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/
 
  /* Call these functions ONLY in DCH state */
  if ((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Here, update the transport channel info (only transport channel IDs 
    * and count) and rearrange the info by sorting transport channel list
    * based on TrCH ID. */

    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList,
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,ul_deletedTransChInfoList),
      &msg_ptr->ul_deletedTransChInfoList);


    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
    would be updated later */
    if ( RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }

    if (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,dl_DeletedTransChInfoList))
    {
      dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
    }

    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
    would be updated later */
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
    }

  }

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  /* Don't process RAB to reconfig info */
  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_release_list(&msg_ptr->rb_InformationReleaseList);
  }

  if (SUCCESS == status)
  {
    /* Get the affected RB list if present */
    status = rrcllc_process_rb_info_reconfig_list_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerRelease_r8_IEs,rb_InformationReconfigList),
      &msg_ptr->rb_InformationReconfigList);
  }

  if (SUCCESS == status)
  {
    /* Get the affected RB list if present */
    status = rrcllc_process_rb_info_affected_list_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerRelease_r8_IEs,rb_InformationAffectedList),
      &msg_ptr->rb_InformationAffectedList);
  }

  if (SUCCESS == status) 
  {
    status = rrcllc_validate_rb_mapping_info();
  }

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/

  /* Get the Common Uplink Transport Channel information */
  if (SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerRelease_r8_IEs,ul_CommonTransChInfo),
      &msg_ptr->ul_CommonTransChInfo);
  }

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
  * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
  * (for Cell FACH state), this check for state needs to be re-examined */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
#ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/

    status = rrcllc_store_ul_add_reconf_trch_info_list_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerRelease_r8_IEs,ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList);

    /* Calculate the UL TFCS */
    if((SUCCESS == status) && RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,
      ul_CommonTransChInfo))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
	  	rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL8) == FAILURE)
        {
          status = FAILURE;
        }
      }
      if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(
	  	msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          status = FAILURE;
        }
      }
    }
  }
   /* If state is Cell_DCH */

   /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if (SUCCESS == status)
  {
    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
        ordered_config_ptr->rrc_state_indicator);
    }
  }

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/

  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) && RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,
    dl_CommonTransChInfo))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo, ordered_config_ptr->rrc_state_indicator);
  }

  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r8(
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,dl_AddReconfTransChInfoList),
      &msg_ptr->dl_AddReconfTransChInfoList, &msg_ptr->ul_AddReconfTransChInfoList);
  } /* If state is Cell_DCH */      

  /* The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  /*When UE goes from non-DCH state to DCH state, we make sure that
  UE has the following Physical channel IEs
  1. ul-DPCH-Info
  2. dl-CommonInformation
  3. dl-InformationPerRL-List
  Think of the cases when even though these IEs are present but the necessary info in these IEs is missing.
  So may bee we can add that check also. See the Spec reference for this check. */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,ul_DPCH_Info),
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,dl_CommonInformation),
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if(SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerRelease_r8_IEs,ul_DPCH_Info), &msg_ptr->ul_DPCH_Info, 
      msg_ptr->rrc_StateIndicator);
  }

  if(SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerRelease_r8_IEs,dl_InformationPerRL_List),
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerRelease_r8_IEs,dl_CommonInformation),
      &msg_ptr->dl_CommonInformation, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_info_per_rl_list_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerRelease_r8_IEs,dl_InformationPerRL_List),
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,
    newPrimary_E_RNTI), msg_ptr->newPrimary_E_RNTI,  TRUE, msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,
    newSecondary_E_RNTI), msg_ptr->newSecondary_E_RNTI, FALSE, msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_RadioBearerRelease_r8_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /*Call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,
     new_H_RNTI), &msg_ptr->new_H_RNTI, msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r8(
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,frequencyInfo))
      && (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r8(&msg_ptr->mimoParameters, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,
    mimoParameters))) == FAILURE))
  {
    status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_rbr_r8(rb_release_r8_ota);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
#else /*FEATURE_WCDMA_MIMO*/
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL8: mimoParameters not supported ");
  }
#endif /*FEATURE_WCDMA_MIMO*/
 
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,hs_scch_LessInfo))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL8: hs_scch_LessInfo not supported ");
  }
#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,
    dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if((rb_release_r8_ota != NULL) && (rb_release_r8_ota->m.v7d0NonCriticalExtensionsPresent) 
		&&(rb_release_r8_ota->v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent) 
		&&(rb_release_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.m.v890NonCriticalExtensionsPresent) 
        &&(rb_release_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.radioBearerRelease_v890ext.
           m.dl_SecondaryCellInfoFDD_v890extPresent) && (rb_release_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.
           radioBearerRelease_v890ext.dl_SecondaryCellInfoFDD_v890ext.m.differentTxModeFromServingHS_DSCHCellPresent))
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = TRUE;
      WRRC_MSG0_HIGH("DC-HSDPA:Different Txd Signaled in OTA.");  
    }
    else
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = FALSE;
    }
  }
  
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL8: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(&msg_ptr->rb_InformationReleaseList) == FAILURE)
    {
      return FAILURE;
    }
  }
  if ((SUCCESS == status) && (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /*Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
     (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,dtx_drx_TimingInfo)),
         &msg_ptr->dtx_drx_Info,
     (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,dtx_drx_Info)),
         msg_ptr->rrc_StateIndicator
    ) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,new_H_RNTI));
  }
#ifdef FEATURE_WCDMA_HS_RACH
    if(status == SUCCESS)
    {
      status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_RadioBearerRelease_r8_IEs,newPrimary_E_RNTI));
    }
#endif

#endif


#ifdef FEATURE_WCDMA_DC_HSUPA
      if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
        FALSE)== FAILURE)
      {
        status = FAILURE;
      }  
#endif /* FEATURE_WCDMA_DC_HSUPA */


  /* By now the status has been filled as per the processing.*/
  return (status);
}

/*====================================================================
FUNCTION: rrcllc_trch_reconfig_ie_r8()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Release 8 Transport Channel Reconfiguration Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_trch_reconfig_ie_r8
(
  rrc_TransportChannelReconfiguration_r8 * trch_reconfig_r8_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_DL_AddReconfTransChInfoList_r7 * dl_trch_add_reconfig_ptr = NULL;
  ordered_config_type              *tmp_config_ptr = NULL;
  rrc_TransportChannelReconfiguration_r8_IEs *msg_ptr;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  msg_ptr = &trch_reconfig_r8_ota->transportChannelReconfiguration_r8;

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,
    controlChannelDRXInfo_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,
    sps_Information_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,
    new_DSCH_RNTI))
  {
     return FAILURE;
  }

  /* We're processing a reconfiguration message now, so set the reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  rrcllc_init_before_msg_processing();

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
   /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = (RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,delayRestrictionFlag) !=0);
#endif
 
  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,
    rrc_TransportChannelReconfiguration_r8_IEs,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_TCR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  status = rrcllc_update_urnti_in_oc(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,
    rrc_TransportChannelReconfiguration_r8_IEs,new_U_RNTI),
    &msg_ptr->new_U_RNTI, msg_ptr->rrc_StateIndicator);

  rrcllc_update_crnti_in_oc(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,
    rrc_TransportChannelReconfiguration_r8_IEs,new_C_RNTI),
    msg_ptr->new_C_RNTI, msg_ptr->rrc_StateIndicator);

  if(SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }

  if(SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
      RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,
      utran_DRX_CycleLengthCoeff), &msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if(SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,
      rrc_TransportChannelReconfiguration_r8_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo, msg_ptr->rrc_StateIndicator);
  }

  if(SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,
      rrc_TransportChannelReconfiguration_r8_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }

  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
    * and count) and rearrange the info by sorting transport channel list
    * based on TrCH ID. */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,
      rrc_TransportChannelReconfiguration_r8_IEs,ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList, FALSE, NULL);
  
  
    if( RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }
  
    if(SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(dl_trch_add_reconfig_ptr, NULL);
    }

  }

  /* Get the Common Uplink Transport Channel information */
  if(SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,
      rrc_TransportChannelReconfiguration_r8_IEs,ul_CommonTransChInfo),
      &msg_ptr->ul_CommonTransChInfo);
  }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_ul_add_reconf_trch_info_list_r8(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,
      rrc_TransportChannelReconfiguration_r8_IEs,ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList);
  
    /* Calculate the UL TFCS */
    if((SUCCESS == status) && (RRCRB_R8_MSG_IE_PRESENT (msg_ptr,
      rrc_TransportChannelReconfiguration_r8_IEs,ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
	  	rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL8) == FAILURE)
        {
          status = FAILURE;
        }
        if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(
			msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
        {
          if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
          {
            status = FAILURE;
          }
        }
      }
    } 
  } /* If state is Cell_DCH */
  
  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      status = FAILURE;
    }
  }

  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/

  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) && (RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,
    dl_CommonTransChInfo)))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo, &msg_ptr->ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator);
  }

  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r8(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,
      rrc_TransportChannelReconfiguration_r8_IEs,dl_AddReconfTransChInfoList),
      &msg_ptr->dl_AddReconfTransChInfoList, &msg_ptr->ul_AddReconfTransChInfoList);
  } /* If state is Cell_DCH */   

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch( 
      RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,ul_DPCH_Info),
      RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,dl_CommonInformation), 
      RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,
      rrc_TransportChannelReconfiguration_r8_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8(
      RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r8(
      RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r8(
      RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,
    newPrimary_E_RNTI), msg_ptr->newPrimary_E_RNTI,  TRUE, msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,
    newSecondary_E_RNTI), msg_ptr->newSecondary_E_RNTI, FALSE, msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information*/
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r8(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,
      rrc_TransportChannelReconfiguration_r8_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status)&&rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,
      new_H_RNTI), &msg_ptr->new_H_RNTI, msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r8(
      RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,dl_HSPDSCH_Information),  
      &msg_ptr->dl_HSPDSCH_Information,
      (( RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,frequencyInfo) ) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r8(&msg_ptr->mimoParameters, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,
    mimoParameters))) == FAILURE))
  {
    status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_tcrc_r8(trch_reconfig_r8_ota);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
#else /*FEATURE_WCDMA_MIMO*/
  if(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,mimoParameters)) 
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL8: mimoParameters not supported ");
  }
#endif /*FEATURE_WCDMA_MIMO*/

  if(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,hs_scch_LessInfo)) 
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL8: hs_scch_LessInfo not supported ");
  }

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,
    dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if((trch_reconfig_r8_ota != NULL) && (trch_reconfig_r8_ota->m.v7d0NonCriticalExtensionsPresent) 
	   &&(trch_reconfig_r8_ota->v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent)
	   &&(trch_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.m.v890NonCriticalExtensionsPresent)
       &&(trch_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.transportChannelReconfiguration_v890ext.m.dl_SecondaryCellInfoFDD_v890extPresent)
       &&(trch_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.transportChannelReconfiguration_v890ext.
      dl_SecondaryCellInfoFDD_v890ext.m.differentTxModeFromServingHS_DSCHCellPresent))
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = TRUE;
      WRRC_MSG0_HIGH("DC-HSDPA:Different Txd Signaled in OTA.");  
    }
    else
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = FALSE;
    }
  }
  
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL8: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/
  
  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }
  
  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,delayRestrictionFlag))
    {
      if(( RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,dl_AddReconfTransChInfoList))
        ||(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,ul_AddReconfTransChInfoList))) 
      {
        WRRC_MSG0_ERROR("REL8: Trch IE touched bitmask , so Delay restriction cannot be applied");
      }
      else
      {
        rrcllc_update_delay_restriction(RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,activationTime),
          RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,delayRestrictionFlag),
          msg_ptr->activationTime,msg_ptr->rrc_StateIndicator);
      }
    }
  }
  /* By now the status has been filled as per the processing.*/


  if (SUCCESS == status)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
    (RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,dtx_drx_TimingInfo)),
         &msg_ptr->dtx_drx_Info,
    (RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,dtx_drx_Info)),
         msg_ptr->rrc_StateIndicator
    ) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRCRB_R8_MSG_IE_PRESENT (msg_ptr,rrc_TransportChannelReconfiguration_r8_IEs,newPrimary_E_RNTI));
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/


#ifdef FEATURE_WCDMA_DC_HSUPA
      if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
        FALSE)== FAILURE)
      {
        status = FAILURE;
      }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  return (status);
}

/*====================================================================
FUNCTION: rrcllc_phychan_reconfig_ie_r8()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Physical Channel Reconfiguration Message for Rel 8

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_phychan_reconfig_ie_r8
(
  rrc_PhysicalChannelReconfiguration_r8 * phys_chan_reconfig_r8_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_PhysicalChannelReconfiguration_r8_IEs *msg_ptr;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  msg_ptr = &phys_chan_reconfig_r8_ota->physicalChannelReconfiguration_r8;

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,
    new_DSCH_RNTI))
  {
     return FAILURE;
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,
    controlChannelDRXInfo_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,
    sps_Information_TDD128))
  {
    return FAILURE;
  }

  /*We're processing a reconfiguration message now, so set the reconfig_in_progress flag accordingly.*/
  ordered_config.reconfig_in_progress = TRUE;

  rrcllc_init_before_msg_processing();

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,delayRestrictionFlag) !=0);
#endif
  
  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,
  activationTime)), msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_PCR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  status = rrcllc_update_urnti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,
    new_U_RNTI)), &msg_ptr->new_U_RNTI, msg_ptr->rrc_StateIndicator);

   rrcllc_update_crnti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,
     new_C_RNTI)), msg_ptr->new_C_RNTI, msg_ptr->rrc_StateIndicator);

   if (SUCCESS == status)
   {
     status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
   }

  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,utran_DRX_CycleLengthCoeff)),
      &msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_PhysicalChannelReconfiguration_r8_IEs,frequencyInfo)),
      &msg_ptr->frequencyInfo, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_PhysicalChannelReconfiguration_r8_IEs,maxAllowedUL_TX_Power)), msg_ptr->maxAllowedUL_TX_Power);
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,ul_DPCH_Info)),
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,dl_CommonInformation)),
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,dl_InformationPerRL_List)),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_PhysicalChannelReconfiguration_r8_IEs,ul_DPCH_Info)),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,
      dl_InformationPerRL_List)), &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_PhysicalChannelReconfiguration_r8_IEs,dl_CommonInformation)),
      &msg_ptr->dl_CommonInformation, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_PhysicalChannelReconfiguration_r8_IEs,dl_InformationPerRL_List)),
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,
    newPrimary_E_RNTI)), msg_ptr->newPrimary_E_RNTI, TRUE, msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,
    newSecondary_E_RNTI)), msg_ptr->newSecondary_E_RNTI, FALSE, msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r8((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_PhysicalChannelReconfiguration_r8_IEs,ul_EDCH_Information)),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }


  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_PhysicalChannelReconfiguration_r8_IEs,new_H_RNTI)),
      &msg_ptr->new_H_RNTI, msg_ptr->rrc_StateIndicator);
  }

  if((SUCCESS == status) && (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,harqInfo)))
  {
    status = set_harq_information_r7(&msg_ptr->harqInfo);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r8(
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,dl_HSPDSCH_Information)),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }


  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,hs_scch_LessInfo))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL8: hs_scch_LessInfo not supported ");
  }
#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r8(&msg_ptr->mimoParameters,
    msg_ptr->rrc_StateIndicator, (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,
    mimoParameters))) == FAILURE))
  {
     status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_pcrc_r8(phys_chan_reconfig_r8_ota);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
#else /*FEATURE_WCDMA_MIMO*/
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL8: mimoParameters not supported ");
  }
#endif /*FEATURE_WCDMA_MIMO*/

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,
    dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if((phys_chan_reconfig_r8_ota != NULL) && (phys_chan_reconfig_r8_ota->m.v7d0NonCriticalExtensionsPresent) 
	   &&(phys_chan_reconfig_r8_ota->v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent)
	   &&(phys_chan_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.m.v890NonCriticalExtensionsPresent)
	   &&(phys_chan_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.physicalChannelReconfiguration_v890ext.m.dl_SecondaryCellInfoFDD_v890extPresent)
	   &&(phys_chan_reconfig_r8_ota->v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.physicalChannelReconfiguration_v890ext.dl_SecondaryCellInfoFDD_v890ext.
	      m.differentTxModeFromServingHS_DSCHCellPresent))
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = TRUE;
      WRRC_MSG0_HIGH("DC-HSDPA:Different Txd Signaled in OTA.");  
    }
    else
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = FALSE;
    }
  }

 
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL8: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  if(SUCCESS == status)
  {
    rrcllc_update_delay_restriction(
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,activationTime)),
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,delayRestrictionFlag)),
      msg_ptr->activationTime,msg_ptr->rrc_StateIndicator);
  }

  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
       (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,dtx_drx_TimingInfo)),
       &msg_ptr->dtx_drx_Info,
       (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,dtx_drx_Info)),
       msg_ptr->rrc_StateIndicator
       ) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_PhysicalChannelReconfiguration_r8_IEs,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_DC_HSUPA
      if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
        FALSE)== FAILURE)
      {
        status = FAILURE;
      }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* By now the status has been filled as per the processing.*/
  return (status);
}

/*====================================================================
FUNCTION: rrcllc_cell_update_confirm_ie_r8()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Cell Update Confirm Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_cell_update_confirm_ie_r8
(
  uint32 dl_sdu_num,
  void * cell_update_r8_msg_ptr

)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_DL_DeletedTransChInfoList_r7   * dl_trch_delete_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList_r7 * dl_trch_add_reconfig_ptr = NULL;
  ordered_config_type              *tmp_config_ptr = NULL;
  rrc_CellUpdateConfirm_r8_IEs *msg_ptr;
  rrcrb_directed_cell_info_type          directed_cell_info;
  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
 
    if(rrc_DL_CCCH_Message_PDU == dl_sdu_num)
  {
    rrc_DL_CCCH_Message *ccch_ptr= NULL;
    ccch_ptr=  (rrc_DL_CCCH_Message *)cell_update_r8_msg_ptr;
    msg_ptr =&ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
				criticalExtensions.u.criticalExtensions.u.
				criticalExtensions.u.criticalExtensions.u.criticalExtensions.
				u.r8.cellUpdateConfirm_r8;
  }
  else
  {
    rrc_DL_DCCH_Message *dcch_ptr= NULL;

    dcch_ptr = (rrc_DL_DCCH_Message *)cell_update_r8_msg_ptr;
 
    msg_ptr =&dcch_ptr->message.u.cellUpdateConfirm.u.
					  later_than_r3.criticalExtensions.u.criticalExtensions.
					  u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
					  u.r8.cellUpdateConfirm_r8;
     
  }
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
    new_DSCH_RNTI))
  {
    return FAILURE;
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
    controlChannelDRXInfo_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
    sps_Information_TDD128))
  {
    return FAILURE;
  }

  /* We're processing a reconfiguration message now, so set the
  reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  rrcllc_init_before_msg_processing();
                                            
   /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
    activationTime), msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_CU);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
   if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
   {
     return FAILURE;
   }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  status = rrcllc_update_urnti_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
    new_U_RNTI), &msg_ptr->new_U_RNTI, msg_ptr->rrc_StateIndicator);

  rrcllc_update_crnti_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
    new_C_RNTI), msg_ptr->new_C_RNTI, msg_ptr->rrc_StateIndicator);

  if(SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }
  
  if(SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
      (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,utran_DRX_CycleLengthCoeff)),
      &msg_ptr->utran_DRX_CycleLengthCoeff);
  }
  
  if(SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_CellUpdateConfirm_r8_IEs,frequencyInfo),
     &msg_ptr->frequencyInfo, msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_CellUpdateConfirm_r8_IEs,maxAllowedUL_TX_Power), msg_ptr->maxAllowedUL_TX_Power);
  }

  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,rab_InformationSetup))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL8: rab_InformationSetup not supported ");
  }
    
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList,
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_deletedTransChInfoList),
      &msg_ptr->ul_deletedTransChInfoList);


    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
    if (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }

    if (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_DeletedTransChInfoList))
    {
      dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
    }

    /*Create a new DFLOW index and update the MAC and RRC structures. 
      Queue Info would be updated later */
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(
        dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
    }


  }

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if(SUCCESS == status && (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
    rb_InformationReleaseList)))
  {
    status = rrcllc_process_rb_info_release_list(&msg_ptr->rb_InformationReleaseList);
  }

  /* Get the RB reconfiguration list */
  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_reconfig_list_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_CellUpdateConfirm_r8_IEs,rb_InformationReconfigList),
      &msg_ptr->rb_InformationReconfigList);
  }

  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_affected_list_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_CellUpdateConfirm_r8_IEs,rb_InformationAffectedList),
      &msg_ptr->rb_InformationAffectedList);
  }

  if (SUCCESS == status) 
  {
    status = rrcllc_validate_rb_mapping_info();
  }

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/
     
  /* Get the Common Uplink Transport Channel information */
  if (SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6(
       RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_CommonTransChInfo),
      &msg_ptr->ul_CommonTransChInfo);
  }

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_ul_add_reconf_trch_info_list_r8(
     RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_AddReconfTransChInfoList),
     &msg_ptr->ul_AddReconfTransChInfoList);
    
    /* Calculate the UL TFCS */
    if((SUCCESS == status) &&
       ( RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_CommonTransChInfo) ))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
	  	rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL8) == FAILURE)
        { 
          status = FAILURE;
        }
      }
      if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(
	  	msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          status = FAILURE;
        }
      }
    }
  }

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if (SUCCESS == status)
  {
    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
        ordered_config_ptr->rrc_state_indicator);
    }
  }

  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) &&
     (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_CommonInformation)))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo, ordered_config_ptr->rrc_state_indicator);
  }

  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r8(
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_AddReconfTransChInfoList), 
      &msg_ptr->dl_AddReconfTransChInfoList, &msg_ptr->ul_AddReconfTransChInfoList);
  }

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,pdcp_ROHC_TargetMode) )
  {
    WRRC_MSG0_ERROR("REL8: pdcp_ROHC_TargetMode IE not supported yet!");
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,ul_DPCH_Info),
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_CommonInformation),
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_InformationPerRL_List), 
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_CellUpdateConfirm_r8_IEs,ul_DPCH_Info), 
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
      dl_InformationPerRL_List), &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_CellUpdateConfirm_r8_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_CellUpdateConfirm_r8_IEs,dl_InformationPerRL_List),  
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
    newPrimary_E_RNTI), msg_ptr->newPrimary_E_RNTI, TRUE, msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
    newSecondary_E_RNTI), msg_ptr->newSecondary_E_RNTI, FALSE, msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r8(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,
      rrc_CellUpdateConfirm_r8_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
      new_H_RNTI), &msg_ptr->new_H_RNTI, msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r8(
      RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      (( RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }


#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r8(&msg_ptr->mimoParameters,
    msg_ptr->rrc_StateIndicator, RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
    mimoParameters)) == FAILURE))
  {
    status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_cu_r8(dl_sdu_num,cell_update_r8_msg_ptr);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/
  
#else /*FEATURE_WCDMA_MIMO*/
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL8: mimoParameters not supported ");
  }
#endif /*FEATURE_WCDMA_MIMO*/

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,
    dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    rrc_CellUpdateConfirm_v890ext_IEs * cellUpdateConfirm_v890ext_ptr = NULL;  

    if(rrc_DL_CCCH_Message_PDU == dl_sdu_num)
    {
      rrc_DL_CCCH_Message *ccch_ptr= NULL;
      ccch_ptr=  (rrc_DL_CCCH_Message *)cell_update_r8_msg_ptr;
  
      msg_ptr =&ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.
                criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.cellUpdateConfirm_r8;
  
      if((ccch_ptr != NULL) && (ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
        	u.criticalExtensions.u.r8.m.v7d0NonCriticalExtensionsPresent)
	  	  && (ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
	  	     u.r8.v7d0NonCriticalExtensions.m.v890NonCriticalExtensionsPresent))
      {
        cellUpdateConfirm_v890ext_ptr = &ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.
          criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.v7d0NonCriticalExtensions.v890NonCriticalExtensions.cellUpdateConfirm_v890ext;
      }
    }
    else
    {
      rrc_DL_DCCH_Message *dcch_ptr= NULL;
      dcch_ptr = (rrc_DL_DCCH_Message *)cell_update_r8_msg_ptr;
  
      if((dcch_ptr != NULL) && (dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.
        criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.m.v7d0NonCriticalExtensionsPresent)
        &&(dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
           u.r8.v7d0NonCriticalExtensions.m.v7f0NonCriticalExtensionsPresent)
        &&(dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
           u.r8.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.m.v890NonCriticalExtensionsPresent))
      {
        cellUpdateConfirm_v890ext_ptr = &dcch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.
          criticalExtensions.u.criticalExtensions.u.r8.v7d0NonCriticalExtensions.v7f0NonCriticalExtensions.v890NonCriticalExtensions.cellUpdateConfirm_v890ext;
      }
    }
  
    if((cellUpdateConfirm_v890ext_ptr != NULL) && (cellUpdateConfirm_v890ext_ptr->m.dl_SecondaryCellInfoFDD_v890extPresent)
		&&(cellUpdateConfirm_v890ext_ptr->dl_SecondaryCellInfoFDD_v890ext.m.differentTxModeFromServingHS_DSCHCellPresent))
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = TRUE;
      WRRC_MSG0_HIGH("DC-HSDPA:Different Txd Signaled in OTA.");  
    }
    else
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = FALSE;
  }
  }

  
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL8: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(&msg_ptr->rb_InformationReleaseList) == FAILURE)
    {
      status = FAILURE;
    }
  }
   
  if ((SUCCESS == status) && (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
   (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,dtx_drx_TimingInfo)),
       &msg_ptr->dtx_drx_Info,
   (RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,dtx_drx_Info)),
       msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRCRB_R8_MSG_IE_PRESENT(msg_ptr,rrc_CellUpdateConfirm_r8_IEs,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_DC_HSUPA
      if(rrcllcpcie_process_dc_hsupa_params(NULL,msg_ptr->rrc_StateIndicator,
        FALSE)== FAILURE)
      {
        status = FAILURE;
      }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* By now the status has been filled as per the processing.*/
  return (status);
}


/*====================================================================
FUNCTION: rrcllc_active_set_update_ie_r8()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Active Set Update Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_active_set_update_ie_r8
(
  rrc_ActiveSetUpdate_r8 * active_set_update_r8_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_ActiveSetUpdate_r8_IEs *msg_ptr;
  
  if(active_set_update_r8_ota == NULL)
  {
    WRRC_MSG0_ERROR("active_set_update_r8_ota is NULL");
    return FAILURE;
  }
  rrcllc_init_before_msg_processing();
  msg_ptr =  &active_set_update_r8_ota->activeSetUpdate_r8;

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
    rrc_ActiveSetUpdate_r8_IEs,activationTime),
    msg_ptr->activationTime, rrc_RRC_StateIndicator_cell_DCH, RRC_PROCEDURE_ASU);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
 /* Get the U-RNTI */
  status = rrcllc_update_urnti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,
    newU_RNTI),&msg_ptr->newU_RNTI, rrc_RRC_StateIndicator_cell_DCH);

  if(SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
      rrc_ActiveSetUpdate_r8_IEs,maxAllowedUL_TX_Power), msg_ptr->maxAllowedUL_TX_Power);
  } 

  if (SUCCESS == status)
  {
    /* Get the Radio Link Removal information */
    status = rrcllcpcie_process_rl_removal_information_list(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,rl_RemovalInformationList),
      &msg_ptr->rl_RemovalInformationList,
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,rl_AdditionInformationList));
  }
    

  /* Get the TX Diversity Mode */
  if((SUCCESS == status) && (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,tx_DiversityMode)))
  {
    status = get_tx_diversity_mode_info(msg_ptr->tx_DiversityMode,
      &ordered_config_ptr->l1_dl_chan_parms.dl_common);
  } 

  if (SUCCESS == status)
  {
    /* Get the Radio Link Addition information */
    status = rrcllcpcie_process_rl_addition_info_list_r8(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,rl_AdditionInformationList),
      &msg_ptr->rl_AdditionInformationList);
  }

  if(SUCCESS == status)
  {
    rrcllcpcie_process_edpch_interpolation_info(  msg_ptr->e_DPDCH_PowerInterpolation,
        (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,e_DPDCH_PowerInterpolation)));
  }

#ifdef FEATURE_WCDMA_REL7_EDPCCH_POWER_BOOST
  if(SUCCESS == status)
  {
    status = rrcllcpcie_process_edpcch_boost_info(&msg_ptr->e_TFC_Boost_Info, RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,e_TFC_Boost_Info));
  }
#else
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,e_TFC_Boost_Info))
  {
    WRRC_MSG0_ERROR("REL8: IE e_TFC_Boost_Info not supported yet!");
  }
#endif
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_e_dch_reconfig_info_samecell(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,e_dch_ReconfInfoSameCell),
      &msg_ptr->e_dch_ReconfInfoSameCell);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_e_dch_reconfig_info_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,e_dch_ReconfigurationInfo),
      &msg_ptr->e_dch_ReconfigurationInfo);
  }
#ifdef FEATURE_WCDMA_16_QAM
  if (SUCCESS == status)
  {
     status = rrcllcpcie_process_ul_16qam_config(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r8_IEs,ul_16QAM_Config),&msg_ptr->ul_16QAM_Config);
  }
#endif

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI, TRUE, rrc_RRC_StateIndicator_cell_DCH);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI, FALSE, rrc_RRC_StateIndicator_cell_DCH);

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(
    rrc_RRC_StateIndicator_cell_DCH) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  /* Validation for and processing for ASU repointing */

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r8_IEs,newH_RNTI), 
      &msg_ptr->newH_RNTI,
      rrc_RRC_StateIndicator_cell_DCH);
  }

  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r8_IEs,serving_HSDSCH_CellInformation))
  {
    if(SUCCESS == status)
    {
      status = rrcllc_process_serving_hsdsch_cell_info_r8(msg_ptr); 
    }
  }

#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r8(&msg_ptr->mimoParameters,
    rrc_RRC_StateIndicator_cell_DCH, (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r8_IEs,mimoParameters))) 
    == FAILURE))
  {
    status = FAILURE;
  }

#if defined(FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT) || defined(FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION)
  if(SUCCESS == status)
  {
    rrcllcpcie_process_mimo_params_ext_asu_r8(active_set_update_r8_ota);
  }
#endif /*FEATURE_WCDMA_SCPICH_MIMO_MODE_PRESENT || FEATURE_WCDMA_MIMO_CODEBOOK_RESTRICTION*/

  
#else /*FEATURE_WCDMA_MIMO*/
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r8_IEs,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL8: mimoParameters not supported ");
  }
#endif /*FEATURE_WCDMA_MIMO*/

  if (msg_ptr->m.servingCellChangeParametersPresent)
  {
    WRRC_MSG0_ERROR("REL8: servingCellChangeParameters not supported yet!");
    status = FAILURE;
  }


  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r8_IEs,dpc_Mode))
  {
    WRRC_MSG0_ERROR("REL8: IE dpc_Mode not supported yet!");
    status = FAILURE;
  } 

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params(&msg_ptr->dl_SecondaryCellInfoFDD, 
    rrc_RRC_StateIndicator_cell_DCH,(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
   rrc_ActiveSetUpdate_r8_IEs,dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if((active_set_update_r8_ota != NULL) &&(active_set_update_r8_ota->m.v890NonCriticalExtensionsPresent) 
       &&(active_set_update_r8_ota->v890NonCriticalExtensions.activeSetUpdate_v890ext.m.dl_SecondaryCellInfoFDD_v890extPresent)
       &&(active_set_update_r8_ota->v890NonCriticalExtensions.activeSetUpdate_v890ext.dl_SecondaryCellInfoFDD_v890ext.m.differentTxModeFromServingHS_DSCHCellPresent))
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = TRUE;
      WRRC_MSG0_HIGH("DC-HSDPA:Different Txd Signaled in OTA.");  
    }
    else
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = FALSE;
    }
  }
  
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r8_IEs,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL8: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  /*By this time, hsdpa_action should have been set.*/
  /*Following check is done to verify whether IE hs-DSCH-TBSizeTable is present or not.*/
  if((SUCCESS == status) && ((active_set_update_r8_ota != NULL)&& RRC_MSG_COMMON_BITMASK_IE(active_set_update_r8_ota->activeSetUpdate_r8,
   rrc_ActiveSetUpdate_r8_IEs,serving_HSDSCH_CellInformation)) &&
    (RRC_MSG_COMMON_BITMASK_IE(active_set_update_r8_ota->activeSetUpdate_r8.serving_HSDSCH_CellInformation,
    rrc_Serving_HSDSCH_CellInformation_r8,dl_hspdsch_Information)) &&
    (RRC_CHECK_COMMON_MSG_TYPE(active_set_update_r8_ota->activeSetUpdate_r8.serving_HSDSCH_CellInformation.dl_hspdsch_Information.modeSpecificInfo,
     rrc_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd)) &&
    (active_set_update_r8_ota->activeSetUpdate_r8.serving_HSDSCH_CellInformation.dl_hspdsch_Information.modeSpecificInfo.u.
    fdd->m.hs_DSCH_TBSizeTablePresent))
  {
    rrcllcpcie_update_hs_tfri_table_type(TRUE);
  }
  else
  {
       /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
    if(((RRC_MSG_COMMON_BITMASK_IE(active_set_update_r8_ota->activeSetUpdate_r8,
     rrc_ActiveSetUpdate_r8_IEs,serving_HSDSCH_CellInformation)) &&
     (RRC_MSG_COMMON_BITMASK_IE(active_set_update_r8_ota->activeSetUpdate_r8.serving_HSDSCH_CellInformation,
     rrc_Serving_HSDSCH_CellInformation_r8,dl_hspdsch_Information)))
       || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
       || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
      )
    {
      rrcllcpcie_update_hs_tfri_table_type(FALSE);
    }
  }

  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
       msg_ptr->m.dtx_drx_TimingInfoPresent,
       &msg_ptr->dtx_drx_Info,
       msg_ptr->m.dtx_drx_InfoPresent,
       rrc_RRC_StateIndicator_cell_DCH) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_DC_HSUPA
      if(rrcllcpcie_process_dc_hsupa_params(NULL,rrc_RRC_StateIndicator_cell_DCH,
        FALSE)== FAILURE)
      {
        status = FAILURE;
      }  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* By now the status has been filled as per the processing.*/
  return (status);
}

/*====================================================================
FUNCTION: rrcllc_rrc_conn_setup_ie_r8()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in R8 RRC Connection Setup Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rrc_conn_setup_ie_r8
(
  rrc_RRCConnectionSetup_r8 *rrc_conn_setup_r8_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_DL_AddReconfTransChInfoList_r7 * dl_trch_add_reconfig_ptr = NULL;
  ordered_config_type              *tmp_config_ptr = NULL;
  rrc_RRCConnectionSetup_r8_IEs *msg_ptr;
  rrcrb_directed_cell_info_type          directed_cell_info;
  msg_ptr = &rrc_conn_setup_r8_ota->rrcConnectionSetup_r8;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  /* We do not handle Cell_PCH and URA_PCH states at present */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH) || (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    WRRC_MSG0_ERROR("CELL_PCH or URA-PCH state transition invalid!");
    return FAILURE;
  }

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,sps_Information_TDD128))
  {
    return FAILURE;
  }

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,multi_frequencyInfo))
  {
    return FAILURE;
  }

  /*We're processing a reconfiguration message now, so set the reconfig_in_progress flag accordingly.*/
  ordered_config.reconfig_in_progress = TRUE;

  /*RRC_GKG: Notice that RRC Conn Setup does have ACT Time.*/
  /* Assume that the default is now, i.e. the current SFN */
  MSG_MED("Activation Time is Now!",0,0,0);

  ordered_config_ptr->activation_time = RRCLLC_ACTIVATION_TIME_NOW;
  ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_NONE;

  rrcllc_init_before_msg_processing();

#ifdef FEATURE_VOC_AMR_WB
  ordered_config_ptr->ul_tfcs.orderd_codec_mode = MVS_MODE_NONE;
#endif/*FEATURE_VOC_AMR_WB*/

  if (SUCCESS == status)
  {
    /* new-U-RNTI is mandatory in RRC Connection Setup message */
    status = rrcllc_update_urnti_in_oc(TRUE, &msg_ptr->new_U_RNTI, msg_ptr->rrc_StateIndicator);  
  }

  /* Get the C-RNTI */
  rrcllc_update_crnti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,new_c_RNTI),
    msg_ptr->new_c_RNTI, msg_ptr->rrc_StateIndicator);

  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the UTRAN DRX cycle length coefficient */
    /*Since Coef1 is always present in RRC connection setup*/
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(TRUE, &msg_ptr->utran_DRX_CycleLengthCoeff);
  }  

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/
     
  if ((SUCCESS == status) && (RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
  	rrc_RRCConnectionSetup_r8_IEs_specificationMode_complete)))
  {
    if(RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r8_IEs))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
    } 
    /* Call these functions ONLY in DCH state */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Here, update the transport channel info (only transport channel IDs 
      * and count) and rearrange the info by sorting transport channel list
      * based on TrCH ID.  */

      /*RRC_GKG: Find out the rationale behind madatory UL AddReconfig. ASN.1 wise it's not OPTIONAL*/
      /* ul_AddReconfTransChInfoList is mandatory present */
      status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(TRUE, 
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList, FALSE, NULL);


      if (SUCCESS == status)
      {
        status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(
                 dl_trch_add_reconfig_ptr, NULL);
      }


    }  

    /* The OC ptr is now restor to point to Order config ptr*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);
 
    /* Get the SRB setup list if present */
    if (SUCCESS == status)
    {
      /* SRB info has to be present in rrcConnectionSetup message */
      status =  rrcllc_process_srb_info_setup_list_r8(TRUE, 
        (rrc_SRB_InformationSetupList_r8 *) &msg_ptr->specificationMode.u.complete.srb_InformationSetupList);
    }

    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }
    
    /* use TOC ptr if not received in DCH state */
    tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
    /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
     OC ptr is now pointing to TOC ptr.*/

    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(
       RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r8_IEs),
       &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined */
    if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      status = rrcllc_store_ul_add_reconf_trch_info_list_r8(
          RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r8_IEs),
          &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);

      /* Calculate the UL TFCS */
      if((SUCCESS == status) &&
         (RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r8_IEs)))
      {
        compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
      }

          }

    /*The OC ptr is now restor to point to Order config ptr */
    rrcllc_restore_oc_ptr (tmp_config_ptr);

    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
       !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
        ordered_config_ptr->rrc_state_indicator) == FAILURE)
      {
        status = FAILURE;
      }
    }

    /* use TOC ptr if not received in DCH state */
    tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
    /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
     OC ptr is now pointing to TOC ptr*/
     
    /* Get the Common Downlink Transport Channel information */
    if((SUCCESS == status) &&
      (RRCRB_R6_DL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r8_IEs)))
    {
      status = get_dl_info_common_for_all_trch_r5(
        &msg_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
        &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
        ordered_config_ptr->rrc_state_indicator);
    }

    if (SUCCESS == status)
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r8(
        RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r8_IEs),
        &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    }
  }
  else /*rrc_RRCConnectionSetup_r8_IEs,specificationMode_complete */
  {
    if(rrcrce_get_rbs_ptr() != NULL)
    {
      status = rrcllc_process_preconfiguration_with_srb5_rrc_conn_setup(msg_ptr->rrc_StateIndicator);
      WRRC_MSG1_HIGH("REL8: Finished processing DC with SRB5. status = %d",status);
    }
    else
    {
      status = rrcllc_process_preconfiguration_rrc_conn_setup_ie_r6((void *) msg_ptr, MSG_REL8);
      WRRC_MSG1_HIGH("REL8: Finished processing DC. status = %d",status);
    }
  }

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);
 
  if (SUCCESS == status)
  {
    /* Get the frequency info */
    status = rrcllc_update_frequency_info_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
     rrc_RRCConnectionSetup_r8_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
     rrc_RRCConnectionSetup_r8_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get Uplink DPCH info if included, Ignore CPCH info */
    status = rrcllcpcie_process_ul_dpch_info_r7(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
     rrc_RRCConnectionSetup_r8_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
     rrc_RRCConnectionSetup_r8_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the DL information for all Radio Links */
    status = rrcllcpcie_process_dl_common_info_r8(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
     rrc_RRCConnectionSetup_r8_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_info_per_rl_list_r8(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
     rrc_RRCConnectionSetup_r8_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
   rrc_RRCConnectionSetup_r8_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI, TRUE, msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
   rrc_RRCConnectionSetup_r8_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI, FALSE, msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r8(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI, msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r8(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator,(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
   rrc_RRCConnectionSetup_r8_IEs,dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if((rrc_conn_setup_r8_ota != NULL) && (rrc_conn_setup_r8_ota->m.v7d0NonCriticalExtensionsPresent)
	   &&(rrc_conn_setup_r8_ota->v7d0NonCriticalExtensions.m.v890NonCriticalExtensionsPresent)
	   &&(rrc_conn_setup_r8_ota->v7d0NonCriticalExtensions.v890NonCriticalExtensions.rrcConnectionSetup_v890ext.m.dl_SecondaryCellInfoFDD_v890extPresent)
	   &&(rrc_conn_setup_r8_ota->v7d0NonCriticalExtensions.v890NonCriticalExtensions.rrcConnectionSetup_v890ext.dl_SecondaryCellInfoFDD_v890ext.m.differentTxModeFromServingHS_DSCHCellPresent))
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = TRUE;
      WRRC_MSG0_HIGH("DC-HSDPA:Different Txd Signaled in OTA.");  
    }
    else
    {
      ordered_config_ptr->l1_hsdpa_info.sec_hs_carrier_info[0].diff_txd_mode = FALSE;
    }
  }
  
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL8: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/


  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
       msg_ptr->m.dtx_drx_TimingInfoPresent,
       &msg_ptr->dtx_drx_Info,
       msg_ptr->m.dtx_drx_InfoPresent,
       msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      TRUE,
                                      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(status == SUCCESS)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        TRUE,
                                        RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r8_IEs,newPrimary_E_RNTI));
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

  /* By now the status has been filled as per the processing.*/
  return (status);
}

/*====================================================================
FUNCTION: rrcllc_handover_to_utran_ie_r8()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Handover to UTRAN Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_handover_to_utran_ie_r8
(
  rrc_HandoverToUTRANCommand_r8 *msg_ptr
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_HandoverToUTRANCommand_r8_IEs * ho_utran_r8_ptr;

  ho_utran_r8_ptr = &msg_ptr->handoverToUTRANCommand_r8;

  ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;

  rrc_translate_urnti_short(&ho_utran_r8_ptr->new_U_RNTI, &ordered_config_ptr->mac_ul_parms.rnti_info.urnti);
  ordered_config_ptr->mac_dl_parms.rnti_info.urnti = ordered_config_ptr->mac_ul_parms.rnti_info.urnti;
  ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power.  MP for ho to utran */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(TRUE, ho_utran_r8_ptr->maxAllowedUL_TX_Power);
  }

  if ((SUCCESS == status) && RRC_CHECK_COMMON_MSG_TYPE(ho_utran_r8_ptr->specificationMode
      ,rrc_HandoverToUTRANCommand_r8_IEs_specificationMode_complete))
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID. */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(
      TRUE, &ho_utran_r8_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList, FALSE, NULL);
    
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r7(
        &ho_utran_r8_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList, NULL);
    }

    /* Get the SRB setup list if present */
    if (SUCCESS == status)
    {
      status =  rrcllc_process_srb_info_setup_list_r8(TRUE, 
          &ho_utran_r8_ptr->specificationMode.u.complete.srb_InformationSetupList);
    }

    /* Get the RAB setup list if present */
    if (SUCCESS == status)
    {
      status = rrcllc_process_rab_info_setup_list_r8(ho_utran_r8_ptr->specificationMode.
	  	u.complete.m.rab_InformationSetupListPresent,
        &ho_utran_r8_ptr->specificationMode.u.complete.rab_InformationSetupList);
    }

    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }
    
    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(TRUE, 
          &ho_utran_r8_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }

    if(SUCCESS == status)
    {
      status = rrcllc_store_ul_add_reconf_trch_info_list_r8(TRUE,
          &ho_utran_r8_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    }

    /* Calculate the UL TFCS */
    compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

    if(RRC_MSG_COMMON_BITMASK_IE(ho_utran_r8_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
      rrc_UL_CommonTransChInfo_r4,tfc_Subset))
    { 
      status = rrcllc_update_oc_with_tfc_subset(
        &ho_utran_r8_ptr->specificationMode.u.complete.ul_CommonTransChInfo, MSG_REL8);
    } 

    if((SUCCESS == status ) &&
      (RRC_MSG_COMMON_BITMASK_IE_TYPE2(ho_utran_r8_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
        tfc_SubsetList)))
    {
      if(rrcllc_update_oc_with_tfc_subset_list(&ho_utran_r8_ptr->specificationMode.u.complete.
          ul_CommonTransChInfo) == FAILURE)
      {
        status= FAILURE;
      }
    }

    /* Get the Common Downlink Transport Channel information */
    if(SUCCESS == status)
    {
      status = get_dl_info_common_for_all_trch_r5(&ho_utran_r8_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
        &ho_utran_r8_ptr->specificationMode.u.complete.ul_CommonTransChInfo, ordered_config_ptr->rrc_state_indicator);
    }

    if(SUCCESS == status)
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r8(
        TRUE, &ho_utran_r8_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &ho_utran_r8_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    } 

    if(SUCCESS == status)
    {
      status = rrcllcpcie_process_ul_dpch_info_r7(TRUE,
        &ho_utran_r8_ptr->specificationMode.u.complete.ul_DPCH_Info, rrc_RRC_StateIndicator_cell_DCH);
    }

    if (SUCCESS == status) 
    {
      status = rrcllcpcie_is_hho_r7(TRUE, 
        &ho_utran_r8_ptr->specificationMode.u.complete.dl_InformationPerRL_List,
        rrc_RRC_StateIndicator_cell_DCH);
    }

    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_dl_common_info_r8(TRUE, 
        &ho_utran_r8_ptr->specificationMode.u.complete.dl_CommonInformation,
        rrc_RRC_StateIndicator_cell_DCH);
    }
    
    if (SUCCESS == status)
    {
      /* update R99, HS and EUL related variables */
      status = rrcllcpcie_process_dl_info_per_rl_list_r7(TRUE, 
        &ho_utran_r8_ptr->specificationMode.u.complete.dl_InformationPerRL_List,
        rrc_RRC_StateIndicator_cell_DCH);
    }

    /* Get the Primary E-RNTI */
    rrcllc_update_ernti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(ho_utran_r8_ptr,  
      rrc_HandoverToUTRANCommand_r8_IEs,newPrimary_E_RNTI),
      ho_utran_r8_ptr->newPrimary_E_RNTI, TRUE, rrc_RRC_StateIndicator_cell_DCH);

    /* Get the Secondary E-RNTI */
    rrcllc_update_ernti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(ho_utran_r8_ptr,  
      rrc_HandoverToUTRANCommand_r8_IEs,newSecondary_E_RNTI),
      ho_utran_r8_ptr->newSecondary_E_RNTI, FALSE, rrc_RRC_StateIndicator_cell_DCH);

    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_ul_e_dch_information_r8(ho_utran_r8_ptr->specificationMode.u.complete.m. 
     ul_EDCH_InformationPresent,
        &ho_utran_r8_ptr->specificationMode.u.complete.ul_EDCH_Information,
        rrc_RRC_StateIndicator_cell_DCH);
    }

    /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
       update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
    if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(
      rrc_RRC_StateIndicator_cell_DCH) == FAILURE))
    { 
      status= FAILURE;
    }

    if (rrcllc_update_hrnti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(ho_utran_r8_ptr, 
		rrc_HandoverToUTRANCommand_r8_IEs,new_H_RNTI), 
        &ho_utran_r8_ptr->new_H_RNTI, rrc_RRC_StateIndicator_cell_DCH) == FAILURE)
    {
      return FAILURE;
    }

    /* Get HS Information */
    /* SET Action Variable by calling HSDPA action table */
    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r8(
        ho_utran_r8_ptr->specificationMode.u.complete.m.dl_HSPDSCH_InformationPresent,
        &ho_utran_r8_ptr->specificationMode.u.complete.dl_HSPDSCH_Information,
        FALSE, rrc_RRC_StateIndicator_cell_DCH);
    }
  }
  else if ((SUCCESS == status) &&RRC_CHECK_COMMON_MSG_TYPE(
  	ho_utran_r8_ptr->specificationMode,
    rrc_HandoverToUTRANCommand_r8_IEs_specificationMode_preconfiguration))
  {
    WRRC_MSG0_HIGH("REL8: Received HandoverToUTRAN with Preconfiguration.");
    status = rrcllc_handover_to_utran_process_preconfig_r8(ho_utran_r8_ptr);
  }
  
#ifdef FEATURE_VOC_AMR_WB
  ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/

  /* Update the timers and constants in ordered config */
  rrcllc_get_timers_and_const_in_conn_mode_for_handover();

  if ((SUCCESS == status) && (!rrcllc_is_tfcs_provided_on_add_delete_trch(rrc_RRC_StateIndicator_cell_DCH)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      status = FAILURE;
    }
  }

  /* By now the status has been filled as per the processing.*/  
  return (status);
}

/*====================================================================
FUNCTION: rrcllc_handover_to_utran_process_preconfig_r8()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Handover to UTRAN Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_handover_to_utran_process_preconfig_r8
(
  rrc_HandoverToUTRANCommand_r8_IEs *msg_ptr
)
{
  /* Local copy of SIB16 pointer.  In the case of a default configuration,
   * this actually points to data for the specified default configuration,
   * not the actual SIB16 data.  That doesn't matter to us, though.  We also
   * declare some convenience pointers here to shorten the names of the 
   * SIB16 members later on. */
  struct rrc_SysInfoType16            *sib16_ptr = NULL;
  rrc_PredefinedRB_Configuration      *predef_rb = NULL;
  rrc_PreDefPhyChConfiguration        *predef_phych = NULL;
  uecomdef_status_e_type ret_val = SUCCESS;
  rrc_RAB_InformationSetupList  tmp_rab_setup_list;
  rrc_UL_DPCH_Info                ul_dpch_info;
  rrc_DL_CommonInformation        dl_common_info;
  rrc_DL_InformationPerRL_List    dl_rl_ptr = {0};
  /* Return status from DL Info per RL processing. */
  rrcllcoc_dl_info_per_rl_status_e_type status = RRCLLCOC_DL_INFO_PER_RL_IGNORED; 
  uint8      idx     = 0; /* Loop index */
  rrc_DL_InformationPerRL_ListPostFDD  * dl_rl_post_ptr;


  struct rrc_RadioBearerSetup_r5_IEs *rbs_r5_ptr = NULL;
  uint32 default_config_id = RRC_DEF_CONFIG_INVALID;
  void *rbs_ptr = NULL;
  tmp_rab_setup_list.elem = NULL;
  tmp_rab_setup_list.n = 0;
  dl_rl_ptr.elem = NULL;

  memset((void *)&ul_dpch_info, 0, sizeof(rrc_UL_DPCH_Info));
  memset((void *)&dl_common_info, 0, sizeof(rrc_DL_CommonInformation));

  rrcllc_handover_to_utran_alloc_mem(&ul_dpch_info, &dl_common_info, &dl_rl_ptr);
  /* Get a pointer to the SIB16 data and set up some shorter aliases for the unwieldy member data names. */
  if((rbs_ptr = rrciho_get_rbs_ptr(&default_config_id)) != NULL)
  {
    rbs_r5_ptr = (rrc_RadioBearerSetup_r5_IEs *) rbs_ptr;
  }
  else
  {
    sib16_ptr = rrciho_get_sib16_ptr(); 
    if(sib16_ptr == NULL)
    {
      WRRC_MSG0_ERROR("REL8: Failed to get SIB16 information.");
      ret_val = FAILURE;
    }
    else
    {
      predef_rb = &sib16_ptr->preDefinedRadioConfiguration.predefinedRB_Configuration;
    
      predef_phych = &sib16_ptr->preDefinedRadioConfiguration.preDefPhyChConfiguration;
    }
  
    if((ret_val == SUCCESS) &&(msg_ptr->specificationMode.u.preconfiguration.m.rab_InfoPresent))
    {
          tmp_rab_setup_list.elem = rrc_malloc(sizeof(rrc_RAB_InformationSetup));
      if(NULL != predef_rb)
      {
        (void) rrcllc_get_predefined_rab_info(msg_ptr->specificationMode.u.preconfiguration.rab_Info,
                                     predef_rb, &tmp_rab_setup_list);
      }
      else
      {
        WRRC_MSG0_ERROR("REL8: predef_rb is NULL .");
        ret_val = FAILURE;
      }
    }
  }

  if((ret_val == SUCCESS) &&(msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.t == 
    T_rrc_HandoverToUTRANCommand_r8_IEs_modeSpecificInfo_fdd))
  { 
    if(rbs_r5_ptr != NULL)
    {
      if((RRC_MSG_COMMON_BITMASK_IE_PTR(rbs_r5_ptr,rrc_RadioBearerSetup_r5_IEs,ul_ChannelRequirement ))
            && (RRC_CHECK_COMMON_MSG_TYPE(rbs_r5_ptr->ul_ChannelRequirement,
            rrc_UL_ChannelRequirement_r5_ul_DPCH_Info)))
      {
        if(rrcllc_get_predefined_ul_dpch_info_srb5(&ul_dpch_info,
                              &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                              fdd.ul_DPCH_Info, rbs_r5_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
        {
          ret_val = FAILURE;
        }
		if(ret_val == SUCCESS)
			{
        (void)rrcllc_get_predefined_dl_common_info_srb5(&dl_common_info,
                              &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                              fdd.dl_CommonInformationPost,
                              &rbs_r5_ptr->dl_CommonInformation.dl_DPCH_InfoCommon, &msg_ptr->new_U_RNTI);
			}
      }
      else
      {
        WRRC_MSG0_ERROR("REL8: UL DPCH info not present in encoded rb-setup not present ");
        ret_val = FAILURE;
      }
    }
    else
    if(ret_val == SUCCESS)
    {
      (void) rrcllc_get_predefined_ul_dpch_info(&ul_dpch_info,
                                               &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                               fdd.ul_DPCH_Info, predef_phych);
 
      (void) rrcllc_get_predefined_dl_common_info(&dl_common_info,
                                                 &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                                 fdd.dl_CommonInformationPost,
                                                 predef_phych, &msg_ptr->new_U_RNTI);
    }
    if(ret_val == SUCCESS)
    	{
    dl_rl_post_ptr= &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.fdd.dl_InformationPerRL_List;
   dl_rl_ptr.n =1;
	
    memset(&dl_rl_ptr.elem[0].m,0,sizeof(dl_rl_ptr.elem[0].m));
    dl_rl_ptr.elem[0].m.dl_DPCH_InfoPerRLPresent = 1;

    memset(&dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd->m,0,
		sizeof(dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd->m));
		
    dl_rl_ptr.elem[0].modeSpecificInfo.t =
      T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd;
    dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info =
      dl_rl_post_ptr->elem[0].primaryCPICH_Info;
	memset(&dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->m,0,sizeof(dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->m));
  
    dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.t =
      T_rrc_DL_DPCH_InfoPerRL_fdd;
    dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->pCPICH_UsageForChannelEst =
      dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.pCPICH_UsageForChannelEst;
    dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->pCPICH_UsageForChannelEst =
       rrc_PCPICH_UsageForChannelEst_mayBeUsed;
    if(NULL != dl_common_info.modeSpecificInfo.u.fdd)
    {
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dpch_FrameOffset = 
         ((dl_common_info.modeSpecificInfo.u.fdd->defaultDPCH_OffsetValue * 512)
           % 38400) / 256; /* 25.331, clause 8.3.5.1.2 */
    }
    
    dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.n = 1;
    dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.elem[0] =
      dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.dl_ChannelisationCode;
 
    dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->tpc_CombinationIndex =
      dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.tpc_CombinationIndex;
    if( dl_rl_post_ptr->n > 1)
    {
      WRRC_MSG0_ERROR("Single Pri-SCR supported for GtoW HO");
    }
    	}
  }
  else
  {
    WRRC_MSG0_ERROR("REL8: Only FDD mode supported in Handover to UTRAN Command.");
    ret_val = FAILURE;
  }

  if((ret_val == SUCCESS) &&
  	(msg_ptr->specificationMode.u.preconfiguration.preConfigMode.t == 
    T_rrc_HandoverToUTRANCommand_r8_IEs_preConfigMode_defaultConfig)  )
  {
    if(msg_ptr->specificationMode.u.preconfiguration.preConfigMode.u.defaultConfig.m.dummyPresent)
    {
      WRRC_MSG0_ERROR("REL8: dlul_HSPA_Information isn't supported");
      ret_val = FAILURE;
    }
  }

  if(rbs_r5_ptr == NULL)
  {
   if((ret_val == SUCCESS) && (sib16_ptr != NULL) &&
   	(rrcllc_preconfig_sib16_ho_info(sib16_ptr,&tmp_rab_setup_list) == FAILURE ))
   {
     ret_val= FAILURE;
   }
  }
  else
  {
    if((ret_val == SUCCESS) && (rrcllc_srb5_ho_info(rbs_r5_ptr) == FAILURE ))
    {
        ret_val =FAILURE;
    }
  }
  if(tmp_rab_setup_list.elem != NULL)
  {
    rrc_free(tmp_rab_setup_list.elem);
  }

  /* Check to make sure DL TFS count is within UE Capabilities */
  if((ret_val == SUCCESS)&& (rrcllc_check_dl_tfs_cnt() == FAILURE))
  {
    ret_val = FAILURE;
  }
  
  if((ret_val == SUCCESS) && (get_ul_dpch_info(&ul_dpch_info) == FAILURE))
  {
    ret_val = FAILURE;
  }
  
  /* Init DL Common Info to Timing Maintained */
  rrcllc_init_dl_common_info(ordered_config_ptr);

  /* All handover to UTRAN are considered HHO. */
  ordered_config_ptr->is_hho = TRUE;

  if((ret_val == SUCCESS) &&(get_dl_info_common_for_all_rl(&dl_common_info,
                                   &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                   &ordered_config_ptr->l1_dl_cctrch_parms,
                                   &ordered_config_ptr->l1_dl_ctfc_parms) == FAILURE))
  {
    ret_val = FAILURE;
  }
  if(ret_val == SUCCESS)
  	{
  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms);
  	}
  /* Initialize the loop variables */
  idx = 0;
  
  while ((ret_val == SUCCESS) &&(idx < UE_MAX_RL) && (dl_rl_ptr.n > idx) )
  {
    /*Get the DL information for each Radio Link */
    status = get_dl_info_for_each_rl(&dl_rl_ptr.elem[idx], &ordered_config_ptr->l1_dl_chan_parms, idx, TRUE);

    if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
    {
      ret_val = FAILURE;
    }
    else if(status == RRCLLCOC_DL_INFO_PER_RL_IGNORED)
    {
      break;
    }
    else
    {
      idx++;
    }
  } /* end loop of all Radio links */

  /* Save off the number of Radio links in ordered config */
  if(status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS)
  {
    ordered_config_ptr->l1_dl_chan_parms.num_rl = (uint16)idx;
  }
  
  if(ret_val == SUCCESS)
  {
    /* Update the timers and constants in ordered config */
    rrcllc_get_timers_and_const_in_conn_mode_for_handover();
  
  #ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status; 
  #endif/*FEATURE_VOC_AMR_WB*/
    
    rrcllc_adjust_tb_size_handover_to_utran();
  }
  /*If we have come this far, then everything is OK.*/
  rrcllc_handover_to_utran_free_mem(ul_dpch_info, dl_common_info, dl_rl_ptr);
  return ret_val;
}
#ifdef FEATURE_WCDMA_REL9

/*====================================================================
FUNCTION: rrcllc_handover_to_utran_process_preconfig_r9()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Handover to UTRAN Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_handover_to_utran_process_preconfig_r9
(
  rrc_HandoverToUTRANCommand_r9_IEs *msg_ptr
)
{
  /* Local copy of SIB16 pointer.  In the case of a default configuration,
   * this actually points to data for the specified default configuration,
   * not the actual SIB16 data.  That doesn't matter to us, though.  We also
   * declare some convenience pointers here to shorten the names of the 
   * SIB16 members later on. */
  struct rrc_SysInfoType16            *sib16_ptr = NULL;
  rrc_PredefinedRB_Configuration      *predef_rb = NULL;
  rrc_PreDefPhyChConfiguration        *predef_phych = NULL;
  uecomdef_status_e_type ret_val = SUCCESS;
  rrc_RAB_InformationSetupList  tmp_rab_setup_list;
  rrc_UL_DPCH_Info                ul_dpch_info;
  rrc_DL_CommonInformation        dl_common_info;
  rrc_DL_InformationPerRL_List    dl_rl_ptr = {0};
  /* Return status from DL Info per RL processing. */
  rrcllcoc_dl_info_per_rl_status_e_type status = RRCLLCOC_DL_INFO_PER_RL_IGNORED; 
  uint8      idx     = 0; /* Loop index */
  rrc_DL_InformationPerRL_ListPostFDD  * dl_rl_post_ptr;

  struct rrc_RadioBearerSetup_r5_IEs *rbs_r5_ptr = NULL;
  uint32 default_config_id = RRC_DEF_CONFIG_INVALID;
  void *rbs_ptr = NULL;
  tmp_rab_setup_list.elem = NULL;
  tmp_rab_setup_list.n = 0;
  dl_rl_ptr.elem = NULL;

  memset((void *)&ul_dpch_info, 0, sizeof(rrc_UL_DPCH_Info));
  memset((void *)&dl_common_info, 0, sizeof(rrc_DL_CommonInformation));

  rrcllc_handover_to_utran_alloc_mem(&ul_dpch_info, &dl_common_info, &dl_rl_ptr);
  /* Get a pointer to the SIB16 data and set up some shorter aliases for the unwieldy member data names. */
  if((rbs_ptr = rrciho_get_rbs_ptr(&default_config_id)) != NULL)
  {
    rbs_r5_ptr = (rrc_RadioBearerSetup_r5_IEs *) rbs_ptr;
  }
  else
  {
    sib16_ptr = rrciho_get_sib16_ptr(); 
    if(sib16_ptr == NULL)
    {
      WRRC_MSG0_ERROR("REL9: Failed to get SIB16 information.");
      ret_val = FAILURE;
    }
    else
    {
      predef_rb = &sib16_ptr->preDefinedRadioConfiguration.predefinedRB_Configuration;
    
      predef_phych = &sib16_ptr->preDefinedRadioConfiguration.preDefPhyChConfiguration;
    }
  
    if((ret_val == SUCCESS) &&(msg_ptr->specificationMode.u.preconfiguration.m.rab_InfoPresent))
    {
      tmp_rab_setup_list.elem = rrc_malloc(sizeof(rrc_RAB_InformationSetup));
      if(NULL != predef_rb)
      {
        (void) rrcllc_get_predefined_rab_info(msg_ptr->specificationMode.u.preconfiguration.rab_Info,
                                 predef_rb, &tmp_rab_setup_list);
      }
      else
      {
        WRRC_MSG0_ERROR("REL9: predef_rb is NULL .");
        ret_val = FAILURE;
      }
    }
  }

  if((ret_val == SUCCESS) &&(msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.t == 
    T_rrc_HandoverToUTRANCommand_r9_IEs_modeSpecificInfo_fdd))
  { 
    if(rbs_r5_ptr != NULL)
    {
      if((RRC_MSG_COMMON_BITMASK_IE_PTR(rbs_r5_ptr,rrc_RadioBearerSetup_r5_IEs,ul_ChannelRequirement ))
            && (RRC_CHECK_COMMON_MSG_TYPE(rbs_r5_ptr->ul_ChannelRequirement,
            rrc_UL_ChannelRequirement_r5_ul_DPCH_Info)))
      {
        if(rrcllc_get_predefined_ul_dpch_info_srb5(&ul_dpch_info,
                              &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                              fdd.ul_DPCH_Info, rbs_r5_ptr->ul_ChannelRequirement.u.ul_DPCH_Info) == FAILURE)
        {
          ret_val = FAILURE;
        }
        if(ret_val == SUCCESS)
        {
          (void)rrcllc_get_predefined_dl_common_info_srb5(&dl_common_info,
                                &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                fdd.dl_CommonInformationPost,
                                &rbs_r5_ptr->dl_CommonInformation.dl_DPCH_InfoCommon, &msg_ptr->new_U_RNTI);
        }
      }
      else
      {
        WRRC_MSG0_ERROR("REL9: UL DPCH info not present in encoded rb-setup not present ");
        ret_val = FAILURE;
      }
    }
    else
    if(ret_val == SUCCESS)
    {
      (void) rrcllc_get_predefined_ul_dpch_info(&ul_dpch_info,
                                               &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                               fdd.ul_DPCH_Info, predef_phych);
 
      (void) rrcllc_get_predefined_dl_common_info(&dl_common_info,
                                                 &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.
                                                 fdd.dl_CommonInformationPost,
                                                 predef_phych, &msg_ptr->new_U_RNTI);
    }
    if(ret_val == SUCCESS)
    {
      dl_rl_post_ptr= &msg_ptr->specificationMode.u.preconfiguration.modeSpecificInfo.u.fdd.dl_InformationPerRL_List;
      dl_rl_ptr.n =1;

      memset(&dl_rl_ptr.elem[0].m,0,sizeof(dl_rl_ptr.elem[0].m));
      dl_rl_ptr.elem[0].m.dl_DPCH_InfoPerRLPresent = 1;

      memset(&dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd->m,0,
      sizeof(dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd->m));
      
      dl_rl_ptr.elem[0].modeSpecificInfo.t =
        T_rrc_DL_InformationPerRL_modeSpecificInfo_fdd;
      dl_rl_ptr.elem[0].modeSpecificInfo.u.fdd->primaryCPICH_Info =
        dl_rl_post_ptr->elem[0].primaryCPICH_Info;
      memset(&dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->m,0,sizeof(dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->m));

      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.t =
        T_rrc_DL_DPCH_InfoPerRL_fdd;
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->pCPICH_UsageForChannelEst =
        dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.pCPICH_UsageForChannelEst;
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->pCPICH_UsageForChannelEst =
         rrc_PCPICH_UsageForChannelEst_mayBeUsed;
      if(NULL != dl_common_info.modeSpecificInfo.u.fdd)
      {
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dpch_FrameOffset = 
         ((dl_common_info.modeSpecificInfo.u.fdd->defaultDPCH_OffsetValue * 512)
           % 38400) / 256; /* 25.331, clause 8.3.5.1.2 */
      }
      
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.n = 1;
      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->dl_ChannelisationCodeList.elem[0] =
        dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.dl_ChannelisationCode;

      dl_rl_ptr.elem[0].dl_DPCH_InfoPerRL.u.fdd->tpc_CombinationIndex =
        dl_rl_post_ptr->elem[0].dl_DPCH_InfoPerRL.tpc_CombinationIndex;
      if( dl_rl_post_ptr->n > 1)
      {
        WRRC_MSG0_ERROR("Single Pri-SCR supported for GtoW HO");
      }
    }
  }
  else
  {
    WRRC_MSG0_ERROR("REL9: Only FDD mode supported in Handover to UTRAN Command.");
    ret_val = FAILURE;
  }

  if((ret_val == SUCCESS) &&
    (msg_ptr->specificationMode.u.preconfiguration.preConfigMode.t == 
    T_rrc_HandoverToUTRANCommand_r9_IEs_preConfigMode_defaultConfig)  )
  {
    if(msg_ptr->specificationMode.u.preconfiguration.preConfigMode.u.defaultConfig.m.dummyPresent)
    {
      WRRC_MSG0_ERROR("REL9: dlul_HSPA_Information isn't supported");
      ret_val = FAILURE;
    }
  }

  if(rbs_r5_ptr == NULL)
  {
   if((ret_val == SUCCESS) && (sib16_ptr != NULL) &&
    (rrcllc_preconfig_sib16_ho_info(sib16_ptr,&tmp_rab_setup_list) == FAILURE ))
   {
     ret_val= FAILURE;
   }
  }
  else
  {
    if((ret_val == SUCCESS) && (rrcllc_srb5_ho_info(rbs_r5_ptr) == FAILURE ))
    {
        ret_val =FAILURE;
    }
  }
  if(tmp_rab_setup_list.elem != NULL)
  {
    rrc_free(tmp_rab_setup_list.elem);
  }

  /* Check to make sure DL TFS count is within UE Capabilities */
  if((ret_val == SUCCESS)&& (rrcllc_check_dl_tfs_cnt() == FAILURE))
  {
    ret_val = FAILURE;
  }
  
  if((ret_val == SUCCESS) && (get_ul_dpch_info(&ul_dpch_info) == FAILURE))
  {
    ret_val = FAILURE;
  }
  
  /* Init DL Common Info to Timing Maintained */
  rrcllc_init_dl_common_info(ordered_config_ptr);

  /* All handover to UTRAN are considered HHO. */
  ordered_config_ptr->is_hho = TRUE;

  if((ret_val == SUCCESS) &&(get_dl_info_common_for_all_rl(&dl_common_info,
                                   &ordered_config_ptr->l1_dl_chan_parms.dl_common,
                                   &ordered_config_ptr->l1_dl_cctrch_parms,
                                   &ordered_config_ptr->l1_dl_ctfc_parms) == FAILURE))
  {
    ret_val = FAILURE;
  }
  if(ret_val == SUCCESS)
    {
  /* Calculate the DL TFCS, apply the latest RM Restriction Info */
  update_rm_restriction_info(&ordered_config_ptr->l1_dl_cctrch_parms,
                             &ordered_config_ptr->dl_ctfc,
                             &ordered_config_ptr->rm_restrict,
                             &ordered_config_ptr->l1_dl_ctfc_parms);
    }
  /* Initialize the loop variables */
  idx = 0;
  
  while ((ret_val == SUCCESS) &&(idx < UE_MAX_RL) && (dl_rl_ptr.n > idx) )
  {
    /*Get the DL information for each Radio Link */
    status = get_dl_info_for_each_rl(&dl_rl_ptr.elem[idx], &ordered_config_ptr->l1_dl_chan_parms, idx, TRUE);

    if(status == RRCLLCOC_DL_INFO_PER_RL_FAILURE)
    {
      ret_val = FAILURE;
    }
    else if(status == RRCLLCOC_DL_INFO_PER_RL_IGNORED)
    {
      break;
    }
    else
    {
      idx++;
    }
  } /* end loop of all Radio links */

  /* Save off the number of Radio links in ordered config */
  if(status == RRCLLCOC_DL_INFO_PER_RL_SUCCESS)
  {
    ordered_config_ptr->l1_dl_chan_parms.num_rl = (uint16)idx;
  }
  if(ret_val == SUCCESS)
  {
    /* Update the timers and constants in ordered config */
    rrcllc_get_timers_and_const_in_conn_mode_for_handover();
  
#ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status; 
#endif/*FEATURE_VOC_AMR_WB*/
    
      rrcllc_adjust_tb_size_handover_to_utran();
  }
  /*If we have come this far, then everything is OK.*/
  rrcllc_handover_to_utran_free_mem(ul_dpch_info, dl_common_info, dl_rl_ptr);
  return ret_val;
}


#ifdef FEATURE_WCDMA_DEFAULT_CFG_CELLFACH
/*====================================================================
FUNCTION: rrcllc_process_default_config_cellfach()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in R5 RRC Connection Setup Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.
add check for F-DPCH & E-DPDCH
SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_process_default_config_cellfach
(
void
)
{
  uint8	srb_cnt =0;
  uecomdef_logch_mode_e_type logch_mode = UE_MODE_MAX_NUM;
  uecomdef_status_e_type status= FAILURE;
  rrc_DL_DCCH_Message     *default_config_msg_ptr=NULL;
  rrc_RadioBearerSetup_r8_IEs *msg_r8_ptr=NULL;
  /* 72526 -rrc_dsds_concurrency not being used for DIME and later and hence being used it here */
  if (0 == rrc_default_cfg_in_cell_fach_nv)
  {
    WRRC_MSG0_ERROR("DC_CELLFACH:defaultConfigForCellFACH not supported yet, please set NV item number 72526 to 1");
    return FAILURE;
  }
  if(NULL != rrcrbrc_default_config_0_dc_fach)
  {
    default_config_msg_ptr = 
          (rrc_DL_DCCH_Message *)rrcasn1_decode_pdu((void *)rrcrbrc_default_config_0_dc_fach,
                                                     rrc_DL_DCCH_Message_PDU,
                                                     rrcrbrc_default_config_0_len
                                                   );
    if(default_config_msg_ptr != NULL)
    {
      msg_r8_ptr = (rrc_RadioBearerSetup_r8_IEs *)&(default_config_msg_ptr->message.u.radioBearerSetup.
                    u.later_than_r3.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.u.r8.radioBearerSetup_r8);
    }
    if (NULL != msg_r8_ptr)
    {
       WRRC_MSG0_ERROR("DC_CELLFACH: Decoded the default config successfully for CELLFACH");
  
       for (srb_cnt =0;srb_cnt < NUM_SRB_DC_CELLFACH;srb_cnt++)
       {
          /*For case 2 below, the UE appends mapping option of FACH + RACH from default configuration to the mapping option list for SRBn.*/
          MSG_6(MSG_SSID_DFLT, MSG_LEGACY_HIGH, "DC_CELLFACH: Mapping %d %d %d, RB present %d %d %d ",
            default_cfg_ota_mapping [0], default_cfg_ota_mapping [1], default_cfg_ota_mapping [2],
            default_cfg_recfg_list_srb_present[0], default_cfg_recfg_list_srb_present[1], default_cfg_recfg_list_srb_present[2]);
          if (TRUE == default_cfg_recfg_list_srb_present[srb_cnt])
          {
            if (FACH_RACH_MAPPING_PRESENT != default_cfg_ota_mapping[msg_r8_ptr->srb_InformationSetupList.elem[srb_cnt].rb_Identity-1])
            {
               /* Use the IE Pointer that came as a parameter to get the RB Mapping info */
               logch_mode = get_rlc_mode_r7(msg_r8_ptr->srb_InformationSetupList.elem[srb_cnt].rlc_InfoChoice.u.rlc_Info);
               if (get_rb_mapping_info_r8(&msg_r8_ptr->srb_InformationSetupList.elem[srb_cnt].rb_MappingInfo, msg_r8_ptr->srb_InformationSetupList.elem[srb_cnt].rb_Identity, logch_mode
               , FALSE,FALSE,TRUE) == FAILURE)
               {
                  return FAILURE;
               }
               if(FAILURE == rrcllc_validate_srb_id(msg_r8_ptr->srb_InformationSetupList.elem[srb_cnt].rb_Identity))
               {
                  return FAILURE;
               }
            }
          }
          else
          {
            /*For case 3 below, the UE stores the mapping option of FACH + RACH from default configuration for SRBn and then (re)configures RLC for SRBn according to Table 13.8.1.*/
            WRRC_MSG0_ERROR("DC_CELLFACH: dc_fach_rb_info_reconfig_present not present");
            unmap_rb(msg_r8_ptr->srb_InformationSetupList.elem[srb_cnt].rb_Identity, OC_AND_TOC);
  
            if(get_srb_info_to_setup_r8(
            &msg_r8_ptr->srb_InformationSetupList.elem[srb_cnt], 
            (&msg_r8_ptr->srb_InformationSetupList), 
            msg_r8_ptr->srb_InformationSetupList.elem[srb_cnt].rb_Identity)
            == FAILURE)
            {
              return FAILURE;
            }
          }
       }
       status = rrcllc_validate_rb_mapping_info();	 
    }
    rrcasn1_free_pdu((int)rrc_DL_DCCH_Message_PDU,default_config_msg_ptr);
  }
  return status;
}
#endif

/*====================================================================
FUNCTION: rrcllc_handover_to_utran_ie_r9()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Handover to UTRAN Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_handover_to_utran_ie_r9
(
  rrc_HandoverToUTRANCommand_r9 *msg_ptr
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_HandoverToUTRANCommand_r9_IEs * ho_utran_r9_ptr;

  ho_utran_r9_ptr = &msg_ptr->handoverToUTRANCommand_r9;

#ifdef FEATURE_WCDMA_DEFAULT_CFG_CELLFACH
  if ((SUCCESS == status) && (ho_utran_r9_ptr->m.defaultConfigForCellFACHPresent))
  {
    memset(default_cfg_ota_mapping,0,NUM_SRB_DC_CELLFACH);
    memset(default_cfg_recfg_list_srb_present,0,NUM_SRB_DC_CELLFACH);
  }
#else
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(ho_utran_r9_ptr,rrc_HandoverToUTRANCommand_r9_IEs,defaultConfigForCellFACH))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: defaultConfigForCellFACH not supported ");
  }
#endif
  if( RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_HandoverToUTRANCommand_r9,v9c0NonCriticalExtensions))
  {
    WRRC_MSG0_ERROR("REL9: nonCriticalExtensions not supported ");
    return FAILURE;
  }

  ordered_config_ptr->rrc_state_indicator = RRC_STATE_CELL_DCH;

  rrc_translate_urnti_short(&ho_utran_r9_ptr->new_U_RNTI, &ordered_config_ptr->mac_ul_parms.rnti_info.urnti);
  ordered_config_ptr->mac_dl_parms.rnti_info.urnti = ordered_config_ptr->mac_ul_parms.rnti_info.urnti;
  ordered_config_ptr->mac_dl_parms.rnti_info.rnti_valid = URNTI_VALID;

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power.  MP for ho to utran */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(TRUE, ho_utran_r9_ptr->maxAllowedUL_TX_Power);
  }

  if ((SUCCESS == status) && RRC_CHECK_COMMON_MSG_TYPE(ho_utran_r9_ptr->specificationMode
      ,rrc_HandoverToUTRANCommand_r9_IEs_specificationMode_complete))
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID. */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(
      TRUE, &ho_utran_r9_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList, FALSE, NULL);
    
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r9(
        &ho_utran_r9_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList, NULL);
    }

    /* Get the SRB setup list if present */
    if (SUCCESS == status)
    {
      status =  rrcllc_process_srb_info_setup_list_r8(TRUE, 
          &ho_utran_r9_ptr->specificationMode.u.complete.srb_InformationSetupList);
    }

    /* Get the RAB setup list if present */
    if (SUCCESS == status)
    {
      status = rrcllc_process_rab_info_setup_list_r8(ho_utran_r9_ptr->specificationMode.
      u.complete.m.rab_InformationSetupListPresent,
        &ho_utran_r9_ptr->specificationMode.u.complete.rab_InformationSetupList);
    }

    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }
    
    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(TRUE, 
          &ho_utran_r9_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }

    if(SUCCESS == status)
    {
      status = rrcllc_store_ul_add_reconf_trch_info_list_r8(TRUE,
          &ho_utran_r9_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    }

    /* Calculate the UL TFCS */
    compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

    if(RRC_MSG_COMMON_BITMASK_IE(ho_utran_r9_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
      rrc_UL_CommonTransChInfo_r4,tfc_Subset))
    { 
      status = rrcllc_update_oc_with_tfc_subset(
        &ho_utran_r9_ptr->specificationMode.u.complete.ul_CommonTransChInfo, MSG_REL9);
    } 

    if((SUCCESS == status ) &&
      (RRC_MSG_COMMON_BITMASK_IE_TYPE2(ho_utran_r9_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
        tfc_SubsetList)))
    {
      if(rrcllc_update_oc_with_tfc_subset_list(&ho_utran_r9_ptr->specificationMode.u.complete.
          ul_CommonTransChInfo) == FAILURE)
      {
        status= FAILURE;
      }
    }

    /* Get the Common Downlink Transport Channel information */
    if(SUCCESS == status)
    {
      status = get_dl_info_common_for_all_trch_r5(&ho_utran_r9_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
        &ho_utran_r9_ptr->specificationMode.u.complete.ul_CommonTransChInfo, ordered_config_ptr->rrc_state_indicator);
    }

    if(SUCCESS == status)
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r9(
        TRUE, &ho_utran_r9_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &ho_utran_r9_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    } 

    if(SUCCESS == status)
    {
      status = rrcllcpcie_process_ul_dpch_info_r7(TRUE,
        &ho_utran_r9_ptr->specificationMode.u.complete.ul_DPCH_Info, rrc_RRC_StateIndicator_cell_DCH);
    }

    if (SUCCESS == status) 
    {
      status = rrcllcpcie_is_hho_r7(TRUE, 
        &ho_utran_r9_ptr->specificationMode.u.complete.dl_InformationPerRL_List,
        rrc_RRC_StateIndicator_cell_DCH);
    }

    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_dl_common_info_r8(TRUE, 
        &ho_utran_r9_ptr->specificationMode.u.complete.dl_CommonInformation,
        rrc_RRC_StateIndicator_cell_DCH);
    }
    
    if (SUCCESS == status)
    {
      /* update R99, HS and EUL related variables */
      status = rrcllcpcie_process_dl_info_per_rl_list_r7(TRUE, 
        &ho_utran_r9_ptr->specificationMode.u.complete.dl_InformationPerRL_List,
        rrc_RRC_StateIndicator_cell_DCH);
    }

    /* Get the Primary E-RNTI */
    rrcllc_update_ernti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(ho_utran_r9_ptr,  
      rrc_HandoverToUTRANCommand_r9_IEs,newPrimary_E_RNTI),
      ho_utran_r9_ptr->newPrimary_E_RNTI, TRUE, rrc_RRC_StateIndicator_cell_DCH);

    /* Get the Secondary E-RNTI */
    rrcllc_update_ernti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(ho_utran_r9_ptr,  
      rrc_HandoverToUTRANCommand_r9_IEs,newSecondary_E_RNTI),
      ho_utran_r9_ptr->newSecondary_E_RNTI, FALSE, rrc_RRC_StateIndicator_cell_DCH);

    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_ul_e_dch_information_r9(ho_utran_r9_ptr->specificationMode.u.complete.m. 
     ul_EDCH_InformationPresent,
        &ho_utran_r9_ptr->specificationMode.u.complete.ul_EDCH_Information,
        rrc_RRC_StateIndicator_cell_DCH);
    }

    /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
       update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
    if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(
      rrc_RRC_StateIndicator_cell_DCH) == FAILURE))
    { 
      status= FAILURE;
    }

    if (rrcllc_update_hrnti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(ho_utran_r9_ptr, 
    rrc_HandoverToUTRANCommand_r9_IEs,new_H_RNTI), 
        &ho_utran_r9_ptr->new_H_RNTI, rrc_RRC_StateIndicator_cell_DCH) == FAILURE)
    {
      return FAILURE;
    }

    /* Get HS Information */
    /* SET Action Variable by calling HSDPA action table */
    if (SUCCESS == status)
    {
      status = rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r9(
        ho_utran_r9_ptr->specificationMode.u.complete.m.dl_HSPDSCH_InformationPresent,
        &ho_utran_r9_ptr->specificationMode.u.complete.dl_HSPDSCH_Information,
        FALSE, rrc_RRC_StateIndicator_cell_DCH);
    }
  }
  else if ((SUCCESS == status) &&RRC_CHECK_COMMON_MSG_TYPE(
    ho_utran_r9_ptr->specificationMode,
    rrc_HandoverToUTRANCommand_r9_IEs_specificationMode_preconfiguration))
  {
    WRRC_MSG0_HIGH("REL9: Received HandoverToUTRAN with Preconfiguration.");
    status = rrcllc_handover_to_utran_process_preconfig_r9(ho_utran_r9_ptr);
  }
  
#ifdef FEATURE_VOC_AMR_WB
  ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/

  /* Update the timers and constants in ordered config */
  rrcllc_get_timers_and_const_in_conn_mode_for_handover();

  if ((SUCCESS == status) && (!rrcllc_is_tfcs_provided_on_add_delete_trch(rrc_RRC_StateIndicator_cell_DCH)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      status = FAILURE;
    }
  }
#ifdef FEATURE_WCDMA_DEFAULT_CFG_CELLFACH
  if (SUCCESS == status)
  {
      if (ho_utran_r9_ptr->m.defaultConfigForCellFACHPresent)
      {
        if (rrc_DefaultConfigMode_fdd == ho_utran_r9_ptr->defaultConfigForCellFACH.defaultConfigMode)
        {
          WRRC_MSG0_HIGH("DC_CELLFACH:Received default configuration mode for FDD");
          
          if (RRC_DEF_CONFIG_0_DC_FACH == ho_utran_r9_ptr->defaultConfigForCellFACH.defaultConfigIdForCellFACH) 		  
          {
            status = rrcllc_process_default_config_cellfach();
          }
        }
      }
  }
#endif

  /* By now the status has been filled as per the processing.*/  
  return (status);
}



/*====================================================================
FUNCTION: rrcllc_rb_reconfig_ie_r9()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Reconfiguration Message R9

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_reconfig_ie_r9
(
  rrc_RadioBearerReconfiguration_r9 * rb_reconfig_r9_ota
)
{
  uecomdef_status_e_type		  status = SUCCESS;
  rrc_RadioBearerReconfiguration_r9_IEs *msg_ptr;
  rrc_DL_DeletedTransChInfoList_r7	 * dl_trch_delete_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList_r9 * dl_trch_add_reconfig_ptr = NULL;
  ordered_config_type			   *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type 		 directed_cell_info;
  
  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
  
  msg_ptr  = &rb_reconfig_r9_ota->radioBearerReconfiguration_r9;
  
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
  new_DSCH_RNTI))
  {
    return FAILURE;
  }
  
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
  controlChannelDRXInfo_TDD128))
  {
    return FAILURE;
  }
  
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
  sps_Information_TDD128))
  {
    return FAILURE;
  }
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
  cellDCHMeasOccasionInfo_TDD128))
  {
    return FAILURE;
  }
#ifndef FEATURE_WCDMA_DC_HSUPA
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
  ul_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9: IE ul_SecondaryCellInfoFDD not supported.");
    return FAILURE;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */
  if(( RRC_MSG_COMMON_BITMASK_IE_PTR(rb_reconfig_r9_ota,rrc_RadioBearerReconfiguration_r9,v950NonCriticalExtensions)) &&
  (RRC_MSG_COMMON_BITMASK_IE(rb_reconfig_r9_ota->v950NonCriticalExtensions.radioBearerReconfiguration_v950ext,rrc_RadioBearerReconfiguration_v950ext_IEs,
  secondaryCellMimoParameters)))
  {
    WRRC_MSG0_ERROR("REL9: secondaryCellMimoParameters not supported ");
    return FAILURE;
  }
  if(( RRC_MSG_COMMON_BITMASK_IE_PTR(rb_reconfig_r9_ota,rrc_RadioBearerReconfiguration_r9,v950NonCriticalExtensions))&&
  (RRC_MSG_COMMON_BITMASK_IE(rb_reconfig_r9_ota->v950NonCriticalExtensions,rrc_RadioBearerReconfiguration_v950NonCriticalExtensions,
  v9c0NonCriticalExtensions)))
  {
    WRRC_MSG0_ERROR("REL9: nonCriticalExtensions not supported ");
    return FAILURE;
  }
  
  /*We're processing a reconfiguration message now, so set the reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;
  
  rrcllc_init_before_msg_processing();

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
    /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,delayRestrictionFlag) !=0);
#endif
  
  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,activationTime)),
  msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBRC);
  
#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  status = rrcllc_update_urnti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,new_U_RNTI)), &msg_ptr->new_U_RNTI,
  msg_ptr->rrc_StateIndicator);
#ifdef FEATURE_WCDMA_DEFAULT_CFG_CELLFACH
   if ((SUCCESS == status) && (msg_ptr->m.defaultConfigForCellFACHPresent))
   {
     memset(default_cfg_ota_mapping,0,NUM_SRB_DC_CELLFACH);
     memset(default_cfg_recfg_list_srb_present,0,NUM_SRB_DC_CELLFACH);
   }
#else
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,defaultConfigForCellFACH))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: defaultConfigForCellFACH not supported yet!");
  }
#endif
  rrcllc_update_crnti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,new_C_RNTI)), msg_ptr->new_C_RNTI, 
  msg_ptr->rrc_StateIndicator);
  
  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,utran_DRX_CycleLengthCoeff)),
    &msg_ptr->utran_DRX_CycleLengthCoeff);
  }
  
  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      frequencyInfo)), &msg_ptr->frequencyInfo,
    msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      maxAllowedUL_TX_Power)),
    msg_ptr->maxAllowedUL_TX_Power);
  }
  
  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
  
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/
  if ((SUCCESS == status) && (T_rrc_RadioBearerReconfiguration_r9_IEs_specificationMode_complete ==
  msg_ptr->specificationMode.t))
  {
    /* Call these functions ONLY in DCH state */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Here, update the transport channel info (only transport channel IDs 
         * and count) and rearrange the info by sorting transport channel list
         * based on TrCH ID. */
      status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(
      RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r9_IEs),
      &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList,
      RRCRB_R6_UL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r9_IEs),
      &msg_ptr->specificationMode.u.complete.ul_deletedTransChInfoList);
      
      
      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
      if (RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r9_IEs))
      {
        dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
      }
      
      if (RRCRB_R6_DL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r9_IEs))
      {
        dl_trch_delete_ptr = &msg_ptr->specificationMode.u.complete.dl_DeletedTransChInfoList;
      }
      
      /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
      if (SUCCESS == status)
      {
        status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r9(
        dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
      }
      

    }
    
    /*The OC ptr is now restor to point to Order config ptr*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);
    
    /* Get the RB reconfiguration list */
    if (SUCCESS == status)
    {
      status = rrcllc_process_rb_info_reconfig_list_r8(RRCRB_R6_RB_INFO_RECONFIG_LIST_PRESENT(msg_ptr, 
      rrc_RadioBearerReconfiguration_r9_IEs), &msg_ptr->specificationMode.u.complete.rb_InformationReconfigList);
    }
    
    if (SUCCESS == status)
    {
      status = rrcllc_process_rb_info_affected_list_r8(RRCRB_R6_RB_INFO_AFFECTED_LIST_PRESENT(msg_ptr, 
      rrc_RadioBearerReconfiguration_r9_IEs), &msg_ptr->specificationMode.u.complete.rb_InformationAffectedList);
    }
    
    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }
    
    /* use TOC ptr if not received in DCH state */
    tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
    /*For FACH, PCH, URA PCH states	the below contents will now be update to TOC.
    OC ptr is now pointing to TOC ptr*/
    
    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(
      RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r9_IEs),
      &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }
    
    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined */
    if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      #ifdef FEATURE_VOC_AMR_WB
      ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
      #endif/*FEATURE_VOC_AMR_WB*/
      
      status = rrcllc_store_ul_add_reconf_trch_info_list_r8(
      RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r9_IEs),
      &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
      
      /* Calculate the UL TFCS */
      if((SUCCESS == status) && (RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr, 
      rrc_RadioBearerReconfiguration_r9_IEs)))
      {
        compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
        
        if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
        rrc_UL_CommonTransChInfo_r4,tfc_Subset))
        {
          if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo, 
          MSG_REL9) == FAILURE)
          {
            status = FAILURE;
          }
          if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
          tfc_SubsetList)))
          {
            if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo) == FAILURE)
            {
              status = FAILURE;
            }
          }
        }
      }
    } /* If state is Cell_DCH */
    
    /*The OC ptr is now restor to point to Order config ptr*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);
    
    if (SUCCESS == status)
    {
      /* Fill in the RLC size restriction information for MAC */
      if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
      {
      status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
      ordered_config_ptr->rrc_state_indicator);
      }
    }
    
    /* use TOC ptr if not received in DCH state */
    tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
    /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
    OC ptr is now pointing to TOC ptr*/
    
    /* Get the Common Downlink Transport Channel information */
    if((SUCCESS == status) &&
    (RRCRB_R6_DL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r9_IEs)))
    {
      status = get_dl_info_common_for_all_trch_r5(&msg_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
      &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator);
    }
    
    if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r9(
      RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r9_IEs),
      &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
      &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    } /* If state is Cell_DCH */	  
    
    /* The OC ptr is now restor to point to Order config ptr */
    rrcllc_restore_oc_ptr (tmp_config_ptr);
    
    if ( msg_ptr->specificationMode.u.complete.m.pdcp_ROHC_TargetModePresent)
    {
      WRRC_MSG0_ERROR("REL9: pdcp_ROHC_TargetMode IE not supported yet!");
    }
  }
  else /* rrc_RadioBearerReconfiguration_r8_IEs_specificationMode_complete */
  {
    WRRC_MSG0_ERROR("REL9: SpecificationMode preconfiguration isn't supported yet!");
    status = FAILURE;
  }
  
  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_DPCH_Info)),
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_CommonInformation)),
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_InformationPerRL_List)),
    msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_DPCH_Info)),
    &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    dl_InformationPerRL_List)), &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_CommonInformation)), &msg_ptr->dl_CommonInformation,
    msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_InformationPerRL_List)), 
    &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }
  
  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
  newPrimary_E_RNTI)), msg_ptr->newPrimary_E_RNTI, TRUE, msg_ptr->rrc_StateIndicator);
  
  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
  newSecondary_E_RNTI)), msg_ptr->newSecondary_E_RNTI, FALSE, msg_ptr->rrc_StateIndicator);
  
  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r9((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_EDCH_Information)),
    &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }
  
  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
  update mac_eul_action and l1_e_req_mask as per computed value of
  e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
  rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }
  
  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }
  
  if (SUCCESS == status)
  {
  /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      new_H_RNTI)), &msg_ptr->new_H_RNTI,
    msg_ptr->rrc_StateIndicator);
  }
  
  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r9(
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_HSPDSCH_Information)),
    &msg_ptr->dl_HSPDSCH_Information,
      ((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,frequencyInfo)) &&
    (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
    msg_ptr->rrc_StateIndicator);
  }
  
  
  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }
  
#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r9(&msg_ptr->mimoParameters, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
  mimoParameters))) == FAILURE))
  {
    status = FAILURE;
  }
  #else /*FEATURE_WCDMA_MIMO*/
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: mimoParameters not supported ");
  }
#endif /*FEATURE_WCDMA_MIMO*/
  
  
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,hs_scch_LessInfo))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: hs_scch_LessInfo not supported ");
  }
  
  #ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params_r9(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
  dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }
  #else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
  #endif /*FEATURE_WCDMA_DC_HSDPA*/
  
  if ((SUCCESS == status) && (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }
  
  if(SUCCESS == status)
  {
    if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,delayRestrictionFlag))
    {
      if((RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r9_IEs))
      ||(RRCRB_R6_UL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r9_IEs))
      ||(RRCRB_R6_DL_DELETED_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r9_IEs))
      ||(RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr, rrc_RadioBearerReconfiguration_r9_IEs))
      ) 
      {
        WRRC_MSG0_ERROR("REL9: Trch IE touched bitmask  , so Delay restriction cannot be applied");
      }
      else
      {
        rrcllc_update_delay_restriction((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
          activationTime)),
        (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,delayRestrictionFlag)),
        msg_ptr->activationTime,msg_ptr->rrc_StateIndicator);
      }
    }
  }
  
  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
         (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dtx_drx_TimingInfo)),
    &msg_ptr->dtx_drx_Info,
         (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dtx_drx_Info)),
    msg_ptr->rrc_StateIndicator
    ) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                               validate_directed_cell_info,
                                               FALSE,
                                               RRCRB_R9_MSG_IE_PRESENT(msg_ptr,new_H_RNTI));
  }
  
  #ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                               validate_directed_cell_info,
                                               FALSE,
                                               RRCRB_R9_MSG_IE_PRESENT(msg_ptr,newPrimary_E_RNTI));

  }
#endif  /*FEATURE_WCDMA_HS_RACH*/
#endif /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_DC_HSUPA
  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dc_hsupa_params(&msg_ptr->ul_SecondaryCellInfoFDD,msg_ptr->rrc_StateIndicator,
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_SecondaryCellInfoFDD)))== FAILURE)
      {
        status = FAILURE;
      }
  }

#endif /* FEATURE_WCDMA_DC_HSUPA */

#ifdef FEATURE_WCDMA_DEFAULT_CFG_CELLFACH
  if (SUCCESS == status)
  {
       if (msg_ptr->m.defaultConfigForCellFACHPresent)
       {
          if (rrc_DefaultConfigMode_fdd == msg_ptr->defaultConfigForCellFACH.defaultConfigMode)
          {
            
            if (RRC_DEF_CONFIG_0_DC_FACH == msg_ptr->defaultConfigForCellFACH.defaultConfigIdForCellFACH)			
            {
               status = rrcllc_process_default_config_cellfach();
            }
          }
       }
       else
       {
       WRRC_MSG0_MED("DC_CELLFACH:defaultConfigForCellFACH is not Present");
       }
  	}
#endif   
  /* By now the status has been filled as per the processing.*/
  return (status);
}


/*====================================================================
FUNCTION: rrcllc_phychan_reconfig_ie_r9()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Physical Channel Reconfiguration Message for Rel 9

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_phychan_reconfig_ie_r9
(
  rrc_PhysicalChannelReconfiguration_r9 * phys_chan_reconfig_r9_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_PhysicalChannelReconfiguration_r9_IEs *msg_ptr;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  msg_ptr = &phys_chan_reconfig_r9_ota->physicalChannelReconfiguration_r9;

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    new_DSCH_RNTI))
  {
     return FAILURE;
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    controlChannelDRXInfo_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    sps_Information_TDD128))
  {
    return FAILURE;
  }
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    cellDCHMeasOccasionInfo_TDD128))
  {
    return FAILURE;
  }

#ifndef FEATURE_WCDMA_DC_HSUPA
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    ul_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9: IE ul_SecondaryCellInfoFDD not supported.");
    return FAILURE;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */

  if(( RRC_MSG_COMMON_BITMASK_IE_PTR(phys_chan_reconfig_r9_ota,rrc_PhysicalChannelReconfiguration_r9,v950NonCriticalExtensions)) &&
    (RRC_MSG_COMMON_BITMASK_IE(phys_chan_reconfig_r9_ota->v950NonCriticalExtensions.physicalChannelReconfiguration_v950ext,rrc_PhysicalChannelReconfiguration_v950ext_IEs,
    secondaryCellMimoParameters)))
  {
    WRRC_MSG0_ERROR("REL9: secondaryCellMimoParameters not supported ");
    return FAILURE;
  }
   if(( RRC_MSG_COMMON_BITMASK_IE_PTR(phys_chan_reconfig_r9_ota,rrc_PhysicalChannelReconfiguration_r9,v950NonCriticalExtensions))&&
    (RRC_MSG_COMMON_BITMASK_IE(phys_chan_reconfig_r9_ota->v950NonCriticalExtensions,rrc_PhysicalChannelReconfiguration_v950NonCriticalExtensions,
     nonCriticalExtensions)))
  {
    WRRC_MSG0_ERROR("REL9: nonCriticalExtensions not supported ");
    return FAILURE;
  }

  /*We're processing a reconfiguration message now, so set the reconfig_in_progress flag accordingly.*/
  ordered_config.reconfig_in_progress = TRUE;

  rrcllc_init_before_msg_processing();

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,delayRestrictionFlag) !=0);
#endif

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
  activationTime)), msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_PCR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  status = rrcllc_update_urnti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    new_U_RNTI)), &msg_ptr->new_U_RNTI, msg_ptr->rrc_StateIndicator);

   rrcllc_update_crnti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
     new_C_RNTI)), msg_ptr->new_C_RNTI, msg_ptr->rrc_StateIndicator);

   if (SUCCESS == status)
   {
     status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
   }

  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,utran_DRX_CycleLengthCoeff)),
      &msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      frequencyInfo)),
      &msg_ptr->frequencyInfo, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      maxAllowedUL_TX_Power)), msg_ptr->maxAllowedUL_TX_Power);
  }


  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_DPCH_Info)),
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_CommonInformation)),
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_InformationPerRL_List)),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_DPCH_Info)),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_InformationPerRL_List)), &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_CommonInformation)),
      &msg_ptr->dl_CommonInformation, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_InformationPerRL_List)),
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    newPrimary_E_RNTI)), msg_ptr->newPrimary_E_RNTI, TRUE, msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    newSecondary_E_RNTI)), msg_ptr->newSecondary_E_RNTI, FALSE, msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r9((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_EDCH_Information)),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }


  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      new_H_RNTI)),
      &msg_ptr->new_H_RNTI, msg_ptr->rrc_StateIndicator);
  }

  if((SUCCESS == status) && (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,harqInfo)))
  {
    status = set_harq_information_r7(&msg_ptr->harqInfo);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r9(
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_HSPDSCH_Information)),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,hs_scch_LessInfo))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: hs_scch_LessInfo not supported ");
  }
#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r9(&msg_ptr->mimoParameters,
    msg_ptr->rrc_StateIndicator, (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    mimoParameters))) == FAILURE))
  {
     status = FAILURE;
  }
#else /*FEATURE_WCDMA_MIMO*/
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: mimoParameters not supported ");
  }
#endif /*FEATURE_WCDMA_MIMO*/

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params_r9(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  if(SUCCESS == status)
  {
    rrcllc_update_delay_restriction(
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,activationTime)),
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,delayRestrictionFlag)),
      msg_ptr->activationTime,msg_ptr->rrc_StateIndicator);
  }

  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
       (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dtx_drx_TimingInfo)),
       &msg_ptr->dtx_drx_Info,
       (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dtx_drx_Info)),
       msg_ptr->rrc_StateIndicator
       ) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRCRB_R9_MSG_IE_PRESENT(msg_ptr,new_H_RNTI));
  }
#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                        validate_directed_cell_info,
                                        FALSE,
                                        RRCRB_R9_MSG_IE_PRESENT(msg_ptr,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_DC_HSUPA
  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dc_hsupa_params(&msg_ptr->ul_SecondaryCellInfoFDD,msg_ptr->rrc_StateIndicator,
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_SecondaryCellInfoFDD)))== FAILURE)
      {
        status = FAILURE;
      }
  }

#endif /* FEATURE_WCDMA_DC_HSUPA */


  /* By now the status has been filled as per the processing.*/
  return (status);
}



/*====================================================================
FUNCTION: rrcllc_rb_release_ie_r9()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Release 8 Radio Bearer Release Message R8.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_release_ie_r9
(
  rrc_RadioBearerRelease_r9 * rb_release_r9_ota
)
{
  uecomdef_status_e_type                status = SUCCESS;
  rrc_DL_DeletedTransChInfoList_r7  * dl_trch_delete_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList_r9 * dl_trch_add_reconfig_ptr = NULL;
  ordered_config_type                         *tmp_config_ptr = NULL;
  rrc_RadioBearerRelease_r9_IEs      *msg_ptr;
  rrcrb_directed_cell_info_type          directed_cell_info;
  
  msg_ptr= &rb_release_r9_ota->radioBearerRelease_r9;
  

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    new_DSCH_RNTI))
  {
     return FAILURE;
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    controlChannelDRXInfo_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    sps_Information_TDD128))
  {
    return FAILURE;
  }
#ifndef FEATURE_WCDMA_DC_HSUPA
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    ul_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9:  IE ul_SecondaryCellInfoFDD not supported.");
    return FAILURE;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */
  if(( RRC_MSG_COMMON_BITMASK_IE_PTR(rb_release_r9_ota,rrc_RadioBearerRelease_r9,v950NonCriticalExtensions)) &&
      (RRC_MSG_COMMON_BITMASK_IE(rb_release_r9_ota->v950NonCriticalExtensions.radioBearerRelease_v950ext,rrc_RadioBearerRelease_v950ext_IEs,
      secondaryCellMimoParameters)))
    {
      WRRC_MSG0_ERROR("REL9: secondaryCellMimoParameters not supported ");
      return FAILURE;
    }
     if(( RRC_MSG_COMMON_BITMASK_IE_PTR(rb_release_r9_ota,rrc_RadioBearerRelease_r9,v950NonCriticalExtensions))&&
      (RRC_MSG_COMMON_BITMASK_IE(rb_release_r9_ota->v950NonCriticalExtensions,rrc_RadioBearerRelease_v950NonCriticalExtensions,
       v970NonCriticalExtensions)))
    {
      WRRC_MSG0_ERROR("REL9: nonCriticalExtensions not supported ");
      return FAILURE;
    }

  rrcllc_init_before_msg_processing();

  /*We're processing a reconfiguration message now, so set the reconfig_in_progress flag accordingly.*/
  ordered_config.reconfig_in_progress = TRUE;

  status = rrcllc_update_urnti_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    new_U_RNTI), &msg_ptr->new_U_RNTI, msg_ptr->rrc_StateIndicator);

  rrcllc_update_crnti_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    new_C_RNTI), msg_ptr->new_C_RNTI, msg_ptr->rrc_StateIndicator);

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_RBR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the UTRAN DRX cycle length coefficient */
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,utran_DRX_CycleLengthCoeff),
      &msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      frequencyInfo), &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/
 
  /* Call these functions ONLY in DCH state */
  if ((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    /* Here, update the transport channel info (only transport channel IDs 
    * and count) and rearrange the info by sorting transport channel list
    * based on TrCH ID. */

    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList,
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_deletedTransChInfoList),
      &msg_ptr->ul_deletedTransChInfoList);


    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
    would be updated later */
    if ( RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }

    if (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_DeletedTransChInfoList))
    {
      dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
    }

    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
    would be updated later */
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r9(dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
    }


  }

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  /* Don't process RAB to reconfig info */
  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_release_list(&msg_ptr->rb_InformationReleaseList);
  }

  if (SUCCESS == status)
  {
    /* Get the affected RB list if present */
    status = rrcllc_process_rb_info_reconfig_list_r8(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      rb_InformationReconfigList),
      &msg_ptr->rb_InformationReconfigList);
  }

  if (SUCCESS == status)
  {
    /* Get the affected RB list if present */
    status = rrcllc_process_rb_info_affected_list_r8(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      rb_InformationAffectedList),
      &msg_ptr->rb_InformationAffectedList);
  }

  if (SUCCESS == status) 
  {
    status = rrcllc_validate_rb_mapping_info();
  }

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/

  /* Get the Common Uplink Transport Channel information */
  if (SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_CommonTransChInfo),
      &msg_ptr->ul_CommonTransChInfo);
  }

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
  * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
  * (for Cell FACH state), this check for state needs to be re-examined */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
#ifdef FEATURE_VOC_AMR_WB
    ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/

    status = rrcllc_store_ul_add_reconf_trch_info_list_r8(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList);

    /* Calculate the UL TFCS */
    if((SUCCESS == status) && RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_CommonTransChInfo))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
	  	rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL9) == FAILURE)
        {
          status = FAILURE;
        }
      }
      if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(
	  	msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          status = FAILURE;
        }
      }
    }
  }
   /* If state is Cell_DCH */

   /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if (SUCCESS == status)
  {
    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
        ordered_config_ptr->rrc_state_indicator);
    }
  }

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/

  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) && RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    dl_CommonTransChInfo))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo, ordered_config_ptr->rrc_state_indicator);
  }

  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r9(
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_AddReconfTransChInfoList),
      &msg_ptr->dl_AddReconfTransChInfoList, &msg_ptr->ul_AddReconfTransChInfoList);
  } /* If state is Cell_DCH */      

  /* The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  /*When UE goes from non-DCH state to DCH state, we make sure that
  UE has the following Physical channel IEs
  1. ul-DPCH-Info
  2. dl-CommonInformation
  3. dl-InformationPerRL-List
  Think of the cases when even though these IEs are present but the necessary info in these IEs is missing.
  So may bee we can add that check also. See the Spec reference for this check. */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_DPCH_Info),
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_CommonInformation),
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if(SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_DPCH_Info), &msg_ptr->ul_DPCH_Info, 
      msg_ptr->rrc_StateIndicator);
  }

  if(SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_InformationPerRL_List),
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r8(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_CommonInformation),
      &msg_ptr->dl_CommonInformation, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_info_per_rl_list_r8(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_InformationPerRL_List),
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    newPrimary_E_RNTI), msg_ptr->newPrimary_E_RNTI,  TRUE, msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    newSecondary_E_RNTI), msg_ptr->newSecondary_E_RNTI, FALSE, msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r9(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /*Call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
     new_H_RNTI), &msg_ptr->new_H_RNTI, msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r9(
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,frequencyInfo))
      && (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r9(&msg_ptr->mimoParameters, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    mimoParameters))) == FAILURE))
  {
    status = FAILURE;
  }
#else /*FEATURE_WCDMA_MIMO*/
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: mimoParameters not supported ");
  }
#endif /*FEATURE_WCDMA_MIMO*/
 
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,hs_scch_LessInfo))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: hs_scch_LessInfo not supported ");
  }
#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params_r9(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(&msg_ptr->rb_InformationReleaseList) == FAILURE)
    {
      return FAILURE;
    }
  }
  if ((SUCCESS == status) && (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /*Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
     (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dtx_drx_TimingInfo)),
         &msg_ptr->dtx_drx_Info,
     (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dtx_drx_Info)),
         msg_ptr->rrc_StateIndicator
    ) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,new_H_RNTI));
  }
#ifdef FEATURE_WCDMA_HS_RACH
  if(status == SUCCESS)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                      validate_directed_cell_info,
                                      FALSE,
                                      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,newPrimary_E_RNTI));
  }
#endif  /*FEATURE_WCDMA_HS_RACH*/
#endif  /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_DC_HSUPA
    if(status == SUCCESS)
    {
      if(rrcllcpcie_process_dc_hsupa_params(&msg_ptr->ul_SecondaryCellInfoFDD,msg_ptr->rrc_StateIndicator,
        (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_SecondaryCellInfoFDD)))== FAILURE)
        {
          status = FAILURE;
        }
    }
  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* By now the status has been filled as per the processing.*/
  return (status);
}


/*====================================================================
FUNCTION: rrcllc_trch_reconfig_ie_r9()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Release 9 Transport Channel Reconfiguration Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_trch_reconfig_ie_r9
(
  rrc_TransportChannelReconfiguration_r9 * trch_reconfig_r9_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_DL_AddReconfTransChInfoList_r9 * dl_trch_add_reconfig_ptr = NULL;
  ordered_config_type              *tmp_config_ptr = NULL;
  rrc_TransportChannelReconfiguration_r9_IEs *msg_ptr;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  msg_ptr = &trch_reconfig_r9_ota->transportChannelReconfiguration_r9;

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    controlChannelDRXInfo_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    sps_Information_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    new_DSCH_RNTI))
  {
     return FAILURE;
  }

   if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    cellDCHMeasOccasionInfo_TDD128))
  {
    return FAILURE;
  }
#ifndef FEATURE_WCDMA_DC_HSUPA
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    ul_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9: IE ul_SecondaryCellInfoFDD not supported.");
    return FAILURE;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */
  if(( RRC_MSG_COMMON_BITMASK_IE_PTR(trch_reconfig_r9_ota,rrc_TransportChannelReconfiguration_r9,v950NonCriticalExtensions)) &&
    (RRC_MSG_COMMON_BITMASK_IE(trch_reconfig_r9_ota->v950NonCriticalExtensions.transportChannelReconfiguration_v950ext,rrc_TransportChannelReconfiguration_v950ext_IEs,
    secondaryCellMimoParameters)))
  {
    WRRC_MSG0_ERROR("REL9: secondaryCellMimoParameters not supported ");
    return FAILURE;
  }
   if(( RRC_MSG_COMMON_BITMASK_IE_PTR(trch_reconfig_r9_ota,rrc_TransportChannelReconfiguration_r9,v950NonCriticalExtensions))&&
    (RRC_MSG_COMMON_BITMASK_IE(trch_reconfig_r9_ota->v950NonCriticalExtensions,rrc_TransportChannelReconfiguration_v950NonCriticalExtensions,
     v9c0NonCriticalExtensions)))
  {
    WRRC_MSG0_ERROR("REL9: nonCriticalExtensions not supported ");
    return FAILURE;
  }

  /* We're processing a reconfiguration message now, so set the reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  rrcllc_init_before_msg_processing();

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
   /* Set the delay restriction flag if the IE is present*/
    rrcdata_misc_info.rrc_delay_restriction_flag
     = (RRCRB_R9_MSG_IE_PRESENT (msg_ptr,delayRestrictionFlag) !=0);
#endif
 
  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
    activationTime),
    msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_TCR);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  status = rrcllc_update_urnti_in_oc(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
    new_U_RNTI),
    &msg_ptr->new_U_RNTI, msg_ptr->rrc_StateIndicator);

  rrcllc_update_crnti_in_oc(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
    new_C_RNTI),
    msg_ptr->new_C_RNTI, msg_ptr->rrc_StateIndicator);

  if(SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }

  if(SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
      RRCRB_R9_MSG_IE_PRESENT (msg_ptr,utran_DRX_CycleLengthCoeff), &msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if(SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
      frequencyInfo), &msg_ptr->frequencyInfo, msg_ptr->rrc_StateIndicator);
  }

  if(SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
      maxAllowedUL_TX_Power), msg_ptr->maxAllowedUL_TX_Power);
  }

  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
    * and count) and rearrange the info by sorting transport channel list
    * based on TrCH ID. */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
      ul_AddReconfTransChInfoList), &msg_ptr->ul_AddReconfTransChInfoList, FALSE, NULL);
  
  
    if( RRCRB_R9_MSG_IE_PRESENT (msg_ptr,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }
  
    if(SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r9(dl_trch_add_reconfig_ptr, NULL);
    }


  }

  /* Get the Common Uplink Transport Channel information */
  if(SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
      ul_CommonTransChInfo),
      &msg_ptr->ul_CommonTransChInfo);
  }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_ul_add_reconf_trch_info_list_r8(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
      ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList);
  
    /* Calculate the UL TFCS */
    if((SUCCESS == status) && (RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
      ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
      rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL8) == FAILURE)
        {
          status = FAILURE;
        }
        if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(
                  msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
        {
          if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
          {
            status = FAILURE;
          }
        }
      }
    } 
  } /* If state is Cell_DCH */
  
  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  /* Fill in the RLC size restriction information for MAC */
  if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
  {
    if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, ordered_config_ptr->rrc_state_indicator)
        == FAILURE)
    {
      status = FAILURE;
    }
  }

  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/

  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) && (RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
    dl_CommonTransChInfo)))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo, &msg_ptr->ul_CommonTransChInfo,
      ordered_config_ptr->rrc_state_indicator);
  }

  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r9(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
      dl_AddReconfTransChInfoList),
      &msg_ptr->dl_AddReconfTransChInfoList, &msg_ptr->ul_AddReconfTransChInfoList);
  } /* If state is Cell_DCH */   

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch( 
      RRCRB_R9_MSG_IE_PRESENT (msg_ptr,ul_DPCH_Info),
      RRCRB_R9_MSG_IE_PRESENT (msg_ptr,dl_CommonInformation), 
      RRCRB_R9_MSG_IE_PRESENT (msg_ptr,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
      ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8(
      RRCRB_R9_MSG_IE_PRESENT (msg_ptr,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r8(
      RRCRB_R9_MSG_IE_PRESENT (msg_ptr,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r8(
      RRCRB_R9_MSG_IE_PRESENT (msg_ptr,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
    newPrimary_E_RNTI), msg_ptr->newPrimary_E_RNTI,  TRUE, msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
    newSecondary_E_RNTI), msg_ptr->newSecondary_E_RNTI, FALSE, msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information*/
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r9(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
      ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status)&&rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,
      new_H_RNTI), &msg_ptr->new_H_RNTI, msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r9(
      RRCRB_R9_MSG_IE_PRESENT (msg_ptr,dl_HSPDSCH_Information),  
      &msg_ptr->dl_HSPDSCH_Information,
      (( RRCRB_R9_MSG_IE_PRESENT (msg_ptr,frequencyInfo) ) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r9(&msg_ptr->mimoParameters, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    mimoParameters))) == FAILURE))
  {
    status = FAILURE;
  } 
#else /*FEATURE_WCDMA_MIMO*/
  if(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,mimoParameters)) 
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: mimoParameters not supported ");
  }
#endif /*FEATURE_WCDMA_MIMO*/


  if(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,hs_scch_LessInfo)) 
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: hs_scch_LessInfo not supported ");
  }

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params_r9(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/
  
  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }
  
  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(SUCCESS == status)
  {
    if(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,delayRestrictionFlag))
    {
      if(( RRCRB_R9_MSG_IE_PRESENT (msg_ptr,dl_AddReconfTransChInfoList))
        ||(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,ul_AddReconfTransChInfoList))) 
      {
        WRRC_MSG0_ERROR("REL9: Trch IE touched bitmask , so Delay restriction cannot be applied");
      }
      else
      {
        rrcllc_update_delay_restriction(RRCRB_R9_MSG_IE_PRESENT (msg_ptr,activationTime),
          RRCRB_R9_MSG_IE_PRESENT (msg_ptr,delayRestrictionFlag),
          msg_ptr->activationTime,msg_ptr->rrc_StateIndicator);
      }
    }
  }
  /* By now the status has been filled as per the processing.*/

  if (SUCCESS == status)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
    (RRCRB_R9_MSG_IE_PRESENT (msg_ptr,dtx_drx_TimingInfo)),
         &msg_ptr->dtx_drx_Info,
    (RRCRB_R9_MSG_IE_PRESENT (msg_ptr,dtx_drx_Info)),
         msg_ptr->rrc_StateIndicator
    ) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
    validate_directed_cell_info,FALSE,
    RRCRB_R9_MSG_IE_PRESENT(msg_ptr,new_H_RNTI));
  }


#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
    validate_directed_cell_info,FALSE,
    RRCRB_R9_MSG_IE_PRESENT(msg_ptr,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/


#ifdef FEATURE_WCDMA_DC_HSUPA
    if(status == SUCCESS)
    {
      if(rrcllcpcie_process_dc_hsupa_params(&msg_ptr->ul_SecondaryCellInfoFDD,msg_ptr->rrc_StateIndicator,
        (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_SecondaryCellInfoFDD)))== FAILURE)
        {
          status = FAILURE;
        }
    }
  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  return (status);
}



/*====================================================================
FUNCTION: rrcllc_cell_update_confirm_ie_r9()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Cell Update Confirm Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_cell_update_confirm_ie_r9
(
  uint32 dl_sdu_num,
  void * cell_update_r9_msg_ptr

)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_DL_DeletedTransChInfoList_r7   * dl_trch_delete_ptr = NULL;
  rrc_DL_AddReconfTransChInfoList_r9 * dl_trch_add_reconfig_ptr = NULL;
  ordered_config_type              *tmp_config_ptr = NULL;
  rrc_CellUpdateConfirm_r9_IEs *msg_ptr = NULL;
  rrc_CellUpdateConfirm_r9 *msg_ptr_r9 = NULL;
  rrc_CellUpdateConfirm_CCCH_r9 *msg_ptr_ccch_r9 = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;
  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
 
  if(rrc_DL_CCCH_Message_PDU == dl_sdu_num)
  {
    rrc_DL_CCCH_Message *ccch_ptr= NULL;
    ccch_ptr=  (rrc_DL_CCCH_Message *)cell_update_r9_msg_ptr;
    msg_ptr =&ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
        criticalExtensions.u.criticalExtensions.u.
        criticalExtensions.u.criticalExtensions.u.criticalExtensions.
        u.later_r8_criticalExtensions.u.r9.cellUpdateConfirm_r9;
    msg_ptr_ccch_r9 = &ccch_ptr->message.u.cellUpdateConfirm.u.later_than_r3.
        criticalExtensions.u.criticalExtensions.u.
        criticalExtensions.u.criticalExtensions.u.criticalExtensions.
        u.later_r8_criticalExtensions.u.r9;
  }
  else
  {
    rrc_DL_DCCH_Message *dcch_ptr= NULL;

    dcch_ptr = (rrc_DL_DCCH_Message *)cell_update_r9_msg_ptr;
 
    msg_ptr =&dcch_ptr->message.u.cellUpdateConfirm.u.
            later_than_r3.criticalExtensions.u.criticalExtensions.
            u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
            u.later_r8_criticalExtensions.u.r9.cellUpdateConfirm_r9;
    msg_ptr_r9 =&dcch_ptr->message.u.cellUpdateConfirm.u.
            later_than_r3.criticalExtensions.u.criticalExtensions.
            u.criticalExtensions.u.criticalExtensions.u.criticalExtensions.
            u.later_r8_criticalExtensions.u.r9;

  }
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    new_DSCH_RNTI))
  {
    return FAILURE;
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    controlChannelDRXInfo_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    sps_Information_TDD128))
  {
    return FAILURE;
  }
#ifndef FEATURE_WCDMA_DC_HSUPA
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    ul_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9:  IE ul_SecondaryCellInfoFDD not supported.");
    return FAILURE;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    cellDCHMeasOccasionInfo_TDD128))
  {
    return FAILURE;
  }

  if(rrc_DL_CCCH_Message_PDU == dl_sdu_num)
  {
     if( RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr_ccch_r9,rrc_CellUpdateConfirm_CCCH_r9,nonCriticalExtensions))
    {
      WRRC_MSG0_ERROR("REL9: nonCriticalExtensions not supported ");
      return FAILURE;
    }
  }
  else
  {
    if(( RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr_r9,rrc_CellUpdateConfirm_r9,v950NonCriticalExtensions)) &&
      (RRC_MSG_COMMON_BITMASK_IE(msg_ptr_r9->v950NonCriticalExtensions.cellUpdateConfirm_v950ext,rrc_CellUpdateConfirm_v950ext_IEs,
      secondaryCellMimoParameters)))
    {
      WRRC_MSG0_ERROR("REL9: secondaryCellMimoParameters not supported ");
      return FAILURE;
    }
     if(( RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr_r9,rrc_CellUpdateConfirm_r9,v950NonCriticalExtensions))&&
      (RRC_MSG_COMMON_BITMASK_IE(msg_ptr_r9->v950NonCriticalExtensions,rrc_CellUpdateConfirm_v950NonCriticalExtensions,
       v9c0NonCriticalExtensions)))
    {
      WRRC_MSG0_ERROR("REL9: nonCriticalExtensions not supported ");
      return FAILURE;
    }
  
  }
  /* We're processing a reconfiguration message now, so set the
  reconfig_in_progress flag accordingly. */
  ordered_config.reconfig_in_progress = TRUE;

  rrcllc_init_before_msg_processing();
                                            
   /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    activationTime), msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, RRC_PROCEDURE_CU);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
   if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
   {
     return FAILURE;
   }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  status = rrcllc_update_urnti_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    new_U_RNTI), &msg_ptr->new_U_RNTI, msg_ptr->rrc_StateIndicator);

  rrcllc_update_crnti_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    new_C_RNTI), msg_ptr->new_C_RNTI, msg_ptr->rrc_StateIndicator);

  if(SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }
  
  if(SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,utran_DRX_CycleLengthCoeff)),
      &msg_ptr->utran_DRX_CycleLengthCoeff);
  }
  
  if(SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      frequencyInfo),
     &msg_ptr->frequencyInfo, msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      maxAllowedUL_TX_Power), msg_ptr->maxAllowedUL_TX_Power);
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,rab_InformationSetup))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: rab_InformationSetup not supported ");
  }
    
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
     * and count) and rearrange the info by sorting transport channel list
     * based on TrCH ID.
     */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_AddReconfTransChInfoList),
      &msg_ptr->ul_AddReconfTransChInfoList,
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_deletedTransChInfoList),
      &msg_ptr->ul_deletedTransChInfoList);


    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
      would be updated later */
    if (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }

    if (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_DeletedTransChInfoList))
    {
      dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
    }

    /*Create a new DFLOW index and update the MAC and RRC structures. 
      Queue Info would be updated later */
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r9(
        dl_trch_add_reconfig_ptr, dl_trch_delete_ptr);
    }


  }

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if(SUCCESS == status && (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    rb_InformationReleaseList)))
  {
    status = rrcllc_process_rb_info_release_list(&msg_ptr->rb_InformationReleaseList);
  }

  /* Get the RB reconfiguration list */
  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_reconfig_list_r8(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      rb_InformationReconfigList),
      &msg_ptr->rb_InformationReconfigList);
  }

  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_affected_list_r8(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      rb_InformationAffectedList),
      &msg_ptr->rb_InformationAffectedList);
  }

  if (SUCCESS == status) 
  {
    status = rrcllc_validate_rb_mapping_info();
  }

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/
     
  /* Get the Common Uplink Transport Channel information */
  if (SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6(
       RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_CommonTransChInfo),
      &msg_ptr->ul_CommonTransChInfo);
  }

  /* Do the processing for Uplink added/reconfigured TrCH, Compute
   * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
   * (for Cell FACH state), this check for state needs to be re-examined */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_ul_add_reconf_trch_info_list_r8(
     RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_AddReconfTransChInfoList),
     &msg_ptr->ul_AddReconfTransChInfoList);
    
    /* Calculate the UL TFCS */
    if((SUCCESS == status) &&
       ( RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_CommonTransChInfo) ))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
      rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL8) == FAILURE)
        { 
          status = FAILURE;
        }
      }
      if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(
      msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          status = FAILURE;
        }
      }
    }
  }

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if (SUCCESS == status)
  {
    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
        ordered_config_ptr->rrc_state_indicator);
    }
  }

  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) &&
     (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_CommonInformation)))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo, ordered_config_ptr->rrc_state_indicator);
  }

  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r9(
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_AddReconfTransChInfoList), 
      &msg_ptr->dl_AddReconfTransChInfoList, &msg_ptr->ul_AddReconfTransChInfoList);
  }

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,pdcp_ROHC_TargetMode) )
  {
    WRRC_MSG0_ERROR("REL9: pdcp_ROHC_TargetMode IE not supported yet!");
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_DPCH_Info),
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_CommonInformation),
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_InformationPerRL_List), 
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_DPCH_Info), 
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_InformationPerRL_List), &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r8(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r8(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_InformationPerRL_List),  
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    newPrimary_E_RNTI), msg_ptr->newPrimary_E_RNTI, TRUE, msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    newSecondary_E_RNTI), msg_ptr->newSecondary_E_RNTI, FALSE, msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r9(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      new_H_RNTI), &msg_ptr->new_H_RNTI, msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r9(
      RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      (( RRCRB_R9_MSG_IE_PRESENT(msg_ptr,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }


#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r9(&msg_ptr->mimoParameters,
    msg_ptr->rrc_StateIndicator, RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    mimoParameters)) == FAILURE))
  {
    status = FAILURE;
  }
  
#else /*FEATURE_WCDMA_MIMO*/
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: mimoParameters not supported ");
  }
#endif /*FEATURE_WCDMA_MIMO*/

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params_r9(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(&msg_ptr->rb_InformationReleaseList) == FAILURE)
    {
      status = FAILURE;
    }
  }
   
  if ((SUCCESS == status) && (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
   (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dtx_drx_TimingInfo)),
       &msg_ptr->dtx_drx_Info,
   (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dtx_drx_Info)),
       msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
    validate_directed_cell_info,FALSE,
    RRCRB_R9_MSG_IE_PRESENT(msg_ptr,new_H_RNTI));
  }


#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
    validate_directed_cell_info,FALSE,
    RRCRB_R9_MSG_IE_PRESENT(msg_ptr,newPrimary_E_RNTI));

  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/


#ifdef FEATURE_WCDMA_DC_HSUPA
    if(status == SUCCESS)
    {
      if(rrcllcpcie_process_dc_hsupa_params(&msg_ptr->ul_SecondaryCellInfoFDD,msg_ptr->rrc_StateIndicator,
        (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_SecondaryCellInfoFDD)))== FAILURE)
        {
          status = FAILURE;
        }
    }
  
#endif /* FEATURE_WCDMA_DC_HSUPA */


  /* By now the status has been filled as per the processing.*/
  return (status);
}



/*====================================================================
FUNCTION: rrcllc_rb_setup_ie_r9()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Radio Bearer Setup Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rb_setup_ie_r9
(
  rrc_RadioBearerSetup_r9 * rb_setup_r9_ota
)
{
  uecomdef_status_e_type                    status = SUCCESS;
  rrc_RadioBearerSetup_r9_IEs             *msg_ptr;
  rrc_DL_AddReconfTransChInfoList_r9  * dl_trch_add_reconfig_ptr = NULL;
  rrc_DL_DeletedTransChInfoList_r7     * dl_trch_delete_ptr = NULL;
  ordered_config_type                          *tmp_config_ptr = NULL;
  rrcrb_directed_cell_info_type          directed_cell_info;
  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));

  msg_ptr = &rb_setup_r9_ota->radioBearerSetup_r9;

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    new_DSCH_RNTI))
  {
     return FAILURE;
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    controlChannelDRXInfo_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    sps_Information_TDD128))
  {
    return FAILURE;
  }

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    cellDCHMeasOccasionInfo_TDD128))
  {
    return FAILURE;
  }
#ifndef FEATURE_WCDMA_DC_HSUPA
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    ul_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9: IE ul_SecondaryCellInfoFDD not supported.");
    return FAILURE;
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */
  if(( RRC_MSG_COMMON_BITMASK_IE_PTR(rb_setup_r9_ota,rrc_RadioBearerSetup_r9,v950NonCriticalExtensions)) &&
    (RRC_MSG_COMMON_BITMASK_IE(rb_setup_r9_ota->v950NonCriticalExtensions.radioBearerSetup_v950ext,rrc_RadioBearerSetup_v950ext_IEs,
    secondaryCellMimoParameters)))
  {
    WRRC_MSG0_ERROR("REL9: secondaryCellMimoParameters not supported ");
    return FAILURE;
  }
   if(( RRC_MSG_COMMON_BITMASK_IE_PTR(rb_setup_r9_ota,rrc_RadioBearerSetup_r9,v950NonCriticalExtensions))&&
    (RRC_MSG_COMMON_BITMASK_IE(rb_setup_r9_ota->v950NonCriticalExtensions,rrc_RadioBearerSetup_v950NonCriticalExtensions,
     v9c0NonCriticalExtensions)))
  {
    WRRC_MSG0_ERROR("REL9: nonCriticalExtensions not supported ");
    return FAILURE;
  }

  /* We're processing a reconfiguration message now, so set the reconfig_in_progress flag accordingly.*/
  ordered_config.reconfig_in_progress = TRUE;
  
  rrcllc_init_before_msg_processing();

  if(msg_ptr->m.sr_vcc_InfoPresent)
  {
    WRRC_MSG0_HIGH("REL9: IE sr-vcc-Info not supported yet!");
    return FAILURE;
  }

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    activationTime)), msg_ptr->activationTime, msg_ptr->rrc_StateIndicator, 
    RRC_PROCEDURE_RBE);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
  /*Update U-RNTI in OC for MAC and also update SCCPCH Info from SIB5/6*/
  status = rrcllc_update_urnti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    new_U_RNTI)), &msg_ptr->new_U_RNTI,
    msg_ptr->rrc_StateIndicator);
 
  /*Update C-RNTI in OC for MAC*/
  rrcllc_update_crnti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    new_C_RNTI)), msg_ptr->new_C_RNTI, 
    msg_ptr->rrc_StateIndicator);

  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }
  
  if (SUCCESS == status)
  {
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    utran_DRX_CycleLengthCoeff)),
    &msg_ptr->utran_DRX_CycleLengthCoeff);
  }

  if (SUCCESS == status)
  {
    /* Get the frequency info */  
    status = rrcllc_update_frequency_info_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      frequencyInfo)), &msg_ptr->frequencyInfo,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      maxAllowedUL_TX_Power)),
      msg_ptr->maxAllowedUL_TX_Power);
  }

  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/

  /* Call these functions ONLY in DCH state */
  if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
  {
    /* Here, update the transport channel info (only transport channel IDs 
    * and count) and rearrange the info by sorting transport channel list
    * based on TrCH ID. */
    status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_AddReconfTransChInfoList)),
      &msg_ptr->ul_AddReconfTransChInfoList,
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_deletedTransChInfoList)),
      &msg_ptr->ul_deletedTransChInfoList);

  
    if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_AddReconfTransChInfoList))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->dl_AddReconfTransChInfoList;
    }
  
    if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_DeletedTransChInfoList))
    {
      dl_trch_delete_ptr = &msg_ptr->dl_DeletedTransChInfoList;
    }
  
    /* Create a new DFLOW index and update the MAC and RRC structures. Queue Info
    would be updated later */
    if (SUCCESS == status)
    {
      status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r9(dl_trch_add_reconfig_ptr, 
                    dl_trch_delete_ptr);
    }


  }
  
   /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  /* Get the SRB setup list if present */
  if (SUCCESS == status)
  {
    status =  rrcllc_process_srb_info_setup_list_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      srb_InformationSetupList)), 
      &msg_ptr->srb_InformationSetupList);
  }
  
  /* Get the RAB setup list if present */
  if (SUCCESS == status)
  {
    status = rrcllc_process_rab_info_setup_list_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      rab_InformationSetupList)),
      &msg_ptr->rab_InformationSetupList);
  }

  /* Get the RB reconfiguration list */
  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_reconfig_list_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      rb_InformationReconfigList)),
      &msg_ptr->rb_InformationReconfigList);
  }

  /* Get the RB Affected list */  
  if (SUCCESS == status)
  {
    status = rrcllc_process_rb_info_affected_list_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      rb_InformationAffectedList)),
      &msg_ptr->rb_InformationAffectedList);
  }
  
  if (SUCCESS == status) 
  {
    status = rrcllc_validate_rb_mapping_info();
  }
  
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  /* Get the Common Uplink Transport Channel information */
  if (SUCCESS == status)
  {
    status = rrcllc_process_ul_common_trch_info_r5_r6((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_CommonTransChInfo)),
      &msg_ptr->ul_CommonTransChInfo);
  }
  
  /* Do the processing for Uplink added/reconfigured TrCH, Compute
  * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
  * (for Cell FACH state), this check for state needs to be re-examined */
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
#ifdef FEATURE_VOC_AMR_WB
      ordered_config_ptr->ul_tfcs.orderd_codec_mode = rrc_ota_codec_mode_status;
#endif/*FEATURE_VOC_AMR_WB*/

    status = rrcllc_store_ul_add_reconf_trch_info_list_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
        ul_AddReconfTransChInfoList)),
        &msg_ptr->ul_AddReconfTransChInfoList);
  
    /* Calculate the UL TFCS */
    if((SUCCESS == status) && (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_CommonTransChInfo)))
    {
      compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);

      if(RRC_MSG_COMMON_BITMASK_IE(msg_ptr->ul_CommonTransChInfo,
       rrc_UL_CommonTransChInfo_r4,tfc_Subset))
      {
        if(rrcllc_update_oc_with_tfc_subset(&msg_ptr->ul_CommonTransChInfo, MSG_REL8) == FAILURE)
        {
          return FAILURE;
        }
      }

      /*RRC_GKG: Processing of TFC subset List is under UL CommonTransChList.*/
      if((status == SUCCESS ) && (RRC_MSG_COMMON_BITMASK_IE_TYPE2(
      msg_ptr->ul_CommonTransChInfo,tfc_SubsetList)))
      {
        if(rrcllc_update_oc_with_tfc_subset_list(&msg_ptr->ul_CommonTransChInfo) == FAILURE)
        {
          status = FAILURE;
        }
      }
    }
  }   /* If state is Cell_DCH */

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);

  if(SUCCESS == status)
  {
    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
      !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
      msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      status = rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
        ordered_config_ptr->rrc_state_indicator);
    }
  }

  /* For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

  /* Get the Common Downlink Transport Channel information */
  if((SUCCESS == status) && (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    dl_CommonTransChInfo)))
  {
    status = get_dl_info_common_for_all_trch_r5(&msg_ptr->dl_CommonTransChInfo,
      &msg_ptr->ul_CommonTransChInfo, ordered_config_ptr->rrc_state_indicator);
  }
  
  if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
  {
    status = rrcllc_store_dl_add_reconf_trch_info_list_r9(
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_AddReconfTransChInfoList)), &msg_ptr->dl_AddReconfTransChInfoList,
      &msg_ptr->ul_AddReconfTransChInfoList);
  }
  
   /* The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr(tmp_config_ptr);

  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,pdcp_ROHC_TargetMode))
  {
    WRRC_MSG0_ERROR("REL9: pdcp_ROHC_TargetMode IE not supported yet");
    /*RRC_GKG: From Spec, see whether we need to ignore or return Failure*/
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_DPCH_Info)),
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_CommonInformation)),
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_InformationPerRL_List)),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_dpch_info_r7((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      ul_DPCH_Info)),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_InformationPerRL_List)), &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_common_info_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_CommonInformation)), &msg_ptr->dl_CommonInformation,
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* update R99, HS and EUL related variables */
    status = rrcllcpcie_process_dl_info_per_rl_list_r8((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      dl_InformationPerRL_List)), 
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    newPrimary_E_RNTI)), msg_ptr->newPrimary_E_RNTI, TRUE,
    msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    newSecondary_E_RNTI)), msg_ptr->newSecondary_E_RNTI, FALSE,
    msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r9(
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_EDCH_Information)),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
    update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable*/
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
      new_H_RNTI)), &msg_ptr->new_H_RNTI, msg_ptr->rrc_StateIndicator);
  }

  /* Get HSDPA Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r9(
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_HSPDSCH_Information)),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRCRB_R9_MSG_IE_PRESENT(msg_ptr,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }


#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r9(&msg_ptr->mimoParameters, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    mimoParameters))) == FAILURE))
  {
    status = FAILURE;
  }

#else /*FEATURE_WCDMA_MIMO*/
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,mimoParameters))
  {
    WRRC_MSG0_ERROR("REL9: mimoParameters IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_MIMO*/


#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params_r9(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator, (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,
    dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }

#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/


  if(RRCRB_R9_MSG_IE_PRESENT(msg_ptr,hs_scch_LessInfo))
  {
    WRRC_MSG0_ERROR("REL8: hs_scch_LessInfo IE not supported yet!");
    status = FAILURE;
  }
  
  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
        (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dtx_drx_TimingInfo)),
        &msg_ptr->dtx_drx_Info,
        (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,dtx_drx_Info)),
        msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
    validate_directed_cell_info,FALSE,
    RRCRB_R9_MSG_IE_PRESENT(msg_ptr,new_H_RNTI));
  }
#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
     validate_directed_cell_info,FALSE,
     RRCRB_R9_MSG_IE_PRESENT(msg_ptr,newPrimary_E_RNTI));
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/


#ifdef FEATURE_WCDMA_DC_HSUPA
    if(status == SUCCESS)
    {
      if(rrcllcpcie_process_dc_hsupa_params(&msg_ptr->ul_SecondaryCellInfoFDD,msg_ptr->rrc_StateIndicator,
        (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_SecondaryCellInfoFDD)))== FAILURE)
        {
          status = FAILURE;
        }
    }
  
#endif /* FEATURE_WCDMA_DC_HSUPA */

  /* By now the status has been filled as per the processing.*/
  return (status);
}



/*====================================================================
FUNCTION: rrcllc_rrc_conn_setup_ie_r9()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in R8 RRC Connection Setup Message.

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_rrc_conn_setup_ie_r9
(
  rrc_RRCConnectionSetup_r9 *rrc_conn_setup_r9_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_DL_AddReconfTransChInfoList_r9 * dl_trch_add_reconfig_ptr = NULL;
  ordered_config_type              *tmp_config_ptr = NULL;
  rrc_RRCConnectionSetup_r9_IEs *msg_ptr;
  rrcrb_directed_cell_info_type          directed_cell_info;

  memset(&directed_cell_info, 0, sizeof(rrcrb_directed_cell_info_type));
  msg_ptr = &rrc_conn_setup_r9_ota->rrcConnectionSetup_r9;

  /* We do not handle Cell_PCH and URA_PCH states at present */
  if((msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_PCH) || (msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_ura_PCH))
  {
    WRRC_MSG0_ERROR("CELL_PCH or URA-PCH state transition invalid!");
    return FAILURE;
    }
    
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r9_IEs,sps_Information_TDD128))
  {
    return FAILURE;
  }

  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r9_IEs,multi_frequencyInfo))
  {
    return FAILURE;
  }
  if(( RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_conn_setup_r9_ota,rrc_RRCConnectionSetup_r9,v950NonCriticalExtensions)) &&
    (RRC_MSG_COMMON_BITMASK_IE(rrc_conn_setup_r9_ota->v950NonCriticalExtensions.rrcConnectionSetup_v950ext,rrc_RRCConnectionSetup_v950ext_IEs,
    secondaryCellMimoParameters)))
  {
    WRRC_MSG0_ERROR("REL9: secondaryCellMimoParameters not supported ");
    return FAILURE;
  }
   if(( RRC_MSG_COMMON_BITMASK_IE_PTR(rrc_conn_setup_r9_ota,rrc_RRCConnectionSetup_r9,v950NonCriticalExtensions))&&
    (RRC_MSG_COMMON_BITMASK_IE(rrc_conn_setup_r9_ota->v950NonCriticalExtensions,rrc_RRCConnectionSetup_v950NonCriticalExtensions,
     nonCriticalExtensions)))
  {
    WRRC_MSG0_ERROR("REL9: nonCriticalExtensions not supported ");
    return FAILURE;
  }


  /*We're processing a reconfiguration message now, so set the reconfig_in_progress flag accordingly.*/
  ordered_config.reconfig_in_progress = TRUE;

  /*RRC_GKG: Notice that RRC Conn Setup does have ACT Time.*/
  /* Assume that the default is now, i.e. the current SFN */
  MSG_MED("Activation Time is Now!",0,0,0);

  ordered_config_ptr->activation_time = RRCLLC_ACTIVATION_TIME_NOW;
  ordered_config_ptr->act_time_type   = L1_ACTIVATION_TIME_NONE;

  rrcllc_init_before_msg_processing();

#ifdef FEATURE_VOC_AMR_WB
  ordered_config_ptr->ul_tfcs.orderd_codec_mode = MVS_MODE_NONE;
#endif/*FEATURE_VOC_AMR_WB*/

  if (SUCCESS == status)
  {
    /* new-U-RNTI is mandatory in RRC Connection Setup message */
    status = rrcllc_update_urnti_in_oc(TRUE, &msg_ptr->new_U_RNTI, msg_ptr->rrc_StateIndicator);  
  }

  /* Get the C-RNTI */
  rrcllc_update_crnti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r9_IEs,new_c_RNTI),
    msg_ptr->new_c_RNTI, msg_ptr->rrc_StateIndicator);

  if (SUCCESS == status)
  {
    status = rrcllc_update_state_indicator_in_oc(msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the UTRAN DRX cycle length coefficient */
    /*Since Coef1 is always present in RRC connection setup*/
    status = rrcllc_update_utran_drx_cycle_length_coeff_in_oc_r7(TRUE, &msg_ptr->utran_DRX_CycleLengthCoeff);
  }  

  /* use TOC ptr if not received in DCH state */
  tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();

#ifdef FEATURE_WCDMA_DEFAULT_CFG_CELLFACH
  if ((SUCCESS == status) && (msg_ptr->m.defaultConfigForCellFACHPresent))
  {
    memset(default_cfg_ota_mapping,0,NUM_SRB_DC_CELLFACH);
    memset(default_cfg_recfg_list_srb_present,0,NUM_SRB_DC_CELLFACH);
  }
#else
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r9_IEs,defaultConfigForCellFACH))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: defaultConfigForCellFACH not supported yet!");
  }
#endif 
  
  /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
  OC ptr is now pointing to TOC ptr*/
     
  if ((SUCCESS == status) && (RRC_CHECK_COMMON_MSG_TYPE(msg_ptr->specificationMode,
    rrc_RRCConnectionSetup_r9_IEs_specificationMode_complete)))
  {
    if(RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r9_IEs))
    {
      dl_trch_add_reconfig_ptr = &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList;
    } 
    /* Call these functions ONLY in DCH state */
    if(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH)
    {
      /* Here, update the transport channel info (only transport channel IDs 
      * and count) and rearrange the info by sorting transport channel list
      * based on TrCH ID.  */

      /*RRC_GKG: Find out the rationale behind madatory UL AddReconfig. ASN.1 wise it's not OPTIONAL*/
      /* ul_AddReconfTransChInfoList is mandatory present */
      status = rrcllc_add_delete_and_arrange_ul_dch_trch_info_r8(TRUE, 
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList, FALSE, NULL);


      if (SUCCESS == status)
      {
        status = rrcllc_add_delete_and_arrange_dl_dch_trch_info_r9(
                 dl_trch_add_reconfig_ptr, NULL);
      }


    }  

    /* The OC ptr is now restor to point to Order config ptr*/
    rrcllc_restore_oc_ptr (tmp_config_ptr);
 
    /* Get the SRB setup list if present */
    if (SUCCESS == status)
    {
      /* SRB info has to be present in rrcConnectionSetup message */
      status =  rrcllc_process_srb_info_setup_list_r8(TRUE, 
        (rrc_SRB_InformationSetupList_r8 *) &msg_ptr->specificationMode.u.complete.srb_InformationSetupList);
    }

    if (SUCCESS == status) 
    {
      status = rrcllc_validate_rb_mapping_info();
    }
    
    /* use TOC ptr if not received in DCH state */
    tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
    /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
     OC ptr is now pointing to TOC ptr.*/

    /* Get the Common Uplink Transport Channel information */
    if (SUCCESS == status)
    {
      status = rrcllc_process_ul_common_trch_info_r5_r6(
       RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r9_IEs),
       &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo);
    }

    /* Do the processing for Uplink added/reconfigured TrCH, Compute
    * TFIs from CTFCs only for DCH. TBD - When TFC subset is processed 
    * (for Cell FACH state), this check for state needs to be re-examined */
    if((SUCCESS == status) && (ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH))
    {
      status = rrcllc_store_ul_add_reconf_trch_info_list_r8(
          RRCRB_R6_UL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r9_IEs),
          &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);

      /* Calculate the UL TFCS */
      if((SUCCESS == status) &&
         (RRCRB_R6_UL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r9_IEs)))
      {
        compute_ul_tfis_from_ctfc(&ordered_config_ptr->ul_tfcs);
      }

    }

    /*The OC ptr is now restor to point to Order config ptr */
    rrcllc_restore_oc_ptr (tmp_config_ptr);

    /* Fill in the RLC size restriction information for MAC */
    if(!(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_FACH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH) &&
       !(ordered_config_ptr->rrc_state_indicator == RRC_STATE_CELL_DCH &&
        msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_FACH))
    {
      if(rrcllc_populate_mac_rlc_size_restriction_info(ordered_config_ptr, 
        ordered_config_ptr->rrc_state_indicator) == FAILURE)
      {
        status = FAILURE;
      }
    }

    /* use TOC ptr if not received in DCH state */
    tmp_config_ptr = rrcllc_copy_toc_ptr_to_oc();
    
    /*For FACH, PCH, URA PCH states  the below contents will now be update to TOC.
     OC ptr is now pointing to TOC ptr*/
     
    /* Get the Common Downlink Transport Channel information */
    if((SUCCESS == status) &&
      (RRCRB_R6_DL_COMMON_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r9_IEs)))
    {
      status = get_dl_info_common_for_all_trch_r5(
        &msg_ptr->specificationMode.u.complete.dl_CommonTransChInfo,
        &msg_ptr->specificationMode.u.complete.ul_CommonTransChInfo,
        ordered_config_ptr->rrc_state_indicator);
    }

    if (SUCCESS == status)
    {
      status = rrcllc_store_dl_add_reconf_trch_info_list_r9(
        RRCRB_R6_DL_ADD_RECFG_TRCH_INFO_LIST_PRESENT(msg_ptr,rrc_RRCConnectionSetup_r9_IEs),
        &msg_ptr->specificationMode.u.complete.dl_AddReconfTransChInfoList,
        &msg_ptr->specificationMode.u.complete.ul_AddReconfTransChInfoList);
    }
  }
  else /*rrc_RRCConnectionSetup_r9_IEs,specificationMode_complete */
  {
    if(rrcrce_get_rbs_ptr() != NULL)
    {
      status = rrcllc_process_preconfiguration_with_srb5_rrc_conn_setup(msg_ptr->rrc_StateIndicator);
      WRRC_MSG1_HIGH("REL9: Finished processing DC with SRB5. status = %d",status);
    }
    else
    {
      status = rrcllc_process_preconfiguration_rrc_conn_setup_ie_r6((void *) msg_ptr, MSG_REL9);
      WRRC_MSG1_HIGH("REL9: Finished processing DC. status = %d",status);
    }
  }

  /*The OC ptr is now restor to point to Order config ptr*/
  rrcllc_restore_oc_ptr (tmp_config_ptr);
 
  if (SUCCESS == status)
  {
    /* Get the frequency info */
    status = rrcllc_update_frequency_info_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
     rrc_RRCConnectionSetup_r9_IEs,frequencyInfo),
      &msg_ptr->frequencyInfo, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
     rrc_RRCConnectionSetup_r9_IEs,maxAllowedUL_TX_Power),
      msg_ptr->maxAllowedUL_TX_Power);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_validate_transition_to_cell_dch(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r9_IEs,ul_DPCH_Info),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r9_IEs,dl_CommonInformation),
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r9_IEs,dl_InformationPerRL_List),
      msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get Uplink DPCH info if included, Ignore CPCH info */
    status = rrcllcpcie_process_ul_dpch_info_r7(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
     rrc_RRCConnectionSetup_r9_IEs,ul_DPCH_Info),
      &msg_ptr->ul_DPCH_Info, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status) 
  {
    status = rrcllcpcie_is_hho_r8(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
     rrc_RRCConnectionSetup_r9_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    /* Get the DL information for all Radio Links */
    status = rrcllcpcie_process_dl_common_info_r8(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
     rrc_RRCConnectionSetup_r9_IEs,dl_CommonInformation), 
      &msg_ptr->dl_CommonInformation, msg_ptr->rrc_StateIndicator);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_dl_info_per_rl_list_r8(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
     rrc_RRCConnectionSetup_r9_IEs,dl_InformationPerRL_List), 
      &msg_ptr->dl_InformationPerRL_List, msg_ptr->rrc_StateIndicator);
  }

  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
   rrc_RRCConnectionSetup_r9_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI, TRUE, msg_ptr->rrc_StateIndicator);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
   rrc_RRCConnectionSetup_r9_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI, FALSE, msg_ptr->rrc_StateIndicator);

  /* process UL-E_DCH Information */
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_ul_e_dch_information_r9(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r9_IEs,ul_EDCH_Information),
      &msg_ptr->ul_EDCH_Information, msg_ptr->rrc_StateIndicator);
  }

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(msg_ptr->
    rrc_StateIndicator) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r9_IEs,new_H_RNTI), 
      &msg_ptr->new_H_RNTI, msg_ptr->rrc_StateIndicator);
  }

  /* Get HS Information */
  /* SET Action Variable by calling HSDPA action table */
  if (SUCCESS == status)
  {
    status =   rrcllcpcie_process_hspdsch_info_and_upd_hsdpa_msg_params_r9(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r9_IEs,dl_HSPDSCH_Information),
      &msg_ptr->dl_HSPDSCH_Information,
      ((RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r9_IEs,frequencyInfo)) &&
      (msg_ptr->frequencyInfo.modeSpecificInfo.u.fdd->uarfcn_DL != rrc_ccm_get_curr_camped_freq())),
      msg_ptr->rrc_StateIndicator);
  }

  if(msg_ptr->rrc_StateIndicator == rrc_RRC_StateIndicator_cell_DCH)
  {
    if(rrcllc_check_trch_mapped_to_rb_present(NULL) == FAILURE)
    {
      return FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params_r9(&msg_ptr->dl_SecondaryCellInfoFDD, 
    msg_ptr->rrc_StateIndicator,(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
   rrc_RRCConnectionSetup_r9_IEs,dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_RRCConnectionSetup_r9_IEs,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/


  if ((SUCCESS == status) && 
      (!rrcllc_is_tfcs_provided_on_add_delete_trch(msg_ptr->rrc_StateIndicator)))
  {
    /* Configuration info missing some tfcs info.  Fail the configuration*/
    status = FAILURE;
  }

  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
       msg_ptr->m.dtx_drx_TimingInfoPresent,
       &msg_ptr->dtx_drx_Info,
       msg_ptr->m.dtx_drx_InfoPresent,
       msg_ptr->rrc_StateIndicator) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifdef FEATURE_WCDMA_HS_FACH
  if(status == SUCCESS)
  {
    rrcllc_fill_directed_cell_info(ordered_config_ptr, &directed_cell_info);
    validate_directed_cell_info = rrcrb_validate_directed_cell_info(directed_cell_info);
    status = rrcenhstate_check_for_efach_parms(msg_ptr->rrc_StateIndicator,
                                     validate_directed_cell_info,
                                     TRUE,
                                     RRCRB_R9_MSG_IE_PRESENT(msg_ptr,new_H_RNTI));
  }

#ifdef FEATURE_WCDMA_HS_RACH
  if(SUCCESS == status)
  {
    status = rrcllc_check_and_update_hsrach_params(msg_ptr->rrc_StateIndicator,
                                     validate_directed_cell_info,
                                     TRUE,
                                     RRCRB_R9_MSG_IE_PRESENT(msg_ptr,newPrimary_E_RNTI));
  }
#endif
#endif /*FEATURE_WCDMA_HS_FACH*/

#ifdef FEATURE_WCDMA_DEFAULT_CFG_CELLFACH
  if (SUCCESS == status)
  {
      if (msg_ptr->m.defaultConfigForCellFACHPresent)
      {
        if (rrc_DefaultConfigMode_fdd == msg_ptr->defaultConfigForCellFACH.defaultConfigMode)
        {
          
          if (RRC_DEF_CONFIG_0_DC_FACH == msg_ptr->defaultConfigForCellFACH.defaultConfigIdForCellFACH) 		  
          {
            status = rrcllc_process_default_config_cellfach();
          }
        }
      }
    }
#endif
  /* By now the status has been filled as per the processing.*/
  return (status);
}


/*====================================================================
FUNCTION: rrcllc_active_set_update_ie_r9()

DESCRIPTION:
  This function updates ordered_config with the latest IEs recv'd 
  in the Active Set Update Message

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
uecomdef_status_e_type rrcllc_active_set_update_ie_r9
(
  rrc_ActiveSetUpdate_r9 * active_set_update_r9_ota
)
{
  uecomdef_status_e_type          status = SUCCESS;
  rrc_ActiveSetUpdate_r9_IEs *msg_ptr;
  
  if (active_set_update_r9_ota == NULL)
  {
    WRRC_MSG0_ERROR("active_set_update_r9_ota is NULL");
    return FAILURE;
  }
  rrcllc_init_before_msg_processing();
  msg_ptr =  &active_set_update_r9_ota->activeSetUpdate_r9;

  /* Get the Activation Time */
  rrcllc_update_activation_time_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
    rrc_ActiveSetUpdate_r9_IEs,activationTime),
    msg_ptr->activationTime, rrc_RRC_StateIndicator_cell_DCH, RRC_PROCEDURE_ASU);

#ifdef FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME
  if(rrcdata_misc_info.rrc_buffer_ota_message == TRUE)
  {
    return FAILURE;
  }
#endif  /*FEATURE_WCDMA_ALLOW_LTA_DURING_ACT_TIME*/
 /* Get the U-RNTI */
  status = rrcllc_update_urnti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,
    newU_RNTI),&msg_ptr->newU_RNTI, rrc_RRC_StateIndicator_cell_DCH);

  if(SUCCESS == status)
  {
    /* Get the Maximum allowed UL TX power */
    status = rrcllc_update_max_allowed_ul_tx_power_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
      rrc_ActiveSetUpdate_r9_IEs,maxAllowedUL_TX_Power), msg_ptr->maxAllowedUL_TX_Power);
  } 

  if (SUCCESS == status)
  {
    /* Get the Radio Link Removal information */
    status = rrcllcpcie_process_rl_removal_information_list(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,rl_RemovalInformationList),
      &msg_ptr->rl_RemovalInformationList,
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,rl_AdditionInformationList));
  }
    

  /* Get the TX Diversity Mode */
  if((SUCCESS == status) && (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,tx_DiversityMode)))
  {
    status = get_tx_diversity_mode_info(msg_ptr->tx_DiversityMode,
      &ordered_config_ptr->l1_dl_chan_parms.dl_common);
  } 

  if (SUCCESS == status)
  {
    /* Get the Radio Link Addition information */
    status = rrcllcpcie_process_rl_addition_info_list_r9(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,rl_AdditionInformationList),
      &msg_ptr->rl_AdditionInformationList);
  }
  if(SUCCESS == status)
  {
    rrcllcpcie_process_edpch_interpolation_info(  msg_ptr->e_DPDCH_PowerInterpolation,
        (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,e_DPDCH_PowerInterpolation)));
  }
#ifdef FEATURE_WCDMA_REL7_EDPCCH_POWER_BOOST
  if(SUCCESS == status)
  {
  status = rrcllcpcie_process_edpcch_boost_info(&msg_ptr->e_TFC_Boost_Info, RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,e_TFC_Boost_Info));
  	}
#else
  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,e_TFC_Boost_Info))
  {
    WRRC_MSG0_ERROR("REL9: IE e_TFC_Boost_Info not supported yet!");
  }
#endif
  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_e_dch_reconfig_info_samecell(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,e_dch_ReconfInfoSameCell),
      &msg_ptr->e_dch_ReconfInfoSameCell);
  }

  if (SUCCESS == status)
  {
    status = rrcllcpcie_process_e_dch_reconfig_info_r7(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,e_dch_ReconfigurationInfo),
      &msg_ptr->e_dch_ReconfigurationInfo);
  }
#ifdef FEATURE_WCDMA_16_QAM
  if (SUCCESS == status)
  {
     status = rrcllcpcie_process_ul_16qam_config(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r9_IEs,ul_16QAM_Config),&msg_ptr->ul_16QAM_Config);
  }
#endif
  /* Get the Primary E-RNTI */
  rrcllc_update_ernti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,newPrimary_E_RNTI),
    msg_ptr->newPrimary_E_RNTI, TRUE, rrc_RRC_StateIndicator_cell_DCH);

  /* Get the Secondary E-RNTI */
  rrcllc_update_ernti_in_oc(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,newSecondary_E_RNTI),
    msg_ptr->newSecondary_E_RNTI, FALSE, rrc_RRC_StateIndicator_cell_DCH);

  /* call EUL post-processing function to evaluate the value of variable e_dch_transmission, 
     update mac_eul_action and l1_e_req_mask as per computed value of e_dch_transmission variable */
  if((SUCCESS == status) && (rrcllc_evaluate_e_dch_tx_var_and_set_lower_layers_action(
    rrc_RRC_StateIndicator_cell_DCH) ==FAILURE))
  { 
    status= FAILURE;
  }

  if ((SUCCESS == status) && rrcllc_is_cm_deactive_with_eul())
  {
    status = FAILURE;
  }

  /* Validation for and processing for ASU repointing */

  if (SUCCESS == status)
  {
    /* Set HRNTI */
    status = rrcllc_update_hrnti_in_oc(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r9_IEs,newH_RNTI), 
      &msg_ptr->newH_RNTI,
      rrc_RRC_StateIndicator_cell_DCH);
  }

  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,serving_HSDSCH_CellInformation))
  {
    if(SUCCESS == status)
    {
      /*Following check is done to make sure that H-RNTI is provided if HS Re-pointing is happening.*/
      if((msg_ptr->serving_HSDSCH_CellInformation.m.primaryCPICH_InfoPresent)
        && (msg_ptr->serving_HSDSCH_CellInformation.primaryCPICH_Info.primaryScramblingCode != ordered_config_ptr->l1_hsdpa_info.hs_pdsch_rl_psc)
        && (!(msg_ptr->m.newH_RNTIPresent)))

      {
        WRRC_MSG0_ERROR("REL9:ASU Re-pointing without new HRNTI!");
        return FAILURE;
      }
    
        status = rrcllc_process_serving_hsdsch_cell_info_r9(&msg_ptr->serving_HSDSCH_CellInformation);
    }
  }

#ifdef FEATURE_WCDMA_MIMO
  if((SUCCESS == status) && (rrcllcpcie_process_mimo_params_r9(&msg_ptr->mimoParameters,
    rrc_RRC_StateIndicator_cell_DCH, (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r9_IEs,mimoParameters))) 
    == FAILURE))
  {
    status = FAILURE;
  }
#else /*FEATURE_WCDMA_MIMO*/
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r9_IEs,mimoParameters))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: mimoParameters not supported ");
  }
#endif /*FEATURE_WCDMA_MIMO*/

  if (msg_ptr->m.servingCellChangeParametersPresent)
  {
    WRRC_MSG0_ERROR("REL9: servingCellChangeParameters not supported yet!");
    status = FAILURE;
  }


  if (RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r9_IEs,dpc_Mode))
  {
    WRRC_MSG0_ERROR("REL9: IE dpc_Mode not supported yet!");
    status = FAILURE;
  } 

#ifdef FEATURE_WCDMA_DC_HSDPA
  if((SUCCESS == status) && (rrcllcpcie_process_dc_hsdpa_params_r9(&msg_ptr->dl_SecondaryCellInfoFDD, 
    rrc_RRC_StateIndicator_cell_DCH,(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, 
   rrc_ActiveSetUpdate_r9_IEs,dl_SecondaryCellInfoFDD))) == FAILURE))
  {
    status = FAILURE;
  }
#else /*FEATURE_WCDMA_DC_HSDPA*/
  if(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r9_IEs,dl_SecondaryCellInfoFDD))
  {
    WRRC_MSG0_ERROR("REL9: dl_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
#endif /*FEATURE_WCDMA_DC_HSDPA*/

  /*By this time, hsdpa_action should have been set.*/
  /*Following check is done to verify whether IE hs-DSCH-TBSizeTable is present or not.*/
  if((SUCCESS == status) && ((active_set_update_r9_ota != NULL)&& RRC_MSG_COMMON_BITMASK_IE(active_set_update_r9_ota->activeSetUpdate_r9,
   rrc_ActiveSetUpdate_r9_IEs,serving_HSDSCH_CellInformation)) &&
    (RRC_MSG_COMMON_BITMASK_IE(active_set_update_r9_ota->activeSetUpdate_r9.serving_HSDSCH_CellInformation,
    rrc_Serving_HSDSCH_CellInformation_r9,dl_hspdsch_Information)) &&
    (RRC_CHECK_COMMON_MSG_TYPE(active_set_update_r9_ota->activeSetUpdate_r9.serving_HSDSCH_CellInformation.dl_hspdsch_Information.modeSpecificInfo,
     rrc_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd)) &&
    (active_set_update_r9_ota->activeSetUpdate_r9.serving_HSDSCH_CellInformation.dl_hspdsch_Information.modeSpecificInfo.u.
    fdd->m.hs_DSCH_TBSizeTablePresent))
  {
    rrcllcpcie_update_hs_tfri_table_type(TRUE);
  }
  else
  {
       /*if the whole Downlink HS-PDSCH information IE is missing we should retain 
            the older TFRI table but if they send the IE with other parameters but not the 
            table info, we should switch to bit aligned as per section 10.3.6.23a
            Also if hs_64_qam_configured is TRUE we should set to octet aligned 
         */
   if(((RRC_MSG_COMMON_BITMASK_IE(active_set_update_r9_ota->activeSetUpdate_r9,
	rrc_ActiveSetUpdate_r9_IEs,serving_HSDSCH_CellInformation)) &&
	(RRC_MSG_COMMON_BITMASK_IE(active_set_update_r9_ota->activeSetUpdate_r9.serving_HSDSCH_CellInformation,
	rrc_Serving_HSDSCH_CellInformation_r9,dl_hspdsch_Information)))
	  || (ordered_config_ptr->l1_hsdpa_info.hs_dsch_info.hs_64_qam_configured == TRUE )
	  || (ordered_config_ptr->mac_dl_parms.mac_hs_or_ehs == MAC_HS)
	 )
    {
      rrcllcpcie_update_hs_tfri_table_type(FALSE);
    }
  }

  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dtx_drx_params(&msg_ptr->dtx_drx_TimingInfo,
       msg_ptr->m.dtx_drx_TimingInfoPresent,
       &msg_ptr->dtx_drx_Info,
       msg_ptr->m.dtx_drx_InfoPresent,
       rrc_RRC_StateIndicator_cell_DCH) == FAILURE)
    {
      status = FAILURE;
    }
  }

#ifndef FEATURE_WCDMA_DC_HSUPA

  if((SUCCESS == status)&&(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r9_IEs,ul_SecondaryCellInfoFDD)))
  {
    WRRC_MSG0_ERROR("REL9: ul_SecondaryCellInfoFDD IE not supported yet!");
    status = FAILURE;
  }
  if((SUCCESS == status)&&(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r9_IEs,e_dch_ReconfigurationInfo_SecULFrequency)))
  {
    WRRC_MSG0_ERROR("REL9: e_dch_ReconfigurationInfo_SecULFrequency IE not supported yet!");
    status = FAILURE;
  }
  if((SUCCESS == status)&&(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r9_IEs,rl_AdditionInformationList_SecULFreq)))
  {
    WRRC_MSG0_ERROR("REL9: rl_AdditionInformationList_SecULFreq IE not supported yet!");
    status = FAILURE;
  }
  if((SUCCESS == status)&&(RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr,rrc_ActiveSetUpdate_r9_IEs,rl_RemovalInformationList_SecULFreq)))
  {
    WRRC_MSG0_ERROR("REL9: rl_RemovalInformationList_SecULFreq IE not supported yet!");
    status = FAILURE;
  }
#endif

  if((SUCCESS == status)&&( RRC_MSG_COMMON_BITMASK_IE_PTR(active_set_update_r9_ota,rrc_ActiveSetUpdate_r9,v950NonCriticalExtensions)) &&
    (RRC_MSG_COMMON_BITMASK_IE(active_set_update_r9_ota->v950NonCriticalExtensions.activeSetUpdate_v950ext,rrc_ActiveSetUpdate_v950ext_IEs,
    secondaryCellMimoParameters)))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: secondaryCellMimoParameters not supported ");
  }
  if((SUCCESS == status)&&( RRC_MSG_COMMON_BITMASK_IE_PTR(active_set_update_r9_ota,rrc_ActiveSetUpdate_r9,v950NonCriticalExtensions))&&
    (RRC_MSG_COMMON_BITMASK_IE(active_set_update_r9_ota->v950NonCriticalExtensions,rrc_ActiveSetUpdate_v950NonCriticalExtensions,
     nonCriticalExtensions)))
  {
    status = FAILURE;
    WRRC_MSG0_ERROR("REL9: nonCriticalExtensions not supported ");
  }
  if ((SUCCESS == status)&&( RRC_MSG_COMMON_BITMASK_IE_PTR(active_set_update_r9_ota,rrc_ActiveSetUpdate_r9,v950NonCriticalExtensions)) &&
  (RRC_MSG_COMMON_BITMASK_IE(active_set_update_r9_ota->v950NonCriticalExtensions.activeSetUpdate_v950ext,rrc_ActiveSetUpdate_v950ext_IEs,
  rl_AdditionInformationList)))
  {
    status= rrcllcpcie_process_rl_addition_info_list_ext_asu_r9(active_set_update_r9_ota->v950NonCriticalExtensions.
    activeSetUpdate_v950ext.rl_AdditionInformationList);    
  }

  
#ifdef FEATURE_WCDMA_DC_HSUPA

  if (status == SUCCESS)
  {
    if(rrcllc_validate_asu_for_sec_eul(msg_ptr) == FALSE)
      {
      
        rrc_msg_failure_cause = RRC_MSG_INVALID_CONFIG;
        status = FAILURE;
      }
  }

  
  if (SUCCESS == status)
  {
    /* Get the Radio Link Removal information */
    status = rrcllcpcie_process_rl_removal_information_list_on_sec_eul(
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,rl_RemovalInformationList_SecULFreq),
    &msg_ptr->rl_RemovalInformationList_SecULFreq,
    RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,rl_AdditionInformationList_SecULFreq));
  }


  if (SUCCESS == status)
  {
    /* Get the Radio Link Addition information */
    status = rrcllcpcie_process_sec_eul_rl_addition_info_list_r9(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,rl_AdditionInformationList_SecULFreq),
      &msg_ptr->rl_AdditionInformationList_SecULFreq);
  }


  if (SUCCESS == status)
  {
    /* Get the Radio Link Addition information */
    status = rrcllcpcie_process_sec_e_dch_reconfig_info_r9(
      RRC_MSG_COMMON_BITMASK_IE_PTR(msg_ptr, rrc_ActiveSetUpdate_r9_IEs,e_dch_ReconfigurationInfo_SecULFrequency),
      &msg_ptr->e_dch_ReconfigurationInfo_SecULFrequency);
  }


  
  if(status == SUCCESS)
  {
    if(rrcllcpcie_process_dc_hsupa_params(&msg_ptr->ul_SecondaryCellInfoFDD,rrc_RRC_StateIndicator_cell_DCH,
      (RRCRB_R9_MSG_IE_PRESENT(msg_ptr,ul_SecondaryCellInfoFDD)))== FAILURE)
      {
        status = FAILURE;
      }
  }
#endif /* FEATURE_WCDMA_DC_HSUPA */
  /* By now the status has been filled as per the processing.*/
  return (status);
}

/*====================================================================
FUNCTION: FIND_TRCH_ID_IN_CONFIG_TRCH_LIST_R9

DESCRIPTION:

DEPENDENCIES:
  None.

RETURN VALUE:
  None.

SIDE EFFECTS:
  None.
====================================================================*/
boolean find_trch_id_in_config_trch_list_r9
(
  rrc_DL_AddReconfTransChInfoList_r9 * dl_trch_add_reconfig_ptr,
  tr_ch_id_type trch_id
)
{
  uint32 idx = 0;
  boolean found = FALSE;
  
  while((idx <= UE_MAX_TRCH) && (dl_trch_add_reconfig_ptr->n > idx))
  {
    if (dl_trch_add_reconfig_ptr->elem[idx].dl_TransportChannelType.t == T_rrc_DL_TrCH_TypeId1_r5_dch)
    {
      if (dl_trch_add_reconfig_ptr->elem[idx].dl_TransportChannelType.u.dch == trch_id)
      {
        found = TRUE;
        break;
      }
    }
    idx++;
  }
  
  return found;
}

#endif /*FEATURE_WCDMA_REL9*/


#ifdef FEATURE_WCDMA_REL10
#error code not present
#endif /*FEATURE_WCDMA_REL10*/

