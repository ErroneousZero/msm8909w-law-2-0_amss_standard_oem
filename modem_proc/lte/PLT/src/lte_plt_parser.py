#!/usr/bin/env python

#===- cindex-dump.py - cindex/Python Source Dump -------------*- python -*--===#
#
#                     The LLVM Compiler Infrastructure
#
# This file is distributed under the University of Illinois Open Source
# License. See LICENSE.TXT for details.
#
#===------------------------------------------------------------------------===#

"""
A simple command line tool for dumping a source file using the Clang Index
Library.
"""
import os, sys
import xml.etree.ElementTree
import pprint
import pdb
import optparse
import json

## HACK ##
# Gotta parse the options before importing the clang library
parser = optparse.OptionParser("usage: %prog [options] {filename} [clang-args*]")
parser.add_option("-p", "--perl-output", dest="perl_output",
                  help="specify name of generated perl library")
parser.add_option("-o", "--c-output", dest="c_output",
                  help="specify name of generated C file")
parser.add_option("-x", "--xml", action="append", dest="xmls",
                  help="specify an xml umid file to load",
                  default=[])
parser.add_option("-d", "--debug", action="count", dest="debug",
                  help="enable debug dump")
parser.add_option("-v", "--version", dest="version",
                  help="specify the version of the Hexagon tools (default 6.3)")
parser.disable_interspersed_args()
(options, args) = parser.parse_args()

if len(args) == 0:
    parser.error('invalid number arguments')

if sys.platform.startswith("linux"):
    hexagon_path = "/pkg/qct/software/hexagon/releases/tools"
    hexagon_path   = os.path.join(hexagon_path, options.version)
    clang_mod      = os.path.join(hexagon_path, "qc", "lib", "libclang.so")
    clang_lib_path = os.path.join(hexagon_path, "qc", "lib", "clang", "python")
else:
    hexagon_path   = "C:/Qualcomm/HEXAGON_Tools"
    hexagon_path   = os.path.join(hexagon_path, options.version)
    clang_mod      = os.path.join(hexagon_path, "qc", "bin", "hexagon-libclang.dll")
    clang_lib_path = os.path.join(hexagon_path, "qc", "lib", "clang", "python")

def write_c_dummy_file(fname):
    f = open(fname, 'w')   
    f.write("/*!\n")
    f.write("  \n")
    f.write("  lte_plt_autogen_pack_unpack.c\n")
    f.write("\n")
    f.write("  \n")
    f.write("  This file contains LTE PLT autogenerated pack/ unpack routines\n")
    f.write("\n")
    f.write("  \n")
    f.write("  description of functions in this file\n")
    f.write(" \n")
    f.write("*/\n")
    f.write("\n")
    f.write("/*===========================================================================\n")
    f.write("\n")
    f.write("  Copyright (c) 2008 QUALCOMM Incorporated. All Rights Reserved\n")
    f.write("\n")
    f.write("  Qualcomm Proprietary\n")
    f.write("\n")
    f.write("  Export of this technology or software is regulated by the U.S. Government.\n")
    f.write("  Diversion contrary to U.S. law prohibited.\n")
    f.write("\n")
    f.write("  All ideas, data and information contained in or disclosed by\n")
    f.write("  this document are confidential and proprietary information of\n")
    f.write("  QUALCOMM Incorporated and all rights therein are expressly reserved.\n")
    f.write("  By accepting this material the recipient agrees that this material\n")
    f.write("  and the information contained therein are held in confidence and in\n")
    f.write("  trust and will not be used, copied, reproduced in whole or in part,\n")
    f.write("  nor its contents revealed in any manner to others without the express\n")
    f.write("  written permission of QUALCOMM Incorporated.\n")
    f.write("\n")
    f.write("===========================================================================*/\n")
    f.write("\n")
    f.write("/*===========================================================================\n")
    f.write("\n")
    f.write("                        EDIT HISTORY FOR MODULE\n")
    f.write("\n")
    f.write("This section contains comments describing changes made to the module.\n")
    f.write("Notice that changes are listed in reverse chronological order.\n")
    f.write("\n")
    f.write("when       who     what, where, why\n")
    f.write("--------   ---     ----------------------------------------------------------\n")
    f.write("09/30/13   Autogenerated      Do  not modify this file\n")
    f.write("===========================================================================*/\n")
    f.write("\n")
    f.write("#include \"lte_plt_autogen_pack_unpack.h\" \n")
    f.write("\n")
    f.write("\n")
    f.write("/*===========================================================================\n")
    f.write("\n")
    f.write("  FUNCTION:  lte_plt_autogen_unpack\n")
    f.write("\n")
    f.write("===========================================================================*/\n")
    f.write("/*!\n")
    f.write("    @brief\n")
    f.write("    Unpack the structure passed in by the PLT client\n")
    f.write("\n")
    f.write("    @detail\n")
    f.write("    A packed structure is passed in by the PLT client. The PLT server needs to\n")
    f.write("	unpack the structure before sending to ML1/ LL1. \n")
    f.write("\n")
    f.write("    @return\n")
    f.write("    autogen result status:0 for success, 1 for unknown UMID, 2 for bad_msg_len\n")
    f.write("*/\n")
    f.write("/*=========================================================================*/\n")
    f.write("lte_plt_autogen_result_enum_type lte_plt_autogen_unpack( \n")
    f.write("	msgr_umid_type umid, /*!< UMID to be unpacked */\n")
    f.write("	uint32 packed_msg_len, /*!< Packed message length */\n")
    f.write("	void *packed_msg_ptr, /*!< Pointer to packed message */\n")
    f.write("	uint32 *unpacked_msg_len, /*!< Pointer to unpacked message length */\n")
    f.write("	void *unpacked_msg_ptr /*!< Pointer to unpacked message */)\n")
    f.write("\n")
    f.write("{\n")
    f.write("  return AUTOGEN_RESULT_UNKNOWN_UMID;\n")
    f.write("}\n")
    f.write("\n")
    f.write("/*===========================================================================\n")
    f.write("\n")
    f.write("  FUNCTION:  lte_plt_autogen_pack\n")
    f.write("\n")
    f.write("===========================================================================*/\n")
    f.write("/*!\n")
    f.write("    @brief\n")
    f.write("    Pack the structure to send to the PLT client\n")
    f.write("\n")
    f.write("    @detail\n")
    f.write("    An unpacked structure is received from ML1/ LL1. The PLT server needs to\n")
    f.write("	pack the structure before sending to PLT client. \n")
    f.write("\n")
    f.write("    @return\n")
    f.write("    autogen result status:0 for success, 1 for unknown UMID, 2 for bad_msg_len\n")
    f.write("*/\n")
    f.write("/*=========================================================================*/\n")
    f.write("lte_plt_autogen_result_enum_type lte_plt_autogen_pack( \n")
    f.write("    msgr_umid_type umid, /*!< UMID to be packed */\n")
    f.write("    uint32 unpacked_msg_len, /*!< Unpacked message length */\n")
    f.write("    void *unpacked_msg_ptr, /*!< Pointer to unpacked message */\n")
    f.write("    uint32 *packed_msg_len, /*!< Pointer to packed message length */\n")
    f.write("    void *packed_msg_ptr /*!< Pointer to packed message */)\n")
    f.write("\n")
    f.write("{\n")
    f.write("  return AUTOGEN_RESULT_UNKNOWN_UMID;\n")
    f.write("}\n")
    f.write("\n")
    f.write("/*===========================================================================\n")
    f.write("\n")
    f.write("  FUNCTION:  lte_plt_autogen_get_rsp_umid\n")
    f.write("\n")
    f.write("===========================================================================*/\n")
    f.write("/*!\n")
    f.write("    @brief\n")
    f.write("    Get all UMIDs to be packed/ unpacked\n")
    f.write("\n")
    f.write("    @detail\n")
    f.write("    We need to know what UMIDs need to be packed/ unpacked to register for\n")
    f.write("	these UMIDs. It is returned in the umids array.\n")
    f.write("\n")
    f.write("    @return\n")
    f.write("    none\n")
    f.write("*/\n")
    f.write("/*=========================================================================*/\n")
    f.write("void lte_plt_autogen_get_rsp_umid( \n")
    f.write("    int *num_umids_ptr, /*!< Pointer to number of UMIDs in the array */\n")
    f.write("    msgr_umid_type *umids /*!< UMID array */)\n")
    f.write("\n")
    f.write("{\n")
    f.write("  return;\n")
    f.write("}\n")
    f.write("\n")
    f.write("\n")
    f.write("/*===========================================================================\n")
    f.write("\n")
    f.write("  FUNCTION:  lte_plt_autogen_pack_unpack_unit_test\n")
    f.write("\n")
    f.write("===========================================================================*/\n")
    f.write("/*!\n")
    f.write("    @brief\n")
    f.write("    Function which contains autogenerated unit tests\n")
    f.write("\n")
    f.write("    @detail\n")
    f.write("    For off target unit testing, the unit tests for packing/ unpacking \n")
    f.write("	are autogenerated. \n")
    f.write("\n")
    f.write("    @return\n")
    f.write("    number of tests failed\n")
    f.write("*/\n")
    f.write("/*=========================================================================*/\n")
    f.write("int lte_plt_autogen_pack_unpack_unit_test( void )\n")
    f.write("{\n")
    f.write("  return 0;\n")
    f.write("}\n")
    f.write("\n")
    f.write("/*===========================================================================\n")
    f.write("\n")
    f.write("  FUNCTION:  lte_plt_autogen_get_cookie\n")
    f.write("\n")
    f.write("===========================================================================*/\n")
    f.write("/*!\n")
    f.write("    @brief\n")
    f.write("    Returns the cookie to validate metadata\n")
    f.write("\n")
    f.write("    @detail\n")
    f.write("    Returns the cookie to validate metadata \n")
    f.write("\n")
    f.write("    @return\n")
    f.write("    number of tests failed\n")
    f.write("*/\n")
    f.write("/*=========================================================================*/\n")
    f.write("int lte_plt_autogen_get_cookie ( void )\n")
    f.write("{\n")
    f.write("  return 0;\n")
    f.write("}\n")
    f.write("\n")
    f.write("\n")
    f.write("\n")
    # Close the file
    f.close()


hexagon_version = options.version
if int(hexagon_version.split('.')[0]) < 6:
    print "Hexagon version is not supported"
    print "Create dummy foo file and exit!"
    write_c_dummy_file(options.c_output)
    sys.exit(0)

# Load the CLANG library
print "Loading clang library from: " + clang_lib_path
sys.path.append(clang_lib_path)
from clang.cindex import Config
from clang.cindex import Index
from clang.cindex import TypeKind
from clang.cindex import CursorKind

ANONYMOUS_PREFIX = "anonymous_"
UMID_STRUCT_PREFIXES = ['msgr_hdr_struct_type', 'lte_LL1','lte_cphy','lte_cphy_test','lte_plt','hdrsrch','qtf_run']
BASIC_TYPES_TABLE = {
    TypeKind.BOOL : 'boolean',
    TypeKind.CHAR_U : 'unsigned char',
    TypeKind.UCHAR : 'unsigned char',
    TypeKind.CHAR16 : 'signed short',
    TypeKind.CHAR32 : 'signed long',
    TypeKind.USHORT : 'unsigned short',
    TypeKind.UINT : 'unsigned int',
    TypeKind.ULONG : 'unsigned long',
    TypeKind.ULONGLONG : 'unsigned long long',
    TypeKind.UINT128 : 'unsigned long long',
    TypeKind.CHAR_S : 'signed char',
    TypeKind.SCHAR : 'signed char',
    TypeKind.WCHAR : 'signed short',
    TypeKind.SHORT : 'short',
    TypeKind.INT : 'int',
    TypeKind.LONG : 'long',
    TypeKind.LONGLONG : 'long long',
    TypeKind.INT128 : 'signed long long',
    TypeKind.FLOAT : 'float',
    TypeKind.DOUBLE : 'double',
    TypeKind.LONGDOUBLE : 'long double',
    TypeKind.ENUM : 'unknown enum',
    }

random_number = 0
anonymous_number = 0
fdebug = None
symbol_ast_cache = {}

def get_diag_info(diag):
    return { 'severity' : diag.severity,
             'location' : diag.location,
             'spelling' : diag.spelling,
             'ranges' : diag.ranges,
             'fixits' : diag.fixits }

def find_child(node, name):
    name = name[0]
    
    global symbol_ast_cache
    if name in symbol_ast_cache:
        return symbol_ast_cache[name]
    
    for c in node.get_children():
        if c.spelling == name:
            symbol_ast_cache[name] = c
            return c
    return None

def find_child_from_path(node, path):
    if not path:
        return node
    name = path[0]
    rest = path[1:]
    for c in node.get_children():
        if c.spelling == name:
            return find_child(c, rest)
    return None

def get_info(node):
    children = [get_info(c) for c in node.get_children()]

    info = { 'cursorkind' : node.kind,
             'typekind' : node.type.kind,
             'canonicalkind' : node.type.get_canonical().kind,
             'spelling' : node.spelling,
             'location' : node.location,
             'is_definition' : node.is_definition(),
             'children' : children,
             'size'     : node.type.get_size(),
             'arrsize'  : node.type.get_array_size()}
    definition = node.get_definition()
    if definition:
        info['def'] = definition.spelling
    if node.kind==CursorKind.ENUM_CONSTANT_DECL:
        info['value'] = node.enum_value
    if node.is_bitfield():
        info['bitwidth'] = node.get_bitfield_width()
    return info

def is_basic_type(t):
    return t.kind in BASIC_TYPES_TABLE.keys()

def convert_to_c_type(t):
    return BASIC_TYPES_TABLE[t.kind]

def gen_perl_for_field(cursor):
    t = cursor.type.get_canonical()
    if is_basic_type(t):
        size = t.get_size()
        arrsize = 1
        if t.kind == TypeKind.CONSTANTARRAY:
            arrsize = t.get_array_size()
            size    = int(size / arrsize)
        depend = ""
        if t.kind == TypeKind.ENUM:
            depend = ", DEPEND"
        return "['" + cursor.spelling + "', BYTE, " + str(size) + ", " + str(arrsize) + depend + "],"
    elif t.kind == TypeKind.ENUM:
        return "size of enum: " + str(t.get_size())
    else:
        return "Unknown"
    
def get_enums(node):
    enums = {}

    # Deal with our node
    if node.kind == CursorKind.ENUM_CONSTANT_DECL:
        enums[node.spelling] = node.enum_value

    # Recurse for children nodes
    for c in node.get_children():
        enums.update(get_enums(c))

    return enums

def get_struct_definitions(root, structnames, debug=0):
    global fdebug
    global anonymous_number

    structs = {}
    
    for name in structnames:
        ## if name == 'lte_LL1_ul_ctrl_params_union':
        ##     pdb.set_trace()
        ## import pdb;pdb.set_trace()
        # Skip blanks
        if name == '':
            continue
        
        # Check for special names
        if name == 'lte_LL1_sys_time_struct':
            structs['lte_LL1_sys_time_struct'] = {
                'fields'   : [ { 'name' : 'value',
                                 'perltype' : 'BYTE',
                                 'ctype'    : 'uint16',
                                 'size'     : 2,
                                 'arrsize'  : -1,
                                 } ] }
            continue
        # Look up the struct
        renamings = name.split(',')
        if len(renamings) > 1:
            assert len(renamings) == 3
            name    = renamings[0]
        cursor = find_child(root, [name])
        if len(renamings) > 1:
            field = renamings[1]
            name  = renamings[2]
            # Handle typedefs
            if cursor.kind == CursorKind.TYPEDEF_DECL:
                structnode = cursor.get_children().next()
            else:
                structnode = cursor
            assert structnode.kind == CursorKind.STRUCT_DECL
            for child in structnode.get_children():
                if child.spelling == field:
                    cursor = child.get_children().next()
                    break
        
        # Error checking
        if not cursor:
            print "Ignoring missing structure: " + name
            continue
        if cursor.kind not in [CursorKind.TYPEDEF_DECL, CursorKind.STRUCT_DECL, CursorKind.UNION_DECL]:
            print "Bad cursor.kind(" + str(cursor.kind) + ") for " + cursor.spelling
            continue
        if cursor.spelling:
            assert name == cursor.spelling

        # Handle unions
        if cursor.kind == CursorKind.UNION_DECL:
            print "Ignoring union: " + cursor.spelling
            continue

        # Handle typedefs
        if cursor.kind == CursorKind.TYPEDEF_DECL:
            structnode = cursor.get_children().next()
        else:
            structnode = cursor

        # Handle type references
        if structnode.kind == CursorKind.TYPE_REF:
            newname = structnode.get_definition().spelling
            if debug > 1:
                pprint.pprint((cursor.spelling, 'requires', newname), stream=fdebug)
            structs.update(get_struct_definitions(root, [newname], debug=debug))
            newstruct = structs[newname]
            if 'enum' not in newstruct:
                structs[name] = { 'fields' : newstruct['fields'] }
        elif structnode.kind == CursorKind.STRUCT_DECL:
            struct = {}
            struct['fields'] = []

            for child in structnode.get_children():
                ## import pdb; pdb.set_trace()
                if child.kind == CursorKind.FIELD_DECL:
                    if not child.spelling:
                        continue
                    
                    field = {}
                    t = child.type.get_canonical()
                    field['name'] = child.spelling
                    # Handle basic types
                    if is_basic_type(t):
                        field['perltype'] = 'BYTE'
                        field['ctype'] = convert_to_c_type(t)
                        field['size'] = t.get_size()
                        field['arrsize'] = t.get_array_size()
                        if child.type.kind == TypeKind.TYPEDEF:
                            subchild = child.get_children().next()
                            field['ctype'] = subchild.get_definition().spelling
                        if t.kind == TypeKind.CONSTANTARRAY:
                            subchild = child.get_children().next()
                            field['size']    = subchild.type.get_size()
                            field['arrsize'] = t.get_size() / field['size']
                        if t.kind == TypeKind.ENUM:
                            field['perltype'] = 'ENUM'
                            # Gotta recurse to make sure we have all types
                            if debug > 1:
                                pprint.pprint((cursor.spelling, 'requires', field['ctype']), stream=fdebug)
                            structs.update(get_struct_definitions(root, [field['ctype']], debug=debug))
                    # Handle structures
                    elif t.kind == TypeKind.RECORD:
                        subchild = child.get_children().next()
                        assert subchild.kind == CursorKind.TYPE_REF
                        field['perltype'] = 'SUBREC'
                        field['ctype'] = subchild.get_definition().spelling
                        field['arrsize'] = t.get_array_size()
                        # Gotta recurse to make sure we have all types
                        if debug > 1:
                            pprint.pprint((cursor.spelling, 'requires', field['ctype']), stream=fdebug)
                        structs.update(get_struct_definitions(root, [field['ctype']], debug=debug))
                        # See if it was a union
                        if 'union' in structs[field['ctype']]:
                            field['perltype'] = 'UNION'
                    # Handle arrays
                    elif t.kind == TypeKind.CONSTANTARRAY:
                        subchild = child.get_children().next()
                        if is_basic_type(subchild.type.get_canonical()):
                            field['perltype'] = 'BYTE'
                            field['size'] = subchild.type.get_size()
                            field['ctype'] = subchild.get_definition().spelling
                            field['arrsize'] = t.get_size() / field['size']
                            if subchild.type.get_size() * t.get_array_size() != t.get_size():
                                # HACK: Assuming double array when sizes don't line up
                                field['arrsize'] = t.get_array_size()
                                field['double_arrsize'] = int(t.get_size() / field['size'] / field['arrsize'])
                            if subchild.type.get_canonical().kind == TypeKind.ENUM:
                                field['ctype'] = subchild.get_definition().spelling
                                field['perltype'] = 'ENUM'
                                # Gotta recurse to make sure we have all types
                                if debug > 1:
                                    pprint.pprint((cursor.spelling, 'requires', field['ctype']), stream=fdebug)
                                structs.update(get_struct_definitions(root, [field['ctype']], debug=debug))
                        else:
                            field['arrsize'] = t.get_array_size()
                            field['perltype'] = 'SUBREC'
                            field['ctype'] = subchild.get_definition().spelling
                            if not field['ctype']:
                                anony = ANONYMOUS_PREFIX + str(anonymous_number)
                                anonymous_number += 1
                                if debug > 1:
                                    pprint.pprint((name, 'requires', anony), stream=fdebug)
                                field['ctype'] = anony
                                ## struct['no_c_code'] = True
                                structs.update(get_struct_definitions(root, [cursor.spelling + "," + field['name'] + "," + anony], debug=debug))
                            else:
                                # Gotta recurse to make sure we have all types
                                if debug > 1:
                                    pprint.pprint((name, 'requires', field['ctype']), stream=fdebug)
                                structs.update(get_struct_definitions(root, [field['ctype']], debug=debug))
                            # See if it was a union
                            if field['ctype'] and 'union' in structs[field['ctype']]:
                                field['perltype'] = 'UNION'
                    elif t.kind == TypeKind.POINTER:
                        try:
                            subchild = child.get_children().next()
                            field['ctype'] = subchild.get_definition().spelling + '*'
                        except StopIteration:
                            field['ctype'] = 'void*'
                        field['perltype'] = 'BYTE'
                        field['size'] = t.get_size()
                        field['arrsize'] = t.get_array_size()
                    else:
                        print "Ignoring field " + child.spelling + " in " + cursor.spelling
                        continue
                    struct['fields'].append(field)
            structs[name] = struct
        elif structnode.kind == CursorKind.UNION_DECL:
            union = {}
            union['name'] = cursor.spelling
            union['union'] = True
            union['fields'] = []
            for child in structnode.get_children():
                ## import pdb; pdb.set_trace()
                if child.kind == CursorKind.FIELD_DECL:
                    if not child.spelling:
                        continue
                    
                    field = {}
                    t = child.type.get_canonical()
                    field['name'] = child.spelling
                    field['perltype'] = 'SUBREC'
                    field['ctype'] = child.get_children().next().get_definition().spelling
                    field['arrsize'] = t.get_array_size()
                    field['size'] = t.get_size()
                    union['fields'].append(field)
                else:
                    print "Ignoring field " + child.spelling + " in " + cursor.spelling
                    continue
            structs[name] = union
            # Recurse through the struct names
            newstructnames = [field['ctype'] for field in union['fields']]
            if debug > 1:
                pprint.pprint((name, 'requires', newstructnames), stream=fdebug)
            structs.update(get_struct_definitions(root, newstructnames, debug=debug))
        elif structnode.kind == CursorKind.ENUM_DECL:
            enum = {}
            enum['name'] = cursor.spelling
            enum['enum'] = True
            enum['keys'] = []
            for child in structnode.get_children():
                enum['keys'].append(child.spelling)
            structs[name] = enum
        else:
            print "Ignoring structure unknown kind(" + str(structnode.kind) + "): " + cursor.spelling

    # Remove duplicates
    return structs

def calculate_packed_size(structs, name, debug=0):
    struct = structs[name]
    packedsize = 0
    if debug > 2:
        print "Calculating packed size for: " + name
    if 'union' in struct:
        if debug > 2:
            print "  - union"
        for field in struct['fields']:
            perltype = field['perltype']
            if debug > 2:
                print "  - field: " + field['ctype'] + " " + field['name'] + " (" + perltype + ")"
            arrsize = max(1,field['arrsize'])
            if perltype == 'BYTE' or perltype == 'ENUM':
                structsize = field['size'] * arrsize
            elif perltype == 'SUBREC':
                structsize = calculate_packed_size(structs, field['ctype']) * arrsize
            else:
                print "Ignoring unknown perltype for union: " + perltype
            if debug > 2:
                print "  - field: " + field['ctype'] + " " + field['name'] + " (" + perltype + ") -> " + str(structsize)
            packedsize = max(packedsize, structsize)
    else:
        if debug > 2:
            print "  - struct"
        for field in struct['fields']:
            perltype = field['perltype']
            if debug > 2:
                print "  - field: " + field['ctype'] + " " + field['name'] + " (" + perltype + ")"
            arrsize = max(1,field['arrsize'])
            if perltype == 'BYTE' or perltype == 'ENUM':
                structsize = field['size'] * arrsize
            elif perltype == 'SUBREC' or perltype == 'UNION':
                structsize = calculate_packed_size(structs, field['ctype']) * arrsize
            else:
                print "Ignoring unknown perltype for non-union: " + perltype
            if debug > 2:
                print "  - field: " + field['ctype'] + " " + field['name'] + " (" + perltype + ") -> " + str(structsize)
            packedsize += structsize
    if debug > 2:
        print "Packed size for " + name + ": " + str(packedsize)
        print
    return packedsize

    
def filter_umids_by_struct_prefixes_and_enums(umids, prefixes, enums):
    filtered = []
    for umid in umids.keys():
        if umids[umid]['umid_alt_str'] in enums.keys():
            for prefix in prefixes:
                if umids[umid]['raw'][5].startswith(prefix):
                    filtered.append(umids[umid])
                    break
    return filtered

def clean_umid_structs(umids):
    for umid in umids.keys():        
        umids[umid]['raw'][5] = umids[umid]['raw'][5].replace('(','')
        umids[umid]['raw'][5] = umids[umid]['raw'][5].replace(')','')
        umids[umid]['raw'][5] = umids[umid]['raw'][5].replace('*','')

def get_umids_filtered_by_struct_and_enums(umids, prefixes, enums):
    clean_umid_structs(umids)
    filtered_umids = filter_umids_by_struct_prefixes_and_enums(umids, prefixes, enums)
    return filtered_umids
    
def write_perl_library(fname, enums, structs, umids):
    global random_number
    
    f = open(fname, 'w')
    # Write the header
    f.write("#===========================================================================\n")
    f.write("#  APS Metadata record definitions template file for sub system 68 APPS.\n")
    f.write("#\n")
    f.write("#  VERSION  DATE                WHO             DESCRIPTION\n")
    f.write("#  1.0.000  August 2nd 2013     autogen.pl      This is an autogenerated file\n")
    f.write("#\n")
    f.write("# Contact qct.lte.ml1.utils for any query\n")
    f.write("#===========================================================================\n")
    f.write("#===========================================================================\n")
    f.write("package APSSubSystem68Metadata;\n")
    f.write("use MetadataConstants;\n")
    f.write("use strict;\n")
    f.write("use warnings;\n")
    f.write("no  warnings qw(once);\n")
    f.write("\n")
    f.write("use base 'Exporter';\n")
    f.write("our $LTE_CONST;\n")
    f.write("our @EXPORT = qw($LTE_CONST);\n")
    # Write the enums
    f.write("our %LTE_CONSTANTS = (\n")
    for key in sorted(enums.keys()):
        f.write("  " + key + " => " + str(enums[key]) + ",\n")
    f.write("  LTE_PLT_COOKIE => " + str(random_number) + "\n")
    f.write(");#end of metadata constants\n")
    f.write("$LTE_CONST = \\%LTE_CONSTANTS;\n")
    # Write the log packets
    f.write("my $umid = 0;\n")
    f.write("\n")
    f.write("# ALL THE LOG PACKETS ARE ADDED IN THIS ARRAY.\n")
    f.write("# FOLLOW THE METADATA SPECIFICATION TO DEFINE THESE\n")
    f.write("# LOG PACKETS, SUBRECORDS etc.\n")
    f.write("our @LOG_68 =\n")
    f.write("(\n")
    f.write(" [\n")
    f.write("   [\'LOG_LTE_PLT\'],\n")
    f.write(" ],\n")
    f.write(");\n")
    f.write("\n")
    f.write("#######################################\n")
    f.write("# add request responses here\n")
    f.write("#######################################\n")
    f.write("our @CMD_68 =\n")
    f.write("(\n")
    f.write(" [\n")
    f.write("   [\'CMD_LTE_PLT\'],\n")
    f.write(" ],\n")
    f.write("#======================================LTE_PLT api/rsp=================================\n")
    f.write("\n")
    f.write("\n")
    for name in sorted(structs.keys()):
        lastenumname = None
        lastenumval = 0
        if 'union' in structs[name] or 'enum' in structs[name]:
            continue
        f.write("[\n")
        f.write("  ['" + name + "'],\n")
        f.write("  [\n")
        for field in structs[name]['fields']:
            if field['perltype'] == 'UNION':
                union = structs[field['ctype']]
                maxpackedsize = 0
                # Add the union fields
                for newfield in union['fields']:
                    perltype = "BYTE" if newfield['perltype'] == 'ENUM' else newfield['perltype']
                    f.write("    ")
                    f.write("['" + newfield['name'] + "'")
                    f.write(", " + perltype)
                    f.write(", '" + str(newfield['ctype'] + "'"))
                    f.write(", " + str(max(1,newfield['arrsize'])))
                    newfield['enumval'] = lastenumval
                    lastenumval += 1
                    f.write(", 0, 0, 'expr $" + lastenumname + " == " + str(newfield['enumval']) + "'")
                    f.write("],\n")
                    arrsize = max(1,field['arrsize'])
                    newfield['size'] = calculate_packed_size(structs, newfield['ctype']) * arrsize
                    maxpackedsize = max(maxpackedsize, newfield['size'])
                # Add padding fields
                for newfield in union['fields']:
                    if newfield['size'] < maxpackedsize:
                        f.write("    ")
                        f.write("['pad', BYTE, 1, ")
                        f.write(str(maxpackedsize-newfield['size']))
                        f.write(", 0, 0")
                        f.write(", 'expr $" + lastenumname + " == " + str(newfield['enumval']) + "'")
                        f.write("],\n")
            else:
                perltype = "BYTE" if field['perltype'] == 'ENUM' else field['perltype']
                # Check for size > 4bytes
                if 'size' in field and field['size'] > 4:
                    f.write("    ")
                    f.write("['" + field['name'] + "_lo'")
                    f.write(", " + perltype)
                    f.write(", 4")
                    f.write(", " + str(max(1,field['arrsize'])))
                    f.write("],\n")
                    f.write("    ")
                    f.write("['" + field['name'] + "_hi'")
                    f.write(", " + perltype)
                    f.write(", 4")
                    f.write(", " + str(max(1,field['arrsize'])))
                    f.write("],\n")
                else:
                    f.write("    ")
                    f.write("['" + field['name'] + "'")
                    f.write(", " + perltype)
                    if 'size' in field:
                        f.write(", " + str(field['size']))
                    elif 'ctype' in field:
                        f.write(", '" + str(field['ctype'] + "'"))
                    if 'double_arrsize' in field:
                        f.write(", " + str(field['arrsize'] * field['double_arrsize']))
                    else:
                        f.write(", " + str(max(1,field['arrsize'])))
                    if field['perltype'] == 'ENUM':
                        lastenumname = field['name']
                        f.write(", DEPEND")
                    f.write("],\n")
        f.write("  ],\n")
        f.write("],\n")
    f.write("[\n")
    f.write("  ['LTE_PLT_DIAG_CMD_ECHO'],\n")
    f.write("  [\n")
    f.write("    ['CMD_CODE', BYTE, 1, 1, HIDDEN|READONLY, 75],\n")
    f.write("    ['SUBSYS_ID', BYTE, 1, 1, HIDDEN|READONLY, 68],\n")
    f.write("    ['SUBSYS_CMD_CODE', BYTE, 2, 1, HIDDEN|READONLY, 0],\n")
    f.write("    ['cookie_value', BYTE, 4, 1, HIDDEN|READONLY, " + str(random_number) + "],\n")
    f.write("    ['umid', BYTE, 4, 1, DEPEND],\n")
    for umid in sorted(umids, key=lambda k: k['umid_alt_str']):
        if umid['raw'][5] not in structs:
            print "Skipping umid " + umid['umid_alt_str'] + " w/ missing struct " + umid['raw'][5]
            continue
        f.write("    ['" + umid['umid_alt_str'].lower())
        f.write("', SUBREC, '" + umid['raw'][5])
        f.write("', 1, 0, 0")
        f.write(", 'expr $umid == " + str(umid['int_value']))
        f.write("'],\n")
    f.write("  ],\n")
    f.write("\n")
    f.write("  ['LTE_PLT_DIAG_CMD_ECHO Response Message'],\n")
    f.write("  [\n")
    f.write("    ['CMD_CODE', BYTE, 1, 1, HIDDEN|READONLY, 75],\n")
    f.write("    ['SUBSYS_ID', BYTE, 1, 1, HIDDEN|READONLY, 68],\n")
    f.write("    ['SUBSYS_CMD_CODE', BYTE, 2, 1, HIDDEN|READONLY, 0],\n")
    f.write("    ['cookie_value', BYTE, 4, 1, HIDDEN|READONLY, " + str(random_number) + "],\n")
    f.write("    ['DIAG_RSP_STATUS', BYTE, 4, 1, DEPEND],\n")
    f.write("    ['TIME', BYTE, 4, 1, 0, 0, 'expr $DIAG_RSP_STATUS == 0'],\n")
    f.write("    ['umid', BYTE, 4, 1, DEPEND, 0, 'expr $DIAG_RSP_STATUS == 0'],\n")
    f.write("    ['SFN', BYTE, 2, 1, DEPEND, 0, 'expr $DIAG_RSP_STATUS == 0'],\n")
    f.write("    ['Sub_FN', BYTE, 2, 1, DEPEND, 0, 'expr $DIAG_RSP_STATUS == 0'],\n")
    for umid in sorted(umids, key=lambda k: k['umid_alt_str']):
        if umid['raw'][5] not in structs:
            continue
        f.write("    ['" + umid['umid_alt_str'].lower())
        f.write("', SUBREC, '" + umid['raw'][5])
        f.write("', 1, 0, 0")
        f.write(", 'expr $DIAG_RSP_STATUS == 0 && $umid == " + str(umid['int_value']))
        f.write("'],\n")
    f.write("  ],\n")
    f.write("],\n")
    f.write("[\n")
    f.write("  ['LTE_PLT_DIAG_CMD_STORE'],\n")
    f.write("  [\n")
    f.write("    ['CMD_CODE', BYTE, 1, 1, HIDDEN|READONLY, 75],\n")
    f.write("    ['SUBSYS_ID', BYTE, 1, 1, HIDDEN|READONLY, 68],\n")
    f.write("    ['SUBSYS_CMD_CODE', BYTE, 2, 1, HIDDEN|READONLY, 1],\n")
    f.write("    ['cookie_value', BYTE, 4, 1, HIDDEN|READONLY, " + str(random_number) + "],\n")
    f.write("    ['umid', BYTE, 4, 1, DEPEND],\n")
    for umid in sorted(umids, key=lambda k: k['umid_alt_str']):
        if umid['raw'][5] not in structs:
            continue
        f.write("    ['" + umid['umid_alt_str'].lower())
        f.write("', SUBREC, '" + umid['raw'][5])
        f.write("', 1, 0, 0")
        f.write(", 'expr $umid == " + str(umid['int_value']))
        f.write("'],\n")
    f.write("  ],\n")
    f.write("\n")
    f.write("  ['LTE_PLT_DIAG_CMD_STORE Response Message'],\n")
    f.write("  [\n")
    f.write("    ['CMD_CODE', BYTE, 1, 1, HIDDEN|READONLY, 75],\n")
    f.write("    ['SUBSYS_ID', BYTE, 1, 1, HIDDEN|READONLY, 68],\n")
    f.write("    ['SUBSYS_CMD_CODE', BYTE, 2, 1, HIDDEN|READONLY, 1],\n")
    f.write("    ['cookie_value', BYTE, 4, 1, HIDDEN|READONLY, " + str(random_number) + "],\n")
    f.write("    ['DIAG_RSP_STATUS',BYTE, 4, 1],\n")
    f.write("  ],\n")
    f.write("],\n")
    f.write("[\n")
    f.write("  ['LTE_PLT_DIAG_CMD_RUN'],\n")
    f.write("  [\n")
    f.write("    ['CMD_CODE', BYTE, 1, 1, HIDDEN|READONLY, 75],\n")
    f.write("    ['SUBSYS_ID', BYTE, 1, 1, HIDDEN|READONLY, 68],\n")
    f.write("    ['SUBSYS_CMD_CODE', BYTE, 2, 1, HIDDEN|READONLY, 2],\n")
    f.write("    ['cookie_value', BYTE, 4, 1, HIDDEN|READONLY, " + str(random_number) + "],\n")
    f.write("  ],\n")
    f.write("\n")
    f.write("  ['LTE_PLT_DIAG_CMD_RUN Response Message'],\n")
    f.write("  [\n")
    f.write("    ['CMD_CODE', BYTE, 1, 1, HIDDEN|READONLY, 75],\n")
    f.write("    ['SUBSYS_ID', BYTE, 1, 1, HIDDEN|READONLY, 68],\n")
    f.write("    ['SUBSYS_CMD_CODE', BYTE, 2, 1, HIDDEN|READONLY, 2],\n")
    f.write("    ['cookie_value', BYTE, 4, 1, HIDDEN|READONLY, " + str(random_number) + "],\n")
    f.write("    ['DIAG_RSP_STATUS',BYTE, 4, 1],\n")
    f.write("  ],\n")
    f.write("],\n")
    f.write("[\n")
    f.write("  ['LTE_PLT_DIAG_CMD_FETCH'],\n")
    f.write("  [\n")
    f.write("    ['CMD_CODE', BYTE, 1, 1, HIDDEN|READONLY, 75],\n")
    f.write("    ['SUBSYS_ID', BYTE, 1, 1, HIDDEN|READONLY, 68],\n")
    f.write("    ['SUBSYS_CMD_CODE', BYTE, 2, 1, HIDDEN|READONLY, 3],\n")
    f.write("    ['cookie_value', BYTE, 4, 1, HIDDEN|READONLY, " + str(random_number) + "],\n")
    f.write("  ],\n")
    f.write("\n")
    f.write("  ['LTE_PLT_DIAG_CMD_FETCH Response Message'],\n")
    f.write("  [\n")
    f.write("    ['CMD_CODE', BYTE, 1, 1, HIDDEN, 75],\n")
    f.write("    ['SUBSYS_ID', BYTE, 1, 1, HIDDEN, 68],\n")
    f.write("    ['SUBSYS_CMD_CODE', BYTE, 2, 1, HIDDEN, 3],\n")
    f.write("    ['cookie_value', BYTE, 4, 1, HIDDEN|READONLY, " + str(random_number) + "],\n")
    f.write("    ['DIAG_RSP_STATUS', BYTE, 4, 1, DEPEND],\n")
    f.write("    ['time', BYTE, 4, 1, 0, 0, 'expr $DIAG_RSP_STATUS == 0'],\n")
    f.write("    ['umid', BYTE, 4, 1, DEPEND, 0, 'expr $DIAG_RSP_STATUS == 0'],\n")
    f.write("    ['SFN', BYTE, 2, 1, DEPEND, 0, 'expr $DIAG_RSP_STATUS == 0'],\n")
    f.write("    ['Sub_FN', BYTE, 2, 1, DEPEND, 0, 'expr $DIAG_RSP_STATUS == 0'],\n")
    for umid in sorted(umids, key=lambda k: k['umid_alt_str']):
        if umid['raw'][5] not in structs:
            continue
        f.write("    ['" + umid['umid_alt_str'].lower())
        f.write("', SUBREC, '" + umid['raw'][5])
        f.write("', 1, 0, 0")
        f.write(", 'expr $DIAG_RSP_STATUS == 0 && $umid == " + str(umid['int_value']))
        f.write("'],\n")
    f.write("  ],\n")
    f.write("],\n")
    f.write("[\n")
    f.write("  ['LTE_PLT_DIAG_CMD_VERSION'],\n")
    f.write("  [\n")
    f.write("    ['CMD_CODE', BYTE, 1, 1, HIDDEN|READONLY, 75],\n")
    f.write("    ['SUBSYS_ID', BYTE, 1, 1, HIDDEN|READONLY, 68],\n")
    f.write("    ['SUBSYS_CMD_CODE', BYTE, 2, 1, HIDDEN|READONLY, 4],\n")
    f.write("  ],\n")
    f.write("\n")
    f.write("  ['LTE_PLT_DIAG_CMD_VERSION Response Message'],\n")
    f.write("  [\n")
    f.write("    ['CMD_CODE', BYTE, 1, 1, HIDDEN, 75],\n")
    f.write("    ['SUBSYS_ID', BYTE, 1, 1, HIDDEN, 68],\n")
    f.write("    ['SUBSYS_CMD_CODE', BYTE, 2, 1, HIDDEN, 4],\n")
    f.write("    ['cookie_value', BYTE, 4, 1, HIDDEN|READONLY, " + str(random_number) + "],\n")
    f.write("    ['diag_rsp_status', BYTE, 4, 1, DEPEND], \n")
    f.write("    ['version', BYTE, 4, 1, DEPEND],     \n")
    f.write("  ],\n")
    f.write("],\n")
    f.write(");\n")
    f.write("\n")
    f.write("1;\n")
    f.write("\n")
    # Close the file
    f.close()


def write_c_pack_unpack(f, structname, structs, prefix1, prefix2):
    struct = structs[structname]
    # Some extra prefixes
    prefix3 = ""
    if prefix2 == "pack":
        prefix3 = "packed_"
    # Check to see if we have sub-structs
    have_substructs = False
    for field in struct['fields']:
        if field['perltype'] == 'SUBREC':
            have_substructs = True
    # Check to see if we have unions
    have_unions = False
    for field in struct['fields']:
        if field['perltype'] == 'UNION':
            have_unions = True
    # Check to see if we have arrays
    have_arrays = False
    have_double_arrays = False
    for field in struct['fields']:
        if field['arrsize'] > 0:
            have_arrays = True
        if 'double_arrsize' in field:
            have_double_arrays = True
    # Write the function
    f.write("static lte_plt_autogen_result_enum_type " + prefix1 + "_" + structname)
    f.write("(uint32 " + prefix2 + "ed_msg_len, void* " + prefix2 + "ed_msg_ptr")
    f.write(", uint32 *" + prefix1 + "ed_msg_len, void* " + prefix1 + "ed_msg_ptr)\n")
    f.write("{\n")
    if have_substructs or have_unions:
        f.write("  uint32 pass_" + prefix2 + "_msg_len;\n")
        f.write("  uint32 ret_" + prefix1 + "_msg_len;\n")
        f.write("  lte_plt_autogen_result_enum_type status;\n")
        f.write("\n")
    if have_arrays:
        f.write("  uint32 index0;\n")
        if have_double_arrays:
            f.write("  uint32 index1;\n")
        f.write("\n")
    f.write("  " + structname + " *unpacked_msg;\n")
    f.write("  packed_" + structname + " *packed_msg;\n")
    f.write("\n")
    f.write("  unpacked_msg = (" + structname + " *) unpacked_msg_ptr;\n")
    f.write("  packed_msg   = (packed_" + structname + " *) packed_msg_ptr;\n")
    f.write("\n")
    f.write("  if(" + prefix2 + "ed_msg_len != sizeof(" + prefix3 + structname + "))\n")
    f.write("  {\n")
    f.write("    return AUTOGEN_RESULT_BAD_MSG_LEN;\n")
    f.write("  }\n")
    f.write("\n")
    f.write("  /* Assign " + prefix1 + "ed structure elements to " + prefix2 + "ed */\n")
    f.write("\n")
    # Iterate through the fields
    lastenumname = ''
    lastenumtype = ''
    for field in struct['fields']:
        if field['perltype'] == 'ENUM':
            lastenumname = field['name']
            lastenumtype = field['ctype']
        spaces = 2*' '
        if field['arrsize'] > 0:
            spaces = 4*' '
            f.write("\n")
            f.write("  for(index0 = 0 ; index0 < " + str(field['arrsize']) + " ; index0++)\n")
            f.write("  {\n")
            if 'double_arrsize' in field:
                spaces = 6*' '
                f.write("    for(index1 = 0 ; index1 < " + str(field['double_arrsize']) + " ; index1++)\n")
                f.write("    {\n")
        if field['perltype'] == 'SUBREC':
            f.write(spaces + "pass_" + prefix2 + "_msg_len = sizeof(" + prefix3 + field['ctype'] + ");\n")
            f.write(spaces + "status = " + prefix1 + "_" + field['ctype'])
            f.write("(pass_" + prefix2 + "_msg_len,(void *)&" + prefix2 + "ed_msg->" + field['name'])
            if field['arrsize'] > 0:
                f.write("[index0]")
            f.write(",&ret_" + prefix1 + "_msg_len,(void *)&" + prefix1 + "ed_msg->" + field['name'])
            if field['arrsize'] > 0:
                f.write("[index0]")
            f.write(");\n")
            f.write("\n")
            f.write(spaces + "if (status != AUTOGEN_RESULT_SUCCESS)\n")
            f.write(spaces + "{\n");
            f.write(spaces + "  return status;\n")
            f.write(spaces + "}\n")
            if not field['arrsize'] > 0:
                f.write("\n")
        elif field['perltype'] == 'UNION':
            f.write("\n")
            f.write(spaces + "switch(" + prefix2 + "ed_msg->" + lastenumname + ")\n")
            f.write(spaces + "{\n")
            union = structs[field['ctype']]
            enum  = structs[lastenumtype]
            index = 0
            for unionfield in union['fields']:
                f.write(spaces + "  case " + enum['keys'][index] + ":\n")
                f.write(spaces + "    pass_" + prefix2 + "_msg_len = sizeof(" + prefix3 + unionfield['ctype'] + ");\n")
                f.write(spaces + "    status = " + prefix1 + "_" + unionfield['ctype'])
                f.write("(pass_" + prefix2 + "_msg_len,(void *)&" + prefix2 + "ed_msg->" + field['name'] + "." + unionfield['name'])
                f.write(",&ret_" + prefix1 + "_msg_len,(void *)&" + prefix1 + "ed_msg->" + field['name'] + "." + unionfield['name'] + ");\n")
                f.write("\n")
                f.write(spaces + "    if (status != AUTOGEN_RESULT_SUCCESS)\n")
                f.write(spaces + "    {\n")
                f.write(spaces + "      return status;\n")
                f.write(spaces + "    }\n")
                f.write("\n")
                f.write(spaces + "    break;\n")
                f.write("\n")
                index += 1
            f.write(spaces + "  default:\n")
            if prefix1 == "pack":
                unionfield = union['fields'][0]
                f.write(spaces + "    /* In case that we have uninitialized data which happens do be invalid, we want to avoid crashing\n")
                f.write(spaces + "       ASIA. We recursively set any Enums to 'default' value and any remaining data set to 0xBA */\n")
                f.write(spaces + "    memset(packed_msg, 0xBA, sizeof(" + unionfield['ctype'] + "));\n")
                f.write(spaces + "    packed_msg->" + lastenumname + " = " + enum['keys'][0] + ";\n")
                f.write(spaces + "    pass_unpack_msg_len = sizeof(" + unionfield['ctype'] + ");\n")
                f.write(spaces + "    status = pack_" + unionfield['ctype'])
                f.write("(pass_unpack_msg_len,(void *)&unpacked_msg->" + field['name'] + "." + unionfield['name'])
                f.write(",&ret_pack_msg_len,(void *)&packed_msg->" + field['name'] + "." + unionfield['name'] + ");\n")
                f.write("\n")
                f.write(spaces + "    if (status != AUTOGEN_RESULT_SUCCESS)\n")
                f.write(spaces + "    {\n")
                f.write(spaces + "      return status;\n")
                f.write(spaces + "    }\n")
            f.write(spaces + "    break;/* Error handling */\n")
            f.write(spaces + "}\n")
        else:
            f.write(spaces + prefix1 + "ed_msg->" + field['name'])
            if field['arrsize'] > 0:
                f.write("[index0]")
                if 'double_arrsize' in field:
                    f.write("[index1]")
            f.write(" = " + prefix2 + "ed_msg->" + field['name'])
            if field['arrsize'] > 0:
                f.write("[index0]")
                if 'double_arrsize' in field:
                    f.write("[index1]")
            f.write(";\n")
        if field['arrsize'] > 0:
            if 'double_arrsize' in field:
                f.write("    }\n")
            f.write("  }\n")
        if field['arrsize'] == 0:
            f.write("  " + prefix1 + "ed_msg->" + field['name'] + " = " + prefix2 + "ed_msg->" + field['name'] + ";\n")
    f.write("\n")
    f.write("  *" + prefix1 + "ed_msg_len = sizeof(" + (prefix1+"ed_" if prefix1=="pack" else "") + structname + ");\n")
    f.write("\n")
    f.write("  return AUTOGEN_RESULT_SUCCESS;\n")
    f.write("}\n")
    f.write("\n")


def write_c_union(f, structs, unionname, structsprinted):
    if unionname in structsprinted:
        return
    else:
        structsprinted.append(unionname)

    union = structs[unionname]
    # Make sure that all dependent structs have been printed
    for field in union['fields']:
        if field['perltype'] == 'SUBREC':
            write_c_struct(f, structs, field['ctype'], structsprinted)
        elif field['perltype'] == 'UNION':
            write_c_union(f, structs, field['ctype'], structsprinted)
    # Packed union definition 
    f.write("typedef PACK(union)\n")
    f.write("{\n")
    for field in union['fields']:
        f.write("  ")
        if field['perltype'] == 'SUBREC':
            f.write("packed_" + field['ctype'] + " " + field['name'])
        else:
            f.write(field['ctype'] + " " + field['name'])
        if field['arrsize'] > 0:
            f.write("[" + str(field['arrsize']) + "]")
        if 'double_arrsize' in field:
            f.write("[" + str(field['double_arrsize']) + "]")
        f.write(";\n")
    f.write("}packed_" + unionname + ";\n")
    f.write("\n")
    
def write_c_struct(f, structs, structname, structsprinted):
    if structname in structsprinted:
        return
    else:
        structsprinted.append(structname)

    struct = structs[structname]
    # See if any fields use anonymous structures and if so, ignore
    if 'no_c_code' in struct:
        return
    # Make sure that all dependent structs have been printed
    for field in struct['fields']:
        if field['perltype'] == 'SUBREC':
            write_c_struct(f, structs, field['ctype'], structsprinted)
        elif field['perltype'] == 'UNION':
            write_c_union(f, structs, field['ctype'], structsprinted)
    # If an anonymous structure, write an unpacked version here
    if structname.startswith(ANONYMOUS_PREFIX):
        f.write("typedef struct\n")
        f.write("{\n")
        for field in struct['fields']:
            f.write("  ")
            if field['perltype'] == 'SUBREC' or field['perltype'] == 'UNION':
                f.write("packed_" + field['ctype'] + " " + field['name'])
            else:
                f.write(field['ctype'] + " " + field['name'])
            if field['arrsize'] > 0:
                f.write("[" + str(field['arrsize']) + "]")
            if 'double_arrsize' in field:
                f.write("[" + str(field['double_arrsize']) + "]")
            f.write(";\n")
        f.write("}" + structname + ";\n")
        f.write("\n")
    # Packed struct definition 
    f.write("typedef PACK(struct)\n")
    f.write("{\n")
    for field in struct['fields']:
        f.write("  ")
        if field['perltype'] == 'SUBREC' or field['perltype'] == 'UNION':
            f.write("packed_" + field['ctype'] + " " + field['name'])
        else:
            f.write(field['ctype'] + " " + field['name'])
        if field['arrsize'] > 0:
            f.write("[" + str(field['arrsize']) + "]")
        if 'double_arrsize' in field:
            f.write("[" + str(field['double_arrsize']) + "]")
        f.write(";\n")
    f.write("}packed_" + structname + ";\n")
    f.write("\n")
    # Unpack routine
    write_c_pack_unpack(f, structname, structs, "unpack", "pack")
    # Pack routine
    write_c_pack_unpack(f, structname, structs, "pack", "unpack")
    
def write_c_file(fname, structs, umids):
    global random_number

    f = open(fname, 'w')
    # Write the header
    f.write("/*!\n")
    f.write("  \n")
    f.write("  lte_plt_autogen_pack_unpack.c\n")
    f.write("\n")
    f.write("  \n")
    f.write("  This file contains LTE PLT autogenerated pack/ unpack routines\n")
    f.write("\n")
    f.write("  \n")
    f.write("  description of functions in this file\n")
    f.write(" \n")
    f.write("*/\n")
    f.write("\n")
    f.write("/*===========================================================================\n")
    f.write("\n")
    f.write("  Copyright (c) 2008 QUALCOMM Incorporated. All Rights Reserved\n")
    f.write("\n")
    f.write("  Qualcomm Proprietary\n")
    f.write("\n")
    f.write("  Export of this technology or software is regulated by the U.S. Government.\n")
    f.write("  Diversion contrary to U.S. law prohibited.\n")
    f.write("\n")
    f.write("  All ideas, data and information contained in or disclosed by\n")
    f.write("  this document are confidential and proprietary information of\n")
    f.write("  QUALCOMM Incorporated and all rights therein are expressly reserved.\n")
    f.write("  By accepting this material the recipient agrees that this material\n")
    f.write("  and the information contained therein are held in confidence and in\n")
    f.write("  trust and will not be used, copied, reproduced in whole or in part,\n")
    f.write("  nor its contents revealed in any manner to others without the express\n")
    f.write("  written permission of QUALCOMM Incorporated.\n")
    f.write("\n")
    f.write("===========================================================================*/\n")
    f.write("\n")
    f.write("/*===========================================================================\n")
    f.write("\n")
    f.write("                        EDIT HISTORY FOR MODULE\n")
    f.write("\n")
    f.write("This section contains comments describing changes made to the module.\n")
    f.write("Notice that changes are listed in reverse chronological order.\n")
    f.write("\n")
    f.write("when       who     what, where, why\n")
    f.write("--------   ---     ----------------------------------------------------------\n")
    f.write("09/30/13   Autogenerated      Do  not modify this file\n")
    f.write("===========================================================================*/\n")
    f.write("\n")
    f.write("\n")
    f.write("/*lint -save -e641*/\n")
    f.write("\n")
    f.write("#include \"lte_plt_autogen_pack_unpack.h\" \n")
    f.write("\n")
    # lte_plt_autogen_get_rsp_umid: List of UMIDS
    f.write("void lte_plt_autogen_get_rsp_umid (int *num_umids_ptr, msgr_umid_type *umids )\n")
    f.write("{\n")
    f.write("  *num_umids_ptr = 0;\n")
    structstoprint = []
    for umid in sorted(umids, key=lambda k: k['umid_alt_str']):
        if umid['raw'][5] in structs:
            structstoprint.append(umid['raw'][5])
            f.write("  *umids = " + umid['umid_alt_str'] + ";\n")
            f.write("  umids++;\n")
            f.write("  (*num_umids_ptr)++;\n")
            f.write("\n")
        else:
            print "Skipping UMID due to missing data struct: " + umid['umid_alt_str'] + " -> " + umid['raw'][5] 
    f.write("}\n")
    f.write("\n")
    f.write("\n")
    f.write("int lte_plt_autogen_get_cookie ( void )\n")
    f.write("{\n")
    f.write("  return " + hex(random_number) + ";\n")
    f.write("}\n")
    f.write("\n")
    # Packed data structures and pack/unpack routines
    structsprinted = []
    for structname in sorted(structstoprint):
        write_c_struct(f, structs, structname, structsprinted)
    # lte_plt_autogen_unpack
    f.write("lte_plt_autogen_result_enum_type lte_plt_autogen_unpack\n")
    f.write("(\n")
    f.write("  msgr_umid_type umid, \n")
    f.write("  uint32 packed_msg_len, \n")
    f.write("  void *packed_msg_ptr, \n")
    f.write("  uint32 *unpacked_msg_len, \n")
    f.write("  void *unpacked_msg_ptr\n")
    f.write(")\n")
    f.write("{\n")
    f.write("  lte_plt_autogen_result_enum_type status = AUTOGEN_RESULT_SUCCESS;\n")
    f.write("\n")
    f.write("  switch (umid)\n")
    f.write("  {\n")
    for umid in sorted(umids, key=lambda k: k['umid_alt_str']):
        if umid['raw'][5] in structs and 'no_c_code' not in structs[umid['raw'][5]]:
            f.write("    case " + umid['umid_alt_str'] + ":\n")
            f.write("      status = unpack_" + umid['raw'][5] + "(packed_msg_len, packed_msg_ptr, unpacked_msg_len, unpacked_msg_ptr);\n")
            f.write("      break;\n")
            f.write("\n")
    f.write("    default:\n")
    f.write("      if (packed_msg_len != 0)\n")
    f.write("      {\n")
    f.write("        status = AUTOGEN_RESULT_UNKNOWN_UMID;\n")
    f.write("      }\n")
    f.write("\n")
    f.write("      break;\n")
    f.write("  }\n")
    f.write("\n")
    f.write("  return status;\n")
    f.write("}\n")
    f.write("\n")
    f.write("\n")
    # lte_plt_autogen_pack
    f.write("lte_plt_autogen_result_enum_type lte_plt_autogen_pack\n")
    f.write("(\n")
    f.write("  msgr_umid_type umid, \n")
    f.write("  uint32 unpacked_msg_len, \n")
    f.write("  void *unpacked_msg_ptr, \n")
    f.write("  uint32 *packed_msg_len, \n")
    f.write("  void *packed_msg_ptr\n")
    f.write(")\n")
    f.write("{\n")
    f.write("  lte_plt_autogen_result_enum_type status = AUTOGEN_RESULT_SUCCESS;\n")
    f.write("\n")
    f.write("  switch (umid)\n")
    f.write("  {\n")
    for umid in sorted(umids, key=lambda k: k['umid_alt_str']):
        if umid['raw'][5] in structs and 'no_c_code' not in structs[umid['raw'][5]]:
            f.write("    case " + umid['umid_alt_str'] + ":\n")
            f.write("      status = pack_" + umid['raw'][5] + "(unpacked_msg_len, unpacked_msg_ptr, packed_msg_len, packed_msg_ptr);\n")
            f.write("      break;\n")
            f.write("\n")
    f.write("     default:\n")
    f.write("        if (packed_msg_len != 0)\n")
    f.write("        {\n")
    f.write("          status = AUTOGEN_RESULT_UNKNOWN_UMID;\n")
    f.write("        }\n")
    f.write("\n")
    f.write("        break;\n")
    f.write("  }\n")
    f.write("\n")
    f.write("  return status;\n")
    f.write("}\n")
    f.write("\n")
    f.write("\n")
    # Verification stuff
    f.write("typedef enum\n")
    f.write("{\n")
    f.write("   AUTOGEN_PACK_UNPACK_SUCCESS,\n")
    f.write("   AUTOGEN_PACK_UNPACK_FAILED\n")
    f.write("}autogen_pack_unpack_result_type_enum;\n")
    f.write("\n")
    f.write("static autogen_pack_unpack_result_type_enum verify_pack_unpack(uint8 *reference_api, uint8 *packed_unpacked_api, uint32 length)\n")
    f.write("{\n")
    f.write("  uint32 index;\n")
    f.write("  uint32 index1;\n")
    f.write("\n")
    f.write("  for (index = 0;index < length; index ++) \n")
    f.write("  {\n")
    f.write("    if (reference_api[index] != packed_unpacked_api[index]) \n")
    f.write("    {\n")
    f.write("      for (index1 = 0; index1 < length; index1++) \n")
    f.write("      {\n")
    f.write("         printf(\"\\n ref_api is %d packed_unpacked is :%d \",(int)reference_api[index1],(int)packed_unpacked_api[index1]);\n")
    f.write("      }\n")
    f.write("      printf(\"\\n Length is :%d\",(int)length);\n")
    f.write("      printf(\"\\n Index failed at :%d\",(int)index);\n")
    f.write("      printf(\"\\n ref_api was %d packed_unpacked was :%d \",(int)reference_api[index],(int)packed_unpacked_api[index]);\n")
    f.write("      return AUTOGEN_PACK_UNPACK_FAILED;\n")
    f.write("    }\n")
    f.write("  }\n")
    f.write("  return AUTOGEN_PACK_UNPACK_SUCCESS;\n")
    f.write("}\n")
    f.write("\n")
    f.write("/* Returns the number of tests failed */\n")
    f.write("\n")
    f.write("uint8 ref_msg[1024];\n")
    f.write("uint8 unpacked_msg[1024];\n")
    f.write("uint8 packed_msg[1024];\n")
    f.write("uint8 passed_msg[1024];\n")
    f.write("\n")
    f.write("int lte_plt_autogen_pack_unpack_unit_test( void )\n")
    f.write("{\n")
    f.write("  int tests_failed = 0;\n")
    f.write("  int tests_passed = 0;\n")
    f.write("  \n")
    f.write("  uint32 index;\n")
    f.write("  uint32 umid;\n")
    f.write("  lte_plt_autogen_result_enum_type status;\n")
    f.write("  uint32 unpacked_length = 0;\n")
    f.write("  uint32 packed_length = 0;\n")
    f.write("  autogen_pack_unpack_result_type_enum pack_unpack_status = AUTOGEN_PACK_UNPACK_SUCCESS;\n")
    f.write("\n")
    f.write("  for (index = 0; index < 1024; index ++) \n")
    f.write("  {\n")
    f.write("    ref_msg[index] = passed_msg[index] = (uint8)index;\n")
    f.write("    unpacked_msg[index] = packed_msg[index] = 0;\n")
    f.write("  }\n")
    f.write("\n")
    for umid in sorted(umids, key=lambda k: k['umid_alt_str']):
        if umid['raw'][5] in structs and 'no_c_code' not in structs[umid['raw'][5]]:
            f.write("\n")
            f.write("  umid = " + umid['umid_alt_str'] + ";\n")
            f.write("  \n")
            f.write("  if(umid == LTE_CPHY_CONN_MEAS_CFG_REQ)\n")
            f.write("  {\n")
            f.write("    tests_passed++;\n")
            f.write("  }\n")
            f.write("  else\n")
            f.write("  {\n")
            f.write("    status = lte_plt_autogen_unpack(umid, sizeof(packed_" + umid['raw'][5] + "), (void *) &passed_msg[0], &unpacked_length, (void *) &unpacked_msg[0]);\n")
            f.write("    \n")
            f.write("    if(status == AUTOGEN_RESULT_SUCCESS)\n")
            f.write("    {\n")
            f.write("      status = lte_plt_autogen_pack(umid,unpacked_length,(void *)&unpacked_msg[0],&packed_length,(void *)&packed_msg[0]);\n")
            f.write("    }\n")
            f.write("    else\n")
            f.write("    {\n")
            f.write("      printf(\"\\n For " + umid['umid_alt_str'] + ", unpacking failed\");\n")
            f.write("    }\n")
            f.write("    \n")
            f.write("    if(status == AUTOGEN_RESULT_SUCCESS) \n")
            f.write("    {\n")
            f.write("      pack_unpack_status = verify_pack_unpack(&ref_msg[0],&packed_msg[0],packed_length);\n")
            f.write("    }\n")
            f.write("    else\n")
            f.write("    {\n")
            f.write("      printf(\"\\n For " + umid['umid_alt_str'] + ", packing failed\");\n")
            f.write("    }\n")
            f.write("    \n")
            f.write("    if(pack_unpack_status == AUTOGEN_PACK_UNPACK_FAILED) \n")
            f.write("    {\n")
            f.write("      printf(\"\\n For " + umid['umid_alt_str'] + ", verify failed\");\n")
            f.write("      tests_failed++;\n")
            f.write("    }\n")
            f.write("    else if(pack_unpack_status == AUTOGEN_PACK_UNPACK_SUCCESS)\n")
            f.write("    {\n")
            f.write("       tests_passed++;\n")
            f.write("    }\n")
            f.write("    else\n")
            f.write("    {\n")
            f.write("      printf(\"\\n Error with status\");\n")
            f.write("    }\n")
            f.write("  }\n")
    f.write("  printf(\"\\n Tests passed: %d, tests failed: %d\",tests_passed,tests_failed);\n")
    f.write("  return tests_failed;\n")
    f.write("}\n")
    f.write("\n")
    f.write("/*lint -restore*/\n")
    # Close the file
    f.close()

    
def main():
    import random

    global random_number
    global options, args
    
    print "Loading clang Module: " + clang_mod
    Config.set_library_file(clang_mod)
    print "Args passed:"
    for in_arr in args:
        print in_arr

    # Open debug file
    global fdebug
    if options.debug > 0:
        fdebug = open(os.path.basename(args[0])+'.py', "w")
 
    # Random number generation
    random.seed()
    ## random_number = random.randint(0,0x7FFFFFFF)
    random_number = 100

    # Parse the input file
    index = Index.create()
    tu = index.parse(None, args)
    if not tu:
        parser.error("unable to load input")

    # Load the XMLs
    umids   = {}
    modules = []
    if options.xmls:         
        for xml in options.xmls:
          xml_handle = open(xml, 'r')
          xmldict    = json.load(xml_handle)
          umids.update(xmldict)

    # Get the list of enums
    enumdefs = get_enums(tu.cursor)

    # Get list of filtered umids
    umiddefs = get_umids_filtered_by_struct_and_enums(umids, UMID_STRUCT_PREFIXES, enumdefs)

    # Debugging
    if options.debug > 0:
        pprint.pprint(('umids', umids), stream=fdebug)
        #pprint.pprint(('modules', modules), stream=fdebug)
    
    # Lookup structs based on list obtained from XML
    structs = list(set([u['raw'][5] for u in umiddefs]))
    structdefs = get_struct_definitions(tu.cursor, sorted(structs), debug=options.debug)
    ## structdefs = get_struct_definitions(tu.cursor, ["lte_cphy_hrpd_meas_results_cnf_s"], debug=options.debug)

    if options.debug > 0:
        pprint.pprint(('structs', structs), stream=fdebug)
        pprint.pprint(('structdefs', structdefs), stream=fdebug)

    # Write perl library
    if options.perl_output:
        write_perl_library(options.perl_output, enumdefs, structdefs, umiddefs)
    else:
        print "Skipping Perl library generation"

    # Write C file
    if options.c_output:
        write_c_file(options.c_output, structdefs, umiddefs)
    else:
        print "Skipping C file generation"

    # More debugging
    if options.debug > 1:
        pprint.pprint(('diags', map(get_diag_info, tu.diagnostics)), stream=fdebug)
        structnames  = []
        structnames.append("msgr_hdr_struct_type")
        structnames.append("msgr_hdr_s")
        structnames.append("msgr_spr_loopback_s")
        structnames.append("lte_LL1_dl_pbch_result_ind_struct")
        structnames.append("lte_LL1_dl_pdcch_ind_struct")
        structnames.append("lte_LL1_log_serving_cell_com_loop_records")
        structnames.append("lte_cphy_conn_meas_report_list_s")
        structnames.append("lte_cphy_band_scan_cnf_s")
        structnames.append("lte_cphy_gps_event_cb_req_s")
        structnames.append("lte_cphy_hrpd_meas_results_cnf_s")
        structnames.append("lte_cphy_band_scan_req_params_s")
        structnames.append("lte_LL1_log_demfront_serving_cell_rs_ind_struct")
        structnames.append("lte_LL1_csf_sched_chan_type")
        for struct in structnames:
            pprint.pprint((struct, get_info(find_child(tu.cursor, [struct]))), stream=fdebug)
        if options.debug > 2:
            pprint.pprint(('nodes', get_info(tu.cursor)), stream=fdebug)


    if options.debug > 0:
        # Close debug file
        fdebug.close()

if __name__ == '__main__':
    main()
