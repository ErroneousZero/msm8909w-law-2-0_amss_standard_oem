/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

                            H D R B C R S D
                     

GENERAL DESCRIPTION
   Reed Solomon Decoder for N = 16(k=12,13,14), 32(K=26,26)
   
EXTERNALIZED FUNCTIONS

INITIALIZATION AND SEQUENCING REQUIREMENTS

Copyright (c) 2002 by Qualcomm Technologies, Incorporated.  All Rights Reserved.
Copyright (c) 2003 by Qualcomm Technologies, Incorporated.  All Rights Reserved.
Copyright (c) 2004 by Qualcomm Technologies, Incorporated.  All Rights Reserved.
Copyright (c) 2005 by Qualcomm Technologies, Incorporated.  All Rights Reserved.
*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/

/*===========================================================================

                        EDIT HISTORY FOR MODULE

$Header: //commercial/MPSS.JO.2.0.c1.4/Main/modem_proc/hdr/bc/src/hdrbcrsd.c#1 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
02/10/05   etv     Fixed lint errors. 
02/02/05   etv     Fixed coding style to match conventions.
06/10/04   kss     Corrected RS matrix tables.
06/07/04   kss     Fixed antilog table (last entry was missing).
04/04/04   kss     Ported from corporate code.

===========================================================================*/


/*===========================================================================

                        INCLUDE FILES FOR MODULE

===========================================================================*/
#include "hdr_variation.h"
#include "comdef.h"
#include "dsm.h"

#include "customer.h"
#ifdef FEATURE_HDR_BCMCS
#include "hdrbcrsd.h"
#include "hdrdebug.h"


/*===========================================================================

            DEFINITIONS AND DECLARATIONS FOR MODULE

This section contains local definitions for constants, macros, types,
variables and other items needed by this module.

===========================================================================*/

#define K_MAX   28  /* Maximum number of information symbols per codeword */
#define R_MAX    8  /* Maximum number of parity packets */
#define NUM_CW 125  /* Number of bytes per packet       */

/*---------------------------------------------------------------------------
        Constant Definitions
---------------------------------------------------------------------------*/

/* GF Log table */
LOCAL const uint8 gflogtable[256] = 
{
  0x00, 0x00, 0x01, 0x19, 0x02, 0x32, 0x1a, 0xc6, 
  0x03, 0xdf, 0x33, 0xee, 0x1b, 0x68, 0xc7, 0x4b, 
  0x04, 0x64, 0xe0, 0x0e, 0x34, 0x8d, 0xef, 0x81, 
  0x1c, 0xc1, 0x69, 0xf8, 0xc8, 0x08, 0x4c, 0x71, 
  0x05, 0x8a, 0x65, 0x2f, 0xe1, 0x24, 0x0f, 0x21, 
  0x35, 0x93, 0x8e, 0xda, 0xf0, 0x12, 0x82, 0x45, 
  0x1d, 0xb5, 0xc2, 0x7d, 0x6a, 0x27, 0xf9, 0xb9,
  0xc9, 0x9a, 0x09, 0x78, 0x4d, 0xe4, 0x72, 0xa6, 
  0x06, 0xbf, 0x8b, 0x62, 0x66, 0xdd, 0x30, 0xfd,
  0xe2, 0x98, 0x25, 0xb3, 0x10, 0x91, 0x22, 0x88, 
  0x36, 0xd0, 0x94, 0xce, 0x8f, 0x96, 0xdb, 0xbd, 
  0xf1, 0xd2, 0x13, 0x5c, 0x83, 0x38, 0x46, 0x40, 
  0x1e, 0x42, 0xb6, 0xa3, 0xc3, 0x48, 0x7e, 0x6e, 
  0x6b, 0x3a, 0x28, 0x54, 0xfa, 0x85, 0xba, 0x3d, 
  0xca, 0x5e, 0x9b, 0x9f, 0x0a, 0x15, 0x79, 0x2b, 
  0x4e, 0xd4, 0xe5, 0xac, 0x73, 0xf3, 0xa7, 0x57, 
  0x07, 0x70, 0xc0, 0xf7, 0x8c, 0x80, 0x63, 0x0d, 
  0x67, 0x4a, 0xde, 0xed, 0x31, 0xc5, 0xfe, 0x18, 
  0xe3, 0xa5, 0x99, 0x77, 0x26, 0xb8, 0xb4, 0x7c, 
  0x11, 0x44, 0x92, 0xd9, 0x23, 0x20, 0x89, 0x2e, 
  0x37, 0x3f, 0xd1, 0x5b, 0x95, 0xbc, 0xcf, 0xcd, 
  0x90, 0x87, 0x97, 0xb2, 0xdc, 0xfc, 0xbe, 0x61, 
  0xf2, 0x56, 0xd3, 0xab, 0x14, 0x2a, 0x5d, 0x9e, 
  0x84, 0x3c, 0x39, 0x53, 0x47, 0x6d, 0x41, 0xa2, 
  0x1f, 0x2d, 0x43, 0xd8, 0xb7, 0x7b, 0xa4, 0x76, 
  0xc4, 0x17, 0x49, 0xec, 0x7f, 0x0c, 0x6f, 0xf6, 
  0x6c, 0xa1, 0x3b, 0x52, 0x29, 0x9d, 0x55, 0xaa,
  0xfb, 0x60, 0x86, 0xb1, 0xbb, 0xcc, 0x3e, 0x5a, 
  0xcb, 0x59, 0x5f, 0xb0, 0x9c, 0xa9, 0xa0, 0x51, 
  0x0b, 0xf5, 0x16, 0xeb, 0x7a, 0x75, 0x2c, 0xd7, 
  0x4f, 0xae, 0xd5, 0xe9, 0xe6, 0xe7, 0xad, 0xe8, 
  0x74, 0xd6, 0xf4, 0xea, 0xa8, 0x50, 0x58, 0xaf
};


/* GF Antilog table */
LOCAL const uint8 gfantilogtable[510] = 
{
  0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 
  0x1d, 0x3a, 0x74, 0xe8, 0xcd, 0x87, 0x13, 0x26, 
  0x4c, 0x98, 0x2d, 0x5a, 0xb4, 0x75, 0xea, 0xc9, 
  0x8f, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 
  0x9d, 0x27, 0x4e, 0x9c, 0x25, 0x4a, 0x94, 0x35, 
  0x6a, 0xd4, 0xb5, 0x77, 0xee, 0xc1, 0x9f, 0x23, 
  0x46, 0x8c, 0x05, 0x0a, 0x14, 0x28, 0x50, 0xa0, 
  0x5d, 0xba, 0x69, 0xd2, 0xb9, 0x6f, 0xde, 0xa1, 
  0x5f, 0xbe, 0x61, 0xc2, 0x99, 0x2f, 0x5e, 0xbc, 
  0x65, 0xca, 0x89, 0x0f, 0x1e, 0x3c, 0x78, 0xf0, 
  0xfd, 0xe7, 0xd3, 0xbb, 0x6b, 0xd6, 0xb1, 0x7f, 
  0xfe, 0xe1, 0xdf, 0xa3, 0x5b, 0xb6, 0x71, 0xe2, 
  0xd9, 0xaf, 0x43, 0x86, 0x11, 0x22, 0x44, 0x88, 
  0x0d, 0x1a, 0x34, 0x68, 0xd0, 0xbd, 0x67, 0xce, 
  0x81, 0x1f, 0x3e, 0x7c, 0xf8, 0xed, 0xc7, 0x93, 
  0x3b, 0x76, 0xec, 0xc5, 0x97, 0x33, 0x66, 0xcc, 
  0x85, 0x17, 0x2e, 0x5c, 0xb8, 0x6d, 0xda, 0xa9, 
  0x4f, 0x9e, 0x21, 0x42, 0x84, 0x15, 0x2a, 0x54, 
  0xa8, 0x4d, 0x9a, 0x29, 0x52, 0xa4, 0x55, 0xaa, 
  0x49, 0x92, 0x39, 0x72, 0xe4, 0xd5, 0xb7, 0x73, 
  0xe6, 0xd1, 0xbf, 0x63, 0xc6, 0x91, 0x3f, 0x7e, 
  0xfc, 0xe5, 0xd7, 0xb3, 0x7b, 0xf6, 0xf1, 0xff, 
  0xe3, 0xdb, 0xab, 0x4b, 0x96, 0x31, 0x62, 0xc4, 
  0x95, 0x37, 0x6e, 0xdc, 0xa5, 0x57, 0xae, 0x41, 
  0x82, 0x19, 0x32, 0x64, 0xc8, 0x8d, 0x07, 0xe, 
  0x1c, 0x38, 0x70, 0xe0, 0xdd, 0xa7, 0x53, 0xa6, 
  0x51, 0xa2, 0x59, 0xb2, 0x79, 0xf2, 0xf9, 0xef, 
  0xc3, 0x9b, 0x2b, 0x56, 0xac, 0x45, 0x8a, 0x9, 
  0x12, 0x24, 0x48, 0x90, 0x3d, 0x7a, 0xf4, 0xf5, 
  0xf7, 0xf3, 0xfb, 0xeb, 0xcb, 0x8b, 0x0b, 0x16, 
  0x2c, 0x58, 0xb0, 0x7d, 0xfa, 0xe9, 0xcf, 0x83, 
  0x1b, 0x36, 0x6c, 0xd8, 0xad, 0x47, 0x8e, 0x01,
  0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1d, 
  0x3a, 0x74, 0xe8, 0xcd, 0x87, 0x13, 0x26, 0x4c, 
  0x98, 0x2d, 0x5a, 0xb4, 0x75, 0xea, 0xc9, 0x8f, 
  0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x9d, 
  0x27, 0x4e, 0x9c, 0x25, 0x4a, 0x94, 0x35, 0x6a, 
  0xd4, 0xb5, 0x77, 0xee, 0xc1, 0x9f, 0x23, 0x46, 
  0x8c, 0x05, 0x0a, 0x14, 0x28, 0x50, 0xa0, 0x5d, 
  0xba, 0x69, 0xd2, 0xb9, 0x6f, 0xde, 0xa1, 0x5f, 
  0xbe, 0x61, 0xc2, 0x99, 0x2f, 0x5e, 0xbc, 0x65, 
  0xca, 0x89, 0x0f, 0x1e, 0x3c, 0x78, 0xf0, 0xfd, 
  0xe7, 0xd3, 0xbb, 0x6b, 0xd6, 0xb1, 0x7f, 0xfe, 
  0xe1, 0xdf, 0xa3, 0x5b, 0xb6, 0x71, 0xe2, 0xd9, 
  0xaf, 0x43, 0x86, 0x11, 0x22, 0x44, 0x88, 0x0d, 
  0x1a, 0x34, 0x68, 0xd0, 0xbd, 0x67, 0xce, 0x81, 
  0x1f, 0x3e, 0x7c, 0xf8, 0xed, 0xc7, 0x93, 0x3b, 
  0x76, 0xec, 0xc5, 0x97, 0x33, 0x66, 0xcc, 0x85, 
  0x17, 0x2e, 0x5c, 0xb8, 0x6d, 0xda, 0xa9, 0x4f, 
  0x9e, 0x21, 0x42, 0x84, 0x15, 0x2a, 0x54, 0xa8, 
  0x4d, 0x9a, 0x29, 0x52, 0xa4, 0x55, 0xaa, 0x49, 
  0x92, 0x39, 0x72, 0xe4, 0xd5, 0xb7, 0x73, 0xe6, 
  0xd1, 0xbf, 0x63, 0xc6, 0x91, 0x3f, 0x7e, 0xfc, 
  0xe5, 0xd7, 0xb3, 0x7b, 0xf6, 0xf1, 0xff, 0xe3, 
  0xdb, 0xab, 0x4b, 0x96, 0x31, 0x62, 0xc4, 0x95, 
  0x37, 0x6e, 0xdc, 0xa5, 0x57, 0xae, 0x41, 0x82, 
  0x19, 0x32, 0x64, 0xc8, 0x8d, 0x07, 0x0e, 0x1c, 
  0x38, 0x70, 0xe0, 0xdd, 0xa7, 0x53, 0xa6, 0x51, 
  0xa2, 0x59, 0xb2, 0x79, 0xf2, 0xf9, 0xef, 0xc3, 
  0x9b, 0x2b, 0x56, 0xac, 0x45, 0x8a, 0x09, 0x12, 
  0x24, 0x48, 0x90, 0x3d, 0x7a, 0xf4, 0xf5, 0xf7, 
  0xf3, 0xfb, 0xeb, 0xcb, 0x8b, 0x0b, 0x16, 0x2c, 
  0x58, 0xb0, 0x7d, 0xfa, 0xe9, 0xcf, 0x83, 0x1b, 
  0x36, 0x6c, 0xd8, 0xad, 0x47, 0x8e
};

/* Generator Matrices
   Note: the matrices are defined in column major order because the
   algorithms are easier to implement.    
*/

LOCAL const uint8 matrix_16_12_4[4][12] = 
{
  { 0x6a, 0x1d, 0xb7, 0xa2, 0x1e, 0xe6, 0x33, 0x5e, 0x9e, 0x8e, 0xe6, 0x38 }, 
  { 0x21, 0xc8, 0x10, 0xc5, 0x48, 0x2a, 0x5a, 0x7f, 0xe5, 0x82, 0xba, 0xcf }, 
  { 0x15, 0xaf, 0x6c, 0xc,  0x7,  0xe2, 0xd2, 0x35, 0xfa, 0xc,  0x28, 0x38 }, 
  { 0x1d, 0xb7, 0xa2, 0x1e, 0xe6, 0x33, 0x5e, 0x9e, 0x8e, 0xe6, 0x38, 0x1  }  
}; 

LOCAL const uint8 matrix_16_13_3[3][13] = 
{
  { 0xe5, 0xcb, 0x84,  0x9d, 0x62, 0x69, 0x0b, 0xf5, 0x09,  0x6c, 0xe6, 0xcf, 
    0x8d},
  { 0x2f, 0x4e, 0x18,  0xfe, 0xa,  0x63, 0xff, 0xfd, 0x64, 0x8b, 0x28, 0x43, 
    0x8d},
  { 0xcb, 0x84, 0x9d,  0x62, 0x69, 0xb,  0xf5, 0x9,  0x6c, 0xe6, 0xcf, 0x8d, 
    0x1}
};

LOCAL const uint8 matrix_16_14_2[2][14] =
{
  {0x2,  0xbe,  0x99,  0x12,  0xef,  0x93,  0xa3,  
   0xee, 0x6b,  0x25,  0xce,  0x38,  0x8d,  0x49},
  {0xbe, 0x99,  0x12,  0xef,  0x93,  0xa3,  0xee,  
   0x6b, 0x25,  0xce,  0x38,  0x8d,  0x49,  0x01}
};

LOCAL const uint8 matrix_32_24_8[8][24] =
{  
  { 0x3b, 0xa7, 0xb2, 0x15, 0xe1, 0xb7, 0xc4, 0x77, 0x7d, 0x99, 0xad, 0x7f, 
    0xb4, 0x6e, 0xc2, 0xaa, 0x4,  0xc1, 0x5f, 0x9d, 0xf1, 0xe6, 0xb,  0xee }, 
  { 0x0f, 0xd,  0xa6, 0x85, 0x78, 0x91, 0x27, 0xbb, 0xea, 0xfc, 0x4d, 0xf1, 
    0x20, 0x40, 0xa0, 0xa6, 0x35, 0xe5, 0x11, 0x41, 0xb6, 0x2c, 0xea, 0xf5 }, 
  { 0x4d, 0x3e, 0xd1, 0x4b, 0x3b, 0xa2, 0xe2, 0x7d, 0xed, 0x04, 0xc1, 0xec, 
    0x29, 0x9f, 0x37, 0x6c, 0x55, 0x40, 0x8f, 0x0c, 0x14, 0xf9, 0xd5, 0x5e }, 
  { 0x06, 0xf9, 0x38, 0x63, 0x38, 0x06, 0xe5, 0xfd, 0x14, 0xcc, 0xc6, 0x14, 
    0x33, 0x2b, 0x01, 0x72, 0x09, 0x29, 0x9a, 0xcb, 0xf6, 0xe0, 0xd1, 0xeb }, 
  { 0xbe, 0x31, 0xb8, 0x4e, 0x4c, 0x19, 0x65, 0x2c, 0xf4, 0x52, 0x3b, 0x4,  
    0x15, 0x0c, 0x08, 0x5d, 0xf9, 0x0a, 0xc7, 0x57, 0xf2, 0x72, 0xcb, 0x5e }, 
  { 0x25, 0x0a, 0x37, 0x0a, 0x3d, 0x71, 0x5e, 0x7a, 0x45, 0xd5, 0x90, 0xee, 
    0xdb, 0x17, 0x92, 0x4d, 0x38, 0x85, 0xd0, 0x83, 0xad, 0x06, 0x5a, 0xf5 }, 
  { 0x84, 0x14, 0xd6, 0xda, 0xb4, 0xe7, 0x02, 0x04, 0x2c, 0xab, 0xe8, 0x31, 
    0x36, 0x64, 0x60, 0x5e, 0xbe, 0x4d, 0xef, 0xcd, 0xd6, 0xe2, 0xff, 0xee }, 
  { 0xa7, 0xb2, 0x15, 0xe1, 0xb7, 0xc4, 0x77, 0x7d, 0x99, 0xad, 0x7f, 0xb4, 
    0x6e, 0xc2, 0xaa, 0x04, 0xc1, 0x5f, 0x9d, 0xf1, 0xe6, 0x0b, 0xee, 0x01 }
};

LOCAL const uint8 matrix_32_26_6[6][26] =
{
  { 0x7d, 0x4c, 0xe7, 0x30, 0xbf, 0xfc, 0x67, 0x06, 0x36, 0xfc,  
    0x5c, 0x15, 0x80, 0x13, 0x8,  0x82, 0x7e, 0x60, 0x5d, 0x9d,  
    0x29, 0x09, 0xef, 0x5e, 0x9,  0x25},
  { 0x61, 0x69, 0xa1, 0x59, 0x37, 0x62, 0x66, 0xb9, 0x66, 0xeb,  
    0x82, 0x87, 0x62, 0x85, 0x26, 0x35, 0x62, 0x1f, 0x3b, 0xc4,  
    0x59, 0x39, 0xd1, 0xdb, 0x4e, 0x6c},
  { 0x39, 0x89, 0x77, 0x2e, 0x8c, 0x54, 0x78, 0x13, 0x43, 0x05,  
    0x8d, 0xcd, 0x83, 0x58, 0xc2, 0xfa, 0x8a, 0x61, 0x15, 0x37,  
    0xee, 0x72, 0x60, 0x6f, 0xf0, 0x8e},
  { 0x35, 0x1f, 0x74, 0x6f, 0xff, 0xf2, 0xe9, 0x7b, 0x08, 0x3d,  
    0x2b, 0x09, 0x8d, 0x4,  0x5c, 0x83, 0xc5, 0xba, 0xc1, 0xd5,  
    0xad, 0x64, 0x8b, 0x4f, 0xe5, 0x6c},
  { 0xf3, 0xdd, 0x01, 0xfb, 0xba, 0x9c, 0xe8, 0x9c, 0x81, 0x6b,  
    0x5b, 0x64, 0x0d, 0xb7, 0x43, 0x80, 0x3c, 0xc6, 0xb0, 0xcd,  
    0xff, 0x86, 0x3d, 0x35, 0x64, 0x25},
  { 0x4c, 0xe7, 0x30, 0xbf, 0xfc, 0x67, 0x06,  0x36, 0xfc, 0x5c,  
    0x15, 0x80, 0x13, 0x08, 0x82, 0x7e, 0x60, 0x5d, 0x9d, 0x29,  
    0x09, 0xef, 0x5e, 0x09, 0x25, 0x01},
};

LOCAL const uint8 matrix_32_28_4[4][28] =
{
  {0xa6,  0x7a,  0x15,  0x9d,  0x12,  0x1b,  0x3b,  
   0x3d,  0x1f,  0xfe,  0x89,  0xab,  0x78,  0x20,  
   0x62,  0x79,  0x6a,  0x1d,  0xb7,  0xa2,  0x1e,  
   0xe6,  0x33,  0x5e,  0x9e,  0x8e,  0xe6,  0x38},
  {0x4e,  0x59,  0x5 ,  0xe6,  0x4a,  0x20,  0x7a,  
   0xca,  0xef,  0x51,  0x4a,  0x1e,  0x24,  0x2b, 
   0xa5,  0xd5,  0x21,  0xc8,  0x10,  0xc5,  0x48,  
   0x2a,  0x5a,  0x7f,  0xe5,  0x82,  0xba,  0xcf},
  {0xea,  0xe2,  0xe1,  0xcc,  0x9,   0x5c,  0xee,  
   0x2c,  0xc7,  0x1f,  0xef,  0xaf,  0x31,  0xfc,  
   0xdd,  0x45,  0x15,  0xaf,  0x6c,  0xc,   0x7,   
   0xe2,  0xd2,  0x35,  0xfa,  0xc,   0x28,  0x38},
  {0x7a,  0x15,  0x9d,  0x12,  0x1b,  0x3b,  0x3d,  
   0x1f,  0xfe,  0x89,  0xab,  0x78,  0x20,  0x62,  
   0x79,  0x6a,  0x1d,  0xb7,  0xa2,  0x1e,  0xe6,  
   0x33,  0x5e,  0x9e,  0x8e,  0xe6,  0x38,  0x1 }
};

/* Structure for mapping outer code to N, K, R, and matrix index */
LOCAL const struct
{
  uint8  n;
  uint8  k;
  uint8* generator_matrix;
} outer_code_info[7] = 
{
  {  1,  1,  NULL                    }, /* Outer Code 0: N= 1, K= 1 */
  { 16, 12,  (uint8*) matrix_16_12_4 }, /* Outer Code 1: N=16, K=12 */
  { 16, 13,  (uint8*) matrix_16_13_3 }, /* Outer Code 2: N=16, K=13 */
  { 16, 14,  (uint8*) matrix_16_14_2 }, /* Outer Code 3: N=16, K=14 */
  { 32, 24,  (uint8*) matrix_32_24_8 }, /* Outer Code 4: N=32, K=24 */
  { 32, 26,  (uint8*) matrix_32_26_6 }, /* Outer Code 5: N=32, K=26 */
  { 32, 28,  (uint8*) matrix_32_28_4 }  /* Outer Code 6: N=32, K=28 */
};


/* Local function prototype */
LOCAL void hdrbcrsd_invert_matrix
(
  uint8 matrix[][K_MAX], 
  int k, 
  int erasure_rows[],
  int erasure_count
);


/*===========================================================================
       FUNCTION DEFINITIONS
===========================================================================*/

/*===========================================================================

FUNCTION HDRBCRSD_GF_MULTIPLY

DESCRIPTION
  Multiply two GF(256) symbols and return the result
  
DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
#define HDRBCRSD_GF_MULTIPLY( gf1, gf2)  \
 ((gf1==0||gf2==0)?0:gfantilogtable[gflogtable[gf1]+gflogtable[gf2]])


__inline uint8 hdrbcrsd_gf_multiply( uint8 gf1, uint8 gf2 )
{
  int temp;

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */ 

  if( gf1 == 0 || gf2 == 0 )
  {
    return 0;
  }
  else
  {
    temp = gflogtable[ gf1 ] + gflogtable[ gf2 ];
    return gfantilogtable[ temp ];
  }

} /* hdrbcrsd_gf_multiply */


 /* EJECT */
/*===========================================================================

FUNCTION HDRBCRSD_GF_DIVIDE

DESCRIPTION
  Divide two GF(256) symbols and return the result.
  
DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
__inline uint8 hdrbcrsd_gf_divide( uint8 gfnum, uint8 gfden )
{

  int temp;

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */ 

  /* Note that gfden should never be 0 (this is undefined) */
  if( gfnum == 0 || gfden == 0 ) 
  {
    return 0;
  }
  else
  {
   	temp = gflogtable[ gfnum ] - gflogtable[ gfden ];
   	temp += 255;
   	return gfantilogtable[ temp ];
  }

} /* hdrbcrsd_gf_divide */


 /* EJECT */
/*===========================================================================

FUNCTION HDRBCRSD_DECODE

DESCRIPTION
  Decodes and corrects (if possible) one row of an ECB block. Note that
  NULL pointers are taken to be missing packets or packets with failed CRC's.
  If error correction is possible, the reconstructed data is placed in a
  parity packet (no new packets are allocated). Thus, the pointers in the 
  packet array parameter may be reordered by this function.  (The caller 
  must take this into account.)

  
DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
uint8 hdrbcrsd_decode
( 
  dsm_item_type* packets[], 
    /* Eventually this should be dsm_item pointers.  This is an array
       of N pointers to good data packets.  A NULL pointer implies a
       bad or missing packet. */

  uint8 outer_code
    /* Outer code index defined in the standard. */
)
{

  int n,k;                      /* Variables to hold N and K values     */

  int irow;                     /* Row index variable                   */

  int icol;                     /* Column index variable                */

  int icw;                      /* Codeword index variable              */

  uint8 temp;                     /* Temporary variable                   */

  int err_row;                  /* Erasure index variable               */

  int irow_parity;              /* Index variable for parity rows       */

  uint8 matrix[R_MAX][K_MAX];     /* Erased generator matrix              */

  int num_eras;                 /* Total number of erasures             */

  int erasure_rows[K_MAX];      /* Stores erased packet row locations   */

  uint8 erasure_count = 0;        /* Number of data erasures              */

  const uint8 *gen_matrix[R_MAX]; /* Generator matrix pointers            */

  const uint8 *gen_matrix_ptr;    /* gen_matrix row ptr (for fast lookup) */

  uint8* matrix_ptr;              /* matrix row ptr     (for fast lookup) */

  uint8* packet_data[K_MAX];      /* data section ptr   (for fast lookup) */

  uint8* packet_data_ptr;         /* data section ptr   (for fast lookup) */

  uint32 err_rows = 0;            /* Bit mask of errors decode (debug info) */
  uint32 err_mask = 1;            /* Bit mask of errors decode (debug info) */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Clear out buffers. This is essentially for debugging, it is not
     strictly needed. */
  memset(gen_matrix,0,sizeof(gen_matrix));
  memset(matrix,0,sizeof(matrix));

  /* Grab N and K values from table */
  n = outer_code_info[outer_code].n;
  k = outer_code_info[outer_code].k;

  /* Count total erasures */
  num_eras = 0;
  for (irow = 0; irow < n; irow++)
  {
    if ( packets[irow] == NULL ) 
    {
      num_eras++;
    }
  }

  HDR_MSG_PROT_3(MSG_LEGACY_HIGH,"N==%d K==%d; %d erasures detected",
                 n,k, num_eras);

  /* Decide if any decoding is possible, abort if not. */
  if ( num_eras > n-k )
  {
    HDR_MSG_PROT(MSG_LEGACY_HIGH,"RS decode: too many erasures");
    return 0;
  }                  

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */                                          

  /* Point gen_matrix_ptr to the first of the matrix rows needed for decoding.
     We need as many matrix rows as there are erasures. */
  gen_matrix_ptr = outer_code_info[outer_code].generator_matrix;

  /* -- Compute the erased generator matrix -- */
  irow_parity = k;
  for ( irow = 0; irow <k; irow++ )
  {
    
    if ( packets[irow] == NULL ) 
    {

      /* Find the next passed parity frame. Since we've already 
         checked the number of erasures, we will not go past the
         end of the packet array */
      while (packets[irow_parity] == NULL )
      {
        irow_parity++;

        /* Point to next row */
        gen_matrix_ptr += k;

      }

      /* Point to current row of matrix (for faster lookup) */
      matrix_ptr = matrix[erasure_count];

      /* Store the location of erased rows and increment erasure 
         count */
      erasure_rows[erasure_count++] = irow;

      /* Copy parity row from generator matrix to erased generator 
         matrix */
      for ( icol = 0; icol < k; icol++ )
      {
        matrix_ptr[icol] = gen_matrix_ptr[icol];
      }
      /* Point to next row */
      gen_matrix_ptr += k;

      /* Point to parity packet instead. Essentially we are moving the
         packet to the erased packet's location */
      packets[irow] = packets[irow_parity]; 
      packets[irow_parity] = NULL;

      irow_parity++;

      /* Construct a bit field with set bits indicating erasures 
         (debug/test) */
      err_rows = err_mask | err_rows;
    }

    err_mask = err_mask << 1;

    /* Store pointers to data section for fast access later */
    packet_data[irow] = packets[irow]->data_ptr;

  }

  /* Invert the erased generator matrix */
  hdrbcrsd_invert_matrix( matrix, k, erasure_rows, erasure_count );

  /* Correct erased systematic rows. */
  for ( irow = erasure_count-1; irow >= 0; irow--)
  { 
      
    /* Get location of erased packet */
    err_row = erasure_rows[irow];

    /* Point to matrix row to be used */
    matrix_ptr = matrix[irow];

    /* Point to packet being constructed */
    packet_data_ptr = packet_data[err_row];

    /* Compute each codeword in the current row */
    for (icw = 0; icw < NUM_CW; icw++)
    {
      temp = 0;
      for (icol = 0; icol < k; icol++)
      {
        temp ^= HDRBCRSD_GF_MULTIPLY( matrix_ptr[icol], 
                                      packet_data[icol][icw] ); 

      } /* for (icol...) */
        
      /* Place decoded codeword in packet */
      packet_data_ptr[icw] = temp;

    } /* for (icw...) */

    /* Clear CRC and slots_to_decode info */
    packet_data_ptr[icw++] = 0;
    packet_data_ptr[icw++] = 0;
    packet_data_ptr[icw++] = 0;

  } /* for (irow...) */

  /* Decoding was successful */
  HDR_MSG_PROT_2 ( MSG_LEGACY_HIGH,
                   "RS decode: %d data erasures decoded (%x)",
                   erasure_count,err_rows );
  
  return erasure_count;

}  /* hdrbcrsd_decode */


 /* EJECT */
/*===========================================================================

FUNCTION HDRBCRSD_INVERT_MATRIX

DESCRIPTION
  Inverts rows of a GF Matrix if the row's crc failed.
   
DEPENDENCIES
  None. 

RETURN VALUE
  None.

SIDE EFFECTS
  None.

===========================================================================*/
LOCAL void hdrbcrsd_invert_matrix
(
  uint8 matrix[][K_MAX], 
    /* Holds the matrix to invert */

  int k, 
    /* Number of information symbols */

  int pivot_point[],
    /* Mapping of matrix row to pivot point index*/
    
  int row_count
    /* Number of rows of matrix to invert (also number of erasures) */
)
{

  int   irow; /* Row index variable    */

  int   icol; /* Column index variable */

  int   ipiv; /* Pivot index variable  */

  int   ierr; /* Erasure index var     */

  uint8   temp; /* Temporary variable    */

  uint8 *matrix_piv_ptr;  /* Matrix pivot row pointer (for fast lookup) */

  uint8 *matrix_row_ptr;  /* Matrix row pointer       (for fast lookup) */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  /* Invert the matrix for each erasure row */
  for ( ierr = 0; ierr < row_count; ierr++ )
  {

    /* Grab the row index of the actual packet */
    ipiv = pivot_point[ierr];

    /* Point matrix_piv_ptr to the pivot row (for faster lookup in loop) */
    matrix_piv_ptr = matrix[ierr];

    /* Store division factor */
    temp = matrix_piv_ptr[ipiv];
    matrix_piv_ptr[ipiv] = 1;

    /* Divide the pivot row by the pivot element */
    for ( icol = 0; icol < k; icol++ )
    {
      matrix_piv_ptr[icol] = hdrbcrsd_gf_divide(matrix_piv_ptr[icol], temp);
    }

    /* Row reduction on *remaining* rows */
    for ( irow = ierr+1; irow < row_count; irow++ )
    {
      /* Point matrix_row_ptr to the current row (for faster lookup in loop)
      */
      matrix_row_ptr = matrix[irow];

      /* Store multiplication factor to be used */
      temp = matrix_row_ptr[ipiv];
      matrix_row_ptr[ipiv] = 0;

      /* Subtract the product of pivot row and temp value from current row
      */
      for (icol = 0; icol < k; icol++)
      {
        matrix_row_ptr[icol] ^= hdrbcrsd_gf_multiply(matrix_piv_ptr[icol], 
                                                  temp);
      } /* for (icol...) */

    } /* for (irow...) */
    
  } /* for (ierr...) */
   
}  /* hdrbcrsd_invert_matrix */

#endif /* FEATURE_HDR_BCMCS */
