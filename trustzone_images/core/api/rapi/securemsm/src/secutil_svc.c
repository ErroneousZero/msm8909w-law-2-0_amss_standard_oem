/* SECUTIL TOOL VERSION: 7 */
/*=============================================================================
                           S E C U T I L _ S V C . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that dispatches RPC requests targetting the
  secutil api.

  ---------------------------------------------------------------------------
  Copyright (c) 2008 Qualcomm Technologies Incorporated.
  All Rights Reserved. QUALCOMM Proprietary and Confidential.
  ---------------------------------------------------------------------------
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */
#ifdef FEATURE_HTORPC_METACOMMENTS
/* Generated by following versions of Htorpc modules:
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/htorpc.pl#6 
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Start.pm#10 
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Htoxdr.pm#6 
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/XDR.pm#15 
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Output.pm#30 
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Parser.pm#10 
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/Metacomments.pm#11 
Id: //depot/asic/msmshared/services/mproc/tools/main/htorpc/lib/Htorpc/SymbolTable.pm#5  */
#endif
/* $Id: //components/rel/tz.bf/2.5.c10/trustzone_images/core/api/rapi/securemsm/src/secutil_svc.c#1 $
=============================================================================*/

#include "customer.h"
#include "target.h"

#ifdef FEATURE_ONCRPC
#ifdef FEATURE_EXPORT_SECUTIL
#define HTORPC_SECUTIL_GLUE

/* Include files */
#include "err.h"
#include "msg.h"
#include "oncrpc.h"

#include "secutil.h"
#include "secutil_rpc.h"

/* Only one copy needed per API */
//static opaque_auth SecutilCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth SecutilVerf = { ONCRPC_AUTH_NONE, 0, 0 };

/*=======================================================================
             Prototypes for the API's RPC Server Functions
=======================================================================*/

static void secutilprog_0 ( struct svc_req *rqstp, xdr_s_type *srv );
static void secutil_null_0( xdr_s_type *svc );
static void secutil_rpc_glue_code_info_remote_0( xdr_s_type *svc );

static void secutil_get_random_0( xdr_s_type *srv );

static void secutil_get_sfs_key_0( xdr_s_type *srv );

/******************************************************************************/
/*=======================================================================
             API RPC Server Implementation
=======================================================================*/

void secutil_app_init( void )
{
  xdr_s_type *transp;

#if (defined FEATURE_ONCRPC_SM)
  transp = svcsm_create(0, 0);
  if ( transp == NULL ) {
    XDR_SVC_CREATE_ERR_FATAL(0, 0);
  }
  if ( !svc_register(transp, SECUTILPROG, SECUTILVERS,
                     secutilprog_0, ONCRPC_SM_PROTOCOL) ) {
    XDR_SVC_REGISTER_ERR_FATAL(transp, SECUTILPROG, SECUTILVERS,
                               secutilprog_0, ONCRPC_SM_PROTOCOL);
  }

#endif /* (defined FEATURE_ONCRPC_SM) */

#if (defined FEATURE_ONCRPC_ROUTER)
  transp = svcrtr_create(0, 0);
  if ( transp == NULL ) {
    XDR_SVC_CREATE_ERR_FATAL(0, 0);
  }
  if ( !svc_register(transp, SECUTILPROG, SECUTILVERS,
                     secutilprog_0, ONCRPC_RTR_PROTOCOL) ) {
    XDR_SVC_REGISTER_ERR_FATAL(transp, SECUTILPROG, SECUTILVERS,
                               secutilprog_0, ONCRPC_RTR_PROTOCOL);
  }

#endif /* (defined FEATURE_ONCRPC_ROUTER) */
} /* secutil_app_init */

void secutil_app_lock( boolean lock )
{
  svc_lock( SECUTILPROG, SECUTILVERS, lock );
} /* secutil_app_lock */

static void secutilprog_0 ( struct svc_req *rqstp, xdr_s_type *srv )
{
  switch ( rqstp->rq_proc ) {
    case ONCRPC_SECUTIL_NULL_PROC:
      secutil_null_0( srv );
      break;
    case ONCRPC_SECUTIL_RPC_GLUE_CODE_INFO_REMOTE_PROC:
      secutil_rpc_glue_code_info_remote_0( srv );
      break;
    case ONCRPC_SECUTIL_GET_RANDOM_PROC:
      secutil_get_random_0( srv );
      break;
    case ONCRPC_SECUTIL_GET_SFS_KEY_PROC:
      secutil_get_sfs_key_0( srv );
      break;

    default:
      // invalid RPC procedure number
      (void) XDR_MSG_DONE( srv );
      svcerr_noproc( srv );
      break;
  }

  oncrpcxdr_mem_free( srv );
} /* secutilprog_0 */

/******************************************************************************/

static void secutil_null_0( xdr_s_type *srv )
{
  if ( ! XDR_MSG_DONE( srv ) ) {
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  if ( ! xdr_reply_msg_start( srv, &SecutilVerf ) ) {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* secutil_null_0 */

static void secutil_rpc_glue_code_info_remote_0( xdr_s_type *srv )
{
  uint32 toolvers   = 7;
  uint32 proghash   = 0x9b497ec4;
  uint32 cbproghash = 0x811c9dc5;
  uint32 features   = ( 0x00000000
#ifdef FEATURE_ONCRPC_SERVER_CLEANUP_SUPPORT
                      | 0x00000001
#endif
                      );

  if ( ! XDR_MSG_DONE( srv ) ) {
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  if ( ! xdr_reply_msg_start( srv, &SecutilVerf ) ||
       ! XDR_SEND_UINT32( srv, &toolvers ) ||
       ! XDR_SEND_UINT32( srv, &features ) ||
       ! XDR_SEND_UINT32( srv, &proghash ) ||
       ! XDR_SEND_UINT32( srv, &cbproghash ) )
  {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* secutil_rpc_glue_code_info_remote_0 */

static void secutil_get_random_0( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean output_pointer_not_null;
  uint32 length_uint32;
  uint16 length_uint16;
  uint8 *random_ptr = NULL;
  uint16 random_len;

  secerrno_enum_type secutil_get_random_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  /* The server must know whether to allocate memory for the output parameter
   * random_ptr or not. A boolean is received to indicate that. The maximum number
   * of objects that could be pointed to by this pointer is also received.
   */
  xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

  if ( xdr_status && output_pointer_not_null ) {

    xdr_status = XDR_RECV_UINT32( srv, &length_uint32 );

    random_ptr = oncrpcxdr_mem_alloc( srv, length_uint32 * sizeof(*random_ptr) );
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT16( srv, &random_len );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  secutil_get_random_result = secutil_get_random(random_ptr, random_len);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &SecutilVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &secutil_get_random_result );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    if ( random_ptr != NULL ) {
      length_uint16 = random_len;
      length_uint16 = ( length_uint16 > random_len ? random_len : length_uint16 );

      xdr_status = XDR_SEND_UINT16( srv, &length_uint16 );

      /* XDR OP NUMBER = 4 */
      if ( xdr_status )
      {
        xdr_op_number  = 4;
        xdr_status = XDR_SEND_BYTES(srv, random_ptr, length_uint16);
      }
    } else {
      length_uint16 = 0;

      xdr_status = XDR_SEND_UINT16( srv, &length_uint16 );
    }
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* secutil_get_random_0 */

static void secutil_get_sfs_key_0( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean output_pointer_not_null;
  uint32 length_uint32;
  uint8 *key_ptr = NULL;
  uint32 key_len;

  secerrno_enum_type secutil_get_sfs_key_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  /* The server must know whether to allocate memory for the output parameter
   * key_ptr or not. A boolean is received to indicate that. The maximum number
   * of objects that could be pointed to by this pointer is also received.
   */
  xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

  if ( xdr_status && output_pointer_not_null ) {

    xdr_status = XDR_RECV_UINT32( srv, &length_uint32 );

    key_ptr = oncrpcxdr_mem_alloc( srv, length_uint32 * sizeof(*key_ptr) );
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT32( srv, &key_len );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  secutil_get_sfs_key_result = secutil_get_sfs_key(key_ptr, key_len);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &SecutilVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &secutil_get_sfs_key_result );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    if ( key_ptr != NULL ) {
      length_uint32 = key_len;
      length_uint32 = ( length_uint32 > key_len ? key_len : length_uint32 );

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );

      /* XDR OP NUMBER = 4 */
      if ( xdr_status )
      {
        xdr_op_number  = 4;
        xdr_status = XDR_SEND_BYTES(srv, key_ptr, length_uint32);
      }
    } else {
      length_uint32 = 0;

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );
    }
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* secutil_get_sfs_key_0 */

#endif /* FEATURE_EXPORT_SECUTIL */
#endif /* FEATURE_ONCRPC */
