/* BUS_PERF TOOL VERSION: 4.30 */
/*=============================================================================
                          B U S _ P E R F _ S V C . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that dispatches RPC requests targetting the
  bus_perf api.

  ---------------------------------------------------------------------------
  Copyright (c) 2009 Qualcomm Technologies Incorporated.
  All Rights Reserved. QUALCOMM Proprietary and Confidential.
  ---------------------------------------------------------------------------
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */
/* Generated by following versions of Htorpc modules:
Id: //source/qcom/qct/core/mproc/tools/main/latest/htorpc/htorpc.pl#3 
$Id: //components/rel/tz.bf/2.5.c10/trustzone_images/core/api/rapi/buses/src/bus_perf_svc.c#1 $
Id: //source/qcom/qct/core/mproc/tools/main/latest/htorpc/lib/Htorpc/Htoxdr.pm#1 
Id: //source/qcom/qct/core/mproc/tools/main/latest/htorpc/lib/Htorpc/XDR.pm#5 
Id: //source/qcom/qct/core/mproc/tools/main/latest/htorpc/lib/Htorpc/Output.pm#17 
Id: //source/qcom/qct/core/mproc/tools/main/latest/htorpc/lib/Htorpc/Parser.pm#3 
Id: //source/qcom/qct/core/mproc/tools/main/latest/htorpc/lib/Htorpc/Metacomments.pm#2 
$Id: //components/rel/tz.bf/2.5.c10/trustzone_images/core/api/rapi/buses/src/bus_perf_svc.c#1 $ 
=============================================================================*/
/*=============================================================================
$Header: //components/rel/tz.bf/2.5.c10/trustzone_images/core/api/rapi/buses/src/bus_perf_svc.c#1 $ 
=============================================================================*/


/* Include files */
#include "oncrpc.h"
#include "bus_perf.h"
#include "bus_perf_rpc.h"

/* Only one copy needed per API */
//static opaque_auth Bus_perfCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth Bus_perfVerf = { ONCRPC_AUTH_NONE, 0, 0 };

/*=======================================================================
             Prototypes for the API's RPC Server Functions
=======================================================================*/

static void bus_perfprog_0x00010001 ( struct svc_req *rqstp, xdr_s_type *srv );
static void bus_perf_null_0x00010001( xdr_s_type *svc );
static void bus_perf_rpc_glue_code_info_remote_0x00010001( xdr_s_type *svc );
static void bus_perf_api_versions_0x00010001( xdr_s_type *srv );

static void bus_alloc_0x00010001( xdr_s_type *srv );

static void bus_free_0x00010001( xdr_s_type *srv );

static void bus_get_oversubscribe_info_0x00010001( xdr_s_type *srv );

static void bus_set_hw_updates_0x00010001( xdr_s_type *srv );

static void bus_halt_port_requests_0x00010001( xdr_s_type *srv );

static void bus_unhalt_port_requests_0x00010001( xdr_s_type *srv );

/******************************************************************************/
/*=======================================================================
             API RPC Server Implementation
=======================================================================*/
static uint32 bus_perf_api_versions_table[] = { 0x00010001 };

static uint32 * bus_perf_api_versions(uint32 *size_entries)
{
  *size_entries = sizeof( bus_perf_api_versions_table) / sizeof(uint32);
  return bus_perf_api_versions_table;
}

void bus_perf_app_init( void )
{
  (void) svc_register_auto_apiversions(BUS_PERFPROG, BUS_PERFVERS, bus_perfprog_0x00010001, 
                                       bus_perf_api_versions);
} /* bus_perf_app_init */

void bus_perf_app_lock( boolean lock )
{
  svc_lock( BUS_PERFPROG, BUS_PERFVERS, lock );
} /* bus_perf_app_lock */

static void bus_perfprog_0x00010001 ( struct svc_req *rqstp, xdr_s_type *srv )
{
  switch ( rqstp->rq_proc ) {
    case ONCRPC_BUS_PERF_NULL_PROC:
      bus_perf_null_0x00010001( srv );
      break;
    case ONCRPC_BUS_PERF_RPC_GLUE_CODE_INFO_REMOTE_PROC:
      bus_perf_rpc_glue_code_info_remote_0x00010001( srv );
      break;
    case ONCRPC_BUS_ALLOC_PROC:
      bus_alloc_0x00010001( srv );
      break;
    case ONCRPC_BUS_FREE_PROC:
      bus_free_0x00010001( srv );
      break;
    case ONCRPC_BUS_GET_OVERSUBSCRIBE_INFO_PROC:
      bus_get_oversubscribe_info_0x00010001( srv );
      break;
    case ONCRPC_BUS_SET_HW_UPDATES_PROC:
      bus_set_hw_updates_0x00010001( srv );
      break;
    case ONCRPC_BUS_HALT_PORT_REQUESTS_PROC:
      bus_halt_port_requests_0x00010001( srv );
      break;
    case ONCRPC_BUS_UNHALT_PORT_REQUESTS_PROC:
      bus_unhalt_port_requests_0x00010001( srv );
      break;
    case ONCRPC_BUS_PERF_API_VERSIONS_PROC:
      bus_perf_api_versions_0x00010001( srv );
      break;

    default:
      // invalid RPC procedure number
      (void) XDR_MSG_DONE( srv );
      svcerr_default_err( srv, rqstp, bus_perf_api_versions  );
      break;
  }

  oncrpcxdr_mem_free( srv );
} /* bus_perfprog_0x00010001 */

/******************************************************************************/

static void bus_perf_null_0x00010001( xdr_s_type *srv )
{
  if ( ! XDR_MSG_DONE( srv ) ) {
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  if ( ! xdr_reply_msg_start( srv, &Bus_perfVerf ) ) {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* bus_perf_null_0x00010001 */

static void bus_perf_rpc_glue_code_info_remote_0x00010001( xdr_s_type *srv )
{
  uint32 toolvers   = BUS_PERF_TOOLVERS; /* 4.30 */
  uint32 proghash   = 0x00010001; /* 0x00010001 */
  uint32 cbproghash = 0x00010001; /* 0x00010001 */
  uint32 features   = BUS_PERF_FEATURES; /* ONCRPC Server Cleanup Support */
                      

  if ( ! XDR_MSG_DONE( srv ) ) {
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  if ( ! xdr_reply_msg_start( srv, &Bus_perfVerf ) ||
       ! XDR_SEND_UINT32( srv, &toolvers ) ||
       ! XDR_SEND_UINT32( srv, &features ) ||
       ! XDR_SEND_UINT32( srv, &proghash ) ||
       ! XDR_SEND_UINT32( srv, &cbproghash ) )
  {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* bus_perf_rpc_glue_code_info_remote_0x00010001 */

static void bus_alloc_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean output_pointer_not_null;
  bus_perf_request request;
  bus_preq_flag_type flags = BUS_FLG_NO_OVERSUBSCRIBE;
  void **handle = NULL;

  bus_return_type bus_alloc_result;

  /* 
   * For struct or union parameters, use memset to zero out their memory on
   * the stack to make sure any pointer members are initialized to NULL
   */
  memset( (void *) &request, 0, sizeof(request) );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_bus_perf_recv_bus_perf_request( srv, &request );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &flags );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /* The server must know whether to allocate memory for the output parameter
     * handle or not. A boolean is received to indicate that.
     */
    xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

    if ( xdr_status && output_pointer_not_null ) {
      handle = oncrpcxdr_mem_alloc( srv, sizeof(*handle) );
    }
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  bus_alloc_result = bus_alloc(request, flags, handle);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Bus_perfVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &bus_alloc_result );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &handle, XDR_SEND_HANDLE, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* bus_alloc_0x00010001 */

static void bus_free_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  void *handle;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_HANDLE( srv, &handle );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  bus_free(handle);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Bus_perfVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* bus_free_0x00010001 */

static void bus_get_oversubscribe_info_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean output_pointer_not_null;
  void *handle;
  bus_oversubscribe_info *info = NULL;

  bus_return_type bus_get_oversubscribe_info_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_HANDLE( srv, &handle );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /* The server must know whether to allocate memory for the output parameter
     * info or not. A boolean is received to indicate that.
     */
    xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

    if ( xdr_status && output_pointer_not_null ) {
      info = oncrpcxdr_mem_alloc( srv, sizeof(*info) );
    }
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  bus_get_oversubscribe_info_result = bus_get_oversubscribe_info(handle, info);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Bus_perfVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &bus_get_oversubscribe_info_result );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    XDR_SEND_POINTER( srv, &info, xdr_bus_perf_send_bus_oversubscribe_info, xdr_status );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* bus_get_oversubscribe_info_0x00010001 */

static void bus_set_hw_updates_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean allow_hw_updates;

  bus_return_type bus_set_hw_updates_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_BOOLEAN( srv, &allow_hw_updates );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  bus_set_hw_updates_result = bus_set_hw_updates(allow_hw_updates);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Bus_perfVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &bus_set_hw_updates_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* bus_set_hw_updates_0x00010001 */

static void bus_halt_port_requests_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  bus_halt_port_type port = BUS_HALT_PORT_MSS_A9I;

  bus_return_type bus_halt_port_requests_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &port );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  bus_halt_port_requests_result = bus_halt_port_requests(port);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Bus_perfVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &bus_halt_port_requests_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* bus_halt_port_requests_0x00010001 */

static void bus_unhalt_port_requests_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  bus_halt_port_type port = BUS_HALT_PORT_MSS_A9I;

  bus_return_type bus_unhalt_port_requests_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &port );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  bus_unhalt_port_requests_result = bus_unhalt_port_requests(port);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Bus_perfVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &bus_unhalt_port_requests_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* bus_unhalt_port_requests_0x00010001 */

/*=========================================================================== 
              API Standard function for api versioning
===========================================================================*/

static void bus_perf_api_versions_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 i;
  boolean output_pointer_not_null;
  uint32 length_uint32;
  uint32 *len = NULL;

  uint32 *bus_perf_api_versions_result = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  /* The server must know whether to allocate memory for the output parameter
   * len or not. A boolean is received to indicate that.
   */
  xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

  if ( xdr_status && output_pointer_not_null ) {
    len = oncrpcxdr_mem_alloc( srv, sizeof(*len) );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  bus_perf_api_versions_result = bus_perf_api_versions(len);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Bus_perfVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    if ( bus_perf_api_versions_result != NULL ) {
      length_uint32 = *len;

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );

      /* XDR OP NUMBER = 3 */
      if ( xdr_status )
      {
        xdr_op_number  = 3;

        /* Calling array of XDR routines */
        for ( i = 0; xdr_status && i < (length_uint32); i++ ) {
          /*lint -save -e545*/
          xdr_status = XDR_SEND_UINT32( srv, &(bus_perf_api_versions_result[i]) );
          /*lint -restore */
        }
      }
    } else {
      length_uint32 = 0;

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );
    }
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &len, XDR_SEND_UINT32, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* bus_perf_api_versions_0x00010001 */

