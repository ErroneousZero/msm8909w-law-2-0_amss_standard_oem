/* TIME_REMOTE_ATOM TOOL VERSION: 4.39 */
/* GENERATED: TUE AUG 17 2010 */
/*=============================================================================
                  T I M E _ R E M O T E _ A T O M _ S V C . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that dispatches RPC requests targetting the
  time_remote_atom api.

  ---------------------------------------------------------------------------
  Copyright (c) 2010 Qualcomm Technologies Incorporated.
  All Rights Reserved. QUALCOMM Proprietary and Confidential.
  ---------------------------------------------------------------------------
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */
/* Generated by following versions of Htorpc modules:
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/htorpc.pl#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/Start.pm#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/Htoxdr.pm#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/XDR.pm#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/Output.pm#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/Parser.pm#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/Metacomments.pm#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/SymbolTable.pm#8   

time_remote_atom Definition File(s):
Id: //source/qcom/qct/core/api/services/time/main/latest/time_remote_atom.h#1
=============================================================================*/
/*=============================================================================
$Header: //components/rel/tz.bf/2.5.c10/trustzone_images/core/api/rapi/services/src/time_remote_atom_svc.c#1 $ 
=============================================================================*/


/* Include files */
#include "oncrpc.h"
#include "time_remote_atom.h"
#include "time_remote_atom_rpc.h"

/* Only one copy needed per API */
//static opaque_auth Time_remote_atomCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth Time_remote_atomVerf = { ONCRPC_AUTH_NONE, 0, 0 };

static opaque_auth Time_remote_atomcbCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth Time_remote_atomcbVerf = { ONCRPC_AUTH_NONE, 0, 0 };

/*=======================================================================
             Prototypes for the API's RPC Server Functions
=======================================================================*/

static void time_remote_atomprog_0x00040005 ( struct svc_req *rqstp, xdr_s_type *srv );
static void time_remote_atom_null_0x00040005( xdr_s_type *svc );
static void time_remote_atom_rpc_glue_code_info_remote_0x00040005( xdr_s_type *svc );
static void time_remote_atom_api_versions_0x00040005( xdr_s_type *srv );

static void time_remote_set_user_time_0x00040005( xdr_s_type *srv );

static void time_alarm_set_0x00040005( xdr_s_type *srv );

static void time_get_local_offset_info_0x00040005( xdr_s_type *srv );

static void time_tod_request_apps_bases_0x00040005( xdr_s_type *srv );

static void time_tod_request_reset_0x00040005( xdr_s_type *srv );

static void time_remote_set_julian_0x00040005( xdr_s_type *srv );

static void time_remote_get_julian_0x00040005( xdr_s_type *srv );

static void time_remote_secure_set_0x00040005( xdr_s_type *srv );

static void time_remote_secure_get_0x00040005( xdr_s_type *srv );

static void time_remote_secure_get_julian_0x00040005( xdr_s_type *srv );

static void time_secure_valid_0x00040005( xdr_s_type *srv );

static void time_alarm_set_ms_0x00040005( xdr_s_type *srv );

static void time_alarm_set_secs_0x00040005( xdr_s_type *srv );

static void time_remote_update_apps_to_modem_offset_0x00040005( xdr_s_type *srv );

static void time_remote_secure_set_julian_0x00040005( xdr_s_type *srv );

static void ats_client_init_0x00040005( xdr_s_type *srv );

static void ats_client_release_0x00040005( xdr_s_type *srv );

static void ats_client_deactivate_0x00040005( xdr_s_type *srv );

static void ats_client_reg_cfg_cb_0x00040005( xdr_s_type *srv );

static void ats_client_activate_0x00040005( xdr_s_type *srv );

static void time_remote_genoff_opr_0x00040005( xdr_s_type *srv );

static void time_remote_atom_genoff_set_generic_offset_0x00040005( xdr_s_type *srv );

static void timer_ipc_remote_set_0x00040005( xdr_s_type *srv );

static void timer_ipc_remote_clr_0x00040005( xdr_s_type *srv );

static void timer_ipc_remote_pause_0x00040005( xdr_s_type *srv );

static void timer_ipc_remote_resume_0x00040005( xdr_s_type *srv );

static void timer_ipc_remote_get_0x00040005( xdr_s_type *srv );

static void time_remote_genoff_set_allow_remote_updates_0x00040005( xdr_s_type *srv );


/*=======================================================================
             Prototypes for the API's Callback RPC clients
=======================================================================*/

static ats_client_err_e_type ats_cfg_event_cb_type_clnt_0x00040005(ats_cfg_event_e_type event,  ats_cfg_event_info_s_type *info_ptr);

/******************************************************************************/
/*=======================================================================
             API RPC Server Implementation
=======================================================================*/
static uint32 time_remote_atom_api_versions_table[] = {  0x00040001 , 0x00040002 , 0x00040003 , 0x00040004 , 0x00040005  };

uint32 * time_remote_atom_api_versions(uint32 *size_entries)
{
  *size_entries = sizeof( time_remote_atom_api_versions_table) / sizeof(uint32);
  return time_remote_atom_api_versions_table;
}

void time_remote_atom_app_init( void )
{
  (void) svc_register_auto_apiversions(TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOMVERS, time_remote_atomprog_0x00040005, 
                                       time_remote_atom_api_versions);
} /* time_remote_atom_app_init */

void time_remote_atom_app_lock( boolean lock )
{
  svc_lock( TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOMVERS, lock );
} /* time_remote_atom_app_lock */

static void time_remote_atomprog_0x00040005 ( struct svc_req *rqstp, xdr_s_type *srv )
{
  switch ( rqstp->rq_proc ) {
    case ONCRPC_TIME_REMOTE_ATOM_NULL_PROC:
      time_remote_atom_null_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_ATOM_RPC_GLUE_CODE_INFO_REMOTE_PROC:
      time_remote_atom_rpc_glue_code_info_remote_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_SET_USER_TIME_PROC:
      time_remote_set_user_time_0x00040005( srv );
      break;
    case ONCRPC_TIME_ALARM_SET_PROC:
      time_alarm_set_0x00040005( srv );
      break;
    case ONCRPC_TIME_GET_LOCAL_OFFSET_INFO_PROC:
      time_get_local_offset_info_0x00040005( srv );
      break;
    case ONCRPC_TIME_TOD_REQUEST_APPS_BASES_PROC:
      time_tod_request_apps_bases_0x00040005( srv );
      break;
    case ONCRPC_TIME_TOD_REQUEST_RESET_PROC:
      time_tod_request_reset_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_SET_JULIAN_PROC:
      time_remote_set_julian_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_GET_JULIAN_PROC:
      time_remote_get_julian_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_SECURE_SET_PROC:
      time_remote_secure_set_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_SECURE_GET_PROC:
      time_remote_secure_get_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_SECURE_GET_JULIAN_PROC:
      time_remote_secure_get_julian_0x00040005( srv );
      break;
    case ONCRPC_TIME_SECURE_VALID_PROC:
      time_secure_valid_0x00040005( srv );
      break;
    case ONCRPC_TIME_ALARM_SET_MS_PROC:
      time_alarm_set_ms_0x00040005( srv );
      break;
    case ONCRPC_TIME_ALARM_SET_SECS_PROC:
      time_alarm_set_secs_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_UPDATE_APPS_TO_MODEM_OFFSET_PROC:
      time_remote_update_apps_to_modem_offset_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_SECURE_SET_JULIAN_PROC:
      time_remote_secure_set_julian_0x00040005( srv );
      break;
    case ONCRPC_ATS_CLIENT_INIT_PROC:
      ats_client_init_0x00040005( srv );
      break;
    case ONCRPC_ATS_CLIENT_RELEASE_PROC:
      ats_client_release_0x00040005( srv );
      break;
    case ONCRPC_ATS_CLIENT_DEACTIVATE_PROC:
      ats_client_deactivate_0x00040005( srv );
      break;
    case ONCRPC_ATS_CLIENT_REG_CFG_CB_PROC:
      ats_client_reg_cfg_cb_0x00040005( srv );
      break;
    case ONCRPC_ATS_CLIENT_ACTIVATE_PROC:
      ats_client_activate_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_GENOFF_OPR_PROC:
      time_remote_genoff_opr_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_ATOM_GENOFF_SET_GENERIC_OFFSET_PROC:
      time_remote_atom_genoff_set_generic_offset_0x00040005( srv );
      break;
    case ONCRPC_TIMER_IPC_REMOTE_SET_PROC:
      timer_ipc_remote_set_0x00040005( srv );
      break;
    case ONCRPC_TIMER_IPC_REMOTE_CLR_PROC:
      timer_ipc_remote_clr_0x00040005( srv );
      break;
    case ONCRPC_TIMER_IPC_REMOTE_PAUSE_PROC:
      timer_ipc_remote_pause_0x00040005( srv );
      break;
    case ONCRPC_TIMER_IPC_REMOTE_RESUME_PROC:
      timer_ipc_remote_resume_0x00040005( srv );
      break;
    case ONCRPC_TIMER_IPC_REMOTE_GET_PROC:
      timer_ipc_remote_get_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_GENOFF_SET_ALLOW_REMOTE_UPDATES_PROC:
      time_remote_genoff_set_allow_remote_updates_0x00040005( srv );
      break;
    case ONCRPC_TIME_REMOTE_ATOM_API_VERSIONS_PROC:
      time_remote_atom_api_versions_0x00040005( srv );
      break;

    default:
      // invalid RPC procedure number
      (void) XDR_MSG_DONE( srv );
      svcerr_default_err( srv, rqstp, time_remote_atom_api_versions  );
      break;
  }

  oncrpcxdr_mem_free( srv );
} /* time_remote_atomprog_0x00040005 */

/******************************************************************************/

static void time_remote_atom_null_0x00040005( xdr_s_type *srv )
{
  if ( ! XDR_MSG_DONE( srv ) ) {
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  if ( ! xdr_reply_msg_start( srv, &Time_remote_atomVerf ) ) {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_atom_null_0x00040005 */

static void time_remote_atom_rpc_glue_code_info_remote_0x00040005( xdr_s_type *srv )
{
  uint32 toolvers   = TIME_REMOTE_ATOM_TOOLVERS; /* 4.39 */
  uint32 proghash   = 0x00040005; /* 0x00040005 */
  uint32 cbproghash = 0x00040005; /* 0x00040005 */
  uint32 features   = TIME_REMOTE_ATOM_FEATURES; /* ONCRPC Server Cleanup Support */
                      

  if ( ! XDR_MSG_DONE( srv ) ) {
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  if ( ! xdr_reply_msg_start( srv, &Time_remote_atomVerf ) ||
       ! XDR_SEND_UINT32( srv, &toolvers ) ||
       ! XDR_SEND_UINT32( srv, &features ) ||
       ! XDR_SEND_UINT32( srv, &proghash ) ||
       ! XDR_SEND_UINT32( srv, &cbproghash ) )
  {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_atom_rpc_glue_code_info_remote_0x00040005 */

static void time_remote_set_user_time_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  int i;
  time_type ts_val;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  /* Calling array of XDR routines */
  for ( i = 0; xdr_status && i < (2); i++ ) {
    /*lint -save -e545*/
    xdr_status = XDR_RECV_UINT32( srv, &(ts_val[i]) );
    /*lint -restore */
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_remote_set_user_time(ts_val);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_set_user_time_0x00040005 */

static void time_alarm_set_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 expiration = 0;

  int32 time_alarm_set_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &expiration );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_alarm_set_result = time_alarm_set(expiration);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_INT32( srv, &time_alarm_set_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_alarm_set_0x00040005 */

static void time_get_local_offset_info_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean output_pointer_not_null;
  int32 *local_timezone = NULL;
  boolean *daylight_savings = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  /* The server must know whether to allocate memory for the output parameter
   * local_timezone or not. A boolean is received to indicate that.
   */
  xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

  if ( xdr_status && output_pointer_not_null ) {
    local_timezone = oncrpcxdr_mem_alloc( srv, sizeof(*local_timezone) );
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /* The server must know whether to allocate memory for the output parameter
     * daylight_savings or not. A boolean is received to indicate that.
     */
    xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

    if ( xdr_status && output_pointer_not_null ) {
      daylight_savings = oncrpcxdr_mem_alloc( srv, sizeof(*daylight_savings) );
    }
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_get_local_offset_info(local_timezone, daylight_savings);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &local_timezone, XDR_SEND_INT32, xdr_status );
    /*lint -restore */
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &daylight_savings, XDR_SEND_BOOLEAN, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_get_local_offset_info_0x00040005 */

static void time_tod_request_apps_bases_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_tod_request_apps_bases();

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_tod_request_apps_bases_0x00040005 */

static void time_tod_request_reset_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_tod_request_reset();

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_tod_request_reset_0x00040005 */

static void time_remote_set_julian_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  time_julian_type *jul_time = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  XDR_RECV_POINTER( srv, &jul_time, xdr_time_remote_atom_recv_time_julian_type, xdr_status );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_remote_set_julian(jul_time);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_set_julian_0x00040005 */

static void time_remote_get_julian_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean output_pointer_not_null;
  time_julian_type *jul_time = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  /* The server must know whether to allocate memory for the output parameter
   * jul_time or not. A boolean is received to indicate that.
   */
  xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

  if ( xdr_status && output_pointer_not_null ) {
    jul_time = oncrpcxdr_mem_alloc( srv, sizeof(*jul_time) );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_remote_get_julian(jul_time);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    XDR_SEND_POINTER( srv, &jul_time, xdr_time_remote_atom_send_time_julian_type, xdr_status );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_get_julian_0x00040005 */

static void time_remote_secure_set_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint64 *ts_val = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  /*lint -save -e123*/
  XDR_RECV_POINTER( srv, &ts_val, XDR_RECV_UINT64, xdr_status );
  /*lint -restore */

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_remote_secure_set(ts_val);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_secure_set_0x00040005 */

static void time_remote_secure_get_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean output_pointer_not_null;
  uint64 *ts_val = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  /* The server must know whether to allocate memory for the output parameter
   * ts_val or not. A boolean is received to indicate that.
   */
  xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

  if ( xdr_status && output_pointer_not_null ) {
    ts_val = oncrpcxdr_mem_alloc( srv, sizeof(*ts_val) );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_remote_secure_get(ts_val);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &ts_val, XDR_SEND_UINT64, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_secure_get_0x00040005 */

static void time_remote_secure_get_julian_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean output_pointer_not_null;
  time_julian_type *julian = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  /* The server must know whether to allocate memory for the output parameter
   * julian or not. A boolean is received to indicate that.
   */
  xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

  if ( xdr_status && output_pointer_not_null ) {
    julian = oncrpcxdr_mem_alloc( srv, sizeof(*julian) );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_remote_secure_get_julian(julian);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    XDR_SEND_POINTER( srv, &julian, xdr_time_remote_atom_send_time_julian_type, xdr_status );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_secure_get_julian_0x00040005 */

static void time_secure_valid_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean time_secure_valid_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_secure_valid_result = time_secure_valid();

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( srv, &time_secure_valid_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_secure_valid_0x00040005 */

static void time_alarm_set_ms_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 expiration = 0;

  int32 time_alarm_set_ms_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &expiration );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_alarm_set_ms_result = time_alarm_set_ms(expiration);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_INT32( srv, &time_alarm_set_ms_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_alarm_set_ms_0x00040005 */

static void time_alarm_set_secs_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 expiration = 0;

  int32 time_alarm_set_secs_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &expiration );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_alarm_set_secs_result = time_alarm_set_secs(expiration);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_INT32( srv, &time_alarm_set_secs_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_alarm_set_secs_0x00040005 */

static void time_remote_update_apps_to_modem_offset_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  int32 offset = 0;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_INT32( srv, &offset );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_remote_update_apps_to_modem_offset(offset);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_update_apps_to_modem_offset_0x00040005 */

static void time_remote_secure_set_julian_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  time_julian_type *julian = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  XDR_RECV_POINTER( srv, &julian, xdr_time_remote_atom_recv_time_julian_type, xdr_status );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_remote_secure_set_julian(julian);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_secure_set_julian_0x00040005 */

static void ats_client_init_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  ats_client_type_e_type client_type = ATS_CLIENT_TYPE_GEN1;
  ats_client_id_type *client_id_ptr = NULL;
  ats_client_processor_e_type processor = ATS_CLIENT_PROCESSOR_NONE;

  ats_client_err_e_type ats_client_init_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &client_type );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_RECV_POINTER( srv, &client_id_ptr, XDR_RECV_UINT8, xdr_status );
    /*lint -restore */
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_RECV_ENUM( srv, &processor );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  ats_client_init_result = ats_client_init(client_type, client_id_ptr, processor);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &ats_client_init_result );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &client_id_ptr, XDR_SEND_UINT8, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* ats_client_init_0x00040005 */

static void ats_client_release_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  ats_client_id_type client_id = 0;

  ats_client_err_e_type ats_client_release_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT8( srv, &client_id );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  ats_client_release_result = ats_client_release(client_id);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &ats_client_release_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* ats_client_release_0x00040005 */

static void ats_client_deactivate_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  ats_client_id_type client_id = 0;

  ats_client_err_e_type ats_client_deactivate_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT8( srv, &client_id );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  ats_client_deactivate_result = ats_client_deactivate(client_id);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &ats_client_deactivate_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* ats_client_deactivate_0x00040005 */

static void ats_client_reg_cfg_cb_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 cb_id1;
  ats_client_id_type client_id = 0;
  ats_cfg_event_cb_type cb1;

  ats_client_err_e_type ats_client_reg_cfg_cb_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT8( srv, &client_id );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id1 );
  }

  /*lint -save -e611*/
  cb1 = (ats_cfg_event_cb_type) rpc_svc_callback_register( (void *) ats_cfg_event_cb_type_clnt_0x00040005, srv, cb_id1 ); 
  /*lint -restore */

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  ats_client_reg_cfg_cb_result = ats_client_reg_cfg_cb(client_id, cb1);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &ats_client_reg_cfg_cb_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* ats_client_reg_cfg_cb_0x00040005 */

static void ats_client_activate_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  ats_client_id_type client_id = 0;

  ats_client_err_e_type ats_client_activate_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT8( srv, &client_id );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  ats_client_activate_result = ats_client_activate(client_id);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &ats_client_activate_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* ats_client_activate_0x00040005 */

static void time_remote_genoff_opr_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  time_bases_type base = ATS_RTC;
  time_unit_type unit = TIME_STAMP;
  time_genoff_opr_type operation = T_SET;
  base_time_source_type base_source = TIME_SCLK;
  time_remote_opr_type *ts_val = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &base );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &unit );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_RECV_ENUM( srv, &operation );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_RECV_ENUM( srv, &base_source );
  }

  /* XDR OP NUMBER = 5 */
  if ( xdr_status )
  {
    xdr_op_number = 5;
    /*lint -save -e123*/
    XDR_RECV_U_POINTER2( srv, &ts_val, &(unit), xdr_time_remote_atom_recv_time_remote_opr, XDR_RECV_ENUM, xdr_status );
    /*lint -restore */
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_remote_genoff_opr(base, unit, operation, base_source, ts_val);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_SEND_U_POINTER2( srv, &ts_val, &(unit), xdr_time_remote_atom_send_time_remote_opr, XDR_SEND_ENUM, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_genoff_opr_0x00040005 */

static void time_remote_atom_genoff_set_generic_offset_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  time_bases_type base = ATS_RTC;
  int64 offset;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &base );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_INT64( srv, &offset );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_remote_atom_genoff_set_generic_offset(base, offset);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_atom_genoff_set_generic_offset_0x00040005 */

static void timer_ipc_remote_set_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 cb_id1;
  boolean output_pointer_not_null;
  timetick_type time = 0;
  timetick_type reload = 0;
  timer_unit_type unit = T_SCLK;
  boolean defer = FALSE;
  ats_cfg_event_cb_type cb1;
  uint32 *handle = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &time );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT32( srv, &reload );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_RECV_ENUM( srv, &unit );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_RECV_BOOLEAN( srv, &defer );
  }

  /* XDR OP NUMBER = 5 */
  if ( xdr_status )
  {
    xdr_op_number = 5;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id1 );
  }

  /*lint -save -e611*/
  cb1 = (ats_cfg_event_cb_type) rpc_svc_callback_register( (void *) ats_cfg_event_cb_type_clnt_0x00040005, srv, cb_id1 ); 
  /*lint -restore */

  /* XDR OP NUMBER = 6 */
  if ( xdr_status )
  {
    xdr_op_number = 6;
    /* The server must know whether to allocate memory for the output parameter
     * handle or not. A boolean is received to indicate that.
     */
    xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

    if ( xdr_status && output_pointer_not_null ) {
      handle = oncrpcxdr_mem_alloc( srv, sizeof(*handle) );
    }
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  timer_ipc_remote_set(time, reload, unit, defer, cb1, handle);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &handle, XDR_SEND_UINT32, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* timer_ipc_remote_set_0x00040005 */

static void timer_ipc_remote_clr_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean output_pointer_not_null;
  uint32 handle = 0;
  timer_unit_type unit = T_SCLK;
  timetick_type *retval = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &handle );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &unit );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /* The server must know whether to allocate memory for the output parameter
     * retval or not. A boolean is received to indicate that.
     */
    xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

    if ( xdr_status && output_pointer_not_null ) {
      retval = oncrpcxdr_mem_alloc( srv, sizeof(*retval) );
    }
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  timer_ipc_remote_clr(handle, unit, retval);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &retval, XDR_SEND_UINT32, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* timer_ipc_remote_clr_0x00040005 */

static void timer_ipc_remote_pause_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 handle = 0;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &handle );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  timer_ipc_remote_pause(handle);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* timer_ipc_remote_pause_0x00040005 */

static void timer_ipc_remote_resume_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 handle = 0;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &handle );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  timer_ipc_remote_resume(handle);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* timer_ipc_remote_resume_0x00040005 */

static void timer_ipc_remote_get_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean output_pointer_not_null;
  uint32 handle = 0;
  timer_unit_type unit = T_SCLK;
  timetick_type *retval = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &handle );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &unit );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /* The server must know whether to allocate memory for the output parameter
     * retval or not. A boolean is received to indicate that.
     */
    xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

    if ( xdr_status && output_pointer_not_null ) {
      retval = oncrpcxdr_mem_alloc( srv, sizeof(*retval) );
    }
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  timer_ipc_remote_get(handle, unit, retval);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &retval, XDR_SEND_UINT32, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* timer_ipc_remote_get_0x00040005 */

static void time_remote_genoff_set_allow_remote_updates_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 curbs = 0;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &curbs );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_remote_genoff_set_allow_remote_updates(curbs);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_genoff_set_allow_remote_updates_0x00040005 */

/*=========================================================================== 
              API Standard function for api versioning
===========================================================================*/

static void time_remote_atom_api_versions_0x00040005( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 i;
  boolean output_pointer_not_null;
  uint32 length_uint32;
  uint32 *len = NULL;

  uint32 *time_remote_atom_api_versions_result = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  /* The server must know whether to allocate memory for the output parameter
   * len or not. A boolean is received to indicate that.
   */
  xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

  if ( xdr_status && output_pointer_not_null ) {
    len = oncrpcxdr_mem_alloc( srv, sizeof(*len) );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  time_remote_atom_api_versions_result = time_remote_atom_api_versions(len);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    if ( time_remote_atom_api_versions_result != NULL ) {
      length_uint32 = *len;

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );

      /* XDR OP NUMBER = 3 */
      if ( xdr_status )
      {
        xdr_op_number  = 3;

        /* Calling array of XDR routines */
        for ( i = 0; xdr_status && i < (length_uint32); i++ ) {
          /*lint -save -e545*/
          xdr_status = XDR_SEND_UINT32( srv, &(time_remote_atom_api_versions_result[i]) );
          /*lint -restore */
        }
      }
    } else {
      length_uint32 = 0;

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );
    }
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &len, XDR_SEND_UINT32, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* time_remote_atom_api_versions_0x00040005 */

/*=========================================================================== 
              API Callback Clients
===========================================================================*/

static ats_client_err_e_type ats_cfg_event_cb_type_clnt_0x00040005(ats_cfg_event_e_type event,  ats_cfg_event_info_s_type *info_ptr)
{
  xdr_s_type       *clnt          = NULL;
  rpc_reply_header  reply_header;
  rpc_cb_data_type *rpc_cb_data   = NULL;
  boolean           xdr_status    = TRUE;
  int               xdr_op_number = 0;

  ats_client_err_e_type cmd_cb_func_result;


  rpc_cb_data = rpc_svc_cb_data_lookup();

  if ( rpc_cb_data == NULL )
  {
    RPC_SVC_CB_DATA_LOOKUP_ERR();
    return ATS_CLIENT_ERR_RPC;
  }

  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMCBPROG, ATS_CFG_EVENT_CB_TYPE_VERS,
                                   ONCRPC_ATS_CFG_EVENT_CB_TYPE_PROC, &Time_remote_atomcbCred, &Time_remote_atomcbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_ENUM( clnt, &event );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    /*lint -save -e123*/
    XDR_SEND_U_POINTER2( clnt, &info_ptr, &(event), xdr_time_remote_atom_send_ats_cfg_event_info_u, XDR_SEND_ENUM, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return ATS_CLIENT_ERR_RPC;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return ATS_CLIENT_ERR_RPC;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( clnt, &cmd_cb_func_result );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
        XDR_OP_ERR( clnt, xdr_op_number );
    return ATS_CLIENT_ERR_RPC;
  }

  return cmd_cb_func_result;
} /* ats_cfg_event_cb_type_clnt_0x00040005 */


