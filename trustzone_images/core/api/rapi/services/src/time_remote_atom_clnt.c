/* TIME_REMOTE_ATOM TOOL VERSION: 4.39 */
/* GENERATED: TUE AUG 17 2010 */
/*=============================================================================
                 T I M E _ R E M O T E _ A T O M _ C L N T . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that provides RPC client functionality for the
  time_remote_atom API.

  ---------------------------------------------------------------------------
  Copyright (c) 2010 Qualcomm Technologies Incorporated.
  All Rights Reserved. QUALCOMM Proprietary and Confidential.
  ---------------------------------------------------------------------------
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */
/* Generated by following versions of Htorpc modules:
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/htorpc.pl#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/Start.pm#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/Htoxdr.pm#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/XDR.pm#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/Output.pm#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/Parser.pm#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/Metacomments.pm#8 
Id: //source/qcom/qct/core/pkg/2H09/halcyon_modem/main/latest/AMSS/products/7x30/tools/htorpc/lib/Htorpc/SymbolTable.pm#8   

time_remote_atom Definition File(s):
Id: //source/qcom/qct/core/api/services/time/main/latest/time_remote_atom.h#1
=============================================================================*/
/*=============================================================================
$Header: //components/rel/tz.bf/2.5.c10/trustzone_images/core/api/rapi/services/src/time_remote_atom_clnt.c#1 $ 
=============================================================================*/


/* Include files */
#include "oncrpc.h"
#include "time_remote_atom.h"
#include "time_remote_atom_rpc.h"

/* Only one copy needed per API */
static opaque_auth Time_remote_atomCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth Time_remote_atomVerf = { ONCRPC_AUTH_NONE, 0, 0 };

//static opaque_auth Time_remote_atomcbCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth Time_remote_atomcbVerf = { ONCRPC_AUTH_NONE, 0, 0 };


/*=======================================================================
             Prototypes for the API Callbacks RPC Server Functions
=======================================================================*/
  
static void time_remote_atomcbprog_0x00040005 ( struct svc_req *rqstp, xdr_s_type *srv );

static void ats_cfg_event_cb_type_svc_0x00040005( xdr_s_type *srv );


/*=======================================================================
             API RPC Clients Implementation
=======================================================================*/

boolean time_remote_atom_null(void)
{
  xdr_s_type       *clnt;
  rpc_reply_header  reply_header;
  boolean           xdr_status = TRUE;
  int               xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOM_NULL_VERS, 0);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOM_NULL_VERS, 0);
    return FALSE;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  if ( ! xdr_call_msg_start( clnt,
                             TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOM_NULL_VERS,
                             ONCRPC_TIME_REMOTE_ATOM_NULL_PROC, &Time_remote_atomCred, &Time_remote_atomVerf ) ) {
    XDR_OP_ERR( clnt, xdr_op_number );
    return FALSE;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return FALSE;
  }
  /* XDR OP NUMBER = 1 */

  if ( reply_header.stat != RPC_MSG_ACCEPTED )
  {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }
  else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS )
  {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    /* XDR OP NUMBER = 2 */
    xdr_op_number = 2;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return FALSE;
  }
  else
  {
    return TRUE;
  }
} /* time_remote_atom_null */

boolean time_remote_atom_rpc_glue_code_info_remote
(
  uint32 *toolvers,
  uint32 *features,
  uint32 *proghash,
  uint32 *cbproghash
)
{
  xdr_s_type       *clnt;
  rpc_reply_header  reply_header;
  uint32            result = 0;
  boolean           xdr_status = TRUE;
  int               xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOM_RPC_GLUE_CODE_INFO_REMOTE_VERS, 0);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOM_RPC_GLUE_CODE_INFO_REMOTE_VERS, 0);
    return FALSE;
  }
  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  if ( ! xdr_call_msg_start( clnt,
                             TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOM_RPC_GLUE_CODE_INFO_REMOTE_VERS,
                             ONCRPC_TIME_REMOTE_ATOM_RPC_GLUE_CODE_INFO_REMOTE_PROC, &Time_remote_atomCred, &Time_remote_atomVerf ) ) {
    XDR_OP_ERR( clnt, xdr_op_number );
    return FALSE;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    // return here without calling XDR_MSG_DONE
    return FALSE;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  if ( reply_header.stat != RPC_MSG_ACCEPTED )
  {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }
  else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS )
  {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    /* XDR OP NUMBER = 2 */
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT32( clnt, &result );
  }

  if ( xdr_status )
  {
    if ( toolvers != NULL )
    {
      *toolvers = result;
    }
    /* XDR OP NUMBER = 3 */
    xdr_op_number = 3;
    xdr_status = XDR_RECV_UINT32( clnt, &result );
  }
  if ( xdr_status )
  {
    if ( features != NULL )
    {
      *features = result;
    }
    /* XDR OP NUMBER = 4 */
    xdr_op_number = 4;
    xdr_status = XDR_RECV_UINT32( clnt, &result );
  }

  if ( xdr_status )
  {
    if ( proghash != NULL )
    {
      *proghash = result;
    }
    /* XDR OP NUMBER = 5 */
    xdr_op_number = 5;
    xdr_status = XDR_RECV_UINT32( clnt, &result );
  }
  if ( xdr_status )
  {
    if ( cbproghash != NULL )
    {
      *cbproghash = result;
    }
    /* XDR OP NUMBER = 6 */
    xdr_op_number = 6;
  }

  if ( xdr_status )
  {
    /* XDR OP NUMBER = 7 */
    xdr_op_number = 7;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return FALSE;
  }
  else
  {
    return TRUE;
  }
} /* time_remote_atom_rpc_glue_code_info_remote */

boolean time_remote_atom_rpc_glue_code_info_local
(
  uint32 *toolvers,
  uint32 *features,
  uint32 *proghash,
  uint32 *cbproghash
)
{
  if ( toolvers != NULL )
  {
    *toolvers = TIME_REMOTE_ATOM_TOOLVERS; /* 4.39 */
  }

  if ( features != NULL )
  {
    *features = TIME_REMOTE_ATOM_FEATURES; /* ONCRPC Server Cleanup Support */
                
  }

  if ( proghash != NULL )
  {
    *proghash = 0x00040005; /* 0x00040005 */
  }

  if ( cbproghash != NULL )
  {
    *cbproghash = 0x00040005; /* 0x00040005 */
  }

  return TRUE;
} /* time_remote_atom_rpc_glue_code_info_local */

void time_remote_set_user_time_external(time_type ts_val)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  int i;
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_SET_USER_TIME_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_SET_USER_TIME_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_REMOTE_SET_USER_TIME_VERS,
                                   ONCRPC_TIME_REMOTE_SET_USER_TIME_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;

    /* Calling array of XDR routines */
    for ( i = 0; xdr_status && i < (2); i++ ) {
      /*lint -save -e545*/
      xdr_status = XDR_SEND_UINT32( clnt, &(ts_val[i]) );
      /*lint -restore */
    }
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_remote_set_user_time_external */

int32 time_alarm_set(uint32 expiration)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  int32 time_alarm_set_result;

  do {
    clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_ALARM_SET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(TIME_REMOTE_ATOMPROG, TIME_ALARM_SET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               TIME_REMOTE_ATOMPROG, TIME_ALARM_SET_VERS,
                               ONCRPC_TIME_ALARM_SET_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

    (void) XDR_SEND_UINT32( clnt, &expiration );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_INT32( clnt, &time_alarm_set_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return time_alarm_set_result;
} /* time_alarm_set */

void time_get_local_offset_info(int32 *local_timezone,  boolean *daylight_savings)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean output_pointer_not_null;
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_GET_LOCAL_OFFSET_INFO_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_GET_LOCAL_OFFSET_INFO_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_GET_LOCAL_OFFSET_INFO_VERS,
                                   ONCRPC_TIME_GET_LOCAL_OFFSET_INFO_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /* Send TRUE if local_timezone is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (local_timezone != NULL);

    xdr_status = XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /* Send TRUE if daylight_savings is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (daylight_savings != NULL);

    xdr_status = XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_RECV_POINTER( clnt, &local_timezone, XDR_RECV_INT32, xdr_status );
    /*lint -restore */
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /*lint -save -e123*/
    XDR_RECV_POINTER( clnt, &daylight_savings, XDR_RECV_BOOLEAN, xdr_status );
    /*lint -restore */
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_get_local_offset_info */

void time_tod_request_apps_bases(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_TOD_REQUEST_APPS_BASES_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_TOD_REQUEST_APPS_BASES_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_TOD_REQUEST_APPS_BASES_VERS,
                                   ONCRPC_TIME_TOD_REQUEST_APPS_BASES_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_tod_request_apps_bases */

void time_tod_request_reset(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_TOD_REQUEST_RESET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_TOD_REQUEST_RESET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_TOD_REQUEST_RESET_VERS,
                                   ONCRPC_TIME_TOD_REQUEST_RESET_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_tod_request_reset */

void time_remote_set_julian(time_julian_type *jul_time)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_SET_JULIAN_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_SET_JULIAN_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_REMOTE_SET_JULIAN_VERS,
                                   ONCRPC_TIME_REMOTE_SET_JULIAN_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    XDR_SEND_POINTER( clnt, &jul_time, xdr_time_remote_atom_send_time_julian_type, xdr_status );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_remote_set_julian */

void time_remote_get_julian(time_julian_type *jul_time)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean output_pointer_not_null;
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_GET_JULIAN_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_GET_JULIAN_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_REMOTE_GET_JULIAN_VERS,
                                   ONCRPC_TIME_REMOTE_GET_JULIAN_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /* Send TRUE if jul_time is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (jul_time != NULL);

    xdr_status = XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    XDR_RECV_POINTER( clnt, &jul_time, xdr_time_remote_atom_recv_time_julian_type, xdr_status );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_remote_get_julian */

void time_remote_secure_set(uint64 *ts_val)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_SECURE_SET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_SECURE_SET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_REMOTE_SECURE_SET_VERS,
                                   ONCRPC_TIME_REMOTE_SECURE_SET_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_SEND_POINTER( clnt, &ts_val, XDR_SEND_UINT64, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_remote_secure_set */

void time_remote_secure_get(uint64 *ts_val)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean output_pointer_not_null;
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_SECURE_GET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_SECURE_GET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_REMOTE_SECURE_GET_VERS,
                                   ONCRPC_TIME_REMOTE_SECURE_GET_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /* Send TRUE if ts_val is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (ts_val != NULL);

    xdr_status = XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_RECV_POINTER( clnt, &ts_val, XDR_RECV_UINT64, xdr_status );
    /*lint -restore */
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_remote_secure_get */

void time_remote_secure_get_julian(time_julian_type *julian)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean output_pointer_not_null;
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_SECURE_GET_JULIAN_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_SECURE_GET_JULIAN_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_REMOTE_SECURE_GET_JULIAN_VERS,
                                   ONCRPC_TIME_REMOTE_SECURE_GET_JULIAN_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /* Send TRUE if julian is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (julian != NULL);

    xdr_status = XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    XDR_RECV_POINTER( clnt, &julian, xdr_time_remote_atom_recv_time_julian_type, xdr_status );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_remote_secure_get_julian */

boolean time_remote_secure_valid(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean time_remote_secure_valid_result;

  do {
    clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_SECURE_VALID_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(TIME_REMOTE_ATOMPROG, TIME_SECURE_VALID_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               TIME_REMOTE_ATOMPROG, TIME_SECURE_VALID_VERS,
                               ONCRPC_TIME_SECURE_VALID_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &time_remote_secure_valid_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return time_remote_secure_valid_result;
} /* time_remote_secure_valid */

int32 time_alarm_set_ms(uint32 expiration)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  int32 time_alarm_set_ms_result;

  do {
    clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_ALARM_SET_MS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(TIME_REMOTE_ATOMPROG, TIME_ALARM_SET_MS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               TIME_REMOTE_ATOMPROG, TIME_ALARM_SET_MS_VERS,
                               ONCRPC_TIME_ALARM_SET_MS_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

    (void) XDR_SEND_UINT32( clnt, &expiration );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_INT32( clnt, &time_alarm_set_ms_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return time_alarm_set_ms_result;
} /* time_alarm_set_ms */

int32 time_alarm_set_secs(uint32 expiration)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  int32 time_alarm_set_secs_result;

  do {
    clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_ALARM_SET_SECS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(TIME_REMOTE_ATOMPROG, TIME_ALARM_SET_SECS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               TIME_REMOTE_ATOMPROG, TIME_ALARM_SET_SECS_VERS,
                               ONCRPC_TIME_ALARM_SET_SECS_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

    (void) XDR_SEND_UINT32( clnt, &expiration );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_INT32( clnt, &time_alarm_set_secs_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return time_alarm_set_secs_result;
} /* time_alarm_set_secs */

void time_remote_update_apps_to_modem_offset(int32 offset)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_UPDATE_APPS_TO_MODEM_OFFSET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_UPDATE_APPS_TO_MODEM_OFFSET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_REMOTE_UPDATE_APPS_TO_MODEM_OFFSET_VERS,
                                   ONCRPC_TIME_REMOTE_UPDATE_APPS_TO_MODEM_OFFSET_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_INT32( clnt, &offset );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_remote_update_apps_to_modem_offset */

void time_remote_secure_set_julian(time_julian_type *julian)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_SECURE_SET_JULIAN_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_SECURE_SET_JULIAN_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_REMOTE_SECURE_SET_JULIAN_VERS,
                                   ONCRPC_TIME_REMOTE_SECURE_SET_JULIAN_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    XDR_SEND_POINTER( clnt, &julian, xdr_time_remote_atom_send_time_julian_type, xdr_status );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_remote_secure_set_julian */

ats_client_err_e_type ats_client_init(ats_client_type_e_type client_type,  ats_client_id_type *client_id_ptr,  ats_client_processor_e_type processor)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  ats_client_err_e_type ats_client_init_result;

  do {
    clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, ATS_CLIENT_INIT_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(TIME_REMOTE_ATOMPROG, ATS_CLIENT_INIT_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               TIME_REMOTE_ATOMPROG, ATS_CLIENT_INIT_VERS,
                               ONCRPC_ATS_CLIENT_INIT_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

    (void) XDR_SEND_ENUM( clnt, &client_type );

    /*lint -save -e123*/
    XDR_SEND_POINTER_NO_ERRCHK( clnt, &client_id_ptr, XDR_SEND_UINT8 );
    /*lint -restore */

    (void) XDR_SEND_ENUM( clnt, &processor );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &ats_client_init_result );

  /*lint -save -e123*/
  XDR_RECV_POINTER_NO_ERRCHK( clnt, &client_id_ptr, XDR_RECV_UINT8 );
  /*lint -restore */


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return ats_client_init_result;
} /* ats_client_init */

ats_client_err_e_type ats_client_release(ats_client_id_type client_id)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  ats_client_err_e_type ats_client_release_result;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, ATS_CLIENT_RELEASE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, ATS_CLIENT_RELEASE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return ATS_CLIENT_ERR_RPC;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, ATS_CLIENT_RELEASE_VERS,
                                   ONCRPC_ATS_CLIENT_RELEASE_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT8( clnt, &client_id );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return ATS_CLIENT_ERR_RPC;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return ATS_CLIENT_ERR_RPC;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( clnt, &ats_client_release_result );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return ATS_CLIENT_ERR_RPC;
  }

  return ats_client_release_result;
} /* ats_client_release */

ats_client_err_e_type ats_client_deactivate(ats_client_id_type client_id)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  ats_client_err_e_type ats_client_deactivate_result;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, ATS_CLIENT_DEACTIVATE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, ATS_CLIENT_DEACTIVATE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return ATS_CLIENT_ERR_RPC;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, ATS_CLIENT_DEACTIVATE_VERS,
                                   ONCRPC_ATS_CLIENT_DEACTIVATE_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT8( clnt, &client_id );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return ATS_CLIENT_ERR_RPC;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return ATS_CLIENT_ERR_RPC;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( clnt, &ats_client_deactivate_result );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return ATS_CLIENT_ERR_RPC;
  }

  return ats_client_deactivate_result;
} /* ats_client_deactivate */

ats_client_err_e_type ats_client_reg_cfg_cb(ats_client_id_type client_id,  ats_cfg_event_cb_type cfg_event_cb)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  ats_client_err_e_type ats_client_reg_cfg_cb_result;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, ATS_CLIENT_REG_CFG_CB_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, ATS_CLIENT_REG_CFG_CB_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return ATS_CLIENT_ERR_RPC;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, ATS_CLIENT_REG_CFG_CB_VERS,
                                   ONCRPC_ATS_CLIENT_REG_CFG_CB_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT8( clnt, &client_id );
  }

  /*lint -save -e611*/
  cb_id = rpc_clnt_callback_register( (void *) cfg_event_cb );
  /*lint -restore */

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_UINT32( clnt, &cb_id );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return ATS_CLIENT_ERR_RPC;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return ATS_CLIENT_ERR_RPC;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( clnt, &ats_client_reg_cfg_cb_result );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return ATS_CLIENT_ERR_RPC;
  }

  return ats_client_reg_cfg_cb_result;
} /* ats_client_reg_cfg_cb */

ats_client_err_e_type ats_client_activate(ats_client_id_type client_id)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  ats_client_err_e_type ats_client_activate_result;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, ATS_CLIENT_ACTIVATE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, ATS_CLIENT_ACTIVATE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return ATS_CLIENT_ERR_RPC;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, ATS_CLIENT_ACTIVATE_VERS,
                                   ONCRPC_ATS_CLIENT_ACTIVATE_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT8( clnt, &client_id );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return ATS_CLIENT_ERR_RPC;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return ATS_CLIENT_ERR_RPC;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( clnt, &ats_client_activate_result );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return ATS_CLIENT_ERR_RPC;
  }

  return ats_client_activate_result;
} /* ats_client_activate */

void time_remote_genoff_opr(
  time_bases_type base,
  time_unit_type unit,
  time_genoff_opr_type operation,
  base_time_source_type base_source,
  time_remote_opr_type *ts_val
)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_GENOFF_OPR_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_GENOFF_OPR_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_REMOTE_GENOFF_OPR_VERS,
                                   ONCRPC_TIME_REMOTE_GENOFF_OPR_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( clnt, &base );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_ENUM( clnt, &unit );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_SEND_ENUM( clnt, &operation );
  }

  /* XDR OP NUMBER = 5 */
  if ( xdr_status )
  {
    xdr_op_number = 5;
    xdr_status = XDR_SEND_ENUM( clnt, &base_source );
  }

  /* XDR OP NUMBER = 6 */
  if ( xdr_status )
  {
    xdr_op_number = 6;
    /*lint -save -e123*/
    XDR_SEND_U_POINTER2( clnt, &ts_val, &(unit), xdr_time_remote_atom_send_time_remote_opr, XDR_SEND_ENUM, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_RECV_U_POINTER2( clnt, &ts_val, &(unit), xdr_time_remote_atom_recv_time_remote_opr, XDR_RECV_ENUM, xdr_status );
    /*lint -restore */
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_remote_genoff_opr */

void time_remote_atom_genoff_set_generic_offset(time_bases_type base,  int64 offset)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOM_GENOFF_SET_GENERIC_OFFSET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOM_GENOFF_SET_GENERIC_OFFSET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOM_GENOFF_SET_GENERIC_OFFSET_VERS,
                                   ONCRPC_TIME_REMOTE_ATOM_GENOFF_SET_GENERIC_OFFSET_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( clnt, &base );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_INT64( clnt, &offset );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_remote_atom_genoff_set_generic_offset */

void timer_ipc_remote_set(
  timetick_type time,
  timetick_type reload,
  timer_unit_type unit,
  boolean defer,
  ats_cfg_event_cb_type cfg_cb,
  uint32 *handle
)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  boolean output_pointer_not_null;
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_SET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_SET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_SET_VERS,
                                   ONCRPC_TIMER_IPC_REMOTE_SET_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &time );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_UINT32( clnt, &reload );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_SEND_ENUM( clnt, &unit );
  }

  /* XDR OP NUMBER = 5 */
  if ( xdr_status )
  {
    xdr_op_number = 5;
    xdr_status = XDR_SEND_BOOLEAN( clnt, &defer );
  }

  /*lint -save -e611*/
  cb_id = rpc_clnt_callback_register( (void *) cfg_cb );
  /*lint -restore */

  /* XDR OP NUMBER = 6 */
  if ( xdr_status )
  {
    xdr_op_number = 6;
    xdr_status = XDR_SEND_UINT32( clnt, &cb_id );
  }

  /* XDR OP NUMBER = 7 */
  if ( xdr_status )
  {
    xdr_op_number = 7;
    /* Send TRUE if handle is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (handle != NULL);

    xdr_status = XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_RECV_POINTER( clnt, &handle, XDR_RECV_UINT32, xdr_status );
    /*lint -restore */
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* timer_ipc_remote_set */

void timer_ipc_remote_clr(uint32 handle,  timer_unit_type unit,  timetick_type *retval)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean output_pointer_not_null;
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_CLR_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_CLR_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_CLR_VERS,
                                   ONCRPC_TIMER_IPC_REMOTE_CLR_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &handle );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_ENUM( clnt, &unit );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    /* Send TRUE if retval is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (retval != NULL);

    xdr_status = XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_RECV_POINTER( clnt, &retval, XDR_RECV_UINT32, xdr_status );
    /*lint -restore */
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* timer_ipc_remote_clr */

void timer_ipc_remote_pause(uint32 handle)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_PAUSE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_PAUSE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_PAUSE_VERS,
                                   ONCRPC_TIMER_IPC_REMOTE_PAUSE_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &handle );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* timer_ipc_remote_pause */

void timer_ipc_remote_resume(uint32 handle)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_RESUME_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_RESUME_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_RESUME_VERS,
                                   ONCRPC_TIMER_IPC_REMOTE_RESUME_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &handle );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* timer_ipc_remote_resume */

void timer_ipc_remote_get(uint32 handle,  timer_unit_type unit,  timetick_type *retval)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean output_pointer_not_null;
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_GET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_GET_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIMER_IPC_REMOTE_GET_VERS,
                                   ONCRPC_TIMER_IPC_REMOTE_GET_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &handle );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_ENUM( clnt, &unit );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    /* Send TRUE if retval is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (retval != NULL);

    xdr_status = XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /*lint -save -e123*/
    XDR_RECV_POINTER( clnt, &retval, XDR_RECV_UINT32, xdr_status );
    /*lint -restore */
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* timer_ipc_remote_get */

void time_remote_genoff_set_allow_remote_updates(uint32 curbs)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_GENOFF_SET_ALLOW_REMOTE_UPDATES_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(TIME_REMOTE_ATOMPROG, TIME_REMOTE_GENOFF_SET_ALLOW_REMOTE_UPDATES_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   TIME_REMOTE_ATOMPROG, TIME_REMOTE_GENOFF_SET_ALLOW_REMOTE_UPDATES_VERS,
                                   ONCRPC_TIME_REMOTE_GENOFF_SET_ALLOW_REMOTE_UPDATES_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &curbs );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* time_remote_genoff_set_allow_remote_updates */


/*=======================================================================
             API Standard Functions for version info
=======================================================================*/

uint32 *time_remote_atom_api_versions(uint32 *len)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 i;
  boolean output_pointer_not_null;
  void *memset_temp;
  uint32 length_uint32;
  uint32 *time_remote_atom_api_versions_result = NULL;

  do {
    clnt = rpc_clnt_lookup2(TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOM_API_VERSIONS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOM_API_VERSIONS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               TIME_REMOTE_ATOMPROG, TIME_REMOTE_ATOM_API_VERSIONS_VERS,
                               ONCRPC_TIME_REMOTE_ATOM_API_VERSIONS_PROC, &Time_remote_atomCred, &Time_remote_atomVerf );

    /* Send TRUE if len is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (len != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_UINT32( clnt, &length_uint32 );

  if ( length_uint32 > 0 )
  {
    memset_temp = oncrpcxdr_mem_alloc( clnt, length_uint32 * sizeof( *time_remote_atom_api_versions_result ));
    memset(memset_temp, 0, length_uint32 * sizeof( *time_remote_atom_api_versions_result ));
    time_remote_atom_api_versions_result = memset_temp;


    /* Calling array of XDR routines */
    for ( i = 0; i < (length_uint32); i++ ) {
      /*lint -save -e545*/
      (void) XDR_RECV_UINT32( clnt, &(time_remote_atom_api_versions_result[i]) );
      /*lint -restore */
    }
  }

  /*lint -save -e123*/
  XDR_RECV_POINTER_NO_ERRCHK( clnt, &len, XDR_RECV_UINT32 );
  /*lint -restore */


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return time_remote_atom_api_versions_result;
} /* time_remote_atom_api_versions */




/*=======================================================================
             API Callbacks RPC Server Implementation
=======================================================================*/

void time_remote_atomcb_app_init( void )
{
  (void) svc_register_auto(TIME_REMOTE_ATOMCBPROG, TIME_REMOTE_ATOMCBVERS, time_remote_atomcbprog_0x00040005);
} /* time_remote_atomcb_app_init */

void time_remote_atomcb_app_lock( boolean lock )
{
  svc_lock( TIME_REMOTE_ATOMCBPROG, TIME_REMOTE_ATOMCBVERS, lock );
} /* time_remote_atomcb_app_enable */

static void time_remote_atomcbprog_0x00040005( struct svc_req *rqstp, xdr_s_type *srv )
{
  switch( rqstp->rq_proc ) {
    case ONCRPC_ATS_CFG_EVENT_CB_TYPE_PROC:
      ats_cfg_event_cb_type_svc_0x00040005( srv );
      break;
    default:
      // invalid RPC procedure number
      (void) XDR_MSG_DONE( srv );
      svcerr_default_err( srv, rqstp, time_remote_atom_api_versions  );
      break;
  }

  oncrpcxdr_mem_free( srv );
} /* time_remote_atomcbprog_0x00040005 */

static void ats_cfg_event_cb_type_svc_0x00040005( xdr_s_type *srv )
{
  ats_cfg_event_cb_type cmd_cb_func;
  uint32  cb_id;
  boolean xdr_status = TRUE;
  int     xdr_op_number = 0;

  ats_cfg_event_e_type event = ATS_CFG_EVENT_TOD_CHANGE;
  ats_cfg_event_info_s_type *info_ptr = NULL;

  ats_client_err_e_type cmd_cb_func_result;


  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &cb_id );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &event );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /*lint -save -e123*/
    XDR_RECV_U_POINTER2( srv, &info_ptr, &(event), xdr_time_remote_atom_recv_ats_cfg_event_info_u, XDR_RECV_ENUM, xdr_status );
    /*lint -restore */
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }      

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cmd_cb_func = (ats_cfg_event_cb_type ) rpc_clnt_callback_lookup( cb_id );
  /*lint -restore */

  if ( cmd_cb_func == NULL ) {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  cmd_cb_func_result = cmd_cb_func(event, info_ptr);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Time_remote_atomcbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &cmd_cb_func_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* ats_cfg_event_cb_type_svc_0x00040005 */

