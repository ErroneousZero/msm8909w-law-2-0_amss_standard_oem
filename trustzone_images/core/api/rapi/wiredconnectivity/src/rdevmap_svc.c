/* RDEVMAP TOOL VERSION: 4.35 */
/*=============================================================================
                           R D E V M A P _ S V C . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that dispatches RPC requests targetting the
  rdevmap api.

  ---------------------------------------------------------------------------
  Copyright (c) 2009 Qualcomm Technologies Incorporated.
  All Rights Reserved. QUALCOMM Proprietary and Confidential.
  ---------------------------------------------------------------------------
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */
/* Generated by following versions of Htorpc modules:
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/htorpc.pl#6 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Start.pm#2 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Htoxdr.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/XDR.pm#2 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Output.pm#5 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Parser.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Metacomments.pm#3 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/SymbolTable.pm#2   

rdevmap Definition File(s):
Id: //source/qcom/qct/core/api/wiredconnectivity/rel/2h09/rdevmap.h#6
=============================================================================*/
/*=============================================================================
$Header: //components/rel/tz.bf/2.5.c10/trustzone_images/core/api/rapi/wiredconnectivity/src/rdevmap_svc.c#1 $ 
=============================================================================*/


/* Include files */
#include "oncrpc.h"
#include "rdevmap.h"
#include "rdevmap_rpc.h"

/* Only one copy needed per API */
//static opaque_auth RdevmapCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth RdevmapVerf = { ONCRPC_AUTH_NONE, 0, 0 };

static opaque_auth RdevmapcbCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth RdevmapcbVerf = { ONCRPC_AUTH_NONE, 0, 0 };

/*=======================================================================
             Prototypes for the API's RPC Server Functions
=======================================================================*/

static void rdevmapprog_0x00010001 ( struct svc_req *rqstp, xdr_s_type *srv );
static void rdevmap_null_0x00010001( xdr_s_type *svc );
static void rdevmap_rpc_glue_code_info_remote_0x00010001( xdr_s_type *svc );
static void rdevmap_api_versions_0x00010001( xdr_s_type *srv );

static void rdm_issue_opens_0x00010001( xdr_s_type *srv );

static void rdm_assign_port_0x00010001( xdr_s_type *srv );

static void rdm_assign_port_tmp_0x00010001( xdr_s_type *srv );

static void rdm_close_device_0x00010001( xdr_s_type *srv );

static void rdm_notify_0x00010001( xdr_s_type *srv );

static void rdm_get_device_0x00010001( xdr_s_type *srv );

static void rdm_get_service_0x00010001( xdr_s_type *srv );

static void rdm_get_valid_ports_0x00010001( xdr_s_type *srv );

static void rdm_register_open_func_0x00010001( xdr_s_type *srv );

static void rdm_register_close_func_0x00010001( xdr_s_type *srv );

static void rdm_register_func_multi_dev_0x00010001( xdr_s_type *srv );

static void rdm_get_device_str_0x00010001( xdr_s_type *srv );

static void rdm_is_srv_holding_dev_0x00010001( xdr_s_type *srv );

static void rdm_set_srv_compat_mask_0x00010001( xdr_s_type *srv );

static void rdm_is_srv_dev_compat_0x00010001( xdr_s_type *srv );


/*=======================================================================
             Prototypes for the API's Callback RPC clients
=======================================================================*/

static void rdm_assign_port_cb_type_clnt_0x00010001(rdm_assign_status_type arg1,  rdm_service_enum_type arg2,  rdm_device_enum_type arg3);

static void rdm_service_close_func_ptr_type_clnt_0x00010001(void);

static void rdm_service_open_func_ptr_type_clnt_0x00010001(sio_port_id_type arg1);

static void rdm_srv_func_ptr_multi_dev_type_clnt_0x00010001(sio_port_id_type port,  void *data);

/******************************************************************************/
/*=======================================================================
             API RPC Server Implementation
=======================================================================*/
static uint32 rdevmap_api_versions_table[] = { 0x00010001 };

uint32 * rdevmap_api_versions(uint32 *size_entries)
{
  *size_entries = sizeof( rdevmap_api_versions_table) / sizeof(uint32);
  return rdevmap_api_versions_table;
}

void rdevmap_app_init( void )
{
  (void) svc_register_auto_apiversions(RDEVMAPPROG, RDEVMAPVERS, rdevmapprog_0x00010001, 
                                       rdevmap_api_versions);
} /* rdevmap_app_init */

void rdevmap_app_lock( boolean lock )
{
  svc_lock( RDEVMAPPROG, RDEVMAPVERS, lock );
} /* rdevmap_app_lock */

static void rdevmapprog_0x00010001 ( struct svc_req *rqstp, xdr_s_type *srv )
{
  switch ( rqstp->rq_proc ) {
    case ONCRPC_RDEVMAP_NULL_PROC:
      rdevmap_null_0x00010001( srv );
      break;
    case ONCRPC_RDEVMAP_RPC_GLUE_CODE_INFO_REMOTE_PROC:
      rdevmap_rpc_glue_code_info_remote_0x00010001( srv );
      break;
    case ONCRPC_RDM_ISSUE_OPENS_PROC:
      rdm_issue_opens_0x00010001( srv );
      break;
    case ONCRPC_RDM_ASSIGN_PORT_PROC:
      rdm_assign_port_0x00010001( srv );
      break;
    case ONCRPC_RDM_ASSIGN_PORT_TMP_PROC:
      rdm_assign_port_tmp_0x00010001( srv );
      break;
    case ONCRPC_RDM_CLOSE_DEVICE_PROC:
      rdm_close_device_0x00010001( srv );
      break;
    case ONCRPC_RDM_NOTIFY_PROC:
      rdm_notify_0x00010001( srv );
      break;
    case ONCRPC_RDM_GET_DEVICE_PROC:
      rdm_get_device_0x00010001( srv );
      break;
    case ONCRPC_RDM_GET_SERVICE_PROC:
      rdm_get_service_0x00010001( srv );
      break;
    case ONCRPC_RDM_GET_VALID_PORTS_PROC:
      rdm_get_valid_ports_0x00010001( srv );
      break;
    case ONCRPC_RDM_REGISTER_OPEN_FUNC_PROC:
      rdm_register_open_func_0x00010001( srv );
      break;
    case ONCRPC_RDM_REGISTER_CLOSE_FUNC_PROC:
      rdm_register_close_func_0x00010001( srv );
      break;
    case ONCRPC_RDM_REGISTER_FUNC_MULTI_DEV_PROC:
      rdm_register_func_multi_dev_0x00010001( srv );
      break;
    case ONCRPC_RDM_GET_DEVICE_STR_PROC:
      rdm_get_device_str_0x00010001( srv );
      break;
    case ONCRPC_RDM_IS_SRV_HOLDING_DEV_PROC:
      rdm_is_srv_holding_dev_0x00010001( srv );
      break;
    case ONCRPC_RDM_SET_SRV_COMPAT_MASK_PROC:
      rdm_set_srv_compat_mask_0x00010001( srv );
      break;
    case ONCRPC_RDM_IS_SRV_DEV_COMPAT_PROC:
      rdm_is_srv_dev_compat_0x00010001( srv );
      break;
    case ONCRPC_RDEVMAP_API_VERSIONS_PROC:
      rdevmap_api_versions_0x00010001( srv );
      break;

    default:
      // invalid RPC procedure number
      (void) XDR_MSG_DONE( srv );
      svcerr_default_err( srv, rqstp, rdevmap_api_versions  );
      break;
  }

  oncrpcxdr_mem_free( srv );
} /* rdevmapprog_0x00010001 */

/******************************************************************************/

static void rdevmap_null_0x00010001( xdr_s_type *srv )
{
  if ( ! XDR_MSG_DONE( srv ) ) {
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  if ( ! xdr_reply_msg_start( srv, &RdevmapVerf ) ) {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdevmap_null_0x00010001 */

static void rdevmap_rpc_glue_code_info_remote_0x00010001( xdr_s_type *srv )
{
  uint32 toolvers   = RDEVMAP_TOOLVERS; /* 4.35 */
  uint32 proghash   = 0x00010001; /* 0x00010001 */
  uint32 cbproghash = 0x00010001; /* 0x00010001 */
  uint32 features   = RDEVMAP_FEATURES; /* ONCRPC Server Cleanup Support */
                      

  if ( ! XDR_MSG_DONE( srv ) ) {
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  if ( ! xdr_reply_msg_start( srv, &RdevmapVerf ) ||
       ! XDR_SEND_UINT32( srv, &toolvers ) ||
       ! XDR_SEND_UINT32( srv, &features ) ||
       ! XDR_SEND_UINT32( srv, &proghash ) ||
       ! XDR_SEND_UINT32( srv, &cbproghash ) )
  {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdevmap_rpc_glue_code_info_remote_0x00010001 */

static void rdm_issue_opens_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_issue_remote_opens();

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_issue_opens_0x00010001 */

static void rdm_assign_port_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 cb_id1;
  rdm_service_enum_type service = RDM_NULL_SRVC;
  rdm_device_enum_type device = RDM_SRVC_NOT_ALLOWED;
  rdm_assign_port_cb_type cb1;

  boolean rdm_assign_port_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &service );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &device );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id1 );
  }

  /*lint -save -e611*/
  cb1 = (rdm_assign_port_cb_type) rpc_svc_callback_register( (void *) rdm_assign_port_cb_type_clnt_0x00010001, srv, cb_id1 ); 
  /*lint -restore */

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_assign_port_result = rdm_assign_port(service, device, cb1);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( srv, &rdm_assign_port_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_assign_port_0x00010001 */

static void rdm_assign_port_tmp_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 cb_id1;
  rdm_service_enum_type service = RDM_NULL_SRVC;
  rdm_device_enum_type device = RDM_SRVC_NOT_ALLOWED;
  rdm_assign_port_cb_type cb1;

  boolean rdm_assign_port_tmp_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &service );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &device );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id1 );
  }

  /*lint -save -e611*/
  cb1 = (rdm_assign_port_cb_type) rpc_svc_callback_register( (void *) rdm_assign_port_cb_type_clnt_0x00010001, srv, cb_id1 ); 
  /*lint -restore */

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_assign_port_tmp_result = rdm_assign_port_tmp(service, device, cb1);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( srv, &rdm_assign_port_tmp_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_assign_port_tmp_0x00010001 */

static void rdm_close_device_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 cb_id1;
  rdm_service_enum_type service = RDM_NULL_SRVC;
  rdm_device_enum_type device = RDM_SRVC_NOT_ALLOWED;
  rdm_assign_port_cb_type cb1;

  boolean rdm_close_device_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &service );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &device );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id1 );
  }

  /*lint -save -e611*/
  cb1 = (rdm_assign_port_cb_type) rpc_svc_callback_register( (void *) rdm_assign_port_cb_type_clnt_0x00010001, srv, cb_id1 ); 
  /*lint -restore */

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_close_device_result = rdm_close_device(service, device, cb1);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( srv, &rdm_close_device_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_close_device_0x00010001 */

static void rdm_notify_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  rdm_service_enum_type service = RDM_NULL_SRVC;
  rdm_assign_status_type status = RDM_NOT_ALLOWED_S;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &service );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &status );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_notify(service, status);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_notify_0x00010001 */

static void rdm_get_device_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  rdm_service_enum_type service = RDM_NULL_SRVC;

  rdm_device_enum_type rdm_get_device_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &service );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_get_device_result = rdm_get_device(service);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &rdm_get_device_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_get_device_0x00010001 */

static void rdm_get_service_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  rdm_device_enum_type device = RDM_SRVC_NOT_ALLOWED;

  rdm_service_enum_type rdm_get_service_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &device );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_get_service_result = rdm_get_service(device);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &rdm_get_service_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_get_service_0x00010001 */

static void rdm_get_valid_ports_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 i;
  void *memset_temp;
  uint32 length_uint32;
  rdm_service_enum_type service = RDM_NULL_SRVC;
  rdm_service_display_type (*devices) = NULL;

  boolean rdm_get_valid_ports_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &service );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT32( srv, &length_uint32 );

    /* XDR OP NUMBER = 3 */
    if ( xdr_status && length_uint32 > 0 )
    {
      xdr_op_number  = 3;
      memset_temp = oncrpcxdr_mem_alloc( srv, length_uint32 * sizeof( *devices ));
      memset(memset_temp, 0, length_uint32 * sizeof( *devices ));
      devices = memset_temp;


      /* Calling array of XDR routines */
      for ( i = 0; xdr_status && i < (length_uint32); i++ ) {
        /*lint -save -e545*/
        xdr_status = xdr_rdevmap_recv_rdm_service_display_type( srv, &(devices[i]) );
        /*lint -restore */
      }
    }
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_get_valid_ports_result = rdm_get_valid_ports(service, devices);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( srv, &rdm_get_valid_ports_result );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    if ( devices != NULL ) {
      length_uint32 = RDM_DEV_MAX;

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );

      /* XDR OP NUMBER = 4 */
      if ( xdr_status )
      {
        xdr_op_number  = 4;

        /* Calling array of XDR routines */
        for ( i = 0; xdr_status && i < (length_uint32); i++ ) {
          /*lint -save -e545*/
          xdr_status = xdr_rdevmap_send_rdm_service_display_type( srv, &(devices[i]) );
          /*lint -restore */
        }
      }
    } else {
      length_uint32 = 0;

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );
    }
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_get_valid_ports_0x00010001 */

static void rdm_register_open_func_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 cb_id1;
  rdm_service_enum_type service = RDM_NULL_SRVC;
  rdm_service_open_func_ptr_type cb1;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &service );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id1 );
  }

  /*lint -save -e611*/
  cb1 = (rdm_service_open_func_ptr_type) rpc_svc_callback_register( (void *) rdm_service_open_func_ptr_type_clnt_0x00010001, srv, cb_id1 ); 
  /*lint -restore */

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_register_remote_open_func(service, cb1);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_register_open_func_0x00010001 */

static void rdm_register_close_func_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 cb_id1;
  rdm_service_enum_type service = RDM_NULL_SRVC;
  rdm_service_close_func_ptr_type cb1;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &service );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id1 );
  }

  /*lint -save -e611*/
  cb1 = (rdm_service_close_func_ptr_type) rpc_svc_callback_register( (void *) rdm_service_close_func_ptr_type_clnt_0x00010001, srv, cb_id1 ); 
  /*lint -restore */

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_register_remote_close_func(service, cb1);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_register_close_func_0x00010001 */

static void rdm_register_func_multi_dev_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 cb_id1;
  uint32 cb_id2;
  rdm_service_enum_type service = RDM_NULL_SRVC;
  rdm_srv_func_ptr_multi_dev_type cb1;
  rdm_srv_func_ptr_multi_dev_type cb2;
  void *data;

  boolean rdm_register_func_multi_dev_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &service );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id1 );
  }

  /*lint -save -e611*/
  cb1 = (rdm_srv_func_ptr_multi_dev_type) rpc_svc_callback_register( (void *) rdm_srv_func_ptr_multi_dev_type_clnt_0x00010001, srv, cb_id1 ); 
  /*lint -restore */

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id2 );
  }

  /*lint -save -e611*/
  cb2 = (rdm_srv_func_ptr_multi_dev_type) rpc_svc_callback_register( (void *) rdm_srv_func_ptr_multi_dev_type_clnt_0x00010001, srv, cb_id2 ); 
  /*lint -restore */

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_RECV_HANDLE( srv, &data );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_register_func_multi_dev_result = rdm_register_remote_func_multi_dev(service, cb1, cb2, data);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( srv, &rdm_register_func_multi_dev_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_register_func_multi_dev_0x00010001 */

static void rdm_get_device_str_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  boolean output_pointer_not_null;
  uint32 length_uint32;
  rdm_device_enum_type device = RDM_SRVC_NOT_ALLOWED;
  char *str = NULL;

  boolean rdm_get_device_str_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &device );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /* The server must know whether to allocate memory for the output parameter
     * str or not. A boolean is received to indicate that. The maximum number
     * of objects that could be pointed to by this pointer is also received.
     */
    xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

    if ( xdr_status && output_pointer_not_null ) {

      xdr_status = XDR_RECV_UINT32( srv, &length_uint32 );

      str = oncrpcxdr_mem_alloc( srv, length_uint32 * sizeof(*str) );
    }
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_get_device_str_result = rdm_get_device_str(device, str);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( srv, &rdm_get_device_str_result );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    length_uint32 = 0;

    if ( str != NULL ) {
      while ( str[length_uint32++] != '\0' && length_uint32 < 13 );

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );

      /* XDR OP NUMBER = 4 */
      if ( xdr_status )
      {
        xdr_op_number  = 4;
        xdr_status = XDR_SEND_STRING(srv, str, length_uint32);
      }
    } else {
      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );

    }
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_get_device_str_0x00010001 */

static void rdm_is_srv_holding_dev_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  rdm_service_enum_type service = RDM_NULL_SRVC;
  rdm_device_enum_type device = RDM_SRVC_NOT_ALLOWED;

  boolean rdm_is_srv_holding_dev_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &service );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &device );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_is_srv_holding_dev_result = rdm_is_srv_holding_dev(service, device);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( srv, &rdm_is_srv_holding_dev_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_is_srv_holding_dev_0x00010001 */

static void rdm_set_srv_compat_mask_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  rdm_service_enum_type service = RDM_NULL_SRVC;
  uint32 dev_mask;

  boolean rdm_set_srv_compat_mask_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &service );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT32( srv, &dev_mask );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_set_srv_compat_mask_result = rdm_set_srv_compat_mask(service, dev_mask);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( srv, &rdm_set_srv_compat_mask_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_set_srv_compat_mask_0x00010001 */

static void rdm_is_srv_dev_compat_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  rdm_service_enum_type service = RDM_NULL_SRVC;
  rdm_device_enum_type device = RDM_SRVC_NOT_ALLOWED;

  boolean rdm_is_srv_dev_compat_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_ENUM( srv, &service );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &device );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdm_is_srv_dev_compat_result = rdm_is_srv_dev_compat(service, device);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( srv, &rdm_is_srv_dev_compat_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_is_srv_dev_compat_0x00010001 */

/*=========================================================================== 
              API Standard function for api versioning
===========================================================================*/

static void rdevmap_api_versions_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 i;
  boolean output_pointer_not_null;
  uint32 length_uint32;
  uint32 *len = NULL;

  uint32 *rdevmap_api_versions_result = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  /* The server must know whether to allocate memory for the output parameter
   * len or not. A boolean is received to indicate that.
   */
  xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

  if ( xdr_status && output_pointer_not_null ) {
    len = oncrpcxdr_mem_alloc( srv, sizeof(*len) );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  rdevmap_api_versions_result = rdevmap_api_versions(len);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    if ( rdevmap_api_versions_result != NULL ) {
      length_uint32 = *len;

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );

      /* XDR OP NUMBER = 3 */
      if ( xdr_status )
      {
        xdr_op_number  = 3;

        /* Calling array of XDR routines */
        for ( i = 0; xdr_status && i < (length_uint32); i++ ) {
          /*lint -save -e545*/
          xdr_status = XDR_SEND_UINT32( srv, &(rdevmap_api_versions_result[i]) );
          /*lint -restore */
        }
      }
    } else {
      length_uint32 = 0;

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );
    }
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &len, XDR_SEND_UINT32, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdevmap_api_versions_0x00010001 */

/*=========================================================================== 
              API Callback Clients
===========================================================================*/

static void rdm_assign_port_cb_type_clnt_0x00010001(rdm_assign_status_type arg1,  rdm_service_enum_type arg2,  rdm_device_enum_type arg3)
{
  xdr_s_type       *clnt          = NULL;
  rpc_reply_header  reply_header;
  rpc_cb_data_type *rpc_cb_data   = NULL;
  boolean           xdr_status    = TRUE;
  int               xdr_op_number = 0;

  rpc_cb_data = rpc_svc_cb_data_lookup();

  if ( rpc_cb_data == NULL )
  {
    RPC_SVC_CB_DATA_LOOKUP_ERR();
    return;
  }

  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   RDEVMAPCBPROG, RDM_ASSIGN_PORT_CB_TYPE_VERS,
                                   ONCRPC_RDM_ASSIGN_PORT_CB_TYPE_PROC, &RdevmapcbCred, &RdevmapcbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_ENUM( clnt, &arg1 );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_SEND_ENUM( clnt, &arg2 );
  }

  /* XDR OP NUMBER = 5 */
  if ( xdr_status )
  {
    xdr_op_number = 5;
    xdr_status = XDR_SEND_ENUM( clnt, &arg3 );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
        XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* rdm_assign_port_cb_type_clnt_0x00010001 */


static void rdm_service_close_func_ptr_type_clnt_0x00010001(void)
{
  xdr_s_type       *clnt          = NULL;
  rpc_reply_header  reply_header;
  rpc_cb_data_type *rpc_cb_data   = NULL;
  boolean           xdr_status    = TRUE;
  int               xdr_op_number = 0;

  rpc_cb_data = rpc_svc_cb_data_lookup();

  if ( rpc_cb_data == NULL )
  {
    RPC_SVC_CB_DATA_LOOKUP_ERR();
    return;
  }

  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   RDEVMAPCBPROG, RDM_SERVICE_CLOSE_FUNC_PTR_TYPE_VERS,
                                   ONCRPC_RDM_SERVICE_CLOSE_FUNC_PTR_TYPE_PROC, &RdevmapcbCred, &RdevmapcbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
        XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* rdm_service_close_func_ptr_type_clnt_0x00010001 */


static void rdm_service_open_func_ptr_type_clnt_0x00010001(sio_port_id_type arg1)
{
  xdr_s_type       *clnt          = NULL;
  rpc_reply_header  reply_header;
  rpc_cb_data_type *rpc_cb_data   = NULL;
  boolean           xdr_status    = TRUE;
  int               xdr_op_number = 0;

  rpc_cb_data = rpc_svc_cb_data_lookup();

  if ( rpc_cb_data == NULL )
  {
    RPC_SVC_CB_DATA_LOOKUP_ERR();
    return;
  }

  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   RDEVMAPCBPROG, RDM_SERVICE_OPEN_FUNC_PTR_TYPE_VERS,
                                   ONCRPC_RDM_SERVICE_OPEN_FUNC_PTR_TYPE_PROC, &RdevmapcbCred, &RdevmapcbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_ENUM( clnt, &arg1 );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
        XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* rdm_service_open_func_ptr_type_clnt_0x00010001 */


static void rdm_srv_func_ptr_multi_dev_type_clnt_0x00010001(sio_port_id_type port,  void *data)
{
  xdr_s_type       *clnt          = NULL;
  rpc_reply_header  reply_header;
  rpc_cb_data_type *rpc_cb_data   = NULL;
  boolean           xdr_status    = TRUE;
  int               xdr_op_number = 0;

  rpc_cb_data = rpc_svc_cb_data_lookup();

  if ( rpc_cb_data == NULL )
  {
    RPC_SVC_CB_DATA_LOOKUP_ERR();
    return;
  }

  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   RDEVMAPCBPROG, RDM_SRV_FUNC_PTR_MULTI_DEV_TYPE_VERS,
                                   ONCRPC_RDM_SRV_FUNC_PTR_MULTI_DEV_TYPE_PROC, &RdevmapcbCred, &RdevmapcbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_ENUM( clnt, &port );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_SEND_HANDLE( clnt, &data );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
        XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* rdm_srv_func_ptr_multi_dev_type_clnt_0x00010001 */


