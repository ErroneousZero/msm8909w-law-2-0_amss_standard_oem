/* RDEVMAP TOOL VERSION: 4.35 */
/*=============================================================================
                          R D E V M A P _ C L N T . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that provides RPC client functionality for the
  rdevmap API.

  ---------------------------------------------------------------------------
  Copyright (c) 2009 Qualcomm Technologies Incorporated.
  All Rights Reserved. QUALCOMM Proprietary and Confidential.
  ---------------------------------------------------------------------------
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */
/* Generated by following versions of Htorpc modules:
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/htorpc.pl#6 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Start.pm#2 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Htoxdr.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/XDR.pm#2 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Output.pm#5 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Parser.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Metacomments.pm#3 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/SymbolTable.pm#2   

rdevmap Definition File(s):
Id: //source/qcom/qct/core/api/wiredconnectivity/rel/2h09/rdevmap.h#6
=============================================================================*/
/*=============================================================================
$Header: //components/rel/tz.bf/2.5.c10/trustzone_images/core/api/rapi/wiredconnectivity/src/rdevmap_clnt.c#1 $ 
=============================================================================*/


/* Include files */
#include "oncrpc.h"
#include "rdevmap.h"
#include "rdevmap_rpc.h"

/* Only one copy needed per API */
static opaque_auth RdevmapCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth RdevmapVerf = { ONCRPC_AUTH_NONE, 0, 0 };

//static opaque_auth RdevmapcbCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth RdevmapcbVerf = { ONCRPC_AUTH_NONE, 0, 0 };


/*=======================================================================
             Prototypes for the API Callbacks RPC Server Functions
=======================================================================*/
  
static void rdevmapcbprog_0x00010001 ( struct svc_req *rqstp, xdr_s_type *srv );

static void rdm_assign_port_cb_type_svc_0x00010001( xdr_s_type *srv );

static void rdm_service_close_func_ptr_type_svc_0x00010001( xdr_s_type *srv );

static void rdm_service_open_func_ptr_type_svc_0x00010001( xdr_s_type *srv );

static void rdm_srv_func_ptr_multi_dev_type_svc_0x00010001( xdr_s_type *srv );


/*=======================================================================
             API RPC Clients Implementation
=======================================================================*/

boolean rdevmap_null(void)
{
  xdr_s_type       *clnt;
  rpc_reply_header  reply_header;
  boolean           xdr_status = TRUE;
  int               xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDEVMAP_NULL_VERS, 0);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(RDEVMAPPROG, RDEVMAP_NULL_VERS, 0);
    return FALSE;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  if ( ! xdr_call_msg_start( clnt,
                             RDEVMAPPROG, RDEVMAP_NULL_VERS,
                             ONCRPC_RDEVMAP_NULL_PROC, &RdevmapCred, &RdevmapVerf ) ) {
    XDR_OP_ERR( clnt, xdr_op_number );
    return FALSE;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return FALSE;
  }
  /* XDR OP NUMBER = 1 */

  if ( reply_header.stat != RPC_MSG_ACCEPTED )
  {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }
  else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS )
  {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    /* XDR OP NUMBER = 2 */
    xdr_op_number = 2;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return FALSE;
  }
  else
  {
    return TRUE;
  }
} /* rdevmap_null */

boolean rdevmap_rpc_glue_code_info_remote
(
  uint32 *toolvers,
  uint32 *features,
  uint32 *proghash,
  uint32 *cbproghash
)
{
  xdr_s_type       *clnt;
  rpc_reply_header  reply_header;
  uint32            result;
  boolean           xdr_status = TRUE;
  int               xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDEVMAP_RPC_GLUE_CODE_INFO_REMOTE_VERS, 0);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(RDEVMAPPROG, RDEVMAP_RPC_GLUE_CODE_INFO_REMOTE_VERS, 0);
    return FALSE;
  }
  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  if ( ! xdr_call_msg_start( clnt,
                             RDEVMAPPROG, RDEVMAP_RPC_GLUE_CODE_INFO_REMOTE_VERS,
                             ONCRPC_RDEVMAP_RPC_GLUE_CODE_INFO_REMOTE_PROC, &RdevmapCred, &RdevmapVerf ) ) {
    XDR_OP_ERR( clnt, xdr_op_number );
    return FALSE;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    // return here without calling XDR_MSG_DONE
    return FALSE;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  if ( reply_header.stat != RPC_MSG_ACCEPTED )
  {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }
  else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS )
  {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    /* XDR OP NUMBER = 2 */
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT32( clnt, &result );
  }

  if ( xdr_status )
  {
    if ( toolvers != NULL )
    {
      *toolvers = result;
    }
    /* XDR OP NUMBER = 3 */
    xdr_op_number = 3;
    xdr_status = XDR_RECV_UINT32( clnt, &result );
  }
  if ( xdr_status )
  {
    if ( features != NULL )
    {
      *features = result;
    }
    /* XDR OP NUMBER = 4 */
    xdr_op_number = 4;
    xdr_status = XDR_RECV_UINT32( clnt, &result );
  }

  if ( xdr_status )
  {
    if ( proghash != NULL )
    {
      *proghash = result;
    }
    /* XDR OP NUMBER = 5 */
    xdr_op_number = 5;
    xdr_status = XDR_RECV_UINT32( clnt, &result );
  }
  if ( xdr_status )
  {
    if ( cbproghash != NULL )
    {
      *cbproghash = result;
    }
    /* XDR OP NUMBER = 6 */
    xdr_op_number = 6;
  }

  if ( xdr_status )
  {
    /* XDR OP NUMBER = 7 */
    xdr_op_number = 7;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return FALSE;
  }
  else
  {
    return TRUE;
  }
} /* rdevmap_rpc_glue_code_info_remote */

boolean rdevmap_rpc_glue_code_info_local
(
  uint32 *toolvers,
  uint32 *features,
  uint32 *proghash,
  uint32 *cbproghash
)
{
  if ( toolvers != NULL )
  {
    *toolvers = RDEVMAP_TOOLVERS; /* 4.35 */
  }

  if ( features != NULL )
  {
    *features = RDEVMAP_FEATURES; /* ONCRPC Server Cleanup Support */
                
  }

  if ( proghash != NULL )
  {
    *proghash = 0x00010001; /* 0x00010001 */
  }

  if ( cbproghash != NULL )
  {
    *cbproghash = 0x00010001; /* 0x00010001 */
  }

  return TRUE;
} /* rdevmap_rpc_glue_code_info_local */

void rdm_issue_opens(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_ISSUE_OPENS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(RDEVMAPPROG, RDM_ISSUE_OPENS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   RDEVMAPPROG, RDM_ISSUE_OPENS_VERS,
                                   ONCRPC_RDM_ISSUE_OPENS_PROC, &RdevmapCred, &RdevmapVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* rdm_issue_opens */

boolean rdm_assign_port(rdm_service_enum_type service,  rdm_device_enum_type device,  rdm_assign_port_cb_type cbptr)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  boolean rdm_assign_port_result;

  do {
    clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_ASSIGN_PORT_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(RDEVMAPPROG, RDM_ASSIGN_PORT_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               RDEVMAPPROG, RDM_ASSIGN_PORT_VERS,
                               ONCRPC_RDM_ASSIGN_PORT_PROC, &RdevmapCred, &RdevmapVerf );

    (void) XDR_SEND_ENUM( clnt, &service );

    (void) XDR_SEND_ENUM( clnt, &device );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) cbptr );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &rdm_assign_port_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return rdm_assign_port_result;
} /* rdm_assign_port */

boolean rdm_assign_port_tmp(rdm_service_enum_type service,  rdm_device_enum_type device,  rdm_assign_port_cb_type cbptr)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  boolean rdm_assign_port_tmp_result;

  do {
    clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_ASSIGN_PORT_TMP_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(RDEVMAPPROG, RDM_ASSIGN_PORT_TMP_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               RDEVMAPPROG, RDM_ASSIGN_PORT_TMP_VERS,
                               ONCRPC_RDM_ASSIGN_PORT_TMP_PROC, &RdevmapCred, &RdevmapVerf );

    (void) XDR_SEND_ENUM( clnt, &service );

    (void) XDR_SEND_ENUM( clnt, &device );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) cbptr );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &rdm_assign_port_tmp_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return rdm_assign_port_tmp_result;
} /* rdm_assign_port_tmp */

boolean rdm_close_device(rdm_service_enum_type service,  rdm_device_enum_type device,  rdm_assign_port_cb_type cbptr)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  boolean rdm_close_device_result;

  do {
    clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_CLOSE_DEVICE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(RDEVMAPPROG, RDM_CLOSE_DEVICE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               RDEVMAPPROG, RDM_CLOSE_DEVICE_VERS,
                               ONCRPC_RDM_CLOSE_DEVICE_PROC, &RdevmapCred, &RdevmapVerf );

    (void) XDR_SEND_ENUM( clnt, &service );

    (void) XDR_SEND_ENUM( clnt, &device );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) cbptr );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &rdm_close_device_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return rdm_close_device_result;
} /* rdm_close_device */

void rdm_notify(rdm_service_enum_type service,  rdm_assign_status_type status)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_NOTIFY_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(RDEVMAPPROG, RDM_NOTIFY_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   RDEVMAPPROG, RDM_NOTIFY_VERS,
                                   ONCRPC_RDM_NOTIFY_PROC, &RdevmapCred, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( clnt, &service );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_ENUM( clnt, &status );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* rdm_notify */

rdm_device_enum_type rdm_get_device(rdm_service_enum_type service)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  rdm_device_enum_type rdm_get_device_result;

  do {
    clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_GET_DEVICE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(RDEVMAPPROG, RDM_GET_DEVICE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               RDEVMAPPROG, RDM_GET_DEVICE_VERS,
                               ONCRPC_RDM_GET_DEVICE_PROC, &RdevmapCred, &RdevmapVerf );

    (void) XDR_SEND_ENUM( clnt, &service );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &rdm_get_device_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return rdm_get_device_result;
} /* rdm_get_device */

rdm_service_enum_type rdm_get_service(rdm_device_enum_type device)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  rdm_service_enum_type rdm_get_service_result;

  do {
    clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_GET_SERVICE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(RDEVMAPPROG, RDM_GET_SERVICE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               RDEVMAPPROG, RDM_GET_SERVICE_VERS,
                               ONCRPC_RDM_GET_SERVICE_PROC, &RdevmapCred, &RdevmapVerf );

    (void) XDR_SEND_ENUM( clnt, &device );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_ENUM( clnt, &rdm_get_service_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return rdm_get_service_result;
} /* rdm_get_service */

boolean rdm_get_valid_ports(rdm_service_enum_type service,  rdm_service_display_type devices[])
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 i;
  uint32 length_uint32;
  boolean rdm_get_valid_ports_result;

  do {
    clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_GET_VALID_PORTS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(RDEVMAPPROG, RDM_GET_VALID_PORTS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               RDEVMAPPROG, RDM_GET_VALID_PORTS_VERS,
                               ONCRPC_RDM_GET_VALID_PORTS_PROC, &RdevmapCred, &RdevmapVerf );

    (void) XDR_SEND_ENUM( clnt, &service );

    if ( devices != NULL ) {
      length_uint32 = RDM_DEV_MAX;

      (void) XDR_SEND_UINT32( clnt, &length_uint32 );


      /* Calling array of XDR routines */
      for ( i = 0; i < (length_uint32); i++ ) {
        /*lint -save -e545*/
        (void) xdr_rdevmap_send_rdm_service_display_type( clnt, &(devices[i]) );
        /*lint -restore */
      }
    } else {
      length_uint32 = 0;

      (void) XDR_SEND_UINT32( clnt, &length_uint32 );
    }


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &rdm_get_valid_ports_result );

  (void) XDR_RECV_UINT32( clnt, &length_uint32 );

  if ( length_uint32 > 0 )
  {
    if ( devices != NULL ) {

      /* Calling array of XDR routines */
      for ( i = 0; i < (length_uint32); i++ ) {
        /*lint -save -e545*/
        (void) xdr_rdevmap_recv_rdm_service_display_type( clnt, &(devices[i]) );
        /*lint -restore */
      }
    }
  }


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return rdm_get_valid_ports_result;
} /* rdm_get_valid_ports */

void rdm_register_open_func(rdm_service_enum_type service,  rdm_service_open_func_ptr_type open_func)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_REGISTER_OPEN_FUNC_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(RDEVMAPPROG, RDM_REGISTER_OPEN_FUNC_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   RDEVMAPPROG, RDM_REGISTER_OPEN_FUNC_VERS,
                                   ONCRPC_RDM_REGISTER_OPEN_FUNC_PROC, &RdevmapCred, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( clnt, &service );
  }

  /*lint -save -e611*/
  cb_id = rpc_clnt_callback_register( (void *) open_func );
  /*lint -restore */

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_UINT32( clnt, &cb_id );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* rdm_register_open_func */

void rdm_register_close_func(rdm_service_enum_type service,  rdm_service_close_func_ptr_type close_func)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_REGISTER_CLOSE_FUNC_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(RDEVMAPPROG, RDM_REGISTER_CLOSE_FUNC_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   RDEVMAPPROG, RDM_REGISTER_CLOSE_FUNC_VERS,
                                   ONCRPC_RDM_REGISTER_CLOSE_FUNC_PROC, &RdevmapCred, &RdevmapVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( clnt, &service );
  }

  /*lint -save -e611*/
  cb_id = rpc_clnt_callback_register( (void *) close_func );
  /*lint -restore */

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_UINT32( clnt, &cb_id );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* rdm_register_close_func */

boolean rdm_register_func_multi_dev(
  rdm_service_enum_type service,
  rdm_srv_func_ptr_multi_dev_type open_func,
  rdm_srv_func_ptr_multi_dev_type close_func,
  void *data
)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 cb_id;
  boolean rdm_register_func_multi_dev_result;

  do {
    clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_REGISTER_FUNC_MULTI_DEV_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(RDEVMAPPROG, RDM_REGISTER_FUNC_MULTI_DEV_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               RDEVMAPPROG, RDM_REGISTER_FUNC_MULTI_DEV_VERS,
                               ONCRPC_RDM_REGISTER_FUNC_MULTI_DEV_PROC, &RdevmapCred, &RdevmapVerf );

    (void) XDR_SEND_ENUM( clnt, &service );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) open_func );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );

    /*lint -save -e611*/
    cb_id = rpc_clnt_callback_register( (void *) close_func );
    /*lint -restore */

    (void) XDR_SEND_UINT32( clnt, &cb_id );

    (void) XDR_SEND_HANDLE( clnt, &data );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &rdm_register_func_multi_dev_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return rdm_register_func_multi_dev_result;
} /* rdm_register_func_multi_dev */

boolean rdm_get_device_str(rdm_device_enum_type device,  char *str)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean output_pointer_not_null;
  uint32 length_uint32;
  boolean rdm_get_device_str_result;

  do {
    clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_GET_DEVICE_STR_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(RDEVMAPPROG, RDM_GET_DEVICE_STR_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               RDEVMAPPROG, RDM_GET_DEVICE_STR_VERS,
                               ONCRPC_RDM_GET_DEVICE_STR_PROC, &RdevmapCred, &RdevmapVerf );

    (void) XDR_SEND_ENUM( clnt, &device );

    /* Send TRUE if str is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use. Also since this is
     * a string, we need to send the maximum size of the string.
     */
    output_pointer_not_null = (str != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );

    if ( output_pointer_not_null ) {
      length_uint32 = 13;

      (void) XDR_SEND_UINT32( clnt, &length_uint32 );

    }


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &rdm_get_device_str_result );

  (void) XDR_RECV_UINT32( clnt, &length_uint32 );

  if ( length_uint32 > 0 ) {
    if ( str != NULL ) {
      (void) XDR_RECV_STRING(clnt, str, length_uint32);
    }
  }


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return rdm_get_device_str_result;
} /* rdm_get_device_str */

boolean rdm_is_srv_holding_dev(rdm_service_enum_type service,  rdm_device_enum_type device)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean rdm_is_srv_holding_dev_result;

  do {
    clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_IS_SRV_HOLDING_DEV_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(RDEVMAPPROG, RDM_IS_SRV_HOLDING_DEV_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               RDEVMAPPROG, RDM_IS_SRV_HOLDING_DEV_VERS,
                               ONCRPC_RDM_IS_SRV_HOLDING_DEV_PROC, &RdevmapCred, &RdevmapVerf );

    (void) XDR_SEND_ENUM( clnt, &service );

    (void) XDR_SEND_ENUM( clnt, &device );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &rdm_is_srv_holding_dev_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return rdm_is_srv_holding_dev_result;
} /* rdm_is_srv_holding_dev */

boolean rdm_set_srv_compat_mask(rdm_service_enum_type service,  uint32 dev_mask)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean rdm_set_srv_compat_mask_result;

  do {
    clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_SET_SRV_COMPAT_MASK_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(RDEVMAPPROG, RDM_SET_SRV_COMPAT_MASK_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               RDEVMAPPROG, RDM_SET_SRV_COMPAT_MASK_VERS,
                               ONCRPC_RDM_SET_SRV_COMPAT_MASK_PROC, &RdevmapCred, &RdevmapVerf );

    (void) XDR_SEND_ENUM( clnt, &service );

    (void) XDR_SEND_UINT32( clnt, &dev_mask );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &rdm_set_srv_compat_mask_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return rdm_set_srv_compat_mask_result;
} /* rdm_set_srv_compat_mask */

boolean rdm_is_srv_dev_compat(rdm_service_enum_type service,  rdm_device_enum_type device)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean rdm_is_srv_dev_compat_result;

  do {
    clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDM_IS_SRV_DEV_COMPAT_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(RDEVMAPPROG, RDM_IS_SRV_DEV_COMPAT_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               RDEVMAPPROG, RDM_IS_SRV_DEV_COMPAT_VERS,
                               ONCRPC_RDM_IS_SRV_DEV_COMPAT_PROC, &RdevmapCred, &RdevmapVerf );

    (void) XDR_SEND_ENUM( clnt, &service );

    (void) XDR_SEND_ENUM( clnt, &device );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &rdm_is_srv_dev_compat_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return rdm_is_srv_dev_compat_result;
} /* rdm_is_srv_dev_compat */


/*=======================================================================
             API Standard Functions for version info
=======================================================================*/

uint32 *rdevmap_api_versions(uint32 *len)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 i;
  boolean output_pointer_not_null;
  void *memset_temp;
  uint32 length_uint32;
  uint32 *rdevmap_api_versions_result = NULL;

  do {
    clnt = rpc_clnt_lookup2(RDEVMAPPROG, RDEVMAP_API_VERSIONS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(RDEVMAPPROG, RDEVMAP_API_VERSIONS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               RDEVMAPPROG, RDEVMAP_API_VERSIONS_VERS,
                               ONCRPC_RDEVMAP_API_VERSIONS_PROC, &RdevmapCred, &RdevmapVerf );

    /* Send TRUE if len is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (len != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_UINT32( clnt, &length_uint32 );

  if ( length_uint32 > 0 )
  {
    memset_temp = oncrpcxdr_mem_alloc( clnt, length_uint32 * sizeof( *rdevmap_api_versions_result ));
    memset(memset_temp, 0, length_uint32 * sizeof( *rdevmap_api_versions_result ));
    rdevmap_api_versions_result = memset_temp;


    /* Calling array of XDR routines */
    for ( i = 0; i < (length_uint32); i++ ) {
      /*lint -save -e545*/
      (void) XDR_RECV_UINT32( clnt, &(rdevmap_api_versions_result[i]) );
      /*lint -restore */
    }
  }

  /*lint -save -e123*/
  XDR_RECV_POINTER_NO_ERRCHK( clnt, &len, XDR_RECV_UINT32 );
  /*lint -restore */


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return rdevmap_api_versions_result;
} /* rdevmap_api_versions */




/*=======================================================================
             API Callbacks RPC Server Implementation
=======================================================================*/

void rdevmapcb_app_init( void )
{
  (void) svc_register_auto(RDEVMAPCBPROG, RDEVMAPCBVERS, rdevmapcbprog_0x00010001);
} /* rdevmapcb_app_init */

void rdevmapcb_app_lock( boolean lock )
{
  svc_lock( RDEVMAPCBPROG, RDEVMAPCBVERS, lock );
} /* rdevmapcb_app_enable */

static void rdevmapcbprog_0x00010001( struct svc_req *rqstp, xdr_s_type *srv )
{
  switch( rqstp->rq_proc ) {
    case ONCRPC_RDM_ASSIGN_PORT_CB_TYPE_PROC:
      rdm_assign_port_cb_type_svc_0x00010001( srv );
      break;
    case ONCRPC_RDM_SERVICE_CLOSE_FUNC_PTR_TYPE_PROC:
      rdm_service_close_func_ptr_type_svc_0x00010001( srv );
      break;
    case ONCRPC_RDM_SERVICE_OPEN_FUNC_PTR_TYPE_PROC:
      rdm_service_open_func_ptr_type_svc_0x00010001( srv );
      break;
    case ONCRPC_RDM_SRV_FUNC_PTR_MULTI_DEV_TYPE_PROC:
      rdm_srv_func_ptr_multi_dev_type_svc_0x00010001( srv );
      break;
    default:
      // invalid RPC procedure number
      (void) XDR_MSG_DONE( srv );
      svcerr_default_err( srv, rqstp, rdevmap_api_versions  );
      break;
  }

  oncrpcxdr_mem_free( srv );
} /* rdevmapcbprog_0x00010001 */

static void rdm_assign_port_cb_type_svc_0x00010001( xdr_s_type *srv )
{
  rdm_assign_port_cb_type cmd_cb_func;
  uint32  cb_id;
  boolean xdr_status = TRUE;
  int     xdr_op_number = 0;

  rdm_assign_status_type arg1 = RDM_NOT_ALLOWED_S;
  rdm_service_enum_type arg2 = RDM_NULL_SRVC;
  rdm_device_enum_type arg3 = RDM_SRVC_NOT_ALLOWED;


  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &cb_id );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &arg1 );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_RECV_ENUM( srv, &arg2 );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_RECV_ENUM( srv, &arg3 );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }      

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cmd_cb_func = (rdm_assign_port_cb_type ) rpc_clnt_callback_lookup( cb_id );
  /*lint -restore */

  if ( cmd_cb_func == NULL ) {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  cmd_cb_func(arg1, arg2, arg3);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapcbVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_assign_port_cb_type_svc_0x00010001 */

static void rdm_service_close_func_ptr_type_svc_0x00010001( xdr_s_type *srv )
{
  rdm_service_close_func_ptr_type cmd_cb_func;
  uint32  cb_id;
  boolean xdr_status = TRUE;
  int     xdr_op_number = 0;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &cb_id );

  if ( xdr_status )
  {
    xdr_op_number++;
  }      

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cmd_cb_func = (rdm_service_close_func_ptr_type ) rpc_clnt_callback_lookup( cb_id );
  /*lint -restore */

  if ( cmd_cb_func == NULL ) {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  cmd_cb_func();

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapcbVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_service_close_func_ptr_type_svc_0x00010001 */

static void rdm_service_open_func_ptr_type_svc_0x00010001( xdr_s_type *srv )
{
  rdm_service_open_func_ptr_type cmd_cb_func;
  uint32  cb_id;
  boolean xdr_status = TRUE;
  int     xdr_op_number = 0;

  sio_port_id_type arg1 = SIO_PORT_NULL;


  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &cb_id );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &arg1 );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }      

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cmd_cb_func = (rdm_service_open_func_ptr_type ) rpc_clnt_callback_lookup( cb_id );
  /*lint -restore */

  if ( cmd_cb_func == NULL ) {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  cmd_cb_func(arg1);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapcbVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_service_open_func_ptr_type_svc_0x00010001 */

static void rdm_srv_func_ptr_multi_dev_type_svc_0x00010001( xdr_s_type *srv )
{
  rdm_srv_func_ptr_multi_dev_type cmd_cb_func;
  uint32  cb_id;
  boolean xdr_status = TRUE;
  int     xdr_op_number = 0;

  sio_port_id_type port = SIO_PORT_NULL;
  void *data;


  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT32( srv, &cb_id );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( srv, &port );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_RECV_HANDLE( srv, &data );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }      

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  /*lint -save -e611*/
  cmd_cb_func = (rdm_srv_func_ptr_multi_dev_type ) rpc_clnt_callback_lookup( cb_id );
  /*lint -restore */

  if ( cmd_cb_func == NULL ) {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  cmd_cb_func(port, data);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &RdevmapcbVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* rdm_srv_func_ptr_multi_dev_type_svc_0x00010001 */

