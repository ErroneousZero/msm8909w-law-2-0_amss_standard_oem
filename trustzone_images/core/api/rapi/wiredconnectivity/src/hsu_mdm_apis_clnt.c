/* HSU_MDM_APIS TOOL VERSION: 4.39 */
/* GENERATED: TUE JUN 22 2010 */
/*=============================================================================
                     H S U _ M D M _ A P I S _ C L N T . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that provides RPC client functionality for the
  hsu_mdm_apis API.

  ---------------------------------------------------------------------------
  Copyright (c) 2010 Qualcomm Technologies Incorporated.
  All Rights Reserved. QUALCOMM Proprietary and Confidential.
  ---------------------------------------------------------------------------
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */
/* Generated by following versions of Htorpc modules:
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/htorpc.pl#2 
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/Start.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/Htoxdr.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/XDR.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/Output.pm#2 
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/Parser.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/Metacomments.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/SymbolTable.pm#1   

hsu_mdm_apis Definition File(s):

=============================================================================*/
/*=============================================================================
$Header: //components/rel/tz.bf/2.5.c10/trustzone_images/core/api/rapi/wiredconnectivity/src/hsu_mdm_apis_clnt.c#1 $ 
=============================================================================*/


/* Include files */
#include "oncrpc.h"
#include "hsu_mdm_apis.h"
#include "hsu_mdm_apis_rpc.h"

/* Only one copy needed per API */
static opaque_auth Hsu_mdm_apisCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth Hsu_mdm_apisVerf = { ONCRPC_AUTH_NONE, 0, 0 };


/*=======================================================================
             API RPC Clients Implementation
=======================================================================*/

boolean hsu_mdm_apis_null(void)
{
  xdr_s_type       *clnt;
  rpc_reply_header  reply_header;
  boolean           xdr_status = TRUE;
  int               xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_MDM_APIS_NULL_VERS, 0);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_MDM_APIS_NULL_VERS, 0);
    return FALSE;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  if ( ! xdr_call_msg_start( clnt,
                             HSU_MDM_APISPROG, HSU_MDM_APIS_NULL_VERS,
                             ONCRPC_HSU_MDM_APIS_NULL_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf ) ) {
    XDR_OP_ERR( clnt, xdr_op_number );
    return FALSE;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return FALSE;
  }
  /* XDR OP NUMBER = 1 */

  if ( reply_header.stat != RPC_MSG_ACCEPTED )
  {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }
  else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS )
  {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    /* XDR OP NUMBER = 2 */
    xdr_op_number = 2;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return FALSE;
  }
  else
  {
    return TRUE;
  }
} /* hsu_mdm_apis_null */

boolean hsu_mdm_apis_rpc_glue_code_info_remote
(
  uint32 *toolvers,
  uint32 *features,
  uint32 *proghash,
  uint32 *cbproghash
)
{
  xdr_s_type       *clnt;
  rpc_reply_header  reply_header;
  uint32            result = 0;
  boolean           xdr_status = TRUE;
  int               xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_MDM_APIS_RPC_GLUE_CODE_INFO_REMOTE_VERS, 0);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_MDM_APIS_RPC_GLUE_CODE_INFO_REMOTE_VERS, 0);
    return FALSE;
  }
  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  if ( ! xdr_call_msg_start( clnt,
                             HSU_MDM_APISPROG, HSU_MDM_APIS_RPC_GLUE_CODE_INFO_REMOTE_VERS,
                             ONCRPC_HSU_MDM_APIS_RPC_GLUE_CODE_INFO_REMOTE_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf ) ) {
    XDR_OP_ERR( clnt, xdr_op_number );
    return FALSE;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    // return here without calling XDR_MSG_DONE
    return FALSE;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  if ( reply_header.stat != RPC_MSG_ACCEPTED )
  {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }
  else if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS )
  {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    /* XDR OP NUMBER = 2 */
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT32( clnt, &result );
  }

  if ( xdr_status )
  {
    if ( toolvers != NULL )
    {
      *toolvers = result;
    }
    /* XDR OP NUMBER = 3 */
    xdr_op_number = 3;
    xdr_status = XDR_RECV_UINT32( clnt, &result );
  }
  if ( xdr_status )
  {
    if ( features != NULL )
    {
      *features = result;
    }
    /* XDR OP NUMBER = 4 */
    xdr_op_number = 4;
    xdr_status = XDR_RECV_UINT32( clnt, &result );
  }

  if ( xdr_status )
  {
    if ( proghash != NULL )
    {
      *proghash = result;
    }
    /* XDR OP NUMBER = 5 */
    xdr_op_number = 5;
    xdr_status = XDR_RECV_UINT32( clnt, &result );
  }
  if ( xdr_status )
  {
    if ( cbproghash != NULL )
    {
      *cbproghash = result;
    }
    /* XDR OP NUMBER = 6 */
    xdr_op_number = 6;
  }

  if ( xdr_status )
  {
    /* XDR OP NUMBER = 7 */
    xdr_op_number = 7;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return FALSE;
  }
  else
  {
    return TRUE;
  }
} /* hsu_mdm_apis_rpc_glue_code_info_remote */

boolean hsu_mdm_apis_rpc_glue_code_info_local
(
  uint32 *toolvers,
  uint32 *features,
  uint32 *proghash,
  uint32 *cbproghash
)
{
  if ( toolvers != NULL )
  {
    *toolvers = HSU_MDM_APIS_TOOLVERS; /* 4.39 */
  }

  if ( features != NULL )
  {
    *features = HSU_MDM_APIS_FEATURES; /* ONCRPC Server Cleanup Support */
                
  }

  if ( proghash != NULL )
  {
    *proghash = 0x00010003; /* 0x00010003 */
  }

  if ( cbproghash != NULL )
  {
    *cbproghash = 0x00010003; /* 0x00010003 */
  }

  return TRUE;
} /* hsu_mdm_apis_rpc_glue_code_info_local */

void hsu_api_init_phy(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_INIT_PHY_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_INIT_PHY_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_INIT_PHY_VERS,
                                   ONCRPC_HSU_API_INIT_PHY_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_init_phy */

void hsu_api_init_uicc(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_INIT_UICC_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_INIT_UICC_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_INIT_UICC_VERS,
                                   ONCRPC_HSU_API_INIT_UICC_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_init_uicc */

void hsu_api_start_uicc(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_START_UICC_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_START_UICC_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_START_UICC_VERS,
                                   ONCRPC_HSU_API_START_UICC_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_start_uicc */

void hsu_api_polldown_uicc(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_POLLDOWN_UICC_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_POLLDOWN_UICC_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_POLLDOWN_UICC_VERS,
                                   ONCRPC_HSU_API_POLLDOWN_UICC_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_polldown_uicc */

void hsu_api_vbus_powerup(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_VBUS_POWERUP_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_VBUS_POWERUP_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_VBUS_POWERUP_VERS,
                                   ONCRPC_HSU_API_VBUS_POWERUP_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_vbus_powerup */

void hsu_api_vbus_shutdown(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_VBUS_SHUTDOWN_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_VBUS_SHUTDOWN_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_VBUS_SHUTDOWN_VERS,
                                   ONCRPC_HSU_API_VBUS_SHUTDOWN_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_vbus_shutdown */

void hsu_api_update_product_id(unsigned short product_id)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_UPDATE_PRODUCT_ID_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_UPDATE_PRODUCT_ID_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_UPDATE_PRODUCT_ID_VERS,
                                   ONCRPC_HSU_API_UPDATE_PRODUCT_ID_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT16( clnt, &product_id );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_update_product_id */

void hsu_api_update_serial_number(const char *serial_number)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 length_uint32;
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_UPDATE_SERIAL_NUMBER_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_UPDATE_SERIAL_NUMBER_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_UPDATE_SERIAL_NUMBER_VERS,
                                   ONCRPC_HSU_API_UPDATE_SERIAL_NUMBER_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    length_uint32 = 0;

    if ( serial_number != NULL ) {
      length_uint32 = strlen((const char *) serial_number) + 1;

      xdr_status = XDR_SEND_UINT32( clnt, &length_uint32 );

      /* XDR OP NUMBER = 3 */
      if ( xdr_status )
      {
        xdr_op_number  = 3;
        xdr_status = XDR_SEND_STRING(clnt, serial_number, length_uint32);
      }
    } else {
      xdr_status = XDR_SEND_UINT32( clnt, &length_uint32 );

    }
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_update_serial_number */

void hsu_api_update_is_serial_number_null(boolean is_serial_number_null)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_UPDATE_IS_SERIAL_NUMBER_NULL_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_UPDATE_IS_SERIAL_NUMBER_NULL_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_UPDATE_IS_SERIAL_NUMBER_NULL_VERS,
                                   ONCRPC_HSU_API_UPDATE_IS_SERIAL_NUMBER_NULL_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( clnt, &is_serial_number_null );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_update_is_serial_number_null */

void hsu_api_notif_charger_not_avail(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_NOTIF_CHARGER_NOT_AVAIL_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_NOTIF_CHARGER_NOT_AVAIL_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_NOTIF_CHARGER_NOT_AVAIL_VERS,
                                   ONCRPC_HSU_API_NOTIF_CHARGER_NOT_AVAIL_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_notif_charger_not_avail */

void hsu_api_notif_charger_is_avail(uint32 amount_current_to_draw)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_NOTIF_CHARGER_IS_AVAIL_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_NOTIF_CHARGER_IS_AVAIL_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_NOTIF_CHARGER_IS_AVAIL_VERS,
                                   ONCRPC_HSU_API_NOTIF_CHARGER_IS_AVAIL_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &amount_current_to_draw );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_notif_charger_is_avail */

void hsu_api_notif_charger_disconnected(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_NOTIF_CHARGER_DISCONNECTED_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_NOTIF_CHARGER_DISCONNECTED_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_NOTIF_CHARGER_DISCONNECTED_VERS,
                                   ONCRPC_HSU_API_NOTIF_CHARGER_DISCONNECTED_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_notif_charger_disconnected */

void hsu_api_notif_charger_connected(boolean is_wall_charger)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_NOTIF_CHARGER_CONNECTED_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_NOTIF_CHARGER_CONNECTED_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_NOTIF_CHARGER_CONNECTED_VERS,
                                   ONCRPC_HSU_API_NOTIF_CHARGER_CONNECTED_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( clnt, &is_wall_charger );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_notif_charger_connected */

void hsu_api_init_chg(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_INIT_CHG_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_INIT_CHG_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_INIT_CHG_VERS,
                                   ONCRPC_HSU_API_INIT_CHG_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_init_chg */

boolean hsu_api_chg_is_connected(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean hsu_api_chg_is_connected_result;

  do {
    clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_CHG_IS_CONNECTED_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(HSU_MDM_APISPROG, HSU_API_CHG_IS_CONNECTED_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               HSU_MDM_APISPROG, HSU_API_CHG_IS_CONNECTED_VERS,
                               ONCRPC_HSU_API_CHG_IS_CONNECTED_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &hsu_api_chg_is_connected_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return hsu_api_chg_is_connected_result;
} /* hsu_api_chg_is_connected */

boolean hsu_api_usb_reset_rework_installed(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean hsu_api_usb_reset_rework_installed_result;

  do {
    clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_USB_RESET_REWORK_INSTALLED_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(HSU_MDM_APISPROG, HSU_API_USB_RESET_REWORK_INSTALLED_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               HSU_MDM_APISPROG, HSU_API_USB_RESET_REWORK_INSTALLED_VERS,
                               ONCRPC_HSU_API_USB_RESET_REWORK_INSTALLED_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &hsu_api_usb_reset_rework_installed_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return hsu_api_usb_reset_rework_installed_result;
} /* hsu_api_usb_reset_rework_installed */

void hsu_api_enable_pmic_ulpidata0_irq_handler(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_ENABLE_PMIC_ULPIDATA0_IRQ_HANDLER_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_ENABLE_PMIC_ULPIDATA0_IRQ_HANDLER_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_ENABLE_PMIC_ULPIDATA0_IRQ_HANDLER_VERS,
                                   ONCRPC_HSU_API_ENABLE_PMIC_ULPIDATA0_IRQ_HANDLER_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_enable_pmic_ulpidata0_irq_handler */

void hsu_api_disable_pmic_ulpidata0_irq_handler(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_DISABLE_PMIC_ULPIDATA0_IRQ_HANDLER_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_DISABLE_PMIC_ULPIDATA0_IRQ_HANDLER_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_DISABLE_PMIC_ULPIDATA0_IRQ_HANDLER_VERS,
                                   ONCRPC_HSU_API_DISABLE_PMIC_ULPIDATA0_IRQ_HANDLER_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_disable_pmic_ulpidata0_irq_handler */

void hsu_dload_set_usb_imax(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_DLOAD_SET_USB_IMAX_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_DLOAD_SET_USB_IMAX_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_DLOAD_SET_USB_IMAX_VERS,
                                   ONCRPC_HSU_DLOAD_SET_USB_IMAX_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_dload_set_usb_imax */

void hsu_dload_enable_disable_core(boolean enable)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_DLOAD_ENABLE_DISABLE_CORE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_DLOAD_ENABLE_DISABLE_CORE_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_DLOAD_ENABLE_DISABLE_CORE_VERS,
                                   ONCRPC_HSU_DLOAD_ENABLE_DISABLE_CORE_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_BOOLEAN( clnt, &enable );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_dload_enable_disable_core */

boolean hsu_dload_is_wall_charger(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean hsu_dload_is_wall_charger_result;

  do {
    clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_DLOAD_IS_WALL_CHARGER_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(HSU_MDM_APISPROG, HSU_DLOAD_IS_WALL_CHARGER_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               HSU_MDM_APISPROG, HSU_DLOAD_IS_WALL_CHARGER_VERS,
                               ONCRPC_HSU_DLOAD_IS_WALL_CHARGER_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &hsu_dload_is_wall_charger_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return hsu_dload_is_wall_charger_result;
} /* hsu_dload_is_wall_charger */

boolean hsu_dload_sess_is_valid(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean hsu_dload_sess_is_valid_result;

  do {
    clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_DLOAD_SESS_IS_VALID_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(HSU_MDM_APISPROG, HSU_DLOAD_SESS_IS_VALID_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               HSU_MDM_APISPROG, HSU_DLOAD_SESS_IS_VALID_VERS,
                               ONCRPC_HSU_DLOAD_SESS_IS_VALID_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &hsu_dload_sess_is_valid_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return hsu_dload_sess_is_valid_result;
} /* hsu_dload_sess_is_valid */

boolean hsu_api_enable_pmic_otg_comparators(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean hsu_api_enable_pmic_otg_comparators_result;

  do {
    clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_ENABLE_PMIC_OTG_COMPARATORS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(HSU_MDM_APISPROG, HSU_API_ENABLE_PMIC_OTG_COMPARATORS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               HSU_MDM_APISPROG, HSU_API_ENABLE_PMIC_OTG_COMPARATORS_VERS,
                               ONCRPC_HSU_API_ENABLE_PMIC_OTG_COMPARATORS_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &hsu_api_enable_pmic_otg_comparators_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return hsu_api_enable_pmic_otg_comparators_result;
} /* hsu_api_enable_pmic_otg_comparators */

boolean hsu_api_disable_pmic_otg_comparators(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean hsu_api_disable_pmic_otg_comparators_result;

  do {
    clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_DISABLE_PMIC_OTG_COMPARATORS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(HSU_MDM_APISPROG, HSU_API_DISABLE_PMIC_OTG_COMPARATORS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               HSU_MDM_APISPROG, HSU_API_DISABLE_PMIC_OTG_COMPARATORS_VERS,
                               ONCRPC_HSU_API_DISABLE_PMIC_OTG_COMPARATORS_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_BOOLEAN( clnt, &hsu_api_disable_pmic_otg_comparators_result );


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return hsu_api_disable_pmic_otg_comparators_result;
} /* hsu_api_disable_pmic_otg_comparators */

void hsu_api_disconnect_pulldowns_uicc(void)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_DISCONNECT_PULLDOWNS_UICC_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_DISCONNECT_PULLDOWNS_UICC_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_DISCONNECT_PULLDOWNS_UICC_VERS,
                                   ONCRPC_HSU_API_DISCONNECT_PULLDOWNS_UICC_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_disconnect_pulldowns_uicc */

void hsu_api_update_vendor_id(unsigned short vendor_id)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  boolean xdr_status = TRUE;
  int xdr_op_number = 0;

  clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_API_UPDATE_VENDOR_ID_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

  if ( clnt == NULL ) {
    XDR_CLNT_LOOKUP2_ERR(HSU_MDM_APISPROG, HSU_API_UPDATE_VENDOR_ID_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    return;
  }

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   HSU_MDM_APISPROG, HSU_API_UPDATE_VENDOR_ID_VERS,
                                   ONCRPC_HSU_API_UPDATE_VENDOR_ID_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT16( clnt, &vendor_id );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
    XDR_OP_ERR( clnt, xdr_op_number );
    return;
  }
} /* hsu_api_update_vendor_id */


/*=======================================================================
             API Standard Functions for version info
=======================================================================*/

uint32 *hsu_mdm_apis_api_versions(uint32 *len)
{
  xdr_s_type *clnt;
  rpc_reply_header reply_header;

  uint32 i;
  boolean output_pointer_not_null;
  void *memset_temp;
  uint32 length_uint32;
  uint32 *hsu_mdm_apis_api_versions_result = NULL;

  do {
    clnt = rpc_clnt_lookup2(HSU_MDM_APISPROG, HSU_MDM_APIS_API_VERSIONS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);

    if ( clnt == NULL ) {
      XDR_CLNT_LOOKUP2_ERR_FATAL(HSU_MDM_APISPROG, HSU_MDM_APIS_API_VERSIONS_VERS, RPC_CLNT_LOOKUP_TIMEOUT);
    }

    oncrpcxdr_mem_free( clnt );

    XDR_ERRCHK( clnt, ON );

    (void) xdr_call_msg_start( clnt,
                               HSU_MDM_APISPROG, HSU_MDM_APIS_API_VERSIONS_VERS,
                               ONCRPC_HSU_MDM_APIS_API_VERSIONS_PROC, &Hsu_mdm_apisCred, &Hsu_mdm_apisVerf );

    /* Send TRUE if len is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (len != NULL);

    (void) XDR_SEND_UINT8( clnt, &output_pointer_not_null );


    /* Send the RPC message and block waiting for a reply */
  } while ( ! XDR_MSG_SEND( clnt, &reply_header ) );

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR_FATAL( clnt, &reply_header );
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR_FATAL( clnt, &reply_header );
  }

  (void) XDR_RECV_UINT32( clnt, &length_uint32 );

  if ( length_uint32 > 0 )
  {
    memset_temp = oncrpcxdr_mem_alloc( clnt, length_uint32 * sizeof( *hsu_mdm_apis_api_versions_result ));
    memset(memset_temp, 0, length_uint32 * sizeof( *hsu_mdm_apis_api_versions_result ));
    hsu_mdm_apis_api_versions_result = memset_temp;


    /* Calling array of XDR routines */
    for ( i = 0; i < (length_uint32); i++ ) {
      /*lint -save -e545*/
      (void) XDR_RECV_UINT32( clnt, &(hsu_mdm_apis_api_versions_result[i]) );
      /*lint -restore */
    }
  }

  /*lint -save -e123*/
  XDR_RECV_POINTER_NO_ERRCHK( clnt, &len, XDR_RECV_UINT32 );
  /*lint -restore */


  if ( ! XDR_MSG_DONE( clnt ) )
  {
    XDR_OP_ERR_FATAL( clnt, 0 );
  }

  XDR_ERRCHK( clnt, OFF );

  return hsu_mdm_apis_api_versions_result;
} /* hsu_mdm_apis_api_versions */




/*=======================================================================
             API Callbacks RPC Server Implementation
=======================================================================*/


void hsu_mdm_apiscb_app_init( void ) {
} /* hsu_mdm_apiscb_app_init */

void hsu_mdm_apiscb_app_lock( boolean lock ){
} /* hsu_mdm_apiscb_app_enable */

