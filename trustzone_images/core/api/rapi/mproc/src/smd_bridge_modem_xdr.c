/* SMD_BRIDGE_MODEM TOOL VERSION: 4.41 */
/* GENERATED: TUE JUL 20 2010 */
/*=============================================================================
                  S M D _ B R I D G E _ M O D E M _ X D R . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that provides xdr encode/decode routines
  specific to the data types used in the exported smd_bridge_modem API.

  ---------------------------------------------------------------------------
  Copyright (c) 2010 Qualcomm Technologies Incorporated.
  All Rights Reserved. QUALCOMM Proprietary and Confidential.
  ---------------------------------------------------------------------------
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */

/* Generated by following versions of Htorpc modules:
Id: //source/qcom/qct/core/mproc/tools/rel/05.02/htorpc/htorpc.pl#2 
Id: //source/qcom/qct/core/mproc/tools/rel/05.02/htorpc/lib/Htorpc/Start.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/05.02/htorpc/lib/Htorpc/Htoxdr.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/05.02/htorpc/lib/Htorpc/XDR.pm#2 
Id: //source/qcom/qct/core/mproc/tools/rel/05.02/htorpc/lib/Htorpc/Output.pm#3 
Id: //source/qcom/qct/core/mproc/tools/rel/05.02/htorpc/lib/Htorpc/Parser.pm#2 
Id: //source/qcom/qct/core/mproc/tools/rel/05.02/htorpc/lib/Htorpc/Metacomments.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/05.02/htorpc/lib/Htorpc/SymbolTable.pm#1   

smd_bridge_modem Definition File(s):
Id: //source/qcom/qct/core/api/mproc/rel/05.02/smd_bridge_modem.h#2
=============================================================================*/
/*=============================================================================
$Header: //components/rel/tz.bf/2.5.c10/trustzone_images/core/api/rapi/mproc/src/smd_bridge_modem_xdr.c#1 $ 
=============================================================================*/


/* Include files */
#include "oncrpc.h"
#include "smd_bridge_modem.h"
#include "smd_bridge_modem_rpc.h"


/*=======================================================================
                  XDR send/recv routines for API types
=======================================================================*/


/*
 * struct sio_ioctl_connection_speed_change_notif XDR_SMD_BRIDGE_MODEM_SEND
 */
boolean xdr_smd_bridge_modem_send_sio_ioctl_connection_speed_change_notif (xdr_s_type *xdrs, struct sio_ioctl_connection_speed_change_notif const *sptr)
{
  if ( ! XDR_SEND_UINT32( xdrs, &(sptr->upstream_bitrate) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_UINT32( xdrs, &(sptr->downstream_bitrate) ) ) {
    return (FALSE);
  }

  return (TRUE);
} /* xdr_smd_bridge_modem_send_sio_ioctl_connection_speed_change_notif */

/*
 * struct sio_ioctl_connection_speed_change_notif XDR_SMD_BRIDGE_MODEM_RECV
 */
boolean xdr_smd_bridge_modem_recv_sio_ioctl_connection_speed_change_notif (xdr_s_type *xdrs, struct sio_ioctl_connection_speed_change_notif *sptr)
{
  if ( ! XDR_RECV_UINT32( xdrs, &(sptr->upstream_bitrate) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_UINT32( xdrs, &(sptr->downstream_bitrate) ) ) {
    return (FALSE);
  }

  return (TRUE);
} /* xdr_smd_bridge_modem_recv_sio_ioctl_connection_speed_change_notif */




/*
 * union sio_ioctl_param XDR_SMD_BRIDGE_MODEM_SEND
 */
boolean xdr_smd_bridge_modem_send_sio_ioctl_param (xdr_s_type *xdrs, union sio_ioctl_param const *uptr, sio_ioctl_cmd_type obj_disc)
{
  switch ( obj_disc ){
 case SIO_IOCTL_CHANGE_BAUD_NOW:
      if ( ! XDR_SEND_UINT16( xdrs, &(uptr->rearm_autobaud) ) ) {
        return (FALSE);
      }

      break;
 case SIO_IOCTL_NETWORK_CONNECTION_NOTIF:
      if ( ! XDR_SEND_BOOLEAN( xdrs, &(uptr->link_up) ) ) {
        return (FALSE);
      }

      break;
 case SIO_IOCTL_CONNECTION_SPEED_CHANGE_NOTIF:
      if ( ! xdr_smd_bridge_modem_send_sio_ioctl_connection_speed_change_notif( xdrs, &(uptr->connection_speed_change_notif) ) ) {
        return (FALSE);
      }

      break;
 case SIO_IOCTL_GET_MAC_ADDRESS:
      if ( ! XDR_SEND_BYTES(xdrs, uptr->mac_address, 13) ) {
        return (FALSE);
      }

      break;
 case SIO_IOCTL_IS_STANDARD_ECM:
      if ( ! XDR_SEND_BOOLEAN( xdrs, &(uptr->is_standard_ecm) ) ) {
        return (FALSE);
      }

      break;
    default:

      ; // case ignored

  }

  return (TRUE);
} /* xdr_smd_bridge_modem_send_sio_ioctl_param */

/*
 * union sio_ioctl_param XDR_SMD_BRIDGE_MODEM_RECV
 */
boolean xdr_smd_bridge_modem_recv_sio_ioctl_param (xdr_s_type *xdrs, union sio_ioctl_param *uptr, sio_ioctl_cmd_type obj_disc)
{
  switch ( obj_disc ){
 case SIO_IOCTL_CHANGE_BAUD_NOW:
      if ( ! XDR_RECV_UINT16( xdrs, &(uptr->rearm_autobaud) ) ) {
        return (FALSE);
      }

      break;
 case SIO_IOCTL_NETWORK_CONNECTION_NOTIF:
      if ( ! XDR_RECV_BOOLEAN( xdrs, &(uptr->link_up) ) ) {
        return (FALSE);
      }

      break;
 case SIO_IOCTL_CONNECTION_SPEED_CHANGE_NOTIF:
      if ( ! xdr_smd_bridge_modem_recv_sio_ioctl_connection_speed_change_notif( xdrs, &(uptr->connection_speed_change_notif) ) ) {
        return (FALSE);
      }

      break;
 case SIO_IOCTL_GET_MAC_ADDRESS:
      if ( ! XDR_RECV_BYTES(xdrs, uptr->mac_address, 13) ) {
        return (FALSE);
      }

      break;
 case SIO_IOCTL_IS_STANDARD_ECM:
      if ( ! XDR_RECV_BOOLEAN( xdrs, &(uptr->is_standard_ecm) ) ) {
        return (FALSE);
      }

      break;
    default:

      ; // case ignored

  }

  return (TRUE);
} /* xdr_smd_bridge_modem_recv_sio_ioctl_param */




/*
 * struct smd_bridge_open XDR_SMD_BRIDGE_MODEM_SEND
 */
boolean xdr_smd_bridge_modem_send_smd_bridge_open (xdr_s_type *xdrs, struct smd_bridge_open const *sptr)
{
  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->stream_mode) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->rx_bitrate) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->tx_bitrate) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->port_id) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_BOOLEAN( xdrs, &(sptr->tail_char_used) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_UINT8( xdrs, &(sptr->tail_char) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->tx_flow) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->rx_flow) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_BOOLEAN( xdrs, &(sptr->control) ) ) {
    return (FALSE);
  }

  return (TRUE);
} /* xdr_smd_bridge_modem_send_smd_bridge_open */

/*
 * struct smd_bridge_open XDR_SMD_BRIDGE_MODEM_RECV
 */
boolean xdr_smd_bridge_modem_recv_smd_bridge_open (xdr_s_type *xdrs, struct smd_bridge_open *sptr)
{
  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->stream_mode) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->rx_bitrate) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->tx_bitrate) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->port_id) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_BOOLEAN( xdrs, &(sptr->tail_char_used) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_UINT8( xdrs, &(sptr->tail_char) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->tx_flow) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->rx_flow) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_BOOLEAN( xdrs, &(sptr->control) ) ) {
    return (FALSE);
  }

  return (TRUE);
} /* xdr_smd_bridge_modem_recv_smd_bridge_open */




/*
 * struct smd_bridge_ioctl_cmd XDR_SMD_BRIDGE_MODEM_SEND
 */
boolean xdr_smd_bridge_modem_send_smd_bridge_ioctl_cmd (xdr_s_type *xdrs, struct smd_bridge_ioctl_cmd const *sptr)
{
  boolean xdr_pointer_result;
  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->cmd) ) ) {
    return (FALSE);
  }

  /*lint -save -e123*/
  XDR_SEND_U_POINTER2( xdrs, &(sptr->param), &(sptr->cmd), xdr_smd_bridge_modem_send_sio_ioctl_param, XDR_SEND_ENUM, xdr_pointer_result );
  /*lint -restore */
  if ( ! xdr_pointer_result ) {
    return (FALSE);
  }

  return (TRUE);
} /* xdr_smd_bridge_modem_send_smd_bridge_ioctl_cmd */

/*
 * struct smd_bridge_ioctl_cmd XDR_SMD_BRIDGE_MODEM_RECV
 */
boolean xdr_smd_bridge_modem_recv_smd_bridge_ioctl_cmd (xdr_s_type *xdrs, struct smd_bridge_ioctl_cmd *sptr)
{
  boolean xdr_pointer_result;
  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->cmd) ) ) {
    return (FALSE);
  }

  /*lint -save -e123*/
  XDR_RECV_U_POINTER2( xdrs, &(sptr->param), &(sptr->cmd), xdr_smd_bridge_modem_recv_sio_ioctl_param, XDR_RECV_ENUM, xdr_pointer_result );
  /*lint -restore */
  if ( ! xdr_pointer_result ) {
    return (FALSE);
  }

  return (TRUE);
} /* xdr_smd_bridge_modem_recv_smd_bridge_ioctl_cmd */




/*
 * struct smd_bridge_remote_cmd_param XDR_SMD_BRIDGE_MODEM_SEND
 */
boolean xdr_smd_bridge_modem_send_smd_bridge_remote_cmd_param (xdr_s_type *xdrs, struct smd_bridge_remote_cmd_param const *sptr)
{
  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->cmd) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_UINT32( xdrs, &(sptr->bridge_id) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_UINT32( xdrs, &(sptr->proc_major_id) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_UINT32( xdrs, &(sptr->rsvd) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->cmd) ) ) {
    return (FALSE);
  }

  switch ( sptr->cmd ){
 case SMD_BRIDGE_CMD_CONNECT:
      if ( ! xdr_smd_bridge_modem_send_smd_bridge_open( xdrs, &(sptr->param.open_struct) ) ) {
        return (FALSE);
      }

      break;
 case SMD_BRIDGE_CMD_IOCTL:
      if ( ! xdr_smd_bridge_modem_send_smd_bridge_ioctl_cmd( xdrs, &(sptr->param.ioctl_struct) ) ) {
        return (FALSE);
      }

      break;
    default:

      if ( ! XDR_SEND_UINT8( xdrs, &(sptr->param.dummy) ) ) {
        return (FALSE);
      }

  }

  return (TRUE);
} /* xdr_smd_bridge_modem_send_smd_bridge_remote_cmd_param */

/*
 * struct smd_bridge_remote_cmd_param XDR_SMD_BRIDGE_MODEM_RECV
 */
boolean xdr_smd_bridge_modem_recv_smd_bridge_remote_cmd_param (xdr_s_type *xdrs, struct smd_bridge_remote_cmd_param *sptr)
{
  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->cmd) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_UINT32( xdrs, &(sptr->bridge_id) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_UINT32( xdrs, &(sptr->proc_major_id) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_UINT32( xdrs, &(sptr->rsvd) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->cmd) ) ) {
    return (FALSE);
  }

  switch ( sptr->cmd ){
 case SMD_BRIDGE_CMD_CONNECT:
      if ( ! xdr_smd_bridge_modem_recv_smd_bridge_open( xdrs, &(sptr->param.open_struct) ) ) {
        return (FALSE);
      }

      break;
 case SMD_BRIDGE_CMD_IOCTL:
      if ( ! xdr_smd_bridge_modem_recv_smd_bridge_ioctl_cmd( xdrs, &(sptr->param.ioctl_struct) ) ) {
        return (FALSE);
      }

      break;
    default:

      if ( ! XDR_RECV_UINT8( xdrs, &(sptr->param.dummy) ) ) {
        return (FALSE);
      }

  }

  return (TRUE);
} /* xdr_smd_bridge_modem_recv_smd_bridge_remote_cmd_param */



