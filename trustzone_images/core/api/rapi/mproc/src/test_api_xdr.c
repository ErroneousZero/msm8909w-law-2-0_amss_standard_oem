/* TEST_API TOOL VERSION: 4.37 */
/* GENERATED: TUE MAR  2 2010 */
/*=============================================================================
                          T E S T _ A P I _ X D R . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that provides xdr encode/decode routines
  specific to the data types used in the exported test_api API.

  ---------------------------------------------------------------------------
  Copyright (c) 2010 Qualcomm Technologies Incorporated.
  All Rights Reserved. QUALCOMM Proprietary and Confidential.
  ---------------------------------------------------------------------------
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */

/* Generated by following versions of Htorpc modules:
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/htorpc.pl#8 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Start.pm#3 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Htoxdr.pm#1 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/XDR.pm#3 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Output.pm#8 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Parser.pm#2 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/Metacomments.pm#5 
Id: //source/qcom/qct/core/mproc/tools/rel/04.07/htorpc/lib/Htorpc/SymbolTable.pm#3   

test_api Definition File(s):

=============================================================================*/
/*=============================================================================
$Header: //components/rel/tz.bf/2.5.c10/trustzone_images/core/api/rapi/mproc/src/test_api_xdr.c#1 $ 
=============================================================================*/


/* Include files */
#include "oncrpc.h"
#include "test_api.h"
#include "test_api_rpc.h"


/*=======================================================================
                  XDR send/recv routines for API types
=======================================================================*/


/*
 * struct test_api_struct_1 XDR_TEST_API_SEND
 */
boolean xdr_test_api_send_test_api_struct_1 (xdr_s_type *xdrs, struct test_api_struct_1 const *sptr)
{
  unsigned long int i;
  unsigned long int length_unsigned_long_int;
  uint32 length_uint32;
  /* Calling array of XDR routines */
  for ( i = 0; i < (100); i++ ) {
    /*lint -save -e545*/
    if ( ! XDR_SEND_UINT32( xdrs, &(sptr->fixed_array[i]) ) ) {
      return (FALSE);
    }
    /*lint -restore */
  }

  if ( sptr->variable_array != NULL ) {
    length_unsigned_long_int = sptr->variable_len;

    if ( ! XDR_SEND_UINT32( xdrs, &length_unsigned_long_int ) ) {
      return (FALSE);
    }


    /* Calling array of XDR routines */
    for ( i = 0; i < (length_unsigned_long_int); i++ ) {
      /*lint -save -e545*/
      if ( ! XDR_SEND_UINT32( xdrs, &(sptr->variable_array[i]) ) ) {
        return (FALSE);
      }
      /*lint -restore */
    }
  } else {
    length_unsigned_long_int = 0;

    if ( ! XDR_SEND_UINT32( xdrs, &length_unsigned_long_int ) ) {
      return (FALSE);
    }
  }

  if ( ! XDR_SEND_UINT32( xdrs, &(sptr->variable_len) ) ) {
    return (FALSE);
  }

  length_uint32 = 0;

  if ( sptr->str != NULL ) {
    length_uint32 = strlen((const char *) sptr->str) + 1;

    if ( ! XDR_SEND_UINT32( xdrs, &length_uint32 ) ) {
      return (FALSE);
    }

    if ( ! XDR_SEND_STRING(xdrs, sptr->str, length_uint32) ) {
      return (FALSE);
    }
  } else {
    if ( ! XDR_SEND_UINT32( xdrs, &length_uint32 ) ) {
      return (FALSE);
    }

  }

  return (TRUE);
} /* xdr_test_api_send_test_api_struct_1 */

/*
 * struct test_api_struct_1 XDR_TEST_API_RECV
 */
boolean xdr_test_api_recv_test_api_struct_1 (xdr_s_type *xdrs, struct test_api_struct_1 *sptr)
{
  unsigned long int i;
  void *memset_temp;
  unsigned long int length_unsigned_long_int;
  uint32 length_uint32;
  /* Calling array of XDR routines */
  for ( i = 0; i < (100); i++ ) {
    /*lint -save -e545*/
    if ( ! XDR_RECV_UINT32( xdrs, &(sptr->fixed_array[i]) ) ) {
      return (FALSE);
    }
    /*lint -restore */
  }

  if ( ! XDR_RECV_UINT32( xdrs, &length_unsigned_long_int ) ) {
    return (FALSE);
  }

  if ( length_unsigned_long_int > 0 )
  {
    if ( sptr->variable_array == NULL ) {
      memset_temp = oncrpcxdr_mem_alloc( xdrs, length_unsigned_long_int * sizeof( *sptr->variable_array ));
      memset(memset_temp, 0, length_unsigned_long_int * sizeof( *sptr->variable_array ));
      sptr->variable_array = memset_temp;
    }


    /* Calling array of XDR routines */
    for ( i = 0; i < (length_unsigned_long_int); i++ ) {
      /*lint -save -e545*/
      if ( ! XDR_RECV_UINT32( xdrs, &(sptr->variable_array[i]) ) ) {
        return (FALSE);
      }
      /*lint -restore */
    }
  }

  if ( ! XDR_RECV_UINT32( xdrs, &(sptr->variable_len) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_UINT32( xdrs, &length_uint32 ) ) {
    return (FALSE);
  }

  if ( length_uint32 > 0 ) {
    memset_temp = oncrpcxdr_mem_alloc( xdrs, length_uint32);
    memset(memset_temp, 0, length_uint32);
    sptr->str = memset_temp;

    if ( ! XDR_RECV_STRING(xdrs, sptr->str, length_uint32) ) {
      return (FALSE);
    }
  }

  return (TRUE);
} /* xdr_test_api_recv_test_api_struct_1 */




/*
 * union test_api_union_1 XDR_TEST_API_SEND
 */
boolean xdr_test_api_send_test_api_union_1 (xdr_s_type *xdrs, union test_api_union_1 const *uptr, send_data_disc_type obj_disc)
{
  boolean xdr_pointer_result;
  int i;
  switch ( obj_disc ){
 case SEND_STRUCT_ONLY:
      XDR_SEND_POINTER( xdrs, &(uptr->struct_data), xdr_test_api_send_test_api_struct_1, xdr_pointer_result );
      if ( ! xdr_pointer_result ) {
        return (FALSE);
      }

      break;
 case SEND_FIXED_ARRAY:

      /* Calling array of XDR routines */
      for ( i = 0; i < (100); i++ ) {
        /*lint -save -e545*/
        if ( ! XDR_SEND_UINT32( xdrs, &(uptr->fixed_array[i]) ) ) {
          return (FALSE);
        }
        /*lint -restore */
      }

      break;
    default:

      XDR_UNKNOWN_DISCRIMINATOR_MSG(obj_disc);

  }

  return (TRUE);
} /* xdr_test_api_send_test_api_union_1 */

/*
 * union test_api_union_1 XDR_TEST_API_RECV
 */
boolean xdr_test_api_recv_test_api_union_1 (xdr_s_type *xdrs, union test_api_union_1 *uptr, send_data_disc_type obj_disc)
{
  boolean xdr_pointer_result;
  int i;
  switch ( obj_disc ){
 case SEND_STRUCT_ONLY:
      XDR_RECV_POINTER( xdrs, &(uptr->struct_data), xdr_test_api_recv_test_api_struct_1, xdr_pointer_result );
      if ( ! xdr_pointer_result ) {
        return (FALSE);
      }

      break;
 case SEND_FIXED_ARRAY:

      /* Calling array of XDR routines */
      for ( i = 0; i < (100); i++ ) {
        /*lint -save -e545*/
        if ( ! XDR_RECV_UINT32( xdrs, &(uptr->fixed_array[i]) ) ) {
          return (FALSE);
        }
        /*lint -restore */
      }

      break;
    default:

      XDR_UNKNOWN_DISCRIMINATOR_MSG(obj_disc);

  }

  return (TRUE);
} /* xdr_test_api_recv_test_api_union_1 */




/*
 * union test_api_union_2 XDR_TEST_API_SEND
 */
boolean xdr_test_api_send_test_api_union_2 (xdr_s_type *xdrs, union test_api_union_2 const *uptr, enum send_data_disc obj_disc)
{
  int i;
  switch ( obj_disc ){
 case SEND_STRUCT_ONLY:
      if ( ! xdr_test_api_send_test_api_struct_1( xdrs, &(uptr->struct_data) ) ) {
        return (FALSE);
      }

      break;
 case SEND_FIXED_ARRAY:

      /* Calling array of XDR routines */
      for ( i = 0; i < (100); i++ ) {
        /*lint -save -e545*/
        if ( ! XDR_SEND_UINT32( xdrs, &(uptr->fixed_array[i]) ) ) {
          return (FALSE);
        }
        /*lint -restore */
      }

      break;
    default:

      XDR_UNKNOWN_DISCRIMINATOR_MSG(obj_disc);

  }

  return (TRUE);
} /* xdr_test_api_send_test_api_union_2 */

/*
 * union test_api_union_2 XDR_TEST_API_RECV
 */
boolean xdr_test_api_recv_test_api_union_2 (xdr_s_type *xdrs, union test_api_union_2 *uptr, enum send_data_disc obj_disc)
{
  int i;
  switch ( obj_disc ){
 case SEND_STRUCT_ONLY:
      if ( ! xdr_test_api_recv_test_api_struct_1( xdrs, &(uptr->struct_data) ) ) {
        return (FALSE);
      }

      break;
 case SEND_FIXED_ARRAY:

      /* Calling array of XDR routines */
      for ( i = 0; i < (100); i++ ) {
        /*lint -save -e545*/
        if ( ! XDR_RECV_UINT32( xdrs, &(uptr->fixed_array[i]) ) ) {
          return (FALSE);
        }
        /*lint -restore */
      }

      break;
    default:

      XDR_UNKNOWN_DISCRIMINATOR_MSG(obj_disc);

  }

  return (TRUE);
} /* xdr_test_api_recv_test_api_union_2 */




/*
 * struct test_api_struct_2 XDR_TEST_API_SEND
 */
boolean xdr_test_api_send_test_api_struct_2 (xdr_s_type *xdrs, struct test_api_struct_2 const *sptr)
{
  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->disc) ) ) {
    return (FALSE);
  }

  if ( ! xdr_test_api_send_test_api_union_2( xdrs, &(sptr->union_data), sptr->disc ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->disc) ) ) {
    return (FALSE);
  }

  return (TRUE);
} /* xdr_test_api_send_test_api_struct_2 */

/*
 * struct test_api_struct_2 XDR_TEST_API_RECV
 */
boolean xdr_test_api_recv_test_api_struct_2 (xdr_s_type *xdrs, struct test_api_struct_2 *sptr)
{
  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->disc) ) ) {
    return (FALSE);
  }

  if ( ! xdr_test_api_recv_test_api_union_2( xdrs, &(sptr->union_data), sptr->disc ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->disc) ) ) {
    return (FALSE);
  }

  return (TRUE);
} /* xdr_test_api_recv_test_api_struct_2 */




/*
 * struct test_api_struct_3 XDR_TEST_API_SEND
 */
boolean xdr_test_api_send_test_api_struct_3 (xdr_s_type *xdrs, struct test_api_struct_3 const *sptr)
{
  int i;
  uint32 length_uint32;
  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->disc) ) ) {
    return (FALSE);
  }

  if ( ! xdr_test_api_send_test_api_struct_1( xdrs, &(sptr->struct_data) ) ) {
    return (FALSE);
  }

  if ( ! XDR_SEND_ENUM( xdrs, &(sptr->disc) ) ) {
    return (FALSE);
  }

  if ( ! xdr_test_api_send_test_api_union_2( xdrs, &(sptr->union_data), sptr->disc ) ) {
    return (FALSE);
  }


  /* Calling array of XDR routines */
  for ( i = 0; i < (100); i++ ) {
    /*lint -save -e545*/
    if ( ! XDR_SEND_UINT32( xdrs, &(sptr->fixed_array[i]) ) ) {
      return (FALSE);
    }
    /*lint -restore */
  }

  length_uint32 = 0;

  if ( sptr->str != NULL ) {
    length_uint32 = strlen((const char *) sptr->str) + 1;

    if ( ! XDR_SEND_UINT32( xdrs, &length_uint32 ) ) {
      return (FALSE);
    }

    if ( ! XDR_SEND_STRING(xdrs, sptr->str, length_uint32) ) {
      return (FALSE);
    }
  } else {
    if ( ! XDR_SEND_UINT32( xdrs, &length_uint32 ) ) {
      return (FALSE);
    }

  }

  return (TRUE);
} /* xdr_test_api_send_test_api_struct_3 */

/*
 * struct test_api_struct_3 XDR_TEST_API_RECV
 */
boolean xdr_test_api_recv_test_api_struct_3 (xdr_s_type *xdrs, struct test_api_struct_3 *sptr)
{
  int i;
  void *memset_temp;
  uint32 length_uint32;
  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->disc) ) ) {
    return (FALSE);
  }

  if ( ! xdr_test_api_recv_test_api_struct_1( xdrs, &(sptr->struct_data) ) ) {
    return (FALSE);
  }

  if ( ! XDR_RECV_ENUM( xdrs, &(sptr->disc) ) ) {
    return (FALSE);
  }

  if ( ! xdr_test_api_recv_test_api_union_2( xdrs, &(sptr->union_data), sptr->disc ) ) {
    return (FALSE);
  }


  /* Calling array of XDR routines */
  for ( i = 0; i < (100); i++ ) {
    /*lint -save -e545*/
    if ( ! XDR_RECV_UINT32( xdrs, &(sptr->fixed_array[i]) ) ) {
      return (FALSE);
    }
    /*lint -restore */
  }

  if ( ! XDR_RECV_UINT32( xdrs, &length_uint32 ) ) {
    return (FALSE);
  }

  if ( length_uint32 > 0 ) {
    memset_temp = oncrpcxdr_mem_alloc( xdrs, length_uint32);
    memset(memset_temp, 0, length_uint32);
    sptr->str = memset_temp;

    if ( ! XDR_RECV_STRING(xdrs, sptr->str, length_uint32) ) {
      return (FALSE);
    }
  }

  return (TRUE);
} /* xdr_test_api_recv_test_api_struct_3 */



