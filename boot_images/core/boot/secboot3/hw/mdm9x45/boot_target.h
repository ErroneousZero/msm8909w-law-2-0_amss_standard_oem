#ifndef _BOOT_TARGET_H
#define _BOOT_TARGET_H

/*===========================================================================

                                boot_target
                                Header File

GENERAL DESCRIPTION
  This header file contains target specific declarations and definitions

INITIALIZATION AND SEQUENCING REQUIREMENTS
  None
  
Copyright 2014 by Qualcomm Technologies, Inc.  All Rights Reserved.
============================================================================*/

/*===========================================================================

                           EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

  $Header: //components/rel/boot.bf/3.1.2.c3/boot_images/core/boot/secboot3/hw/mdm9x45/boot_target.h#1 $
  $DateTime: 2015/09/01 00:30:35 $ 
  $Author: pwbldsvc $

when       who          what, where, why
--------   --------     ----------------------------------------------------------
12/08/14    jz           Added define of BOOT_CLOBBER_MAX_PROTECTED_REGIONS to overwrite the default
11/21/14    jz           Removed BOOT_ELF_RECONSTRUCT_BASE (MBA reconstruction is done in MBA region)
10/24/14    jz           Added a flag SMC_SUPPORTED to enable boot_fastcall_tz
10/16/14    jz           Added SBL1_OEM_CODE_DDR region
10/09/14    jz           Added BOOT_ELF_RECONSTRUCT_BASE for MBA image reconstruction
06/30/14    jz           Added BOOT_TEMP_ADDR to use DDR region for storing temp data read from QPIC
04/23/14    ck           Added QFPROM read only block size
04/08/14    jz           Updated MODEM_PBL_START_ADDR for Bear
12/20/13    kedara       Added EEPROM_DEVICE_ID_SECONDARY
09/27/13    dhaval       disabled CDT error failure till EEPROM CDT read is verified
09/04/13    kedara       Added SBL1_DISABLE_D_CACHE
06/19/13    kedara       Initial revision
============================================================================*/

/*===========================================================================

                           INCLUDE FILES

===========================================================================*/
#ifndef _ARM_ASM_
#include "boot_comdef.h"
#endif /* _ARM_ASM_ */

#include CUST_H

/*===========================================================================
                      SBL1 SCL DEFINES
===========================================================================*/

#define SBL1_WDOG_RESET_VALUE   0x1

/*---------------------------------------------------------------------------
  Define the destination address and size of the SBL1.
---------------------------------------------------------------------------*/
#define SBL1_CODE_BASE       SCL_SBL1_CODE_BASE
#define SBL1_MAX_IMAGE_SIZE  SCL_SBL1_TOTAL_SIZE


#ifndef _ARM_ASM_
/*---------------------------------------------------------------------------
  Symbols generated by linker with "$" instead of "_".  Symbols are renamed
  in an assembler file to have "_" to make them valid "C" identifiers and
  the symbols are located in the boot ROM.  These symbols define the
  Read/Write data area in boot ROM and RAM, and the Zero Init data area in
  RAM.  Base addresses and length in bytes are given.
---------------------------------------------------------------------------*/
extern uint32  Load$$SBL1_DATA_RW$$Base;
extern uint32  Image$$SBL1_DATA_RW$$Base;
extern uint32  Image$$SBL1_DATA_RW$$Length;
extern uint32  Image$$SBL1_DATA_ZI$$Base;
extern uint32  Image$$SBL1_DATA_ZI$$ZI$$Length;
extern uint32  Image$$SBL1_DDR_ZI$$Base;
extern uint32  Image$$SBL1_DDR_ZI$$ZI$$Length;
extern uint32  Image$$SBL1_LOG_BUF_SECTION$$Base[];
extern uint32  Image$$SBL1_LOG_META_INFO_SECTION$$Base;
extern uint32  Image$$SBL1_DLOAD_ZI$$Base;
extern uint32  Image$$SBL1_DLOAD_ZI$$ZI$$Length;
extern uint32  Load$$SBL1_OEM_CODE_DDR$$Base;
extern uint32  Image$$SBL1_OEM_CODE_DDR$$Base;
extern uint32  Image$$SBL1_OEM_CODE_DDR$$Length;
#endif /* _ARM_ASM_ */


#define BOOT_FLASH_TRANS_MAX_INSTANCES 1

/* Define start address for Q6 /Modem bootrom */
#define MODEM_PBL_START_ADDR 0x00118000


/*===========================================================================
                      QDST DEFINES
===========================================================================*/ 
/*Use chip hw id for MSM part value. This would simply preparation for OEM pk
  hash auth Test case. With the change, the same QDST signed image can be used
  to verify OEM pk hash authentication*/
#define BOOT_MSM_PART  0x006B20E1
#define BOOT_MSM_HW_ID  (((uint64)BOOT_MSM_PART) << 32)


/*===========================================================================
  Definitions of boot clobber region table size
===========================================================================*/
#define BOOT_CLOBBER_MAX_LOCAL_REGION_HOLES 8

#define BOOT_CLOBBER_MAX_PROTECTED_REGIONS  64

/*===========================================================================
  Definitions of address range where IMEM exists on the MSM.
===========================================================================*/
#define IMEM_RANGE_START_ADDR SCL_IMEM_BASE
#define IMEM_RANGE_END_ADDR   (SCL_IMEM_BASE+SCL_IMEM_SIZE)


/*===========================================================================
  Definition for the end address of SDRAM on the MSM.
===========================================================================*/
#define RANGE_END_ADDR        0xFFFFFFFFUL


/*===========================================================================
                      BOOT LOGGER DEFINES
===========================================================================*/

/**
 * Time out value for outputing a single char to jtag terminal.
 * 
 * Value used by rpm jtag. moved it to this target specific file
 * from common boot_arm7.c Existing value does not ensure proper
 * output to jtag and has to be updated for 8960
 * JTAG_TERM_TIME_OUT renamed to RPM_JTAG_TERM_TIME_OUT as krait
 * uses similar define.
 */
#define RPM_JTAG_TERM_TIME_OUT       0x500

/*=========================================================================== 
  The clock that is used to track time passing.
===========================================================================*/
#define TIMETICK_CLK  MPM2_MPM_SLEEP_TIMETICK_COUNT_VAL 

/*=========================================================================== 
  Clock frequency is 32.768 KHz
  The number of microseconds per cycle is:
  1 / (32.768 KHz) = 30.52ms
  The int part is 30
===========================================================================*/
#define TIMETICK_CLK_SPEED_INT       30

/*=========================================================================== 
  MPM Sleep Clock frequency is 32.768 KHz
  The number of microseconds per cycle is:
  1 / (32.768 KHz) = 30.52ms
  we round 0.52 to 1/2.
  Timestamp is calculated as : count*int + count/2
  Floating point arithmetic should not be used to avoid error and speed penalty
===========================================================================*/
#define CALCULATE_TIMESTAMP(COUNT) \
  ((COUNT)*TIMETICK_CLK_SPEED_INT + (COUNT)/2)

/*=========================================================================== 
  Qtimer Clock frequency is CXO 19.2MHz
  The number of microseconds per cycle 1/19.2
===========================================================================*/
#define CALCULATE_QTIMER_TIMESTAMP(COUNT) \
  ((COUNT)/19.2)
  
/*
  we are using 32 bits timestamp, the max counter value is:
  0xFFFFFFFF/31 = 138547732
  after this value the timestamp will overflow
*/
#define LOG_MAX_COUNT_VAL  138547732


/*---------------------------------------------------------------------------
  Start address of boot logger's logging buffer, defined by scl
---------------------------------------------------------------------------*/
#define SBL1_LOG_BUF_START  (&Image$$SBL1_LOG_BUF_SECTION$$Base)


/*---------------------------------------------------------------------------
  Size of boot logger's logging buffer, define by .builds
---------------------------------------------------------------------------*/
#define SBL1_LOG_BUF_SIZE  SCL_BOOT_LOG_BUF_SIZE

/*---------------------------------------------------------------------------
  Start address of boot logger's meta info structure, defined by scl
  ---------------------------------------------------------------------------*/
#define SBL1_LOG_META_INFO_START  (&Image$$SBL1_LOG_META_INFO_SECTION$$Base)

/*---------------------------------------------------------------------------
  Size of boot logger's meta info structure, define by .builds
  ---------------------------------------------------------------------------*/
#define SBL1_LOG_META_INFO_SIZE  SCL_BOOT_LOG_META_INFO_SIZE


/*OEM fuse All jtag debug disable status
  1 if OEM all jtag debug is disabled, 0 otherwise*/
#define FUSE0_DISABLE  (HWIO_INM(OEM_CONFIG1,  \
                                 HWIO_FMSK(OEM_CONFIG1, ALL_DEBUG_DISABLE)))

/*QC fuse RPM jtag debug disable status
  1 if QC RPM jtag debug is disabled, 0 otherwise
  */
#define FUSE1_DISABLE  (HWIO_INM(FEATURE_CONFIG2, \
                                 HWIO_FMSK(FEATURE_CONFIG2, RPM_DBGEN_DISABLE)))

/*OEM fuse RPM jtag debug disable status
  1 if OEM RPM jtag debug is disabled, 0 otherwise*/
#define FUSE2_DISABLE  (HWIO_INM(OEM_CONFIG0, \
                                 HWIO_FMSK(OEM_CONFIG0, RPM_DBGEN_DISABLE)))

/*QC fuse APPS jtag debug disable status     
  1 if QC APPS jtag debug is disabled, 0 otherwise*/
#define FUSE3_DISABLE  (HWIO_INM(FEATURE_CONFIG2, \
                                 HWIO_FMSK(FEATURE_CONFIG2, QC_APPS_DBGEN_DISABLE)))

/*OEM fuse APPS jtag debug disable status
  1 if OEM APPS jtag debug is disabled, 0 otherwise*/
#define FUSE4_DISABLE  (HWIO_INM(OEM_CONFIG1, \
                                 HWIO_FMSK(OEM_CONFIG1, APPS_DBGEN_DISABLE)))

/*QC fuse APPS secure jtag debug disable status
  1 if QC APPS secure jtag debug is disabled, 0 otherwise*/
#define FUSE5_DISABLE  (HWIO_INM(FEATURE_CONFIG2, \
                                 HWIO_FMSK(FEATURE_CONFIG2, QC_APPS_SPIDEN_DISABLE)))

/*OEM fuse APPS secure jtag debug disable status
  1 if OEM APPS secure jtag debug is disabled, 0 otherwise*/
#define FUSE6_DISABLE  (HWIO_INM(OEM_CONFIG1,  \
                                 HWIO_FMSK(OEM_CONFIG1, APPS_SPNIDEN_DISABLE)))


/* OEM fuse disables the DAP non-invasive debug capabilities */                                
#define DAP_FUSE0_DISABLE  (HWIO_INM(OEM_CONFIG1,  \
                                 HWIO_FMSK(OEM_CONFIG1, DAP_NIDEN_DISABLE)))   
                                 
/* QC fuse disables the DAP non-invasive debug capabilities */                                
#define DAP_FUSE1_DISABLE  (HWIO_INM(FEATURE_CONFIG2,  \
                                 HWIO_FMSK(FEATURE_CONFIG2, QC_DAP_NIDEN_DISABLE)))   
                                 
/* OEM fuse disables the DAP Secure non-invasive debug capabilities.*/                              
#define DAP_FUSE2_DISABLE  (HWIO_INM(OEM_CONFIG1,  \
                                 HWIO_FMSK(OEM_CONFIG1, DAP_SPNIDEN_DISABLE)))
                                 
/* QC fuse disables the DAP Secure non-invasive debug capabilities.*/                              
#define DAP_FUSE3_DISABLE  (HWIO_INM(FEATURE_CONFIG2,  \
                                 HWIO_FMSK(FEATURE_CONFIG2, QC_DAP_SPNIDEN_DISABLE)))   
                                 
/* OEM fuse disables the Disables the DAP invasive debug capabilities.*/
#define DAP_FUSE4_DISABLE  (HWIO_INM(OEM_CONFIG1,  \
                                 HWIO_FMSK(OEM_CONFIG1, DAP_DBGEN_DISABLE))) 
                                 
/* QC fuse disables the Disables the DAP invasive debug capabilities.*/
#define DAP_FUSE5_DISABLE  (HWIO_INM(FEATURE_CONFIG2,  \
                                 HWIO_FMSK(FEATURE_CONFIG2, QC_DAP_DBGEN_DISABLE)))                                  
                             
                                 
/*Macro to check if any RPM jtag debug feature is disabled
  return 1 if any RPM jtag debug is disabled.
  return 0 if it is enabled
*/
#define DEBUG_DISABLED_RPM (FUSE0_DISABLE| \
                            FUSE1_DISABLE| \
                            FUSE2_DISABLE)

/*Macro to check if any apps jtag debug feature is disabled
  return 1 if any apps jtag debug is disabled.
  return 0 if it is enabled*/
#define DEBUG_DISABLED_APPS (FUSE0_DISABLE|  \
                             FUSE3_DISABLE|  \
                             FUSE4_DISABLE|  \
                             FUSE5_DISABLE|  \
                             FUSE6_DISABLE)
                             
/* Macro to check if wdog debug image disable fuses are blown 
   return 1 if any one is blown thus disable wdog debug image loading
   return 0 if none is blown thus enable wdog debug image loading */                            
#define DEBUG_DISABLE_WDT  (DAP_FUSE0_DISABLE | \
                            DAP_FUSE1_DISABLE | \
                            DAP_FUSE2_DISABLE | \
                            DAP_FUSE3_DISABLE | \
                            DAP_FUSE4_DISABLE | \
                            DAP_FUSE5_DISABLE)

/*===========================================================================
                      QFPROM DRIVER DEFINES
===========================================================================*/ 
/* Mark QFPROM region as read only: 24KB from SECURITY_CONTROL_BASE */
#define QFPROM_READONLY_BLOCK_SIZE 0x6000


/* SFPB clock defines for Qfprom Driver in khz.
   Clock runs at 64Mhz in sbl3 for 8960. This clock is used
   in Qfprom driver to compute correct timer value.
*/
#define BOOT_QFPROM_SFPB_CLOCK  (0x40 * 1000)


/* EEPROM' DAL device ID */                             
#define EEPROM_DEVICE_ID DALDEVICEID_FLASH_DEVICE_2

/* SECONDARY EEPROM DAL device ID */                             
#define EEPROM_DEVICE_ID_SECONDARY DALDEVICEID_FLASH_DEVICE_3

#if (defined(BOOT_PRE_SILICON))
/* eeprom CDT read is still not functional/verified on presilicon */
#define CDT_BL_ERROR(BL_ERR_CODE) \
        break;
#else
/* Macro for EEPROM CDT parsing error action, in this target we go to error handler*/
#define CDT_BL_ERROR(BL_ERR_CODE) \
        BL_VERIFY( FALSE, BL_ERR_CODE );
#endif

/* In RPM elf image the entry point is in RPM address space so 
  offset is set to 0 */
#define APPS_RPM_ADDR_VIEW_OFFSET 0x0

/* Disable D cache */
#define SBL1_DISABLE_D_CACHE

/* Define the SD Ram Dump Indicator LED */
#define RAM_DUMP_LED  PM_RGB_SEGMENT_B

/* Use APPSBL region in DDR for storing temp data read from QPIC for RPM image loading */
#define BOOT_TEMP_BASE  SCL_APPSBL_CODE_BASE

/* Use SMC call to TZ */
#define SMC_SUPPORTED

/*===========================================================================
                      L2CC DEFINES
===========================================================================*/
/*
 * Initial value for L2 cache controller.
 *
 * Corresponds to:
 *   0:2   --(010b) 3 cycles of latency for data ram reads.
 *   3:5   --(010b) 3 cycles of latency for data ram writes.
 *   6:8   --(000b) 1 cycle of latency for TAG ram.
 *   9:11  --(000b) 1 cycle of latency for dirty ram.
 *   12    --(0b) master port can perform wrap access.
 *   13:16 --(0100b) 4 way associativity.
 *   17:19 --(011b) 64Kb way size.
 *
 * Corresponds to:
 *   30    --(0b) Early BRESP disable
 *   29    --(0b) Instruction prefetch disable
 *   28    --(0b) Data prefetch disable
 *   27    --(0b) Non-secure interrupt access control disable
 *   26    --(0b) Non-secure lockdown disable
 *   25    --(1b) Round-robin cache replacement policy
 *   24-23 --(00b) Use AWCACHE attributs for Write-Allocate
 *   22    --(0b) Shared attribute override disable
 *   21    --(0b) Parity disable
 *   20    --(0b) Event monitor bus disable
 *   19-17 --(001b) 16KB way size
 *   16    --(0b) 8-way associativity
 *   13    --(0b) Shared attribute invalidate disable
 *   12    --(0b) Exclusive cache configuration disable
 *   11    --(0b) Store buffer device limitation disable
 *   10    --(0b) High priority for SO and Dev Reads disable
 *   0     --(0b) Full line of write zero behaviour disable
 */
 /* 32K/8way/Event monitor enable/Ignore Shared attr */
#define L2CC_AUX_CONTROL_INIT_VALUE 0x00540000 

/*
 * Initial value for Tag RAM latency control registers
 *
 * Corresponds to:
 *   2-0   --(000b) RAM setup latency; 1 cycle
 *   6-4   --(000b) RAM read access latency; 1 cycle
 *   10-8  --(000b) RAM write access latency; 1 cycle
 */
#define L2CC_TAG_RAM_CONTROL_INIT_VALUE 0x00000000

/*
 * Initial value for Data RAM latency control registers
 *
 * Corresponds to:
 *   2-0   --(011b) RAM setup latency; 3 cycle
 *   6-4   --(011b) RAM read access latency; 3 cycle
 *   10-8  --(011b) RAM write access latency; 3 cycle
 */
#define L2CC_DATA_RAM_CONTROL_INIT_VALUE 0x220

/* Cache line size. */
#define L2CC_LINE_SIZE (1UL << 5UL)

/* L2 Cache addresses */
#define L2CC_HARDWARE_WORD(offset) (*(volatile uint32 *)(CA5_L2CC_REG_BASE + (offset)))
#define L2CC_CACHE_ID         L2CC_HARDWARE_WORD(0x000)
#define L2CC_CACHE_TYPE       L2CC_HARDWARE_WORD(0x004)
#define L2CC_CONTROL          L2CC_HARDWARE_WORD(0x100)
#define L2CC_AUX_CONTROL      L2CC_HARDWARE_WORD(0x104)
#define L2CC_TAG_RAM_CONTROL  L2CC_HARDWARE_WORD(0x108)
#define L2CC_DATA_RAM_CONTROL L2CC_HARDWARE_WORD(0x10C)
#define L2CC_IVLD_BY_PA       L2CC_HARDWARE_WORD(0x770)
#define L2CC_IVLD_BY_WAY      L2CC_HARDWARE_WORD(0x77C)
#define L2CC_CLN_BY_PA        L2CC_HARDWARE_WORD(0x7B0)
#define L2CC_CLN_BY_WAY       L2CC_HARDWARE_WORD(0x7BC)
#define L2CC_IVLD_CLN_BY_PA   L2CC_HARDWARE_WORD(0x7F0)
#define L2CC_IVLD_CLN_BY_WAY  L2CC_HARDWARE_WORD(0x7FC)

#endif  /* _BOOT_TARGET_H */
